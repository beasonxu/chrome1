// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: components/autofill_assistant/browser/service.proto

#include "components/autofill_assistant/browser/service.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace autofill_assistant {
PROTOBUF_CONSTEXPR FieldTrialProto::FieldTrialProto(
    ::_pbi::ConstantInitialized)
  : trial_name_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , group_name_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}){}
struct FieldTrialProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FieldTrialProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FieldTrialProtoDefaultTypeInternal() {}
  union {
    FieldTrialProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FieldTrialProtoDefaultTypeInternal _FieldTrialProto_default_instance_;
PROTOBUF_CONSTEXPR ClientContextProto_Chrome::ClientContextProto_Chrome(
    ::_pbi::ConstantInitialized)
  : active_field_trials_()
  , chrome_version_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}){}
struct ClientContextProto_ChromeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ClientContextProto_ChromeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ClientContextProto_ChromeDefaultTypeInternal() {}
  union {
    ClientContextProto_Chrome _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClientContextProto_ChromeDefaultTypeInternal _ClientContextProto_Chrome_default_instance_;
PROTOBUF_CONSTEXPR ClientContextProto_DeviceContextProto_VersionProto::ClientContextProto_DeviceContextProto_VersionProto(
    ::_pbi::ConstantInitialized)
  : sdk_int_(0){}
struct ClientContextProto_DeviceContextProto_VersionProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ClientContextProto_DeviceContextProto_VersionProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ClientContextProto_DeviceContextProto_VersionProtoDefaultTypeInternal() {}
  union {
    ClientContextProto_DeviceContextProto_VersionProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClientContextProto_DeviceContextProto_VersionProtoDefaultTypeInternal _ClientContextProto_DeviceContextProto_VersionProto_default_instance_;
PROTOBUF_CONSTEXPR ClientContextProto_DeviceContextProto::ClientContextProto_DeviceContextProto(
    ::_pbi::ConstantInitialized)
  : manufacturer_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , model_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , version_(nullptr){}
struct ClientContextProto_DeviceContextProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ClientContextProto_DeviceContextProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ClientContextProto_DeviceContextProtoDefaultTypeInternal() {}
  union {
    ClientContextProto_DeviceContextProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClientContextProto_DeviceContextProtoDefaultTypeInternal _ClientContextProto_DeviceContextProto_default_instance_;
PROTOBUF_CONSTEXPR ClientContextProto_WindowSize::ClientContextProto_WindowSize(
    ::_pbi::ConstantInitialized)
  : height_pixels_(0)
  , width_pixels_(0){}
struct ClientContextProto_WindowSizeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ClientContextProto_WindowSizeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ClientContextProto_WindowSizeDefaultTypeInternal() {}
  union {
    ClientContextProto_WindowSize _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClientContextProto_WindowSizeDefaultTypeInternal _ClientContextProto_WindowSize_default_instance_;
PROTOBUF_CONSTEXPR ClientContextProto_AnnotateDomModelContextProto::ClientContextProto_AnnotateDomModelContextProto(
    ::_pbi::ConstantInitialized)
  : model_version_(int64_t{0})
  , force_semantic_selection_(false){}
struct ClientContextProto_AnnotateDomModelContextProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ClientContextProto_AnnotateDomModelContextProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ClientContextProto_AnnotateDomModelContextProtoDefaultTypeInternal() {}
  union {
    ClientContextProto_AnnotateDomModelContextProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClientContextProto_AnnotateDomModelContextProtoDefaultTypeInternal _ClientContextProto_AnnotateDomModelContextProto_default_instance_;
PROTOBUF_CONSTEXPR ClientContextProto::ClientContextProto(
    ::_pbi::ConstantInitialized)
  : locale_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , country_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , experiment_ids_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , device_context_(nullptr)
  , window_size_(nullptr)
  , annotate_dom_model_context_(nullptr)
  , is_cct_(false)
  , is_onboarding_shown_(false)
  , is_direct_action_(false)
  , is_in_chrome_triggered_(false)
  , accounts_matching_status_(0)

  , signed_into_chrome_status_(0)

  , screen_orientation_(0)

  , trigger_ui_type_(0)

  , accessibility_enabled_(false)
  , js_flow_library_loaded_(false)
  , platform_type_(0)

  , _oneof_case_{}{}
struct ClientContextProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ClientContextProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ClientContextProtoDefaultTypeInternal() {}
  union {
    ClientContextProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClientContextProtoDefaultTypeInternal _ClientContextProto_default_instance_;
PROTOBUF_CONSTEXPR SupportsScriptRequestProto::SupportsScriptRequestProto(
    ::_pbi::ConstantInitialized)
  : script_parameters_()
  , url_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , client_context_(nullptr){}
struct SupportsScriptRequestProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SupportsScriptRequestProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SupportsScriptRequestProtoDefaultTypeInternal() {}
  union {
    SupportsScriptRequestProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SupportsScriptRequestProtoDefaultTypeInternal _SupportsScriptRequestProto_default_instance_;
PROTOBUF_CONSTEXPR ImplicitTriggeringDebugParametersProto::ImplicitTriggeringDebugParametersProto(
    ::_pbi::ConstantInitialized)
  : additional_script_parameters_(){}
struct ImplicitTriggeringDebugParametersProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ImplicitTriggeringDebugParametersProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ImplicitTriggeringDebugParametersProtoDefaultTypeInternal() {}
  union {
    ImplicitTriggeringDebugParametersProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ImplicitTriggeringDebugParametersProtoDefaultTypeInternal _ImplicitTriggeringDebugParametersProto_default_instance_;
PROTOBUF_CONSTEXPR ScriptParameterProto::ScriptParameterProto(
    ::_pbi::ConstantInitialized)
  : value_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , name_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}){}
struct ScriptParameterProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ScriptParameterProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ScriptParameterProtoDefaultTypeInternal() {}
  union {
    ScriptParameterProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ScriptParameterProtoDefaultTypeInternal _ScriptParameterProto_default_instance_;
PROTOBUF_CONSTEXPR SupportsScriptResponseProto::SupportsScriptResponseProto(
    ::_pbi::ConstantInitialized)
  : scripts_()
  , script_timeout_error_(nullptr)
  , client_settings_(nullptr)
  , script_store_config_(nullptr)
  , semantic_selector_policy_(nullptr){}
struct SupportsScriptResponseProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SupportsScriptResponseProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SupportsScriptResponseProtoDefaultTypeInternal() {}
  union {
    SupportsScriptResponseProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SupportsScriptResponseProtoDefaultTypeInternal _SupportsScriptResponseProto_default_instance_;
PROTOBUF_CONSTEXPR GetCapabilitiesByHashPrefixRequestProto::GetCapabilitiesByHashPrefixRequestProto(
    ::_pbi::ConstantInitialized)
  : hash_prefix_()
  , _hash_prefix_cached_byte_size_(0)
  , script_parameters_()
  , client_context_(nullptr)
  , hash_prefix_length_(0u){}
struct GetCapabilitiesByHashPrefixRequestProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GetCapabilitiesByHashPrefixRequestProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GetCapabilitiesByHashPrefixRequestProtoDefaultTypeInternal() {}
  union {
    GetCapabilitiesByHashPrefixRequestProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GetCapabilitiesByHashPrefixRequestProtoDefaultTypeInternal _GetCapabilitiesByHashPrefixRequestProto_default_instance_;
PROTOBUF_CONSTEXPR GetCapabilitiesByHashPrefixResponseProto_MatchInfoProto::GetCapabilitiesByHashPrefixResponseProto_MatchInfoProto(
    ::_pbi::ConstantInitialized)
  : script_parameters_override_()
  , url_match_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}){}
struct GetCapabilitiesByHashPrefixResponseProto_MatchInfoProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GetCapabilitiesByHashPrefixResponseProto_MatchInfoProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GetCapabilitiesByHashPrefixResponseProto_MatchInfoProtoDefaultTypeInternal() {}
  union {
    GetCapabilitiesByHashPrefixResponseProto_MatchInfoProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GetCapabilitiesByHashPrefixResponseProto_MatchInfoProtoDefaultTypeInternal _GetCapabilitiesByHashPrefixResponseProto_MatchInfoProto_default_instance_;
PROTOBUF_CONSTEXPR GetCapabilitiesByHashPrefixResponseProto::GetCapabilitiesByHashPrefixResponseProto(
    ::_pbi::ConstantInitialized)
  : match_info_(){}
struct GetCapabilitiesByHashPrefixResponseProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GetCapabilitiesByHashPrefixResponseProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GetCapabilitiesByHashPrefixResponseProtoDefaultTypeInternal() {}
  union {
    GetCapabilitiesByHashPrefixResponseProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GetCapabilitiesByHashPrefixResponseProtoDefaultTypeInternal _GetCapabilitiesByHashPrefixResponseProto_default_instance_;
PROTOBUF_CONSTEXPR GetUserDataRequestProto_PaymentMethodRequest::GetUserDataRequestProto_PaymentMethodRequest(
    ::_pbi::ConstantInitialized)
  : supported_card_networks_()
  , preexisting_ids_()
  , client_token_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}){}
struct GetUserDataRequestProto_PaymentMethodRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GetUserDataRequestProto_PaymentMethodRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GetUserDataRequestProto_PaymentMethodRequestDefaultTypeInternal() {}
  union {
    GetUserDataRequestProto_PaymentMethodRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GetUserDataRequestProto_PaymentMethodRequestDefaultTypeInternal _GetUserDataRequestProto_PaymentMethodRequest_default_instance_;
PROTOBUF_CONSTEXPR GetUserDataRequestProto_AddressRequest::GetUserDataRequestProto_AddressRequest(
    ::_pbi::ConstantInitialized)
  : preexisting_ids_(){}
struct GetUserDataRequestProto_AddressRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GetUserDataRequestProto_AddressRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GetUserDataRequestProto_AddressRequestDefaultTypeInternal() {}
  union {
    GetUserDataRequestProto_AddressRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GetUserDataRequestProto_AddressRequestDefaultTypeInternal _GetUserDataRequestProto_AddressRequest_default_instance_;
PROTOBUF_CONSTEXPR GetUserDataRequestProto::GetUserDataRequestProto(
    ::_pbi::ConstantInitialized)
  : request_payment_methods_(nullptr)
  , request_shipping_addresses_(nullptr)
  , run_id_(uint64_t{0u})
  , request_name_(false)
  , request_email_(false)
  , request_phone_(false){}
struct GetUserDataRequestProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GetUserDataRequestProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GetUserDataRequestProtoDefaultTypeInternal() {}
  union {
    GetUserDataRequestProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GetUserDataRequestProtoDefaultTypeInternal _GetUserDataRequestProto_default_instance_;
PROTOBUF_CONSTEXPR GetUserDataResponseProto::GetUserDataResponseProto(
    ::_pbi::ConstantInitialized)
  : available_contacts_()
  , available_payment_instruments_()
  , available_addresses_()
  , available_phone_numbers_()
  , locale_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , selected_contact_identifier_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , selected_shipping_address_identifier_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , selected_payment_instrument_identifier_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , add_address_token_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , add_payment_instrument_token_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , selected_phone_number_identifier_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}){}
struct GetUserDataResponseProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GetUserDataResponseProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GetUserDataResponseProtoDefaultTypeInternal() {}
  union {
    GetUserDataResponseProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GetUserDataResponseProtoDefaultTypeInternal _GetUserDataResponseProto_default_instance_;
PROTOBUF_CONSTEXPR OverlayImageProto::OverlayImageProto(
    ::_pbi::ConstantInitialized)
  : text_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , text_color_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , image_size_(nullptr)
  , image_top_margin_(nullptr)
  , image_bottom_margin_(nullptr)
  , text_size_(nullptr)
  , _oneof_case_{}{}
struct OverlayImageProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR OverlayImageProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~OverlayImageProtoDefaultTypeInternal() {}
  union {
    OverlayImageProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 OverlayImageProtoDefaultTypeInternal _OverlayImageProto_default_instance_;
PROTOBUF_CONSTEXPR ClientSettingsProto_IntegrationTestSettings::ClientSettingsProto_IntegrationTestSettings(
    ::_pbi::ConstantInitialized)
  : disable_header_animations_(false)
  , disable_carousel_change_animations_(false){}
struct ClientSettingsProto_IntegrationTestSettingsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ClientSettingsProto_IntegrationTestSettingsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ClientSettingsProto_IntegrationTestSettingsDefaultTypeInternal() {}
  union {
    ClientSettingsProto_IntegrationTestSettings _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClientSettingsProto_IntegrationTestSettingsDefaultTypeInternal _ClientSettingsProto_IntegrationTestSettings_default_instance_;
PROTOBUF_CONSTEXPR ClientSettingsProto_BackButtonSettings::ClientSettingsProto_BackButtonSettings(
    ::_pbi::ConstantInitialized)
  : undo_label_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}){}
struct ClientSettingsProto_BackButtonSettingsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ClientSettingsProto_BackButtonSettingsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ClientSettingsProto_BackButtonSettingsDefaultTypeInternal() {}
  union {
    ClientSettingsProto_BackButtonSettings _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClientSettingsProto_BackButtonSettingsDefaultTypeInternal _ClientSettingsProto_BackButtonSettings_default_instance_;
PROTOBUF_CONSTEXPR ClientSettingsProto_SlowWarningSettings::ClientSettingsProto_SlowWarningSettings(
    ::_pbi::ConstantInitialized)
  : slow_connection_message_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , slow_website_message_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , enable_slow_connection_warnings_(false)
  , enable_slow_website_warnings_(false)
  , only_show_warning_once_(false)
  , only_show_connection_warning_once_(false)
  , only_show_website_warning_once_(false)
  , warning_delay_ms_(0)
  , slow_roundtrip_threshold_ms_(0)
  , max_consecutive_slow_roundtrips_(0)
  , minimum_warning_message_duration_ms_(0)
  , message_mode_(0)
{}
struct ClientSettingsProto_SlowWarningSettingsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ClientSettingsProto_SlowWarningSettingsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ClientSettingsProto_SlowWarningSettingsDefaultTypeInternal() {}
  union {
    ClientSettingsProto_SlowWarningSettings _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClientSettingsProto_SlowWarningSettingsDefaultTypeInternal _ClientSettingsProto_SlowWarningSettings_default_instance_;
PROTOBUF_CONSTEXPR ClientSettingsProto_DisplayString::ClientSettingsProto_DisplayString(
    ::_pbi::ConstantInitialized)
  : value_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , id_(0)
{}
struct ClientSettingsProto_DisplayStringDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ClientSettingsProto_DisplayStringDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ClientSettingsProto_DisplayStringDefaultTypeInternal() {}
  union {
    ClientSettingsProto_DisplayString _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClientSettingsProto_DisplayStringDefaultTypeInternal _ClientSettingsProto_DisplayString_default_instance_;
PROTOBUF_CONSTEXPR ClientSettingsProto::ClientSettingsProto(
    ::_pbi::ConstantInitialized)
  : display_strings_()
  , display_strings_locale_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , overlay_image_(nullptr)
  , integration_test_settings_(nullptr)
  , back_button_settings_(nullptr)
  , slow_warning_settings_(nullptr)
  , periodic_script_check_interval_ms_(0)
  , periodic_element_check_interval_ms_(0)
  , periodic_script_check_count_(0)
  , element_position_update_interval_ms_(0)
  , short_wait_for_element_deadline_ms_(0)
  , box_model_check_interval_ms_(0)
  , box_model_check_count_(0)
  , cancel_delay_ms_(0)
  , tap_count_(0)
  , tap_tracking_duration_ms_(0)
  , tap_shutdown_delay_ms_(0)
  , talkback_sheet_size_fraction_(0)
  , document_ready_check_timeout_ms_(0)
  , selector_observer_extra_timeout_ms_(0)
  , selector_observer_debounce_interval_ms_(0){}
struct ClientSettingsProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ClientSettingsProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ClientSettingsProtoDefaultTypeInternal() {}
  union {
    ClientSettingsProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClientSettingsProtoDefaultTypeInternal _ClientSettingsProto_default_instance_;
PROTOBUF_CONSTEXPR ScriptTimeoutError::ScriptTimeoutError(
    ::_pbi::ConstantInitialized)
  : script_path_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , timeout_ms_(0){}
struct ScriptTimeoutErrorDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ScriptTimeoutErrorDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ScriptTimeoutErrorDefaultTypeInternal() {}
  union {
    ScriptTimeoutError _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ScriptTimeoutErrorDefaultTypeInternal _ScriptTimeoutError_default_instance_;
PROTOBUF_CONSTEXPR SupportedScriptProto_PresentationProto::SupportedScriptProto_PresentationProto(
    ::_pbi::ConstantInitialized)
  : start_message_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , precondition_(nullptr)
  , direct_action_(nullptr)
  , priority_(0)
  , autostart_(false)
  , interrupt_(false)
  , needs_ui_(true){}
struct SupportedScriptProto_PresentationProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SupportedScriptProto_PresentationProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SupportedScriptProto_PresentationProtoDefaultTypeInternal() {}
  union {
    SupportedScriptProto_PresentationProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SupportedScriptProto_PresentationProtoDefaultTypeInternal _SupportedScriptProto_PresentationProto_default_instance_;
PROTOBUF_CONSTEXPR SupportedScriptProto::SupportedScriptProto(
    ::_pbi::ConstantInitialized)
  : path_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , presentation_(nullptr){}
struct SupportedScriptProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SupportedScriptProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SupportedScriptProtoDefaultTypeInternal() {}
  union {
    SupportedScriptProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SupportedScriptProtoDefaultTypeInternal _SupportedScriptProto_default_instance_;
PROTOBUF_CONSTEXPR ScriptPreconditionProto::ScriptPreconditionProto(
    ::_pbi::ConstantInitialized)
  : path_pattern_()
  , domain_()
  , script_parameter_match_()
  , element_condition_(nullptr){}
struct ScriptPreconditionProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ScriptPreconditionProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ScriptPreconditionProtoDefaultTypeInternal() {}
  union {
    ScriptPreconditionProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ScriptPreconditionProtoDefaultTypeInternal _ScriptPreconditionProto_default_instance_;
PROTOBUF_CONSTEXPR ScriptParameterMatchProto::ScriptParameterMatchProto(
    ::_pbi::ConstantInitialized)
  : value_equals_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , name_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , exists_(true){}
struct ScriptParameterMatchProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ScriptParameterMatchProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ScriptParameterMatchProtoDefaultTypeInternal() {}
  union {
    ScriptParameterMatchProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ScriptParameterMatchProtoDefaultTypeInternal _ScriptParameterMatchProto_default_instance_;
PROTOBUF_CONSTEXPR CUPRequestData::CUPRequestData(
    ::_pbi::ConstantInitialized)
  : request_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , query_cup2key_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , hash_hex_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}){}
struct CUPRequestDataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CUPRequestDataDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CUPRequestDataDefaultTypeInternal() {}
  union {
    CUPRequestData _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CUPRequestDataDefaultTypeInternal _CUPRequestData_default_instance_;
PROTOBUF_CONSTEXPR ScriptActionRequestProto::ScriptActionRequestProto(
    ::_pbi::ConstantInitialized)
  : script_payload_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , global_payload_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , client_context_(nullptr)
  , cup_data_(nullptr)
  , _oneof_case_{}{}
struct ScriptActionRequestProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ScriptActionRequestProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ScriptActionRequestProtoDefaultTypeInternal() {}
  union {
    ScriptActionRequestProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ScriptActionRequestProtoDefaultTypeInternal _ScriptActionRequestProto_default_instance_;
PROTOBUF_CONSTEXPR ScriptStoreConfig::ScriptStoreConfig(
    ::_pbi::ConstantInitialized)
  : bundle_path_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , bundle_version_(int64_t{0}){}
struct ScriptStoreConfigDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ScriptStoreConfigDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ScriptStoreConfigDefaultTypeInternal() {}
  union {
    ScriptStoreConfig _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ScriptStoreConfigDefaultTypeInternal _ScriptStoreConfig_default_instance_;
PROTOBUF_CONSTEXPR InitialScriptActionsRequestProto_QueryProto::InitialScriptActionsRequestProto_QueryProto(
    ::_pbi::ConstantInitialized)
  : script_path_()
  , url_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , policy_(0)
{}
struct InitialScriptActionsRequestProto_QueryProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR InitialScriptActionsRequestProto_QueryProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~InitialScriptActionsRequestProto_QueryProtoDefaultTypeInternal() {}
  union {
    InitialScriptActionsRequestProto_QueryProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 InitialScriptActionsRequestProto_QueryProtoDefaultTypeInternal _InitialScriptActionsRequestProto_QueryProto_default_instance_;
PROTOBUF_CONSTEXPR InitialScriptActionsRequestProto::InitialScriptActionsRequestProto(
    ::_pbi::ConstantInitialized)
  : script_parameters_()
  , query_(nullptr)
  , script_store_config_(nullptr){}
struct InitialScriptActionsRequestProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR InitialScriptActionsRequestProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~InitialScriptActionsRequestProtoDefaultTypeInternal() {}
  union {
    InitialScriptActionsRequestProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 InitialScriptActionsRequestProtoDefaultTypeInternal _InitialScriptActionsRequestProto_default_instance_;
PROTOBUF_CONSTEXPR RoundtripTimingStats::RoundtripTimingStats(
    ::_pbi::ConstantInitialized)
  : roundtrip_time_ms_(int64_t{0})
  , client_time_ms_(int64_t{0}){}
struct RoundtripTimingStatsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RoundtripTimingStatsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RoundtripTimingStatsDefaultTypeInternal() {}
  union {
    RoundtripTimingStats _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RoundtripTimingStatsDefaultTypeInternal _RoundtripTimingStats_default_instance_;
PROTOBUF_CONSTEXPR RoundtripNetworkStats_ActionNetworkStats::RoundtripNetworkStats_ActionNetworkStats(
    ::_pbi::ConstantInitialized)
  : decoded_size_bytes_(int64_t{0})
  , action_info_case_(0){}
struct RoundtripNetworkStats_ActionNetworkStatsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RoundtripNetworkStats_ActionNetworkStatsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RoundtripNetworkStats_ActionNetworkStatsDefaultTypeInternal() {}
  union {
    RoundtripNetworkStats_ActionNetworkStats _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RoundtripNetworkStats_ActionNetworkStatsDefaultTypeInternal _RoundtripNetworkStats_ActionNetworkStats_default_instance_;
PROTOBUF_CONSTEXPR RoundtripNetworkStats::RoundtripNetworkStats(
    ::_pbi::ConstantInitialized)
  : action_stats_()
  , roundtrip_encoded_body_size_bytes_(int64_t{0})
  , roundtrip_decoded_body_size_bytes_(int64_t{0})
  , num_roundtrips_(0){}
struct RoundtripNetworkStatsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RoundtripNetworkStatsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RoundtripNetworkStatsDefaultTypeInternal() {}
  union {
    RoundtripNetworkStats _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RoundtripNetworkStatsDefaultTypeInternal _RoundtripNetworkStats_default_instance_;
PROTOBUF_CONSTEXPR NextScriptActionsRequestProto::NextScriptActionsRequestProto(
    ::_pbi::ConstantInitialized)
  : processed_actions_()
  , timing_stats_(nullptr)
  , network_stats_(nullptr)
  , slow_connection_warning_(0)
{}
struct NextScriptActionsRequestProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NextScriptActionsRequestProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NextScriptActionsRequestProtoDefaultTypeInternal() {}
  union {
    NextScriptActionsRequestProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NextScriptActionsRequestProtoDefaultTypeInternal _NextScriptActionsRequestProto_default_instance_;
PROTOBUF_CONSTEXPR CUPResponseData::CUPResponseData(
    ::_pbi::ConstantInitialized)
  : response_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , ecdsa_signature_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}){}
struct CUPResponseDataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CUPResponseDataDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CUPResponseDataDefaultTypeInternal() {}
  union {
    CUPResponseData _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CUPResponseDataDefaultTypeInternal _CUPResponseData_default_instance_;
PROTOBUF_CONSTEXPR ActionsResponseProto_UpdateScriptListProto::ActionsResponseProto_UpdateScriptListProto(
    ::_pbi::ConstantInitialized)
  : scripts_(){}
struct ActionsResponseProto_UpdateScriptListProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ActionsResponseProto_UpdateScriptListProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ActionsResponseProto_UpdateScriptListProtoDefaultTypeInternal() {}
  union {
    ActionsResponseProto_UpdateScriptListProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ActionsResponseProto_UpdateScriptListProtoDefaultTypeInternal _ActionsResponseProto_UpdateScriptListProto_default_instance_;
PROTOBUF_CONSTEXPR ActionsResponseProto::ActionsResponseProto(
    ::_pbi::ConstantInitialized)
  : actions_()
  , script_payload_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , global_payload_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , js_flow_library_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , report_token_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , update_script_list_(nullptr)
  , cup_data_(nullptr)
  , run_id_(uint64_t{0u}){}
struct ActionsResponseProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ActionsResponseProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ActionsResponseProtoDefaultTypeInternal() {}
  union {
    ActionsResponseProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ActionsResponseProtoDefaultTypeInternal _ActionsResponseProto_default_instance_;
PROTOBUF_CONSTEXPR GetTriggerScriptsRequestProto::GetTriggerScriptsRequestProto(
    ::_pbi::ConstantInitialized)
  : script_parameters_()
  , url_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , client_context_(nullptr){}
struct GetTriggerScriptsRequestProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GetTriggerScriptsRequestProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GetTriggerScriptsRequestProtoDefaultTypeInternal() {}
  union {
    GetTriggerScriptsRequestProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GetTriggerScriptsRequestProtoDefaultTypeInternal _GetTriggerScriptsRequestProto_default_instance_;
PROTOBUF_CONSTEXPR GetTriggerScriptsResponseProto::GetTriggerScriptsResponseProto(
    ::_pbi::ConstantInitialized)
  : trigger_scripts_()
  , additional_allowed_domains_()
  , script_parameters_()
  , trigger_condition_timeout_ms_(0)
  , trigger_condition_check_interval_ms_(1000){}
struct GetTriggerScriptsResponseProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GetTriggerScriptsResponseProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GetTriggerScriptsResponseProtoDefaultTypeInternal() {}
  union {
    GetTriggerScriptsResponseProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GetTriggerScriptsResponseProtoDefaultTypeInternal _GetTriggerScriptsResponseProto_default_instance_;
PROTOBUF_CONSTEXPR TriggerScriptProto::TriggerScriptProto(
    ::_pbi::ConstantInitialized)
  : trigger_condition_(nullptr)
  , user_interface_(nullptr)
  , trigger_ui_type_(0)

  , on_swipe_to_dismiss_(2)
{}
struct TriggerScriptProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TriggerScriptProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TriggerScriptProtoDefaultTypeInternal() {}
  union {
    TriggerScriptProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TriggerScriptProtoDefaultTypeInternal _TriggerScriptProto_default_instance_;
PROTOBUF_CONSTEXPR TriggerScriptConditionProto_DocumentReadyStateCondition::TriggerScriptConditionProto_DocumentReadyStateCondition(
    ::_pbi::ConstantInitialized)
  : frame_(nullptr)
  , min_document_ready_state_(0)
{}
struct TriggerScriptConditionProto_DocumentReadyStateConditionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TriggerScriptConditionProto_DocumentReadyStateConditionDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TriggerScriptConditionProto_DocumentReadyStateConditionDefaultTypeInternal() {}
  union {
    TriggerScriptConditionProto_DocumentReadyStateCondition _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TriggerScriptConditionProto_DocumentReadyStateConditionDefaultTypeInternal _TriggerScriptConditionProto_DocumentReadyStateCondition_default_instance_;
PROTOBUF_CONSTEXPR TriggerScriptConditionProto::TriggerScriptConditionProto(
    ::_pbi::ConstantInitialized)
  : _oneof_case_{}{}
struct TriggerScriptConditionProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TriggerScriptConditionProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TriggerScriptConditionProtoDefaultTypeInternal() {}
  union {
    TriggerScriptConditionProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TriggerScriptConditionProtoDefaultTypeInternal _TriggerScriptConditionProto_default_instance_;
PROTOBUF_CONSTEXPR TriggerScriptConditionsProto::TriggerScriptConditionsProto(
    ::_pbi::ConstantInitialized)
  : conditions_(){}
struct TriggerScriptConditionsProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TriggerScriptConditionsProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TriggerScriptConditionsProtoDefaultTypeInternal() {}
  union {
    TriggerScriptConditionsProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TriggerScriptConditionsProtoDefaultTypeInternal _TriggerScriptConditionsProto_default_instance_;
PROTOBUF_CONSTEXPR TriggerScriptUIProto_ProgressBar::TriggerScriptUIProto_ProgressBar(
    ::_pbi::ConstantInitialized)
  : step_icons_()
  , active_step_(0){}
struct TriggerScriptUIProto_ProgressBarDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TriggerScriptUIProto_ProgressBarDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TriggerScriptUIProto_ProgressBarDefaultTypeInternal() {}
  union {
    TriggerScriptUIProto_ProgressBar _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TriggerScriptUIProto_ProgressBarDefaultTypeInternal _TriggerScriptUIProto_ProgressBar_default_instance_;
PROTOBUF_CONSTEXPR TriggerScriptUIProto_TriggerChip::TriggerScriptUIProto_TriggerChip(
    ::_pbi::ConstantInitialized)
  : chip_(nullptr)
  , action_(0)
{}
struct TriggerScriptUIProto_TriggerChipDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TriggerScriptUIProto_TriggerChipDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TriggerScriptUIProto_TriggerChipDefaultTypeInternal() {}
  union {
    TriggerScriptUIProto_TriggerChip _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TriggerScriptUIProto_TriggerChipDefaultTypeInternal _TriggerScriptUIProto_TriggerChip_default_instance_;
PROTOBUF_CONSTEXPR TriggerScriptUIProto_Popup_Choice::TriggerScriptUIProto_Popup_Choice(
    ::_pbi::ConstantInitialized)
  : text_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , action_(0)
{}
struct TriggerScriptUIProto_Popup_ChoiceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TriggerScriptUIProto_Popup_ChoiceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TriggerScriptUIProto_Popup_ChoiceDefaultTypeInternal() {}
  union {
    TriggerScriptUIProto_Popup_Choice _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TriggerScriptUIProto_Popup_ChoiceDefaultTypeInternal _TriggerScriptUIProto_Popup_Choice_default_instance_;
PROTOBUF_CONSTEXPR TriggerScriptUIProto_Popup::TriggerScriptUIProto_Popup(
    ::_pbi::ConstantInitialized)
  : choices_(){}
struct TriggerScriptUIProto_PopupDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TriggerScriptUIProto_PopupDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TriggerScriptUIProto_PopupDefaultTypeInternal() {}
  union {
    TriggerScriptUIProto_Popup _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TriggerScriptUIProto_PopupDefaultTypeInternal _TriggerScriptUIProto_Popup_default_instance_;
PROTOBUF_CONSTEXPR TriggerScriptUIProto::TriggerScriptUIProto(
    ::_pbi::ConstantInitialized)
  : left_aligned_chips_()
  , right_aligned_chips_()
  , status_message_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , callout_message_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , regular_script_loading_status_message_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , progress_bar_(nullptr)
  , cancel_popup_(nullptr)
  , resize_visual_viewport_(false)
  , scroll_to_hide_(false)
  , ui_timeout_ms_(0){}
struct TriggerScriptUIProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TriggerScriptUIProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TriggerScriptUIProtoDefaultTypeInternal() {}
  union {
    TriggerScriptUIProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TriggerScriptUIProtoDefaultTypeInternal _TriggerScriptUIProto_default_instance_;
PROTOBUF_CONSTEXPR ActionProto::ActionProto(
    ::_pbi::ConstantInitialized)
  : server_payload_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , action_delay_ms_(0)
  , clean_contextual_ui_(false)
  , _oneof_case_{}{}
struct ActionProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ActionProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ActionProtoDefaultTypeInternal() {}
  union {
    ActionProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ActionProtoDefaultTypeInternal _ActionProto_default_instance_;
PROTOBUF_CONSTEXPR CollectUserDataResultProto::CollectUserDataResultProto(
    ::_pbi::ConstantInitialized)
  : set_text_input_memory_keys_()
  , additional_sections_values_()
  , card_issuer_network_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , payer_email_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , model_(nullptr)
  , additional_action_index_(0)
  , terms_link_(0)
  , is_terms_and_conditions_accepted_(false)
  , shown_to_user_(false)
  , login_missing_username_(false)
  , _oneof_case_{}{}
struct CollectUserDataResultProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CollectUserDataResultProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CollectUserDataResultProtoDefaultTypeInternal() {}
  union {
    CollectUserDataResultProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CollectUserDataResultProtoDefaultTypeInternal _CollectUserDataResultProto_default_instance_;
PROTOBUF_CONSTEXPR ActionTimingStats::ActionTimingStats(
    ::_pbi::ConstantInitialized)
  : delay_ms_(int64_t{0})
  , active_time_ms_(int64_t{0})
  , wait_time_ms_(int64_t{0}){}
struct ActionTimingStatsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ActionTimingStatsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ActionTimingStatsDefaultTypeInternal() {}
  union {
    ActionTimingStats _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ActionTimingStatsDefaultTypeInternal _ActionTimingStats_default_instance_;
PROTOBUF_CONSTEXPR ProcessedActionProto::ProcessedActionProto(
    ::_pbi::ConstantInitialized)
  : action_(nullptr)
  , status_details_(nullptr)
  , navigation_info_(nullptr)
  , timing_stats_(nullptr)
  , status_(0)

  , slow_warning_status_(0)

  , run_time_ms_(int64_t{0})
  , _oneof_case_{}{}
struct ProcessedActionProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ProcessedActionProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ProcessedActionProtoDefaultTypeInternal() {}
  union {
    ProcessedActionProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ProcessedActionProtoDefaultTypeInternal _ProcessedActionProto_default_instance_;
PROTOBUF_CONSTEXPR ProcessedActionStatusDetailsProto::ProcessedActionStatusDetailsProto(
    ::_pbi::ConstantInitialized)
  : element_finder_info_()
  , unexpected_error_info_(nullptr)
  , autofill_error_info_(nullptr)
  , web_controller_error_info_(nullptr)
  , original_status_(0)
{}
struct ProcessedActionStatusDetailsProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ProcessedActionStatusDetailsProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ProcessedActionStatusDetailsProtoDefaultTypeInternal() {}
  union {
    ProcessedActionStatusDetailsProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ProcessedActionStatusDetailsProtoDefaultTypeInternal _ProcessedActionStatusDetailsProto_default_instance_;
PROTOBUF_CONSTEXPR NavigationInfoProto::NavigationInfoProto(
    ::_pbi::ConstantInitialized)
  : started_(false)
  , ended_(false)
  , has_error_(false)
  , unexpected_(false){}
struct NavigationInfoProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NavigationInfoProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NavigationInfoProtoDefaultTypeInternal() {}
  union {
    NavigationInfoProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NavigationInfoProtoDefaultTypeInternal _NavigationInfoProto_default_instance_;
PROTOBUF_CONSTEXPR UnexpectedErrorInfoProto::UnexpectedErrorInfoProto(
    ::_pbi::ConstantInitialized)
  : js_exception_line_numbers_()
  , js_exception_column_numbers_()
  , js_exception_locations_()
  , _js_exception_locations_cached_byte_size_(0)
  , source_file_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , js_exception_classname_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , devtools_error_message_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , source_line_number_(0)
  , devtools_error_code_(0){}
struct UnexpectedErrorInfoProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UnexpectedErrorInfoProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~UnexpectedErrorInfoProtoDefaultTypeInternal() {}
  union {
    UnexpectedErrorInfoProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UnexpectedErrorInfoProtoDefaultTypeInternal _UnexpectedErrorInfoProto_default_instance_;
PROTOBUF_CONSTEXPR AutofillErrorInfoProto_AutofillFieldError::AutofillErrorInfoProto_AutofillFieldError(
    ::_pbi::ConstantInitialized)
  : value_expression_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , field_(nullptr)
  , _oneof_case_{}{}
struct AutofillErrorInfoProto_AutofillFieldErrorDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AutofillErrorInfoProto_AutofillFieldErrorDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AutofillErrorInfoProto_AutofillFieldErrorDefaultTypeInternal() {}
  union {
    AutofillErrorInfoProto_AutofillFieldError _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AutofillErrorInfoProto_AutofillFieldErrorDefaultTypeInternal _AutofillErrorInfoProto_AutofillFieldError_default_instance_;
PROTOBUF_CONSTEXPR AutofillErrorInfoProto::AutofillErrorInfoProto(
    ::_pbi::ConstantInitialized)
  : autofill_field_error_()
  , client_memory_address_key_names_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , address_key_requested_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , address_pointee_was_null_(false)
  , autofill_error_status_(0)

  , get_full_card_failure_type_(0)
{}
struct AutofillErrorInfoProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AutofillErrorInfoProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AutofillErrorInfoProtoDefaultTypeInternal() {}
  union {
    AutofillErrorInfoProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AutofillErrorInfoProtoDefaultTypeInternal _AutofillErrorInfoProto_default_instance_;
PROTOBUF_CONSTEXPR WebControllerErrorInfoProto::WebControllerErrorInfoProto(
    ::_pbi::ConstantInitialized)
  : failed_web_action_(0)
{}
struct WebControllerErrorInfoProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR WebControllerErrorInfoProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~WebControllerErrorInfoProtoDefaultTypeInternal() {}
  union {
    WebControllerErrorInfoProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 WebControllerErrorInfoProtoDefaultTypeInternal _WebControllerErrorInfoProto_default_instance_;
PROTOBUF_CONSTEXPR ElementFinderInfoProto_PredictedElement::ElementFinderInfoProto_PredictedElement(
    ::_pbi::ConstantInitialized)
  : semantic_filter_(nullptr)
  , backend_node_id_(0){}
struct ElementFinderInfoProto_PredictedElementDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ElementFinderInfoProto_PredictedElementDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ElementFinderInfoProto_PredictedElementDefaultTypeInternal() {}
  union {
    ElementFinderInfoProto_PredictedElement _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ElementFinderInfoProto_PredictedElementDefaultTypeInternal _ElementFinderInfoProto_PredictedElement_default_instance_;
PROTOBUF_CONSTEXPR ElementFinderInfoProto_SemanticInferenceResult::ElementFinderInfoProto_SemanticInferenceResult(
    ::_pbi::ConstantInitialized)
  : predicted_elements_()
  , status_per_frame_(){}
struct ElementFinderInfoProto_SemanticInferenceResultDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ElementFinderInfoProto_SemanticInferenceResultDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ElementFinderInfoProto_SemanticInferenceResultDefaultTypeInternal() {}
  union {
    ElementFinderInfoProto_SemanticInferenceResult _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ElementFinderInfoProto_SemanticInferenceResultDefaultTypeInternal _ElementFinderInfoProto_SemanticInferenceResult_default_instance_;
PROTOBUF_CONSTEXPR ElementFinderInfoProto::ElementFinderInfoProto(
    ::_pbi::ConstantInitialized)
  : semantic_inference_result_(nullptr)
  , tracking_id_(int64_t{0})
  , failed_filter_index_range_start_(0)
  , failed_filter_index_range_end_(0)
  , status_(0)

  , get_document_failed_(false){}
struct ElementFinderInfoProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ElementFinderInfoProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ElementFinderInfoProtoDefaultTypeInternal() {}
  union {
    ElementFinderInfoProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ElementFinderInfoProtoDefaultTypeInternal _ElementFinderInfoProto_default_instance_;
PROTOBUF_CONSTEXPR SelectorProto_Filter::SelectorProto_Filter(
    ::_pbi::ConstantInitialized)
  : _oneof_case_{}{}
struct SelectorProto_FilterDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SelectorProto_FilterDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SelectorProto_FilterDefaultTypeInternal() {}
  union {
    SelectorProto_Filter _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SelectorProto_FilterDefaultTypeInternal _SelectorProto_Filter_default_instance_;
PROTOBUF_CONSTEXPR SelectorProto_PropertyFilter::SelectorProto_PropertyFilter(
    ::_pbi::ConstantInitialized)
  : property_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , _oneof_case_{}{}
struct SelectorProto_PropertyFilterDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SelectorProto_PropertyFilterDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SelectorProto_PropertyFilterDefaultTypeInternal() {}
  union {
    SelectorProto_PropertyFilter _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SelectorProto_PropertyFilterDefaultTypeInternal _SelectorProto_PropertyFilter_default_instance_;
PROTOBUF_CONSTEXPR SelectorProto_PseudoElementContent::SelectorProto_PseudoElementContent(
    ::_pbi::ConstantInitialized)
  : content_(nullptr)
  , pseudo_type_(0)
{}
struct SelectorProto_PseudoElementContentDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SelectorProto_PseudoElementContentDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SelectorProto_PseudoElementContentDefaultTypeInternal() {}
  union {
    SelectorProto_PseudoElementContent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SelectorProto_PseudoElementContentDefaultTypeInternal _SelectorProto_PseudoElementContent_default_instance_;
PROTOBUF_CONSTEXPR SelectorProto_CssStyleFilter::SelectorProto_CssStyleFilter(
    ::_pbi::ConstantInitialized)
  : property_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , pseudo_element_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , value_(nullptr)
  , should_match_(true){}
struct SelectorProto_CssStyleFilterDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SelectorProto_CssStyleFilterDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SelectorProto_CssStyleFilterDefaultTypeInternal() {}
  union {
    SelectorProto_CssStyleFilter _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SelectorProto_CssStyleFilterDefaultTypeInternal _SelectorProto_CssStyleFilter_default_instance_;
PROTOBUF_CONSTEXPR SelectorProto_BoundingBoxFilter::SelectorProto_BoundingBoxFilter(
    ::_pbi::ConstantInitialized)
  : require_nonempty_(false){}
struct SelectorProto_BoundingBoxFilterDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SelectorProto_BoundingBoxFilterDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SelectorProto_BoundingBoxFilterDefaultTypeInternal() {}
  union {
    SelectorProto_BoundingBoxFilter _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SelectorProto_BoundingBoxFilterDefaultTypeInternal _SelectorProto_BoundingBoxFilter_default_instance_;
PROTOBUF_CONSTEXPR SelectorProto_OnTopFilter::SelectorProto_OnTopFilter(
    ::_pbi::ConstantInitialized)
  : accept_element_if_not_in_view_(false)
  , scroll_into_view_if_needed_(true){}
struct SelectorProto_OnTopFilterDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SelectorProto_OnTopFilterDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SelectorProto_OnTopFilterDefaultTypeInternal() {}
  union {
    SelectorProto_OnTopFilter _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SelectorProto_OnTopFilterDefaultTypeInternal _SelectorProto_OnTopFilter_default_instance_;
PROTOBUF_CONSTEXPR SelectorProto_EmptyFilter::SelectorProto_EmptyFilter(
    ::_pbi::ConstantInitialized){}
struct SelectorProto_EmptyFilterDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SelectorProto_EmptyFilterDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SelectorProto_EmptyFilterDefaultTypeInternal() {}
  union {
    SelectorProto_EmptyFilter _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SelectorProto_EmptyFilterDefaultTypeInternal _SelectorProto_EmptyFilter_default_instance_;
PROTOBUF_CONSTEXPR SelectorProto_NthMatchFilter::SelectorProto_NthMatchFilter(
    ::_pbi::ConstantInitialized)
  : index_(0){}
struct SelectorProto_NthMatchFilterDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SelectorProto_NthMatchFilterDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SelectorProto_NthMatchFilterDefaultTypeInternal() {}
  union {
    SelectorProto_NthMatchFilter _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SelectorProto_NthMatchFilterDefaultTypeInternal _SelectorProto_NthMatchFilter_default_instance_;
PROTOBUF_CONSTEXPR SelectorProto_SemanticFilter::SelectorProto_SemanticFilter(
    ::_pbi::ConstantInitialized)
  : objective_(0)
  , role_(0)
  , ignore_objective_(false)
  , model_timeout_ms_(5000){}
struct SelectorProto_SemanticFilterDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SelectorProto_SemanticFilterDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SelectorProto_SemanticFilterDefaultTypeInternal() {}
  union {
    SelectorProto_SemanticFilter _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SelectorProto_SemanticFilterDefaultTypeInternal _SelectorProto_SemanticFilter_default_instance_;
PROTOBUF_CONSTEXPR SelectorProto::SelectorProto(
    ::_pbi::ConstantInitialized)
  : filters_()
  , tracking_id_(int64_t{0}){}
struct SelectorProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SelectorProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SelectorProtoDefaultTypeInternal() {}
  union {
    SelectorProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SelectorProtoDefaultTypeInternal _SelectorProto_default_instance_;
PROTOBUF_CONSTEXPR SelectOptionProto::SelectOptionProto(
    ::_pbi::ConstantInitialized)
  : element_(nullptr)
  , option_comparison_attribute_(0)

  , strict_(false)
  , _oneof_case_{}{}
struct SelectOptionProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SelectOptionProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SelectOptionProtoDefaultTypeInternal() {}
  union {
    SelectOptionProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SelectOptionProtoDefaultTypeInternal _SelectOptionProto_default_instance_;
PROTOBUF_CONSTEXPR UpdateClientSettingsProto::UpdateClientSettingsProto(
    ::_pbi::ConstantInitialized)
  : client_settings_(nullptr){}
struct UpdateClientSettingsProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UpdateClientSettingsProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~UpdateClientSettingsProtoDefaultTypeInternal() {}
  union {
    UpdateClientSettingsProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UpdateClientSettingsProtoDefaultTypeInternal _UpdateClientSettingsProto_default_instance_;
PROTOBUF_CONSTEXPR PromptQrCodeScanProto_CameraScanUiStrings::PromptQrCodeScanProto_CameraScanUiStrings(
    ::_pbi::ConstantInitialized)
  : title_text_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , permission_text_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , permission_button_text_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , open_settings_text_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , open_settings_button_text_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , camera_preview_instruction_text_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , camera_preview_security_text_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}){}
struct PromptQrCodeScanProto_CameraScanUiStringsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PromptQrCodeScanProto_CameraScanUiStringsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PromptQrCodeScanProto_CameraScanUiStringsDefaultTypeInternal() {}
  union {
    PromptQrCodeScanProto_CameraScanUiStrings _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PromptQrCodeScanProto_CameraScanUiStringsDefaultTypeInternal _PromptQrCodeScanProto_CameraScanUiStrings_default_instance_;
PROTOBUF_CONSTEXPR PromptQrCodeScanProto_ImagePickerUiStrings::PromptQrCodeScanProto_ImagePickerUiStrings(
    ::_pbi::ConstantInitialized)
  : title_text_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , permission_text_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , permission_button_text_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , open_settings_text_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , open_settings_button_text_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}){}
struct PromptQrCodeScanProto_ImagePickerUiStringsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PromptQrCodeScanProto_ImagePickerUiStringsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PromptQrCodeScanProto_ImagePickerUiStringsDefaultTypeInternal() {}
  union {
    PromptQrCodeScanProto_ImagePickerUiStrings _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PromptQrCodeScanProto_ImagePickerUiStringsDefaultTypeInternal _PromptQrCodeScanProto_ImagePickerUiStrings_default_instance_;
PROTOBUF_CONSTEXPR PromptQrCodeScanProto::PromptQrCodeScanProto(
    ::_pbi::ConstantInitialized)
  : output_client_memory_key_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , camera_scan_ui_strings_(nullptr)
  , image_picker_ui_strings_(nullptr)
  , use_gallery_(false){}
struct PromptQrCodeScanProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PromptQrCodeScanProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PromptQrCodeScanProtoDefaultTypeInternal() {}
  union {
    PromptQrCodeScanProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PromptQrCodeScanProtoDefaultTypeInternal _PromptQrCodeScanProto_default_instance_;
PROTOBUF_CONSTEXPR TellProto_TextToSpeech::TellProto_TextToSpeech(
    ::_pbi::ConstantInitialized)
  : tts_message_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , play_now_(false){}
struct TellProto_TextToSpeechDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TellProto_TextToSpeechDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TellProto_TextToSpeechDefaultTypeInternal() {}
  union {
    TellProto_TextToSpeech _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TellProto_TextToSpeechDefaultTypeInternal _TellProto_TextToSpeech_default_instance_;
PROTOBUF_CONSTEXPR TellProto::TellProto(
    ::_pbi::ConstantInitialized)
  : message_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , text_to_speech_(nullptr)
  , needs_ui_(true){}
struct TellProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TellProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TellProtoDefaultTypeInternal() {}
  union {
    TellProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TellProtoDefaultTypeInternal _TellProto_default_instance_;
PROTOBUF_CONSTEXPR ShowCastProto_TopPadding::ShowCastProto_TopPadding(
    ::_pbi::ConstantInitialized)
  : _oneof_case_{}{}
struct ShowCastProto_TopPaddingDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ShowCastProto_TopPaddingDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ShowCastProto_TopPaddingDefaultTypeInternal() {}
  union {
    ShowCastProto_TopPadding _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ShowCastProto_TopPaddingDefaultTypeInternal _ShowCastProto_TopPadding_default_instance_;
PROTOBUF_CONSTEXPR ShowCastProto::ShowCastProto(
    ::_pbi::ConstantInitialized)
  : element_to_present_(nullptr)
  , touchable_element_area_(nullptr)
  , top_padding_(nullptr)
  , container_(nullptr)
  , wait_for_stable_element_(0)

  , stable_check_max_rounds_(50)
  , stable_check_interval_ms_(200){}
struct ShowCastProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ShowCastProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ShowCastProtoDefaultTypeInternal() {}
  union {
    ShowCastProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ShowCastProtoDefaultTypeInternal _ShowCastProto_default_instance_;
PROTOBUF_CONSTEXPR SetTouchableAreaProto::SetTouchableAreaProto(
    ::_pbi::ConstantInitialized)
  : element_area_(nullptr){}
struct SetTouchableAreaProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SetTouchableAreaProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SetTouchableAreaProtoDefaultTypeInternal() {}
  union {
    SetTouchableAreaProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SetTouchableAreaProtoDefaultTypeInternal _SetTouchableAreaProto_default_instance_;
PROTOBUF_CONSTEXPR ElementAreaProto_Rectangle::ElementAreaProto_Rectangle(
    ::_pbi::ConstantInitialized)
  : elements_()
  , full_width_(false){}
struct ElementAreaProto_RectangleDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ElementAreaProto_RectangleDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ElementAreaProto_RectangleDefaultTypeInternal() {}
  union {
    ElementAreaProto_Rectangle _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ElementAreaProto_RectangleDefaultTypeInternal _ElementAreaProto_Rectangle_default_instance_;
PROTOBUF_CONSTEXPR ElementAreaProto::ElementAreaProto(
    ::_pbi::ConstantInitialized)
  : touchable_()
  , restricted_(){}
struct ElementAreaProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ElementAreaProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ElementAreaProtoDefaultTypeInternal() {}
  union {
    ElementAreaProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ElementAreaProtoDefaultTypeInternal _ElementAreaProto_default_instance_;
PROTOBUF_CONSTEXPR RequiredFieldProto::RequiredFieldProto(
    ::_pbi::ConstantInitialized)
  : element_(nullptr)
  , option_element_to_click_(nullptr)
  , value_expression_(nullptr)
  , option_comparison_value_expression_re2_(nullptr)
  , fill_strategy_(0)

  , select_strategy_(0)

  , forced_(false)
  , is_optional_(false)
  , click_type_(0)

  , option_comparison_attribute_(0)

  , delay_in_millisecond_(20){}
struct RequiredFieldProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RequiredFieldProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RequiredFieldProtoDefaultTypeInternal() {}
  union {
    RequiredFieldProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RequiredFieldProtoDefaultTypeInternal _RequiredFieldProto_default_instance_;
PROTOBUF_CONSTEXPR UseAddressProto::UseAddressProto(
    ::_pbi::ConstantInitialized)
  : required_fields_()
  , form_field_element_(nullptr)
  , skip_autofill_(false)
  , _oneof_case_{}{}
struct UseAddressProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UseAddressProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~UseAddressProtoDefaultTypeInternal() {}
  union {
    UseAddressProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UseAddressProtoDefaultTypeInternal _UseAddressProto_default_instance_;
PROTOBUF_CONSTEXPR UseCreditCardProto::UseCreditCardProto(
    ::_pbi::ConstantInitialized)
  : required_fields_()
  , model_identifier_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , form_field_element_(nullptr)
  , skip_autofill_(false)
  , skip_resolve_(false){}
struct UseCreditCardProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UseCreditCardProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~UseCreditCardProtoDefaultTypeInternal() {}
  union {
    UseCreditCardProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UseCreditCardProtoDefaultTypeInternal _UseCreditCardProto_default_instance_;
PROTOBUF_CONSTEXPR WaitForDomProto_Result::WaitForDomProto_Result(
    ::_pbi::ConstantInitialized)
  : matching_condition_payloads_()
  , matching_condition_tags_(){}
struct WaitForDomProto_ResultDefaultTypeInternal {
  PROTOBUF_CONSTEXPR WaitForDomProto_ResultDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~WaitForDomProto_ResultDefaultTypeInternal() {}
  union {
    WaitForDomProto_Result _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 WaitForDomProto_ResultDefaultTypeInternal _WaitForDomProto_Result_default_instance_;
PROTOBUF_CONSTEXPR WaitForDomProto::WaitForDomProto(
    ::_pbi::ConstantInitialized)
  : wait_condition_(nullptr)
  , timeout_ms_(0)
  , allow_interrupt_(false){}
struct WaitForDomProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR WaitForDomProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~WaitForDomProtoDefaultTypeInternal() {}
  union {
    WaitForDomProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 WaitForDomProtoDefaultTypeInternal _WaitForDomProto_default_instance_;
PROTOBUF_CONSTEXPR ElementConditionProto::ElementConditionProto(
    ::_pbi::ConstantInitialized)
  : payload_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , tag_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , client_id_(nullptr)
  , require_unique_element_(false)
  , _oneof_case_{}{}
struct ElementConditionProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ElementConditionProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ElementConditionProtoDefaultTypeInternal() {}
  union {
    ElementConditionProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ElementConditionProtoDefaultTypeInternal _ElementConditionProto_default_instance_;
PROTOBUF_CONSTEXPR ElementConditionsProto::ElementConditionsProto(
    ::_pbi::ConstantInitialized)
  : conditions_(){}
struct ElementConditionsProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ElementConditionsProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ElementConditionsProtoDefaultTypeInternal() {}
  union {
    ElementConditionsProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ElementConditionsProtoDefaultTypeInternal _ElementConditionsProto_default_instance_;
PROTOBUF_CONSTEXPR UploadDomProto_Result::UploadDomProto_Result(
    ::_pbi::ConstantInitialized)
  : outer_htmls_(){}
struct UploadDomProto_ResultDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UploadDomProto_ResultDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~UploadDomProto_ResultDefaultTypeInternal() {}
  union {
    UploadDomProto_Result _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UploadDomProto_ResultDefaultTypeInternal _UploadDomProto_Result_default_instance_;
PROTOBUF_CONSTEXPR UploadDomProto::UploadDomProto(
    ::_pbi::ConstantInitialized)
  : tree_root_(nullptr)
  , can_match_multiple_elements_(false)
  , include_all_inner_text_(false){}
struct UploadDomProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UploadDomProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~UploadDomProtoDefaultTypeInternal() {}
  union {
    UploadDomProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UploadDomProtoDefaultTypeInternal _UploadDomProto_default_instance_;
PROTOBUF_CONSTEXPR ShowProgressBarProto_StepProgressBarIcon::ShowProgressBarProto_StepProgressBarIcon(
    ::_pbi::ConstantInitialized)
  : identifier_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , icon_(nullptr){}
struct ShowProgressBarProto_StepProgressBarIconDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ShowProgressBarProto_StepProgressBarIconDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ShowProgressBarProto_StepProgressBarIconDefaultTypeInternal() {}
  union {
    ShowProgressBarProto_StepProgressBarIcon _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ShowProgressBarProto_StepProgressBarIconDefaultTypeInternal _ShowProgressBarProto_StepProgressBarIcon_default_instance_;
PROTOBUF_CONSTEXPR ShowProgressBarProto_StepProgressBarConfiguration::ShowProgressBarProto_StepProgressBarConfiguration(
    ::_pbi::ConstantInitialized)
  : annotated_step_icons_(){}
struct ShowProgressBarProto_StepProgressBarConfigurationDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ShowProgressBarProto_StepProgressBarConfigurationDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ShowProgressBarProto_StepProgressBarConfigurationDefaultTypeInternal() {}
  union {
    ShowProgressBarProto_StepProgressBarConfiguration _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ShowProgressBarProto_StepProgressBarConfigurationDefaultTypeInternal _ShowProgressBarProto_StepProgressBarConfiguration_default_instance_;
PROTOBUF_CONSTEXPR ShowProgressBarProto::ShowProgressBarProto(
    ::_pbi::ConstantInitialized)
  : step_progress_bar_configuration_(nullptr)
  , error_state_(false)
  , hide_(false)
  , _oneof_case_{}{}
struct ShowProgressBarProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ShowProgressBarProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ShowProgressBarProtoDefaultTypeInternal() {}
  union {
    ShowProgressBarProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ShowProgressBarProtoDefaultTypeInternal _ShowProgressBarProto_default_instance_;
PROTOBUF_CONSTEXPR NavigateProto::NavigateProto(
    ::_pbi::ConstantInitialized)
  : _oneof_case_{}{}
struct NavigateProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NavigateProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NavigateProtoDefaultTypeInternal() {}
  union {
    NavigateProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NavigateProtoDefaultTypeInternal _NavigateProto_default_instance_;
PROTOBUF_CONSTEXPR ExpectNavigationProto::ExpectNavigationProto(
    ::_pbi::ConstantInitialized){}
struct ExpectNavigationProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ExpectNavigationProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ExpectNavigationProtoDefaultTypeInternal() {}
  union {
    ExpectNavigationProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ExpectNavigationProtoDefaultTypeInternal _ExpectNavigationProto_default_instance_;
PROTOBUF_CONSTEXPR WaitForNavigationProto::WaitForNavigationProto(
    ::_pbi::ConstantInitialized)
  : timeout_ms_(0){}
struct WaitForNavigationProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR WaitForNavigationProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~WaitForNavigationProtoDefaultTypeInternal() {}
  union {
    WaitForNavigationProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 WaitForNavigationProtoDefaultTypeInternal _WaitForNavigationProto_default_instance_;
PROTOBUF_CONSTEXPR WaitForDocumentProto_Result::WaitForDocumentProto_Result(
    ::_pbi::ConstantInitialized)
  : start_ready_state_(0)

  , end_ready_state_(0)
{}
struct WaitForDocumentProto_ResultDefaultTypeInternal {
  PROTOBUF_CONSTEXPR WaitForDocumentProto_ResultDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~WaitForDocumentProto_ResultDefaultTypeInternal() {}
  union {
    WaitForDocumentProto_Result _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 WaitForDocumentProto_ResultDefaultTypeInternal _WaitForDocumentProto_Result_default_instance_;
PROTOBUF_CONSTEXPR WaitForDocumentProto::WaitForDocumentProto(
    ::_pbi::ConstantInitialized)
  : frame_(nullptr)
  , timeout_ms_(5000)
  , min_ready_state_(4)
{}
struct WaitForDocumentProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR WaitForDocumentProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~WaitForDocumentProtoDefaultTypeInternal() {}
  union {
    WaitForDocumentProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 WaitForDocumentProtoDefaultTypeInternal _WaitForDocumentProto_default_instance_;
PROTOBUF_CONSTEXPR ShowGenericUiProto_RequestUserData_AdditionalValue::ShowGenericUiProto_RequestUserData_AdditionalValue(
    ::_pbi::ConstantInitialized)
  : source_identifier_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , model_identifier_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}){}
struct ShowGenericUiProto_RequestUserData_AdditionalValueDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ShowGenericUiProto_RequestUserData_AdditionalValueDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ShowGenericUiProto_RequestUserData_AdditionalValueDefaultTypeInternal() {}
  union {
    ShowGenericUiProto_RequestUserData_AdditionalValue _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ShowGenericUiProto_RequestUserData_AdditionalValueDefaultTypeInternal _ShowGenericUiProto_RequestUserData_AdditionalValue_default_instance_;
PROTOBUF_CONSTEXPR ShowGenericUiProto_RequestUserData::ShowGenericUiProto_RequestUserData(
    ::_pbi::ConstantInitialized)
  : additional_values_(){}
struct ShowGenericUiProto_RequestUserDataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ShowGenericUiProto_RequestUserDataDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ShowGenericUiProto_RequestUserDataDefaultTypeInternal() {}
  union {
    ShowGenericUiProto_RequestUserData _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ShowGenericUiProto_RequestUserDataDefaultTypeInternal _ShowGenericUiProto_RequestUserData_default_instance_;
PROTOBUF_CONSTEXPR ShowGenericUiProto_Result::ShowGenericUiProto_Result(
    ::_pbi::ConstantInitialized)
  : model_(nullptr)
  , navigation_ended_(false){}
struct ShowGenericUiProto_ResultDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ShowGenericUiProto_ResultDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ShowGenericUiProto_ResultDefaultTypeInternal() {}
  union {
    ShowGenericUiProto_Result _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ShowGenericUiProto_ResultDefaultTypeInternal _ShowGenericUiProto_Result_default_instance_;
PROTOBUF_CONSTEXPR ShowGenericUiProto_PeriodicElementChecks_ElementCheck::ShowGenericUiProto_PeriodicElementChecks_ElementCheck(
    ::_pbi::ConstantInitialized)
  : model_identifier_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , element_condition_(nullptr){}
struct ShowGenericUiProto_PeriodicElementChecks_ElementCheckDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ShowGenericUiProto_PeriodicElementChecks_ElementCheckDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ShowGenericUiProto_PeriodicElementChecks_ElementCheckDefaultTypeInternal() {}
  union {
    ShowGenericUiProto_PeriodicElementChecks_ElementCheck _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ShowGenericUiProto_PeriodicElementChecks_ElementCheckDefaultTypeInternal _ShowGenericUiProto_PeriodicElementChecks_ElementCheck_default_instance_;
PROTOBUF_CONSTEXPR ShowGenericUiProto_PeriodicElementChecks::ShowGenericUiProto_PeriodicElementChecks(
    ::_pbi::ConstantInitialized)
  : element_checks_(){}
struct ShowGenericUiProto_PeriodicElementChecksDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ShowGenericUiProto_PeriodicElementChecksDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ShowGenericUiProto_PeriodicElementChecksDefaultTypeInternal() {}
  union {
    ShowGenericUiProto_PeriodicElementChecks _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ShowGenericUiProto_PeriodicElementChecksDefaultTypeInternal _ShowGenericUiProto_PeriodicElementChecks_default_instance_;
PROTOBUF_CONSTEXPR ShowGenericUiProto::ShowGenericUiProto(
    ::_pbi::ConstantInitialized)
  : output_model_identifiers_()
  , generic_user_interface_(nullptr)
  , periodic_element_checks_(nullptr)
  , request_user_data_(nullptr)
  , end_on_navigation_(false)
  , allow_interrupt_(false){}
struct ShowGenericUiProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ShowGenericUiProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ShowGenericUiProtoDefaultTypeInternal() {}
  union {
    ShowGenericUiProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ShowGenericUiProtoDefaultTypeInternal _ShowGenericUiProto_default_instance_;
PROTOBUF_CONSTEXPR SetPersistentUiProto::SetPersistentUiProto(
    ::_pbi::ConstantInitialized)
  : generic_user_interface_(nullptr){}
struct SetPersistentUiProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SetPersistentUiProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SetPersistentUiProtoDefaultTypeInternal() {}
  union {
    SetPersistentUiProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SetPersistentUiProtoDefaultTypeInternal _SetPersistentUiProto_default_instance_;
PROTOBUF_CONSTEXPR ClearPersistentUiProto::ClearPersistentUiProto(
    ::_pbi::ConstantInitialized){}
struct ClearPersistentUiProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ClearPersistentUiProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ClearPersistentUiProtoDefaultTypeInternal() {}
  union {
    ClearPersistentUiProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClearPersistentUiProtoDefaultTypeInternal _ClearPersistentUiProto_default_instance_;
PROTOBUF_CONSTEXPR PromptProto_Choice::PromptProto_Choice(
    ::_pbi::ConstantInitialized)
  : server_payload_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , tag_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , chip_(nullptr)
  , auto_select_when_(nullptr)
  , show_only_when_(nullptr)
  , allow_disabling_(false){}
struct PromptProto_ChoiceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PromptProto_ChoiceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PromptProto_ChoiceDefaultTypeInternal() {}
  union {
    PromptProto_Choice _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PromptProto_ChoiceDefaultTypeInternal _PromptProto_Choice_default_instance_;
PROTOBUF_CONSTEXPR PromptProto_Result::PromptProto_Result(
    ::_pbi::ConstantInitialized)
  : server_payload_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , choice_tag_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , navigation_ended_(false){}
struct PromptProto_ResultDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PromptProto_ResultDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PromptProto_ResultDefaultTypeInternal() {}
  union {
    PromptProto_Result _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PromptProto_ResultDefaultTypeInternal _PromptProto_Result_default_instance_;
PROTOBUF_CONSTEXPR PromptProto::PromptProto(
    ::_pbi::ConstantInitialized)
  : choices_()
  , browse_domains_allowlist_()
  , message_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , allow_interrupt_(false)
  , disable_force_expand_sheet_(false)
  , browse_mode_(false)
  , browse_mode_invisible_(false)
  , end_on_navigation_(false){}
struct PromptProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PromptProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PromptProtoDefaultTypeInternal() {}
  union {
    PromptProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PromptProtoDefaultTypeInternal _PromptProto_default_instance_;
PROTOBUF_CONSTEXPR ContactDetailsProto::ContactDetailsProto(
    ::_pbi::ConstantInitialized)
  : summary_fields_()
  , full_fields_()
  , required_data_piece_()
  , phone_number_required_data_piece_()
  , contact_details_name_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , contact_details_section_title_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , phone_number_section_title_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , request_payer_name_(false)
  , request_payer_email_(false)
  , request_payer_phone_(false)
  , separate_phone_number_section_(false)
  , max_number_summary_lines_(0)
  , max_number_full_lines_(0){}
struct ContactDetailsProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ContactDetailsProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ContactDetailsProtoDefaultTypeInternal() {}
  union {
    ContactDetailsProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ContactDetailsProtoDefaultTypeInternal _ContactDetailsProto_default_instance_;
PROTOBUF_CONSTEXPR LoginDetailsProto_LoginOptionCustomProto::LoginDetailsProto_LoginOptionCustomProto(
    ::_pbi::ConstantInitialized)
  : label_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}){}
struct LoginDetailsProto_LoginOptionCustomProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LoginDetailsProto_LoginOptionCustomProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LoginDetailsProto_LoginOptionCustomProtoDefaultTypeInternal() {}
  union {
    LoginDetailsProto_LoginOptionCustomProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LoginDetailsProto_LoginOptionCustomProtoDefaultTypeInternal _LoginDetailsProto_LoginOptionCustomProto_default_instance_;
PROTOBUF_CONSTEXPR LoginDetailsProto_LoginOptionPasswordManagerProto::LoginDetailsProto_LoginOptionPasswordManagerProto(
    ::_pbi::ConstantInitialized){}
struct LoginDetailsProto_LoginOptionPasswordManagerProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LoginDetailsProto_LoginOptionPasswordManagerProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LoginDetailsProto_LoginOptionPasswordManagerProtoDefaultTypeInternal() {}
  union {
    LoginDetailsProto_LoginOptionPasswordManagerProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LoginDetailsProto_LoginOptionPasswordManagerProtoDefaultTypeInternal _LoginDetailsProto_LoginOptionPasswordManagerProto_default_instance_;
PROTOBUF_CONSTEXPR LoginDetailsProto_LoginOptionProto::LoginDetailsProto_LoginOptionProto(
    ::_pbi::ConstantInitialized)
  : sublabel_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , sublabel_accessibility_hint_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , edit_button_content_description_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , info_popup_(nullptr)
  , choose_automatically_if_no_stored_login_(false)
  , preselection_priority_(0)
  , _oneof_case_{}{}
struct LoginDetailsProto_LoginOptionProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LoginDetailsProto_LoginOptionProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LoginDetailsProto_LoginOptionProtoDefaultTypeInternal() {}
  union {
    LoginDetailsProto_LoginOptionProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LoginDetailsProto_LoginOptionProtoDefaultTypeInternal _LoginDetailsProto_LoginOptionProto_default_instance_;
PROTOBUF_CONSTEXPR LoginDetailsProto::LoginDetailsProto(
    ::_pbi::ConstantInitialized)
  : login_options_()
  , section_title_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}){}
struct LoginDetailsProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LoginDetailsProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LoginDetailsProtoDefaultTypeInternal() {}
  union {
    LoginDetailsProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LoginDetailsProtoDefaultTypeInternal _LoginDetailsProto_default_instance_;
PROTOBUF_CONSTEXPR StaticTextSectionProto::StaticTextSectionProto(
    ::_pbi::ConstantInitialized)
  : _oneof_case_{}{}
struct StaticTextSectionProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StaticTextSectionProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~StaticTextSectionProtoDefaultTypeInternal() {}
  union {
    StaticTextSectionProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StaticTextSectionProtoDefaultTypeInternal _StaticTextSectionProto_default_instance_;
PROTOBUF_CONSTEXPR TextInputProto::TextInputProto(
    ::_pbi::ConstantInitialized)
  : hint_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , client_memory_key_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , value_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , input_type_(0)
{}
struct TextInputProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TextInputProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TextInputProtoDefaultTypeInternal() {}
  union {
    TextInputProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TextInputProtoDefaultTypeInternal _TextInputProto_default_instance_;
PROTOBUF_CONSTEXPR TextInputSectionProto::TextInputSectionProto(
    ::_pbi::ConstantInitialized)
  : input_fields_(){}
struct TextInputSectionProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TextInputSectionProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TextInputSectionProtoDefaultTypeInternal() {}
  union {
    TextInputSectionProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TextInputSectionProtoDefaultTypeInternal _TextInputSectionProto_default_instance_;
PROTOBUF_CONSTEXPR UserFormSectionProto::UserFormSectionProto(
    ::_pbi::ConstantInitialized)
  : title_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , send_result_to_backend_(false)
  , _oneof_case_{}{}
struct UserFormSectionProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UserFormSectionProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~UserFormSectionProtoDefaultTypeInternal() {}
  union {
    UserFormSectionProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UserFormSectionProtoDefaultTypeInternal _UserFormSectionProto_default_instance_;
PROTOBUF_CONSTEXPR PopupListSectionProto::PopupListSectionProto(
    ::_pbi::ConstantInitialized)
  : item_names_()
  , initial_selection_()
  , additional_value_key_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , no_selection_error_message_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , allow_multiselect_(false)
  , selection_mandatory_(true){}
struct PopupListSectionProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PopupListSectionProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PopupListSectionProtoDefaultTypeInternal() {}
  union {
    PopupListSectionProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PopupListSectionProtoDefaultTypeInternal _PopupListSectionProto_default_instance_;
PROTOBUF_CONSTEXPR AutofillEntryProto::AutofillEntryProto(
    ::_pbi::ConstantInitialized)
  : value_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , raw_(false){}
struct AutofillEntryProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AutofillEntryProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AutofillEntryProtoDefaultTypeInternal() {}
  union {
    AutofillEntryProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AutofillEntryProtoDefaultTypeInternal _AutofillEntryProto_default_instance_;
PROTOBUF_CONSTEXPR ProfileProto_ValuesEntry_DoNotUse::ProfileProto_ValuesEntry_DoNotUse(
    ::_pbi::ConstantInitialized){}
struct ProfileProto_ValuesEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ProfileProto_ValuesEntry_DoNotUseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ProfileProto_ValuesEntry_DoNotUseDefaultTypeInternal() {}
  union {
    ProfileProto_ValuesEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ProfileProto_ValuesEntry_DoNotUseDefaultTypeInternal _ProfileProto_ValuesEntry_DoNotUse_default_instance_;
PROTOBUF_CONSTEXPR ProfileProto::ProfileProto(
    ::_pbi::ConstantInitialized)
  : values_()
  , identifier_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , edit_token_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}){}
struct ProfileProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ProfileProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ProfileProtoDefaultTypeInternal() {}
  union {
    ProfileProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ProfileProtoDefaultTypeInternal _ProfileProto_default_instance_;
PROTOBUF_CONSTEXPR PhoneNumberProto::PhoneNumberProto(
    ::_pbi::ConstantInitialized)
  : identifier_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , value_(nullptr){}
struct PhoneNumberProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PhoneNumberProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PhoneNumberProtoDefaultTypeInternal() {}
  union {
    PhoneNumberProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PhoneNumberProtoDefaultTypeInternal _PhoneNumberProto_default_instance_;
PROTOBUF_CONSTEXPR PaymentInstrumentProto_CardValuesEntry_DoNotUse::PaymentInstrumentProto_CardValuesEntry_DoNotUse(
    ::_pbi::ConstantInitialized){}
struct PaymentInstrumentProto_CardValuesEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PaymentInstrumentProto_CardValuesEntry_DoNotUseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PaymentInstrumentProto_CardValuesEntry_DoNotUseDefaultTypeInternal() {}
  union {
    PaymentInstrumentProto_CardValuesEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PaymentInstrumentProto_CardValuesEntry_DoNotUseDefaultTypeInternal _PaymentInstrumentProto_CardValuesEntry_DoNotUse_default_instance_;
PROTOBUF_CONSTEXPR PaymentInstrumentProto_AddressValuesEntry_DoNotUse::PaymentInstrumentProto_AddressValuesEntry_DoNotUse(
    ::_pbi::ConstantInitialized){}
struct PaymentInstrumentProto_AddressValuesEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PaymentInstrumentProto_AddressValuesEntry_DoNotUseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PaymentInstrumentProto_AddressValuesEntry_DoNotUseDefaultTypeInternal() {}
  union {
    PaymentInstrumentProto_AddressValuesEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PaymentInstrumentProto_AddressValuesEntry_DoNotUseDefaultTypeInternal _PaymentInstrumentProto_AddressValuesEntry_DoNotUse_default_instance_;
PROTOBUF_CONSTEXPR PaymentInstrumentProto::PaymentInstrumentProto(
    ::_pbi::ConstantInitialized)
  : card_values_()
  , address_values_()
  , identifier_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , network_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , last_four_digits_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , edit_token_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , instrument_id_(int64_t{0}){}
struct PaymentInstrumentProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PaymentInstrumentProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PaymentInstrumentProtoDefaultTypeInternal() {}
  union {
    PaymentInstrumentProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PaymentInstrumentProtoDefaultTypeInternal _PaymentInstrumentProto_default_instance_;
PROTOBUF_CONSTEXPR DataOriginNoticeProto::DataOriginNoticeProto(
    ::_pbi::ConstantInitialized)
  : link_text_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , dialog_title_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , dialog_text_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , dialog_button_text_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}){}
struct DataOriginNoticeProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DataOriginNoticeProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DataOriginNoticeProtoDefaultTypeInternal() {}
  union {
    DataOriginNoticeProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DataOriginNoticeProtoDefaultTypeInternal _DataOriginNoticeProto_default_instance_;
PROTOBUF_CONSTEXPR CollectUserDataProto_DataSource::CollectUserDataProto_DataSource(
    ::_pbi::ConstantInitialized)
  : allow_fallback_(true){}
struct CollectUserDataProto_DataSourceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CollectUserDataProto_DataSourceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CollectUserDataProto_DataSourceDefaultTypeInternal() {}
  union {
    CollectUserDataProto_DataSource _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CollectUserDataProto_DataSourceDefaultTypeInternal _CollectUserDataProto_DataSource_default_instance_;
PROTOBUF_CONSTEXPR CollectUserDataProto::CollectUserDataProto(
    ::_pbi::ConstantInitialized)
  : supported_basic_card_networks_()
  , additional_actions_()
  , additional_prepended_sections_()
  , additional_appended_sections_()
  , clear_previous_profile_selection_()
  , required_shipping_address_data_piece_()
  , required_credit_card_data_piece_()
  , required_billing_address_data_piece_()
  , prompt_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , billing_address_name_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , shipping_address_name_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , accept_terms_and_conditions_text_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , terms_require_review_text_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , privacy_notice_text_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , credit_card_expired_text_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , info_section_text_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , additional_model_identifier_to_check_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , shipping_address_section_title_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , contact_details_(nullptr)
  , login_details_(nullptr)
  , generic_user_interface_prepended_(nullptr)
  , generic_user_interface_appended_(nullptr)
  , confirm_chip_(nullptr)
  , data_source_(nullptr)
  , data_origin_notice_(nullptr)
  , terms_and_conditions_state_(0)

  , request_payment_method_(false)
  , show_terms_as_checkbox_(false)
  , info_section_text_center_(false)
  , clear_previous_credit_card_selection_(false)
  , clear_previous_login_selection_(false)
  , request_terms_and_conditions_(true){}
struct CollectUserDataProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CollectUserDataProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CollectUserDataProtoDefaultTypeInternal() {}
  union {
    CollectUserDataProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CollectUserDataProtoDefaultTypeInternal _CollectUserDataProto_default_instance_;
PROTOBUF_CONSTEXPR StopProto::StopProto(
    ::_pbi::ConstantInitialized)
  : close_cct_(false)
  , show_feedback_chip_(false){}
struct StopProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StopProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~StopProtoDefaultTypeInternal() {}
  union {
    StopProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StopProtoDefaultTypeInternal _StopProto_default_instance_;
PROTOBUF_CONSTEXPR DetailsChangesProto::DetailsChangesProto(
    ::_pbi::ConstantInitialized)
  : user_approval_required_(false)
  , highlight_title_(false)
  , highlight_line1_(false)
  , highlight_line2_(false)
  , highlight_line3_(false){}
struct DetailsChangesProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DetailsChangesProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DetailsChangesProtoDefaultTypeInternal() {}
  union {
    DetailsChangesProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DetailsChangesProtoDefaultTypeInternal _DetailsChangesProto_default_instance_;
PROTOBUF_CONSTEXPR DetailsProto_ImageClickthroughData::DetailsProto_ImageClickthroughData(
    ::_pbi::ConstantInitialized)
  : description_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , positive_text_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , negative_text_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , clickthrough_url_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , allow_clickthrough_(false){}
struct DetailsProto_ImageClickthroughDataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DetailsProto_ImageClickthroughDataDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DetailsProto_ImageClickthroughDataDefaultTypeInternal() {}
  union {
    DetailsProto_ImageClickthroughData _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DetailsProto_ImageClickthroughDataDefaultTypeInternal _DetailsProto_ImageClickthroughData_default_instance_;
PROTOBUF_CONSTEXPR DetailsProto_PlaceholdersConfiguration::DetailsProto_PlaceholdersConfiguration(
    ::_pbi::ConstantInitialized)
  : show_image_placeholder_(false)
  , show_title_placeholder_(false)
  , show_description_line_1_placeholder_(false)
  , show_description_line_2_placeholder_(false)
  , show_description_line_3_placeholder_(false){}
struct DetailsProto_PlaceholdersConfigurationDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DetailsProto_PlaceholdersConfigurationDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DetailsProto_PlaceholdersConfigurationDefaultTypeInternal() {}
  union {
    DetailsProto_PlaceholdersConfiguration _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DetailsProto_PlaceholdersConfigurationDefaultTypeInternal _DetailsProto_PlaceholdersConfiguration_default_instance_;
PROTOBUF_CONSTEXPR DetailsProto::DetailsProto(
    ::_pbi::ConstantInitialized)
  : title_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , image_url_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , description_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , total_price_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , description_line_1_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , description_line_2_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , total_price_label_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , description_line_3_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , image_accessibility_hint_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , datetime_(nullptr)
  , image_clickthrough_data_(nullptr)
  , placeholders_(nullptr){}
struct DetailsProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DetailsProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DetailsProtoDefaultTypeInternal() {}
  union {
    DetailsProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DetailsProtoDefaultTypeInternal _DetailsProto_default_instance_;
PROTOBUF_CONSTEXPR ShowDetailsProto::ShowDetailsProto(
    ::_pbi::ConstantInitialized)
  : change_flags_(nullptr)
  , append_(false)
  , delay_ms_(0)
  , _oneof_case_{}{}
struct ShowDetailsProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ShowDetailsProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ShowDetailsProtoDefaultTypeInternal() {}
  union {
    ShowDetailsProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ShowDetailsProtoDefaultTypeInternal _ShowDetailsProto_default_instance_;
PROTOBUF_CONSTEXPR GeneratePasswordForFormFieldProto::GeneratePasswordForFormFieldProto(
    ::_pbi::ConstantInitialized)
  : memory_key_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , element_(nullptr){}
struct GeneratePasswordForFormFieldProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GeneratePasswordForFormFieldProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GeneratePasswordForFormFieldProtoDefaultTypeInternal() {}
  union {
    GeneratePasswordForFormFieldProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GeneratePasswordForFormFieldProtoDefaultTypeInternal _GeneratePasswordForFormFieldProto_default_instance_;
PROTOBUF_CONSTEXPR PresaveGeneratedPasswordProto::PresaveGeneratedPasswordProto(
    ::_pbi::ConstantInitialized)
  : memory_key_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}){}
struct PresaveGeneratedPasswordProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PresaveGeneratedPasswordProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PresaveGeneratedPasswordProtoDefaultTypeInternal() {}
  union {
    PresaveGeneratedPasswordProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PresaveGeneratedPasswordProtoDefaultTypeInternal _PresaveGeneratedPasswordProto_default_instance_;
PROTOBUF_CONSTEXPR SaveGeneratedPasswordProto::SaveGeneratedPasswordProto(
    ::_pbi::ConstantInitialized)
  : memory_key_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}){}
struct SaveGeneratedPasswordProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SaveGeneratedPasswordProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SaveGeneratedPasswordProtoDefaultTypeInternal() {}
  union {
    SaveGeneratedPasswordProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SaveGeneratedPasswordProtoDefaultTypeInternal _SaveGeneratedPasswordProto_default_instance_;
PROTOBUF_CONSTEXPR DeleteSelectedPasswordProto::DeleteSelectedPasswordProto(
    ::_pbi::ConstantInitialized){}
struct DeleteSelectedPasswordProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DeleteSelectedPasswordProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DeleteSelectedPasswordProtoDefaultTypeInternal() {}
  union {
    DeleteSelectedPasswordProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DeleteSelectedPasswordProtoDefaultTypeInternal _DeleteSelectedPasswordProto_default_instance_;
PROTOBUF_CONSTEXPR EditSelectedPasswordProto::EditSelectedPasswordProto(
    ::_pbi::ConstantInitialized)
  : memory_key_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}){}
struct EditSelectedPasswordProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EditSelectedPasswordProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~EditSelectedPasswordProtoDefaultTypeInternal() {}
  union {
    EditSelectedPasswordProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EditSelectedPasswordProtoDefaultTypeInternal _EditSelectedPasswordProto_default_instance_;
PROTOBUF_CONSTEXPR ResetPendingCredentialsProto::ResetPendingCredentialsProto(
    ::_pbi::ConstantInitialized){}
struct ResetPendingCredentialsProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ResetPendingCredentialsProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ResetPendingCredentialsProtoDefaultTypeInternal() {}
  union {
    ResetPendingCredentialsProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ResetPendingCredentialsProtoDefaultTypeInternal _ResetPendingCredentialsProto_default_instance_;
PROTOBUF_CONSTEXPR SaveSubmittedPasswordProto_Result::SaveSubmittedPasswordProto_Result(
    ::_pbi::ConstantInitialized)
  : used_same_password_(false)
  , used_leaked_credential_(false){}
struct SaveSubmittedPasswordProto_ResultDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SaveSubmittedPasswordProto_ResultDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SaveSubmittedPasswordProto_ResultDefaultTypeInternal() {}
  union {
    SaveSubmittedPasswordProto_Result _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SaveSubmittedPasswordProto_ResultDefaultTypeInternal _SaveSubmittedPasswordProto_Result_default_instance_;
PROTOBUF_CONSTEXPR SaveSubmittedPasswordProto::SaveSubmittedPasswordProto(
    ::_pbi::ConstantInitialized)
  : leak_detection_timeout_ms_(0){}
struct SaveSubmittedPasswordProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SaveSubmittedPasswordProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SaveSubmittedPasswordProtoDefaultTypeInternal() {}
  union {
    SaveSubmittedPasswordProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SaveSubmittedPasswordProtoDefaultTypeInternal _SaveSubmittedPasswordProto_default_instance_;
PROTOBUF_CONSTEXPR RegisterPasswordResetRequestProto::RegisterPasswordResetRequestProto(
    ::_pbi::ConstantInitialized){}
struct RegisterPasswordResetRequestProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RegisterPasswordResetRequestProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RegisterPasswordResetRequestProtoDefaultTypeInternal() {}
  union {
    RegisterPasswordResetRequestProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RegisterPasswordResetRequestProtoDefaultTypeInternal _RegisterPasswordResetRequestProto_default_instance_;
PROTOBUF_CONSTEXPR ConfigureUiStateProto::ConfigureUiStateProto(
    ::_pbi::ConstantInitialized)
  : overlay_behavior_(0)
{}
struct ConfigureUiStateProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ConfigureUiStateProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ConfigureUiStateProtoDefaultTypeInternal() {}
  union {
    ConfigureUiStateProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ConfigureUiStateProtoDefaultTypeInternal _ConfigureUiStateProto_default_instance_;
PROTOBUF_CONSTEXPR SetAttributeProto::SetAttributeProto(
    ::_pbi::ConstantInitialized)
  : attribute_()
  , value_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , element_(nullptr){}
struct SetAttributeProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SetAttributeProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SetAttributeProtoDefaultTypeInternal() {}
  union {
    SetAttributeProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SetAttributeProtoDefaultTypeInternal _SetAttributeProto_default_instance_;
PROTOBUF_CONSTEXPR InfoBoxProto::InfoBoxProto(
    ::_pbi::ConstantInitialized)
  : explanation_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , _oneof_case_{}{}
struct InfoBoxProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR InfoBoxProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~InfoBoxProtoDefaultTypeInternal() {}
  union {
    InfoBoxProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 InfoBoxProtoDefaultTypeInternal _InfoBoxProto_default_instance_;
PROTOBUF_CONSTEXPR ShowInfoBoxProto::ShowInfoBoxProto(
    ::_pbi::ConstantInitialized)
  : info_box_(nullptr){}
struct ShowInfoBoxProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ShowInfoBoxProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ShowInfoBoxProtoDefaultTypeInternal() {}
  union {
    ShowInfoBoxProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ShowInfoBoxProtoDefaultTypeInternal _ShowInfoBoxProto_default_instance_;
PROTOBUF_CONSTEXPR ConfigureBottomSheetProto::ConfigureBottomSheetProto(
    ::_pbi::ConstantInitialized)
  : viewport_resizing_(0)

  , peek_mode_(0)

  , resize_timeout_ms_(0)
  , _oneof_case_{}{}
struct ConfigureBottomSheetProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ConfigureBottomSheetProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ConfigureBottomSheetProtoDefaultTypeInternal() {}
  union {
    ConfigureBottomSheetProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ConfigureBottomSheetProtoDefaultTypeInternal _ConfigureBottomSheetProto_default_instance_;
PROTOBUF_CONSTEXPR ShowFormProto::ShowFormProto(
    ::_pbi::ConstantInitialized)
  : form_(nullptr)
  , chip_(nullptr){}
struct ShowFormProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ShowFormProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ShowFormProtoDefaultTypeInternal() {}
  union {
    ShowFormProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ShowFormProtoDefaultTypeInternal _ShowFormProto_default_instance_;
PROTOBUF_CONSTEXPR FormProto_Result::FormProto_Result(
    ::_pbi::ConstantInitialized)
  : input_results_()
  , link_(0){}
struct FormProto_ResultDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FormProto_ResultDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FormProto_ResultDefaultTypeInternal() {}
  union {
    FormProto_Result _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FormProto_ResultDefaultTypeInternal _FormProto_Result_default_instance_;
PROTOBUF_CONSTEXPR FormProto::FormProto(
    ::_pbi::ConstantInitialized)
  : inputs_()
  , info_label_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , info_popup_(nullptr){}
struct FormProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FormProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FormProtoDefaultTypeInternal() {}
  union {
    FormProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FormProtoDefaultTypeInternal _FormProto_default_instance_;
PROTOBUF_CONSTEXPR FormInputProto_Result::FormInputProto_Result(
    ::_pbi::ConstantInitialized)
  : _oneof_case_{}{}
struct FormInputProto_ResultDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FormInputProto_ResultDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FormInputProto_ResultDefaultTypeInternal() {}
  union {
    FormInputProto_Result _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FormInputProto_ResultDefaultTypeInternal _FormInputProto_Result_default_instance_;
PROTOBUF_CONSTEXPR FormInputProto::FormInputProto(
    ::_pbi::ConstantInitialized)
  : _oneof_case_{}{}
struct FormInputProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FormInputProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FormInputProtoDefaultTypeInternal() {}
  union {
    FormInputProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FormInputProtoDefaultTypeInternal _FormInputProto_default_instance_;
PROTOBUF_CONSTEXPR CounterInputProto_Counter::CounterInputProto_Counter(
    ::_pbi::ConstantInitialized)
  : allowed_values_()
  , label_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , description_line_1_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , description_line_2_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , initial_value_(0)
  , size_(1)
  , min_value_(-2147483647 - 1)
  , max_value_(2147483647){}
struct CounterInputProto_CounterDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CounterInputProto_CounterDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CounterInputProto_CounterDefaultTypeInternal() {}
  union {
    CounterInputProto_Counter _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CounterInputProto_CounterDefaultTypeInternal _CounterInputProto_Counter_default_instance_;
PROTOBUF_CONSTEXPR CounterInputProto_Result::CounterInputProto_Result(
    ::_pbi::ConstantInitialized)
  : values_(){}
struct CounterInputProto_ResultDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CounterInputProto_ResultDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CounterInputProto_ResultDefaultTypeInternal() {}
  union {
    CounterInputProto_Result _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CounterInputProto_ResultDefaultTypeInternal _CounterInputProto_Result_default_instance_;
PROTOBUF_CONSTEXPR CounterInputProto_ValidationRule_BooleanRule::CounterInputProto_ValidationRule_BooleanRule(
    ::_pbi::ConstantInitialized)
  : sub_rules_()
  , min_satisfied_rules_(0)
  , max_satisfied_rules_(2147483647){}
struct CounterInputProto_ValidationRule_BooleanRuleDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CounterInputProto_ValidationRule_BooleanRuleDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CounterInputProto_ValidationRule_BooleanRuleDefaultTypeInternal() {}
  union {
    CounterInputProto_ValidationRule_BooleanRule _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CounterInputProto_ValidationRule_BooleanRuleDefaultTypeInternal _CounterInputProto_ValidationRule_BooleanRule_default_instance_;
PROTOBUF_CONSTEXPR CounterInputProto_ValidationRule_CounterRule::CounterInputProto_ValidationRule_CounterRule(
    ::_pbi::ConstantInitialized)
  : counter_index_(0)
  , min_value_(-2147483647 - 1)
  , max_value_(2147483647){}
struct CounterInputProto_ValidationRule_CounterRuleDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CounterInputProto_ValidationRule_CounterRuleDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CounterInputProto_ValidationRule_CounterRuleDefaultTypeInternal() {}
  union {
    CounterInputProto_ValidationRule_CounterRule _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CounterInputProto_ValidationRule_CounterRuleDefaultTypeInternal _CounterInputProto_ValidationRule_CounterRule_default_instance_;
PROTOBUF_CONSTEXPR CounterInputProto_ValidationRule_CountersSumRule::CounterInputProto_ValidationRule_CountersSumRule(
    ::_pbi::ConstantInitialized)
  : min_value_(int64_t{-9223372036854775807} - 1)
  , max_value_(int64_t{9223372036854775807}){}
struct CounterInputProto_ValidationRule_CountersSumRuleDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CounterInputProto_ValidationRule_CountersSumRuleDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CounterInputProto_ValidationRule_CountersSumRuleDefaultTypeInternal() {}
  union {
    CounterInputProto_ValidationRule_CountersSumRule _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CounterInputProto_ValidationRule_CountersSumRuleDefaultTypeInternal _CounterInputProto_ValidationRule_CountersSumRule_default_instance_;
PROTOBUF_CONSTEXPR CounterInputProto_ValidationRule::CounterInputProto_ValidationRule(
    ::_pbi::ConstantInitialized)
  : _oneof_case_{}{}
struct CounterInputProto_ValidationRuleDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CounterInputProto_ValidationRuleDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CounterInputProto_ValidationRuleDefaultTypeInternal() {}
  union {
    CounterInputProto_ValidationRule _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CounterInputProto_ValidationRuleDefaultTypeInternal _CounterInputProto_ValidationRule_default_instance_;
PROTOBUF_CONSTEXPR CounterInputProto::CounterInputProto(
    ::_pbi::ConstantInitialized)
  : counters_()
  , label_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , expand_text_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , minimize_text_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , validation_rule_(nullptr)
  , minimized_count_(2147483647)
  , min_counters_sum_(int64_t{-9223372036854775807} - 1)
  , max_counters_sum_(int64_t{9223372036854775807}){}
struct CounterInputProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CounterInputProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CounterInputProtoDefaultTypeInternal() {}
  union {
    CounterInputProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CounterInputProtoDefaultTypeInternal _CounterInputProto_default_instance_;
PROTOBUF_CONSTEXPR SelectionInputProto_Choice::SelectionInputProto_Choice(
    ::_pbi::ConstantInitialized)
  : label_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , description_line_1_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , description_line_2_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , selected_(false){}
struct SelectionInputProto_ChoiceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SelectionInputProto_ChoiceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SelectionInputProto_ChoiceDefaultTypeInternal() {}
  union {
    SelectionInputProto_Choice _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SelectionInputProto_ChoiceDefaultTypeInternal _SelectionInputProto_Choice_default_instance_;
PROTOBUF_CONSTEXPR SelectionInputProto_Result::SelectionInputProto_Result(
    ::_pbi::ConstantInitialized)
  : selected_(){}
struct SelectionInputProto_ResultDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SelectionInputProto_ResultDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SelectionInputProto_ResultDefaultTypeInternal() {}
  union {
    SelectionInputProto_Result _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SelectionInputProto_ResultDefaultTypeInternal _SelectionInputProto_Result_default_instance_;
PROTOBUF_CONSTEXPR SelectionInputProto::SelectionInputProto(
    ::_pbi::ConstantInitialized)
  : choices_()
  , label_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , allow_multiple_(false)
  , min_selected_choices_(1){}
struct SelectionInputProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SelectionInputProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SelectionInputProtoDefaultTypeInternal() {}
  union {
    SelectionInputProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SelectionInputProtoDefaultTypeInternal _SelectionInputProto_default_instance_;
PROTOBUF_CONSTEXPR PopupMessageProto::PopupMessageProto(
    ::_pbi::ConstantInitialized)
  : message_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}){}
struct PopupMessageProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PopupMessageProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PopupMessageProtoDefaultTypeInternal() {}
  union {
    PopupMessageProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PopupMessageProtoDefaultTypeInternal _PopupMessageProto_default_instance_;
PROTOBUF_CONSTEXPR GetElementStatusProto_Result::GetElementStatusProto_Result(
    ::_pbi::ConstantInitialized)
  : reports_()
  , not_empty_(false)
  , match_success_(false)
  , expected_empty_match_(false){}
struct GetElementStatusProto_ResultDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GetElementStatusProto_ResultDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GetElementStatusProto_ResultDefaultTypeInternal() {}
  union {
    GetElementStatusProto_Result _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GetElementStatusProto_ResultDefaultTypeInternal _GetElementStatusProto_Result_default_instance_;
PROTOBUF_CONSTEXPR GetElementStatusProto_MatchOptions::GetElementStatusProto_MatchOptions(
    ::_pbi::ConstantInitialized)
  : find_and_remove_re2_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , case_sensitive_(false)
  , remove_space_(false){}
struct GetElementStatusProto_MatchOptionsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GetElementStatusProto_MatchOptionsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GetElementStatusProto_MatchOptionsDefaultTypeInternal() {}
  union {
    GetElementStatusProto_MatchOptions _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GetElementStatusProto_MatchOptionsDefaultTypeInternal _GetElementStatusProto_MatchOptions_default_instance_;
PROTOBUF_CONSTEXPR GetElementStatusProto_MatchExpectation::GetElementStatusProto_MatchExpectation(
    ::_pbi::ConstantInitialized)
  : match_options_(nullptr)
  , _oneof_case_{}{}
struct GetElementStatusProto_MatchExpectationDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GetElementStatusProto_MatchExpectationDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GetElementStatusProto_MatchExpectationDefaultTypeInternal() {}
  union {
    GetElementStatusProto_MatchExpectation _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GetElementStatusProto_MatchExpectationDefaultTypeInternal _GetElementStatusProto_MatchExpectation_default_instance_;
PROTOBUF_CONSTEXPR GetElementStatusProto_TextMatch::GetElementStatusProto_TextMatch(
    ::_pbi::ConstantInitialized)
  : match_expectation_(nullptr)
  , _oneof_case_{}{}
struct GetElementStatusProto_TextMatchDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GetElementStatusProto_TextMatchDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GetElementStatusProto_TextMatchDefaultTypeInternal() {}
  union {
    GetElementStatusProto_TextMatch _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GetElementStatusProto_TextMatchDefaultTypeInternal _GetElementStatusProto_TextMatch_default_instance_;
PROTOBUF_CONSTEXPR GetElementStatusProto_ValueMatch::GetElementStatusProto_ValueMatch(
    ::_pbi::ConstantInitialized)
  : text_match_(nullptr){}
struct GetElementStatusProto_ValueMatchDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GetElementStatusProto_ValueMatchDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GetElementStatusProto_ValueMatchDefaultTypeInternal() {}
  union {
    GetElementStatusProto_ValueMatch _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GetElementStatusProto_ValueMatchDefaultTypeInternal _GetElementStatusProto_ValueMatch_default_instance_;
PROTOBUF_CONSTEXPR GetElementStatusProto_ComparisonReport::GetElementStatusProto_ComparisonReport(
    ::_pbi::ConstantInitialized)
  : match_options_(nullptr)
  , full_match_(false)
  , contains_(false)
  , starts_with_(false)
  , ends_with_(false)
  , empty_(false)
  , expected_empty_match_(false){}
struct GetElementStatusProto_ComparisonReportDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GetElementStatusProto_ComparisonReportDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GetElementStatusProto_ComparisonReportDefaultTypeInternal() {}
  union {
    GetElementStatusProto_ComparisonReport _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GetElementStatusProto_ComparisonReportDefaultTypeInternal _GetElementStatusProto_ComparisonReport_default_instance_;
PROTOBUF_CONSTEXPR GetElementStatusProto::GetElementStatusProto(
    ::_pbi::ConstantInitialized)
  : expected_value_match_(nullptr)
  , mismatch_should_fail_(false)
  , value_source_(0)

  , _oneof_case_{}{}
struct GetElementStatusProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GetElementStatusProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GetElementStatusProtoDefaultTypeInternal() {}
  union {
    GetElementStatusProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GetElementStatusProtoDefaultTypeInternal _GetElementStatusProto_default_instance_;
PROTOBUF_CONSTEXPR ReleaseElementsProto::ReleaseElementsProto(
    ::_pbi::ConstantInitialized)
  : client_ids_(){}
struct ReleaseElementsProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ReleaseElementsProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ReleaseElementsProtoDefaultTypeInternal() {}
  union {
    ReleaseElementsProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ReleaseElementsProtoDefaultTypeInternal _ReleaseElementsProto_default_instance_;
PROTOBUF_CONSTEXPR DispatchJsEventProto::DispatchJsEventProto(
    ::_pbi::ConstantInitialized){}
struct DispatchJsEventProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DispatchJsEventProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DispatchJsEventProtoDefaultTypeInternal() {}
  union {
    DispatchJsEventProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DispatchJsEventProtoDefaultTypeInternal _DispatchJsEventProto_default_instance_;
PROTOBUF_CONSTEXPR JsFlowProto_Result::JsFlowProto_Result(
    ::_pbi::ConstantInitialized)
  : result_json_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}){}
struct JsFlowProto_ResultDefaultTypeInternal {
  PROTOBUF_CONSTEXPR JsFlowProto_ResultDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~JsFlowProto_ResultDefaultTypeInternal() {}
  union {
    JsFlowProto_Result _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 JsFlowProto_ResultDefaultTypeInternal _JsFlowProto_Result_default_instance_;
PROTOBUF_CONSTEXPR JsFlowProto::JsFlowProto(
    ::_pbi::ConstantInitialized)
  : js_flow_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}){}
struct JsFlowProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR JsFlowProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~JsFlowProtoDefaultTypeInternal() {}
  union {
    JsFlowProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 JsFlowProtoDefaultTypeInternal _JsFlowProto_default_instance_;
PROTOBUF_CONSTEXPR ExternalActionProto_ExternalCondition::ExternalActionProto_ExternalCondition(
    ::_pbi::ConstantInitialized)
  : element_condition_(nullptr)
  , id_(0){}
struct ExternalActionProto_ExternalConditionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ExternalActionProto_ExternalConditionDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ExternalActionProto_ExternalConditionDefaultTypeInternal() {}
  union {
    ExternalActionProto_ExternalCondition _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ExternalActionProto_ExternalConditionDefaultTypeInternal _ExternalActionProto_ExternalCondition_default_instance_;
PROTOBUF_CONSTEXPR ExternalActionProto_Result::ExternalActionProto_Result(
    ::_pbi::ConstantInitialized)
  : result_info_(nullptr){}
struct ExternalActionProto_ResultDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ExternalActionProto_ResultDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ExternalActionProto_ResultDefaultTypeInternal() {}
  union {
    ExternalActionProto_Result _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ExternalActionProto_ResultDefaultTypeInternal _ExternalActionProto_Result_default_instance_;
PROTOBUF_CONSTEXPR ExternalActionProto::ExternalActionProto(
    ::_pbi::ConstantInitialized)
  : conditions_()
  , info_(nullptr)
  , show_touchable_area_(false)
  , allow_interrupt_(false){}
struct ExternalActionProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ExternalActionProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ExternalActionProtoDefaultTypeInternal() {}
  union {
    ExternalActionProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ExternalActionProtoDefaultTypeInternal _ExternalActionProto_default_instance_;
}  // namespace autofill_assistant
namespace autofill_assistant {
bool ClientContextProto_AccountsMatchingStatus_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ClientContextProto_AccountsMatchingStatus_strings[3] = {};

static const char ClientContextProto_AccountsMatchingStatus_names[] =
  "ACCOUNTS_MATCHING"
  "ACCOUNTS_NOT_MATCHING"
  "UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ClientContextProto_AccountsMatchingStatus_entries[] = {
  { {ClientContextProto_AccountsMatchingStatus_names + 0, 17}, 1 },
  { {ClientContextProto_AccountsMatchingStatus_names + 17, 21}, 2 },
  { {ClientContextProto_AccountsMatchingStatus_names + 38, 7}, 0 },
};

static const int ClientContextProto_AccountsMatchingStatus_entries_by_number[] = {
  2, // 0 -> UNKNOWN
  0, // 1 -> ACCOUNTS_MATCHING
  1, // 2 -> ACCOUNTS_NOT_MATCHING
};

const std::string& ClientContextProto_AccountsMatchingStatus_Name(
    ClientContextProto_AccountsMatchingStatus value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ClientContextProto_AccountsMatchingStatus_entries,
          ClientContextProto_AccountsMatchingStatus_entries_by_number,
          3, ClientContextProto_AccountsMatchingStatus_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ClientContextProto_AccountsMatchingStatus_entries,
      ClientContextProto_AccountsMatchingStatus_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ClientContextProto_AccountsMatchingStatus_strings[idx].get();
}
bool ClientContextProto_AccountsMatchingStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ClientContextProto_AccountsMatchingStatus* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ClientContextProto_AccountsMatchingStatus_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<ClientContextProto_AccountsMatchingStatus>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ClientContextProto_AccountsMatchingStatus ClientContextProto::UNKNOWN;
constexpr ClientContextProto_AccountsMatchingStatus ClientContextProto::ACCOUNTS_MATCHING;
constexpr ClientContextProto_AccountsMatchingStatus ClientContextProto::ACCOUNTS_NOT_MATCHING;
constexpr ClientContextProto_AccountsMatchingStatus ClientContextProto::AccountsMatchingStatus_MIN;
constexpr ClientContextProto_AccountsMatchingStatus ClientContextProto::AccountsMatchingStatus_MAX;
constexpr int ClientContextProto::AccountsMatchingStatus_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool ClientContextProto_SignedIntoChromeStatus_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ClientContextProto_SignedIntoChromeStatus_strings[3] = {};

static const char ClientContextProto_SignedIntoChromeStatus_names[] =
  "NOT_SIGNED_IN"
  "SIGNED_IN"
  "UNDEFINED";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ClientContextProto_SignedIntoChromeStatus_entries[] = {
  { {ClientContextProto_SignedIntoChromeStatus_names + 0, 13}, 1 },
  { {ClientContextProto_SignedIntoChromeStatus_names + 13, 9}, 2 },
  { {ClientContextProto_SignedIntoChromeStatus_names + 22, 9}, 0 },
};

static const int ClientContextProto_SignedIntoChromeStatus_entries_by_number[] = {
  2, // 0 -> UNDEFINED
  0, // 1 -> NOT_SIGNED_IN
  1, // 2 -> SIGNED_IN
};

const std::string& ClientContextProto_SignedIntoChromeStatus_Name(
    ClientContextProto_SignedIntoChromeStatus value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ClientContextProto_SignedIntoChromeStatus_entries,
          ClientContextProto_SignedIntoChromeStatus_entries_by_number,
          3, ClientContextProto_SignedIntoChromeStatus_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ClientContextProto_SignedIntoChromeStatus_entries,
      ClientContextProto_SignedIntoChromeStatus_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ClientContextProto_SignedIntoChromeStatus_strings[idx].get();
}
bool ClientContextProto_SignedIntoChromeStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ClientContextProto_SignedIntoChromeStatus* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ClientContextProto_SignedIntoChromeStatus_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<ClientContextProto_SignedIntoChromeStatus>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ClientContextProto_SignedIntoChromeStatus ClientContextProto::UNDEFINED;
constexpr ClientContextProto_SignedIntoChromeStatus ClientContextProto::NOT_SIGNED_IN;
constexpr ClientContextProto_SignedIntoChromeStatus ClientContextProto::SIGNED_IN;
constexpr ClientContextProto_SignedIntoChromeStatus ClientContextProto::SignedIntoChromeStatus_MIN;
constexpr ClientContextProto_SignedIntoChromeStatus ClientContextProto::SignedIntoChromeStatus_MAX;
constexpr int ClientContextProto::SignedIntoChromeStatus_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool ClientContextProto_ScreenOrientation_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ClientContextProto_ScreenOrientation_strings[3] = {};

static const char ClientContextProto_ScreenOrientation_names[] =
  "LANDSCAPE"
  "PORTRAIT"
  "UNDEFINED_ORIENTATION";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ClientContextProto_ScreenOrientation_entries[] = {
  { {ClientContextProto_ScreenOrientation_names + 0, 9}, 2 },
  { {ClientContextProto_ScreenOrientation_names + 9, 8}, 1 },
  { {ClientContextProto_ScreenOrientation_names + 17, 21}, 0 },
};

static const int ClientContextProto_ScreenOrientation_entries_by_number[] = {
  2, // 0 -> UNDEFINED_ORIENTATION
  1, // 1 -> PORTRAIT
  0, // 2 -> LANDSCAPE
};

const std::string& ClientContextProto_ScreenOrientation_Name(
    ClientContextProto_ScreenOrientation value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ClientContextProto_ScreenOrientation_entries,
          ClientContextProto_ScreenOrientation_entries_by_number,
          3, ClientContextProto_ScreenOrientation_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ClientContextProto_ScreenOrientation_entries,
      ClientContextProto_ScreenOrientation_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ClientContextProto_ScreenOrientation_strings[idx].get();
}
bool ClientContextProto_ScreenOrientation_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ClientContextProto_ScreenOrientation* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ClientContextProto_ScreenOrientation_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<ClientContextProto_ScreenOrientation>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ClientContextProto_ScreenOrientation ClientContextProto::UNDEFINED_ORIENTATION;
constexpr ClientContextProto_ScreenOrientation ClientContextProto::PORTRAIT;
constexpr ClientContextProto_ScreenOrientation ClientContextProto::LANDSCAPE;
constexpr ClientContextProto_ScreenOrientation ClientContextProto::ScreenOrientation_MIN;
constexpr ClientContextProto_ScreenOrientation ClientContextProto::ScreenOrientation_MAX;
constexpr int ClientContextProto::ScreenOrientation_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool ClientContextProto_PlatformType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ClientContextProto_PlatformType_strings[4] = {};

static const char ClientContextProto_PlatformType_names[] =
  "PLATFORM_TYPE_ANDROID"
  "PLATFORM_TYPE_DESKTOP"
  "PLATFORM_TYPE_IOS"
  "PLATFORM_TYPE_UNDEFINED";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ClientContextProto_PlatformType_entries[] = {
  { {ClientContextProto_PlatformType_names + 0, 21}, 1 },
  { {ClientContextProto_PlatformType_names + 21, 21}, 3 },
  { {ClientContextProto_PlatformType_names + 42, 17}, 2 },
  { {ClientContextProto_PlatformType_names + 59, 23}, 0 },
};

static const int ClientContextProto_PlatformType_entries_by_number[] = {
  3, // 0 -> PLATFORM_TYPE_UNDEFINED
  0, // 1 -> PLATFORM_TYPE_ANDROID
  2, // 2 -> PLATFORM_TYPE_IOS
  1, // 3 -> PLATFORM_TYPE_DESKTOP
};

const std::string& ClientContextProto_PlatformType_Name(
    ClientContextProto_PlatformType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ClientContextProto_PlatformType_entries,
          ClientContextProto_PlatformType_entries_by_number,
          4, ClientContextProto_PlatformType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ClientContextProto_PlatformType_entries,
      ClientContextProto_PlatformType_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ClientContextProto_PlatformType_strings[idx].get();
}
bool ClientContextProto_PlatformType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ClientContextProto_PlatformType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ClientContextProto_PlatformType_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<ClientContextProto_PlatformType>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ClientContextProto_PlatformType ClientContextProto::PLATFORM_TYPE_UNDEFINED;
constexpr ClientContextProto_PlatformType ClientContextProto::PLATFORM_TYPE_ANDROID;
constexpr ClientContextProto_PlatformType ClientContextProto::PLATFORM_TYPE_IOS;
constexpr ClientContextProto_PlatformType ClientContextProto::PLATFORM_TYPE_DESKTOP;
constexpr ClientContextProto_PlatformType ClientContextProto::PlatformType_MIN;
constexpr ClientContextProto_PlatformType ClientContextProto::PlatformType_MAX;
constexpr int ClientContextProto::PlatformType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool ClientSettingsProto_SlowWarningSettings_MessageMode_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ClientSettingsProto_SlowWarningSettings_MessageMode_strings[3] = {};

static const char ClientSettingsProto_SlowWarningSettings_MessageMode_names[] =
  "CONCATENATE"
  "REPLACE"
  "UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ClientSettingsProto_SlowWarningSettings_MessageMode_entries[] = {
  { {ClientSettingsProto_SlowWarningSettings_MessageMode_names + 0, 11}, 1 },
  { {ClientSettingsProto_SlowWarningSettings_MessageMode_names + 11, 7}, 2 },
  { {ClientSettingsProto_SlowWarningSettings_MessageMode_names + 18, 7}, 0 },
};

static const int ClientSettingsProto_SlowWarningSettings_MessageMode_entries_by_number[] = {
  2, // 0 -> UNKNOWN
  0, // 1 -> CONCATENATE
  1, // 2 -> REPLACE
};

const std::string& ClientSettingsProto_SlowWarningSettings_MessageMode_Name(
    ClientSettingsProto_SlowWarningSettings_MessageMode value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ClientSettingsProto_SlowWarningSettings_MessageMode_entries,
          ClientSettingsProto_SlowWarningSettings_MessageMode_entries_by_number,
          3, ClientSettingsProto_SlowWarningSettings_MessageMode_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ClientSettingsProto_SlowWarningSettings_MessageMode_entries,
      ClientSettingsProto_SlowWarningSettings_MessageMode_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ClientSettingsProto_SlowWarningSettings_MessageMode_strings[idx].get();
}
bool ClientSettingsProto_SlowWarningSettings_MessageMode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ClientSettingsProto_SlowWarningSettings_MessageMode* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ClientSettingsProto_SlowWarningSettings_MessageMode_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<ClientSettingsProto_SlowWarningSettings_MessageMode>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ClientSettingsProto_SlowWarningSettings_MessageMode ClientSettingsProto_SlowWarningSettings::UNKNOWN;
constexpr ClientSettingsProto_SlowWarningSettings_MessageMode ClientSettingsProto_SlowWarningSettings::CONCATENATE;
constexpr ClientSettingsProto_SlowWarningSettings_MessageMode ClientSettingsProto_SlowWarningSettings::REPLACE;
constexpr ClientSettingsProto_SlowWarningSettings_MessageMode ClientSettingsProto_SlowWarningSettings::MessageMode_MIN;
constexpr ClientSettingsProto_SlowWarningSettings_MessageMode ClientSettingsProto_SlowWarningSettings::MessageMode_MAX;
constexpr int ClientSettingsProto_SlowWarningSettings::MessageMode_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool ClientSettingsProto_DisplayStringId_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ClientSettingsProto_DisplayStringId_strings[11] = {};

static const char ClientSettingsProto_DisplayStringId_names[] =
  "CLOSE"
  "CONTINUE_BUTTON"
  "DEFAULT_ERROR"
  "GIVE_UP"
  "MAYBE_GIVE_UP"
  "PAYMENT_INFO_CONFIRM"
  "SEND_FEEDBACK"
  "SETTINGS"
  "STOPPED"
  "UNDO"
  "UNSPECIFIED";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ClientSettingsProto_DisplayStringId_entries[] = {
  { {ClientSettingsProto_DisplayStringId_names + 0, 5}, 8 },
  { {ClientSettingsProto_DisplayStringId_names + 5, 15}, 5 },
  { {ClientSettingsProto_DisplayStringId_names + 20, 13}, 3 },
  { {ClientSettingsProto_DisplayStringId_names + 33, 7}, 1 },
  { {ClientSettingsProto_DisplayStringId_names + 40, 13}, 2 },
  { {ClientSettingsProto_DisplayStringId_names + 53, 20}, 4 },
  { {ClientSettingsProto_DisplayStringId_names + 73, 13}, 7 },
  { {ClientSettingsProto_DisplayStringId_names + 86, 8}, 9 },
  { {ClientSettingsProto_DisplayStringId_names + 94, 7}, 6 },
  { {ClientSettingsProto_DisplayStringId_names + 101, 4}, 10 },
  { {ClientSettingsProto_DisplayStringId_names + 105, 11}, 0 },
};

static const int ClientSettingsProto_DisplayStringId_entries_by_number[] = {
  10, // 0 -> UNSPECIFIED
  3, // 1 -> GIVE_UP
  4, // 2 -> MAYBE_GIVE_UP
  2, // 3 -> DEFAULT_ERROR
  5, // 4 -> PAYMENT_INFO_CONFIRM
  1, // 5 -> CONTINUE_BUTTON
  8, // 6 -> STOPPED
  6, // 7 -> SEND_FEEDBACK
  0, // 8 -> CLOSE
  7, // 9 -> SETTINGS
  9, // 10 -> UNDO
};

const std::string& ClientSettingsProto_DisplayStringId_Name(
    ClientSettingsProto_DisplayStringId value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ClientSettingsProto_DisplayStringId_entries,
          ClientSettingsProto_DisplayStringId_entries_by_number,
          11, ClientSettingsProto_DisplayStringId_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ClientSettingsProto_DisplayStringId_entries,
      ClientSettingsProto_DisplayStringId_entries_by_number,
      11, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ClientSettingsProto_DisplayStringId_strings[idx].get();
}
bool ClientSettingsProto_DisplayStringId_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ClientSettingsProto_DisplayStringId* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ClientSettingsProto_DisplayStringId_entries, 11, name, &int_value);
  if (success) {
    *value = static_cast<ClientSettingsProto_DisplayStringId>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ClientSettingsProto_DisplayStringId ClientSettingsProto::UNSPECIFIED;
constexpr ClientSettingsProto_DisplayStringId ClientSettingsProto::GIVE_UP;
constexpr ClientSettingsProto_DisplayStringId ClientSettingsProto::MAYBE_GIVE_UP;
constexpr ClientSettingsProto_DisplayStringId ClientSettingsProto::DEFAULT_ERROR;
constexpr ClientSettingsProto_DisplayStringId ClientSettingsProto::PAYMENT_INFO_CONFIRM;
constexpr ClientSettingsProto_DisplayStringId ClientSettingsProto::CONTINUE_BUTTON;
constexpr ClientSettingsProto_DisplayStringId ClientSettingsProto::STOPPED;
constexpr ClientSettingsProto_DisplayStringId ClientSettingsProto::SEND_FEEDBACK;
constexpr ClientSettingsProto_DisplayStringId ClientSettingsProto::CLOSE;
constexpr ClientSettingsProto_DisplayStringId ClientSettingsProto::SETTINGS;
constexpr ClientSettingsProto_DisplayStringId ClientSettingsProto::UNDO;
constexpr ClientSettingsProto_DisplayStringId ClientSettingsProto::DisplayStringId_MIN;
constexpr ClientSettingsProto_DisplayStringId ClientSettingsProto::DisplayStringId_MAX;
constexpr int ClientSettingsProto::DisplayStringId_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool TriggerScriptProto_TriggerScriptAction_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> TriggerScriptProto_TriggerScriptAction_strings[6] = {};

static const char TriggerScriptProto_TriggerScriptAction_names[] =
  "ACCEPT"
  "CANCEL_FOREVER"
  "CANCEL_SESSION"
  "NOT_NOW"
  "SHOW_CANCEL_POPUP"
  "UNDEFINED";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry TriggerScriptProto_TriggerScriptAction_entries[] = {
  { {TriggerScriptProto_TriggerScriptAction_names + 0, 6}, 5 },
  { {TriggerScriptProto_TriggerScriptAction_names + 6, 14}, 3 },
  { {TriggerScriptProto_TriggerScriptAction_names + 20, 14}, 2 },
  { {TriggerScriptProto_TriggerScriptAction_names + 34, 7}, 1 },
  { {TriggerScriptProto_TriggerScriptAction_names + 41, 17}, 4 },
  { {TriggerScriptProto_TriggerScriptAction_names + 58, 9}, 0 },
};

static const int TriggerScriptProto_TriggerScriptAction_entries_by_number[] = {
  5, // 0 -> UNDEFINED
  3, // 1 -> NOT_NOW
  2, // 2 -> CANCEL_SESSION
  1, // 3 -> CANCEL_FOREVER
  4, // 4 -> SHOW_CANCEL_POPUP
  0, // 5 -> ACCEPT
};

const std::string& TriggerScriptProto_TriggerScriptAction_Name(
    TriggerScriptProto_TriggerScriptAction value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          TriggerScriptProto_TriggerScriptAction_entries,
          TriggerScriptProto_TriggerScriptAction_entries_by_number,
          6, TriggerScriptProto_TriggerScriptAction_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      TriggerScriptProto_TriggerScriptAction_entries,
      TriggerScriptProto_TriggerScriptAction_entries_by_number,
      6, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     TriggerScriptProto_TriggerScriptAction_strings[idx].get();
}
bool TriggerScriptProto_TriggerScriptAction_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TriggerScriptProto_TriggerScriptAction* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      TriggerScriptProto_TriggerScriptAction_entries, 6, name, &int_value);
  if (success) {
    *value = static_cast<TriggerScriptProto_TriggerScriptAction>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr TriggerScriptProto_TriggerScriptAction TriggerScriptProto::UNDEFINED;
constexpr TriggerScriptProto_TriggerScriptAction TriggerScriptProto::NOT_NOW;
constexpr TriggerScriptProto_TriggerScriptAction TriggerScriptProto::CANCEL_SESSION;
constexpr TriggerScriptProto_TriggerScriptAction TriggerScriptProto::CANCEL_FOREVER;
constexpr TriggerScriptProto_TriggerScriptAction TriggerScriptProto::SHOW_CANCEL_POPUP;
constexpr TriggerScriptProto_TriggerScriptAction TriggerScriptProto::ACCEPT;
constexpr TriggerScriptProto_TriggerScriptAction TriggerScriptProto::TriggerScriptAction_MIN;
constexpr TriggerScriptProto_TriggerScriptAction TriggerScriptProto::TriggerScriptAction_MAX;
constexpr int TriggerScriptProto::TriggerScriptAction_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool TriggerScriptProto_TriggerUIType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> TriggerScriptProto_TriggerUIType_strings[13] = {};

static const char TriggerScriptProto_TriggerUIType_names[] =
  "FOOD_ORDERING_CART_FIRST_TIME_USER"
  "FOOD_ORDERING_CART_RETURNING_USER"
  "IN_CHROME_FOOD_ORDERING_CART_FIRST_TIME_USER"
  "IN_CHROME_FOOD_ORDERING_CART_RETURNING_USER"
  "IN_CHROME_SHOPPING_CART_FIRST_TIME_USER"
  "IN_CHROME_SHOPPING_CART_RETURNING_USER"
  "IN_CHROME_SHOPPING_CHECKOUT_FIRST_TIME_USER"
  "IN_CHROME_SHOPPING_CHECKOUT_RETURNING_USER"
  "SHOPPING_CART_FIRST_TIME_USER"
  "SHOPPING_CART_RETURNING_USER"
  "SHOPPING_CHECKOUT_FIRST_TIME_USER"
  "SHOPPING_CHECKOUT_RETURNING_USER"
  "UNSPECIFIED_TRIGGER_UI_TYPE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry TriggerScriptProto_TriggerUIType_entries[] = {
  { {TriggerScriptProto_TriggerUIType_names + 0, 34}, 9 },
  { {TriggerScriptProto_TriggerUIType_names + 34, 33}, 10 },
  { {TriggerScriptProto_TriggerUIType_names + 67, 44}, 11 },
  { {TriggerScriptProto_TriggerUIType_names + 111, 43}, 12 },
  { {TriggerScriptProto_TriggerUIType_names + 154, 39}, 5 },
  { {TriggerScriptProto_TriggerUIType_names + 193, 38}, 6 },
  { {TriggerScriptProto_TriggerUIType_names + 231, 43}, 7 },
  { {TriggerScriptProto_TriggerUIType_names + 274, 42}, 8 },
  { {TriggerScriptProto_TriggerUIType_names + 316, 29}, 1 },
  { {TriggerScriptProto_TriggerUIType_names + 345, 28}, 2 },
  { {TriggerScriptProto_TriggerUIType_names + 373, 33}, 3 },
  { {TriggerScriptProto_TriggerUIType_names + 406, 32}, 4 },
  { {TriggerScriptProto_TriggerUIType_names + 438, 27}, 0 },
};

static const int TriggerScriptProto_TriggerUIType_entries_by_number[] = {
  12, // 0 -> UNSPECIFIED_TRIGGER_UI_TYPE
  8, // 1 -> SHOPPING_CART_FIRST_TIME_USER
  9, // 2 -> SHOPPING_CART_RETURNING_USER
  10, // 3 -> SHOPPING_CHECKOUT_FIRST_TIME_USER
  11, // 4 -> SHOPPING_CHECKOUT_RETURNING_USER
  4, // 5 -> IN_CHROME_SHOPPING_CART_FIRST_TIME_USER
  5, // 6 -> IN_CHROME_SHOPPING_CART_RETURNING_USER
  6, // 7 -> IN_CHROME_SHOPPING_CHECKOUT_FIRST_TIME_USER
  7, // 8 -> IN_CHROME_SHOPPING_CHECKOUT_RETURNING_USER
  0, // 9 -> FOOD_ORDERING_CART_FIRST_TIME_USER
  1, // 10 -> FOOD_ORDERING_CART_RETURNING_USER
  2, // 11 -> IN_CHROME_FOOD_ORDERING_CART_FIRST_TIME_USER
  3, // 12 -> IN_CHROME_FOOD_ORDERING_CART_RETURNING_USER
};

const std::string& TriggerScriptProto_TriggerUIType_Name(
    TriggerScriptProto_TriggerUIType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          TriggerScriptProto_TriggerUIType_entries,
          TriggerScriptProto_TriggerUIType_entries_by_number,
          13, TriggerScriptProto_TriggerUIType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      TriggerScriptProto_TriggerUIType_entries,
      TriggerScriptProto_TriggerUIType_entries_by_number,
      13, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     TriggerScriptProto_TriggerUIType_strings[idx].get();
}
bool TriggerScriptProto_TriggerUIType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TriggerScriptProto_TriggerUIType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      TriggerScriptProto_TriggerUIType_entries, 13, name, &int_value);
  if (success) {
    *value = static_cast<TriggerScriptProto_TriggerUIType>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr TriggerScriptProto_TriggerUIType TriggerScriptProto::UNSPECIFIED_TRIGGER_UI_TYPE;
constexpr TriggerScriptProto_TriggerUIType TriggerScriptProto::SHOPPING_CART_FIRST_TIME_USER;
constexpr TriggerScriptProto_TriggerUIType TriggerScriptProto::SHOPPING_CART_RETURNING_USER;
constexpr TriggerScriptProto_TriggerUIType TriggerScriptProto::SHOPPING_CHECKOUT_FIRST_TIME_USER;
constexpr TriggerScriptProto_TriggerUIType TriggerScriptProto::SHOPPING_CHECKOUT_RETURNING_USER;
constexpr TriggerScriptProto_TriggerUIType TriggerScriptProto::FOOD_ORDERING_CART_FIRST_TIME_USER;
constexpr TriggerScriptProto_TriggerUIType TriggerScriptProto::FOOD_ORDERING_CART_RETURNING_USER;
constexpr TriggerScriptProto_TriggerUIType TriggerScriptProto::IN_CHROME_SHOPPING_CART_FIRST_TIME_USER;
constexpr TriggerScriptProto_TriggerUIType TriggerScriptProto::IN_CHROME_SHOPPING_CART_RETURNING_USER;
constexpr TriggerScriptProto_TriggerUIType TriggerScriptProto::IN_CHROME_SHOPPING_CHECKOUT_FIRST_TIME_USER;
constexpr TriggerScriptProto_TriggerUIType TriggerScriptProto::IN_CHROME_SHOPPING_CHECKOUT_RETURNING_USER;
constexpr TriggerScriptProto_TriggerUIType TriggerScriptProto::IN_CHROME_FOOD_ORDERING_CART_FIRST_TIME_USER;
constexpr TriggerScriptProto_TriggerUIType TriggerScriptProto::IN_CHROME_FOOD_ORDERING_CART_RETURNING_USER;
constexpr TriggerScriptProto_TriggerUIType TriggerScriptProto::TriggerUIType_MIN;
constexpr TriggerScriptProto_TriggerUIType TriggerScriptProto::TriggerUIType_MAX;
constexpr int TriggerScriptProto::TriggerUIType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool UnexpectedErrorInfoProto_JsExceptionLocation_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> UnexpectedErrorInfoProto_JsExceptionLocation_strings[3] = {};

static const char UnexpectedErrorInfoProto_JsExceptionLocation_names[] =
  "JS_FLOW"
  "JS_FLOW_LIBRARY"
  "UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry UnexpectedErrorInfoProto_JsExceptionLocation_entries[] = {
  { {UnexpectedErrorInfoProto_JsExceptionLocation_names + 0, 7}, 2 },
  { {UnexpectedErrorInfoProto_JsExceptionLocation_names + 7, 15}, 1 },
  { {UnexpectedErrorInfoProto_JsExceptionLocation_names + 22, 7}, 0 },
};

static const int UnexpectedErrorInfoProto_JsExceptionLocation_entries_by_number[] = {
  2, // 0 -> UNKNOWN
  1, // 1 -> JS_FLOW_LIBRARY
  0, // 2 -> JS_FLOW
};

const std::string& UnexpectedErrorInfoProto_JsExceptionLocation_Name(
    UnexpectedErrorInfoProto_JsExceptionLocation value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          UnexpectedErrorInfoProto_JsExceptionLocation_entries,
          UnexpectedErrorInfoProto_JsExceptionLocation_entries_by_number,
          3, UnexpectedErrorInfoProto_JsExceptionLocation_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      UnexpectedErrorInfoProto_JsExceptionLocation_entries,
      UnexpectedErrorInfoProto_JsExceptionLocation_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     UnexpectedErrorInfoProto_JsExceptionLocation_strings[idx].get();
}
bool UnexpectedErrorInfoProto_JsExceptionLocation_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, UnexpectedErrorInfoProto_JsExceptionLocation* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      UnexpectedErrorInfoProto_JsExceptionLocation_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<UnexpectedErrorInfoProto_JsExceptionLocation>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr UnexpectedErrorInfoProto_JsExceptionLocation UnexpectedErrorInfoProto::UNKNOWN;
constexpr UnexpectedErrorInfoProto_JsExceptionLocation UnexpectedErrorInfoProto::JS_FLOW_LIBRARY;
constexpr UnexpectedErrorInfoProto_JsExceptionLocation UnexpectedErrorInfoProto::JS_FLOW;
constexpr UnexpectedErrorInfoProto_JsExceptionLocation UnexpectedErrorInfoProto::JsExceptionLocation_MIN;
constexpr UnexpectedErrorInfoProto_JsExceptionLocation UnexpectedErrorInfoProto::JsExceptionLocation_MAX;
constexpr int UnexpectedErrorInfoProto::JsExceptionLocation_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool AutofillErrorInfoProto_GetFullCardFailureType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> AutofillErrorInfoProto_GetFullCardFailureType_strings[4] = {};

static const char AutofillErrorInfoProto_GetFullCardFailureType_names[] =
  "GENERIC_FAILURE"
  "PROMPT_CLOSED"
  "UNKNOWN_FAILURE_TYPE"
  "VERIFICATION_DECLINED";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry AutofillErrorInfoProto_GetFullCardFailureType_entries[] = {
  { {AutofillErrorInfoProto_GetFullCardFailureType_names + 0, 15}, 3 },
  { {AutofillErrorInfoProto_GetFullCardFailureType_names + 15, 13}, 1 },
  { {AutofillErrorInfoProto_GetFullCardFailureType_names + 28, 20}, 0 },
  { {AutofillErrorInfoProto_GetFullCardFailureType_names + 48, 21}, 2 },
};

static const int AutofillErrorInfoProto_GetFullCardFailureType_entries_by_number[] = {
  2, // 0 -> UNKNOWN_FAILURE_TYPE
  1, // 1 -> PROMPT_CLOSED
  3, // 2 -> VERIFICATION_DECLINED
  0, // 3 -> GENERIC_FAILURE
};

const std::string& AutofillErrorInfoProto_GetFullCardFailureType_Name(
    AutofillErrorInfoProto_GetFullCardFailureType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          AutofillErrorInfoProto_GetFullCardFailureType_entries,
          AutofillErrorInfoProto_GetFullCardFailureType_entries_by_number,
          4, AutofillErrorInfoProto_GetFullCardFailureType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      AutofillErrorInfoProto_GetFullCardFailureType_entries,
      AutofillErrorInfoProto_GetFullCardFailureType_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     AutofillErrorInfoProto_GetFullCardFailureType_strings[idx].get();
}
bool AutofillErrorInfoProto_GetFullCardFailureType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AutofillErrorInfoProto_GetFullCardFailureType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      AutofillErrorInfoProto_GetFullCardFailureType_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<AutofillErrorInfoProto_GetFullCardFailureType>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr AutofillErrorInfoProto_GetFullCardFailureType AutofillErrorInfoProto::UNKNOWN_FAILURE_TYPE;
constexpr AutofillErrorInfoProto_GetFullCardFailureType AutofillErrorInfoProto::PROMPT_CLOSED;
constexpr AutofillErrorInfoProto_GetFullCardFailureType AutofillErrorInfoProto::VERIFICATION_DECLINED;
constexpr AutofillErrorInfoProto_GetFullCardFailureType AutofillErrorInfoProto::GENERIC_FAILURE;
constexpr AutofillErrorInfoProto_GetFullCardFailureType AutofillErrorInfoProto::GetFullCardFailureType_MIN;
constexpr AutofillErrorInfoProto_GetFullCardFailureType AutofillErrorInfoProto::GetFullCardFailureType_MAX;
constexpr int AutofillErrorInfoProto::GetFullCardFailureType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool WebControllerErrorInfoProto_WebAction_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
    case 27:
    case 28:
    case 29:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> WebControllerErrorInfoProto_WebAction_strings[29] = {};

static const char WebControllerErrorInfoProto_WebAction_names[] =
  "BLUR_FIELD"
  "CHECK_OPTION_ELEMENT"
  "CLICK_OR_TAP_ELEMENT"
  "DISPATCH_EVENT_ON_DOCUMENT"
  "EXECUTE_JS"
  "FOCUS_FIELD"
  "GET_ELEMENT_TAG"
  "GET_FIELD_VALUE"
  "GET_OUTER_HTML"
  "GET_STRING_ATTRIBUTE"
  "JS_CLICK_ELEMENT"
  "ON_TOP"
  "SCROLL_CONTAINER"
  "SCROLL_INTO_VIEW"
  "SCROLL_INTO_VIEW_IF_NEEDED"
  "SCROLL_INTO_VIEW_WITH_PADDING"
  "SCROLL_WINDOW"
  "SELECT_FIELD_VALUE"
  "SELECT_OPTION"
  "SELECT_OPTION_ELEMENT"
  "SEND_CHANGE_EVENT"
  "SEND_KEYBOARD_INPUT"
  "SEND_KEY_EVENT"
  "SET_ATTRIBUTE"
  "SET_VALUE_ATTRIBUTE"
  "UNSPECIFIED_WEB_ACTION"
  "WAIT_FOR_DOCUMENT_READY_STATE"
  "WAIT_FOR_DOCUMENT_TO_BECOME_INTERACTIVE"
  "WAIT_UNTIL_ELEMENT_IS_STABLE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry WebControllerErrorInfoProto_WebAction_entries[] = {
  { {WebControllerErrorInfoProto_WebAction_names + 0, 10}, 28 },
  { {WebControllerErrorInfoProto_WebAction_names + 10, 20}, 24 },
  { {WebControllerErrorInfoProto_WebAction_names + 30, 20}, 3 },
  { {WebControllerErrorInfoProto_WebAction_names + 50, 26}, 20 },
  { {WebControllerErrorInfoProto_WebAction_names + 76, 10}, 29 },
  { {WebControllerErrorInfoProto_WebAction_names + 86, 11}, 15 },
  { {WebControllerErrorInfoProto_WebAction_names + 97, 15}, 14 },
  { {WebControllerErrorInfoProto_WebAction_names + 112, 15}, 7 },
  { {WebControllerErrorInfoProto_WebAction_names + 127, 14}, 13 },
  { {WebControllerErrorInfoProto_WebAction_names + 141, 20}, 8 },
  { {WebControllerErrorInfoProto_WebAction_names + 161, 16}, 23 },
  { {WebControllerErrorInfoProto_WebAction_names + 177, 6}, 17 },
  { {WebControllerErrorInfoProto_WebAction_names + 183, 16}, 27 },
  { {WebControllerErrorInfoProto_WebAction_names + 199, 16}, 1 },
  { {WebControllerErrorInfoProto_WebAction_names + 215, 26}, 25 },
  { {WebControllerErrorInfoProto_WebAction_names + 241, 29}, 6 },
  { {WebControllerErrorInfoProto_WebAction_names + 270, 13}, 26 },
  { {WebControllerErrorInfoProto_WebAction_names + 283, 18}, 9 },
  { {WebControllerErrorInfoProto_WebAction_names + 301, 13}, 4 },
  { {WebControllerErrorInfoProto_WebAction_names + 314, 21}, 22 },
  { {WebControllerErrorInfoProto_WebAction_names + 335, 17}, 19 },
  { {WebControllerErrorInfoProto_WebAction_names + 352, 19}, 12 },
  { {WebControllerErrorInfoProto_WebAction_names + 371, 14}, 21 },
  { {WebControllerErrorInfoProto_WebAction_names + 385, 13}, 11 },
  { {WebControllerErrorInfoProto_WebAction_names + 398, 19}, 10 },
  { {WebControllerErrorInfoProto_WebAction_names + 417, 22}, 0 },
  { {WebControllerErrorInfoProto_WebAction_names + 439, 29}, 18 },
  { {WebControllerErrorInfoProto_WebAction_names + 468, 39}, 2 },
  { {WebControllerErrorInfoProto_WebAction_names + 507, 28}, 16 },
};

static const int WebControllerErrorInfoProto_WebAction_entries_by_number[] = {
  25, // 0 -> UNSPECIFIED_WEB_ACTION
  13, // 1 -> SCROLL_INTO_VIEW
  27, // 2 -> WAIT_FOR_DOCUMENT_TO_BECOME_INTERACTIVE
  2, // 3 -> CLICK_OR_TAP_ELEMENT
  18, // 4 -> SELECT_OPTION
  15, // 6 -> SCROLL_INTO_VIEW_WITH_PADDING
  7, // 7 -> GET_FIELD_VALUE
  9, // 8 -> GET_STRING_ATTRIBUTE
  17, // 9 -> SELECT_FIELD_VALUE
  24, // 10 -> SET_VALUE_ATTRIBUTE
  23, // 11 -> SET_ATTRIBUTE
  21, // 12 -> SEND_KEYBOARD_INPUT
  8, // 13 -> GET_OUTER_HTML
  6, // 14 -> GET_ELEMENT_TAG
  5, // 15 -> FOCUS_FIELD
  28, // 16 -> WAIT_UNTIL_ELEMENT_IS_STABLE
  11, // 17 -> ON_TOP
  26, // 18 -> WAIT_FOR_DOCUMENT_READY_STATE
  20, // 19 -> SEND_CHANGE_EVENT
  3, // 20 -> DISPATCH_EVENT_ON_DOCUMENT
  22, // 21 -> SEND_KEY_EVENT
  19, // 22 -> SELECT_OPTION_ELEMENT
  10, // 23 -> JS_CLICK_ELEMENT
  1, // 24 -> CHECK_OPTION_ELEMENT
  14, // 25 -> SCROLL_INTO_VIEW_IF_NEEDED
  16, // 26 -> SCROLL_WINDOW
  12, // 27 -> SCROLL_CONTAINER
  0, // 28 -> BLUR_FIELD
  4, // 29 -> EXECUTE_JS
};

const std::string& WebControllerErrorInfoProto_WebAction_Name(
    WebControllerErrorInfoProto_WebAction value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          WebControllerErrorInfoProto_WebAction_entries,
          WebControllerErrorInfoProto_WebAction_entries_by_number,
          29, WebControllerErrorInfoProto_WebAction_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      WebControllerErrorInfoProto_WebAction_entries,
      WebControllerErrorInfoProto_WebAction_entries_by_number,
      29, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     WebControllerErrorInfoProto_WebAction_strings[idx].get();
}
bool WebControllerErrorInfoProto_WebAction_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, WebControllerErrorInfoProto_WebAction* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      WebControllerErrorInfoProto_WebAction_entries, 29, name, &int_value);
  if (success) {
    *value = static_cast<WebControllerErrorInfoProto_WebAction>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr WebControllerErrorInfoProto_WebAction WebControllerErrorInfoProto::UNSPECIFIED_WEB_ACTION;
constexpr WebControllerErrorInfoProto_WebAction WebControllerErrorInfoProto::SCROLL_INTO_VIEW;
constexpr WebControllerErrorInfoProto_WebAction WebControllerErrorInfoProto::WAIT_FOR_DOCUMENT_TO_BECOME_INTERACTIVE;
constexpr WebControllerErrorInfoProto_WebAction WebControllerErrorInfoProto::CLICK_OR_TAP_ELEMENT;
constexpr WebControllerErrorInfoProto_WebAction WebControllerErrorInfoProto::SELECT_OPTION;
constexpr WebControllerErrorInfoProto_WebAction WebControllerErrorInfoProto::SCROLL_INTO_VIEW_WITH_PADDING;
constexpr WebControllerErrorInfoProto_WebAction WebControllerErrorInfoProto::GET_FIELD_VALUE;
constexpr WebControllerErrorInfoProto_WebAction WebControllerErrorInfoProto::GET_STRING_ATTRIBUTE;
constexpr WebControllerErrorInfoProto_WebAction WebControllerErrorInfoProto::SELECT_FIELD_VALUE;
constexpr WebControllerErrorInfoProto_WebAction WebControllerErrorInfoProto::SET_VALUE_ATTRIBUTE;
constexpr WebControllerErrorInfoProto_WebAction WebControllerErrorInfoProto::SET_ATTRIBUTE;
constexpr WebControllerErrorInfoProto_WebAction WebControllerErrorInfoProto::SEND_KEYBOARD_INPUT;
constexpr WebControllerErrorInfoProto_WebAction WebControllerErrorInfoProto::GET_OUTER_HTML;
constexpr WebControllerErrorInfoProto_WebAction WebControllerErrorInfoProto::GET_ELEMENT_TAG;
constexpr WebControllerErrorInfoProto_WebAction WebControllerErrorInfoProto::FOCUS_FIELD;
constexpr WebControllerErrorInfoProto_WebAction WebControllerErrorInfoProto::WAIT_UNTIL_ELEMENT_IS_STABLE;
constexpr WebControllerErrorInfoProto_WebAction WebControllerErrorInfoProto::ON_TOP;
constexpr WebControllerErrorInfoProto_WebAction WebControllerErrorInfoProto::WAIT_FOR_DOCUMENT_READY_STATE;
constexpr WebControllerErrorInfoProto_WebAction WebControllerErrorInfoProto::SEND_CHANGE_EVENT;
constexpr WebControllerErrorInfoProto_WebAction WebControllerErrorInfoProto::DISPATCH_EVENT_ON_DOCUMENT;
constexpr WebControllerErrorInfoProto_WebAction WebControllerErrorInfoProto::SEND_KEY_EVENT;
constexpr WebControllerErrorInfoProto_WebAction WebControllerErrorInfoProto::SELECT_OPTION_ELEMENT;
constexpr WebControllerErrorInfoProto_WebAction WebControllerErrorInfoProto::JS_CLICK_ELEMENT;
constexpr WebControllerErrorInfoProto_WebAction WebControllerErrorInfoProto::CHECK_OPTION_ELEMENT;
constexpr WebControllerErrorInfoProto_WebAction WebControllerErrorInfoProto::SCROLL_INTO_VIEW_IF_NEEDED;
constexpr WebControllerErrorInfoProto_WebAction WebControllerErrorInfoProto::SCROLL_WINDOW;
constexpr WebControllerErrorInfoProto_WebAction WebControllerErrorInfoProto::SCROLL_CONTAINER;
constexpr WebControllerErrorInfoProto_WebAction WebControllerErrorInfoProto::BLUR_FIELD;
constexpr WebControllerErrorInfoProto_WebAction WebControllerErrorInfoProto::EXECUTE_JS;
constexpr WebControllerErrorInfoProto_WebAction WebControllerErrorInfoProto::WebAction_MIN;
constexpr WebControllerErrorInfoProto_WebAction WebControllerErrorInfoProto::WebAction_MAX;
constexpr int WebControllerErrorInfoProto::WebAction_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool ElementFinderInfoProto_SemanticInferenceStatus_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ElementFinderInfoProto_SemanticInferenceStatus_strings[6] = {};

static const char ElementFinderInfoProto_SemanticInferenceStatus_names[] =
  "INITIALIZATION_ERROR"
  "MODEL_LOAD_ERROR"
  "MODEL_LOAD_TIMEOUT"
  "SUCCESS"
  "UNEXPECTED_ERROR"
  "UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ElementFinderInfoProto_SemanticInferenceStatus_entries[] = {
  { {ElementFinderInfoProto_SemanticInferenceStatus_names + 0, 20}, 3 },
  { {ElementFinderInfoProto_SemanticInferenceStatus_names + 20, 16}, 4 },
  { {ElementFinderInfoProto_SemanticInferenceStatus_names + 36, 18}, 5 },
  { {ElementFinderInfoProto_SemanticInferenceStatus_names + 54, 7}, 1 },
  { {ElementFinderInfoProto_SemanticInferenceStatus_names + 61, 16}, 2 },
  { {ElementFinderInfoProto_SemanticInferenceStatus_names + 77, 7}, 0 },
};

static const int ElementFinderInfoProto_SemanticInferenceStatus_entries_by_number[] = {
  5, // 0 -> UNKNOWN
  3, // 1 -> SUCCESS
  4, // 2 -> UNEXPECTED_ERROR
  0, // 3 -> INITIALIZATION_ERROR
  1, // 4 -> MODEL_LOAD_ERROR
  2, // 5 -> MODEL_LOAD_TIMEOUT
};

const std::string& ElementFinderInfoProto_SemanticInferenceStatus_Name(
    ElementFinderInfoProto_SemanticInferenceStatus value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ElementFinderInfoProto_SemanticInferenceStatus_entries,
          ElementFinderInfoProto_SemanticInferenceStatus_entries_by_number,
          6, ElementFinderInfoProto_SemanticInferenceStatus_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ElementFinderInfoProto_SemanticInferenceStatus_entries,
      ElementFinderInfoProto_SemanticInferenceStatus_entries_by_number,
      6, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ElementFinderInfoProto_SemanticInferenceStatus_strings[idx].get();
}
bool ElementFinderInfoProto_SemanticInferenceStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ElementFinderInfoProto_SemanticInferenceStatus* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ElementFinderInfoProto_SemanticInferenceStatus_entries, 6, name, &int_value);
  if (success) {
    *value = static_cast<ElementFinderInfoProto_SemanticInferenceStatus>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ElementFinderInfoProto_SemanticInferenceStatus ElementFinderInfoProto::UNKNOWN;
constexpr ElementFinderInfoProto_SemanticInferenceStatus ElementFinderInfoProto::SUCCESS;
constexpr ElementFinderInfoProto_SemanticInferenceStatus ElementFinderInfoProto::UNEXPECTED_ERROR;
constexpr ElementFinderInfoProto_SemanticInferenceStatus ElementFinderInfoProto::INITIALIZATION_ERROR;
constexpr ElementFinderInfoProto_SemanticInferenceStatus ElementFinderInfoProto::MODEL_LOAD_ERROR;
constexpr ElementFinderInfoProto_SemanticInferenceStatus ElementFinderInfoProto::MODEL_LOAD_TIMEOUT;
constexpr ElementFinderInfoProto_SemanticInferenceStatus ElementFinderInfoProto::SemanticInferenceStatus_MIN;
constexpr ElementFinderInfoProto_SemanticInferenceStatus ElementFinderInfoProto::SemanticInferenceStatus_MAX;
constexpr int ElementFinderInfoProto::SemanticInferenceStatus_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool SelectOptionProto_OptionComparisonAttribute_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> SelectOptionProto_OptionComparisonAttribute_strings[3] = {};

static const char SelectOptionProto_OptionComparisonAttribute_names[] =
  "LABEL"
  "NOT_SET"
  "VALUE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry SelectOptionProto_OptionComparisonAttribute_entries[] = {
  { {SelectOptionProto_OptionComparisonAttribute_names + 0, 5}, 2 },
  { {SelectOptionProto_OptionComparisonAttribute_names + 5, 7}, 0 },
  { {SelectOptionProto_OptionComparisonAttribute_names + 12, 5}, 1 },
};

static const int SelectOptionProto_OptionComparisonAttribute_entries_by_number[] = {
  1, // 0 -> NOT_SET
  2, // 1 -> VALUE
  0, // 2 -> LABEL
};

const std::string& SelectOptionProto_OptionComparisonAttribute_Name(
    SelectOptionProto_OptionComparisonAttribute value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          SelectOptionProto_OptionComparisonAttribute_entries,
          SelectOptionProto_OptionComparisonAttribute_entries_by_number,
          3, SelectOptionProto_OptionComparisonAttribute_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      SelectOptionProto_OptionComparisonAttribute_entries,
      SelectOptionProto_OptionComparisonAttribute_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     SelectOptionProto_OptionComparisonAttribute_strings[idx].get();
}
bool SelectOptionProto_OptionComparisonAttribute_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SelectOptionProto_OptionComparisonAttribute* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      SelectOptionProto_OptionComparisonAttribute_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<SelectOptionProto_OptionComparisonAttribute>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr SelectOptionProto_OptionComparisonAttribute SelectOptionProto::NOT_SET;
constexpr SelectOptionProto_OptionComparisonAttribute SelectOptionProto::VALUE;
constexpr SelectOptionProto_OptionComparisonAttribute SelectOptionProto::LABEL;
constexpr SelectOptionProto_OptionComparisonAttribute SelectOptionProto::OptionComparisonAttribute_MIN;
constexpr SelectOptionProto_OptionComparisonAttribute SelectOptionProto::OptionComparisonAttribute_MAX;
constexpr int SelectOptionProto::OptionComparisonAttribute_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool ContactDetailsProto_AutofillContactField_IsValid(int value) {
  switch (value) {
    case 7:
    case 9:
    case 14:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ContactDetailsProto_AutofillContactField_strings[3] = {};

static const char ContactDetailsProto_AutofillContactField_names[] =
  "EMAIL_ADDRESS"
  "NAME_FULL"
  "PHONE_HOME_WHOLE_NUMBER";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ContactDetailsProto_AutofillContactField_entries[] = {
  { {ContactDetailsProto_AutofillContactField_names + 0, 13}, 9 },
  { {ContactDetailsProto_AutofillContactField_names + 13, 9}, 7 },
  { {ContactDetailsProto_AutofillContactField_names + 22, 23}, 14 },
};

static const int ContactDetailsProto_AutofillContactField_entries_by_number[] = {
  1, // 7 -> NAME_FULL
  0, // 9 -> EMAIL_ADDRESS
  2, // 14 -> PHONE_HOME_WHOLE_NUMBER
};

const std::string& ContactDetailsProto_AutofillContactField_Name(
    ContactDetailsProto_AutofillContactField value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ContactDetailsProto_AutofillContactField_entries,
          ContactDetailsProto_AutofillContactField_entries_by_number,
          3, ContactDetailsProto_AutofillContactField_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ContactDetailsProto_AutofillContactField_entries,
      ContactDetailsProto_AutofillContactField_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ContactDetailsProto_AutofillContactField_strings[idx].get();
}
bool ContactDetailsProto_AutofillContactField_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ContactDetailsProto_AutofillContactField* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ContactDetailsProto_AutofillContactField_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<ContactDetailsProto_AutofillContactField>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ContactDetailsProto_AutofillContactField ContactDetailsProto::NAME_FULL;
constexpr ContactDetailsProto_AutofillContactField ContactDetailsProto::EMAIL_ADDRESS;
constexpr ContactDetailsProto_AutofillContactField ContactDetailsProto::PHONE_HOME_WHOLE_NUMBER;
constexpr ContactDetailsProto_AutofillContactField ContactDetailsProto::AutofillContactField_MIN;
constexpr ContactDetailsProto_AutofillContactField ContactDetailsProto::AutofillContactField_MAX;
constexpr int ContactDetailsProto::AutofillContactField_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool TextInputProto_InputType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> TextInputProto_InputType_strings[3] = {};

static const char TextInputProto_InputType_names[] =
  "INPUT_ALPHANUMERIC"
  "INPUT_TEXT"
  "UNDEFINED";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry TextInputProto_InputType_entries[] = {
  { {TextInputProto_InputType_names + 0, 18}, 2 },
  { {TextInputProto_InputType_names + 18, 10}, 1 },
  { {TextInputProto_InputType_names + 28, 9}, 0 },
};

static const int TextInputProto_InputType_entries_by_number[] = {
  2, // 0 -> UNDEFINED
  1, // 1 -> INPUT_TEXT
  0, // 2 -> INPUT_ALPHANUMERIC
};

const std::string& TextInputProto_InputType_Name(
    TextInputProto_InputType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          TextInputProto_InputType_entries,
          TextInputProto_InputType_entries_by_number,
          3, TextInputProto_InputType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      TextInputProto_InputType_entries,
      TextInputProto_InputType_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     TextInputProto_InputType_strings[idx].get();
}
bool TextInputProto_InputType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TextInputProto_InputType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      TextInputProto_InputType_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<TextInputProto_InputType>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr TextInputProto_InputType TextInputProto::UNDEFINED;
constexpr TextInputProto_InputType TextInputProto::INPUT_TEXT;
constexpr TextInputProto_InputType TextInputProto::INPUT_ALPHANUMERIC;
constexpr TextInputProto_InputType TextInputProto::InputType_MIN;
constexpr TextInputProto_InputType TextInputProto::InputType_MAX;
constexpr int TextInputProto::InputType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool CollectUserDataProto_TermsAndConditionsState_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> CollectUserDataProto_TermsAndConditionsState_strings[3] = {};

static const char CollectUserDataProto_TermsAndConditionsState_names[] =
  "ACCEPTED"
  "NOT_SELECTED"
  "REVIEW_REQUIRED";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry CollectUserDataProto_TermsAndConditionsState_entries[] = {
  { {CollectUserDataProto_TermsAndConditionsState_names + 0, 8}, 1 },
  { {CollectUserDataProto_TermsAndConditionsState_names + 8, 12}, 0 },
  { {CollectUserDataProto_TermsAndConditionsState_names + 20, 15}, 2 },
};

static const int CollectUserDataProto_TermsAndConditionsState_entries_by_number[] = {
  1, // 0 -> NOT_SELECTED
  0, // 1 -> ACCEPTED
  2, // 2 -> REVIEW_REQUIRED
};

const std::string& CollectUserDataProto_TermsAndConditionsState_Name(
    CollectUserDataProto_TermsAndConditionsState value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          CollectUserDataProto_TermsAndConditionsState_entries,
          CollectUserDataProto_TermsAndConditionsState_entries_by_number,
          3, CollectUserDataProto_TermsAndConditionsState_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      CollectUserDataProto_TermsAndConditionsState_entries,
      CollectUserDataProto_TermsAndConditionsState_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     CollectUserDataProto_TermsAndConditionsState_strings[idx].get();
}
bool CollectUserDataProto_TermsAndConditionsState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CollectUserDataProto_TermsAndConditionsState* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      CollectUserDataProto_TermsAndConditionsState_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<CollectUserDataProto_TermsAndConditionsState>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr CollectUserDataProto_TermsAndConditionsState CollectUserDataProto::NOT_SELECTED;
constexpr CollectUserDataProto_TermsAndConditionsState CollectUserDataProto::ACCEPTED;
constexpr CollectUserDataProto_TermsAndConditionsState CollectUserDataProto::REVIEW_REQUIRED;
constexpr CollectUserDataProto_TermsAndConditionsState CollectUserDataProto::TermsAndConditionsState_MIN;
constexpr CollectUserDataProto_TermsAndConditionsState CollectUserDataProto::TermsAndConditionsState_MAX;
constexpr int CollectUserDataProto::TermsAndConditionsState_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool ConfigureUiStateProto_OverlayBehavior_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ConfigureUiStateProto_OverlayBehavior_strings[2] = {};

static const char ConfigureUiStateProto_OverlayBehavior_names[] =
  "DEFAULT"
  "HIDDEN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ConfigureUiStateProto_OverlayBehavior_entries[] = {
  { {ConfigureUiStateProto_OverlayBehavior_names + 0, 7}, 0 },
  { {ConfigureUiStateProto_OverlayBehavior_names + 7, 6}, 1 },
};

static const int ConfigureUiStateProto_OverlayBehavior_entries_by_number[] = {
  0, // 0 -> DEFAULT
  1, // 1 -> HIDDEN
};

const std::string& ConfigureUiStateProto_OverlayBehavior_Name(
    ConfigureUiStateProto_OverlayBehavior value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ConfigureUiStateProto_OverlayBehavior_entries,
          ConfigureUiStateProto_OverlayBehavior_entries_by_number,
          2, ConfigureUiStateProto_OverlayBehavior_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ConfigureUiStateProto_OverlayBehavior_entries,
      ConfigureUiStateProto_OverlayBehavior_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ConfigureUiStateProto_OverlayBehavior_strings[idx].get();
}
bool ConfigureUiStateProto_OverlayBehavior_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ConfigureUiStateProto_OverlayBehavior* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ConfigureUiStateProto_OverlayBehavior_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<ConfigureUiStateProto_OverlayBehavior>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ConfigureUiStateProto_OverlayBehavior ConfigureUiStateProto::DEFAULT;
constexpr ConfigureUiStateProto_OverlayBehavior ConfigureUiStateProto::HIDDEN;
constexpr ConfigureUiStateProto_OverlayBehavior ConfigureUiStateProto::OverlayBehavior_MIN;
constexpr ConfigureUiStateProto_OverlayBehavior ConfigureUiStateProto::OverlayBehavior_MAX;
constexpr int ConfigureUiStateProto::OverlayBehavior_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool ConfigureBottomSheetProto_ViewportResizing_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ConfigureBottomSheetProto_ViewportResizing_strings[4] = {};

static const char ConfigureBottomSheetProto_ViewportResizing_names[] =
  "NO_CHANGE"
  "NO_RESIZE"
  "RESIZE_LAYOUT_VIEWPORT"
  "RESIZE_VISUAL_VIEWPORT";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ConfigureBottomSheetProto_ViewportResizing_entries[] = {
  { {ConfigureBottomSheetProto_ViewportResizing_names + 0, 9}, 0 },
  { {ConfigureBottomSheetProto_ViewportResizing_names + 9, 9}, 2 },
  { {ConfigureBottomSheetProto_ViewportResizing_names + 18, 22}, 1 },
  { {ConfigureBottomSheetProto_ViewportResizing_names + 40, 22}, 3 },
};

static const int ConfigureBottomSheetProto_ViewportResizing_entries_by_number[] = {
  0, // 0 -> NO_CHANGE
  2, // 1 -> RESIZE_LAYOUT_VIEWPORT
  1, // 2 -> NO_RESIZE
  3, // 3 -> RESIZE_VISUAL_VIEWPORT
};

const std::string& ConfigureBottomSheetProto_ViewportResizing_Name(
    ConfigureBottomSheetProto_ViewportResizing value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ConfigureBottomSheetProto_ViewportResizing_entries,
          ConfigureBottomSheetProto_ViewportResizing_entries_by_number,
          4, ConfigureBottomSheetProto_ViewportResizing_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ConfigureBottomSheetProto_ViewportResizing_entries,
      ConfigureBottomSheetProto_ViewportResizing_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ConfigureBottomSheetProto_ViewportResizing_strings[idx].get();
}
bool ConfigureBottomSheetProto_ViewportResizing_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ConfigureBottomSheetProto_ViewportResizing* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ConfigureBottomSheetProto_ViewportResizing_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<ConfigureBottomSheetProto_ViewportResizing>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ConfigureBottomSheetProto_ViewportResizing ConfigureBottomSheetProto::NO_CHANGE;
constexpr ConfigureBottomSheetProto_ViewportResizing ConfigureBottomSheetProto::RESIZE_LAYOUT_VIEWPORT;
constexpr ConfigureBottomSheetProto_ViewportResizing ConfigureBottomSheetProto::NO_RESIZE;
constexpr ConfigureBottomSheetProto_ViewportResizing ConfigureBottomSheetProto::RESIZE_VISUAL_VIEWPORT;
constexpr ConfigureBottomSheetProto_ViewportResizing ConfigureBottomSheetProto::ViewportResizing_MIN;
constexpr ConfigureBottomSheetProto_ViewportResizing ConfigureBottomSheetProto::ViewportResizing_MAX;
constexpr int ConfigureBottomSheetProto::ViewportResizing_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool ConfigureBottomSheetProto_PeekMode_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ConfigureBottomSheetProto_PeekMode_strings[4] = {};

static const char ConfigureBottomSheetProto_PeekMode_names[] =
  "HANDLE"
  "HANDLE_HEADER"
  "HANDLE_HEADER_CAROUSELS"
  "UNDEFINED_PEEK_MODE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ConfigureBottomSheetProto_PeekMode_entries[] = {
  { {ConfigureBottomSheetProto_PeekMode_names + 0, 6}, 1 },
  { {ConfigureBottomSheetProto_PeekMode_names + 6, 13}, 2 },
  { {ConfigureBottomSheetProto_PeekMode_names + 19, 23}, 3 },
  { {ConfigureBottomSheetProto_PeekMode_names + 42, 19}, 0 },
};

static const int ConfigureBottomSheetProto_PeekMode_entries_by_number[] = {
  3, // 0 -> UNDEFINED_PEEK_MODE
  0, // 1 -> HANDLE
  1, // 2 -> HANDLE_HEADER
  2, // 3 -> HANDLE_HEADER_CAROUSELS
};

const std::string& ConfigureBottomSheetProto_PeekMode_Name(
    ConfigureBottomSheetProto_PeekMode value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ConfigureBottomSheetProto_PeekMode_entries,
          ConfigureBottomSheetProto_PeekMode_entries_by_number,
          4, ConfigureBottomSheetProto_PeekMode_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ConfigureBottomSheetProto_PeekMode_entries,
      ConfigureBottomSheetProto_PeekMode_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ConfigureBottomSheetProto_PeekMode_strings[idx].get();
}
bool ConfigureBottomSheetProto_PeekMode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ConfigureBottomSheetProto_PeekMode* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ConfigureBottomSheetProto_PeekMode_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<ConfigureBottomSheetProto_PeekMode>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ConfigureBottomSheetProto_PeekMode ConfigureBottomSheetProto::UNDEFINED_PEEK_MODE;
constexpr ConfigureBottomSheetProto_PeekMode ConfigureBottomSheetProto::HANDLE;
constexpr ConfigureBottomSheetProto_PeekMode ConfigureBottomSheetProto::HANDLE_HEADER;
constexpr ConfigureBottomSheetProto_PeekMode ConfigureBottomSheetProto::HANDLE_HEADER_CAROUSELS;
constexpr ConfigureBottomSheetProto_PeekMode ConfigureBottomSheetProto::PeekMode_MIN;
constexpr ConfigureBottomSheetProto_PeekMode ConfigureBottomSheetProto::PeekMode_MAX;
constexpr int ConfigureBottomSheetProto::PeekMode_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool GetElementStatusProto_ValueSource_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> GetElementStatusProto_ValueSource_strings[3] = {};

static const char GetElementStatusProto_ValueSource_names[] =
  "INNER_TEXT"
  "NOT_SET"
  "VALUE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry GetElementStatusProto_ValueSource_entries[] = {
  { {GetElementStatusProto_ValueSource_names + 0, 10}, 2 },
  { {GetElementStatusProto_ValueSource_names + 10, 7}, 0 },
  { {GetElementStatusProto_ValueSource_names + 17, 5}, 1 },
};

static const int GetElementStatusProto_ValueSource_entries_by_number[] = {
  1, // 0 -> NOT_SET
  2, // 1 -> VALUE
  0, // 2 -> INNER_TEXT
};

const std::string& GetElementStatusProto_ValueSource_Name(
    GetElementStatusProto_ValueSource value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          GetElementStatusProto_ValueSource_entries,
          GetElementStatusProto_ValueSource_entries_by_number,
          3, GetElementStatusProto_ValueSource_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      GetElementStatusProto_ValueSource_entries,
      GetElementStatusProto_ValueSource_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     GetElementStatusProto_ValueSource_strings[idx].get();
}
bool GetElementStatusProto_ValueSource_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, GetElementStatusProto_ValueSource* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      GetElementStatusProto_ValueSource_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<GetElementStatusProto_ValueSource>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr GetElementStatusProto_ValueSource GetElementStatusProto::NOT_SET;
constexpr GetElementStatusProto_ValueSource GetElementStatusProto::VALUE;
constexpr GetElementStatusProto_ValueSource GetElementStatusProto::INNER_TEXT;
constexpr GetElementStatusProto_ValueSource GetElementStatusProto::ValueSource_MIN;
constexpr GetElementStatusProto_ValueSource GetElementStatusProto::ValueSource_MAX;
constexpr int GetElementStatusProto::ValueSource_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool PolicyType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> PolicyType_strings[2] = {};

static const char PolicyType_names[] =
  "SCRIPT"
  "UNKNOWN_POLICY";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry PolicyType_entries[] = {
  { {PolicyType_names + 0, 6}, 1 },
  { {PolicyType_names + 6, 14}, 0 },
};

static const int PolicyType_entries_by_number[] = {
  1, // 0 -> UNKNOWN_POLICY
  0, // 1 -> SCRIPT
};

const std::string& PolicyType_Name(
    PolicyType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          PolicyType_entries,
          PolicyType_entries_by_number,
          2, PolicyType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      PolicyType_entries,
      PolicyType_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     PolicyType_strings[idx].get();
}
bool PolicyType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PolicyType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      PolicyType_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<PolicyType>(int_value);
  }
  return success;
}
bool SlowWarningStatus_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> SlowWarningStatus_strings[3] = {};

static const char SlowWarningStatus_names[] =
  "NO_WARNING"
  "WARNING_SHOWN"
  "WARNING_TRIGGERED";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry SlowWarningStatus_entries[] = {
  { {SlowWarningStatus_names + 0, 10}, 0 },
  { {SlowWarningStatus_names + 10, 13}, 2 },
  { {SlowWarningStatus_names + 23, 17}, 1 },
};

static const int SlowWarningStatus_entries_by_number[] = {
  0, // 0 -> NO_WARNING
  2, // 1 -> WARNING_TRIGGERED
  1, // 2 -> WARNING_SHOWN
};

const std::string& SlowWarningStatus_Name(
    SlowWarningStatus value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          SlowWarningStatus_entries,
          SlowWarningStatus_entries_by_number,
          3, SlowWarningStatus_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      SlowWarningStatus_entries,
      SlowWarningStatus_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     SlowWarningStatus_strings[idx].get();
}
bool SlowWarningStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SlowWarningStatus* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      SlowWarningStatus_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<SlowWarningStatus>(int_value);
  }
  return success;
}
bool PseudoType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> PseudoType_strings[16] = {};

static const char PseudoType_names[] =
  "AFTER"
  "BACKDROP"
  "BEFORE"
  "FIRST_LETTER"
  "FIRST_LINE"
  "FIRST_LINE_INHERITED"
  "INPUT_LIST_BUTTON"
  "RESIZER"
  "SCROLLBAR"
  "SCROLLBAR_BUTTON"
  "SCROLLBAR_CORNER"
  "SCROLLBAR_THUMB"
  "SCROLLBAR_TRACK"
  "SCROLLBAR_TRACK_PIECE"
  "SELECTION"
  "UNDEFINED";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry PseudoType_entries[] = {
  { {PseudoType_names + 0, 5}, 4 },
  { {PseudoType_names + 5, 8}, 5 },
  { {PseudoType_names + 13, 6}, 3 },
  { {PseudoType_names + 19, 12}, 2 },
  { {PseudoType_names + 31, 10}, 1 },
  { {PseudoType_names + 41, 20}, 7 },
  { {PseudoType_names + 61, 17}, 15 },
  { {PseudoType_names + 78, 7}, 14 },
  { {PseudoType_names + 85, 9}, 8 },
  { {PseudoType_names + 94, 16}, 10 },
  { {PseudoType_names + 110, 16}, 13 },
  { {PseudoType_names + 126, 15}, 9 },
  { {PseudoType_names + 141, 15}, 11 },
  { {PseudoType_names + 156, 21}, 12 },
  { {PseudoType_names + 177, 9}, 6 },
  { {PseudoType_names + 186, 9}, 0 },
};

static const int PseudoType_entries_by_number[] = {
  15, // 0 -> UNDEFINED
  4, // 1 -> FIRST_LINE
  3, // 2 -> FIRST_LETTER
  2, // 3 -> BEFORE
  0, // 4 -> AFTER
  1, // 5 -> BACKDROP
  14, // 6 -> SELECTION
  5, // 7 -> FIRST_LINE_INHERITED
  8, // 8 -> SCROLLBAR
  11, // 9 -> SCROLLBAR_THUMB
  9, // 10 -> SCROLLBAR_BUTTON
  12, // 11 -> SCROLLBAR_TRACK
  13, // 12 -> SCROLLBAR_TRACK_PIECE
  10, // 13 -> SCROLLBAR_CORNER
  7, // 14 -> RESIZER
  6, // 15 -> INPUT_LIST_BUTTON
};

const std::string& PseudoType_Name(
    PseudoType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          PseudoType_entries,
          PseudoType_entries_by_number,
          16, PseudoType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      PseudoType_entries,
      PseudoType_entries_by_number,
      16, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     PseudoType_strings[idx].get();
}
bool PseudoType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PseudoType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      PseudoType_entries, 16, name, &int_value);
  if (success) {
    *value = static_cast<PseudoType>(int_value);
  }
  return success;
}
bool OptionalStep_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> OptionalStep_strings[4] = {};

static const char OptionalStep_names[] =
  "REPORT_STEP_RESULT"
  "REQUIRE_STEP_SUCCESS"
  "SKIP_STEP"
  "STEP_UNSPECIFIED";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry OptionalStep_entries[] = {
  { {OptionalStep_names + 0, 18}, 2 },
  { {OptionalStep_names + 18, 20}, 3 },
  { {OptionalStep_names + 38, 9}, 1 },
  { {OptionalStep_names + 47, 16}, 0 },
};

static const int OptionalStep_entries_by_number[] = {
  3, // 0 -> STEP_UNSPECIFIED
  2, // 1 -> SKIP_STEP
  0, // 2 -> REPORT_STEP_RESULT
  1, // 3 -> REQUIRE_STEP_SUCCESS
};

const std::string& OptionalStep_Name(
    OptionalStep value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          OptionalStep_entries,
          OptionalStep_entries_by_number,
          4, OptionalStep_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      OptionalStep_entries,
      OptionalStep_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     OptionalStep_strings[idx].get();
}
bool OptionalStep_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, OptionalStep* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      OptionalStep_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<OptionalStep>(int_value);
  }
  return success;
}
bool DocumentReadyState_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> DocumentReadyState_strings[6] = {};

static const char DocumentReadyState_names[] =
  "DOCUMENT_COMPLETE"
  "DOCUMENT_INTERACTIVE"
  "DOCUMENT_LOADED"
  "DOCUMENT_LOADING"
  "DOCUMENT_MAX_READY_STATE"
  "DOCUMENT_UNINITIALIZED"
  "DOCUMENT_UNKNOWN_READY_STATE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry DocumentReadyState_entries[] = {
  { {DocumentReadyState_names + 0, 17}, 5 },
  { {DocumentReadyState_names + 17, 20}, 4 },
  { {DocumentReadyState_names + 37, 15}, 3 },
  { {DocumentReadyState_names + 52, 16}, 2 },
  { {DocumentReadyState_names + 68, 24}, 5 },
  { {DocumentReadyState_names + 92, 22}, 1 },
  { {DocumentReadyState_names + 114, 28}, 0 },
};

static const int DocumentReadyState_entries_by_number[] = {
  6, // 0 -> DOCUMENT_UNKNOWN_READY_STATE
  5, // 1 -> DOCUMENT_UNINITIALIZED
  3, // 2 -> DOCUMENT_LOADING
  2, // 3 -> DOCUMENT_LOADED
  1, // 4 -> DOCUMENT_INTERACTIVE
  0, // 5 -> DOCUMENT_COMPLETE
};

const std::string& DocumentReadyState_Name(
    DocumentReadyState value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          DocumentReadyState_entries,
          DocumentReadyState_entries_by_number,
          6, DocumentReadyState_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      DocumentReadyState_entries,
      DocumentReadyState_entries_by_number,
      6, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     DocumentReadyState_strings[idx].get();
}
bool DocumentReadyState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DocumentReadyState* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      DocumentReadyState_entries, 7, name, &int_value);
  if (success) {
    *value = static_cast<DocumentReadyState>(int_value);
  }
  return success;
}

// ===================================================================

class FieldTrialProto::_Internal {
 public:
  using HasBits = decltype(std::declval<FieldTrialProto>()._has_bits_);
  static void set_has_trial_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_group_name(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

FieldTrialProto::FieldTrialProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.FieldTrialProto)
}
FieldTrialProto::FieldTrialProto(const FieldTrialProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  trial_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    trial_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_trial_name()) {
    trial_name_.Set(from._internal_trial_name(), 
      GetArenaForAllocation());
  }
  group_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    group_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_group_name()) {
    group_name_.Set(from._internal_group_name(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.FieldTrialProto)
}

inline void FieldTrialProto::SharedCtor() {
trial_name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  trial_name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
group_name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  group_name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

FieldTrialProto::~FieldTrialProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.FieldTrialProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void FieldTrialProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  trial_name_.Destroy();
  group_name_.Destroy();
}

void FieldTrialProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void FieldTrialProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.FieldTrialProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      trial_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      group_name_.ClearNonDefaultToEmpty();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* FieldTrialProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string trial_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_trial_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string group_name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_group_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FieldTrialProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.FieldTrialProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string trial_name = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_trial_name(), target);
  }

  // optional string group_name = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_group_name(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.FieldTrialProto)
  return target;
}

size_t FieldTrialProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.FieldTrialProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string trial_name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_trial_name());
    }

    // optional string group_name = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_group_name());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void FieldTrialProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const FieldTrialProto*>(
      &from));
}

void FieldTrialProto::MergeFrom(const FieldTrialProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.FieldTrialProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_trial_name(from._internal_trial_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_group_name(from._internal_group_name());
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void FieldTrialProto::CopyFrom(const FieldTrialProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.FieldTrialProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FieldTrialProto::IsInitialized() const {
  return true;
}

void FieldTrialProto::InternalSwap(FieldTrialProto* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &trial_name_, lhs_arena,
      &other->trial_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &group_name_, lhs_arena,
      &other->group_name_, rhs_arena
  );
}

std::string FieldTrialProto::GetTypeName() const {
  return "autofill_assistant.FieldTrialProto";
}


// ===================================================================

class ClientContextProto_Chrome::_Internal {
 public:
  using HasBits = decltype(std::declval<ClientContextProto_Chrome>()._has_bits_);
  static void set_has_chrome_version(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

ClientContextProto_Chrome::ClientContextProto_Chrome(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  active_field_trials_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.ClientContextProto.Chrome)
}
ClientContextProto_Chrome::ClientContextProto_Chrome(const ClientContextProto_Chrome& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      active_field_trials_(from.active_field_trials_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  chrome_version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    chrome_version_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_chrome_version()) {
    chrome_version_.Set(from._internal_chrome_version(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.ClientContextProto.Chrome)
}

inline void ClientContextProto_Chrome::SharedCtor() {
chrome_version_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  chrome_version_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ClientContextProto_Chrome::~ClientContextProto_Chrome() {
  // @@protoc_insertion_point(destructor:autofill_assistant.ClientContextProto.Chrome)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ClientContextProto_Chrome::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  chrome_version_.Destroy();
}

void ClientContextProto_Chrome::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ClientContextProto_Chrome::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.ClientContextProto.Chrome)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  active_field_trials_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    chrome_version_.ClearNonDefaultToEmpty();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ClientContextProto_Chrome::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string chrome_version = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_chrome_version();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .autofill_assistant.FieldTrialProto active_field_trials = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_active_field_trials(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ClientContextProto_Chrome::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.ClientContextProto.Chrome)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string chrome_version = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_chrome_version(), target);
  }

  // repeated .autofill_assistant.FieldTrialProto active_field_trials = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_active_field_trials_size()); i < n; i++) {
    const auto& repfield = this->_internal_active_field_trials(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.ClientContextProto.Chrome)
  return target;
}

size_t ClientContextProto_Chrome::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.ClientContextProto.Chrome)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .autofill_assistant.FieldTrialProto active_field_trials = 2;
  total_size += 1UL * this->_internal_active_field_trials_size();
  for (const auto& msg : this->active_field_trials_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional string chrome_version = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_chrome_version());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ClientContextProto_Chrome::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ClientContextProto_Chrome*>(
      &from));
}

void ClientContextProto_Chrome::MergeFrom(const ClientContextProto_Chrome& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.ClientContextProto.Chrome)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  active_field_trials_.MergeFrom(from.active_field_trials_);
  if (from._internal_has_chrome_version()) {
    _internal_set_chrome_version(from._internal_chrome_version());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClientContextProto_Chrome::CopyFrom(const ClientContextProto_Chrome& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.ClientContextProto.Chrome)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClientContextProto_Chrome::IsInitialized() const {
  return true;
}

void ClientContextProto_Chrome::InternalSwap(ClientContextProto_Chrome* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  active_field_trials_.InternalSwap(&other->active_field_trials_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &chrome_version_, lhs_arena,
      &other->chrome_version_, rhs_arena
  );
}

std::string ClientContextProto_Chrome::GetTypeName() const {
  return "autofill_assistant.ClientContextProto.Chrome";
}


// ===================================================================

class ClientContextProto_DeviceContextProto_VersionProto::_Internal {
 public:
  using HasBits = decltype(std::declval<ClientContextProto_DeviceContextProto_VersionProto>()._has_bits_);
  static void set_has_sdk_int(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

ClientContextProto_DeviceContextProto_VersionProto::ClientContextProto_DeviceContextProto_VersionProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.ClientContextProto.DeviceContextProto.VersionProto)
}
ClientContextProto_DeviceContextProto_VersionProto::ClientContextProto_DeviceContextProto_VersionProto(const ClientContextProto_DeviceContextProto_VersionProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  sdk_int_ = from.sdk_int_;
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.ClientContextProto.DeviceContextProto.VersionProto)
}

inline void ClientContextProto_DeviceContextProto_VersionProto::SharedCtor() {
sdk_int_ = 0;
}

ClientContextProto_DeviceContextProto_VersionProto::~ClientContextProto_DeviceContextProto_VersionProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.ClientContextProto.DeviceContextProto.VersionProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ClientContextProto_DeviceContextProto_VersionProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ClientContextProto_DeviceContextProto_VersionProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ClientContextProto_DeviceContextProto_VersionProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.ClientContextProto.DeviceContextProto.VersionProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  sdk_int_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ClientContextProto_DeviceContextProto_VersionProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 sdk_int = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_sdk_int(&has_bits);
          sdk_int_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ClientContextProto_DeviceContextProto_VersionProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.ClientContextProto.DeviceContextProto.VersionProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 sdk_int = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_sdk_int(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.ClientContextProto.DeviceContextProto.VersionProto)
  return target;
}

size_t ClientContextProto_DeviceContextProto_VersionProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.ClientContextProto.DeviceContextProto.VersionProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional int32 sdk_int = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_sdk_int());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ClientContextProto_DeviceContextProto_VersionProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ClientContextProto_DeviceContextProto_VersionProto*>(
      &from));
}

void ClientContextProto_DeviceContextProto_VersionProto::MergeFrom(const ClientContextProto_DeviceContextProto_VersionProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.ClientContextProto.DeviceContextProto.VersionProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_sdk_int()) {
    _internal_set_sdk_int(from._internal_sdk_int());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClientContextProto_DeviceContextProto_VersionProto::CopyFrom(const ClientContextProto_DeviceContextProto_VersionProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.ClientContextProto.DeviceContextProto.VersionProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClientContextProto_DeviceContextProto_VersionProto::IsInitialized() const {
  return true;
}

void ClientContextProto_DeviceContextProto_VersionProto::InternalSwap(ClientContextProto_DeviceContextProto_VersionProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(sdk_int_, other->sdk_int_);
}

std::string ClientContextProto_DeviceContextProto_VersionProto::GetTypeName() const {
  return "autofill_assistant.ClientContextProto.DeviceContextProto.VersionProto";
}


// ===================================================================

class ClientContextProto_DeviceContextProto::_Internal {
 public:
  using HasBits = decltype(std::declval<ClientContextProto_DeviceContextProto>()._has_bits_);
  static const ::autofill_assistant::ClientContextProto_DeviceContextProto_VersionProto& version(const ClientContextProto_DeviceContextProto* msg);
  static void set_has_version(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_manufacturer(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_model(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::autofill_assistant::ClientContextProto_DeviceContextProto_VersionProto&
ClientContextProto_DeviceContextProto::_Internal::version(const ClientContextProto_DeviceContextProto* msg) {
  return *msg->version_;
}
ClientContextProto_DeviceContextProto::ClientContextProto_DeviceContextProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.ClientContextProto.DeviceContextProto)
}
ClientContextProto_DeviceContextProto::ClientContextProto_DeviceContextProto(const ClientContextProto_DeviceContextProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  manufacturer_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    manufacturer_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_manufacturer()) {
    manufacturer_.Set(from._internal_manufacturer(), 
      GetArenaForAllocation());
  }
  model_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    model_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_model()) {
    model_.Set(from._internal_model(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_version()) {
    version_ = new ::autofill_assistant::ClientContextProto_DeviceContextProto_VersionProto(*from.version_);
  } else {
    version_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.ClientContextProto.DeviceContextProto)
}

inline void ClientContextProto_DeviceContextProto::SharedCtor() {
manufacturer_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  manufacturer_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
model_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  model_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
version_ = nullptr;
}

ClientContextProto_DeviceContextProto::~ClientContextProto_DeviceContextProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.ClientContextProto.DeviceContextProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ClientContextProto_DeviceContextProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  manufacturer_.Destroy();
  model_.Destroy();
  if (this != internal_default_instance()) delete version_;
}

void ClientContextProto_DeviceContextProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ClientContextProto_DeviceContextProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.ClientContextProto.DeviceContextProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      manufacturer_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      model_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(version_ != nullptr);
      version_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ClientContextProto_DeviceContextProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .autofill_assistant.ClientContextProto.DeviceContextProto.VersionProto version = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_version(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string manufacturer = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_manufacturer();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string model = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_model();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ClientContextProto_DeviceContextProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.ClientContextProto.DeviceContextProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .autofill_assistant.ClientContextProto.DeviceContextProto.VersionProto version = 1;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::version(this),
        _Internal::version(this).GetCachedSize(), target, stream);
  }

  // optional string manufacturer = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_manufacturer(), target);
  }

  // optional string model = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_model(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.ClientContextProto.DeviceContextProto)
  return target;
}

size_t ClientContextProto_DeviceContextProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.ClientContextProto.DeviceContextProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string manufacturer = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_manufacturer());
    }

    // optional string model = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_model());
    }

    // optional .autofill_assistant.ClientContextProto.DeviceContextProto.VersionProto version = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *version_);
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ClientContextProto_DeviceContextProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ClientContextProto_DeviceContextProto*>(
      &from));
}

void ClientContextProto_DeviceContextProto::MergeFrom(const ClientContextProto_DeviceContextProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.ClientContextProto.DeviceContextProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_manufacturer(from._internal_manufacturer());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_model(from._internal_model());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_version()->::autofill_assistant::ClientContextProto_DeviceContextProto_VersionProto::MergeFrom(from._internal_version());
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClientContextProto_DeviceContextProto::CopyFrom(const ClientContextProto_DeviceContextProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.ClientContextProto.DeviceContextProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClientContextProto_DeviceContextProto::IsInitialized() const {
  return true;
}

void ClientContextProto_DeviceContextProto::InternalSwap(ClientContextProto_DeviceContextProto* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &manufacturer_, lhs_arena,
      &other->manufacturer_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &model_, lhs_arena,
      &other->model_, rhs_arena
  );
  swap(version_, other->version_);
}

std::string ClientContextProto_DeviceContextProto::GetTypeName() const {
  return "autofill_assistant.ClientContextProto.DeviceContextProto";
}


// ===================================================================

class ClientContextProto_WindowSize::_Internal {
 public:
  using HasBits = decltype(std::declval<ClientContextProto_WindowSize>()._has_bits_);
  static void set_has_height_pixels(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_width_pixels(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

ClientContextProto_WindowSize::ClientContextProto_WindowSize(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.ClientContextProto.WindowSize)
}
ClientContextProto_WindowSize::ClientContextProto_WindowSize(const ClientContextProto_WindowSize& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&height_pixels_, &from.height_pixels_,
    static_cast<size_t>(reinterpret_cast<char*>(&width_pixels_) -
    reinterpret_cast<char*>(&height_pixels_)) + sizeof(width_pixels_));
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.ClientContextProto.WindowSize)
}

inline void ClientContextProto_WindowSize::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&height_pixels_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&width_pixels_) -
    reinterpret_cast<char*>(&height_pixels_)) + sizeof(width_pixels_));
}

ClientContextProto_WindowSize::~ClientContextProto_WindowSize() {
  // @@protoc_insertion_point(destructor:autofill_assistant.ClientContextProto.WindowSize)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ClientContextProto_WindowSize::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ClientContextProto_WindowSize::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ClientContextProto_WindowSize::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.ClientContextProto.WindowSize)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&height_pixels_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&width_pixels_) -
        reinterpret_cast<char*>(&height_pixels_)) + sizeof(width_pixels_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ClientContextProto_WindowSize::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 height_pixels = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_height_pixels(&has_bits);
          height_pixels_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 width_pixels = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_width_pixels(&has_bits);
          width_pixels_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ClientContextProto_WindowSize::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.ClientContextProto.WindowSize)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 height_pixels = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_height_pixels(), target);
  }

  // optional int32 width_pixels = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_width_pixels(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.ClientContextProto.WindowSize)
  return target;
}

size_t ClientContextProto_WindowSize::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.ClientContextProto.WindowSize)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional int32 height_pixels = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_height_pixels());
    }

    // optional int32 width_pixels = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_width_pixels());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ClientContextProto_WindowSize::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ClientContextProto_WindowSize*>(
      &from));
}

void ClientContextProto_WindowSize::MergeFrom(const ClientContextProto_WindowSize& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.ClientContextProto.WindowSize)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      height_pixels_ = from.height_pixels_;
    }
    if (cached_has_bits & 0x00000002u) {
      width_pixels_ = from.width_pixels_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClientContextProto_WindowSize::CopyFrom(const ClientContextProto_WindowSize& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.ClientContextProto.WindowSize)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClientContextProto_WindowSize::IsInitialized() const {
  return true;
}

void ClientContextProto_WindowSize::InternalSwap(ClientContextProto_WindowSize* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ClientContextProto_WindowSize, width_pixels_)
      + sizeof(ClientContextProto_WindowSize::width_pixels_)
      - PROTOBUF_FIELD_OFFSET(ClientContextProto_WindowSize, height_pixels_)>(
          reinterpret_cast<char*>(&height_pixels_),
          reinterpret_cast<char*>(&other->height_pixels_));
}

std::string ClientContextProto_WindowSize::GetTypeName() const {
  return "autofill_assistant.ClientContextProto.WindowSize";
}


// ===================================================================

class ClientContextProto_AnnotateDomModelContextProto::_Internal {
 public:
  using HasBits = decltype(std::declval<ClientContextProto_AnnotateDomModelContextProto>()._has_bits_);
  static void set_has_model_version(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_force_semantic_selection(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

ClientContextProto_AnnotateDomModelContextProto::ClientContextProto_AnnotateDomModelContextProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.ClientContextProto.AnnotateDomModelContextProto)
}
ClientContextProto_AnnotateDomModelContextProto::ClientContextProto_AnnotateDomModelContextProto(const ClientContextProto_AnnotateDomModelContextProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&model_version_, &from.model_version_,
    static_cast<size_t>(reinterpret_cast<char*>(&force_semantic_selection_) -
    reinterpret_cast<char*>(&model_version_)) + sizeof(force_semantic_selection_));
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.ClientContextProto.AnnotateDomModelContextProto)
}

inline void ClientContextProto_AnnotateDomModelContextProto::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&model_version_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&force_semantic_selection_) -
    reinterpret_cast<char*>(&model_version_)) + sizeof(force_semantic_selection_));
}

ClientContextProto_AnnotateDomModelContextProto::~ClientContextProto_AnnotateDomModelContextProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.ClientContextProto.AnnotateDomModelContextProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ClientContextProto_AnnotateDomModelContextProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ClientContextProto_AnnotateDomModelContextProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ClientContextProto_AnnotateDomModelContextProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.ClientContextProto.AnnotateDomModelContextProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&model_version_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&force_semantic_selection_) -
        reinterpret_cast<char*>(&model_version_)) + sizeof(force_semantic_selection_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ClientContextProto_AnnotateDomModelContextProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 model_version = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_model_version(&has_bits);
          model_version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool force_semantic_selection = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_force_semantic_selection(&has_bits);
          force_semantic_selection_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ClientContextProto_AnnotateDomModelContextProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.ClientContextProto.AnnotateDomModelContextProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int64 model_version = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_model_version(), target);
  }

  // optional bool force_semantic_selection = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_force_semantic_selection(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.ClientContextProto.AnnotateDomModelContextProto)
  return target;
}

size_t ClientContextProto_AnnotateDomModelContextProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.ClientContextProto.AnnotateDomModelContextProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional int64 model_version = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_model_version());
    }

    // optional bool force_semantic_selection = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ClientContextProto_AnnotateDomModelContextProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ClientContextProto_AnnotateDomModelContextProto*>(
      &from));
}

void ClientContextProto_AnnotateDomModelContextProto::MergeFrom(const ClientContextProto_AnnotateDomModelContextProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.ClientContextProto.AnnotateDomModelContextProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      model_version_ = from.model_version_;
    }
    if (cached_has_bits & 0x00000002u) {
      force_semantic_selection_ = from.force_semantic_selection_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClientContextProto_AnnotateDomModelContextProto::CopyFrom(const ClientContextProto_AnnotateDomModelContextProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.ClientContextProto.AnnotateDomModelContextProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClientContextProto_AnnotateDomModelContextProto::IsInitialized() const {
  return true;
}

void ClientContextProto_AnnotateDomModelContextProto::InternalSwap(ClientContextProto_AnnotateDomModelContextProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ClientContextProto_AnnotateDomModelContextProto, force_semantic_selection_)
      + sizeof(ClientContextProto_AnnotateDomModelContextProto::force_semantic_selection_)
      - PROTOBUF_FIELD_OFFSET(ClientContextProto_AnnotateDomModelContextProto, model_version_)>(
          reinterpret_cast<char*>(&model_version_),
          reinterpret_cast<char*>(&other->model_version_));
}

std::string ClientContextProto_AnnotateDomModelContextProto::GetTypeName() const {
  return "autofill_assistant.ClientContextProto.AnnotateDomModelContextProto";
}


// ===================================================================

class ClientContextProto::_Internal {
 public:
  using HasBits = decltype(std::declval<ClientContextProto>()._has_bits_);
  static const ::autofill_assistant::ClientContextProto_Chrome& chrome(const ClientContextProto* msg);
  static void set_has_locale(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_country(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_experiment_ids(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_is_cct(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_is_onboarding_shown(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_is_direct_action(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_is_in_chrome_triggered(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_trigger_ui_type(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static const ::autofill_assistant::ClientContextProto_DeviceContextProto& device_context(const ClientContextProto* msg);
  static void set_has_device_context(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_accounts_matching_status(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_accessibility_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_signed_into_chrome_status(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static const ::autofill_assistant::ClientContextProto_WindowSize& window_size(const ClientContextProto* msg);
  static void set_has_window_size(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_screen_orientation(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_platform_type(HasBits* has_bits) {
    (*has_bits)[0] |= 65536u;
  }
  static const ::autofill_assistant::ClientContextProto_AnnotateDomModelContextProto& annotate_dom_model_context(const ClientContextProto* msg);
  static void set_has_annotate_dom_model_context(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_js_flow_library_loaded(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
};

const ::autofill_assistant::ClientContextProto_Chrome&
ClientContextProto::_Internal::chrome(const ClientContextProto* msg) {
  return *msg->client_.chrome_;
}
const ::autofill_assistant::ClientContextProto_DeviceContextProto&
ClientContextProto::_Internal::device_context(const ClientContextProto* msg) {
  return *msg->device_context_;
}
const ::autofill_assistant::ClientContextProto_WindowSize&
ClientContextProto::_Internal::window_size(const ClientContextProto* msg) {
  return *msg->window_size_;
}
const ::autofill_assistant::ClientContextProto_AnnotateDomModelContextProto&
ClientContextProto::_Internal::annotate_dom_model_context(const ClientContextProto* msg) {
  return *msg->annotate_dom_model_context_;
}
void ClientContextProto::set_allocated_chrome(::autofill_assistant::ClientContextProto_Chrome* chrome) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_client();
  if (chrome) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(chrome);
    if (message_arena != submessage_arena) {
      chrome = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, chrome, submessage_arena);
    }
    set_has_chrome();
    client_.chrome_ = chrome;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ClientContextProto.chrome)
}
ClientContextProto::ClientContextProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.ClientContextProto)
}
ClientContextProto::ClientContextProto(const ClientContextProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  locale_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    locale_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_locale()) {
    locale_.Set(from._internal_locale(), 
      GetArenaForAllocation());
  }
  country_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    country_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_country()) {
    country_.Set(from._internal_country(), 
      GetArenaForAllocation());
  }
  experiment_ids_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    experiment_ids_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_experiment_ids()) {
    experiment_ids_.Set(from._internal_experiment_ids(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_device_context()) {
    device_context_ = new ::autofill_assistant::ClientContextProto_DeviceContextProto(*from.device_context_);
  } else {
    device_context_ = nullptr;
  }
  if (from._internal_has_window_size()) {
    window_size_ = new ::autofill_assistant::ClientContextProto_WindowSize(*from.window_size_);
  } else {
    window_size_ = nullptr;
  }
  if (from._internal_has_annotate_dom_model_context()) {
    annotate_dom_model_context_ = new ::autofill_assistant::ClientContextProto_AnnotateDomModelContextProto(*from.annotate_dom_model_context_);
  } else {
    annotate_dom_model_context_ = nullptr;
  }
  ::memcpy(&is_cct_, &from.is_cct_,
    static_cast<size_t>(reinterpret_cast<char*>(&platform_type_) -
    reinterpret_cast<char*>(&is_cct_)) + sizeof(platform_type_));
  clear_has_client();
  switch (from.client_case()) {
    case kChrome: {
      _internal_mutable_chrome()->::autofill_assistant::ClientContextProto_Chrome::MergeFrom(from._internal_chrome());
      break;
    }
    case CLIENT_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.ClientContextProto)
}

inline void ClientContextProto::SharedCtor() {
locale_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  locale_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
country_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  country_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
experiment_ids_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  experiment_ids_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&device_context_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&platform_type_) -
    reinterpret_cast<char*>(&device_context_)) + sizeof(platform_type_));
clear_has_client();
}

ClientContextProto::~ClientContextProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.ClientContextProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ClientContextProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  locale_.Destroy();
  country_.Destroy();
  experiment_ids_.Destroy();
  if (this != internal_default_instance()) delete device_context_;
  if (this != internal_default_instance()) delete window_size_;
  if (this != internal_default_instance()) delete annotate_dom_model_context_;
  if (has_client()) {
    clear_client();
  }
}

void ClientContextProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ClientContextProto::clear_client() {
// @@protoc_insertion_point(one_of_clear_start:autofill_assistant.ClientContextProto)
  switch (client_case()) {
    case kChrome: {
      if (GetArenaForAllocation() == nullptr) {
        delete client_.chrome_;
      }
      break;
    }
    case CLIENT_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = CLIENT_NOT_SET;
}


void ClientContextProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.ClientContextProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      locale_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      country_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      experiment_ids_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(device_context_ != nullptr);
      device_context_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(window_size_ != nullptr);
      window_size_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(annotate_dom_model_context_ != nullptr);
      annotate_dom_model_context_->Clear();
    }
  }
  if (cached_has_bits & 0x000000c0u) {
    ::memset(&is_cct_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&is_onboarding_shown_) -
        reinterpret_cast<char*>(&is_cct_)) + sizeof(is_onboarding_shown_));
  }
  if (cached_has_bits & 0x0000ff00u) {
    ::memset(&is_direct_action_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&js_flow_library_loaded_) -
        reinterpret_cast<char*>(&is_direct_action_)) + sizeof(js_flow_library_loaded_));
  }
  platform_type_ = 0;
  clear_client();
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ClientContextProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .autofill_assistant.ClientContextProto.Chrome chrome = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_chrome(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string locale = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_locale();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string country = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_country();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string experiment_ids = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_experiment_ids();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_cct = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_is_cct(&has_bits);
          is_cct_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_direct_action = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_is_direct_action(&has_bits);
          is_direct_action_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_onboarding_shown = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_is_onboarding_shown(&has_bits);
          is_onboarding_shown_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .autofill_assistant.ClientContextProto.DeviceContextProto device_context = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_device_context(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .autofill_assistant.ClientContextProto.AccountsMatchingStatus accounts_matching_status = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::autofill_assistant::ClientContextProto_AccountsMatchingStatus_IsValid(val))) {
            _internal_set_accounts_matching_status(static_cast<::autofill_assistant::ClientContextProto_AccountsMatchingStatus>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(12, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional bool accessibility_enabled = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          _Internal::set_has_accessibility_enabled(&has_bits);
          accessibility_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .autofill_assistant.ClientContextProto.SignedIntoChromeStatus signed_into_chrome_status = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::autofill_assistant::ClientContextProto_SignedIntoChromeStatus_IsValid(val))) {
            _internal_set_signed_into_chrome_status(static_cast<::autofill_assistant::ClientContextProto_SignedIntoChromeStatus>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(14, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .autofill_assistant.ClientContextProto.WindowSize window_size = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 122)) {
          ptr = ctx->ParseMessage(_internal_mutable_window_size(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .autofill_assistant.ClientContextProto.ScreenOrientation screen_orientation = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 128)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::autofill_assistant::ClientContextProto_ScreenOrientation_IsValid(val))) {
            _internal_set_screen_orientation(static_cast<::autofill_assistant::ClientContextProto_ScreenOrientation>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(16, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional bool is_in_chrome_triggered = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 136)) {
          _Internal::set_has_is_in_chrome_triggered(&has_bits);
          is_in_chrome_triggered_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .autofill_assistant.TriggerScriptProto.TriggerUIType trigger_ui_type = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 144)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::autofill_assistant::TriggerScriptProto_TriggerUIType_IsValid(val))) {
            _internal_set_trigger_ui_type(static_cast<::autofill_assistant::TriggerScriptProto_TriggerUIType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(18, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .autofill_assistant.ClientContextProto.PlatformType platform_type = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 160)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::autofill_assistant::ClientContextProto_PlatformType_IsValid(val))) {
            _internal_set_platform_type(static_cast<::autofill_assistant::ClientContextProto_PlatformType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(20, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .autofill_assistant.ClientContextProto.AnnotateDomModelContextProto annotate_dom_model_context = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 178)) {
          ptr = ctx->ParseMessage(_internal_mutable_annotate_dom_model_context(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool js_flow_library_loaded = 23;
      case 23:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 184)) {
          _Internal::set_has_js_flow_library_loaded(&has_bits);
          js_flow_library_loaded_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ClientContextProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.ClientContextProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .autofill_assistant.ClientContextProto.Chrome chrome = 1;
  if (_internal_has_chrome()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::chrome(this),
        _Internal::chrome(this).GetCachedSize(), target, stream);
  }

  cached_has_bits = _has_bits_[0];
  // optional string locale = 5;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_locale(), target);
  }

  // optional string country = 6;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_country(), target);
  }

  // optional string experiment_ids = 7;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteStringMaybeAliased(
        7, this->_internal_experiment_ids(), target);
  }

  // optional bool is_cct = 8;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(8, this->_internal_is_cct(), target);
  }

  // optional bool is_direct_action = 9;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(9, this->_internal_is_direct_action(), target);
  }

  // optional bool is_onboarding_shown = 10;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(10, this->_internal_is_onboarding_shown(), target);
  }

  // optional .autofill_assistant.ClientContextProto.DeviceContextProto device_context = 11;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(11, _Internal::device_context(this),
        _Internal::device_context(this).GetCachedSize(), target, stream);
  }

  // optional .autofill_assistant.ClientContextProto.AccountsMatchingStatus accounts_matching_status = 12;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      12, this->_internal_accounts_matching_status(), target);
  }

  // optional bool accessibility_enabled = 13;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(13, this->_internal_accessibility_enabled(), target);
  }

  // optional .autofill_assistant.ClientContextProto.SignedIntoChromeStatus signed_into_chrome_status = 14;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      14, this->_internal_signed_into_chrome_status(), target);
  }

  // optional .autofill_assistant.ClientContextProto.WindowSize window_size = 15;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(15, _Internal::window_size(this),
        _Internal::window_size(this).GetCachedSize(), target, stream);
  }

  // optional .autofill_assistant.ClientContextProto.ScreenOrientation screen_orientation = 16;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      16, this->_internal_screen_orientation(), target);
  }

  // optional bool is_in_chrome_triggered = 17;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(17, this->_internal_is_in_chrome_triggered(), target);
  }

  // optional .autofill_assistant.TriggerScriptProto.TriggerUIType trigger_ui_type = 18;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      18, this->_internal_trigger_ui_type(), target);
  }

  // optional .autofill_assistant.ClientContextProto.PlatformType platform_type = 20;
  if (cached_has_bits & 0x00010000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      20, this->_internal_platform_type(), target);
  }

  // optional .autofill_assistant.ClientContextProto.AnnotateDomModelContextProto annotate_dom_model_context = 22;
  if (cached_has_bits & 0x00000020u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(22, _Internal::annotate_dom_model_context(this),
        _Internal::annotate_dom_model_context(this).GetCachedSize(), target, stream);
  }

  // optional bool js_flow_library_loaded = 23;
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(23, this->_internal_js_flow_library_loaded(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.ClientContextProto)
  return target;
}

size_t ClientContextProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.ClientContextProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string locale = 5;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_locale());
    }

    // optional string country = 6;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_country());
    }

    // optional string experiment_ids = 7;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_experiment_ids());
    }

    // optional .autofill_assistant.ClientContextProto.DeviceContextProto device_context = 11;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *device_context_);
    }

    // optional .autofill_assistant.ClientContextProto.WindowSize window_size = 15;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *window_size_);
    }

    // optional .autofill_assistant.ClientContextProto.AnnotateDomModelContextProto annotate_dom_model_context = 22;
    if (cached_has_bits & 0x00000020u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *annotate_dom_model_context_);
    }

    // optional bool is_cct = 8;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 1;
    }

    // optional bool is_onboarding_shown = 10;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 1;
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional bool is_direct_action = 9;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 1;
    }

    // optional bool is_in_chrome_triggered = 17;
    if (cached_has_bits & 0x00000200u) {
      total_size += 2 + 1;
    }

    // optional .autofill_assistant.ClientContextProto.AccountsMatchingStatus accounts_matching_status = 12;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_accounts_matching_status());
    }

    // optional .autofill_assistant.ClientContextProto.SignedIntoChromeStatus signed_into_chrome_status = 14;
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_signed_into_chrome_status());
    }

    // optional .autofill_assistant.ClientContextProto.ScreenOrientation screen_orientation = 16;
    if (cached_has_bits & 0x00001000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_screen_orientation());
    }

    // optional .autofill_assistant.TriggerScriptProto.TriggerUIType trigger_ui_type = 18;
    if (cached_has_bits & 0x00002000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_trigger_ui_type());
    }

    // optional bool accessibility_enabled = 13;
    if (cached_has_bits & 0x00004000u) {
      total_size += 1 + 1;
    }

    // optional bool js_flow_library_loaded = 23;
    if (cached_has_bits & 0x00008000u) {
      total_size += 2 + 1;
    }

  }
  // optional .autofill_assistant.ClientContextProto.PlatformType platform_type = 20;
  if (cached_has_bits & 0x00010000u) {
    total_size += 2 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_platform_type());
  }

  switch (client_case()) {
    // .autofill_assistant.ClientContextProto.Chrome chrome = 1;
    case kChrome: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *client_.chrome_);
      break;
    }
    case CLIENT_NOT_SET: {
      break;
    }
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ClientContextProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ClientContextProto*>(
      &from));
}

void ClientContextProto::MergeFrom(const ClientContextProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.ClientContextProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_locale(from._internal_locale());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_country(from._internal_country());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_experiment_ids(from._internal_experiment_ids());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_mutable_device_context()->::autofill_assistant::ClientContextProto_DeviceContextProto::MergeFrom(from._internal_device_context());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_mutable_window_size()->::autofill_assistant::ClientContextProto_WindowSize::MergeFrom(from._internal_window_size());
    }
    if (cached_has_bits & 0x00000020u) {
      _internal_mutable_annotate_dom_model_context()->::autofill_assistant::ClientContextProto_AnnotateDomModelContextProto::MergeFrom(from._internal_annotate_dom_model_context());
    }
    if (cached_has_bits & 0x00000040u) {
      is_cct_ = from.is_cct_;
    }
    if (cached_has_bits & 0x00000080u) {
      is_onboarding_shown_ = from.is_onboarding_shown_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      is_direct_action_ = from.is_direct_action_;
    }
    if (cached_has_bits & 0x00000200u) {
      is_in_chrome_triggered_ = from.is_in_chrome_triggered_;
    }
    if (cached_has_bits & 0x00000400u) {
      accounts_matching_status_ = from.accounts_matching_status_;
    }
    if (cached_has_bits & 0x00000800u) {
      signed_into_chrome_status_ = from.signed_into_chrome_status_;
    }
    if (cached_has_bits & 0x00001000u) {
      screen_orientation_ = from.screen_orientation_;
    }
    if (cached_has_bits & 0x00002000u) {
      trigger_ui_type_ = from.trigger_ui_type_;
    }
    if (cached_has_bits & 0x00004000u) {
      accessibility_enabled_ = from.accessibility_enabled_;
    }
    if (cached_has_bits & 0x00008000u) {
      js_flow_library_loaded_ = from.js_flow_library_loaded_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00010000u) {
    _internal_set_platform_type(from._internal_platform_type());
  }
  switch (from.client_case()) {
    case kChrome: {
      _internal_mutable_chrome()->::autofill_assistant::ClientContextProto_Chrome::MergeFrom(from._internal_chrome());
      break;
    }
    case CLIENT_NOT_SET: {
      break;
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClientContextProto::CopyFrom(const ClientContextProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.ClientContextProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClientContextProto::IsInitialized() const {
  return true;
}

void ClientContextProto::InternalSwap(ClientContextProto* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &locale_, lhs_arena,
      &other->locale_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &country_, lhs_arena,
      &other->country_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &experiment_ids_, lhs_arena,
      &other->experiment_ids_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ClientContextProto, platform_type_)
      + sizeof(ClientContextProto::platform_type_)
      - PROTOBUF_FIELD_OFFSET(ClientContextProto, device_context_)>(
          reinterpret_cast<char*>(&device_context_),
          reinterpret_cast<char*>(&other->device_context_));
  swap(client_, other->client_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

std::string ClientContextProto::GetTypeName() const {
  return "autofill_assistant.ClientContextProto";
}


// ===================================================================

class SupportsScriptRequestProto::_Internal {
 public:
  using HasBits = decltype(std::declval<SupportsScriptRequestProto>()._has_bits_);
  static void set_has_url(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::autofill_assistant::ClientContextProto& client_context(const SupportsScriptRequestProto* msg);
  static void set_has_client_context(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::autofill_assistant::ClientContextProto&
SupportsScriptRequestProto::_Internal::client_context(const SupportsScriptRequestProto* msg) {
  return *msg->client_context_;
}
SupportsScriptRequestProto::SupportsScriptRequestProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  script_parameters_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.SupportsScriptRequestProto)
}
SupportsScriptRequestProto::SupportsScriptRequestProto(const SupportsScriptRequestProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      script_parameters_(from.script_parameters_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_url()) {
    url_.Set(from._internal_url(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_client_context()) {
    client_context_ = new ::autofill_assistant::ClientContextProto(*from.client_context_);
  } else {
    client_context_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.SupportsScriptRequestProto)
}

inline void SupportsScriptRequestProto::SharedCtor() {
url_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  url_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
client_context_ = nullptr;
}

SupportsScriptRequestProto::~SupportsScriptRequestProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.SupportsScriptRequestProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SupportsScriptRequestProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  url_.Destroy();
  if (this != internal_default_instance()) delete client_context_;
}

void SupportsScriptRequestProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SupportsScriptRequestProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.SupportsScriptRequestProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  script_parameters_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      url_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(client_context_ != nullptr);
      client_context_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* SupportsScriptRequestProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string url = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_url();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .autofill_assistant.ScriptParameterProto script_parameters = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_script_parameters(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .autofill_assistant.ClientContextProto client_context = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_client_context(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SupportsScriptRequestProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.SupportsScriptRequestProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string url = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_url(), target);
  }

  // repeated .autofill_assistant.ScriptParameterProto script_parameters = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_script_parameters_size()); i < n; i++) {
    const auto& repfield = this->_internal_script_parameters(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional .autofill_assistant.ClientContextProto client_context = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::client_context(this),
        _Internal::client_context(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.SupportsScriptRequestProto)
  return target;
}

size_t SupportsScriptRequestProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.SupportsScriptRequestProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .autofill_assistant.ScriptParameterProto script_parameters = 2;
  total_size += 1UL * this->_internal_script_parameters_size();
  for (const auto& msg : this->script_parameters_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string url = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_url());
    }

    // optional .autofill_assistant.ClientContextProto client_context = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *client_context_);
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SupportsScriptRequestProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const SupportsScriptRequestProto*>(
      &from));
}

void SupportsScriptRequestProto::MergeFrom(const SupportsScriptRequestProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.SupportsScriptRequestProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  script_parameters_.MergeFrom(from.script_parameters_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_url(from._internal_url());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_client_context()->::autofill_assistant::ClientContextProto::MergeFrom(from._internal_client_context());
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SupportsScriptRequestProto::CopyFrom(const SupportsScriptRequestProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.SupportsScriptRequestProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SupportsScriptRequestProto::IsInitialized() const {
  return true;
}

void SupportsScriptRequestProto::InternalSwap(SupportsScriptRequestProto* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  script_parameters_.InternalSwap(&other->script_parameters_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &url_, lhs_arena,
      &other->url_, rhs_arena
  );
  swap(client_context_, other->client_context_);
}

std::string SupportsScriptRequestProto::GetTypeName() const {
  return "autofill_assistant.SupportsScriptRequestProto";
}


// ===================================================================

class ImplicitTriggeringDebugParametersProto::_Internal {
 public:
};

ImplicitTriggeringDebugParametersProto::ImplicitTriggeringDebugParametersProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  additional_script_parameters_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.ImplicitTriggeringDebugParametersProto)
}
ImplicitTriggeringDebugParametersProto::ImplicitTriggeringDebugParametersProto(const ImplicitTriggeringDebugParametersProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      additional_script_parameters_(from.additional_script_parameters_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.ImplicitTriggeringDebugParametersProto)
}

inline void ImplicitTriggeringDebugParametersProto::SharedCtor() {
}

ImplicitTriggeringDebugParametersProto::~ImplicitTriggeringDebugParametersProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.ImplicitTriggeringDebugParametersProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ImplicitTriggeringDebugParametersProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ImplicitTriggeringDebugParametersProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ImplicitTriggeringDebugParametersProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.ImplicitTriggeringDebugParametersProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  additional_script_parameters_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ImplicitTriggeringDebugParametersProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .autofill_assistant.ScriptParameterProto additional_script_parameters = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_additional_script_parameters(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ImplicitTriggeringDebugParametersProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.ImplicitTriggeringDebugParametersProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .autofill_assistant.ScriptParameterProto additional_script_parameters = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_additional_script_parameters_size()); i < n; i++) {
    const auto& repfield = this->_internal_additional_script_parameters(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.ImplicitTriggeringDebugParametersProto)
  return target;
}

size_t ImplicitTriggeringDebugParametersProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.ImplicitTriggeringDebugParametersProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .autofill_assistant.ScriptParameterProto additional_script_parameters = 1;
  total_size += 1UL * this->_internal_additional_script_parameters_size();
  for (const auto& msg : this->additional_script_parameters_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ImplicitTriggeringDebugParametersProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ImplicitTriggeringDebugParametersProto*>(
      &from));
}

void ImplicitTriggeringDebugParametersProto::MergeFrom(const ImplicitTriggeringDebugParametersProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.ImplicitTriggeringDebugParametersProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  additional_script_parameters_.MergeFrom(from.additional_script_parameters_);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ImplicitTriggeringDebugParametersProto::CopyFrom(const ImplicitTriggeringDebugParametersProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.ImplicitTriggeringDebugParametersProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ImplicitTriggeringDebugParametersProto::IsInitialized() const {
  return true;
}

void ImplicitTriggeringDebugParametersProto::InternalSwap(ImplicitTriggeringDebugParametersProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  additional_script_parameters_.InternalSwap(&other->additional_script_parameters_);
}

std::string ImplicitTriggeringDebugParametersProto::GetTypeName() const {
  return "autofill_assistant.ImplicitTriggeringDebugParametersProto";
}


// ===================================================================

class ScriptParameterProto::_Internal {
 public:
  using HasBits = decltype(std::declval<ScriptParameterProto>()._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_value(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

ScriptParameterProto::ScriptParameterProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.ScriptParameterProto)
}
ScriptParameterProto::ScriptParameterProto(const ScriptParameterProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  value_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    value_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_value()) {
    value_.Set(from._internal_value(), 
      GetArenaForAllocation());
  }
  name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    name_.Set(from._internal_name(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.ScriptParameterProto)
}

inline void ScriptParameterProto::SharedCtor() {
value_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  value_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ScriptParameterProto::~ScriptParameterProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.ScriptParameterProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ScriptParameterProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  value_.Destroy();
  name_.Destroy();
}

void ScriptParameterProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ScriptParameterProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.ScriptParameterProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      value_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      name_.ClearNonDefaultToEmpty();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ScriptParameterProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string value = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_value();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string name = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ScriptParameterProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.ScriptParameterProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string value = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_value(), target);
  }

  // optional string name = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_name(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.ScriptParameterProto)
  return target;
}

size_t ScriptParameterProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.ScriptParameterProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string value = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_value());
    }

    // optional string name = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ScriptParameterProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ScriptParameterProto*>(
      &from));
}

void ScriptParameterProto::MergeFrom(const ScriptParameterProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.ScriptParameterProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_value(from._internal_value());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_name(from._internal_name());
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ScriptParameterProto::CopyFrom(const ScriptParameterProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.ScriptParameterProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ScriptParameterProto::IsInitialized() const {
  return true;
}

void ScriptParameterProto::InternalSwap(ScriptParameterProto* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &value_, lhs_arena,
      &other->value_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &name_, lhs_arena,
      &other->name_, rhs_arena
  );
}

std::string ScriptParameterProto::GetTypeName() const {
  return "autofill_assistant.ScriptParameterProto";
}


// ===================================================================

class SupportsScriptResponseProto::_Internal {
 public:
  using HasBits = decltype(std::declval<SupportsScriptResponseProto>()._has_bits_);
  static const ::autofill_assistant::ScriptTimeoutError& script_timeout_error(const SupportsScriptResponseProto* msg);
  static void set_has_script_timeout_error(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::autofill_assistant::ClientSettingsProto& client_settings(const SupportsScriptResponseProto* msg);
  static void set_has_client_settings(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::autofill_assistant::ScriptStoreConfig& script_store_config(const SupportsScriptResponseProto* msg);
  static void set_has_script_store_config(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::autofill_assistant::SemanticSelectorPolicy& semantic_selector_policy(const SupportsScriptResponseProto* msg);
  static void set_has_semantic_selector_policy(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::autofill_assistant::ScriptTimeoutError&
SupportsScriptResponseProto::_Internal::script_timeout_error(const SupportsScriptResponseProto* msg) {
  return *msg->script_timeout_error_;
}
const ::autofill_assistant::ClientSettingsProto&
SupportsScriptResponseProto::_Internal::client_settings(const SupportsScriptResponseProto* msg) {
  return *msg->client_settings_;
}
const ::autofill_assistant::ScriptStoreConfig&
SupportsScriptResponseProto::_Internal::script_store_config(const SupportsScriptResponseProto* msg) {
  return *msg->script_store_config_;
}
const ::autofill_assistant::SemanticSelectorPolicy&
SupportsScriptResponseProto::_Internal::semantic_selector_policy(const SupportsScriptResponseProto* msg) {
  return *msg->semantic_selector_policy_;
}
void SupportsScriptResponseProto::clear_semantic_selector_policy() {
  if (semantic_selector_policy_ != nullptr) semantic_selector_policy_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
SupportsScriptResponseProto::SupportsScriptResponseProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  scripts_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.SupportsScriptResponseProto)
}
SupportsScriptResponseProto::SupportsScriptResponseProto(const SupportsScriptResponseProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      scripts_(from.scripts_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_script_timeout_error()) {
    script_timeout_error_ = new ::autofill_assistant::ScriptTimeoutError(*from.script_timeout_error_);
  } else {
    script_timeout_error_ = nullptr;
  }
  if (from._internal_has_client_settings()) {
    client_settings_ = new ::autofill_assistant::ClientSettingsProto(*from.client_settings_);
  } else {
    client_settings_ = nullptr;
  }
  if (from._internal_has_script_store_config()) {
    script_store_config_ = new ::autofill_assistant::ScriptStoreConfig(*from.script_store_config_);
  } else {
    script_store_config_ = nullptr;
  }
  if (from._internal_has_semantic_selector_policy()) {
    semantic_selector_policy_ = new ::autofill_assistant::SemanticSelectorPolicy(*from.semantic_selector_policy_);
  } else {
    semantic_selector_policy_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.SupportsScriptResponseProto)
}

inline void SupportsScriptResponseProto::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&script_timeout_error_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&semantic_selector_policy_) -
    reinterpret_cast<char*>(&script_timeout_error_)) + sizeof(semantic_selector_policy_));
}

SupportsScriptResponseProto::~SupportsScriptResponseProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.SupportsScriptResponseProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SupportsScriptResponseProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete script_timeout_error_;
  if (this != internal_default_instance()) delete client_settings_;
  if (this != internal_default_instance()) delete script_store_config_;
  if (this != internal_default_instance()) delete semantic_selector_policy_;
}

void SupportsScriptResponseProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SupportsScriptResponseProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.SupportsScriptResponseProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  scripts_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(script_timeout_error_ != nullptr);
      script_timeout_error_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(client_settings_ != nullptr);
      client_settings_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(script_store_config_ != nullptr);
      script_store_config_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(semantic_selector_policy_ != nullptr);
      semantic_selector_policy_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* SupportsScriptResponseProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .autofill_assistant.SupportedScriptProto scripts = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_scripts(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .autofill_assistant.ScriptTimeoutError script_timeout_error = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_script_timeout_error(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .autofill_assistant.ClientSettingsProto client_settings = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_client_settings(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .autofill_assistant.ScriptStoreConfig script_store_config = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_script_store_config(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .autofill_assistant.SemanticSelectorPolicy semantic_selector_policy = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_semantic_selector_policy(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SupportsScriptResponseProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.SupportsScriptResponseProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .autofill_assistant.SupportedScriptProto scripts = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_scripts_size()); i < n; i++) {
    const auto& repfield = this->_internal_scripts(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  cached_has_bits = _has_bits_[0];
  // optional .autofill_assistant.ScriptTimeoutError script_timeout_error = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::script_timeout_error(this),
        _Internal::script_timeout_error(this).GetCachedSize(), target, stream);
  }

  // optional .autofill_assistant.ClientSettingsProto client_settings = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::client_settings(this),
        _Internal::client_settings(this).GetCachedSize(), target, stream);
  }

  // optional .autofill_assistant.ScriptStoreConfig script_store_config = 6;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::script_store_config(this),
        _Internal::script_store_config(this).GetCachedSize(), target, stream);
  }

  // optional .autofill_assistant.SemanticSelectorPolicy semantic_selector_policy = 7;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::semantic_selector_policy(this),
        _Internal::semantic_selector_policy(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.SupportsScriptResponseProto)
  return target;
}

size_t SupportsScriptResponseProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.SupportsScriptResponseProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .autofill_assistant.SupportedScriptProto scripts = 1;
  total_size += 1UL * this->_internal_scripts_size();
  for (const auto& msg : this->scripts_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional .autofill_assistant.ScriptTimeoutError script_timeout_error = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *script_timeout_error_);
    }

    // optional .autofill_assistant.ClientSettingsProto client_settings = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *client_settings_);
    }

    // optional .autofill_assistant.ScriptStoreConfig script_store_config = 6;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *script_store_config_);
    }

    // optional .autofill_assistant.SemanticSelectorPolicy semantic_selector_policy = 7;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *semantic_selector_policy_);
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SupportsScriptResponseProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const SupportsScriptResponseProto*>(
      &from));
}

void SupportsScriptResponseProto::MergeFrom(const SupportsScriptResponseProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.SupportsScriptResponseProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  scripts_.MergeFrom(from.scripts_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_script_timeout_error()->::autofill_assistant::ScriptTimeoutError::MergeFrom(from._internal_script_timeout_error());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_client_settings()->::autofill_assistant::ClientSettingsProto::MergeFrom(from._internal_client_settings());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_script_store_config()->::autofill_assistant::ScriptStoreConfig::MergeFrom(from._internal_script_store_config());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_mutable_semantic_selector_policy()->::autofill_assistant::SemanticSelectorPolicy::MergeFrom(from._internal_semantic_selector_policy());
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SupportsScriptResponseProto::CopyFrom(const SupportsScriptResponseProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.SupportsScriptResponseProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SupportsScriptResponseProto::IsInitialized() const {
  return true;
}

void SupportsScriptResponseProto::InternalSwap(SupportsScriptResponseProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  scripts_.InternalSwap(&other->scripts_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SupportsScriptResponseProto, semantic_selector_policy_)
      + sizeof(SupportsScriptResponseProto::semantic_selector_policy_)
      - PROTOBUF_FIELD_OFFSET(SupportsScriptResponseProto, script_timeout_error_)>(
          reinterpret_cast<char*>(&script_timeout_error_),
          reinterpret_cast<char*>(&other->script_timeout_error_));
}

std::string SupportsScriptResponseProto::GetTypeName() const {
  return "autofill_assistant.SupportsScriptResponseProto";
}


// ===================================================================

class GetCapabilitiesByHashPrefixRequestProto::_Internal {
 public:
  using HasBits = decltype(std::declval<GetCapabilitiesByHashPrefixRequestProto>()._has_bits_);
  static void set_has_hash_prefix_length(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::autofill_assistant::ClientContextProto& client_context(const GetCapabilitiesByHashPrefixRequestProto* msg);
  static void set_has_client_context(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::autofill_assistant::ClientContextProto&
GetCapabilitiesByHashPrefixRequestProto::_Internal::client_context(const GetCapabilitiesByHashPrefixRequestProto* msg) {
  return *msg->client_context_;
}
GetCapabilitiesByHashPrefixRequestProto::GetCapabilitiesByHashPrefixRequestProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  hash_prefix_(arena),
  script_parameters_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.GetCapabilitiesByHashPrefixRequestProto)
}
GetCapabilitiesByHashPrefixRequestProto::GetCapabilitiesByHashPrefixRequestProto(const GetCapabilitiesByHashPrefixRequestProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      hash_prefix_(from.hash_prefix_),
      script_parameters_(from.script_parameters_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_client_context()) {
    client_context_ = new ::autofill_assistant::ClientContextProto(*from.client_context_);
  } else {
    client_context_ = nullptr;
  }
  hash_prefix_length_ = from.hash_prefix_length_;
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.GetCapabilitiesByHashPrefixRequestProto)
}

inline void GetCapabilitiesByHashPrefixRequestProto::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&client_context_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&hash_prefix_length_) -
    reinterpret_cast<char*>(&client_context_)) + sizeof(hash_prefix_length_));
}

GetCapabilitiesByHashPrefixRequestProto::~GetCapabilitiesByHashPrefixRequestProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.GetCapabilitiesByHashPrefixRequestProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GetCapabilitiesByHashPrefixRequestProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete client_context_;
}

void GetCapabilitiesByHashPrefixRequestProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void GetCapabilitiesByHashPrefixRequestProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.GetCapabilitiesByHashPrefixRequestProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  hash_prefix_.Clear();
  script_parameters_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(client_context_ != nullptr);
    client_context_->Clear();
  }
  hash_prefix_length_ = 0u;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* GetCapabilitiesByHashPrefixRequestProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 hash_prefix_length = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_hash_prefix_length(&has_bits);
          hash_prefix_length_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint64 hash_prefix = 2 [packed = true];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt64Parser(_internal_mutable_hash_prefix(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 16) {
          _internal_add_hash_prefix(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .autofill_assistant.ClientContextProto client_context = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_client_context(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .autofill_assistant.ScriptParameterProto script_parameters = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_script_parameters(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GetCapabilitiesByHashPrefixRequestProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.GetCapabilitiesByHashPrefixRequestProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 hash_prefix_length = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_hash_prefix_length(), target);
  }

  // repeated uint64 hash_prefix = 2 [packed = true];
  {
    int byte_size = _hash_prefix_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteUInt64Packed(
          2, _internal_hash_prefix(), byte_size, target);
    }
  }

  // optional .autofill_assistant.ClientContextProto client_context = 3;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::client_context(this),
        _Internal::client_context(this).GetCachedSize(), target, stream);
  }

  // repeated .autofill_assistant.ScriptParameterProto script_parameters = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_script_parameters_size()); i < n; i++) {
    const auto& repfield = this->_internal_script_parameters(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.GetCapabilitiesByHashPrefixRequestProto)
  return target;
}

size_t GetCapabilitiesByHashPrefixRequestProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.GetCapabilitiesByHashPrefixRequestProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint64 hash_prefix = 2 [packed = true];
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt64Size(this->hash_prefix_);
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    int cached_size = ::_pbi::ToCachedSize(data_size);
    _hash_prefix_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // repeated .autofill_assistant.ScriptParameterProto script_parameters = 4;
  total_size += 1UL * this->_internal_script_parameters_size();
  for (const auto& msg : this->script_parameters_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .autofill_assistant.ClientContextProto client_context = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *client_context_);
    }

    // optional uint32 hash_prefix_length = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_hash_prefix_length());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void GetCapabilitiesByHashPrefixRequestProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const GetCapabilitiesByHashPrefixRequestProto*>(
      &from));
}

void GetCapabilitiesByHashPrefixRequestProto::MergeFrom(const GetCapabilitiesByHashPrefixRequestProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.GetCapabilitiesByHashPrefixRequestProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  hash_prefix_.MergeFrom(from.hash_prefix_);
  script_parameters_.MergeFrom(from.script_parameters_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_client_context()->::autofill_assistant::ClientContextProto::MergeFrom(from._internal_client_context());
    }
    if (cached_has_bits & 0x00000002u) {
      hash_prefix_length_ = from.hash_prefix_length_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void GetCapabilitiesByHashPrefixRequestProto::CopyFrom(const GetCapabilitiesByHashPrefixRequestProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.GetCapabilitiesByHashPrefixRequestProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetCapabilitiesByHashPrefixRequestProto::IsInitialized() const {
  return true;
}

void GetCapabilitiesByHashPrefixRequestProto::InternalSwap(GetCapabilitiesByHashPrefixRequestProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  hash_prefix_.InternalSwap(&other->hash_prefix_);
  script_parameters_.InternalSwap(&other->script_parameters_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(GetCapabilitiesByHashPrefixRequestProto, hash_prefix_length_)
      + sizeof(GetCapabilitiesByHashPrefixRequestProto::hash_prefix_length_)
      - PROTOBUF_FIELD_OFFSET(GetCapabilitiesByHashPrefixRequestProto, client_context_)>(
          reinterpret_cast<char*>(&client_context_),
          reinterpret_cast<char*>(&other->client_context_));
}

std::string GetCapabilitiesByHashPrefixRequestProto::GetTypeName() const {
  return "autofill_assistant.GetCapabilitiesByHashPrefixRequestProto";
}


// ===================================================================

class GetCapabilitiesByHashPrefixResponseProto_MatchInfoProto::_Internal {
 public:
  using HasBits = decltype(std::declval<GetCapabilitiesByHashPrefixResponseProto_MatchInfoProto>()._has_bits_);
  static void set_has_url_match(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

GetCapabilitiesByHashPrefixResponseProto_MatchInfoProto::GetCapabilitiesByHashPrefixResponseProto_MatchInfoProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  script_parameters_override_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.GetCapabilitiesByHashPrefixResponseProto.MatchInfoProto)
}
GetCapabilitiesByHashPrefixResponseProto_MatchInfoProto::GetCapabilitiesByHashPrefixResponseProto_MatchInfoProto(const GetCapabilitiesByHashPrefixResponseProto_MatchInfoProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      script_parameters_override_(from.script_parameters_override_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  url_match_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    url_match_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_url_match()) {
    url_match_.Set(from._internal_url_match(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.GetCapabilitiesByHashPrefixResponseProto.MatchInfoProto)
}

inline void GetCapabilitiesByHashPrefixResponseProto_MatchInfoProto::SharedCtor() {
url_match_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  url_match_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

GetCapabilitiesByHashPrefixResponseProto_MatchInfoProto::~GetCapabilitiesByHashPrefixResponseProto_MatchInfoProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.GetCapabilitiesByHashPrefixResponseProto.MatchInfoProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GetCapabilitiesByHashPrefixResponseProto_MatchInfoProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  url_match_.Destroy();
}

void GetCapabilitiesByHashPrefixResponseProto_MatchInfoProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void GetCapabilitiesByHashPrefixResponseProto_MatchInfoProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.GetCapabilitiesByHashPrefixResponseProto.MatchInfoProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  script_parameters_override_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    url_match_.ClearNonDefaultToEmpty();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* GetCapabilitiesByHashPrefixResponseProto_MatchInfoProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string url_match = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_url_match();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .autofill_assistant.ScriptParameterProto script_parameters_override = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_script_parameters_override(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GetCapabilitiesByHashPrefixResponseProto_MatchInfoProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.GetCapabilitiesByHashPrefixResponseProto.MatchInfoProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string url_match = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_url_match(), target);
  }

  // repeated .autofill_assistant.ScriptParameterProto script_parameters_override = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_script_parameters_override_size()); i < n; i++) {
    const auto& repfield = this->_internal_script_parameters_override(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.GetCapabilitiesByHashPrefixResponseProto.MatchInfoProto)
  return target;
}

size_t GetCapabilitiesByHashPrefixResponseProto_MatchInfoProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.GetCapabilitiesByHashPrefixResponseProto.MatchInfoProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .autofill_assistant.ScriptParameterProto script_parameters_override = 2;
  total_size += 1UL * this->_internal_script_parameters_override_size();
  for (const auto& msg : this->script_parameters_override_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional string url_match = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_url_match());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void GetCapabilitiesByHashPrefixResponseProto_MatchInfoProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const GetCapabilitiesByHashPrefixResponseProto_MatchInfoProto*>(
      &from));
}

void GetCapabilitiesByHashPrefixResponseProto_MatchInfoProto::MergeFrom(const GetCapabilitiesByHashPrefixResponseProto_MatchInfoProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.GetCapabilitiesByHashPrefixResponseProto.MatchInfoProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  script_parameters_override_.MergeFrom(from.script_parameters_override_);
  if (from._internal_has_url_match()) {
    _internal_set_url_match(from._internal_url_match());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void GetCapabilitiesByHashPrefixResponseProto_MatchInfoProto::CopyFrom(const GetCapabilitiesByHashPrefixResponseProto_MatchInfoProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.GetCapabilitiesByHashPrefixResponseProto.MatchInfoProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetCapabilitiesByHashPrefixResponseProto_MatchInfoProto::IsInitialized() const {
  return true;
}

void GetCapabilitiesByHashPrefixResponseProto_MatchInfoProto::InternalSwap(GetCapabilitiesByHashPrefixResponseProto_MatchInfoProto* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  script_parameters_override_.InternalSwap(&other->script_parameters_override_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &url_match_, lhs_arena,
      &other->url_match_, rhs_arena
  );
}

std::string GetCapabilitiesByHashPrefixResponseProto_MatchInfoProto::GetTypeName() const {
  return "autofill_assistant.GetCapabilitiesByHashPrefixResponseProto.MatchInfoProto";
}


// ===================================================================

class GetCapabilitiesByHashPrefixResponseProto::_Internal {
 public:
};

GetCapabilitiesByHashPrefixResponseProto::GetCapabilitiesByHashPrefixResponseProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  match_info_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.GetCapabilitiesByHashPrefixResponseProto)
}
GetCapabilitiesByHashPrefixResponseProto::GetCapabilitiesByHashPrefixResponseProto(const GetCapabilitiesByHashPrefixResponseProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      match_info_(from.match_info_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.GetCapabilitiesByHashPrefixResponseProto)
}

inline void GetCapabilitiesByHashPrefixResponseProto::SharedCtor() {
}

GetCapabilitiesByHashPrefixResponseProto::~GetCapabilitiesByHashPrefixResponseProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.GetCapabilitiesByHashPrefixResponseProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GetCapabilitiesByHashPrefixResponseProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void GetCapabilitiesByHashPrefixResponseProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void GetCapabilitiesByHashPrefixResponseProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.GetCapabilitiesByHashPrefixResponseProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  match_info_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* GetCapabilitiesByHashPrefixResponseProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .autofill_assistant.GetCapabilitiesByHashPrefixResponseProto.MatchInfoProto match_info = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_match_info(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GetCapabilitiesByHashPrefixResponseProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.GetCapabilitiesByHashPrefixResponseProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .autofill_assistant.GetCapabilitiesByHashPrefixResponseProto.MatchInfoProto match_info = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_match_info_size()); i < n; i++) {
    const auto& repfield = this->_internal_match_info(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.GetCapabilitiesByHashPrefixResponseProto)
  return target;
}

size_t GetCapabilitiesByHashPrefixResponseProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.GetCapabilitiesByHashPrefixResponseProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .autofill_assistant.GetCapabilitiesByHashPrefixResponseProto.MatchInfoProto match_info = 1;
  total_size += 1UL * this->_internal_match_info_size();
  for (const auto& msg : this->match_info_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void GetCapabilitiesByHashPrefixResponseProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const GetCapabilitiesByHashPrefixResponseProto*>(
      &from));
}

void GetCapabilitiesByHashPrefixResponseProto::MergeFrom(const GetCapabilitiesByHashPrefixResponseProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.GetCapabilitiesByHashPrefixResponseProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  match_info_.MergeFrom(from.match_info_);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void GetCapabilitiesByHashPrefixResponseProto::CopyFrom(const GetCapabilitiesByHashPrefixResponseProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.GetCapabilitiesByHashPrefixResponseProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetCapabilitiesByHashPrefixResponseProto::IsInitialized() const {
  return true;
}

void GetCapabilitiesByHashPrefixResponseProto::InternalSwap(GetCapabilitiesByHashPrefixResponseProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  match_info_.InternalSwap(&other->match_info_);
}

std::string GetCapabilitiesByHashPrefixResponseProto::GetTypeName() const {
  return "autofill_assistant.GetCapabilitiesByHashPrefixResponseProto";
}


// ===================================================================

class GetUserDataRequestProto_PaymentMethodRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<GetUserDataRequestProto_PaymentMethodRequest>()._has_bits_);
  static void set_has_client_token(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

GetUserDataRequestProto_PaymentMethodRequest::GetUserDataRequestProto_PaymentMethodRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  supported_card_networks_(arena),
  preexisting_ids_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.GetUserDataRequestProto.PaymentMethodRequest)
}
GetUserDataRequestProto_PaymentMethodRequest::GetUserDataRequestProto_PaymentMethodRequest(const GetUserDataRequestProto_PaymentMethodRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      supported_card_networks_(from.supported_card_networks_),
      preexisting_ids_(from.preexisting_ids_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  client_token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    client_token_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_client_token()) {
    client_token_.Set(from._internal_client_token(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.GetUserDataRequestProto.PaymentMethodRequest)
}

inline void GetUserDataRequestProto_PaymentMethodRequest::SharedCtor() {
client_token_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  client_token_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

GetUserDataRequestProto_PaymentMethodRequest::~GetUserDataRequestProto_PaymentMethodRequest() {
  // @@protoc_insertion_point(destructor:autofill_assistant.GetUserDataRequestProto.PaymentMethodRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GetUserDataRequestProto_PaymentMethodRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  client_token_.Destroy();
}

void GetUserDataRequestProto_PaymentMethodRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void GetUserDataRequestProto_PaymentMethodRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.GetUserDataRequestProto.PaymentMethodRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  supported_card_networks_.Clear();
  preexisting_ids_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    client_token_.ClearNonDefaultToEmpty();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* GetUserDataRequestProto_PaymentMethodRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes client_token = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_client_token();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated string supported_card_networks = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_supported_card_networks();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated string preexisting_ids = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_preexisting_ids();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GetUserDataRequestProto_PaymentMethodRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.GetUserDataRequestProto.PaymentMethodRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bytes client_token = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_client_token(), target);
  }

  // repeated string supported_card_networks = 2;
  for (int i = 0, n = this->_internal_supported_card_networks_size(); i < n; i++) {
    const auto& s = this->_internal_supported_card_networks(i);
    target = stream->WriteString(2, s, target);
  }

  // repeated string preexisting_ids = 3;
  for (int i = 0, n = this->_internal_preexisting_ids_size(); i < n; i++) {
    const auto& s = this->_internal_preexisting_ids(i);
    target = stream->WriteString(3, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.GetUserDataRequestProto.PaymentMethodRequest)
  return target;
}

size_t GetUserDataRequestProto_PaymentMethodRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.GetUserDataRequestProto.PaymentMethodRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string supported_card_networks = 2;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(supported_card_networks_.size());
  for (int i = 0, n = supported_card_networks_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      supported_card_networks_.Get(i));
  }

  // repeated string preexisting_ids = 3;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(preexisting_ids_.size());
  for (int i = 0, n = preexisting_ids_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      preexisting_ids_.Get(i));
  }

  // optional bytes client_token = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_client_token());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void GetUserDataRequestProto_PaymentMethodRequest::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const GetUserDataRequestProto_PaymentMethodRequest*>(
      &from));
}

void GetUserDataRequestProto_PaymentMethodRequest::MergeFrom(const GetUserDataRequestProto_PaymentMethodRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.GetUserDataRequestProto.PaymentMethodRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  supported_card_networks_.MergeFrom(from.supported_card_networks_);
  preexisting_ids_.MergeFrom(from.preexisting_ids_);
  if (from._internal_has_client_token()) {
    _internal_set_client_token(from._internal_client_token());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void GetUserDataRequestProto_PaymentMethodRequest::CopyFrom(const GetUserDataRequestProto_PaymentMethodRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.GetUserDataRequestProto.PaymentMethodRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetUserDataRequestProto_PaymentMethodRequest::IsInitialized() const {
  return true;
}

void GetUserDataRequestProto_PaymentMethodRequest::InternalSwap(GetUserDataRequestProto_PaymentMethodRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  supported_card_networks_.InternalSwap(&other->supported_card_networks_);
  preexisting_ids_.InternalSwap(&other->preexisting_ids_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &client_token_, lhs_arena,
      &other->client_token_, rhs_arena
  );
}

std::string GetUserDataRequestProto_PaymentMethodRequest::GetTypeName() const {
  return "autofill_assistant.GetUserDataRequestProto.PaymentMethodRequest";
}


// ===================================================================

class GetUserDataRequestProto_AddressRequest::_Internal {
 public:
};

GetUserDataRequestProto_AddressRequest::GetUserDataRequestProto_AddressRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  preexisting_ids_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.GetUserDataRequestProto.AddressRequest)
}
GetUserDataRequestProto_AddressRequest::GetUserDataRequestProto_AddressRequest(const GetUserDataRequestProto_AddressRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      preexisting_ids_(from.preexisting_ids_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.GetUserDataRequestProto.AddressRequest)
}

inline void GetUserDataRequestProto_AddressRequest::SharedCtor() {
}

GetUserDataRequestProto_AddressRequest::~GetUserDataRequestProto_AddressRequest() {
  // @@protoc_insertion_point(destructor:autofill_assistant.GetUserDataRequestProto.AddressRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GetUserDataRequestProto_AddressRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void GetUserDataRequestProto_AddressRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void GetUserDataRequestProto_AddressRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.GetUserDataRequestProto.AddressRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  preexisting_ids_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* GetUserDataRequestProto_AddressRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated string preexisting_ids = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_preexisting_ids();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GetUserDataRequestProto_AddressRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.GetUserDataRequestProto.AddressRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated string preexisting_ids = 1;
  for (int i = 0, n = this->_internal_preexisting_ids_size(); i < n; i++) {
    const auto& s = this->_internal_preexisting_ids(i);
    target = stream->WriteString(1, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.GetUserDataRequestProto.AddressRequest)
  return target;
}

size_t GetUserDataRequestProto_AddressRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.GetUserDataRequestProto.AddressRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string preexisting_ids = 1;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(preexisting_ids_.size());
  for (int i = 0, n = preexisting_ids_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      preexisting_ids_.Get(i));
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void GetUserDataRequestProto_AddressRequest::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const GetUserDataRequestProto_AddressRequest*>(
      &from));
}

void GetUserDataRequestProto_AddressRequest::MergeFrom(const GetUserDataRequestProto_AddressRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.GetUserDataRequestProto.AddressRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  preexisting_ids_.MergeFrom(from.preexisting_ids_);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void GetUserDataRequestProto_AddressRequest::CopyFrom(const GetUserDataRequestProto_AddressRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.GetUserDataRequestProto.AddressRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetUserDataRequestProto_AddressRequest::IsInitialized() const {
  return true;
}

void GetUserDataRequestProto_AddressRequest::InternalSwap(GetUserDataRequestProto_AddressRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  preexisting_ids_.InternalSwap(&other->preexisting_ids_);
}

std::string GetUserDataRequestProto_AddressRequest::GetTypeName() const {
  return "autofill_assistant.GetUserDataRequestProto.AddressRequest";
}


// ===================================================================

class GetUserDataRequestProto::_Internal {
 public:
  using HasBits = decltype(std::declval<GetUserDataRequestProto>()._has_bits_);
  static void set_has_run_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_request_name(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_request_email(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_request_phone(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static const ::autofill_assistant::GetUserDataRequestProto_AddressRequest& request_shipping_addresses(const GetUserDataRequestProto* msg);
  static void set_has_request_shipping_addresses(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::autofill_assistant::GetUserDataRequestProto_PaymentMethodRequest& request_payment_methods(const GetUserDataRequestProto* msg);
  static void set_has_request_payment_methods(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::autofill_assistant::GetUserDataRequestProto_AddressRequest&
GetUserDataRequestProto::_Internal::request_shipping_addresses(const GetUserDataRequestProto* msg) {
  return *msg->request_shipping_addresses_;
}
const ::autofill_assistant::GetUserDataRequestProto_PaymentMethodRequest&
GetUserDataRequestProto::_Internal::request_payment_methods(const GetUserDataRequestProto* msg) {
  return *msg->request_payment_methods_;
}
GetUserDataRequestProto::GetUserDataRequestProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.GetUserDataRequestProto)
}
GetUserDataRequestProto::GetUserDataRequestProto(const GetUserDataRequestProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_request_payment_methods()) {
    request_payment_methods_ = new ::autofill_assistant::GetUserDataRequestProto_PaymentMethodRequest(*from.request_payment_methods_);
  } else {
    request_payment_methods_ = nullptr;
  }
  if (from._internal_has_request_shipping_addresses()) {
    request_shipping_addresses_ = new ::autofill_assistant::GetUserDataRequestProto_AddressRequest(*from.request_shipping_addresses_);
  } else {
    request_shipping_addresses_ = nullptr;
  }
  ::memcpy(&run_id_, &from.run_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&request_phone_) -
    reinterpret_cast<char*>(&run_id_)) + sizeof(request_phone_));
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.GetUserDataRequestProto)
}

inline void GetUserDataRequestProto::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&request_payment_methods_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&request_phone_) -
    reinterpret_cast<char*>(&request_payment_methods_)) + sizeof(request_phone_));
}

GetUserDataRequestProto::~GetUserDataRequestProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.GetUserDataRequestProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GetUserDataRequestProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete request_payment_methods_;
  if (this != internal_default_instance()) delete request_shipping_addresses_;
}

void GetUserDataRequestProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void GetUserDataRequestProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.GetUserDataRequestProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(request_payment_methods_ != nullptr);
      request_payment_methods_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(request_shipping_addresses_ != nullptr);
      request_shipping_addresses_->Clear();
    }
  }
  if (cached_has_bits & 0x0000003cu) {
    ::memset(&run_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&request_phone_) -
        reinterpret_cast<char*>(&run_id_)) + sizeof(request_phone_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* GetUserDataRequestProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 run_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_run_id(&has_bits);
          run_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool request_name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_request_name(&has_bits);
          request_name_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool request_email = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_request_email(&has_bits);
          request_email_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool request_phone = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_request_phone(&has_bits);
          request_phone_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .autofill_assistant.GetUserDataRequestProto.PaymentMethodRequest request_payment_methods = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_request_payment_methods(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .autofill_assistant.GetUserDataRequestProto.AddressRequest request_shipping_addresses = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_request_shipping_addresses(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GetUserDataRequestProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.GetUserDataRequestProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 run_id = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_run_id(), target);
  }

  // optional bool request_name = 2;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_request_name(), target);
  }

  // optional bool request_email = 3;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_request_email(), target);
  }

  // optional bool request_phone = 4;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_request_phone(), target);
  }

  // optional .autofill_assistant.GetUserDataRequestProto.PaymentMethodRequest request_payment_methods = 7;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::request_payment_methods(this),
        _Internal::request_payment_methods(this).GetCachedSize(), target, stream);
  }

  // optional .autofill_assistant.GetUserDataRequestProto.AddressRequest request_shipping_addresses = 8;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, _Internal::request_shipping_addresses(this),
        _Internal::request_shipping_addresses(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.GetUserDataRequestProto)
  return target;
}

size_t GetUserDataRequestProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.GetUserDataRequestProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional .autofill_assistant.GetUserDataRequestProto.PaymentMethodRequest request_payment_methods = 7;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *request_payment_methods_);
    }

    // optional .autofill_assistant.GetUserDataRequestProto.AddressRequest request_shipping_addresses = 8;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *request_shipping_addresses_);
    }

    // optional uint64 run_id = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_run_id());
    }

    // optional bool request_name = 2;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

    // optional bool request_email = 3;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 1;
    }

    // optional bool request_phone = 4;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 1;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void GetUserDataRequestProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const GetUserDataRequestProto*>(
      &from));
}

void GetUserDataRequestProto::MergeFrom(const GetUserDataRequestProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.GetUserDataRequestProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_request_payment_methods()->::autofill_assistant::GetUserDataRequestProto_PaymentMethodRequest::MergeFrom(from._internal_request_payment_methods());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_request_shipping_addresses()->::autofill_assistant::GetUserDataRequestProto_AddressRequest::MergeFrom(from._internal_request_shipping_addresses());
    }
    if (cached_has_bits & 0x00000004u) {
      run_id_ = from.run_id_;
    }
    if (cached_has_bits & 0x00000008u) {
      request_name_ = from.request_name_;
    }
    if (cached_has_bits & 0x00000010u) {
      request_email_ = from.request_email_;
    }
    if (cached_has_bits & 0x00000020u) {
      request_phone_ = from.request_phone_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void GetUserDataRequestProto::CopyFrom(const GetUserDataRequestProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.GetUserDataRequestProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetUserDataRequestProto::IsInitialized() const {
  return true;
}

void GetUserDataRequestProto::InternalSwap(GetUserDataRequestProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(GetUserDataRequestProto, request_phone_)
      + sizeof(GetUserDataRequestProto::request_phone_)
      - PROTOBUF_FIELD_OFFSET(GetUserDataRequestProto, request_payment_methods_)>(
          reinterpret_cast<char*>(&request_payment_methods_),
          reinterpret_cast<char*>(&other->request_payment_methods_));
}

std::string GetUserDataRequestProto::GetTypeName() const {
  return "autofill_assistant.GetUserDataRequestProto";
}


// ===================================================================

class GetUserDataResponseProto::_Internal {
 public:
  using HasBits = decltype(std::declval<GetUserDataResponseProto>()._has_bits_);
  static void set_has_locale(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_selected_contact_identifier(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_selected_phone_number_identifier(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_selected_shipping_address_identifier(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_add_address_token(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_selected_payment_instrument_identifier(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_add_payment_instrument_token(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

GetUserDataResponseProto::GetUserDataResponseProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  available_contacts_(arena),
  available_payment_instruments_(arena),
  available_addresses_(arena),
  available_phone_numbers_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.GetUserDataResponseProto)
}
GetUserDataResponseProto::GetUserDataResponseProto(const GetUserDataResponseProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      available_contacts_(from.available_contacts_),
      available_payment_instruments_(from.available_payment_instruments_),
      available_addresses_(from.available_addresses_),
      available_phone_numbers_(from.available_phone_numbers_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  locale_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    locale_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_locale()) {
    locale_.Set(from._internal_locale(), 
      GetArenaForAllocation());
  }
  selected_contact_identifier_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    selected_contact_identifier_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_selected_contact_identifier()) {
    selected_contact_identifier_.Set(from._internal_selected_contact_identifier(), 
      GetArenaForAllocation());
  }
  selected_shipping_address_identifier_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    selected_shipping_address_identifier_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_selected_shipping_address_identifier()) {
    selected_shipping_address_identifier_.Set(from._internal_selected_shipping_address_identifier(), 
      GetArenaForAllocation());
  }
  selected_payment_instrument_identifier_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    selected_payment_instrument_identifier_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_selected_payment_instrument_identifier()) {
    selected_payment_instrument_identifier_.Set(from._internal_selected_payment_instrument_identifier(), 
      GetArenaForAllocation());
  }
  add_address_token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    add_address_token_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_add_address_token()) {
    add_address_token_.Set(from._internal_add_address_token(), 
      GetArenaForAllocation());
  }
  add_payment_instrument_token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    add_payment_instrument_token_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_add_payment_instrument_token()) {
    add_payment_instrument_token_.Set(from._internal_add_payment_instrument_token(), 
      GetArenaForAllocation());
  }
  selected_phone_number_identifier_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    selected_phone_number_identifier_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_selected_phone_number_identifier()) {
    selected_phone_number_identifier_.Set(from._internal_selected_phone_number_identifier(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.GetUserDataResponseProto)
}

inline void GetUserDataResponseProto::SharedCtor() {
locale_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  locale_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
selected_contact_identifier_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  selected_contact_identifier_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
selected_shipping_address_identifier_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  selected_shipping_address_identifier_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
selected_payment_instrument_identifier_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  selected_payment_instrument_identifier_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
add_address_token_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  add_address_token_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
add_payment_instrument_token_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  add_payment_instrument_token_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
selected_phone_number_identifier_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  selected_phone_number_identifier_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

GetUserDataResponseProto::~GetUserDataResponseProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.GetUserDataResponseProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GetUserDataResponseProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  locale_.Destroy();
  selected_contact_identifier_.Destroy();
  selected_shipping_address_identifier_.Destroy();
  selected_payment_instrument_identifier_.Destroy();
  add_address_token_.Destroy();
  add_payment_instrument_token_.Destroy();
  selected_phone_number_identifier_.Destroy();
}

void GetUserDataResponseProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void GetUserDataResponseProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.GetUserDataResponseProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  available_contacts_.Clear();
  available_payment_instruments_.Clear();
  available_addresses_.Clear();
  available_phone_numbers_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      locale_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      selected_contact_identifier_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      selected_shipping_address_identifier_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      selected_payment_instrument_identifier_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      add_address_token_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000020u) {
      add_payment_instrument_token_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000040u) {
      selected_phone_number_identifier_.ClearNonDefaultToEmpty();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* GetUserDataResponseProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .autofill_assistant.ProfileProto available_contacts = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_available_contacts(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .autofill_assistant.PaymentInstrumentProto available_payment_instruments = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_available_payment_instruments(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional string locale = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_locale();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .autofill_assistant.ProfileProto available_addresses = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_available_addresses(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional string selected_contact_identifier = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_selected_contact_identifier();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string selected_shipping_address_identifier = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_selected_shipping_address_identifier();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string selected_payment_instrument_identifier = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_selected_payment_instrument_identifier();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes add_address_token = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          auto str = _internal_mutable_add_address_token();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes add_payment_instrument_token = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          auto str = _internal_mutable_add_payment_instrument_token();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .autofill_assistant.PhoneNumberProto available_phone_numbers = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_available_phone_numbers(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<82>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional string selected_phone_number_identifier = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          auto str = _internal_mutable_selected_phone_number_identifier();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GetUserDataResponseProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.GetUserDataResponseProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .autofill_assistant.ProfileProto available_contacts = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_available_contacts_size()); i < n; i++) {
    const auto& repfield = this->_internal_available_contacts(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .autofill_assistant.PaymentInstrumentProto available_payment_instruments = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_available_payment_instruments_size()); i < n; i++) {
    const auto& repfield = this->_internal_available_payment_instruments(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  cached_has_bits = _has_bits_[0];
  // optional string locale = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_locale(), target);
  }

  // repeated .autofill_assistant.ProfileProto available_addresses = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_available_addresses_size()); i < n; i++) {
    const auto& repfield = this->_internal_available_addresses(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional string selected_contact_identifier = 5;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_selected_contact_identifier(), target);
  }

  // optional string selected_shipping_address_identifier = 6;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_selected_shipping_address_identifier(), target);
  }

  // optional string selected_payment_instrument_identifier = 7;
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteStringMaybeAliased(
        7, this->_internal_selected_payment_instrument_identifier(), target);
  }

  // optional bytes add_address_token = 8;
  if (cached_has_bits & 0x00000010u) {
    target = stream->WriteBytesMaybeAliased(
        8, this->_internal_add_address_token(), target);
  }

  // optional bytes add_payment_instrument_token = 9;
  if (cached_has_bits & 0x00000020u) {
    target = stream->WriteBytesMaybeAliased(
        9, this->_internal_add_payment_instrument_token(), target);
  }

  // repeated .autofill_assistant.PhoneNumberProto available_phone_numbers = 10;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_available_phone_numbers_size()); i < n; i++) {
    const auto& repfield = this->_internal_available_phone_numbers(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(10, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional string selected_phone_number_identifier = 11;
  if (cached_has_bits & 0x00000040u) {
    target = stream->WriteStringMaybeAliased(
        11, this->_internal_selected_phone_number_identifier(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.GetUserDataResponseProto)
  return target;
}

size_t GetUserDataResponseProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.GetUserDataResponseProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .autofill_assistant.ProfileProto available_contacts = 1;
  total_size += 1UL * this->_internal_available_contacts_size();
  for (const auto& msg : this->available_contacts_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .autofill_assistant.PaymentInstrumentProto available_payment_instruments = 2;
  total_size += 1UL * this->_internal_available_payment_instruments_size();
  for (const auto& msg : this->available_payment_instruments_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .autofill_assistant.ProfileProto available_addresses = 4;
  total_size += 1UL * this->_internal_available_addresses_size();
  for (const auto& msg : this->available_addresses_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .autofill_assistant.PhoneNumberProto available_phone_numbers = 10;
  total_size += 1UL * this->_internal_available_phone_numbers_size();
  for (const auto& msg : this->available_phone_numbers_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // optional string locale = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_locale());
    }

    // optional string selected_contact_identifier = 5;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_selected_contact_identifier());
    }

    // optional string selected_shipping_address_identifier = 6;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_selected_shipping_address_identifier());
    }

    // optional string selected_payment_instrument_identifier = 7;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_selected_payment_instrument_identifier());
    }

    // optional bytes add_address_token = 8;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_add_address_token());
    }

    // optional bytes add_payment_instrument_token = 9;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_add_payment_instrument_token());
    }

    // optional string selected_phone_number_identifier = 11;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_selected_phone_number_identifier());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void GetUserDataResponseProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const GetUserDataResponseProto*>(
      &from));
}

void GetUserDataResponseProto::MergeFrom(const GetUserDataResponseProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.GetUserDataResponseProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  available_contacts_.MergeFrom(from.available_contacts_);
  available_payment_instruments_.MergeFrom(from.available_payment_instruments_);
  available_addresses_.MergeFrom(from.available_addresses_);
  available_phone_numbers_.MergeFrom(from.available_phone_numbers_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_locale(from._internal_locale());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_selected_contact_identifier(from._internal_selected_contact_identifier());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_selected_shipping_address_identifier(from._internal_selected_shipping_address_identifier());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_set_selected_payment_instrument_identifier(from._internal_selected_payment_instrument_identifier());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_set_add_address_token(from._internal_add_address_token());
    }
    if (cached_has_bits & 0x00000020u) {
      _internal_set_add_payment_instrument_token(from._internal_add_payment_instrument_token());
    }
    if (cached_has_bits & 0x00000040u) {
      _internal_set_selected_phone_number_identifier(from._internal_selected_phone_number_identifier());
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void GetUserDataResponseProto::CopyFrom(const GetUserDataResponseProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.GetUserDataResponseProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetUserDataResponseProto::IsInitialized() const {
  return true;
}

void GetUserDataResponseProto::InternalSwap(GetUserDataResponseProto* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  available_contacts_.InternalSwap(&other->available_contacts_);
  available_payment_instruments_.InternalSwap(&other->available_payment_instruments_);
  available_addresses_.InternalSwap(&other->available_addresses_);
  available_phone_numbers_.InternalSwap(&other->available_phone_numbers_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &locale_, lhs_arena,
      &other->locale_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &selected_contact_identifier_, lhs_arena,
      &other->selected_contact_identifier_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &selected_shipping_address_identifier_, lhs_arena,
      &other->selected_shipping_address_identifier_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &selected_payment_instrument_identifier_, lhs_arena,
      &other->selected_payment_instrument_identifier_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &add_address_token_, lhs_arena,
      &other->add_address_token_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &add_payment_instrument_token_, lhs_arena,
      &other->add_payment_instrument_token_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &selected_phone_number_identifier_, lhs_arena,
      &other->selected_phone_number_identifier_, rhs_arena
  );
}

std::string GetUserDataResponseProto::GetTypeName() const {
  return "autofill_assistant.GetUserDataResponseProto";
}


// ===================================================================

class OverlayImageProto::_Internal {
 public:
  using HasBits = decltype(std::declval<OverlayImageProto>()._has_bits_);
  static const ::autofill_assistant::DrawableProto& image_drawable(const OverlayImageProto* msg);
  static const ::autofill_assistant::ClientDimensionProto& image_size(const OverlayImageProto* msg);
  static void set_has_image_size(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::autofill_assistant::ClientDimensionProto& image_top_margin(const OverlayImageProto* msg);
  static void set_has_image_top_margin(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::autofill_assistant::ClientDimensionProto& image_bottom_margin(const OverlayImageProto* msg);
  static void set_has_image_bottom_margin(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_text(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_text_color(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::autofill_assistant::ClientDimensionProto& text_size(const OverlayImageProto* msg);
  static void set_has_text_size(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

const ::autofill_assistant::DrawableProto&
OverlayImageProto::_Internal::image_drawable(const OverlayImageProto* msg) {
  return *msg->image_.image_drawable_;
}
const ::autofill_assistant::ClientDimensionProto&
OverlayImageProto::_Internal::image_size(const OverlayImageProto* msg) {
  return *msg->image_size_;
}
const ::autofill_assistant::ClientDimensionProto&
OverlayImageProto::_Internal::image_top_margin(const OverlayImageProto* msg) {
  return *msg->image_top_margin_;
}
const ::autofill_assistant::ClientDimensionProto&
OverlayImageProto::_Internal::image_bottom_margin(const OverlayImageProto* msg) {
  return *msg->image_bottom_margin_;
}
const ::autofill_assistant::ClientDimensionProto&
OverlayImageProto::_Internal::text_size(const OverlayImageProto* msg) {
  return *msg->text_size_;
}
void OverlayImageProto::set_allocated_image_drawable(::autofill_assistant::DrawableProto* image_drawable) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_image();
  if (image_drawable) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(image_drawable));
    if (message_arena != submessage_arena) {
      image_drawable = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, image_drawable, submessage_arena);
    }
    set_has_image_drawable();
    image_.image_drawable_ = image_drawable;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.OverlayImageProto.image_drawable)
}
void OverlayImageProto::clear_image_drawable() {
  if (_internal_has_image_drawable()) {
    if (GetArenaForAllocation() == nullptr) {
      delete image_.image_drawable_;
    }
    clear_has_image();
  }
}
void OverlayImageProto::clear_image_size() {
  if (image_size_ != nullptr) image_size_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
void OverlayImageProto::clear_image_top_margin() {
  if (image_top_margin_ != nullptr) image_top_margin_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
void OverlayImageProto::clear_image_bottom_margin() {
  if (image_bottom_margin_ != nullptr) image_bottom_margin_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
void OverlayImageProto::clear_text_size() {
  if (text_size_ != nullptr) text_size_->Clear();
  _has_bits_[0] &= ~0x00000020u;
}
OverlayImageProto::OverlayImageProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.OverlayImageProto)
}
OverlayImageProto::OverlayImageProto(const OverlayImageProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  text_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    text_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_text()) {
    text_.Set(from._internal_text(), 
      GetArenaForAllocation());
  }
  text_color_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    text_color_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_text_color()) {
    text_color_.Set(from._internal_text_color(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_image_size()) {
    image_size_ = new ::autofill_assistant::ClientDimensionProto(*from.image_size_);
  } else {
    image_size_ = nullptr;
  }
  if (from._internal_has_image_top_margin()) {
    image_top_margin_ = new ::autofill_assistant::ClientDimensionProto(*from.image_top_margin_);
  } else {
    image_top_margin_ = nullptr;
  }
  if (from._internal_has_image_bottom_margin()) {
    image_bottom_margin_ = new ::autofill_assistant::ClientDimensionProto(*from.image_bottom_margin_);
  } else {
    image_bottom_margin_ = nullptr;
  }
  if (from._internal_has_text_size()) {
    text_size_ = new ::autofill_assistant::ClientDimensionProto(*from.text_size_);
  } else {
    text_size_ = nullptr;
  }
  clear_has_image();
  switch (from.image_case()) {
    case kImageUrl: {
      _internal_set_image_url(from._internal_image_url());
      break;
    }
    case kImageDrawable: {
      _internal_mutable_image_drawable()->::autofill_assistant::DrawableProto::MergeFrom(from._internal_image_drawable());
      break;
    }
    case IMAGE_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.OverlayImageProto)
}

inline void OverlayImageProto::SharedCtor() {
text_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  text_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
text_color_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  text_color_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&image_size_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&text_size_) -
    reinterpret_cast<char*>(&image_size_)) + sizeof(text_size_));
clear_has_image();
}

OverlayImageProto::~OverlayImageProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.OverlayImageProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void OverlayImageProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  text_.Destroy();
  text_color_.Destroy();
  if (this != internal_default_instance()) delete image_size_;
  if (this != internal_default_instance()) delete image_top_margin_;
  if (this != internal_default_instance()) delete image_bottom_margin_;
  if (this != internal_default_instance()) delete text_size_;
  if (has_image()) {
    clear_image();
  }
}

void OverlayImageProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void OverlayImageProto::clear_image() {
// @@protoc_insertion_point(one_of_clear_start:autofill_assistant.OverlayImageProto)
  switch (image_case()) {
    case kImageUrl: {
      image_.image_url_.Destroy();
      break;
    }
    case kImageDrawable: {
      if (GetArenaForAllocation() == nullptr) {
        delete image_.image_drawable_;
      }
      break;
    }
    case IMAGE_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = IMAGE_NOT_SET;
}


void OverlayImageProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.OverlayImageProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      text_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      text_color_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(image_size_ != nullptr);
      image_size_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(image_top_margin_ != nullptr);
      image_top_margin_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(image_bottom_margin_ != nullptr);
      image_bottom_margin_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(text_size_ != nullptr);
      text_size_->Clear();
    }
  }
  clear_image();
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* OverlayImageProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string image_url = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_image_url();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .autofill_assistant.ClientDimensionProto image_size = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_image_size(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .autofill_assistant.ClientDimensionProto image_top_margin = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_image_top_margin(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .autofill_assistant.ClientDimensionProto image_bottom_margin = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_image_bottom_margin(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string text = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_text();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string text_color = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_text_color();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .autofill_assistant.ClientDimensionProto text_size = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_text_size(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.DrawableProto image_drawable = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_image_drawable(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* OverlayImageProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.OverlayImageProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string image_url = 1;
  if (_internal_has_image_url()) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_image_url(), target);
  }

  cached_has_bits = _has_bits_[0];
  // optional .autofill_assistant.ClientDimensionProto image_size = 2;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::image_size(this),
        _Internal::image_size(this).GetCachedSize(), target, stream);
  }

  // optional .autofill_assistant.ClientDimensionProto image_top_margin = 3;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::image_top_margin(this),
        _Internal::image_top_margin(this).GetCachedSize(), target, stream);
  }

  // optional .autofill_assistant.ClientDimensionProto image_bottom_margin = 4;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::image_bottom_margin(this),
        _Internal::image_bottom_margin(this).GetCachedSize(), target, stream);
  }

  // optional string text = 5;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_text(), target);
  }

  // optional string text_color = 6;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_text_color(), target);
  }

  // optional .autofill_assistant.ClientDimensionProto text_size = 7;
  if (cached_has_bits & 0x00000020u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::text_size(this),
        _Internal::text_size(this).GetCachedSize(), target, stream);
  }

  // .autofill_assistant.DrawableProto image_drawable = 8;
  if (_internal_has_image_drawable()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, _Internal::image_drawable(this),
        _Internal::image_drawable(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.OverlayImageProto)
  return target;
}

size_t OverlayImageProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.OverlayImageProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional string text = 5;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_text());
    }

    // optional string text_color = 6;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_text_color());
    }

    // optional .autofill_assistant.ClientDimensionProto image_size = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *image_size_);
    }

    // optional .autofill_assistant.ClientDimensionProto image_top_margin = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *image_top_margin_);
    }

    // optional .autofill_assistant.ClientDimensionProto image_bottom_margin = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *image_bottom_margin_);
    }

    // optional .autofill_assistant.ClientDimensionProto text_size = 7;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *text_size_);
    }

  }
  switch (image_case()) {
    // string image_url = 1;
    case kImageUrl: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_image_url());
      break;
    }
    // .autofill_assistant.DrawableProto image_drawable = 8;
    case kImageDrawable: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *image_.image_drawable_);
      break;
    }
    case IMAGE_NOT_SET: {
      break;
    }
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void OverlayImageProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const OverlayImageProto*>(
      &from));
}

void OverlayImageProto::MergeFrom(const OverlayImageProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.OverlayImageProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_text(from._internal_text());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_text_color(from._internal_text_color());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_image_size()->::autofill_assistant::ClientDimensionProto::MergeFrom(from._internal_image_size());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_mutable_image_top_margin()->::autofill_assistant::ClientDimensionProto::MergeFrom(from._internal_image_top_margin());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_mutable_image_bottom_margin()->::autofill_assistant::ClientDimensionProto::MergeFrom(from._internal_image_bottom_margin());
    }
    if (cached_has_bits & 0x00000020u) {
      _internal_mutable_text_size()->::autofill_assistant::ClientDimensionProto::MergeFrom(from._internal_text_size());
    }
  }
  switch (from.image_case()) {
    case kImageUrl: {
      _internal_set_image_url(from._internal_image_url());
      break;
    }
    case kImageDrawable: {
      _internal_mutable_image_drawable()->::autofill_assistant::DrawableProto::MergeFrom(from._internal_image_drawable());
      break;
    }
    case IMAGE_NOT_SET: {
      break;
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void OverlayImageProto::CopyFrom(const OverlayImageProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.OverlayImageProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OverlayImageProto::IsInitialized() const {
  return true;
}

void OverlayImageProto::InternalSwap(OverlayImageProto* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &text_, lhs_arena,
      &other->text_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &text_color_, lhs_arena,
      &other->text_color_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(OverlayImageProto, text_size_)
      + sizeof(OverlayImageProto::text_size_)
      - PROTOBUF_FIELD_OFFSET(OverlayImageProto, image_size_)>(
          reinterpret_cast<char*>(&image_size_),
          reinterpret_cast<char*>(&other->image_size_));
  swap(image_, other->image_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

std::string OverlayImageProto::GetTypeName() const {
  return "autofill_assistant.OverlayImageProto";
}


// ===================================================================

class ClientSettingsProto_IntegrationTestSettings::_Internal {
 public:
  using HasBits = decltype(std::declval<ClientSettingsProto_IntegrationTestSettings>()._has_bits_);
  static void set_has_disable_header_animations(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_disable_carousel_change_animations(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

ClientSettingsProto_IntegrationTestSettings::ClientSettingsProto_IntegrationTestSettings(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.ClientSettingsProto.IntegrationTestSettings)
}
ClientSettingsProto_IntegrationTestSettings::ClientSettingsProto_IntegrationTestSettings(const ClientSettingsProto_IntegrationTestSettings& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&disable_header_animations_, &from.disable_header_animations_,
    static_cast<size_t>(reinterpret_cast<char*>(&disable_carousel_change_animations_) -
    reinterpret_cast<char*>(&disable_header_animations_)) + sizeof(disable_carousel_change_animations_));
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.ClientSettingsProto.IntegrationTestSettings)
}

inline void ClientSettingsProto_IntegrationTestSettings::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&disable_header_animations_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&disable_carousel_change_animations_) -
    reinterpret_cast<char*>(&disable_header_animations_)) + sizeof(disable_carousel_change_animations_));
}

ClientSettingsProto_IntegrationTestSettings::~ClientSettingsProto_IntegrationTestSettings() {
  // @@protoc_insertion_point(destructor:autofill_assistant.ClientSettingsProto.IntegrationTestSettings)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ClientSettingsProto_IntegrationTestSettings::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ClientSettingsProto_IntegrationTestSettings::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ClientSettingsProto_IntegrationTestSettings::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.ClientSettingsProto.IntegrationTestSettings)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&disable_header_animations_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&disable_carousel_change_animations_) -
      reinterpret_cast<char*>(&disable_header_animations_)) + sizeof(disable_carousel_change_animations_));
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ClientSettingsProto_IntegrationTestSettings::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool disable_header_animations = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_disable_header_animations(&has_bits);
          disable_header_animations_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool disable_carousel_change_animations = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_disable_carousel_change_animations(&has_bits);
          disable_carousel_change_animations_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ClientSettingsProto_IntegrationTestSettings::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.ClientSettingsProto.IntegrationTestSettings)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bool disable_header_animations = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_disable_header_animations(), target);
  }

  // optional bool disable_carousel_change_animations = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_disable_carousel_change_animations(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.ClientSettingsProto.IntegrationTestSettings)
  return target;
}

size_t ClientSettingsProto_IntegrationTestSettings::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.ClientSettingsProto.IntegrationTestSettings)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional bool disable_header_animations = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 1;
    }

    // optional bool disable_carousel_change_animations = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ClientSettingsProto_IntegrationTestSettings::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ClientSettingsProto_IntegrationTestSettings*>(
      &from));
}

void ClientSettingsProto_IntegrationTestSettings::MergeFrom(const ClientSettingsProto_IntegrationTestSettings& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.ClientSettingsProto.IntegrationTestSettings)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      disable_header_animations_ = from.disable_header_animations_;
    }
    if (cached_has_bits & 0x00000002u) {
      disable_carousel_change_animations_ = from.disable_carousel_change_animations_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClientSettingsProto_IntegrationTestSettings::CopyFrom(const ClientSettingsProto_IntegrationTestSettings& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.ClientSettingsProto.IntegrationTestSettings)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClientSettingsProto_IntegrationTestSettings::IsInitialized() const {
  return true;
}

void ClientSettingsProto_IntegrationTestSettings::InternalSwap(ClientSettingsProto_IntegrationTestSettings* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ClientSettingsProto_IntegrationTestSettings, disable_carousel_change_animations_)
      + sizeof(ClientSettingsProto_IntegrationTestSettings::disable_carousel_change_animations_)
      - PROTOBUF_FIELD_OFFSET(ClientSettingsProto_IntegrationTestSettings, disable_header_animations_)>(
          reinterpret_cast<char*>(&disable_header_animations_),
          reinterpret_cast<char*>(&other->disable_header_animations_));
}

std::string ClientSettingsProto_IntegrationTestSettings::GetTypeName() const {
  return "autofill_assistant.ClientSettingsProto.IntegrationTestSettings";
}


// ===================================================================

class ClientSettingsProto_BackButtonSettings::_Internal {
 public:
  using HasBits = decltype(std::declval<ClientSettingsProto_BackButtonSettings>()._has_bits_);
  static void set_has_undo_label(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

ClientSettingsProto_BackButtonSettings::ClientSettingsProto_BackButtonSettings(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.ClientSettingsProto.BackButtonSettings)
}
ClientSettingsProto_BackButtonSettings::ClientSettingsProto_BackButtonSettings(const ClientSettingsProto_BackButtonSettings& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  undo_label_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    undo_label_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_undo_label()) {
    undo_label_.Set(from._internal_undo_label(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.ClientSettingsProto.BackButtonSettings)
}

inline void ClientSettingsProto_BackButtonSettings::SharedCtor() {
undo_label_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  undo_label_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ClientSettingsProto_BackButtonSettings::~ClientSettingsProto_BackButtonSettings() {
  // @@protoc_insertion_point(destructor:autofill_assistant.ClientSettingsProto.BackButtonSettings)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ClientSettingsProto_BackButtonSettings::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  undo_label_.Destroy();
}

void ClientSettingsProto_BackButtonSettings::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ClientSettingsProto_BackButtonSettings::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.ClientSettingsProto.BackButtonSettings)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    undo_label_.ClearNonDefaultToEmpty();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ClientSettingsProto_BackButtonSettings::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string undo_label = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_undo_label();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ClientSettingsProto_BackButtonSettings::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.ClientSettingsProto.BackButtonSettings)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string undo_label = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_undo_label(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.ClientSettingsProto.BackButtonSettings)
  return target;
}

size_t ClientSettingsProto_BackButtonSettings::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.ClientSettingsProto.BackButtonSettings)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string undo_label = 2;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_undo_label());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ClientSettingsProto_BackButtonSettings::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ClientSettingsProto_BackButtonSettings*>(
      &from));
}

void ClientSettingsProto_BackButtonSettings::MergeFrom(const ClientSettingsProto_BackButtonSettings& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.ClientSettingsProto.BackButtonSettings)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_undo_label()) {
    _internal_set_undo_label(from._internal_undo_label());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClientSettingsProto_BackButtonSettings::CopyFrom(const ClientSettingsProto_BackButtonSettings& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.ClientSettingsProto.BackButtonSettings)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClientSettingsProto_BackButtonSettings::IsInitialized() const {
  return true;
}

void ClientSettingsProto_BackButtonSettings::InternalSwap(ClientSettingsProto_BackButtonSettings* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &undo_label_, lhs_arena,
      &other->undo_label_, rhs_arena
  );
}

std::string ClientSettingsProto_BackButtonSettings::GetTypeName() const {
  return "autofill_assistant.ClientSettingsProto.BackButtonSettings";
}


// ===================================================================

class ClientSettingsProto_SlowWarningSettings::_Internal {
 public:
  using HasBits = decltype(std::declval<ClientSettingsProto_SlowWarningSettings>()._has_bits_);
  static void set_has_enable_slow_connection_warnings(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_enable_slow_website_warnings(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_only_show_warning_once(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_only_show_connection_warning_once(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_only_show_website_warning_once(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_warning_delay_ms(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_slow_roundtrip_threshold_ms(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_max_consecutive_slow_roundtrips(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_slow_connection_message(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_slow_website_message(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_minimum_warning_message_duration_ms(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_message_mode(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
};

ClientSettingsProto_SlowWarningSettings::ClientSettingsProto_SlowWarningSettings(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.ClientSettingsProto.SlowWarningSettings)
}
ClientSettingsProto_SlowWarningSettings::ClientSettingsProto_SlowWarningSettings(const ClientSettingsProto_SlowWarningSettings& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  slow_connection_message_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    slow_connection_message_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_slow_connection_message()) {
    slow_connection_message_.Set(from._internal_slow_connection_message(), 
      GetArenaForAllocation());
  }
  slow_website_message_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    slow_website_message_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_slow_website_message()) {
    slow_website_message_.Set(from._internal_slow_website_message(), 
      GetArenaForAllocation());
  }
  ::memcpy(&enable_slow_connection_warnings_, &from.enable_slow_connection_warnings_,
    static_cast<size_t>(reinterpret_cast<char*>(&message_mode_) -
    reinterpret_cast<char*>(&enable_slow_connection_warnings_)) + sizeof(message_mode_));
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.ClientSettingsProto.SlowWarningSettings)
}

inline void ClientSettingsProto_SlowWarningSettings::SharedCtor() {
slow_connection_message_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  slow_connection_message_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
slow_website_message_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  slow_website_message_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&enable_slow_connection_warnings_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&message_mode_) -
    reinterpret_cast<char*>(&enable_slow_connection_warnings_)) + sizeof(message_mode_));
}

ClientSettingsProto_SlowWarningSettings::~ClientSettingsProto_SlowWarningSettings() {
  // @@protoc_insertion_point(destructor:autofill_assistant.ClientSettingsProto.SlowWarningSettings)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ClientSettingsProto_SlowWarningSettings::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  slow_connection_message_.Destroy();
  slow_website_message_.Destroy();
}

void ClientSettingsProto_SlowWarningSettings::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ClientSettingsProto_SlowWarningSettings::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.ClientSettingsProto.SlowWarningSettings)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      slow_connection_message_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      slow_website_message_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x000000fcu) {
    ::memset(&enable_slow_connection_warnings_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&warning_delay_ms_) -
        reinterpret_cast<char*>(&enable_slow_connection_warnings_)) + sizeof(warning_delay_ms_));
  }
  if (cached_has_bits & 0x00000f00u) {
    ::memset(&slow_roundtrip_threshold_ms_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&message_mode_) -
        reinterpret_cast<char*>(&slow_roundtrip_threshold_ms_)) + sizeof(message_mode_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ClientSettingsProto_SlowWarningSettings::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool enable_slow_connection_warnings = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_enable_slow_connection_warnings(&has_bits);
          enable_slow_connection_warnings_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool enable_slow_website_warnings = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_enable_slow_website_warnings(&has_bits);
          enable_slow_website_warnings_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool only_show_warning_once = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_only_show_warning_once(&has_bits);
          only_show_warning_once_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool only_show_connection_warning_once = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_only_show_connection_warning_once(&has_bits);
          only_show_connection_warning_once_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool only_show_website_warning_once = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_only_show_website_warning_once(&has_bits);
          only_show_website_warning_once_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 warning_delay_ms = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_warning_delay_ms(&has_bits);
          warning_delay_ms_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 slow_roundtrip_threshold_ms = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_slow_roundtrip_threshold_ms(&has_bits);
          slow_roundtrip_threshold_ms_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 max_consecutive_slow_roundtrips = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_max_consecutive_slow_roundtrips(&has_bits);
          max_consecutive_slow_roundtrips_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string slow_connection_message = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          auto str = _internal_mutable_slow_connection_message();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string slow_website_message = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          auto str = _internal_mutable_slow_website_message();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 minimum_warning_message_duration_ms = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_minimum_warning_message_duration_ms(&has_bits);
          minimum_warning_message_duration_ms_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .autofill_assistant.ClientSettingsProto.SlowWarningSettings.MessageMode message_mode = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::autofill_assistant::ClientSettingsProto_SlowWarningSettings_MessageMode_IsValid(val))) {
            _internal_set_message_mode(static_cast<::autofill_assistant::ClientSettingsProto_SlowWarningSettings_MessageMode>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(12, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ClientSettingsProto_SlowWarningSettings::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.ClientSettingsProto.SlowWarningSettings)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bool enable_slow_connection_warnings = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_enable_slow_connection_warnings(), target);
  }

  // optional bool enable_slow_website_warnings = 2;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_enable_slow_website_warnings(), target);
  }

  // optional bool only_show_warning_once = 3;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_only_show_warning_once(), target);
  }

  // optional bool only_show_connection_warning_once = 4;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_only_show_connection_warning_once(), target);
  }

  // optional bool only_show_website_warning_once = 5;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_only_show_website_warning_once(), target);
  }

  // optional int32 warning_delay_ms = 6;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(6, this->_internal_warning_delay_ms(), target);
  }

  // optional int32 slow_roundtrip_threshold_ms = 7;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(7, this->_internal_slow_roundtrip_threshold_ms(), target);
  }

  // optional int32 max_consecutive_slow_roundtrips = 8;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(8, this->_internal_max_consecutive_slow_roundtrips(), target);
  }

  // optional string slow_connection_message = 9;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        9, this->_internal_slow_connection_message(), target);
  }

  // optional string slow_website_message = 10;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        10, this->_internal_slow_website_message(), target);
  }

  // optional int32 minimum_warning_message_duration_ms = 11;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(11, this->_internal_minimum_warning_message_duration_ms(), target);
  }

  // optional .autofill_assistant.ClientSettingsProto.SlowWarningSettings.MessageMode message_mode = 12;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      12, this->_internal_message_mode(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.ClientSettingsProto.SlowWarningSettings)
  return target;
}

size_t ClientSettingsProto_SlowWarningSettings::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.ClientSettingsProto.SlowWarningSettings)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string slow_connection_message = 9;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_slow_connection_message());
    }

    // optional string slow_website_message = 10;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_slow_website_message());
    }

    // optional bool enable_slow_connection_warnings = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

    // optional bool enable_slow_website_warnings = 2;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

    // optional bool only_show_warning_once = 3;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 1;
    }

    // optional bool only_show_connection_warning_once = 4;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 1;
    }

    // optional bool only_show_website_warning_once = 5;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 1;
    }

    // optional int32 warning_delay_ms = 6;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_warning_delay_ms());
    }

  }
  if (cached_has_bits & 0x00000f00u) {
    // optional int32 slow_roundtrip_threshold_ms = 7;
    if (cached_has_bits & 0x00000100u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_slow_roundtrip_threshold_ms());
    }

    // optional int32 max_consecutive_slow_roundtrips = 8;
    if (cached_has_bits & 0x00000200u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_max_consecutive_slow_roundtrips());
    }

    // optional int32 minimum_warning_message_duration_ms = 11;
    if (cached_has_bits & 0x00000400u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_minimum_warning_message_duration_ms());
    }

    // optional .autofill_assistant.ClientSettingsProto.SlowWarningSettings.MessageMode message_mode = 12;
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_message_mode());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ClientSettingsProto_SlowWarningSettings::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ClientSettingsProto_SlowWarningSettings*>(
      &from));
}

void ClientSettingsProto_SlowWarningSettings::MergeFrom(const ClientSettingsProto_SlowWarningSettings& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.ClientSettingsProto.SlowWarningSettings)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_slow_connection_message(from._internal_slow_connection_message());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_slow_website_message(from._internal_slow_website_message());
    }
    if (cached_has_bits & 0x00000004u) {
      enable_slow_connection_warnings_ = from.enable_slow_connection_warnings_;
    }
    if (cached_has_bits & 0x00000008u) {
      enable_slow_website_warnings_ = from.enable_slow_website_warnings_;
    }
    if (cached_has_bits & 0x00000010u) {
      only_show_warning_once_ = from.only_show_warning_once_;
    }
    if (cached_has_bits & 0x00000020u) {
      only_show_connection_warning_once_ = from.only_show_connection_warning_once_;
    }
    if (cached_has_bits & 0x00000040u) {
      only_show_website_warning_once_ = from.only_show_website_warning_once_;
    }
    if (cached_has_bits & 0x00000080u) {
      warning_delay_ms_ = from.warning_delay_ms_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000f00u) {
    if (cached_has_bits & 0x00000100u) {
      slow_roundtrip_threshold_ms_ = from.slow_roundtrip_threshold_ms_;
    }
    if (cached_has_bits & 0x00000200u) {
      max_consecutive_slow_roundtrips_ = from.max_consecutive_slow_roundtrips_;
    }
    if (cached_has_bits & 0x00000400u) {
      minimum_warning_message_duration_ms_ = from.minimum_warning_message_duration_ms_;
    }
    if (cached_has_bits & 0x00000800u) {
      message_mode_ = from.message_mode_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClientSettingsProto_SlowWarningSettings::CopyFrom(const ClientSettingsProto_SlowWarningSettings& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.ClientSettingsProto.SlowWarningSettings)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClientSettingsProto_SlowWarningSettings::IsInitialized() const {
  return true;
}

void ClientSettingsProto_SlowWarningSettings::InternalSwap(ClientSettingsProto_SlowWarningSettings* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &slow_connection_message_, lhs_arena,
      &other->slow_connection_message_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &slow_website_message_, lhs_arena,
      &other->slow_website_message_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ClientSettingsProto_SlowWarningSettings, message_mode_)
      + sizeof(ClientSettingsProto_SlowWarningSettings::message_mode_)
      - PROTOBUF_FIELD_OFFSET(ClientSettingsProto_SlowWarningSettings, enable_slow_connection_warnings_)>(
          reinterpret_cast<char*>(&enable_slow_connection_warnings_),
          reinterpret_cast<char*>(&other->enable_slow_connection_warnings_));
}

std::string ClientSettingsProto_SlowWarningSettings::GetTypeName() const {
  return "autofill_assistant.ClientSettingsProto.SlowWarningSettings";
}


// ===================================================================

class ClientSettingsProto_DisplayString::_Internal {
 public:
  using HasBits = decltype(std::declval<ClientSettingsProto_DisplayString>()._has_bits_);
  static void set_has_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_value(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

ClientSettingsProto_DisplayString::ClientSettingsProto_DisplayString(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.ClientSettingsProto.DisplayString)
}
ClientSettingsProto_DisplayString::ClientSettingsProto_DisplayString(const ClientSettingsProto_DisplayString& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  value_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    value_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_value()) {
    value_.Set(from._internal_value(), 
      GetArenaForAllocation());
  }
  id_ = from.id_;
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.ClientSettingsProto.DisplayString)
}

inline void ClientSettingsProto_DisplayString::SharedCtor() {
value_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  value_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
id_ = 0;
}

ClientSettingsProto_DisplayString::~ClientSettingsProto_DisplayString() {
  // @@protoc_insertion_point(destructor:autofill_assistant.ClientSettingsProto.DisplayString)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ClientSettingsProto_DisplayString::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  value_.Destroy();
}

void ClientSettingsProto_DisplayString::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ClientSettingsProto_DisplayString::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.ClientSettingsProto.DisplayString)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    value_.ClearNonDefaultToEmpty();
  }
  id_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ClientSettingsProto_DisplayString::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .autofill_assistant.ClientSettingsProto.DisplayStringId id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::autofill_assistant::ClientSettingsProto_DisplayStringId_IsValid(val))) {
            _internal_set_id(static_cast<::autofill_assistant::ClientSettingsProto_DisplayStringId>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional string value = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_value();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ClientSettingsProto_DisplayString::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.ClientSettingsProto.DisplayString)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .autofill_assistant.ClientSettingsProto.DisplayStringId id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_id(), target);
  }

  // optional string value = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_value(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.ClientSettingsProto.DisplayString)
  return target;
}

size_t ClientSettingsProto_DisplayString::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.ClientSettingsProto.DisplayString)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string value = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_value());
    }

    // optional .autofill_assistant.ClientSettingsProto.DisplayStringId id = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_id());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ClientSettingsProto_DisplayString::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ClientSettingsProto_DisplayString*>(
      &from));
}

void ClientSettingsProto_DisplayString::MergeFrom(const ClientSettingsProto_DisplayString& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.ClientSettingsProto.DisplayString)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_value(from._internal_value());
    }
    if (cached_has_bits & 0x00000002u) {
      id_ = from.id_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClientSettingsProto_DisplayString::CopyFrom(const ClientSettingsProto_DisplayString& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.ClientSettingsProto.DisplayString)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClientSettingsProto_DisplayString::IsInitialized() const {
  return true;
}

void ClientSettingsProto_DisplayString::InternalSwap(ClientSettingsProto_DisplayString* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &value_, lhs_arena,
      &other->value_, rhs_arena
  );
  swap(id_, other->id_);
}

std::string ClientSettingsProto_DisplayString::GetTypeName() const {
  return "autofill_assistant.ClientSettingsProto.DisplayString";
}


// ===================================================================

class ClientSettingsProto::_Internal {
 public:
  using HasBits = decltype(std::declval<ClientSettingsProto>()._has_bits_);
  static void set_has_periodic_script_check_interval_ms(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_periodic_element_check_interval_ms(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_periodic_script_check_count(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_element_position_update_interval_ms(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_short_wait_for_element_deadline_ms(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_box_model_check_interval_ms(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_box_model_check_count(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_document_ready_check_timeout_ms(HasBits* has_bits) {
    (*has_bits)[0] |= 131072u;
  }
  static void set_has_cancel_delay_ms(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_tap_count(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_tap_tracking_duration_ms(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_tap_shutdown_delay_ms(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static const ::autofill_assistant::OverlayImageProto& overlay_image(const ClientSettingsProto* msg);
  static void set_has_overlay_image(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::autofill_assistant::ClientSettingsProto_IntegrationTestSettings& integration_test_settings(const ClientSettingsProto* msg);
  static void set_has_integration_test_settings(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_talkback_sheet_size_fraction(HasBits* has_bits) {
    (*has_bits)[0] |= 65536u;
  }
  static const ::autofill_assistant::ClientSettingsProto_BackButtonSettings& back_button_settings(const ClientSettingsProto* msg);
  static void set_has_back_button_settings(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::autofill_assistant::ClientSettingsProto_SlowWarningSettings& slow_warning_settings(const ClientSettingsProto* msg);
  static void set_has_slow_warning_settings(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_display_strings_locale(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_selector_observer_extra_timeout_ms(HasBits* has_bits) {
    (*has_bits)[0] |= 262144u;
  }
  static void set_has_selector_observer_debounce_interval_ms(HasBits* has_bits) {
    (*has_bits)[0] |= 524288u;
  }
};

const ::autofill_assistant::OverlayImageProto&
ClientSettingsProto::_Internal::overlay_image(const ClientSettingsProto* msg) {
  return *msg->overlay_image_;
}
const ::autofill_assistant::ClientSettingsProto_IntegrationTestSettings&
ClientSettingsProto::_Internal::integration_test_settings(const ClientSettingsProto* msg) {
  return *msg->integration_test_settings_;
}
const ::autofill_assistant::ClientSettingsProto_BackButtonSettings&
ClientSettingsProto::_Internal::back_button_settings(const ClientSettingsProto* msg) {
  return *msg->back_button_settings_;
}
const ::autofill_assistant::ClientSettingsProto_SlowWarningSettings&
ClientSettingsProto::_Internal::slow_warning_settings(const ClientSettingsProto* msg) {
  return *msg->slow_warning_settings_;
}
ClientSettingsProto::ClientSettingsProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  display_strings_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.ClientSettingsProto)
}
ClientSettingsProto::ClientSettingsProto(const ClientSettingsProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      display_strings_(from.display_strings_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  display_strings_locale_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    display_strings_locale_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_display_strings_locale()) {
    display_strings_locale_.Set(from._internal_display_strings_locale(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_overlay_image()) {
    overlay_image_ = new ::autofill_assistant::OverlayImageProto(*from.overlay_image_);
  } else {
    overlay_image_ = nullptr;
  }
  if (from._internal_has_integration_test_settings()) {
    integration_test_settings_ = new ::autofill_assistant::ClientSettingsProto_IntegrationTestSettings(*from.integration_test_settings_);
  } else {
    integration_test_settings_ = nullptr;
  }
  if (from._internal_has_back_button_settings()) {
    back_button_settings_ = new ::autofill_assistant::ClientSettingsProto_BackButtonSettings(*from.back_button_settings_);
  } else {
    back_button_settings_ = nullptr;
  }
  if (from._internal_has_slow_warning_settings()) {
    slow_warning_settings_ = new ::autofill_assistant::ClientSettingsProto_SlowWarningSettings(*from.slow_warning_settings_);
  } else {
    slow_warning_settings_ = nullptr;
  }
  ::memcpy(&periodic_script_check_interval_ms_, &from.periodic_script_check_interval_ms_,
    static_cast<size_t>(reinterpret_cast<char*>(&selector_observer_debounce_interval_ms_) -
    reinterpret_cast<char*>(&periodic_script_check_interval_ms_)) + sizeof(selector_observer_debounce_interval_ms_));
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.ClientSettingsProto)
}

inline void ClientSettingsProto::SharedCtor() {
display_strings_locale_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  display_strings_locale_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&overlay_image_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&selector_observer_debounce_interval_ms_) -
    reinterpret_cast<char*>(&overlay_image_)) + sizeof(selector_observer_debounce_interval_ms_));
}

ClientSettingsProto::~ClientSettingsProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.ClientSettingsProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ClientSettingsProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  display_strings_locale_.Destroy();
  if (this != internal_default_instance()) delete overlay_image_;
  if (this != internal_default_instance()) delete integration_test_settings_;
  if (this != internal_default_instance()) delete back_button_settings_;
  if (this != internal_default_instance()) delete slow_warning_settings_;
}

void ClientSettingsProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ClientSettingsProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.ClientSettingsProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  display_strings_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      display_strings_locale_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(overlay_image_ != nullptr);
      overlay_image_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(integration_test_settings_ != nullptr);
      integration_test_settings_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(back_button_settings_ != nullptr);
      back_button_settings_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(slow_warning_settings_ != nullptr);
      slow_warning_settings_->Clear();
    }
  }
  if (cached_has_bits & 0x000000e0u) {
    ::memset(&periodic_script_check_interval_ms_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&periodic_script_check_count_) -
        reinterpret_cast<char*>(&periodic_script_check_interval_ms_)) + sizeof(periodic_script_check_count_));
  }
  if (cached_has_bits & 0x0000ff00u) {
    ::memset(&element_position_update_interval_ms_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&tap_shutdown_delay_ms_) -
        reinterpret_cast<char*>(&element_position_update_interval_ms_)) + sizeof(tap_shutdown_delay_ms_));
  }
  if (cached_has_bits & 0x000f0000u) {
    ::memset(&talkback_sheet_size_fraction_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&selector_observer_debounce_interval_ms_) -
        reinterpret_cast<char*>(&talkback_sheet_size_fraction_)) + sizeof(selector_observer_debounce_interval_ms_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ClientSettingsProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 periodic_script_check_interval_ms = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_periodic_script_check_interval_ms(&has_bits);
          periodic_script_check_interval_ms_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 periodic_element_check_interval_ms = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_periodic_element_check_interval_ms(&has_bits);
          periodic_element_check_interval_ms_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 periodic_script_check_count = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_periodic_script_check_count(&has_bits);
          periodic_script_check_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 element_position_update_interval_ms = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_element_position_update_interval_ms(&has_bits);
          element_position_update_interval_ms_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 short_wait_for_element_deadline_ms = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_short_wait_for_element_deadline_ms(&has_bits);
          short_wait_for_element_deadline_ms_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 box_model_check_interval_ms = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_box_model_check_interval_ms(&has_bits);
          box_model_check_interval_ms_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 box_model_check_count = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_box_model_check_count(&has_bits);
          box_model_check_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 cancel_delay_ms = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_cancel_delay_ms(&has_bits);
          cancel_delay_ms_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 tap_count = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          _Internal::set_has_tap_count(&has_bits);
          tap_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 tap_tracking_duration_ms = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          _Internal::set_has_tap_tracking_duration_ms(&has_bits);
          tap_tracking_duration_ms_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 tap_shutdown_delay_ms = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 120)) {
          _Internal::set_has_tap_shutdown_delay_ms(&has_bits);
          tap_shutdown_delay_ms_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .autofill_assistant.OverlayImageProto overlay_image = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 130)) {
          ptr = ctx->ParseMessage(_internal_mutable_overlay_image(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .autofill_assistant.ClientSettingsProto.IntegrationTestSettings integration_test_settings = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 138)) {
          ptr = ctx->ParseMessage(_internal_mutable_integration_test_settings(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float talkback_sheet_size_fraction = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 149)) {
          _Internal::set_has_talkback_sheet_size_fraction(&has_bits);
          talkback_sheet_size_fraction_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional .autofill_assistant.ClientSettingsProto.BackButtonSettings back_button_settings = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 154)) {
          ptr = ctx->ParseMessage(_internal_mutable_back_button_settings(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 document_ready_check_timeout_ms = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 160)) {
          _Internal::set_has_document_ready_check_timeout_ms(&has_bits);
          document_ready_check_timeout_ms_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .autofill_assistant.ClientSettingsProto.SlowWarningSettings slow_warning_settings = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 170)) {
          ptr = ctx->ParseMessage(_internal_mutable_slow_warning_settings(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .autofill_assistant.ClientSettingsProto.DisplayString display_strings = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 178)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_display_strings(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<178>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional string display_strings_locale = 23;
      case 23:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 186)) {
          auto str = _internal_mutable_display_strings_locale();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 selector_observer_extra_timeout_ms = 24;
      case 24:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 192)) {
          _Internal::set_has_selector_observer_extra_timeout_ms(&has_bits);
          selector_observer_extra_timeout_ms_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 selector_observer_debounce_interval_ms = 25;
      case 25:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 200)) {
          _Internal::set_has_selector_observer_debounce_interval_ms(&has_bits);
          selector_observer_debounce_interval_ms_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ClientSettingsProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.ClientSettingsProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 periodic_script_check_interval_ms = 1;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_periodic_script_check_interval_ms(), target);
  }

  // optional int32 periodic_element_check_interval_ms = 2;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_periodic_element_check_interval_ms(), target);
  }

  // optional int32 periodic_script_check_count = 3;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_periodic_script_check_count(), target);
  }

  // optional int32 element_position_update_interval_ms = 4;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_element_position_update_interval_ms(), target);
  }

  // optional int32 short_wait_for_element_deadline_ms = 5;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_short_wait_for_element_deadline_ms(), target);
  }

  // optional int32 box_model_check_interval_ms = 6;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(6, this->_internal_box_model_check_interval_ms(), target);
  }

  // optional int32 box_model_check_count = 7;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(7, this->_internal_box_model_check_count(), target);
  }

  // optional int32 cancel_delay_ms = 12;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(12, this->_internal_cancel_delay_ms(), target);
  }

  // optional int32 tap_count = 13;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(13, this->_internal_tap_count(), target);
  }

  // optional int32 tap_tracking_duration_ms = 14;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(14, this->_internal_tap_tracking_duration_ms(), target);
  }

  // optional int32 tap_shutdown_delay_ms = 15;
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(15, this->_internal_tap_shutdown_delay_ms(), target);
  }

  // optional .autofill_assistant.OverlayImageProto overlay_image = 16;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(16, _Internal::overlay_image(this),
        _Internal::overlay_image(this).GetCachedSize(), target, stream);
  }

  // optional .autofill_assistant.ClientSettingsProto.IntegrationTestSettings integration_test_settings = 17;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(17, _Internal::integration_test_settings(this),
        _Internal::integration_test_settings(this).GetCachedSize(), target, stream);
  }

  // optional float talkback_sheet_size_fraction = 18;
  if (cached_has_bits & 0x00010000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(18, this->_internal_talkback_sheet_size_fraction(), target);
  }

  // optional .autofill_assistant.ClientSettingsProto.BackButtonSettings back_button_settings = 19;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(19, _Internal::back_button_settings(this),
        _Internal::back_button_settings(this).GetCachedSize(), target, stream);
  }

  // optional int32 document_ready_check_timeout_ms = 20;
  if (cached_has_bits & 0x00020000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(20, this->_internal_document_ready_check_timeout_ms(), target);
  }

  // optional .autofill_assistant.ClientSettingsProto.SlowWarningSettings slow_warning_settings = 21;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(21, _Internal::slow_warning_settings(this),
        _Internal::slow_warning_settings(this).GetCachedSize(), target, stream);
  }

  // repeated .autofill_assistant.ClientSettingsProto.DisplayString display_strings = 22;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_display_strings_size()); i < n; i++) {
    const auto& repfield = this->_internal_display_strings(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(22, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional string display_strings_locale = 23;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        23, this->_internal_display_strings_locale(), target);
  }

  // optional int32 selector_observer_extra_timeout_ms = 24;
  if (cached_has_bits & 0x00040000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(24, this->_internal_selector_observer_extra_timeout_ms(), target);
  }

  // optional int32 selector_observer_debounce_interval_ms = 25;
  if (cached_has_bits & 0x00080000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(25, this->_internal_selector_observer_debounce_interval_ms(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.ClientSettingsProto)
  return target;
}

size_t ClientSettingsProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.ClientSettingsProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .autofill_assistant.ClientSettingsProto.DisplayString display_strings = 22;
  total_size += 2UL * this->_internal_display_strings_size();
  for (const auto& msg : this->display_strings_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string display_strings_locale = 23;
    if (cached_has_bits & 0x00000001u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_display_strings_locale());
    }

    // optional .autofill_assistant.OverlayImageProto overlay_image = 16;
    if (cached_has_bits & 0x00000002u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *overlay_image_);
    }

    // optional .autofill_assistant.ClientSettingsProto.IntegrationTestSettings integration_test_settings = 17;
    if (cached_has_bits & 0x00000004u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *integration_test_settings_);
    }

    // optional .autofill_assistant.ClientSettingsProto.BackButtonSettings back_button_settings = 19;
    if (cached_has_bits & 0x00000008u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *back_button_settings_);
    }

    // optional .autofill_assistant.ClientSettingsProto.SlowWarningSettings slow_warning_settings = 21;
    if (cached_has_bits & 0x00000010u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *slow_warning_settings_);
    }

    // optional int32 periodic_script_check_interval_ms = 1;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_periodic_script_check_interval_ms());
    }

    // optional int32 periodic_element_check_interval_ms = 2;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_periodic_element_check_interval_ms());
    }

    // optional int32 periodic_script_check_count = 3;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_periodic_script_check_count());
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional int32 element_position_update_interval_ms = 4;
    if (cached_has_bits & 0x00000100u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_element_position_update_interval_ms());
    }

    // optional int32 short_wait_for_element_deadline_ms = 5;
    if (cached_has_bits & 0x00000200u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_short_wait_for_element_deadline_ms());
    }

    // optional int32 box_model_check_interval_ms = 6;
    if (cached_has_bits & 0x00000400u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_box_model_check_interval_ms());
    }

    // optional int32 box_model_check_count = 7;
    if (cached_has_bits & 0x00000800u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_box_model_check_count());
    }

    // optional int32 cancel_delay_ms = 12;
    if (cached_has_bits & 0x00001000u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_cancel_delay_ms());
    }

    // optional int32 tap_count = 13;
    if (cached_has_bits & 0x00002000u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_tap_count());
    }

    // optional int32 tap_tracking_duration_ms = 14;
    if (cached_has_bits & 0x00004000u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_tap_tracking_duration_ms());
    }

    // optional int32 tap_shutdown_delay_ms = 15;
    if (cached_has_bits & 0x00008000u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_tap_shutdown_delay_ms());
    }

  }
  if (cached_has_bits & 0x000f0000u) {
    // optional float talkback_sheet_size_fraction = 18;
    if (cached_has_bits & 0x00010000u) {
      total_size += 2 + 4;
    }

    // optional int32 document_ready_check_timeout_ms = 20;
    if (cached_has_bits & 0x00020000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int32Size(
          this->_internal_document_ready_check_timeout_ms());
    }

    // optional int32 selector_observer_extra_timeout_ms = 24;
    if (cached_has_bits & 0x00040000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int32Size(
          this->_internal_selector_observer_extra_timeout_ms());
    }

    // optional int32 selector_observer_debounce_interval_ms = 25;
    if (cached_has_bits & 0x00080000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int32Size(
          this->_internal_selector_observer_debounce_interval_ms());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ClientSettingsProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ClientSettingsProto*>(
      &from));
}

void ClientSettingsProto::MergeFrom(const ClientSettingsProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.ClientSettingsProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  display_strings_.MergeFrom(from.display_strings_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_display_strings_locale(from._internal_display_strings_locale());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_overlay_image()->::autofill_assistant::OverlayImageProto::MergeFrom(from._internal_overlay_image());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_integration_test_settings()->::autofill_assistant::ClientSettingsProto_IntegrationTestSettings::MergeFrom(from._internal_integration_test_settings());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_mutable_back_button_settings()->::autofill_assistant::ClientSettingsProto_BackButtonSettings::MergeFrom(from._internal_back_button_settings());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_mutable_slow_warning_settings()->::autofill_assistant::ClientSettingsProto_SlowWarningSettings::MergeFrom(from._internal_slow_warning_settings());
    }
    if (cached_has_bits & 0x00000020u) {
      periodic_script_check_interval_ms_ = from.periodic_script_check_interval_ms_;
    }
    if (cached_has_bits & 0x00000040u) {
      periodic_element_check_interval_ms_ = from.periodic_element_check_interval_ms_;
    }
    if (cached_has_bits & 0x00000080u) {
      periodic_script_check_count_ = from.periodic_script_check_count_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      element_position_update_interval_ms_ = from.element_position_update_interval_ms_;
    }
    if (cached_has_bits & 0x00000200u) {
      short_wait_for_element_deadline_ms_ = from.short_wait_for_element_deadline_ms_;
    }
    if (cached_has_bits & 0x00000400u) {
      box_model_check_interval_ms_ = from.box_model_check_interval_ms_;
    }
    if (cached_has_bits & 0x00000800u) {
      box_model_check_count_ = from.box_model_check_count_;
    }
    if (cached_has_bits & 0x00001000u) {
      cancel_delay_ms_ = from.cancel_delay_ms_;
    }
    if (cached_has_bits & 0x00002000u) {
      tap_count_ = from.tap_count_;
    }
    if (cached_has_bits & 0x00004000u) {
      tap_tracking_duration_ms_ = from.tap_tracking_duration_ms_;
    }
    if (cached_has_bits & 0x00008000u) {
      tap_shutdown_delay_ms_ = from.tap_shutdown_delay_ms_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x000f0000u) {
    if (cached_has_bits & 0x00010000u) {
      talkback_sheet_size_fraction_ = from.talkback_sheet_size_fraction_;
    }
    if (cached_has_bits & 0x00020000u) {
      document_ready_check_timeout_ms_ = from.document_ready_check_timeout_ms_;
    }
    if (cached_has_bits & 0x00040000u) {
      selector_observer_extra_timeout_ms_ = from.selector_observer_extra_timeout_ms_;
    }
    if (cached_has_bits & 0x00080000u) {
      selector_observer_debounce_interval_ms_ = from.selector_observer_debounce_interval_ms_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClientSettingsProto::CopyFrom(const ClientSettingsProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.ClientSettingsProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClientSettingsProto::IsInitialized() const {
  return true;
}

void ClientSettingsProto::InternalSwap(ClientSettingsProto* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  display_strings_.InternalSwap(&other->display_strings_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &display_strings_locale_, lhs_arena,
      &other->display_strings_locale_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ClientSettingsProto, selector_observer_debounce_interval_ms_)
      + sizeof(ClientSettingsProto::selector_observer_debounce_interval_ms_)
      - PROTOBUF_FIELD_OFFSET(ClientSettingsProto, overlay_image_)>(
          reinterpret_cast<char*>(&overlay_image_),
          reinterpret_cast<char*>(&other->overlay_image_));
}

std::string ClientSettingsProto::GetTypeName() const {
  return "autofill_assistant.ClientSettingsProto";
}


// ===================================================================

class ScriptTimeoutError::_Internal {
 public:
  using HasBits = decltype(std::declval<ScriptTimeoutError>()._has_bits_);
  static void set_has_timeout_ms(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_script_path(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

ScriptTimeoutError::ScriptTimeoutError(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.ScriptTimeoutError)
}
ScriptTimeoutError::ScriptTimeoutError(const ScriptTimeoutError& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  script_path_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    script_path_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_script_path()) {
    script_path_.Set(from._internal_script_path(), 
      GetArenaForAllocation());
  }
  timeout_ms_ = from.timeout_ms_;
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.ScriptTimeoutError)
}

inline void ScriptTimeoutError::SharedCtor() {
script_path_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  script_path_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
timeout_ms_ = 0;
}

ScriptTimeoutError::~ScriptTimeoutError() {
  // @@protoc_insertion_point(destructor:autofill_assistant.ScriptTimeoutError)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ScriptTimeoutError::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  script_path_.Destroy();
}

void ScriptTimeoutError::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ScriptTimeoutError::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.ScriptTimeoutError)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    script_path_.ClearNonDefaultToEmpty();
  }
  timeout_ms_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ScriptTimeoutError::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 timeout_ms = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_timeout_ms(&has_bits);
          timeout_ms_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string script_path = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_script_path();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ScriptTimeoutError::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.ScriptTimeoutError)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 timeout_ms = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_timeout_ms(), target);
  }

  // optional string script_path = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_script_path(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.ScriptTimeoutError)
  return target;
}

size_t ScriptTimeoutError::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.ScriptTimeoutError)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string script_path = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_script_path());
    }

    // optional int32 timeout_ms = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_timeout_ms());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ScriptTimeoutError::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ScriptTimeoutError*>(
      &from));
}

void ScriptTimeoutError::MergeFrom(const ScriptTimeoutError& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.ScriptTimeoutError)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_script_path(from._internal_script_path());
    }
    if (cached_has_bits & 0x00000002u) {
      timeout_ms_ = from.timeout_ms_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ScriptTimeoutError::CopyFrom(const ScriptTimeoutError& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.ScriptTimeoutError)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ScriptTimeoutError::IsInitialized() const {
  return true;
}

void ScriptTimeoutError::InternalSwap(ScriptTimeoutError* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &script_path_, lhs_arena,
      &other->script_path_, rhs_arena
  );
  swap(timeout_ms_, other->timeout_ms_);
}

std::string ScriptTimeoutError::GetTypeName() const {
  return "autofill_assistant.ScriptTimeoutError";
}


// ===================================================================

class SupportedScriptProto_PresentationProto::_Internal {
 public:
  using HasBits = decltype(std::declval<SupportedScriptProto_PresentationProto>()._has_bits_);
  static const ::autofill_assistant::ScriptPreconditionProto& precondition(const SupportedScriptProto_PresentationProto* msg);
  static void set_has_precondition(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_priority(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::autofill_assistant::DirectActionProto& direct_action(const SupportedScriptProto_PresentationProto* msg);
  static void set_has_direct_action(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_autostart(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_interrupt(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_start_message(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_needs_ui(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
};

const ::autofill_assistant::ScriptPreconditionProto&
SupportedScriptProto_PresentationProto::_Internal::precondition(const SupportedScriptProto_PresentationProto* msg) {
  return *msg->precondition_;
}
const ::autofill_assistant::DirectActionProto&
SupportedScriptProto_PresentationProto::_Internal::direct_action(const SupportedScriptProto_PresentationProto* msg) {
  return *msg->direct_action_;
}
void SupportedScriptProto_PresentationProto::clear_direct_action() {
  if (direct_action_ != nullptr) direct_action_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
SupportedScriptProto_PresentationProto::SupportedScriptProto_PresentationProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.SupportedScriptProto.PresentationProto)
}
SupportedScriptProto_PresentationProto::SupportedScriptProto_PresentationProto(const SupportedScriptProto_PresentationProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  start_message_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    start_message_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_start_message()) {
    start_message_.Set(from._internal_start_message(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_precondition()) {
    precondition_ = new ::autofill_assistant::ScriptPreconditionProto(*from.precondition_);
  } else {
    precondition_ = nullptr;
  }
  if (from._internal_has_direct_action()) {
    direct_action_ = new ::autofill_assistant::DirectActionProto(*from.direct_action_);
  } else {
    direct_action_ = nullptr;
  }
  ::memcpy(&priority_, &from.priority_,
    static_cast<size_t>(reinterpret_cast<char*>(&needs_ui_) -
    reinterpret_cast<char*>(&priority_)) + sizeof(needs_ui_));
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.SupportedScriptProto.PresentationProto)
}

inline void SupportedScriptProto_PresentationProto::SharedCtor() {
start_message_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  start_message_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&precondition_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&interrupt_) -
    reinterpret_cast<char*>(&precondition_)) + sizeof(interrupt_));
needs_ui_ = true;
}

SupportedScriptProto_PresentationProto::~SupportedScriptProto_PresentationProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.SupportedScriptProto.PresentationProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SupportedScriptProto_PresentationProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  start_message_.Destroy();
  if (this != internal_default_instance()) delete precondition_;
  if (this != internal_default_instance()) delete direct_action_;
}

void SupportedScriptProto_PresentationProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SupportedScriptProto_PresentationProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.SupportedScriptProto.PresentationProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      start_message_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(precondition_ != nullptr);
      precondition_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(direct_action_ != nullptr);
      direct_action_->Clear();
    }
  }
  if (cached_has_bits & 0x00000078u) {
    ::memset(&priority_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&interrupt_) -
        reinterpret_cast<char*>(&priority_)) + sizeof(interrupt_));
    needs_ui_ = true;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* SupportedScriptProto_PresentationProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .autofill_assistant.ScriptPreconditionProto precondition = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_precondition(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 priority = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_priority(&has_bits);
          priority_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool autostart = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_autostart(&has_bits);
          autostart_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool interrupt = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_interrupt(&has_bits);
          interrupt_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .autofill_assistant.DirectActionProto direct_action = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          ptr = ctx->ParseMessage(_internal_mutable_direct_action(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string start_message = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 114)) {
          auto str = _internal_mutable_start_message();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool needs_ui = 15 [default = true];
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 120)) {
          _Internal::set_has_needs_ui(&has_bits);
          needs_ui_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SupportedScriptProto_PresentationProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.SupportedScriptProto.PresentationProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .autofill_assistant.ScriptPreconditionProto precondition = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::precondition(this),
        _Internal::precondition(this).GetCachedSize(), target, stream);
  }

  // optional int32 priority = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_priority(), target);
  }

  // optional bool autostart = 8;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(8, this->_internal_autostart(), target);
  }

  // optional bool interrupt = 9;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(9, this->_internal_interrupt(), target);
  }

  // optional .autofill_assistant.DirectActionProto direct_action = 13;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(13, _Internal::direct_action(this),
        _Internal::direct_action(this).GetCachedSize(), target, stream);
  }

  // optional string start_message = 14;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        14, this->_internal_start_message(), target);
  }

  // optional bool needs_ui = 15 [default = true];
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(15, this->_internal_needs_ui(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.SupportedScriptProto.PresentationProto)
  return target;
}

size_t SupportedScriptProto_PresentationProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.SupportedScriptProto.PresentationProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // optional string start_message = 14;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_start_message());
    }

    // optional .autofill_assistant.ScriptPreconditionProto precondition = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *precondition_);
    }

    // optional .autofill_assistant.DirectActionProto direct_action = 13;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *direct_action_);
    }

    // optional int32 priority = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_priority());
    }

    // optional bool autostart = 8;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 1;
    }

    // optional bool interrupt = 9;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 1;
    }

    // optional bool needs_ui = 15 [default = true];
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 1;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SupportedScriptProto_PresentationProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const SupportedScriptProto_PresentationProto*>(
      &from));
}

void SupportedScriptProto_PresentationProto::MergeFrom(const SupportedScriptProto_PresentationProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.SupportedScriptProto.PresentationProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_start_message(from._internal_start_message());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_precondition()->::autofill_assistant::ScriptPreconditionProto::MergeFrom(from._internal_precondition());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_direct_action()->::autofill_assistant::DirectActionProto::MergeFrom(from._internal_direct_action());
    }
    if (cached_has_bits & 0x00000008u) {
      priority_ = from.priority_;
    }
    if (cached_has_bits & 0x00000010u) {
      autostart_ = from.autostart_;
    }
    if (cached_has_bits & 0x00000020u) {
      interrupt_ = from.interrupt_;
    }
    if (cached_has_bits & 0x00000040u) {
      needs_ui_ = from.needs_ui_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SupportedScriptProto_PresentationProto::CopyFrom(const SupportedScriptProto_PresentationProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.SupportedScriptProto.PresentationProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SupportedScriptProto_PresentationProto::IsInitialized() const {
  return true;
}

void SupportedScriptProto_PresentationProto::InternalSwap(SupportedScriptProto_PresentationProto* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &start_message_, lhs_arena,
      &other->start_message_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SupportedScriptProto_PresentationProto, interrupt_)
      + sizeof(SupportedScriptProto_PresentationProto::interrupt_)
      - PROTOBUF_FIELD_OFFSET(SupportedScriptProto_PresentationProto, precondition_)>(
          reinterpret_cast<char*>(&precondition_),
          reinterpret_cast<char*>(&other->precondition_));
  swap(needs_ui_, other->needs_ui_);
}

std::string SupportedScriptProto_PresentationProto::GetTypeName() const {
  return "autofill_assistant.SupportedScriptProto.PresentationProto";
}


// ===================================================================

class SupportedScriptProto::_Internal {
 public:
  using HasBits = decltype(std::declval<SupportedScriptProto>()._has_bits_);
  static void set_has_path(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::autofill_assistant::SupportedScriptProto_PresentationProto& presentation(const SupportedScriptProto* msg);
  static void set_has_presentation(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::autofill_assistant::SupportedScriptProto_PresentationProto&
SupportedScriptProto::_Internal::presentation(const SupportedScriptProto* msg) {
  return *msg->presentation_;
}
SupportedScriptProto::SupportedScriptProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.SupportedScriptProto)
}
SupportedScriptProto::SupportedScriptProto(const SupportedScriptProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  path_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    path_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_path()) {
    path_.Set(from._internal_path(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_presentation()) {
    presentation_ = new ::autofill_assistant::SupportedScriptProto_PresentationProto(*from.presentation_);
  } else {
    presentation_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.SupportedScriptProto)
}

inline void SupportedScriptProto::SharedCtor() {
path_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  path_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
presentation_ = nullptr;
}

SupportedScriptProto::~SupportedScriptProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.SupportedScriptProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SupportedScriptProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  path_.Destroy();
  if (this != internal_default_instance()) delete presentation_;
}

void SupportedScriptProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SupportedScriptProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.SupportedScriptProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      path_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(presentation_ != nullptr);
      presentation_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* SupportedScriptProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string path = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_path();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .autofill_assistant.SupportedScriptProto.PresentationProto presentation = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_presentation(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SupportedScriptProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.SupportedScriptProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string path = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_path(), target);
  }

  // optional .autofill_assistant.SupportedScriptProto.PresentationProto presentation = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::presentation(this),
        _Internal::presentation(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.SupportedScriptProto)
  return target;
}

size_t SupportedScriptProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.SupportedScriptProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string path = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_path());
    }

    // optional .autofill_assistant.SupportedScriptProto.PresentationProto presentation = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *presentation_);
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SupportedScriptProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const SupportedScriptProto*>(
      &from));
}

void SupportedScriptProto::MergeFrom(const SupportedScriptProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.SupportedScriptProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_path(from._internal_path());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_presentation()->::autofill_assistant::SupportedScriptProto_PresentationProto::MergeFrom(from._internal_presentation());
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SupportedScriptProto::CopyFrom(const SupportedScriptProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.SupportedScriptProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SupportedScriptProto::IsInitialized() const {
  return true;
}

void SupportedScriptProto::InternalSwap(SupportedScriptProto* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &path_, lhs_arena,
      &other->path_, rhs_arena
  );
  swap(presentation_, other->presentation_);
}

std::string SupportedScriptProto::GetTypeName() const {
  return "autofill_assistant.SupportedScriptProto";
}


// ===================================================================

class ScriptPreconditionProto::_Internal {
 public:
  using HasBits = decltype(std::declval<ScriptPreconditionProto>()._has_bits_);
  static const ::autofill_assistant::ElementConditionProto& element_condition(const ScriptPreconditionProto* msg);
  static void set_has_element_condition(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::autofill_assistant::ElementConditionProto&
ScriptPreconditionProto::_Internal::element_condition(const ScriptPreconditionProto* msg) {
  return *msg->element_condition_;
}
ScriptPreconditionProto::ScriptPreconditionProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  path_pattern_(arena),
  domain_(arena),
  script_parameter_match_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.ScriptPreconditionProto)
}
ScriptPreconditionProto::ScriptPreconditionProto(const ScriptPreconditionProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      path_pattern_(from.path_pattern_),
      domain_(from.domain_),
      script_parameter_match_(from.script_parameter_match_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_element_condition()) {
    element_condition_ = new ::autofill_assistant::ElementConditionProto(*from.element_condition_);
  } else {
    element_condition_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.ScriptPreconditionProto)
}

inline void ScriptPreconditionProto::SharedCtor() {
element_condition_ = nullptr;
}

ScriptPreconditionProto::~ScriptPreconditionProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.ScriptPreconditionProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ScriptPreconditionProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete element_condition_;
}

void ScriptPreconditionProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ScriptPreconditionProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.ScriptPreconditionProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  path_pattern_.Clear();
  domain_.Clear();
  script_parameter_match_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(element_condition_ != nullptr);
    element_condition_->Clear();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ScriptPreconditionProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated string path_pattern = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_path_pattern();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated string domain = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_domain();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .autofill_assistant.ScriptParameterMatchProto script_parameter_match = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_script_parameter_match(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<58>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .autofill_assistant.ElementConditionProto element_condition = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_element_condition(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ScriptPreconditionProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.ScriptPreconditionProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated string path_pattern = 5;
  for (int i = 0, n = this->_internal_path_pattern_size(); i < n; i++) {
    const auto& s = this->_internal_path_pattern(i);
    target = stream->WriteString(5, s, target);
  }

  // repeated string domain = 6;
  for (int i = 0, n = this->_internal_domain_size(); i < n; i++) {
    const auto& s = this->_internal_domain(i);
    target = stream->WriteString(6, s, target);
  }

  // repeated .autofill_assistant.ScriptParameterMatchProto script_parameter_match = 7;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_script_parameter_match_size()); i < n; i++) {
    const auto& repfield = this->_internal_script_parameter_match(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(7, repfield, repfield.GetCachedSize(), target, stream);
  }

  cached_has_bits = _has_bits_[0];
  // optional .autofill_assistant.ElementConditionProto element_condition = 10;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(10, _Internal::element_condition(this),
        _Internal::element_condition(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.ScriptPreconditionProto)
  return target;
}

size_t ScriptPreconditionProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.ScriptPreconditionProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string path_pattern = 5;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(path_pattern_.size());
  for (int i = 0, n = path_pattern_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      path_pattern_.Get(i));
  }

  // repeated string domain = 6;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(domain_.size());
  for (int i = 0, n = domain_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      domain_.Get(i));
  }

  // repeated .autofill_assistant.ScriptParameterMatchProto script_parameter_match = 7;
  total_size += 1UL * this->_internal_script_parameter_match_size();
  for (const auto& msg : this->script_parameter_match_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional .autofill_assistant.ElementConditionProto element_condition = 10;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *element_condition_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ScriptPreconditionProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ScriptPreconditionProto*>(
      &from));
}

void ScriptPreconditionProto::MergeFrom(const ScriptPreconditionProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.ScriptPreconditionProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  path_pattern_.MergeFrom(from.path_pattern_);
  domain_.MergeFrom(from.domain_);
  script_parameter_match_.MergeFrom(from.script_parameter_match_);
  if (from._internal_has_element_condition()) {
    _internal_mutable_element_condition()->::autofill_assistant::ElementConditionProto::MergeFrom(from._internal_element_condition());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ScriptPreconditionProto::CopyFrom(const ScriptPreconditionProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.ScriptPreconditionProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ScriptPreconditionProto::IsInitialized() const {
  return true;
}

void ScriptPreconditionProto::InternalSwap(ScriptPreconditionProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  path_pattern_.InternalSwap(&other->path_pattern_);
  domain_.InternalSwap(&other->domain_);
  script_parameter_match_.InternalSwap(&other->script_parameter_match_);
  swap(element_condition_, other->element_condition_);
}

std::string ScriptPreconditionProto::GetTypeName() const {
  return "autofill_assistant.ScriptPreconditionProto";
}


// ===================================================================

class ScriptParameterMatchProto::_Internal {
 public:
  using HasBits = decltype(std::declval<ScriptParameterMatchProto>()._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_exists(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_value_equals(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

ScriptParameterMatchProto::ScriptParameterMatchProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.ScriptParameterMatchProto)
}
ScriptParameterMatchProto::ScriptParameterMatchProto(const ScriptParameterMatchProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  value_equals_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    value_equals_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_value_equals()) {
    value_equals_.Set(from._internal_value_equals(), 
      GetArenaForAllocation());
  }
  name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    name_.Set(from._internal_name(), 
      GetArenaForAllocation());
  }
  exists_ = from.exists_;
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.ScriptParameterMatchProto)
}

inline void ScriptParameterMatchProto::SharedCtor() {
value_equals_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  value_equals_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
exists_ = true;
}

ScriptParameterMatchProto::~ScriptParameterMatchProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.ScriptParameterMatchProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ScriptParameterMatchProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  value_equals_.Destroy();
  name_.Destroy();
}

void ScriptParameterMatchProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ScriptParameterMatchProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.ScriptParameterMatchProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      value_equals_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      name_.ClearNonDefaultToEmpty();
    }
    exists_ = true;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ScriptParameterMatchProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool exists = 2 [default = true];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_exists(&has_bits);
          exists_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string value_equals = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_value_equals();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string name = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ScriptParameterMatchProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.ScriptParameterMatchProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bool exists = 2 [default = true];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_exists(), target);
  }

  // optional string value_equals = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_value_equals(), target);
  }

  // optional string name = 4;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_name(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.ScriptParameterMatchProto)
  return target;
}

size_t ScriptParameterMatchProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.ScriptParameterMatchProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string value_equals = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_value_equals());
    }

    // optional string name = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional bool exists = 2 [default = true];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ScriptParameterMatchProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ScriptParameterMatchProto*>(
      &from));
}

void ScriptParameterMatchProto::MergeFrom(const ScriptParameterMatchProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.ScriptParameterMatchProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_value_equals(from._internal_value_equals());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000004u) {
      exists_ = from.exists_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ScriptParameterMatchProto::CopyFrom(const ScriptParameterMatchProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.ScriptParameterMatchProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ScriptParameterMatchProto::IsInitialized() const {
  return true;
}

void ScriptParameterMatchProto::InternalSwap(ScriptParameterMatchProto* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &value_equals_, lhs_arena,
      &other->value_equals_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &name_, lhs_arena,
      &other->name_, rhs_arena
  );
  swap(exists_, other->exists_);
}

std::string ScriptParameterMatchProto::GetTypeName() const {
  return "autofill_assistant.ScriptParameterMatchProto";
}


// ===================================================================

class CUPRequestData::_Internal {
 public:
  using HasBits = decltype(std::declval<CUPRequestData>()._has_bits_);
  static void set_has_request(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_query_cup2key(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_hash_hex(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

CUPRequestData::CUPRequestData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.CUPRequestData)
}
CUPRequestData::CUPRequestData(const CUPRequestData& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  request_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    request_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_request()) {
    request_.Set(from._internal_request(), 
      GetArenaForAllocation());
  }
  query_cup2key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    query_cup2key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_query_cup2key()) {
    query_cup2key_.Set(from._internal_query_cup2key(), 
      GetArenaForAllocation());
  }
  hash_hex_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    hash_hex_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_hash_hex()) {
    hash_hex_.Set(from._internal_hash_hex(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.CUPRequestData)
}

inline void CUPRequestData::SharedCtor() {
request_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  request_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
query_cup2key_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  query_cup2key_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
hash_hex_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  hash_hex_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CUPRequestData::~CUPRequestData() {
  // @@protoc_insertion_point(destructor:autofill_assistant.CUPRequestData)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CUPRequestData::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  request_.Destroy();
  query_cup2key_.Destroy();
  hash_hex_.Destroy();
}

void CUPRequestData::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CUPRequestData::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.CUPRequestData)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      request_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      query_cup2key_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      hash_hex_.ClearNonDefaultToEmpty();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CUPRequestData::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes request = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_request();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes query_cup2key = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_query_cup2key();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes hash_hex = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_hash_hex();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CUPRequestData::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.CUPRequestData)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bytes request = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_request(), target);
  }

  // optional bytes query_cup2key = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_query_cup2key(), target);
  }

  // optional bytes hash_hex = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_hash_hex(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.CUPRequestData)
  return target;
}

size_t CUPRequestData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.CUPRequestData)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional bytes request = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_request());
    }

    // optional bytes query_cup2key = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_query_cup2key());
    }

    // optional bytes hash_hex = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_hash_hex());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CUPRequestData::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CUPRequestData*>(
      &from));
}

void CUPRequestData::MergeFrom(const CUPRequestData& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.CUPRequestData)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_request(from._internal_request());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_query_cup2key(from._internal_query_cup2key());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_hash_hex(from._internal_hash_hex());
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CUPRequestData::CopyFrom(const CUPRequestData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.CUPRequestData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CUPRequestData::IsInitialized() const {
  return true;
}

void CUPRequestData::InternalSwap(CUPRequestData* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &request_, lhs_arena,
      &other->request_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &query_cup2key_, lhs_arena,
      &other->query_cup2key_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &hash_hex_, lhs_arena,
      &other->hash_hex_, rhs_arena
  );
}

std::string CUPRequestData::GetTypeName() const {
  return "autofill_assistant.CUPRequestData";
}


// ===================================================================

class ScriptActionRequestProto::_Internal {
 public:
  using HasBits = decltype(std::declval<ScriptActionRequestProto>()._has_bits_);
  static const ::autofill_assistant::CUPRequestData& cup_data(const ScriptActionRequestProto* msg);
  static void set_has_cup_data(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::autofill_assistant::ClientContextProto& client_context(const ScriptActionRequestProto* msg);
  static void set_has_client_context(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_global_payload(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_script_payload(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::autofill_assistant::InitialScriptActionsRequestProto& initial_request(const ScriptActionRequestProto* msg);
  static const ::autofill_assistant::NextScriptActionsRequestProto& next_request(const ScriptActionRequestProto* msg);
};

const ::autofill_assistant::CUPRequestData&
ScriptActionRequestProto::_Internal::cup_data(const ScriptActionRequestProto* msg) {
  return *msg->cup_data_;
}
const ::autofill_assistant::ClientContextProto&
ScriptActionRequestProto::_Internal::client_context(const ScriptActionRequestProto* msg) {
  return *msg->client_context_;
}
const ::autofill_assistant::InitialScriptActionsRequestProto&
ScriptActionRequestProto::_Internal::initial_request(const ScriptActionRequestProto* msg) {
  return *msg->request_.initial_request_;
}
const ::autofill_assistant::NextScriptActionsRequestProto&
ScriptActionRequestProto::_Internal::next_request(const ScriptActionRequestProto* msg) {
  return *msg->request_.next_request_;
}
void ScriptActionRequestProto::set_allocated_initial_request(::autofill_assistant::InitialScriptActionsRequestProto* initial_request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_request();
  if (initial_request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(initial_request);
    if (message_arena != submessage_arena) {
      initial_request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, initial_request, submessage_arena);
    }
    set_has_initial_request();
    request_.initial_request_ = initial_request;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ScriptActionRequestProto.initial_request)
}
void ScriptActionRequestProto::set_allocated_next_request(::autofill_assistant::NextScriptActionsRequestProto* next_request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_request();
  if (next_request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(next_request);
    if (message_arena != submessage_arena) {
      next_request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, next_request, submessage_arena);
    }
    set_has_next_request();
    request_.next_request_ = next_request;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ScriptActionRequestProto.next_request)
}
ScriptActionRequestProto::ScriptActionRequestProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.ScriptActionRequestProto)
}
ScriptActionRequestProto::ScriptActionRequestProto(const ScriptActionRequestProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  script_payload_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    script_payload_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_script_payload()) {
    script_payload_.Set(from._internal_script_payload(), 
      GetArenaForAllocation());
  }
  global_payload_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    global_payload_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_global_payload()) {
    global_payload_.Set(from._internal_global_payload(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_client_context()) {
    client_context_ = new ::autofill_assistant::ClientContextProto(*from.client_context_);
  } else {
    client_context_ = nullptr;
  }
  if (from._internal_has_cup_data()) {
    cup_data_ = new ::autofill_assistant::CUPRequestData(*from.cup_data_);
  } else {
    cup_data_ = nullptr;
  }
  clear_has_request();
  switch (from.request_case()) {
    case kInitialRequest: {
      _internal_mutable_initial_request()->::autofill_assistant::InitialScriptActionsRequestProto::MergeFrom(from._internal_initial_request());
      break;
    }
    case kNextRequest: {
      _internal_mutable_next_request()->::autofill_assistant::NextScriptActionsRequestProto::MergeFrom(from._internal_next_request());
      break;
    }
    case REQUEST_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.ScriptActionRequestProto)
}

inline void ScriptActionRequestProto::SharedCtor() {
script_payload_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  script_payload_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
global_payload_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  global_payload_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&client_context_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&cup_data_) -
    reinterpret_cast<char*>(&client_context_)) + sizeof(cup_data_));
clear_has_request();
}

ScriptActionRequestProto::~ScriptActionRequestProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.ScriptActionRequestProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ScriptActionRequestProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  script_payload_.Destroy();
  global_payload_.Destroy();
  if (this != internal_default_instance()) delete client_context_;
  if (this != internal_default_instance()) delete cup_data_;
  if (has_request()) {
    clear_request();
  }
}

void ScriptActionRequestProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ScriptActionRequestProto::clear_request() {
// @@protoc_insertion_point(one_of_clear_start:autofill_assistant.ScriptActionRequestProto)
  switch (request_case()) {
    case kInitialRequest: {
      if (GetArenaForAllocation() == nullptr) {
        delete request_.initial_request_;
      }
      break;
    }
    case kNextRequest: {
      if (GetArenaForAllocation() == nullptr) {
        delete request_.next_request_;
      }
      break;
    }
    case REQUEST_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = REQUEST_NOT_SET;
}


void ScriptActionRequestProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.ScriptActionRequestProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      script_payload_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      global_payload_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(client_context_ != nullptr);
      client_context_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(cup_data_ != nullptr);
      cup_data_->Clear();
    }
  }
  clear_request();
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ScriptActionRequestProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes script_payload = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_script_payload();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.InitialScriptActionsRequestProto initial_request = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_initial_request(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.NextScriptActionsRequestProto next_request = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_next_request(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .autofill_assistant.ClientContextProto client_context = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_client_context(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes global_payload = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          auto str = _internal_mutable_global_payload();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .autofill_assistant.CUPRequestData cup_data = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_cup_data(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ScriptActionRequestProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.ScriptActionRequestProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bytes script_payload = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_script_payload(), target);
  }

  switch (request_case()) {
    case kInitialRequest: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, _Internal::initial_request(this),
          _Internal::initial_request(this).GetCachedSize(), target, stream);
      break;
    }
    case kNextRequest: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(5, _Internal::next_request(this),
          _Internal::next_request(this).GetCachedSize(), target, stream);
      break;
    }
    default: ;
  }
  // optional .autofill_assistant.ClientContextProto client_context = 7;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::client_context(this),
        _Internal::client_context(this).GetCachedSize(), target, stream);
  }

  // optional bytes global_payload = 8;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        8, this->_internal_global_payload(), target);
  }

  // optional .autofill_assistant.CUPRequestData cup_data = 11;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(11, _Internal::cup_data(this),
        _Internal::cup_data(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.ScriptActionRequestProto)
  return target;
}

size_t ScriptActionRequestProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.ScriptActionRequestProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional bytes script_payload = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_script_payload());
    }

    // optional bytes global_payload = 8;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_global_payload());
    }

    // optional .autofill_assistant.ClientContextProto client_context = 7;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *client_context_);
    }

    // optional .autofill_assistant.CUPRequestData cup_data = 11;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *cup_data_);
    }

  }
  switch (request_case()) {
    // .autofill_assistant.InitialScriptActionsRequestProto initial_request = 4;
    case kInitialRequest: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *request_.initial_request_);
      break;
    }
    // .autofill_assistant.NextScriptActionsRequestProto next_request = 5;
    case kNextRequest: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *request_.next_request_);
      break;
    }
    case REQUEST_NOT_SET: {
      break;
    }
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ScriptActionRequestProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ScriptActionRequestProto*>(
      &from));
}

void ScriptActionRequestProto::MergeFrom(const ScriptActionRequestProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.ScriptActionRequestProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_script_payload(from._internal_script_payload());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_global_payload(from._internal_global_payload());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_client_context()->::autofill_assistant::ClientContextProto::MergeFrom(from._internal_client_context());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_mutable_cup_data()->::autofill_assistant::CUPRequestData::MergeFrom(from._internal_cup_data());
    }
  }
  switch (from.request_case()) {
    case kInitialRequest: {
      _internal_mutable_initial_request()->::autofill_assistant::InitialScriptActionsRequestProto::MergeFrom(from._internal_initial_request());
      break;
    }
    case kNextRequest: {
      _internal_mutable_next_request()->::autofill_assistant::NextScriptActionsRequestProto::MergeFrom(from._internal_next_request());
      break;
    }
    case REQUEST_NOT_SET: {
      break;
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ScriptActionRequestProto::CopyFrom(const ScriptActionRequestProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.ScriptActionRequestProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ScriptActionRequestProto::IsInitialized() const {
  switch (request_case()) {
    case kInitialRequest: {
      break;
    }
    case kNextRequest: {
      if (_internal_has_next_request()) {
        if (!request_.next_request_->IsInitialized()) return false;
      }
      break;
    }
    case REQUEST_NOT_SET: {
      break;
    }
  }
  return true;
}

void ScriptActionRequestProto::InternalSwap(ScriptActionRequestProto* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &script_payload_, lhs_arena,
      &other->script_payload_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &global_payload_, lhs_arena,
      &other->global_payload_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ScriptActionRequestProto, cup_data_)
      + sizeof(ScriptActionRequestProto::cup_data_)
      - PROTOBUF_FIELD_OFFSET(ScriptActionRequestProto, client_context_)>(
          reinterpret_cast<char*>(&client_context_),
          reinterpret_cast<char*>(&other->client_context_));
  swap(request_, other->request_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

std::string ScriptActionRequestProto::GetTypeName() const {
  return "autofill_assistant.ScriptActionRequestProto";
}


// ===================================================================

class ScriptStoreConfig::_Internal {
 public:
  using HasBits = decltype(std::declval<ScriptStoreConfig>()._has_bits_);
  static void set_has_bundle_path(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_bundle_version(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

ScriptStoreConfig::ScriptStoreConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.ScriptStoreConfig)
}
ScriptStoreConfig::ScriptStoreConfig(const ScriptStoreConfig& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  bundle_path_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    bundle_path_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_bundle_path()) {
    bundle_path_.Set(from._internal_bundle_path(), 
      GetArenaForAllocation());
  }
  bundle_version_ = from.bundle_version_;
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.ScriptStoreConfig)
}

inline void ScriptStoreConfig::SharedCtor() {
bundle_path_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  bundle_path_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
bundle_version_ = int64_t{0};
}

ScriptStoreConfig::~ScriptStoreConfig() {
  // @@protoc_insertion_point(destructor:autofill_assistant.ScriptStoreConfig)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ScriptStoreConfig::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  bundle_path_.Destroy();
}

void ScriptStoreConfig::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ScriptStoreConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.ScriptStoreConfig)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    bundle_path_.ClearNonDefaultToEmpty();
  }
  bundle_version_ = int64_t{0};
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ScriptStoreConfig::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string bundle_path = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_bundle_path();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 bundle_version = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_bundle_version(&has_bits);
          bundle_version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ScriptStoreConfig::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.ScriptStoreConfig)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string bundle_path = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_bundle_path(), target);
  }

  // optional int64 bundle_version = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_bundle_version(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.ScriptStoreConfig)
  return target;
}

size_t ScriptStoreConfig::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.ScriptStoreConfig)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string bundle_path = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_bundle_path());
    }

    // optional int64 bundle_version = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_bundle_version());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ScriptStoreConfig::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ScriptStoreConfig*>(
      &from));
}

void ScriptStoreConfig::MergeFrom(const ScriptStoreConfig& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.ScriptStoreConfig)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_bundle_path(from._internal_bundle_path());
    }
    if (cached_has_bits & 0x00000002u) {
      bundle_version_ = from.bundle_version_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ScriptStoreConfig::CopyFrom(const ScriptStoreConfig& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.ScriptStoreConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ScriptStoreConfig::IsInitialized() const {
  return true;
}

void ScriptStoreConfig::InternalSwap(ScriptStoreConfig* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &bundle_path_, lhs_arena,
      &other->bundle_path_, rhs_arena
  );
  swap(bundle_version_, other->bundle_version_);
}

std::string ScriptStoreConfig::GetTypeName() const {
  return "autofill_assistant.ScriptStoreConfig";
}


// ===================================================================

class InitialScriptActionsRequestProto_QueryProto::_Internal {
 public:
  using HasBits = decltype(std::declval<InitialScriptActionsRequestProto_QueryProto>()._has_bits_);
  static void set_has_url(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_policy(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

InitialScriptActionsRequestProto_QueryProto::InitialScriptActionsRequestProto_QueryProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  script_path_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.InitialScriptActionsRequestProto.QueryProto)
}
InitialScriptActionsRequestProto_QueryProto::InitialScriptActionsRequestProto_QueryProto(const InitialScriptActionsRequestProto_QueryProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      script_path_(from.script_path_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_url()) {
    url_.Set(from._internal_url(), 
      GetArenaForAllocation());
  }
  policy_ = from.policy_;
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.InitialScriptActionsRequestProto.QueryProto)
}

inline void InitialScriptActionsRequestProto_QueryProto::SharedCtor() {
url_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  url_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
policy_ = 0;
}

InitialScriptActionsRequestProto_QueryProto::~InitialScriptActionsRequestProto_QueryProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.InitialScriptActionsRequestProto.QueryProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void InitialScriptActionsRequestProto_QueryProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  url_.Destroy();
}

void InitialScriptActionsRequestProto_QueryProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void InitialScriptActionsRequestProto_QueryProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.InitialScriptActionsRequestProto.QueryProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  script_path_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    url_.ClearNonDefaultToEmpty();
  }
  policy_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* InitialScriptActionsRequestProto_QueryProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated string script_path = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_script_path();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional string url = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_url();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .autofill_assistant.PolicyType policy = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::autofill_assistant::PolicyType_IsValid(val))) {
            _internal_set_policy(static_cast<::autofill_assistant::PolicyType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* InitialScriptActionsRequestProto_QueryProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.InitialScriptActionsRequestProto.QueryProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated string script_path = 1;
  for (int i = 0, n = this->_internal_script_path_size(); i < n; i++) {
    const auto& s = this->_internal_script_path(i);
    target = stream->WriteString(1, s, target);
  }

  cached_has_bits = _has_bits_[0];
  // optional string url = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_url(), target);
  }

  // optional .autofill_assistant.PolicyType policy = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_policy(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.InitialScriptActionsRequestProto.QueryProto)
  return target;
}

size_t InitialScriptActionsRequestProto_QueryProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.InitialScriptActionsRequestProto.QueryProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string script_path = 1;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(script_path_.size());
  for (int i = 0, n = script_path_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      script_path_.Get(i));
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string url = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_url());
    }

    // optional .autofill_assistant.PolicyType policy = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_policy());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void InitialScriptActionsRequestProto_QueryProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const InitialScriptActionsRequestProto_QueryProto*>(
      &from));
}

void InitialScriptActionsRequestProto_QueryProto::MergeFrom(const InitialScriptActionsRequestProto_QueryProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.InitialScriptActionsRequestProto.QueryProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  script_path_.MergeFrom(from.script_path_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_url(from._internal_url());
    }
    if (cached_has_bits & 0x00000002u) {
      policy_ = from.policy_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void InitialScriptActionsRequestProto_QueryProto::CopyFrom(const InitialScriptActionsRequestProto_QueryProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.InitialScriptActionsRequestProto.QueryProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool InitialScriptActionsRequestProto_QueryProto::IsInitialized() const {
  return true;
}

void InitialScriptActionsRequestProto_QueryProto::InternalSwap(InitialScriptActionsRequestProto_QueryProto* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  script_path_.InternalSwap(&other->script_path_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &url_, lhs_arena,
      &other->url_, rhs_arena
  );
  swap(policy_, other->policy_);
}

std::string InitialScriptActionsRequestProto_QueryProto::GetTypeName() const {
  return "autofill_assistant.InitialScriptActionsRequestProto.QueryProto";
}


// ===================================================================

class InitialScriptActionsRequestProto::_Internal {
 public:
  using HasBits = decltype(std::declval<InitialScriptActionsRequestProto>()._has_bits_);
  static const ::autofill_assistant::InitialScriptActionsRequestProto_QueryProto& query(const InitialScriptActionsRequestProto* msg);
  static void set_has_query(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::autofill_assistant::ScriptStoreConfig& script_store_config(const InitialScriptActionsRequestProto* msg);
  static void set_has_script_store_config(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::autofill_assistant::InitialScriptActionsRequestProto_QueryProto&
InitialScriptActionsRequestProto::_Internal::query(const InitialScriptActionsRequestProto* msg) {
  return *msg->query_;
}
const ::autofill_assistant::ScriptStoreConfig&
InitialScriptActionsRequestProto::_Internal::script_store_config(const InitialScriptActionsRequestProto* msg) {
  return *msg->script_store_config_;
}
InitialScriptActionsRequestProto::InitialScriptActionsRequestProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  script_parameters_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.InitialScriptActionsRequestProto)
}
InitialScriptActionsRequestProto::InitialScriptActionsRequestProto(const InitialScriptActionsRequestProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      script_parameters_(from.script_parameters_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_query()) {
    query_ = new ::autofill_assistant::InitialScriptActionsRequestProto_QueryProto(*from.query_);
  } else {
    query_ = nullptr;
  }
  if (from._internal_has_script_store_config()) {
    script_store_config_ = new ::autofill_assistant::ScriptStoreConfig(*from.script_store_config_);
  } else {
    script_store_config_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.InitialScriptActionsRequestProto)
}

inline void InitialScriptActionsRequestProto::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&query_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&script_store_config_) -
    reinterpret_cast<char*>(&query_)) + sizeof(script_store_config_));
}

InitialScriptActionsRequestProto::~InitialScriptActionsRequestProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.InitialScriptActionsRequestProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void InitialScriptActionsRequestProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete query_;
  if (this != internal_default_instance()) delete script_store_config_;
}

void InitialScriptActionsRequestProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void InitialScriptActionsRequestProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.InitialScriptActionsRequestProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  script_parameters_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(query_ != nullptr);
      query_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(script_store_config_ != nullptr);
      script_store_config_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* InitialScriptActionsRequestProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .autofill_assistant.ScriptParameterProto script_parameters = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_script_parameters(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .autofill_assistant.InitialScriptActionsRequestProto.QueryProto query = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_query(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .autofill_assistant.ScriptStoreConfig script_store_config = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_script_store_config(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* InitialScriptActionsRequestProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.InitialScriptActionsRequestProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .autofill_assistant.ScriptParameterProto script_parameters = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_script_parameters_size()); i < n; i++) {
    const auto& repfield = this->_internal_script_parameters(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  cached_has_bits = _has_bits_[0];
  // optional .autofill_assistant.InitialScriptActionsRequestProto.QueryProto query = 3;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::query(this),
        _Internal::query(this).GetCachedSize(), target, stream);
  }

  // optional .autofill_assistant.ScriptStoreConfig script_store_config = 6;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::script_store_config(this),
        _Internal::script_store_config(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.InitialScriptActionsRequestProto)
  return target;
}

size_t InitialScriptActionsRequestProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.InitialScriptActionsRequestProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .autofill_assistant.ScriptParameterProto script_parameters = 2;
  total_size += 1UL * this->_internal_script_parameters_size();
  for (const auto& msg : this->script_parameters_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .autofill_assistant.InitialScriptActionsRequestProto.QueryProto query = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *query_);
    }

    // optional .autofill_assistant.ScriptStoreConfig script_store_config = 6;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *script_store_config_);
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void InitialScriptActionsRequestProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const InitialScriptActionsRequestProto*>(
      &from));
}

void InitialScriptActionsRequestProto::MergeFrom(const InitialScriptActionsRequestProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.InitialScriptActionsRequestProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  script_parameters_.MergeFrom(from.script_parameters_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_query()->::autofill_assistant::InitialScriptActionsRequestProto_QueryProto::MergeFrom(from._internal_query());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_script_store_config()->::autofill_assistant::ScriptStoreConfig::MergeFrom(from._internal_script_store_config());
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void InitialScriptActionsRequestProto::CopyFrom(const InitialScriptActionsRequestProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.InitialScriptActionsRequestProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool InitialScriptActionsRequestProto::IsInitialized() const {
  return true;
}

void InitialScriptActionsRequestProto::InternalSwap(InitialScriptActionsRequestProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  script_parameters_.InternalSwap(&other->script_parameters_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(InitialScriptActionsRequestProto, script_store_config_)
      + sizeof(InitialScriptActionsRequestProto::script_store_config_)
      - PROTOBUF_FIELD_OFFSET(InitialScriptActionsRequestProto, query_)>(
          reinterpret_cast<char*>(&query_),
          reinterpret_cast<char*>(&other->query_));
}

std::string InitialScriptActionsRequestProto::GetTypeName() const {
  return "autofill_assistant.InitialScriptActionsRequestProto";
}


// ===================================================================

class RoundtripTimingStats::_Internal {
 public:
  using HasBits = decltype(std::declval<RoundtripTimingStats>()._has_bits_);
  static void set_has_roundtrip_time_ms(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_client_time_ms(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

RoundtripTimingStats::RoundtripTimingStats(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.RoundtripTimingStats)
}
RoundtripTimingStats::RoundtripTimingStats(const RoundtripTimingStats& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&roundtrip_time_ms_, &from.roundtrip_time_ms_,
    static_cast<size_t>(reinterpret_cast<char*>(&client_time_ms_) -
    reinterpret_cast<char*>(&roundtrip_time_ms_)) + sizeof(client_time_ms_));
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.RoundtripTimingStats)
}

inline void RoundtripTimingStats::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&roundtrip_time_ms_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&client_time_ms_) -
    reinterpret_cast<char*>(&roundtrip_time_ms_)) + sizeof(client_time_ms_));
}

RoundtripTimingStats::~RoundtripTimingStats() {
  // @@protoc_insertion_point(destructor:autofill_assistant.RoundtripTimingStats)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RoundtripTimingStats::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void RoundtripTimingStats::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void RoundtripTimingStats::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.RoundtripTimingStats)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&roundtrip_time_ms_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&client_time_ms_) -
        reinterpret_cast<char*>(&roundtrip_time_ms_)) + sizeof(client_time_ms_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* RoundtripTimingStats::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 roundtrip_time_ms = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_roundtrip_time_ms(&has_bits);
          roundtrip_time_ms_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 client_time_ms = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_client_time_ms(&has_bits);
          client_time_ms_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RoundtripTimingStats::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.RoundtripTimingStats)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int64 roundtrip_time_ms = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_roundtrip_time_ms(), target);
  }

  // optional int64 client_time_ms = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_client_time_ms(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.RoundtripTimingStats)
  return target;
}

size_t RoundtripTimingStats::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.RoundtripTimingStats)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional int64 roundtrip_time_ms = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_roundtrip_time_ms());
    }

    // optional int64 client_time_ms = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_client_time_ms());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void RoundtripTimingStats::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const RoundtripTimingStats*>(
      &from));
}

void RoundtripTimingStats::MergeFrom(const RoundtripTimingStats& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.RoundtripTimingStats)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      roundtrip_time_ms_ = from.roundtrip_time_ms_;
    }
    if (cached_has_bits & 0x00000002u) {
      client_time_ms_ = from.client_time_ms_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void RoundtripTimingStats::CopyFrom(const RoundtripTimingStats& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.RoundtripTimingStats)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RoundtripTimingStats::IsInitialized() const {
  return true;
}

void RoundtripTimingStats::InternalSwap(RoundtripTimingStats* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RoundtripTimingStats, client_time_ms_)
      + sizeof(RoundtripTimingStats::client_time_ms_)
      - PROTOBUF_FIELD_OFFSET(RoundtripTimingStats, roundtrip_time_ms_)>(
          reinterpret_cast<char*>(&roundtrip_time_ms_),
          reinterpret_cast<char*>(&other->roundtrip_time_ms_));
}

std::string RoundtripTimingStats::GetTypeName() const {
  return "autofill_assistant.RoundtripTimingStats";
}


// ===================================================================

class RoundtripNetworkStats_ActionNetworkStats::_Internal {
 public:
  using HasBits = decltype(std::declval<RoundtripNetworkStats_ActionNetworkStats>()._has_bits_);
  static void set_has_action_info_case(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_decoded_size_bytes(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

RoundtripNetworkStats_ActionNetworkStats::RoundtripNetworkStats_ActionNetworkStats(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.RoundtripNetworkStats.ActionNetworkStats)
}
RoundtripNetworkStats_ActionNetworkStats::RoundtripNetworkStats_ActionNetworkStats(const RoundtripNetworkStats_ActionNetworkStats& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&decoded_size_bytes_, &from.decoded_size_bytes_,
    static_cast<size_t>(reinterpret_cast<char*>(&action_info_case_) -
    reinterpret_cast<char*>(&decoded_size_bytes_)) + sizeof(action_info_case_));
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.RoundtripNetworkStats.ActionNetworkStats)
}

inline void RoundtripNetworkStats_ActionNetworkStats::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&decoded_size_bytes_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&action_info_case_) -
    reinterpret_cast<char*>(&decoded_size_bytes_)) + sizeof(action_info_case_));
}

RoundtripNetworkStats_ActionNetworkStats::~RoundtripNetworkStats_ActionNetworkStats() {
  // @@protoc_insertion_point(destructor:autofill_assistant.RoundtripNetworkStats.ActionNetworkStats)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RoundtripNetworkStats_ActionNetworkStats::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void RoundtripNetworkStats_ActionNetworkStats::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void RoundtripNetworkStats_ActionNetworkStats::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.RoundtripNetworkStats.ActionNetworkStats)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&decoded_size_bytes_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&action_info_case_) -
        reinterpret_cast<char*>(&decoded_size_bytes_)) + sizeof(action_info_case_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* RoundtripNetworkStats_ActionNetworkStats::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 action_info_case = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_action_info_case(&has_bits);
          action_info_case_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 decoded_size_bytes = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_decoded_size_bytes(&has_bits);
          decoded_size_bytes_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RoundtripNetworkStats_ActionNetworkStats::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.RoundtripNetworkStats.ActionNetworkStats)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 action_info_case = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_action_info_case(), target);
  }

  // optional int64 decoded_size_bytes = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_decoded_size_bytes(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.RoundtripNetworkStats.ActionNetworkStats)
  return target;
}

size_t RoundtripNetworkStats_ActionNetworkStats::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.RoundtripNetworkStats.ActionNetworkStats)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional int64 decoded_size_bytes = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_decoded_size_bytes());
    }

    // optional int32 action_info_case = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_action_info_case());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void RoundtripNetworkStats_ActionNetworkStats::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const RoundtripNetworkStats_ActionNetworkStats*>(
      &from));
}

void RoundtripNetworkStats_ActionNetworkStats::MergeFrom(const RoundtripNetworkStats_ActionNetworkStats& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.RoundtripNetworkStats.ActionNetworkStats)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      decoded_size_bytes_ = from.decoded_size_bytes_;
    }
    if (cached_has_bits & 0x00000002u) {
      action_info_case_ = from.action_info_case_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void RoundtripNetworkStats_ActionNetworkStats::CopyFrom(const RoundtripNetworkStats_ActionNetworkStats& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.RoundtripNetworkStats.ActionNetworkStats)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RoundtripNetworkStats_ActionNetworkStats::IsInitialized() const {
  return true;
}

void RoundtripNetworkStats_ActionNetworkStats::InternalSwap(RoundtripNetworkStats_ActionNetworkStats* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RoundtripNetworkStats_ActionNetworkStats, action_info_case_)
      + sizeof(RoundtripNetworkStats_ActionNetworkStats::action_info_case_)
      - PROTOBUF_FIELD_OFFSET(RoundtripNetworkStats_ActionNetworkStats, decoded_size_bytes_)>(
          reinterpret_cast<char*>(&decoded_size_bytes_),
          reinterpret_cast<char*>(&other->decoded_size_bytes_));
}

std::string RoundtripNetworkStats_ActionNetworkStats::GetTypeName() const {
  return "autofill_assistant.RoundtripNetworkStats.ActionNetworkStats";
}


// ===================================================================

class RoundtripNetworkStats::_Internal {
 public:
  using HasBits = decltype(std::declval<RoundtripNetworkStats>()._has_bits_);
  static void set_has_roundtrip_encoded_body_size_bytes(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_roundtrip_decoded_body_size_bytes(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_num_roundtrips(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

RoundtripNetworkStats::RoundtripNetworkStats(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  action_stats_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.RoundtripNetworkStats)
}
RoundtripNetworkStats::RoundtripNetworkStats(const RoundtripNetworkStats& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      action_stats_(from.action_stats_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&roundtrip_encoded_body_size_bytes_, &from.roundtrip_encoded_body_size_bytes_,
    static_cast<size_t>(reinterpret_cast<char*>(&num_roundtrips_) -
    reinterpret_cast<char*>(&roundtrip_encoded_body_size_bytes_)) + sizeof(num_roundtrips_));
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.RoundtripNetworkStats)
}

inline void RoundtripNetworkStats::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&roundtrip_encoded_body_size_bytes_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&num_roundtrips_) -
    reinterpret_cast<char*>(&roundtrip_encoded_body_size_bytes_)) + sizeof(num_roundtrips_));
}

RoundtripNetworkStats::~RoundtripNetworkStats() {
  // @@protoc_insertion_point(destructor:autofill_assistant.RoundtripNetworkStats)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RoundtripNetworkStats::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void RoundtripNetworkStats::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void RoundtripNetworkStats::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.RoundtripNetworkStats)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  action_stats_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&roundtrip_encoded_body_size_bytes_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&num_roundtrips_) -
        reinterpret_cast<char*>(&roundtrip_encoded_body_size_bytes_)) + sizeof(num_roundtrips_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* RoundtripNetworkStats::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 roundtrip_encoded_body_size_bytes = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_roundtrip_encoded_body_size_bytes(&has_bits);
          roundtrip_encoded_body_size_bytes_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 roundtrip_decoded_body_size_bytes = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_roundtrip_decoded_body_size_bytes(&has_bits);
          roundtrip_decoded_body_size_bytes_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .autofill_assistant.RoundtripNetworkStats.ActionNetworkStats action_stats = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_action_stats(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional int32 num_roundtrips = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_num_roundtrips(&has_bits);
          num_roundtrips_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RoundtripNetworkStats::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.RoundtripNetworkStats)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int64 roundtrip_encoded_body_size_bytes = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_roundtrip_encoded_body_size_bytes(), target);
  }

  // optional int64 roundtrip_decoded_body_size_bytes = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_roundtrip_decoded_body_size_bytes(), target);
  }

  // repeated .autofill_assistant.RoundtripNetworkStats.ActionNetworkStats action_stats = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_action_stats_size()); i < n; i++) {
    const auto& repfield = this->_internal_action_stats(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional int32 num_roundtrips = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_num_roundtrips(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.RoundtripNetworkStats)
  return target;
}

size_t RoundtripNetworkStats::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.RoundtripNetworkStats)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .autofill_assistant.RoundtripNetworkStats.ActionNetworkStats action_stats = 3;
  total_size += 1UL * this->_internal_action_stats_size();
  for (const auto& msg : this->action_stats_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional int64 roundtrip_encoded_body_size_bytes = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_roundtrip_encoded_body_size_bytes());
    }

    // optional int64 roundtrip_decoded_body_size_bytes = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_roundtrip_decoded_body_size_bytes());
    }

    // optional int32 num_roundtrips = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_num_roundtrips());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void RoundtripNetworkStats::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const RoundtripNetworkStats*>(
      &from));
}

void RoundtripNetworkStats::MergeFrom(const RoundtripNetworkStats& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.RoundtripNetworkStats)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  action_stats_.MergeFrom(from.action_stats_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      roundtrip_encoded_body_size_bytes_ = from.roundtrip_encoded_body_size_bytes_;
    }
    if (cached_has_bits & 0x00000002u) {
      roundtrip_decoded_body_size_bytes_ = from.roundtrip_decoded_body_size_bytes_;
    }
    if (cached_has_bits & 0x00000004u) {
      num_roundtrips_ = from.num_roundtrips_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void RoundtripNetworkStats::CopyFrom(const RoundtripNetworkStats& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.RoundtripNetworkStats)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RoundtripNetworkStats::IsInitialized() const {
  return true;
}

void RoundtripNetworkStats::InternalSwap(RoundtripNetworkStats* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  action_stats_.InternalSwap(&other->action_stats_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RoundtripNetworkStats, num_roundtrips_)
      + sizeof(RoundtripNetworkStats::num_roundtrips_)
      - PROTOBUF_FIELD_OFFSET(RoundtripNetworkStats, roundtrip_encoded_body_size_bytes_)>(
          reinterpret_cast<char*>(&roundtrip_encoded_body_size_bytes_),
          reinterpret_cast<char*>(&other->roundtrip_encoded_body_size_bytes_));
}

std::string RoundtripNetworkStats::GetTypeName() const {
  return "autofill_assistant.RoundtripNetworkStats";
}


// ===================================================================

class NextScriptActionsRequestProto::_Internal {
 public:
  using HasBits = decltype(std::declval<NextScriptActionsRequestProto>()._has_bits_);
  static const ::autofill_assistant::RoundtripTimingStats& timing_stats(const NextScriptActionsRequestProto* msg);
  static void set_has_timing_stats(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_slow_connection_warning(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::autofill_assistant::RoundtripNetworkStats& network_stats(const NextScriptActionsRequestProto* msg);
  static void set_has_network_stats(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::autofill_assistant::RoundtripTimingStats&
NextScriptActionsRequestProto::_Internal::timing_stats(const NextScriptActionsRequestProto* msg) {
  return *msg->timing_stats_;
}
const ::autofill_assistant::RoundtripNetworkStats&
NextScriptActionsRequestProto::_Internal::network_stats(const NextScriptActionsRequestProto* msg) {
  return *msg->network_stats_;
}
NextScriptActionsRequestProto::NextScriptActionsRequestProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  processed_actions_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.NextScriptActionsRequestProto)
}
NextScriptActionsRequestProto::NextScriptActionsRequestProto(const NextScriptActionsRequestProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      processed_actions_(from.processed_actions_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_timing_stats()) {
    timing_stats_ = new ::autofill_assistant::RoundtripTimingStats(*from.timing_stats_);
  } else {
    timing_stats_ = nullptr;
  }
  if (from._internal_has_network_stats()) {
    network_stats_ = new ::autofill_assistant::RoundtripNetworkStats(*from.network_stats_);
  } else {
    network_stats_ = nullptr;
  }
  slow_connection_warning_ = from.slow_connection_warning_;
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.NextScriptActionsRequestProto)
}

inline void NextScriptActionsRequestProto::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&timing_stats_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&slow_connection_warning_) -
    reinterpret_cast<char*>(&timing_stats_)) + sizeof(slow_connection_warning_));
}

NextScriptActionsRequestProto::~NextScriptActionsRequestProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.NextScriptActionsRequestProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void NextScriptActionsRequestProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete timing_stats_;
  if (this != internal_default_instance()) delete network_stats_;
}

void NextScriptActionsRequestProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void NextScriptActionsRequestProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.NextScriptActionsRequestProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  processed_actions_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(timing_stats_ != nullptr);
      timing_stats_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(network_stats_ != nullptr);
      network_stats_->Clear();
    }
  }
  slow_connection_warning_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* NextScriptActionsRequestProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .autofill_assistant.ProcessedActionProto processed_actions = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_processed_actions(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .autofill_assistant.RoundtripTimingStats timing_stats = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_timing_stats(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .autofill_assistant.RoundtripNetworkStats network_stats = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_network_stats(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .autofill_assistant.SlowWarningStatus slow_connection_warning = 34;
      case 34:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::autofill_assistant::SlowWarningStatus_IsValid(val))) {
            _internal_set_slow_connection_warning(static_cast<::autofill_assistant::SlowWarningStatus>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(34, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NextScriptActionsRequestProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.NextScriptActionsRequestProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .autofill_assistant.ProcessedActionProto processed_actions = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_processed_actions_size()); i < n; i++) {
    const auto& repfield = this->_internal_processed_actions(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  cached_has_bits = _has_bits_[0];
  // optional .autofill_assistant.RoundtripTimingStats timing_stats = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::timing_stats(this),
        _Internal::timing_stats(this).GetCachedSize(), target, stream);
  }

  // optional .autofill_assistant.RoundtripNetworkStats network_stats = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::network_stats(this),
        _Internal::network_stats(this).GetCachedSize(), target, stream);
  }

  // optional .autofill_assistant.SlowWarningStatus slow_connection_warning = 34;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      34, this->_internal_slow_connection_warning(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.NextScriptActionsRequestProto)
  return target;
}

size_t NextScriptActionsRequestProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.NextScriptActionsRequestProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .autofill_assistant.ProcessedActionProto processed_actions = 1;
  total_size += 1UL * this->_internal_processed_actions_size();
  for (const auto& msg : this->processed_actions_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .autofill_assistant.RoundtripTimingStats timing_stats = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *timing_stats_);
    }

    // optional .autofill_assistant.RoundtripNetworkStats network_stats = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *network_stats_);
    }

    // optional .autofill_assistant.SlowWarningStatus slow_connection_warning = 34;
    if (cached_has_bits & 0x00000004u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_slow_connection_warning());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void NextScriptActionsRequestProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const NextScriptActionsRequestProto*>(
      &from));
}

void NextScriptActionsRequestProto::MergeFrom(const NextScriptActionsRequestProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.NextScriptActionsRequestProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  processed_actions_.MergeFrom(from.processed_actions_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_timing_stats()->::autofill_assistant::RoundtripTimingStats::MergeFrom(from._internal_timing_stats());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_network_stats()->::autofill_assistant::RoundtripNetworkStats::MergeFrom(from._internal_network_stats());
    }
    if (cached_has_bits & 0x00000004u) {
      slow_connection_warning_ = from.slow_connection_warning_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void NextScriptActionsRequestProto::CopyFrom(const NextScriptActionsRequestProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.NextScriptActionsRequestProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NextScriptActionsRequestProto::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(processed_actions_))
    return false;
  return true;
}

void NextScriptActionsRequestProto::InternalSwap(NextScriptActionsRequestProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  processed_actions_.InternalSwap(&other->processed_actions_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(NextScriptActionsRequestProto, slow_connection_warning_)
      + sizeof(NextScriptActionsRequestProto::slow_connection_warning_)
      - PROTOBUF_FIELD_OFFSET(NextScriptActionsRequestProto, timing_stats_)>(
          reinterpret_cast<char*>(&timing_stats_),
          reinterpret_cast<char*>(&other->timing_stats_));
}

std::string NextScriptActionsRequestProto::GetTypeName() const {
  return "autofill_assistant.NextScriptActionsRequestProto";
}


// ===================================================================

class CUPResponseData::_Internal {
 public:
  using HasBits = decltype(std::declval<CUPResponseData>()._has_bits_);
  static void set_has_response(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ecdsa_signature(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CUPResponseData::CUPResponseData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.CUPResponseData)
}
CUPResponseData::CUPResponseData(const CUPResponseData& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  response_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    response_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_response()) {
    response_.Set(from._internal_response(), 
      GetArenaForAllocation());
  }
  ecdsa_signature_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    ecdsa_signature_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_ecdsa_signature()) {
    ecdsa_signature_.Set(from._internal_ecdsa_signature(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.CUPResponseData)
}

inline void CUPResponseData::SharedCtor() {
response_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  response_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
ecdsa_signature_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  ecdsa_signature_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CUPResponseData::~CUPResponseData() {
  // @@protoc_insertion_point(destructor:autofill_assistant.CUPResponseData)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CUPResponseData::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  response_.Destroy();
  ecdsa_signature_.Destroy();
}

void CUPResponseData::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CUPResponseData::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.CUPResponseData)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      response_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      ecdsa_signature_.ClearNonDefaultToEmpty();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CUPResponseData::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes response = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_response();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes ecdsa_signature = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_ecdsa_signature();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CUPResponseData::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.CUPResponseData)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bytes response = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_response(), target);
  }

  // optional bytes ecdsa_signature = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_ecdsa_signature(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.CUPResponseData)
  return target;
}

size_t CUPResponseData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.CUPResponseData)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional bytes response = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_response());
    }

    // optional bytes ecdsa_signature = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_ecdsa_signature());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CUPResponseData::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CUPResponseData*>(
      &from));
}

void CUPResponseData::MergeFrom(const CUPResponseData& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.CUPResponseData)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_response(from._internal_response());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_ecdsa_signature(from._internal_ecdsa_signature());
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CUPResponseData::CopyFrom(const CUPResponseData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.CUPResponseData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CUPResponseData::IsInitialized() const {
  return true;
}

void CUPResponseData::InternalSwap(CUPResponseData* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &response_, lhs_arena,
      &other->response_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &ecdsa_signature_, lhs_arena,
      &other->ecdsa_signature_, rhs_arena
  );
}

std::string CUPResponseData::GetTypeName() const {
  return "autofill_assistant.CUPResponseData";
}


// ===================================================================

class ActionsResponseProto_UpdateScriptListProto::_Internal {
 public:
};

ActionsResponseProto_UpdateScriptListProto::ActionsResponseProto_UpdateScriptListProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  scripts_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.ActionsResponseProto.UpdateScriptListProto)
}
ActionsResponseProto_UpdateScriptListProto::ActionsResponseProto_UpdateScriptListProto(const ActionsResponseProto_UpdateScriptListProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      scripts_(from.scripts_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.ActionsResponseProto.UpdateScriptListProto)
}

inline void ActionsResponseProto_UpdateScriptListProto::SharedCtor() {
}

ActionsResponseProto_UpdateScriptListProto::~ActionsResponseProto_UpdateScriptListProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.ActionsResponseProto.UpdateScriptListProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ActionsResponseProto_UpdateScriptListProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ActionsResponseProto_UpdateScriptListProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ActionsResponseProto_UpdateScriptListProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.ActionsResponseProto.UpdateScriptListProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  scripts_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ActionsResponseProto_UpdateScriptListProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .autofill_assistant.SupportedScriptProto scripts = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_scripts(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ActionsResponseProto_UpdateScriptListProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.ActionsResponseProto.UpdateScriptListProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .autofill_assistant.SupportedScriptProto scripts = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_scripts_size()); i < n; i++) {
    const auto& repfield = this->_internal_scripts(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.ActionsResponseProto.UpdateScriptListProto)
  return target;
}

size_t ActionsResponseProto_UpdateScriptListProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.ActionsResponseProto.UpdateScriptListProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .autofill_assistant.SupportedScriptProto scripts = 1;
  total_size += 1UL * this->_internal_scripts_size();
  for (const auto& msg : this->scripts_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ActionsResponseProto_UpdateScriptListProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ActionsResponseProto_UpdateScriptListProto*>(
      &from));
}

void ActionsResponseProto_UpdateScriptListProto::MergeFrom(const ActionsResponseProto_UpdateScriptListProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.ActionsResponseProto.UpdateScriptListProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  scripts_.MergeFrom(from.scripts_);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ActionsResponseProto_UpdateScriptListProto::CopyFrom(const ActionsResponseProto_UpdateScriptListProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.ActionsResponseProto.UpdateScriptListProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ActionsResponseProto_UpdateScriptListProto::IsInitialized() const {
  return true;
}

void ActionsResponseProto_UpdateScriptListProto::InternalSwap(ActionsResponseProto_UpdateScriptListProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  scripts_.InternalSwap(&other->scripts_);
}

std::string ActionsResponseProto_UpdateScriptListProto::GetTypeName() const {
  return "autofill_assistant.ActionsResponseProto.UpdateScriptListProto";
}


// ===================================================================

class ActionsResponseProto::_Internal {
 public:
  using HasBits = decltype(std::declval<ActionsResponseProto>()._has_bits_);
  static const ::autofill_assistant::CUPResponseData& cup_data(const ActionsResponseProto* msg);
  static void set_has_cup_data(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_global_payload(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_script_payload(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::autofill_assistant::ActionsResponseProto_UpdateScriptListProto& update_script_list(const ActionsResponseProto* msg);
  static void set_has_update_script_list(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_js_flow_library(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_run_id(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_report_token(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::autofill_assistant::CUPResponseData&
ActionsResponseProto::_Internal::cup_data(const ActionsResponseProto* msg) {
  return *msg->cup_data_;
}
const ::autofill_assistant::ActionsResponseProto_UpdateScriptListProto&
ActionsResponseProto::_Internal::update_script_list(const ActionsResponseProto* msg) {
  return *msg->update_script_list_;
}
ActionsResponseProto::ActionsResponseProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  actions_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.ActionsResponseProto)
}
ActionsResponseProto::ActionsResponseProto(const ActionsResponseProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      actions_(from.actions_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  script_payload_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    script_payload_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_script_payload()) {
    script_payload_.Set(from._internal_script_payload(), 
      GetArenaForAllocation());
  }
  global_payload_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    global_payload_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_global_payload()) {
    global_payload_.Set(from._internal_global_payload(), 
      GetArenaForAllocation());
  }
  js_flow_library_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    js_flow_library_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_js_flow_library()) {
    js_flow_library_.Set(from._internal_js_flow_library(), 
      GetArenaForAllocation());
  }
  report_token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    report_token_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_report_token()) {
    report_token_.Set(from._internal_report_token(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_update_script_list()) {
    update_script_list_ = new ::autofill_assistant::ActionsResponseProto_UpdateScriptListProto(*from.update_script_list_);
  } else {
    update_script_list_ = nullptr;
  }
  if (from._internal_has_cup_data()) {
    cup_data_ = new ::autofill_assistant::CUPResponseData(*from.cup_data_);
  } else {
    cup_data_ = nullptr;
  }
  run_id_ = from.run_id_;
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.ActionsResponseProto)
}

inline void ActionsResponseProto::SharedCtor() {
script_payload_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  script_payload_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
global_payload_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  global_payload_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
js_flow_library_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  js_flow_library_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
report_token_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  report_token_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&update_script_list_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&run_id_) -
    reinterpret_cast<char*>(&update_script_list_)) + sizeof(run_id_));
}

ActionsResponseProto::~ActionsResponseProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.ActionsResponseProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ActionsResponseProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  script_payload_.Destroy();
  global_payload_.Destroy();
  js_flow_library_.Destroy();
  report_token_.Destroy();
  if (this != internal_default_instance()) delete update_script_list_;
  if (this != internal_default_instance()) delete cup_data_;
}

void ActionsResponseProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ActionsResponseProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.ActionsResponseProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  actions_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      script_payload_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      global_payload_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      js_flow_library_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      report_token_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(update_script_list_ != nullptr);
      update_script_list_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(cup_data_ != nullptr);
      cup_data_->Clear();
    }
  }
  run_id_ = uint64_t{0u};
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ActionsResponseProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes script_payload = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_script_payload();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .autofill_assistant.ActionProto actions = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_actions(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional bytes global_payload = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_global_payload();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .autofill_assistant.ActionsResponseProto.UpdateScriptListProto update_script_list = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_update_script_list(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .autofill_assistant.CUPResponseData cup_data = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_cup_data(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 run_id = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_run_id(&has_bits);
          run_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string js_flow_library = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          auto str = _internal_mutable_js_flow_library();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string report_token = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 114)) {
          auto str = _internal_mutable_report_token();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ActionsResponseProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.ActionsResponseProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bytes script_payload = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_script_payload(), target);
  }

  // repeated .autofill_assistant.ActionProto actions = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_actions_size()); i < n; i++) {
    const auto& repfield = this->_internal_actions(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional bytes global_payload = 4;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        4, this->_internal_global_payload(), target);
  }

  // optional .autofill_assistant.ActionsResponseProto.UpdateScriptListProto update_script_list = 5;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::update_script_list(this),
        _Internal::update_script_list(this).GetCachedSize(), target, stream);
  }

  // optional .autofill_assistant.CUPResponseData cup_data = 11;
  if (cached_has_bits & 0x00000020u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(11, _Internal::cup_data(this),
        _Internal::cup_data(this).GetCachedSize(), target, stream);
  }

  // optional uint64 run_id = 12;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(12, this->_internal_run_id(), target);
  }

  // optional string js_flow_library = 13;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteStringMaybeAliased(
        13, this->_internal_js_flow_library(), target);
  }

  // optional string report_token = 14;
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteStringMaybeAliased(
        14, this->_internal_report_token(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.ActionsResponseProto)
  return target;
}

size_t ActionsResponseProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.ActionsResponseProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .autofill_assistant.ActionProto actions = 3;
  total_size += 1UL * this->_internal_actions_size();
  for (const auto& msg : this->actions_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // optional bytes script_payload = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_script_payload());
    }

    // optional bytes global_payload = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_global_payload());
    }

    // optional string js_flow_library = 13;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_js_flow_library());
    }

    // optional string report_token = 14;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_report_token());
    }

    // optional .autofill_assistant.ActionsResponseProto.UpdateScriptListProto update_script_list = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *update_script_list_);
    }

    // optional .autofill_assistant.CUPResponseData cup_data = 11;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *cup_data_);
    }

    // optional uint64 run_id = 12;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_run_id());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ActionsResponseProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ActionsResponseProto*>(
      &from));
}

void ActionsResponseProto::MergeFrom(const ActionsResponseProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.ActionsResponseProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  actions_.MergeFrom(from.actions_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_script_payload(from._internal_script_payload());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_global_payload(from._internal_global_payload());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_js_flow_library(from._internal_js_flow_library());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_set_report_token(from._internal_report_token());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_mutable_update_script_list()->::autofill_assistant::ActionsResponseProto_UpdateScriptListProto::MergeFrom(from._internal_update_script_list());
    }
    if (cached_has_bits & 0x00000020u) {
      _internal_mutable_cup_data()->::autofill_assistant::CUPResponseData::MergeFrom(from._internal_cup_data());
    }
    if (cached_has_bits & 0x00000040u) {
      run_id_ = from.run_id_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ActionsResponseProto::CopyFrom(const ActionsResponseProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.ActionsResponseProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ActionsResponseProto::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(actions_))
    return false;
  return true;
}

void ActionsResponseProto::InternalSwap(ActionsResponseProto* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  actions_.InternalSwap(&other->actions_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &script_payload_, lhs_arena,
      &other->script_payload_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &global_payload_, lhs_arena,
      &other->global_payload_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &js_flow_library_, lhs_arena,
      &other->js_flow_library_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &report_token_, lhs_arena,
      &other->report_token_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ActionsResponseProto, run_id_)
      + sizeof(ActionsResponseProto::run_id_)
      - PROTOBUF_FIELD_OFFSET(ActionsResponseProto, update_script_list_)>(
          reinterpret_cast<char*>(&update_script_list_),
          reinterpret_cast<char*>(&other->update_script_list_));
}

std::string ActionsResponseProto::GetTypeName() const {
  return "autofill_assistant.ActionsResponseProto";
}


// ===================================================================

class GetTriggerScriptsRequestProto::_Internal {
 public:
  using HasBits = decltype(std::declval<GetTriggerScriptsRequestProto>()._has_bits_);
  static void set_has_url(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::autofill_assistant::ClientContextProto& client_context(const GetTriggerScriptsRequestProto* msg);
  static void set_has_client_context(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::autofill_assistant::ClientContextProto&
GetTriggerScriptsRequestProto::_Internal::client_context(const GetTriggerScriptsRequestProto* msg) {
  return *msg->client_context_;
}
GetTriggerScriptsRequestProto::GetTriggerScriptsRequestProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  script_parameters_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.GetTriggerScriptsRequestProto)
}
GetTriggerScriptsRequestProto::GetTriggerScriptsRequestProto(const GetTriggerScriptsRequestProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      script_parameters_(from.script_parameters_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_url()) {
    url_.Set(from._internal_url(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_client_context()) {
    client_context_ = new ::autofill_assistant::ClientContextProto(*from.client_context_);
  } else {
    client_context_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.GetTriggerScriptsRequestProto)
}

inline void GetTriggerScriptsRequestProto::SharedCtor() {
url_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  url_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
client_context_ = nullptr;
}

GetTriggerScriptsRequestProto::~GetTriggerScriptsRequestProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.GetTriggerScriptsRequestProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GetTriggerScriptsRequestProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  url_.Destroy();
  if (this != internal_default_instance()) delete client_context_;
}

void GetTriggerScriptsRequestProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void GetTriggerScriptsRequestProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.GetTriggerScriptsRequestProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  script_parameters_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      url_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(client_context_ != nullptr);
      client_context_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* GetTriggerScriptsRequestProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string url = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_url();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .autofill_assistant.ClientContextProto client_context = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_client_context(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .autofill_assistant.ScriptParameterProto script_parameters = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_script_parameters(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GetTriggerScriptsRequestProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.GetTriggerScriptsRequestProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string url = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_url(), target);
  }

  // optional .autofill_assistant.ClientContextProto client_context = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::client_context(this),
        _Internal::client_context(this).GetCachedSize(), target, stream);
  }

  // repeated .autofill_assistant.ScriptParameterProto script_parameters = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_script_parameters_size()); i < n; i++) {
    const auto& repfield = this->_internal_script_parameters(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.GetTriggerScriptsRequestProto)
  return target;
}

size_t GetTriggerScriptsRequestProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.GetTriggerScriptsRequestProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .autofill_assistant.ScriptParameterProto script_parameters = 3;
  total_size += 1UL * this->_internal_script_parameters_size();
  for (const auto& msg : this->script_parameters_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string url = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_url());
    }

    // optional .autofill_assistant.ClientContextProto client_context = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *client_context_);
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void GetTriggerScriptsRequestProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const GetTriggerScriptsRequestProto*>(
      &from));
}

void GetTriggerScriptsRequestProto::MergeFrom(const GetTriggerScriptsRequestProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.GetTriggerScriptsRequestProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  script_parameters_.MergeFrom(from.script_parameters_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_url(from._internal_url());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_client_context()->::autofill_assistant::ClientContextProto::MergeFrom(from._internal_client_context());
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void GetTriggerScriptsRequestProto::CopyFrom(const GetTriggerScriptsRequestProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.GetTriggerScriptsRequestProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetTriggerScriptsRequestProto::IsInitialized() const {
  return true;
}

void GetTriggerScriptsRequestProto::InternalSwap(GetTriggerScriptsRequestProto* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  script_parameters_.InternalSwap(&other->script_parameters_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &url_, lhs_arena,
      &other->url_, rhs_arena
  );
  swap(client_context_, other->client_context_);
}

std::string GetTriggerScriptsRequestProto::GetTypeName() const {
  return "autofill_assistant.GetTriggerScriptsRequestProto";
}


// ===================================================================

class GetTriggerScriptsResponseProto::_Internal {
 public:
  using HasBits = decltype(std::declval<GetTriggerScriptsResponseProto>()._has_bits_);
  static void set_has_trigger_condition_timeout_ms(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_trigger_condition_check_interval_ms(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

GetTriggerScriptsResponseProto::GetTriggerScriptsResponseProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  trigger_scripts_(arena),
  additional_allowed_domains_(arena),
  script_parameters_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.GetTriggerScriptsResponseProto)
}
GetTriggerScriptsResponseProto::GetTriggerScriptsResponseProto(const GetTriggerScriptsResponseProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      trigger_scripts_(from.trigger_scripts_),
      additional_allowed_domains_(from.additional_allowed_domains_),
      script_parameters_(from.script_parameters_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&trigger_condition_timeout_ms_, &from.trigger_condition_timeout_ms_,
    static_cast<size_t>(reinterpret_cast<char*>(&trigger_condition_check_interval_ms_) -
    reinterpret_cast<char*>(&trigger_condition_timeout_ms_)) + sizeof(trigger_condition_check_interval_ms_));
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.GetTriggerScriptsResponseProto)
}

inline void GetTriggerScriptsResponseProto::SharedCtor() {
trigger_condition_timeout_ms_ = 0;
trigger_condition_check_interval_ms_ = 1000;
}

GetTriggerScriptsResponseProto::~GetTriggerScriptsResponseProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.GetTriggerScriptsResponseProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GetTriggerScriptsResponseProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void GetTriggerScriptsResponseProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void GetTriggerScriptsResponseProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.GetTriggerScriptsResponseProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  trigger_scripts_.Clear();
  additional_allowed_domains_.Clear();
  script_parameters_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    trigger_condition_timeout_ms_ = 0;
    trigger_condition_check_interval_ms_ = 1000;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* GetTriggerScriptsResponseProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .autofill_assistant.TriggerScriptProto trigger_scripts = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_trigger_scripts(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated string additional_allowed_domains = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_additional_allowed_domains();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional int32 trigger_condition_timeout_ms = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_trigger_condition_timeout_ms(&has_bits);
          trigger_condition_timeout_ms_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 trigger_condition_check_interval_ms = 4 [default = 1000];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_trigger_condition_check_interval_ms(&has_bits);
          trigger_condition_check_interval_ms_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .autofill_assistant.ScriptParameterProto script_parameters = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_script_parameters(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GetTriggerScriptsResponseProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.GetTriggerScriptsResponseProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .autofill_assistant.TriggerScriptProto trigger_scripts = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_trigger_scripts_size()); i < n; i++) {
    const auto& repfield = this->_internal_trigger_scripts(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated string additional_allowed_domains = 2;
  for (int i = 0, n = this->_internal_additional_allowed_domains_size(); i < n; i++) {
    const auto& s = this->_internal_additional_allowed_domains(i);
    target = stream->WriteString(2, s, target);
  }

  cached_has_bits = _has_bits_[0];
  // optional int32 trigger_condition_timeout_ms = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_trigger_condition_timeout_ms(), target);
  }

  // optional int32 trigger_condition_check_interval_ms = 4 [default = 1000];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_trigger_condition_check_interval_ms(), target);
  }

  // repeated .autofill_assistant.ScriptParameterProto script_parameters = 5;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_script_parameters_size()); i < n; i++) {
    const auto& repfield = this->_internal_script_parameters(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(5, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.GetTriggerScriptsResponseProto)
  return target;
}

size_t GetTriggerScriptsResponseProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.GetTriggerScriptsResponseProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .autofill_assistant.TriggerScriptProto trigger_scripts = 1;
  total_size += 1UL * this->_internal_trigger_scripts_size();
  for (const auto& msg : this->trigger_scripts_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated string additional_allowed_domains = 2;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(additional_allowed_domains_.size());
  for (int i = 0, n = additional_allowed_domains_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      additional_allowed_domains_.Get(i));
  }

  // repeated .autofill_assistant.ScriptParameterProto script_parameters = 5;
  total_size += 1UL * this->_internal_script_parameters_size();
  for (const auto& msg : this->script_parameters_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional int32 trigger_condition_timeout_ms = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_trigger_condition_timeout_ms());
    }

    // optional int32 trigger_condition_check_interval_ms = 4 [default = 1000];
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_trigger_condition_check_interval_ms());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void GetTriggerScriptsResponseProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const GetTriggerScriptsResponseProto*>(
      &from));
}

void GetTriggerScriptsResponseProto::MergeFrom(const GetTriggerScriptsResponseProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.GetTriggerScriptsResponseProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  trigger_scripts_.MergeFrom(from.trigger_scripts_);
  additional_allowed_domains_.MergeFrom(from.additional_allowed_domains_);
  script_parameters_.MergeFrom(from.script_parameters_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      trigger_condition_timeout_ms_ = from.trigger_condition_timeout_ms_;
    }
    if (cached_has_bits & 0x00000002u) {
      trigger_condition_check_interval_ms_ = from.trigger_condition_check_interval_ms_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void GetTriggerScriptsResponseProto::CopyFrom(const GetTriggerScriptsResponseProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.GetTriggerScriptsResponseProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetTriggerScriptsResponseProto::IsInitialized() const {
  return true;
}

void GetTriggerScriptsResponseProto::InternalSwap(GetTriggerScriptsResponseProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  trigger_scripts_.InternalSwap(&other->trigger_scripts_);
  additional_allowed_domains_.InternalSwap(&other->additional_allowed_domains_);
  script_parameters_.InternalSwap(&other->script_parameters_);
  swap(trigger_condition_timeout_ms_, other->trigger_condition_timeout_ms_);
  swap(trigger_condition_check_interval_ms_, other->trigger_condition_check_interval_ms_);
}

std::string GetTriggerScriptsResponseProto::GetTypeName() const {
  return "autofill_assistant.GetTriggerScriptsResponseProto";
}


// ===================================================================

class TriggerScriptProto::_Internal {
 public:
  using HasBits = decltype(std::declval<TriggerScriptProto>()._has_bits_);
  static const ::autofill_assistant::TriggerScriptConditionProto& trigger_condition(const TriggerScriptProto* msg);
  static void set_has_trigger_condition(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::autofill_assistant::TriggerScriptUIProto& user_interface(const TriggerScriptProto* msg);
  static void set_has_user_interface(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_on_swipe_to_dismiss(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_trigger_ui_type(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::autofill_assistant::TriggerScriptConditionProto&
TriggerScriptProto::_Internal::trigger_condition(const TriggerScriptProto* msg) {
  return *msg->trigger_condition_;
}
const ::autofill_assistant::TriggerScriptUIProto&
TriggerScriptProto::_Internal::user_interface(const TriggerScriptProto* msg) {
  return *msg->user_interface_;
}
TriggerScriptProto::TriggerScriptProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.TriggerScriptProto)
}
TriggerScriptProto::TriggerScriptProto(const TriggerScriptProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_trigger_condition()) {
    trigger_condition_ = new ::autofill_assistant::TriggerScriptConditionProto(*from.trigger_condition_);
  } else {
    trigger_condition_ = nullptr;
  }
  if (from._internal_has_user_interface()) {
    user_interface_ = new ::autofill_assistant::TriggerScriptUIProto(*from.user_interface_);
  } else {
    user_interface_ = nullptr;
  }
  ::memcpy(&trigger_ui_type_, &from.trigger_ui_type_,
    static_cast<size_t>(reinterpret_cast<char*>(&on_swipe_to_dismiss_) -
    reinterpret_cast<char*>(&trigger_ui_type_)) + sizeof(on_swipe_to_dismiss_));
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.TriggerScriptProto)
}

inline void TriggerScriptProto::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&trigger_condition_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&trigger_ui_type_) -
    reinterpret_cast<char*>(&trigger_condition_)) + sizeof(trigger_ui_type_));
on_swipe_to_dismiss_ = 2;
}

TriggerScriptProto::~TriggerScriptProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.TriggerScriptProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TriggerScriptProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete trigger_condition_;
  if (this != internal_default_instance()) delete user_interface_;
}

void TriggerScriptProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void TriggerScriptProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.TriggerScriptProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(trigger_condition_ != nullptr);
      trigger_condition_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(user_interface_ != nullptr);
      user_interface_->Clear();
    }
  }
  if (cached_has_bits & 0x0000000cu) {
    trigger_ui_type_ = 0;
    on_swipe_to_dismiss_ = 2;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* TriggerScriptProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .autofill_assistant.TriggerScriptConditionProto trigger_condition = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_trigger_condition(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .autofill_assistant.TriggerScriptUIProto user_interface = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_user_interface(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .autofill_assistant.TriggerScriptProto.TriggerScriptAction on_swipe_to_dismiss = 4 [default = CANCEL_SESSION];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::autofill_assistant::TriggerScriptProto_TriggerScriptAction_IsValid(val))) {
            _internal_set_on_swipe_to_dismiss(static_cast<::autofill_assistant::TriggerScriptProto_TriggerScriptAction>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .autofill_assistant.TriggerScriptProto.TriggerUIType trigger_ui_type = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::autofill_assistant::TriggerScriptProto_TriggerUIType_IsValid(val))) {
            _internal_set_trigger_ui_type(static_cast<::autofill_assistant::TriggerScriptProto_TriggerUIType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(7, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TriggerScriptProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.TriggerScriptProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .autofill_assistant.TriggerScriptConditionProto trigger_condition = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::trigger_condition(this),
        _Internal::trigger_condition(this).GetCachedSize(), target, stream);
  }

  // optional .autofill_assistant.TriggerScriptUIProto user_interface = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::user_interface(this),
        _Internal::user_interface(this).GetCachedSize(), target, stream);
  }

  // optional .autofill_assistant.TriggerScriptProto.TriggerScriptAction on_swipe_to_dismiss = 4 [default = CANCEL_SESSION];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      4, this->_internal_on_swipe_to_dismiss(), target);
  }

  // optional .autofill_assistant.TriggerScriptProto.TriggerUIType trigger_ui_type = 7;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      7, this->_internal_trigger_ui_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.TriggerScriptProto)
  return target;
}

size_t TriggerScriptProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.TriggerScriptProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional .autofill_assistant.TriggerScriptConditionProto trigger_condition = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *trigger_condition_);
    }

    // optional .autofill_assistant.TriggerScriptUIProto user_interface = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *user_interface_);
    }

    // optional .autofill_assistant.TriggerScriptProto.TriggerUIType trigger_ui_type = 7;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_trigger_ui_type());
    }

    // optional .autofill_assistant.TriggerScriptProto.TriggerScriptAction on_swipe_to_dismiss = 4 [default = CANCEL_SESSION];
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_on_swipe_to_dismiss());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TriggerScriptProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const TriggerScriptProto*>(
      &from));
}

void TriggerScriptProto::MergeFrom(const TriggerScriptProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.TriggerScriptProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_trigger_condition()->::autofill_assistant::TriggerScriptConditionProto::MergeFrom(from._internal_trigger_condition());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_user_interface()->::autofill_assistant::TriggerScriptUIProto::MergeFrom(from._internal_user_interface());
    }
    if (cached_has_bits & 0x00000004u) {
      trigger_ui_type_ = from.trigger_ui_type_;
    }
    if (cached_has_bits & 0x00000008u) {
      on_swipe_to_dismiss_ = from.on_swipe_to_dismiss_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TriggerScriptProto::CopyFrom(const TriggerScriptProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.TriggerScriptProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TriggerScriptProto::IsInitialized() const {
  return true;
}

void TriggerScriptProto::InternalSwap(TriggerScriptProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TriggerScriptProto, trigger_ui_type_)
      + sizeof(TriggerScriptProto::trigger_ui_type_)
      - PROTOBUF_FIELD_OFFSET(TriggerScriptProto, trigger_condition_)>(
          reinterpret_cast<char*>(&trigger_condition_),
          reinterpret_cast<char*>(&other->trigger_condition_));
  swap(on_swipe_to_dismiss_, other->on_swipe_to_dismiss_);
}

std::string TriggerScriptProto::GetTypeName() const {
  return "autofill_assistant.TriggerScriptProto";
}


// ===================================================================

class TriggerScriptConditionProto_DocumentReadyStateCondition::_Internal {
 public:
  using HasBits = decltype(std::declval<TriggerScriptConditionProto_DocumentReadyStateCondition>()._has_bits_);
  static void set_has_min_document_ready_state(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::autofill_assistant::SelectorProto& frame(const TriggerScriptConditionProto_DocumentReadyStateCondition* msg);
  static void set_has_frame(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::autofill_assistant::SelectorProto&
TriggerScriptConditionProto_DocumentReadyStateCondition::_Internal::frame(const TriggerScriptConditionProto_DocumentReadyStateCondition* msg) {
  return *msg->frame_;
}
TriggerScriptConditionProto_DocumentReadyStateCondition::TriggerScriptConditionProto_DocumentReadyStateCondition(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.TriggerScriptConditionProto.DocumentReadyStateCondition)
}
TriggerScriptConditionProto_DocumentReadyStateCondition::TriggerScriptConditionProto_DocumentReadyStateCondition(const TriggerScriptConditionProto_DocumentReadyStateCondition& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_frame()) {
    frame_ = new ::autofill_assistant::SelectorProto(*from.frame_);
  } else {
    frame_ = nullptr;
  }
  min_document_ready_state_ = from.min_document_ready_state_;
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.TriggerScriptConditionProto.DocumentReadyStateCondition)
}

inline void TriggerScriptConditionProto_DocumentReadyStateCondition::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&frame_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&min_document_ready_state_) -
    reinterpret_cast<char*>(&frame_)) + sizeof(min_document_ready_state_));
}

TriggerScriptConditionProto_DocumentReadyStateCondition::~TriggerScriptConditionProto_DocumentReadyStateCondition() {
  // @@protoc_insertion_point(destructor:autofill_assistant.TriggerScriptConditionProto.DocumentReadyStateCondition)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TriggerScriptConditionProto_DocumentReadyStateCondition::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete frame_;
}

void TriggerScriptConditionProto_DocumentReadyStateCondition::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void TriggerScriptConditionProto_DocumentReadyStateCondition::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.TriggerScriptConditionProto.DocumentReadyStateCondition)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(frame_ != nullptr);
    frame_->Clear();
  }
  min_document_ready_state_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* TriggerScriptConditionProto_DocumentReadyStateCondition::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .autofill_assistant.DocumentReadyState min_document_ready_state = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::autofill_assistant::DocumentReadyState_IsValid(val))) {
            _internal_set_min_document_ready_state(static_cast<::autofill_assistant::DocumentReadyState>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .autofill_assistant.SelectorProto frame = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_frame(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TriggerScriptConditionProto_DocumentReadyStateCondition::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.TriggerScriptConditionProto.DocumentReadyStateCondition)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .autofill_assistant.DocumentReadyState min_document_ready_state = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_min_document_ready_state(), target);
  }

  // optional .autofill_assistant.SelectorProto frame = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::frame(this),
        _Internal::frame(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.TriggerScriptConditionProto.DocumentReadyStateCondition)
  return target;
}

size_t TriggerScriptConditionProto_DocumentReadyStateCondition::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.TriggerScriptConditionProto.DocumentReadyStateCondition)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .autofill_assistant.SelectorProto frame = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *frame_);
    }

    // optional .autofill_assistant.DocumentReadyState min_document_ready_state = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_min_document_ready_state());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TriggerScriptConditionProto_DocumentReadyStateCondition::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const TriggerScriptConditionProto_DocumentReadyStateCondition*>(
      &from));
}

void TriggerScriptConditionProto_DocumentReadyStateCondition::MergeFrom(const TriggerScriptConditionProto_DocumentReadyStateCondition& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.TriggerScriptConditionProto.DocumentReadyStateCondition)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_frame()->::autofill_assistant::SelectorProto::MergeFrom(from._internal_frame());
    }
    if (cached_has_bits & 0x00000002u) {
      min_document_ready_state_ = from.min_document_ready_state_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TriggerScriptConditionProto_DocumentReadyStateCondition::CopyFrom(const TriggerScriptConditionProto_DocumentReadyStateCondition& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.TriggerScriptConditionProto.DocumentReadyStateCondition)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TriggerScriptConditionProto_DocumentReadyStateCondition::IsInitialized() const {
  return true;
}

void TriggerScriptConditionProto_DocumentReadyStateCondition::InternalSwap(TriggerScriptConditionProto_DocumentReadyStateCondition* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TriggerScriptConditionProto_DocumentReadyStateCondition, min_document_ready_state_)
      + sizeof(TriggerScriptConditionProto_DocumentReadyStateCondition::min_document_ready_state_)
      - PROTOBUF_FIELD_OFFSET(TriggerScriptConditionProto_DocumentReadyStateCondition, frame_)>(
          reinterpret_cast<char*>(&frame_),
          reinterpret_cast<char*>(&other->frame_));
}

std::string TriggerScriptConditionProto_DocumentReadyStateCondition::GetTypeName() const {
  return "autofill_assistant.TriggerScriptConditionProto.DocumentReadyStateCondition";
}


// ===================================================================

class TriggerScriptConditionProto::_Internal {
 public:
  static const ::autofill_assistant::TriggerScriptConditionsProto& all_of(const TriggerScriptConditionProto* msg);
  static const ::autofill_assistant::TriggerScriptConditionsProto& any_of(const TriggerScriptConditionProto* msg);
  static const ::autofill_assistant::TriggerScriptConditionsProto& none_of(const TriggerScriptConditionProto* msg);
  static const ::autofill_assistant::SelectorProto& selector(const TriggerScriptConditionProto* msg);
  static const ::autofill_assistant::Empty& stored_login_credentials(const TriggerScriptConditionProto* msg);
  static const ::autofill_assistant::Empty& is_first_time_user(const TriggerScriptConditionProto* msg);
  static const ::autofill_assistant::Empty& keyboard_hidden(const TriggerScriptConditionProto* msg);
  static const ::autofill_assistant::ScriptParameterMatchProto& script_parameter_match(const TriggerScriptConditionProto* msg);
  static const ::autofill_assistant::TriggerScriptConditionProto_DocumentReadyStateCondition& document_ready_state(const TriggerScriptConditionProto* msg);
};

const ::autofill_assistant::TriggerScriptConditionsProto&
TriggerScriptConditionProto::_Internal::all_of(const TriggerScriptConditionProto* msg) {
  return *msg->type_.all_of_;
}
const ::autofill_assistant::TriggerScriptConditionsProto&
TriggerScriptConditionProto::_Internal::any_of(const TriggerScriptConditionProto* msg) {
  return *msg->type_.any_of_;
}
const ::autofill_assistant::TriggerScriptConditionsProto&
TriggerScriptConditionProto::_Internal::none_of(const TriggerScriptConditionProto* msg) {
  return *msg->type_.none_of_;
}
const ::autofill_assistant::SelectorProto&
TriggerScriptConditionProto::_Internal::selector(const TriggerScriptConditionProto* msg) {
  return *msg->type_.selector_;
}
const ::autofill_assistant::Empty&
TriggerScriptConditionProto::_Internal::stored_login_credentials(const TriggerScriptConditionProto* msg) {
  return *msg->type_.stored_login_credentials_;
}
const ::autofill_assistant::Empty&
TriggerScriptConditionProto::_Internal::is_first_time_user(const TriggerScriptConditionProto* msg) {
  return *msg->type_.is_first_time_user_;
}
const ::autofill_assistant::Empty&
TriggerScriptConditionProto::_Internal::keyboard_hidden(const TriggerScriptConditionProto* msg) {
  return *msg->type_.keyboard_hidden_;
}
const ::autofill_assistant::ScriptParameterMatchProto&
TriggerScriptConditionProto::_Internal::script_parameter_match(const TriggerScriptConditionProto* msg) {
  return *msg->type_.script_parameter_match_;
}
const ::autofill_assistant::TriggerScriptConditionProto_DocumentReadyStateCondition&
TriggerScriptConditionProto::_Internal::document_ready_state(const TriggerScriptConditionProto* msg) {
  return *msg->type_.document_ready_state_;
}
void TriggerScriptConditionProto::set_allocated_all_of(::autofill_assistant::TriggerScriptConditionsProto* all_of) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_type();
  if (all_of) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(all_of);
    if (message_arena != submessage_arena) {
      all_of = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, all_of, submessage_arena);
    }
    set_has_all_of();
    type_.all_of_ = all_of;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.TriggerScriptConditionProto.all_of)
}
void TriggerScriptConditionProto::set_allocated_any_of(::autofill_assistant::TriggerScriptConditionsProto* any_of) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_type();
  if (any_of) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(any_of);
    if (message_arena != submessage_arena) {
      any_of = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, any_of, submessage_arena);
    }
    set_has_any_of();
    type_.any_of_ = any_of;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.TriggerScriptConditionProto.any_of)
}
void TriggerScriptConditionProto::set_allocated_none_of(::autofill_assistant::TriggerScriptConditionsProto* none_of) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_type();
  if (none_of) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(none_of);
    if (message_arena != submessage_arena) {
      none_of = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, none_of, submessage_arena);
    }
    set_has_none_of();
    type_.none_of_ = none_of;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.TriggerScriptConditionProto.none_of)
}
void TriggerScriptConditionProto::set_allocated_selector(::autofill_assistant::SelectorProto* selector) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_type();
  if (selector) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(selector);
    if (message_arena != submessage_arena) {
      selector = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, selector, submessage_arena);
    }
    set_has_selector();
    type_.selector_ = selector;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.TriggerScriptConditionProto.selector)
}
void TriggerScriptConditionProto::set_allocated_stored_login_credentials(::autofill_assistant::Empty* stored_login_credentials) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_type();
  if (stored_login_credentials) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(stored_login_credentials));
    if (message_arena != submessage_arena) {
      stored_login_credentials = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stored_login_credentials, submessage_arena);
    }
    set_has_stored_login_credentials();
    type_.stored_login_credentials_ = stored_login_credentials;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.TriggerScriptConditionProto.stored_login_credentials)
}
void TriggerScriptConditionProto::clear_stored_login_credentials() {
  if (_internal_has_stored_login_credentials()) {
    if (GetArenaForAllocation() == nullptr) {
      delete type_.stored_login_credentials_;
    }
    clear_has_type();
  }
}
void TriggerScriptConditionProto::set_allocated_is_first_time_user(::autofill_assistant::Empty* is_first_time_user) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_type();
  if (is_first_time_user) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(is_first_time_user));
    if (message_arena != submessage_arena) {
      is_first_time_user = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, is_first_time_user, submessage_arena);
    }
    set_has_is_first_time_user();
    type_.is_first_time_user_ = is_first_time_user;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.TriggerScriptConditionProto.is_first_time_user)
}
void TriggerScriptConditionProto::clear_is_first_time_user() {
  if (_internal_has_is_first_time_user()) {
    if (GetArenaForAllocation() == nullptr) {
      delete type_.is_first_time_user_;
    }
    clear_has_type();
  }
}
void TriggerScriptConditionProto::set_allocated_keyboard_hidden(::autofill_assistant::Empty* keyboard_hidden) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_type();
  if (keyboard_hidden) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(keyboard_hidden));
    if (message_arena != submessage_arena) {
      keyboard_hidden = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, keyboard_hidden, submessage_arena);
    }
    set_has_keyboard_hidden();
    type_.keyboard_hidden_ = keyboard_hidden;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.TriggerScriptConditionProto.keyboard_hidden)
}
void TriggerScriptConditionProto::clear_keyboard_hidden() {
  if (_internal_has_keyboard_hidden()) {
    if (GetArenaForAllocation() == nullptr) {
      delete type_.keyboard_hidden_;
    }
    clear_has_type();
  }
}
void TriggerScriptConditionProto::set_allocated_script_parameter_match(::autofill_assistant::ScriptParameterMatchProto* script_parameter_match) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_type();
  if (script_parameter_match) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(script_parameter_match);
    if (message_arena != submessage_arena) {
      script_parameter_match = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, script_parameter_match, submessage_arena);
    }
    set_has_script_parameter_match();
    type_.script_parameter_match_ = script_parameter_match;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.TriggerScriptConditionProto.script_parameter_match)
}
void TriggerScriptConditionProto::set_allocated_document_ready_state(::autofill_assistant::TriggerScriptConditionProto_DocumentReadyStateCondition* document_ready_state) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_type();
  if (document_ready_state) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(document_ready_state);
    if (message_arena != submessage_arena) {
      document_ready_state = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, document_ready_state, submessage_arena);
    }
    set_has_document_ready_state();
    type_.document_ready_state_ = document_ready_state;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.TriggerScriptConditionProto.document_ready_state)
}
TriggerScriptConditionProto::TriggerScriptConditionProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.TriggerScriptConditionProto)
}
TriggerScriptConditionProto::TriggerScriptConditionProto(const TriggerScriptConditionProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  clear_has_type();
  switch (from.type_case()) {
    case kAllOf: {
      _internal_mutable_all_of()->::autofill_assistant::TriggerScriptConditionsProto::MergeFrom(from._internal_all_of());
      break;
    }
    case kAnyOf: {
      _internal_mutable_any_of()->::autofill_assistant::TriggerScriptConditionsProto::MergeFrom(from._internal_any_of());
      break;
    }
    case kNoneOf: {
      _internal_mutable_none_of()->::autofill_assistant::TriggerScriptConditionsProto::MergeFrom(from._internal_none_of());
      break;
    }
    case kSelector: {
      _internal_mutable_selector()->::autofill_assistant::SelectorProto::MergeFrom(from._internal_selector());
      break;
    }
    case kStoredLoginCredentials: {
      _internal_mutable_stored_login_credentials()->::autofill_assistant::Empty::MergeFrom(from._internal_stored_login_credentials());
      break;
    }
    case kIsFirstTimeUser: {
      _internal_mutable_is_first_time_user()->::autofill_assistant::Empty::MergeFrom(from._internal_is_first_time_user());
      break;
    }
    case kExperimentId: {
      _internal_set_experiment_id(from._internal_experiment_id());
      break;
    }
    case kKeyboardHidden: {
      _internal_mutable_keyboard_hidden()->::autofill_assistant::Empty::MergeFrom(from._internal_keyboard_hidden());
      break;
    }
    case kScriptParameterMatch: {
      _internal_mutable_script_parameter_match()->::autofill_assistant::ScriptParameterMatchProto::MergeFrom(from._internal_script_parameter_match());
      break;
    }
    case kPathPattern: {
      _internal_set_path_pattern(from._internal_path_pattern());
      break;
    }
    case kDomainWithScheme: {
      _internal_set_domain_with_scheme(from._internal_domain_with_scheme());
      break;
    }
    case kDocumentReadyState: {
      _internal_mutable_document_ready_state()->::autofill_assistant::TriggerScriptConditionProto_DocumentReadyStateCondition::MergeFrom(from._internal_document_ready_state());
      break;
    }
    case TYPE_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.TriggerScriptConditionProto)
}

inline void TriggerScriptConditionProto::SharedCtor() {
clear_has_type();
}

TriggerScriptConditionProto::~TriggerScriptConditionProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.TriggerScriptConditionProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TriggerScriptConditionProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_type()) {
    clear_type();
  }
}

void TriggerScriptConditionProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void TriggerScriptConditionProto::clear_type() {
// @@protoc_insertion_point(one_of_clear_start:autofill_assistant.TriggerScriptConditionProto)
  switch (type_case()) {
    case kAllOf: {
      if (GetArenaForAllocation() == nullptr) {
        delete type_.all_of_;
      }
      break;
    }
    case kAnyOf: {
      if (GetArenaForAllocation() == nullptr) {
        delete type_.any_of_;
      }
      break;
    }
    case kNoneOf: {
      if (GetArenaForAllocation() == nullptr) {
        delete type_.none_of_;
      }
      break;
    }
    case kSelector: {
      if (GetArenaForAllocation() == nullptr) {
        delete type_.selector_;
      }
      break;
    }
    case kStoredLoginCredentials: {
      if (GetArenaForAllocation() == nullptr) {
        delete type_.stored_login_credentials_;
      }
      break;
    }
    case kIsFirstTimeUser: {
      if (GetArenaForAllocation() == nullptr) {
        delete type_.is_first_time_user_;
      }
      break;
    }
    case kExperimentId: {
      // No need to clear
      break;
    }
    case kKeyboardHidden: {
      if (GetArenaForAllocation() == nullptr) {
        delete type_.keyboard_hidden_;
      }
      break;
    }
    case kScriptParameterMatch: {
      if (GetArenaForAllocation() == nullptr) {
        delete type_.script_parameter_match_;
      }
      break;
    }
    case kPathPattern: {
      type_.path_pattern_.Destroy();
      break;
    }
    case kDomainWithScheme: {
      type_.domain_with_scheme_.Destroy();
      break;
    }
    case kDocumentReadyState: {
      if (GetArenaForAllocation() == nullptr) {
        delete type_.document_ready_state_;
      }
      break;
    }
    case TYPE_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = TYPE_NOT_SET;
}


void TriggerScriptConditionProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.TriggerScriptConditionProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_type();
  _internal_metadata_.Clear<std::string>();
}

const char* TriggerScriptConditionProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .autofill_assistant.TriggerScriptConditionsProto all_of = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_all_of(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.TriggerScriptConditionsProto any_of = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_any_of(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.TriggerScriptConditionsProto none_of = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_none_of(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.Empty stored_login_credentials = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_stored_login_credentials(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.Empty is_first_time_user = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_is_first_time_user(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 experiment_id = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _internal_set_experiment_id(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.SelectorProto selector = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_selector(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.Empty keyboard_hidden = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_keyboard_hidden(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.ScriptParameterMatchProto script_parameter_match = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_script_parameter_match(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string path_pattern = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          auto str = _internal_mutable_path_pattern();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string domain_with_scheme = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          auto str = _internal_mutable_domain_with_scheme();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.TriggerScriptConditionProto.DocumentReadyStateCondition document_ready_state = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          ptr = ctx->ParseMessage(_internal_mutable_document_ready_state(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TriggerScriptConditionProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.TriggerScriptConditionProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (type_case()) {
    case kAllOf: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, _Internal::all_of(this),
          _Internal::all_of(this).GetCachedSize(), target, stream);
      break;
    }
    case kAnyOf: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, _Internal::any_of(this),
          _Internal::any_of(this).GetCachedSize(), target, stream);
      break;
    }
    case kNoneOf: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, _Internal::none_of(this),
          _Internal::none_of(this).GetCachedSize(), target, stream);
      break;
    }
    case kStoredLoginCredentials: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(5, _Internal::stored_login_credentials(this),
          _Internal::stored_login_credentials(this).GetCachedSize(), target, stream);
      break;
    }
    case kIsFirstTimeUser: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(6, _Internal::is_first_time_user(this),
          _Internal::is_first_time_user(this).GetCachedSize(), target, stream);
      break;
    }
    case kExperimentId: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteInt32ToArray(7, this->_internal_experiment_id(), target);
      break;
    }
    case kSelector: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(8, _Internal::selector(this),
          _Internal::selector(this).GetCachedSize(), target, stream);
      break;
    }
    case kKeyboardHidden: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(9, _Internal::keyboard_hidden(this),
          _Internal::keyboard_hidden(this).GetCachedSize(), target, stream);
      break;
    }
    case kScriptParameterMatch: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(10, _Internal::script_parameter_match(this),
          _Internal::script_parameter_match(this).GetCachedSize(), target, stream);
      break;
    }
    case kPathPattern: {
      target = stream->WriteStringMaybeAliased(
          11, this->_internal_path_pattern(), target);
      break;
    }
    case kDomainWithScheme: {
      target = stream->WriteStringMaybeAliased(
          12, this->_internal_domain_with_scheme(), target);
      break;
    }
    case kDocumentReadyState: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(13, _Internal::document_ready_state(this),
          _Internal::document_ready_state(this).GetCachedSize(), target, stream);
      break;
    }
    default: ;
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.TriggerScriptConditionProto)
  return target;
}

size_t TriggerScriptConditionProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.TriggerScriptConditionProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (type_case()) {
    // .autofill_assistant.TriggerScriptConditionsProto all_of = 1;
    case kAllOf: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *type_.all_of_);
      break;
    }
    // .autofill_assistant.TriggerScriptConditionsProto any_of = 2;
    case kAnyOf: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *type_.any_of_);
      break;
    }
    // .autofill_assistant.TriggerScriptConditionsProto none_of = 3;
    case kNoneOf: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *type_.none_of_);
      break;
    }
    // .autofill_assistant.SelectorProto selector = 8;
    case kSelector: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *type_.selector_);
      break;
    }
    // .autofill_assistant.Empty stored_login_credentials = 5;
    case kStoredLoginCredentials: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *type_.stored_login_credentials_);
      break;
    }
    // .autofill_assistant.Empty is_first_time_user = 6;
    case kIsFirstTimeUser: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *type_.is_first_time_user_);
      break;
    }
    // int32 experiment_id = 7;
    case kExperimentId: {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_experiment_id());
      break;
    }
    // .autofill_assistant.Empty keyboard_hidden = 9;
    case kKeyboardHidden: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *type_.keyboard_hidden_);
      break;
    }
    // .autofill_assistant.ScriptParameterMatchProto script_parameter_match = 10;
    case kScriptParameterMatch: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *type_.script_parameter_match_);
      break;
    }
    // string path_pattern = 11;
    case kPathPattern: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_path_pattern());
      break;
    }
    // string domain_with_scheme = 12;
    case kDomainWithScheme: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_domain_with_scheme());
      break;
    }
    // .autofill_assistant.TriggerScriptConditionProto.DocumentReadyStateCondition document_ready_state = 13;
    case kDocumentReadyState: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *type_.document_ready_state_);
      break;
    }
    case TYPE_NOT_SET: {
      break;
    }
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TriggerScriptConditionProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const TriggerScriptConditionProto*>(
      &from));
}

void TriggerScriptConditionProto::MergeFrom(const TriggerScriptConditionProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.TriggerScriptConditionProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.type_case()) {
    case kAllOf: {
      _internal_mutable_all_of()->::autofill_assistant::TriggerScriptConditionsProto::MergeFrom(from._internal_all_of());
      break;
    }
    case kAnyOf: {
      _internal_mutable_any_of()->::autofill_assistant::TriggerScriptConditionsProto::MergeFrom(from._internal_any_of());
      break;
    }
    case kNoneOf: {
      _internal_mutable_none_of()->::autofill_assistant::TriggerScriptConditionsProto::MergeFrom(from._internal_none_of());
      break;
    }
    case kSelector: {
      _internal_mutable_selector()->::autofill_assistant::SelectorProto::MergeFrom(from._internal_selector());
      break;
    }
    case kStoredLoginCredentials: {
      _internal_mutable_stored_login_credentials()->::autofill_assistant::Empty::MergeFrom(from._internal_stored_login_credentials());
      break;
    }
    case kIsFirstTimeUser: {
      _internal_mutable_is_first_time_user()->::autofill_assistant::Empty::MergeFrom(from._internal_is_first_time_user());
      break;
    }
    case kExperimentId: {
      _internal_set_experiment_id(from._internal_experiment_id());
      break;
    }
    case kKeyboardHidden: {
      _internal_mutable_keyboard_hidden()->::autofill_assistant::Empty::MergeFrom(from._internal_keyboard_hidden());
      break;
    }
    case kScriptParameterMatch: {
      _internal_mutable_script_parameter_match()->::autofill_assistant::ScriptParameterMatchProto::MergeFrom(from._internal_script_parameter_match());
      break;
    }
    case kPathPattern: {
      _internal_set_path_pattern(from._internal_path_pattern());
      break;
    }
    case kDomainWithScheme: {
      _internal_set_domain_with_scheme(from._internal_domain_with_scheme());
      break;
    }
    case kDocumentReadyState: {
      _internal_mutable_document_ready_state()->::autofill_assistant::TriggerScriptConditionProto_DocumentReadyStateCondition::MergeFrom(from._internal_document_ready_state());
      break;
    }
    case TYPE_NOT_SET: {
      break;
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TriggerScriptConditionProto::CopyFrom(const TriggerScriptConditionProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.TriggerScriptConditionProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TriggerScriptConditionProto::IsInitialized() const {
  return true;
}

void TriggerScriptConditionProto::InternalSwap(TriggerScriptConditionProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(type_, other->type_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

std::string TriggerScriptConditionProto::GetTypeName() const {
  return "autofill_assistant.TriggerScriptConditionProto";
}


// ===================================================================

class TriggerScriptConditionsProto::_Internal {
 public:
};

TriggerScriptConditionsProto::TriggerScriptConditionsProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  conditions_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.TriggerScriptConditionsProto)
}
TriggerScriptConditionsProto::TriggerScriptConditionsProto(const TriggerScriptConditionsProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      conditions_(from.conditions_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.TriggerScriptConditionsProto)
}

inline void TriggerScriptConditionsProto::SharedCtor() {
}

TriggerScriptConditionsProto::~TriggerScriptConditionsProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.TriggerScriptConditionsProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TriggerScriptConditionsProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void TriggerScriptConditionsProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void TriggerScriptConditionsProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.TriggerScriptConditionsProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  conditions_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* TriggerScriptConditionsProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .autofill_assistant.TriggerScriptConditionProto conditions = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_conditions(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TriggerScriptConditionsProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.TriggerScriptConditionsProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .autofill_assistant.TriggerScriptConditionProto conditions = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_conditions_size()); i < n; i++) {
    const auto& repfield = this->_internal_conditions(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.TriggerScriptConditionsProto)
  return target;
}

size_t TriggerScriptConditionsProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.TriggerScriptConditionsProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .autofill_assistant.TriggerScriptConditionProto conditions = 1;
  total_size += 1UL * this->_internal_conditions_size();
  for (const auto& msg : this->conditions_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TriggerScriptConditionsProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const TriggerScriptConditionsProto*>(
      &from));
}

void TriggerScriptConditionsProto::MergeFrom(const TriggerScriptConditionsProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.TriggerScriptConditionsProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  conditions_.MergeFrom(from.conditions_);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TriggerScriptConditionsProto::CopyFrom(const TriggerScriptConditionsProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.TriggerScriptConditionsProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TriggerScriptConditionsProto::IsInitialized() const {
  return true;
}

void TriggerScriptConditionsProto::InternalSwap(TriggerScriptConditionsProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  conditions_.InternalSwap(&other->conditions_);
}

std::string TriggerScriptConditionsProto::GetTypeName() const {
  return "autofill_assistant.TriggerScriptConditionsProto";
}


// ===================================================================

class TriggerScriptUIProto_ProgressBar::_Internal {
 public:
  using HasBits = decltype(std::declval<TriggerScriptUIProto_ProgressBar>()._has_bits_);
  static void set_has_active_step(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

void TriggerScriptUIProto_ProgressBar::clear_step_icons() {
  step_icons_.Clear();
}
TriggerScriptUIProto_ProgressBar::TriggerScriptUIProto_ProgressBar(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  step_icons_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.TriggerScriptUIProto.ProgressBar)
}
TriggerScriptUIProto_ProgressBar::TriggerScriptUIProto_ProgressBar(const TriggerScriptUIProto_ProgressBar& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      step_icons_(from.step_icons_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  active_step_ = from.active_step_;
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.TriggerScriptUIProto.ProgressBar)
}

inline void TriggerScriptUIProto_ProgressBar::SharedCtor() {
active_step_ = 0;
}

TriggerScriptUIProto_ProgressBar::~TriggerScriptUIProto_ProgressBar() {
  // @@protoc_insertion_point(destructor:autofill_assistant.TriggerScriptUIProto.ProgressBar)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TriggerScriptUIProto_ProgressBar::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void TriggerScriptUIProto_ProgressBar::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void TriggerScriptUIProto_ProgressBar::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.TriggerScriptUIProto.ProgressBar)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  step_icons_.Clear();
  active_step_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* TriggerScriptUIProto_ProgressBar::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .autofill_assistant.DrawableProto step_icons = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_step_icons(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional int32 active_step = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_active_step(&has_bits);
          active_step_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TriggerScriptUIProto_ProgressBar::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.TriggerScriptUIProto.ProgressBar)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .autofill_assistant.DrawableProto step_icons = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_step_icons_size()); i < n; i++) {
    const auto& repfield = this->_internal_step_icons(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  cached_has_bits = _has_bits_[0];
  // optional int32 active_step = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_active_step(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.TriggerScriptUIProto.ProgressBar)
  return target;
}

size_t TriggerScriptUIProto_ProgressBar::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.TriggerScriptUIProto.ProgressBar)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .autofill_assistant.DrawableProto step_icons = 1;
  total_size += 1UL * this->_internal_step_icons_size();
  for (const auto& msg : this->step_icons_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional int32 active_step = 2;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_active_step());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TriggerScriptUIProto_ProgressBar::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const TriggerScriptUIProto_ProgressBar*>(
      &from));
}

void TriggerScriptUIProto_ProgressBar::MergeFrom(const TriggerScriptUIProto_ProgressBar& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.TriggerScriptUIProto.ProgressBar)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  step_icons_.MergeFrom(from.step_icons_);
  if (from._internal_has_active_step()) {
    _internal_set_active_step(from._internal_active_step());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TriggerScriptUIProto_ProgressBar::CopyFrom(const TriggerScriptUIProto_ProgressBar& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.TriggerScriptUIProto.ProgressBar)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TriggerScriptUIProto_ProgressBar::IsInitialized() const {
  return true;
}

void TriggerScriptUIProto_ProgressBar::InternalSwap(TriggerScriptUIProto_ProgressBar* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  step_icons_.InternalSwap(&other->step_icons_);
  swap(active_step_, other->active_step_);
}

std::string TriggerScriptUIProto_ProgressBar::GetTypeName() const {
  return "autofill_assistant.TriggerScriptUIProto.ProgressBar";
}


// ===================================================================

class TriggerScriptUIProto_TriggerChip::_Internal {
 public:
  using HasBits = decltype(std::declval<TriggerScriptUIProto_TriggerChip>()._has_bits_);
  static const ::autofill_assistant::ChipProto& chip(const TriggerScriptUIProto_TriggerChip* msg);
  static void set_has_chip(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_action(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::autofill_assistant::ChipProto&
TriggerScriptUIProto_TriggerChip::_Internal::chip(const TriggerScriptUIProto_TriggerChip* msg) {
  return *msg->chip_;
}
void TriggerScriptUIProto_TriggerChip::clear_chip() {
  if (chip_ != nullptr) chip_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
TriggerScriptUIProto_TriggerChip::TriggerScriptUIProto_TriggerChip(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.TriggerScriptUIProto.TriggerChip)
}
TriggerScriptUIProto_TriggerChip::TriggerScriptUIProto_TriggerChip(const TriggerScriptUIProto_TriggerChip& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_chip()) {
    chip_ = new ::autofill_assistant::ChipProto(*from.chip_);
  } else {
    chip_ = nullptr;
  }
  action_ = from.action_;
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.TriggerScriptUIProto.TriggerChip)
}

inline void TriggerScriptUIProto_TriggerChip::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&chip_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&action_) -
    reinterpret_cast<char*>(&chip_)) + sizeof(action_));
}

TriggerScriptUIProto_TriggerChip::~TriggerScriptUIProto_TriggerChip() {
  // @@protoc_insertion_point(destructor:autofill_assistant.TriggerScriptUIProto.TriggerChip)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TriggerScriptUIProto_TriggerChip::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete chip_;
}

void TriggerScriptUIProto_TriggerChip::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void TriggerScriptUIProto_TriggerChip::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.TriggerScriptUIProto.TriggerChip)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(chip_ != nullptr);
    chip_->Clear();
  }
  action_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* TriggerScriptUIProto_TriggerChip::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .autofill_assistant.ChipProto chip = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_chip(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .autofill_assistant.TriggerScriptProto.TriggerScriptAction action = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::autofill_assistant::TriggerScriptProto_TriggerScriptAction_IsValid(val))) {
            _internal_set_action(static_cast<::autofill_assistant::TriggerScriptProto_TriggerScriptAction>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TriggerScriptUIProto_TriggerChip::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.TriggerScriptUIProto.TriggerChip)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .autofill_assistant.ChipProto chip = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::chip(this),
        _Internal::chip(this).GetCachedSize(), target, stream);
  }

  // optional .autofill_assistant.TriggerScriptProto.TriggerScriptAction action = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_action(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.TriggerScriptUIProto.TriggerChip)
  return target;
}

size_t TriggerScriptUIProto_TriggerChip::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.TriggerScriptUIProto.TriggerChip)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .autofill_assistant.ChipProto chip = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *chip_);
    }

    // optional .autofill_assistant.TriggerScriptProto.TriggerScriptAction action = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_action());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TriggerScriptUIProto_TriggerChip::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const TriggerScriptUIProto_TriggerChip*>(
      &from));
}

void TriggerScriptUIProto_TriggerChip::MergeFrom(const TriggerScriptUIProto_TriggerChip& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.TriggerScriptUIProto.TriggerChip)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_chip()->::autofill_assistant::ChipProto::MergeFrom(from._internal_chip());
    }
    if (cached_has_bits & 0x00000002u) {
      action_ = from.action_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TriggerScriptUIProto_TriggerChip::CopyFrom(const TriggerScriptUIProto_TriggerChip& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.TriggerScriptUIProto.TriggerChip)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TriggerScriptUIProto_TriggerChip::IsInitialized() const {
  return true;
}

void TriggerScriptUIProto_TriggerChip::InternalSwap(TriggerScriptUIProto_TriggerChip* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TriggerScriptUIProto_TriggerChip, action_)
      + sizeof(TriggerScriptUIProto_TriggerChip::action_)
      - PROTOBUF_FIELD_OFFSET(TriggerScriptUIProto_TriggerChip, chip_)>(
          reinterpret_cast<char*>(&chip_),
          reinterpret_cast<char*>(&other->chip_));
}

std::string TriggerScriptUIProto_TriggerChip::GetTypeName() const {
  return "autofill_assistant.TriggerScriptUIProto.TriggerChip";
}


// ===================================================================

class TriggerScriptUIProto_Popup_Choice::_Internal {
 public:
  using HasBits = decltype(std::declval<TriggerScriptUIProto_Popup_Choice>()._has_bits_);
  static void set_has_text(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_action(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

TriggerScriptUIProto_Popup_Choice::TriggerScriptUIProto_Popup_Choice(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.TriggerScriptUIProto.Popup.Choice)
}
TriggerScriptUIProto_Popup_Choice::TriggerScriptUIProto_Popup_Choice(const TriggerScriptUIProto_Popup_Choice& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  text_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    text_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_text()) {
    text_.Set(from._internal_text(), 
      GetArenaForAllocation());
  }
  action_ = from.action_;
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.TriggerScriptUIProto.Popup.Choice)
}

inline void TriggerScriptUIProto_Popup_Choice::SharedCtor() {
text_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  text_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
action_ = 0;
}

TriggerScriptUIProto_Popup_Choice::~TriggerScriptUIProto_Popup_Choice() {
  // @@protoc_insertion_point(destructor:autofill_assistant.TriggerScriptUIProto.Popup.Choice)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TriggerScriptUIProto_Popup_Choice::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  text_.Destroy();
}

void TriggerScriptUIProto_Popup_Choice::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void TriggerScriptUIProto_Popup_Choice::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.TriggerScriptUIProto.Popup.Choice)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    text_.ClearNonDefaultToEmpty();
  }
  action_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* TriggerScriptUIProto_Popup_Choice::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string text = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_text();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .autofill_assistant.TriggerScriptProto.TriggerScriptAction action = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::autofill_assistant::TriggerScriptProto_TriggerScriptAction_IsValid(val))) {
            _internal_set_action(static_cast<::autofill_assistant::TriggerScriptProto_TriggerScriptAction>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TriggerScriptUIProto_Popup_Choice::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.TriggerScriptUIProto.Popup.Choice)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string text = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_text(), target);
  }

  // optional .autofill_assistant.TriggerScriptProto.TriggerScriptAction action = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_action(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.TriggerScriptUIProto.Popup.Choice)
  return target;
}

size_t TriggerScriptUIProto_Popup_Choice::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.TriggerScriptUIProto.Popup.Choice)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string text = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_text());
    }

    // optional .autofill_assistant.TriggerScriptProto.TriggerScriptAction action = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_action());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TriggerScriptUIProto_Popup_Choice::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const TriggerScriptUIProto_Popup_Choice*>(
      &from));
}

void TriggerScriptUIProto_Popup_Choice::MergeFrom(const TriggerScriptUIProto_Popup_Choice& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.TriggerScriptUIProto.Popup.Choice)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_text(from._internal_text());
    }
    if (cached_has_bits & 0x00000002u) {
      action_ = from.action_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TriggerScriptUIProto_Popup_Choice::CopyFrom(const TriggerScriptUIProto_Popup_Choice& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.TriggerScriptUIProto.Popup.Choice)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TriggerScriptUIProto_Popup_Choice::IsInitialized() const {
  return true;
}

void TriggerScriptUIProto_Popup_Choice::InternalSwap(TriggerScriptUIProto_Popup_Choice* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &text_, lhs_arena,
      &other->text_, rhs_arena
  );
  swap(action_, other->action_);
}

std::string TriggerScriptUIProto_Popup_Choice::GetTypeName() const {
  return "autofill_assistant.TriggerScriptUIProto.Popup.Choice";
}


// ===================================================================

class TriggerScriptUIProto_Popup::_Internal {
 public:
};

TriggerScriptUIProto_Popup::TriggerScriptUIProto_Popup(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  choices_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.TriggerScriptUIProto.Popup)
}
TriggerScriptUIProto_Popup::TriggerScriptUIProto_Popup(const TriggerScriptUIProto_Popup& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      choices_(from.choices_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.TriggerScriptUIProto.Popup)
}

inline void TriggerScriptUIProto_Popup::SharedCtor() {
}

TriggerScriptUIProto_Popup::~TriggerScriptUIProto_Popup() {
  // @@protoc_insertion_point(destructor:autofill_assistant.TriggerScriptUIProto.Popup)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TriggerScriptUIProto_Popup::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void TriggerScriptUIProto_Popup::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void TriggerScriptUIProto_Popup::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.TriggerScriptUIProto.Popup)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  choices_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* TriggerScriptUIProto_Popup::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .autofill_assistant.TriggerScriptUIProto.Popup.Choice choices = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_choices(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TriggerScriptUIProto_Popup::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.TriggerScriptUIProto.Popup)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .autofill_assistant.TriggerScriptUIProto.Popup.Choice choices = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_choices_size()); i < n; i++) {
    const auto& repfield = this->_internal_choices(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.TriggerScriptUIProto.Popup)
  return target;
}

size_t TriggerScriptUIProto_Popup::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.TriggerScriptUIProto.Popup)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .autofill_assistant.TriggerScriptUIProto.Popup.Choice choices = 1;
  total_size += 1UL * this->_internal_choices_size();
  for (const auto& msg : this->choices_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TriggerScriptUIProto_Popup::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const TriggerScriptUIProto_Popup*>(
      &from));
}

void TriggerScriptUIProto_Popup::MergeFrom(const TriggerScriptUIProto_Popup& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.TriggerScriptUIProto.Popup)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  choices_.MergeFrom(from.choices_);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TriggerScriptUIProto_Popup::CopyFrom(const TriggerScriptUIProto_Popup& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.TriggerScriptUIProto.Popup)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TriggerScriptUIProto_Popup::IsInitialized() const {
  return true;
}

void TriggerScriptUIProto_Popup::InternalSwap(TriggerScriptUIProto_Popup* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  choices_.InternalSwap(&other->choices_);
}

std::string TriggerScriptUIProto_Popup::GetTypeName() const {
  return "autofill_assistant.TriggerScriptUIProto.Popup";
}


// ===================================================================

class TriggerScriptUIProto::_Internal {
 public:
  using HasBits = decltype(std::declval<TriggerScriptUIProto>()._has_bits_);
  static void set_has_status_message(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_callout_message(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::autofill_assistant::TriggerScriptUIProto_ProgressBar& progress_bar(const TriggerScriptUIProto* msg);
  static void set_has_progress_bar(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::autofill_assistant::TriggerScriptUIProto_Popup& cancel_popup(const TriggerScriptUIProto* msg);
  static void set_has_cancel_popup(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_regular_script_loading_status_message(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_resize_visual_viewport(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_scroll_to_hide(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_ui_timeout_ms(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
};

const ::autofill_assistant::TriggerScriptUIProto_ProgressBar&
TriggerScriptUIProto::_Internal::progress_bar(const TriggerScriptUIProto* msg) {
  return *msg->progress_bar_;
}
const ::autofill_assistant::TriggerScriptUIProto_Popup&
TriggerScriptUIProto::_Internal::cancel_popup(const TriggerScriptUIProto* msg) {
  return *msg->cancel_popup_;
}
TriggerScriptUIProto::TriggerScriptUIProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  left_aligned_chips_(arena),
  right_aligned_chips_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.TriggerScriptUIProto)
}
TriggerScriptUIProto::TriggerScriptUIProto(const TriggerScriptUIProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      left_aligned_chips_(from.left_aligned_chips_),
      right_aligned_chips_(from.right_aligned_chips_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  status_message_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    status_message_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_status_message()) {
    status_message_.Set(from._internal_status_message(), 
      GetArenaForAllocation());
  }
  callout_message_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    callout_message_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_callout_message()) {
    callout_message_.Set(from._internal_callout_message(), 
      GetArenaForAllocation());
  }
  regular_script_loading_status_message_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    regular_script_loading_status_message_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_regular_script_loading_status_message()) {
    regular_script_loading_status_message_.Set(from._internal_regular_script_loading_status_message(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_progress_bar()) {
    progress_bar_ = new ::autofill_assistant::TriggerScriptUIProto_ProgressBar(*from.progress_bar_);
  } else {
    progress_bar_ = nullptr;
  }
  if (from._internal_has_cancel_popup()) {
    cancel_popup_ = new ::autofill_assistant::TriggerScriptUIProto_Popup(*from.cancel_popup_);
  } else {
    cancel_popup_ = nullptr;
  }
  ::memcpy(&resize_visual_viewport_, &from.resize_visual_viewport_,
    static_cast<size_t>(reinterpret_cast<char*>(&ui_timeout_ms_) -
    reinterpret_cast<char*>(&resize_visual_viewport_)) + sizeof(ui_timeout_ms_));
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.TriggerScriptUIProto)
}

inline void TriggerScriptUIProto::SharedCtor() {
status_message_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  status_message_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
callout_message_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  callout_message_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
regular_script_loading_status_message_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  regular_script_loading_status_message_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&progress_bar_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&ui_timeout_ms_) -
    reinterpret_cast<char*>(&progress_bar_)) + sizeof(ui_timeout_ms_));
}

TriggerScriptUIProto::~TriggerScriptUIProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.TriggerScriptUIProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TriggerScriptUIProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  status_message_.Destroy();
  callout_message_.Destroy();
  regular_script_loading_status_message_.Destroy();
  if (this != internal_default_instance()) delete progress_bar_;
  if (this != internal_default_instance()) delete cancel_popup_;
}

void TriggerScriptUIProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void TriggerScriptUIProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.TriggerScriptUIProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  left_aligned_chips_.Clear();
  right_aligned_chips_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      status_message_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      callout_message_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      regular_script_loading_status_message_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(progress_bar_ != nullptr);
      progress_bar_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(cancel_popup_ != nullptr);
      cancel_popup_->Clear();
    }
  }
  if (cached_has_bits & 0x000000e0u) {
    ::memset(&resize_visual_viewport_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&ui_timeout_ms_) -
        reinterpret_cast<char*>(&resize_visual_viewport_)) + sizeof(ui_timeout_ms_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* TriggerScriptUIProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string status_message = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_status_message();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string callout_message = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_callout_message();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .autofill_assistant.TriggerScriptUIProto.ProgressBar progress_bar = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_progress_bar(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .autofill_assistant.TriggerScriptUIProto.Popup cancel_popup = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_cancel_popup(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .autofill_assistant.TriggerScriptUIProto.TriggerChip left_aligned_chips = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_left_aligned_chips(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .autofill_assistant.TriggerScriptUIProto.TriggerChip right_aligned_chips = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_right_aligned_chips(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional string regular_script_loading_status_message = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_regular_script_loading_status_message();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool resize_visual_viewport = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_resize_visual_viewport(&has_bits);
          resize_visual_viewport_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool scroll_to_hide = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_scroll_to_hide(&has_bits);
          scroll_to_hide_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 ui_timeout_ms = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_ui_timeout_ms(&has_bits);
          ui_timeout_ms_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TriggerScriptUIProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.TriggerScriptUIProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string status_message = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_status_message(), target);
  }

  // optional string callout_message = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_callout_message(), target);
  }

  // optional .autofill_assistant.TriggerScriptUIProto.ProgressBar progress_bar = 3;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::progress_bar(this),
        _Internal::progress_bar(this).GetCachedSize(), target, stream);
  }

  // optional .autofill_assistant.TriggerScriptUIProto.Popup cancel_popup = 4;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::cancel_popup(this),
        _Internal::cancel_popup(this).GetCachedSize(), target, stream);
  }

  // repeated .autofill_assistant.TriggerScriptUIProto.TriggerChip left_aligned_chips = 5;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_left_aligned_chips_size()); i < n; i++) {
    const auto& repfield = this->_internal_left_aligned_chips(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(5, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .autofill_assistant.TriggerScriptUIProto.TriggerChip right_aligned_chips = 6;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_right_aligned_chips_size()); i < n; i++) {
    const auto& repfield = this->_internal_right_aligned_chips(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(6, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional string regular_script_loading_status_message = 7;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteStringMaybeAliased(
        7, this->_internal_regular_script_loading_status_message(), target);
  }

  // optional bool resize_visual_viewport = 8;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(8, this->_internal_resize_visual_viewport(), target);
  }

  // optional bool scroll_to_hide = 9;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(9, this->_internal_scroll_to_hide(), target);
  }

  // optional int32 ui_timeout_ms = 10;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(10, this->_internal_ui_timeout_ms(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.TriggerScriptUIProto)
  return target;
}

size_t TriggerScriptUIProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.TriggerScriptUIProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .autofill_assistant.TriggerScriptUIProto.TriggerChip left_aligned_chips = 5;
  total_size += 1UL * this->_internal_left_aligned_chips_size();
  for (const auto& msg : this->left_aligned_chips_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .autofill_assistant.TriggerScriptUIProto.TriggerChip right_aligned_chips = 6;
  total_size += 1UL * this->_internal_right_aligned_chips_size();
  for (const auto& msg : this->right_aligned_chips_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string status_message = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_status_message());
    }

    // optional string callout_message = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_callout_message());
    }

    // optional string regular_script_loading_status_message = 7;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_regular_script_loading_status_message());
    }

    // optional .autofill_assistant.TriggerScriptUIProto.ProgressBar progress_bar = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *progress_bar_);
    }

    // optional .autofill_assistant.TriggerScriptUIProto.Popup cancel_popup = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *cancel_popup_);
    }

    // optional bool resize_visual_viewport = 8;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 1;
    }

    // optional bool scroll_to_hide = 9;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 1;
    }

    // optional int32 ui_timeout_ms = 10;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_ui_timeout_ms());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TriggerScriptUIProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const TriggerScriptUIProto*>(
      &from));
}

void TriggerScriptUIProto::MergeFrom(const TriggerScriptUIProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.TriggerScriptUIProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  left_aligned_chips_.MergeFrom(from.left_aligned_chips_);
  right_aligned_chips_.MergeFrom(from.right_aligned_chips_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_status_message(from._internal_status_message());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_callout_message(from._internal_callout_message());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_regular_script_loading_status_message(from._internal_regular_script_loading_status_message());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_mutable_progress_bar()->::autofill_assistant::TriggerScriptUIProto_ProgressBar::MergeFrom(from._internal_progress_bar());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_mutable_cancel_popup()->::autofill_assistant::TriggerScriptUIProto_Popup::MergeFrom(from._internal_cancel_popup());
    }
    if (cached_has_bits & 0x00000020u) {
      resize_visual_viewport_ = from.resize_visual_viewport_;
    }
    if (cached_has_bits & 0x00000040u) {
      scroll_to_hide_ = from.scroll_to_hide_;
    }
    if (cached_has_bits & 0x00000080u) {
      ui_timeout_ms_ = from.ui_timeout_ms_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TriggerScriptUIProto::CopyFrom(const TriggerScriptUIProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.TriggerScriptUIProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TriggerScriptUIProto::IsInitialized() const {
  return true;
}

void TriggerScriptUIProto::InternalSwap(TriggerScriptUIProto* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  left_aligned_chips_.InternalSwap(&other->left_aligned_chips_);
  right_aligned_chips_.InternalSwap(&other->right_aligned_chips_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &status_message_, lhs_arena,
      &other->status_message_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &callout_message_, lhs_arena,
      &other->callout_message_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &regular_script_loading_status_message_, lhs_arena,
      &other->regular_script_loading_status_message_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TriggerScriptUIProto, ui_timeout_ms_)
      + sizeof(TriggerScriptUIProto::ui_timeout_ms_)
      - PROTOBUF_FIELD_OFFSET(TriggerScriptUIProto, progress_bar_)>(
          reinterpret_cast<char*>(&progress_bar_),
          reinterpret_cast<char*>(&other->progress_bar_));
}

std::string TriggerScriptUIProto::GetTypeName() const {
  return "autofill_assistant.TriggerScriptUIProto";
}


// ===================================================================

class ActionProto::_Internal {
 public:
  using HasBits = decltype(std::declval<ActionProto>()._has_bits_);
  static void set_has_action_delay_ms(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_server_payload(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::autofill_assistant::SelectOptionProto& select_option(const ActionProto* msg);
  static const ::autofill_assistant::NavigateProto& navigate(const ActionProto* msg);
  static const ::autofill_assistant::PromptProto& prompt(const ActionProto* msg);
  static const ::autofill_assistant::TellProto& tell(const ActionProto* msg);
  static const ::autofill_assistant::ShowCastProto& show_cast(const ActionProto* msg);
  static const ::autofill_assistant::WaitForDomProto& wait_for_dom(const ActionProto* msg);
  static const ::autofill_assistant::UseCreditCardProto& use_card(const ActionProto* msg);
  static const ::autofill_assistant::UseAddressProto& use_address(const ActionProto* msg);
  static const ::autofill_assistant::UploadDomProto& upload_dom(const ActionProto* msg);
  static const ::autofill_assistant::ShowProgressBarProto& show_progress_bar(const ActionProto* msg);
  static const ::autofill_assistant::ShowDetailsProto& show_details(const ActionProto* msg);
  static const ::autofill_assistant::StopProto& stop(const ActionProto* msg);
  static const ::autofill_assistant::CollectUserDataProto& collect_user_data(const ActionProto* msg);
  static const ::autofill_assistant::SetAttributeProto& set_attribute(const ActionProto* msg);
  static const ::autofill_assistant::ShowInfoBoxProto& show_info_box(const ActionProto* msg);
  static const ::autofill_assistant::ExpectNavigationProto& expect_navigation(const ActionProto* msg);
  static const ::autofill_assistant::WaitForNavigationProto& wait_for_navigation(const ActionProto* msg);
  static const ::autofill_assistant::ConfigureBottomSheetProto& configure_bottom_sheet(const ActionProto* msg);
  static const ::autofill_assistant::ShowFormProto& show_form(const ActionProto* msg);
  static const ::autofill_assistant::PopupMessageProto& popup_message(const ActionProto* msg);
  static const ::autofill_assistant::WaitForDocumentProto& wait_for_document(const ActionProto* msg);
  static const ::autofill_assistant::ShowGenericUiProto& show_generic_ui(const ActionProto* msg);
  static const ::autofill_assistant::GeneratePasswordForFormFieldProto& generate_password_for_form_field(const ActionProto* msg);
  static const ::autofill_assistant::SaveGeneratedPasswordProto& save_generated_password(const ActionProto* msg);
  static const ::autofill_assistant::ConfigureUiStateProto& configure_ui_state(const ActionProto* msg);
  static const ::autofill_assistant::PresaveGeneratedPasswordProto& presave_generated_password(const ActionProto* msg);
  static const ::autofill_assistant::GetElementStatusProto& get_element_status(const ActionProto* msg);
  static const ::autofill_assistant::ScrollIntoViewProto& scroll_into_view(const ActionProto* msg);
  static const ::autofill_assistant::WaitForDocumentToBecomeInteractiveProto& wait_for_document_to_become_interactive(const ActionProto* msg);
  static const ::autofill_assistant::WaitForDocumentToBecomeCompleteProto& wait_for_document_to_become_complete(const ActionProto* msg);
  static const ::autofill_assistant::SendClickEventProto& send_click_event(const ActionProto* msg);
  static const ::autofill_assistant::SendTapEventProto& send_tap_event(const ActionProto* msg);
  static const ::autofill_assistant::JsClickProto& js_click(const ActionProto* msg);
  static const ::autofill_assistant::SendKeystrokeEventsProto& send_keystroke_events(const ActionProto* msg);
  static const ::autofill_assistant::SendChangeEventProto& send_change_event(const ActionProto* msg);
  static const ::autofill_assistant::SetElementAttributeProto& set_element_attribute(const ActionProto* msg);
  static const ::autofill_assistant::SelectFieldValueProto& select_field_value(const ActionProto* msg);
  static const ::autofill_assistant::FocusFieldProto& focus_field(const ActionProto* msg);
  static const ::autofill_assistant::WaitForElementToBecomeStableProto& wait_for_element_to_become_stable(const ActionProto* msg);
  static const ::autofill_assistant::CheckElementIsOnTopProto& check_element_is_on_top(const ActionProto* msg);
  static const ::autofill_assistant::ReleaseElementsProto& release_elements(const ActionProto* msg);
  static const ::autofill_assistant::DispatchJsEventProto& dispatch_js_event(const ActionProto* msg);
  static const ::autofill_assistant::SendKeyEventProto& send_key_event(const ActionProto* msg);
  static const ::autofill_assistant::SelectOptionElementProto& select_option_element(const ActionProto* msg);
  static const ::autofill_assistant::CheckElementTagProto& check_element_tag(const ActionProto* msg);
  static const ::autofill_assistant::CheckOptionElementProto& check_option_element(const ActionProto* msg);
  static const ::autofill_assistant::SetPersistentUiProto& set_persistent_ui(const ActionProto* msg);
  static const ::autofill_assistant::ClearPersistentUiProto& clear_persistent_ui(const ActionProto* msg);
  static const ::autofill_assistant::ScrollIntoViewIfNeededProto& scroll_into_view_if_needed(const ActionProto* msg);
  static const ::autofill_assistant::ScrollWindowProto& scroll_window(const ActionProto* msg);
  static const ::autofill_assistant::ScrollContainerProto& scroll_container(const ActionProto* msg);
  static const ::autofill_assistant::SetTouchableAreaProto& set_touchable_area(const ActionProto* msg);
  static const ::autofill_assistant::DeleteSelectedPasswordProto& delete_password(const ActionProto* msg);
  static const ::autofill_assistant::EditSelectedPasswordProto& edit_password(const ActionProto* msg);
  static const ::autofill_assistant::BlurFieldProto& blur_field(const ActionProto* msg);
  static const ::autofill_assistant::ResetPendingCredentialsProto& reset_pending_credentials(const ActionProto* msg);
  static const ::autofill_assistant::SaveSubmittedPasswordProto& save_submitted_password(const ActionProto* msg);
  static const ::autofill_assistant::UpdateClientSettingsProto& update_client_settings(const ActionProto* msg);
  static const ::autofill_assistant::JsFlowProto& js_flow(const ActionProto* msg);
  static const ::autofill_assistant::ExecuteJsProto& execute_js(const ActionProto* msg);
  static const ::autofill_assistant::RegisterPasswordResetRequestProto& register_password_reset_request(const ActionProto* msg);
  static const ::autofill_assistant::ExternalActionProto& external_action(const ActionProto* msg);
  static const ::autofill_assistant::SetNativeValueProto& set_native_value(const ActionProto* msg);
  static const ::autofill_assistant::SetNativeCheckedProto& set_native_checked(const ActionProto* msg);
  static const ::autofill_assistant::PromptQrCodeScanProto& prompt_qr_code_scan(const ActionProto* msg);
  static void set_has_clean_contextual_ui(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::autofill_assistant::SelectOptionProto&
ActionProto::_Internal::select_option(const ActionProto* msg) {
  return *msg->action_info_.select_option_;
}
const ::autofill_assistant::NavigateProto&
ActionProto::_Internal::navigate(const ActionProto* msg) {
  return *msg->action_info_.navigate_;
}
const ::autofill_assistant::PromptProto&
ActionProto::_Internal::prompt(const ActionProto* msg) {
  return *msg->action_info_.prompt_;
}
const ::autofill_assistant::TellProto&
ActionProto::_Internal::tell(const ActionProto* msg) {
  return *msg->action_info_.tell_;
}
const ::autofill_assistant::ShowCastProto&
ActionProto::_Internal::show_cast(const ActionProto* msg) {
  return *msg->action_info_.show_cast_;
}
const ::autofill_assistant::WaitForDomProto&
ActionProto::_Internal::wait_for_dom(const ActionProto* msg) {
  return *msg->action_info_.wait_for_dom_;
}
const ::autofill_assistant::UseCreditCardProto&
ActionProto::_Internal::use_card(const ActionProto* msg) {
  return *msg->action_info_.use_card_;
}
const ::autofill_assistant::UseAddressProto&
ActionProto::_Internal::use_address(const ActionProto* msg) {
  return *msg->action_info_.use_address_;
}
const ::autofill_assistant::UploadDomProto&
ActionProto::_Internal::upload_dom(const ActionProto* msg) {
  return *msg->action_info_.upload_dom_;
}
const ::autofill_assistant::ShowProgressBarProto&
ActionProto::_Internal::show_progress_bar(const ActionProto* msg) {
  return *msg->action_info_.show_progress_bar_;
}
const ::autofill_assistant::ShowDetailsProto&
ActionProto::_Internal::show_details(const ActionProto* msg) {
  return *msg->action_info_.show_details_;
}
const ::autofill_assistant::StopProto&
ActionProto::_Internal::stop(const ActionProto* msg) {
  return *msg->action_info_.stop_;
}
const ::autofill_assistant::CollectUserDataProto&
ActionProto::_Internal::collect_user_data(const ActionProto* msg) {
  return *msg->action_info_.collect_user_data_;
}
const ::autofill_assistant::SetAttributeProto&
ActionProto::_Internal::set_attribute(const ActionProto* msg) {
  return *msg->action_info_.set_attribute_;
}
const ::autofill_assistant::ShowInfoBoxProto&
ActionProto::_Internal::show_info_box(const ActionProto* msg) {
  return *msg->action_info_.show_info_box_;
}
const ::autofill_assistant::ExpectNavigationProto&
ActionProto::_Internal::expect_navigation(const ActionProto* msg) {
  return *msg->action_info_.expect_navigation_;
}
const ::autofill_assistant::WaitForNavigationProto&
ActionProto::_Internal::wait_for_navigation(const ActionProto* msg) {
  return *msg->action_info_.wait_for_navigation_;
}
const ::autofill_assistant::ConfigureBottomSheetProto&
ActionProto::_Internal::configure_bottom_sheet(const ActionProto* msg) {
  return *msg->action_info_.configure_bottom_sheet_;
}
const ::autofill_assistant::ShowFormProto&
ActionProto::_Internal::show_form(const ActionProto* msg) {
  return *msg->action_info_.show_form_;
}
const ::autofill_assistant::PopupMessageProto&
ActionProto::_Internal::popup_message(const ActionProto* msg) {
  return *msg->action_info_.popup_message_;
}
const ::autofill_assistant::WaitForDocumentProto&
ActionProto::_Internal::wait_for_document(const ActionProto* msg) {
  return *msg->action_info_.wait_for_document_;
}
const ::autofill_assistant::ShowGenericUiProto&
ActionProto::_Internal::show_generic_ui(const ActionProto* msg) {
  return *msg->action_info_.show_generic_ui_;
}
const ::autofill_assistant::GeneratePasswordForFormFieldProto&
ActionProto::_Internal::generate_password_for_form_field(const ActionProto* msg) {
  return *msg->action_info_.generate_password_for_form_field_;
}
const ::autofill_assistant::SaveGeneratedPasswordProto&
ActionProto::_Internal::save_generated_password(const ActionProto* msg) {
  return *msg->action_info_.save_generated_password_;
}
const ::autofill_assistant::ConfigureUiStateProto&
ActionProto::_Internal::configure_ui_state(const ActionProto* msg) {
  return *msg->action_info_.configure_ui_state_;
}
const ::autofill_assistant::PresaveGeneratedPasswordProto&
ActionProto::_Internal::presave_generated_password(const ActionProto* msg) {
  return *msg->action_info_.presave_generated_password_;
}
const ::autofill_assistant::GetElementStatusProto&
ActionProto::_Internal::get_element_status(const ActionProto* msg) {
  return *msg->action_info_.get_element_status_;
}
const ::autofill_assistant::ScrollIntoViewProto&
ActionProto::_Internal::scroll_into_view(const ActionProto* msg) {
  return *msg->action_info_.scroll_into_view_;
}
const ::autofill_assistant::WaitForDocumentToBecomeInteractiveProto&
ActionProto::_Internal::wait_for_document_to_become_interactive(const ActionProto* msg) {
  return *msg->action_info_.wait_for_document_to_become_interactive_;
}
const ::autofill_assistant::WaitForDocumentToBecomeCompleteProto&
ActionProto::_Internal::wait_for_document_to_become_complete(const ActionProto* msg) {
  return *msg->action_info_.wait_for_document_to_become_complete_;
}
const ::autofill_assistant::SendClickEventProto&
ActionProto::_Internal::send_click_event(const ActionProto* msg) {
  return *msg->action_info_.send_click_event_;
}
const ::autofill_assistant::SendTapEventProto&
ActionProto::_Internal::send_tap_event(const ActionProto* msg) {
  return *msg->action_info_.send_tap_event_;
}
const ::autofill_assistant::JsClickProto&
ActionProto::_Internal::js_click(const ActionProto* msg) {
  return *msg->action_info_.js_click_;
}
const ::autofill_assistant::SendKeystrokeEventsProto&
ActionProto::_Internal::send_keystroke_events(const ActionProto* msg) {
  return *msg->action_info_.send_keystroke_events_;
}
const ::autofill_assistant::SendChangeEventProto&
ActionProto::_Internal::send_change_event(const ActionProto* msg) {
  return *msg->action_info_.send_change_event_;
}
const ::autofill_assistant::SetElementAttributeProto&
ActionProto::_Internal::set_element_attribute(const ActionProto* msg) {
  return *msg->action_info_.set_element_attribute_;
}
const ::autofill_assistant::SelectFieldValueProto&
ActionProto::_Internal::select_field_value(const ActionProto* msg) {
  return *msg->action_info_.select_field_value_;
}
const ::autofill_assistant::FocusFieldProto&
ActionProto::_Internal::focus_field(const ActionProto* msg) {
  return *msg->action_info_.focus_field_;
}
const ::autofill_assistant::WaitForElementToBecomeStableProto&
ActionProto::_Internal::wait_for_element_to_become_stable(const ActionProto* msg) {
  return *msg->action_info_.wait_for_element_to_become_stable_;
}
const ::autofill_assistant::CheckElementIsOnTopProto&
ActionProto::_Internal::check_element_is_on_top(const ActionProto* msg) {
  return *msg->action_info_.check_element_is_on_top_;
}
const ::autofill_assistant::ReleaseElementsProto&
ActionProto::_Internal::release_elements(const ActionProto* msg) {
  return *msg->action_info_.release_elements_;
}
const ::autofill_assistant::DispatchJsEventProto&
ActionProto::_Internal::dispatch_js_event(const ActionProto* msg) {
  return *msg->action_info_.dispatch_js_event_;
}
const ::autofill_assistant::SendKeyEventProto&
ActionProto::_Internal::send_key_event(const ActionProto* msg) {
  return *msg->action_info_.send_key_event_;
}
const ::autofill_assistant::SelectOptionElementProto&
ActionProto::_Internal::select_option_element(const ActionProto* msg) {
  return *msg->action_info_.select_option_element_;
}
const ::autofill_assistant::CheckElementTagProto&
ActionProto::_Internal::check_element_tag(const ActionProto* msg) {
  return *msg->action_info_.check_element_tag_;
}
const ::autofill_assistant::CheckOptionElementProto&
ActionProto::_Internal::check_option_element(const ActionProto* msg) {
  return *msg->action_info_.check_option_element_;
}
const ::autofill_assistant::SetPersistentUiProto&
ActionProto::_Internal::set_persistent_ui(const ActionProto* msg) {
  return *msg->action_info_.set_persistent_ui_;
}
const ::autofill_assistant::ClearPersistentUiProto&
ActionProto::_Internal::clear_persistent_ui(const ActionProto* msg) {
  return *msg->action_info_.clear_persistent_ui_;
}
const ::autofill_assistant::ScrollIntoViewIfNeededProto&
ActionProto::_Internal::scroll_into_view_if_needed(const ActionProto* msg) {
  return *msg->action_info_.scroll_into_view_if_needed_;
}
const ::autofill_assistant::ScrollWindowProto&
ActionProto::_Internal::scroll_window(const ActionProto* msg) {
  return *msg->action_info_.scroll_window_;
}
const ::autofill_assistant::ScrollContainerProto&
ActionProto::_Internal::scroll_container(const ActionProto* msg) {
  return *msg->action_info_.scroll_container_;
}
const ::autofill_assistant::SetTouchableAreaProto&
ActionProto::_Internal::set_touchable_area(const ActionProto* msg) {
  return *msg->action_info_.set_touchable_area_;
}
const ::autofill_assistant::DeleteSelectedPasswordProto&
ActionProto::_Internal::delete_password(const ActionProto* msg) {
  return *msg->action_info_.delete_password_;
}
const ::autofill_assistant::EditSelectedPasswordProto&
ActionProto::_Internal::edit_password(const ActionProto* msg) {
  return *msg->action_info_.edit_password_;
}
const ::autofill_assistant::BlurFieldProto&
ActionProto::_Internal::blur_field(const ActionProto* msg) {
  return *msg->action_info_.blur_field_;
}
const ::autofill_assistant::ResetPendingCredentialsProto&
ActionProto::_Internal::reset_pending_credentials(const ActionProto* msg) {
  return *msg->action_info_.reset_pending_credentials_;
}
const ::autofill_assistant::SaveSubmittedPasswordProto&
ActionProto::_Internal::save_submitted_password(const ActionProto* msg) {
  return *msg->action_info_.save_submitted_password_;
}
const ::autofill_assistant::UpdateClientSettingsProto&
ActionProto::_Internal::update_client_settings(const ActionProto* msg) {
  return *msg->action_info_.update_client_settings_;
}
const ::autofill_assistant::JsFlowProto&
ActionProto::_Internal::js_flow(const ActionProto* msg) {
  return *msg->action_info_.js_flow_;
}
const ::autofill_assistant::ExecuteJsProto&
ActionProto::_Internal::execute_js(const ActionProto* msg) {
  return *msg->action_info_.execute_js_;
}
const ::autofill_assistant::RegisterPasswordResetRequestProto&
ActionProto::_Internal::register_password_reset_request(const ActionProto* msg) {
  return *msg->action_info_.register_password_reset_request_;
}
const ::autofill_assistant::ExternalActionProto&
ActionProto::_Internal::external_action(const ActionProto* msg) {
  return *msg->action_info_.external_action_;
}
const ::autofill_assistant::SetNativeValueProto&
ActionProto::_Internal::set_native_value(const ActionProto* msg) {
  return *msg->action_info_.set_native_value_;
}
const ::autofill_assistant::SetNativeCheckedProto&
ActionProto::_Internal::set_native_checked(const ActionProto* msg) {
  return *msg->action_info_.set_native_checked_;
}
const ::autofill_assistant::PromptQrCodeScanProto&
ActionProto::_Internal::prompt_qr_code_scan(const ActionProto* msg) {
  return *msg->action_info_.prompt_qr_code_scan_;
}
void ActionProto::set_allocated_select_option(::autofill_assistant::SelectOptionProto* select_option) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action_info();
  if (select_option) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(select_option);
    if (message_arena != submessage_arena) {
      select_option = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, select_option, submessage_arena);
    }
    set_has_select_option();
    action_info_.select_option_ = select_option;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ActionProto.select_option)
}
void ActionProto::set_allocated_navigate(::autofill_assistant::NavigateProto* navigate) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action_info();
  if (navigate) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(navigate);
    if (message_arena != submessage_arena) {
      navigate = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, navigate, submessage_arena);
    }
    set_has_navigate();
    action_info_.navigate_ = navigate;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ActionProto.navigate)
}
void ActionProto::set_allocated_prompt(::autofill_assistant::PromptProto* prompt) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action_info();
  if (prompt) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(prompt);
    if (message_arena != submessage_arena) {
      prompt = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, prompt, submessage_arena);
    }
    set_has_prompt();
    action_info_.prompt_ = prompt;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ActionProto.prompt)
}
void ActionProto::set_allocated_tell(::autofill_assistant::TellProto* tell) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action_info();
  if (tell) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(tell);
    if (message_arena != submessage_arena) {
      tell = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tell, submessage_arena);
    }
    set_has_tell();
    action_info_.tell_ = tell;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ActionProto.tell)
}
void ActionProto::set_allocated_show_cast(::autofill_assistant::ShowCastProto* show_cast) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action_info();
  if (show_cast) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(show_cast);
    if (message_arena != submessage_arena) {
      show_cast = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, show_cast, submessage_arena);
    }
    set_has_show_cast();
    action_info_.show_cast_ = show_cast;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ActionProto.show_cast)
}
void ActionProto::set_allocated_wait_for_dom(::autofill_assistant::WaitForDomProto* wait_for_dom) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action_info();
  if (wait_for_dom) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(wait_for_dom);
    if (message_arena != submessage_arena) {
      wait_for_dom = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, wait_for_dom, submessage_arena);
    }
    set_has_wait_for_dom();
    action_info_.wait_for_dom_ = wait_for_dom;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ActionProto.wait_for_dom)
}
void ActionProto::set_allocated_use_card(::autofill_assistant::UseCreditCardProto* use_card) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action_info();
  if (use_card) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(use_card);
    if (message_arena != submessage_arena) {
      use_card = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, use_card, submessage_arena);
    }
    set_has_use_card();
    action_info_.use_card_ = use_card;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ActionProto.use_card)
}
void ActionProto::set_allocated_use_address(::autofill_assistant::UseAddressProto* use_address) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action_info();
  if (use_address) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(use_address);
    if (message_arena != submessage_arena) {
      use_address = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, use_address, submessage_arena);
    }
    set_has_use_address();
    action_info_.use_address_ = use_address;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ActionProto.use_address)
}
void ActionProto::set_allocated_upload_dom(::autofill_assistant::UploadDomProto* upload_dom) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action_info();
  if (upload_dom) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(upload_dom);
    if (message_arena != submessage_arena) {
      upload_dom = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, upload_dom, submessage_arena);
    }
    set_has_upload_dom();
    action_info_.upload_dom_ = upload_dom;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ActionProto.upload_dom)
}
void ActionProto::set_allocated_show_progress_bar(::autofill_assistant::ShowProgressBarProto* show_progress_bar) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action_info();
  if (show_progress_bar) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(show_progress_bar);
    if (message_arena != submessage_arena) {
      show_progress_bar = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, show_progress_bar, submessage_arena);
    }
    set_has_show_progress_bar();
    action_info_.show_progress_bar_ = show_progress_bar;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ActionProto.show_progress_bar)
}
void ActionProto::set_allocated_show_details(::autofill_assistant::ShowDetailsProto* show_details) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action_info();
  if (show_details) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(show_details);
    if (message_arena != submessage_arena) {
      show_details = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, show_details, submessage_arena);
    }
    set_has_show_details();
    action_info_.show_details_ = show_details;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ActionProto.show_details)
}
void ActionProto::set_allocated_stop(::autofill_assistant::StopProto* stop) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action_info();
  if (stop) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(stop);
    if (message_arena != submessage_arena) {
      stop = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stop, submessage_arena);
    }
    set_has_stop();
    action_info_.stop_ = stop;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ActionProto.stop)
}
void ActionProto::set_allocated_collect_user_data(::autofill_assistant::CollectUserDataProto* collect_user_data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action_info();
  if (collect_user_data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(collect_user_data);
    if (message_arena != submessage_arena) {
      collect_user_data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, collect_user_data, submessage_arena);
    }
    set_has_collect_user_data();
    action_info_.collect_user_data_ = collect_user_data;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ActionProto.collect_user_data)
}
void ActionProto::set_allocated_set_attribute(::autofill_assistant::SetAttributeProto* set_attribute) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action_info();
  if (set_attribute) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(set_attribute);
    if (message_arena != submessage_arena) {
      set_attribute = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, set_attribute, submessage_arena);
    }
    set_has_set_attribute();
    action_info_.set_attribute_ = set_attribute;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ActionProto.set_attribute)
}
void ActionProto::set_allocated_show_info_box(::autofill_assistant::ShowInfoBoxProto* show_info_box) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action_info();
  if (show_info_box) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(show_info_box);
    if (message_arena != submessage_arena) {
      show_info_box = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, show_info_box, submessage_arena);
    }
    set_has_show_info_box();
    action_info_.show_info_box_ = show_info_box;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ActionProto.show_info_box)
}
void ActionProto::set_allocated_expect_navigation(::autofill_assistant::ExpectNavigationProto* expect_navigation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action_info();
  if (expect_navigation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(expect_navigation);
    if (message_arena != submessage_arena) {
      expect_navigation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, expect_navigation, submessage_arena);
    }
    set_has_expect_navigation();
    action_info_.expect_navigation_ = expect_navigation;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ActionProto.expect_navigation)
}
void ActionProto::set_allocated_wait_for_navigation(::autofill_assistant::WaitForNavigationProto* wait_for_navigation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action_info();
  if (wait_for_navigation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(wait_for_navigation);
    if (message_arena != submessage_arena) {
      wait_for_navigation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, wait_for_navigation, submessage_arena);
    }
    set_has_wait_for_navigation();
    action_info_.wait_for_navigation_ = wait_for_navigation;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ActionProto.wait_for_navigation)
}
void ActionProto::set_allocated_configure_bottom_sheet(::autofill_assistant::ConfigureBottomSheetProto* configure_bottom_sheet) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action_info();
  if (configure_bottom_sheet) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(configure_bottom_sheet);
    if (message_arena != submessage_arena) {
      configure_bottom_sheet = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, configure_bottom_sheet, submessage_arena);
    }
    set_has_configure_bottom_sheet();
    action_info_.configure_bottom_sheet_ = configure_bottom_sheet;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ActionProto.configure_bottom_sheet)
}
void ActionProto::set_allocated_show_form(::autofill_assistant::ShowFormProto* show_form) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action_info();
  if (show_form) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(show_form);
    if (message_arena != submessage_arena) {
      show_form = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, show_form, submessage_arena);
    }
    set_has_show_form();
    action_info_.show_form_ = show_form;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ActionProto.show_form)
}
void ActionProto::set_allocated_popup_message(::autofill_assistant::PopupMessageProto* popup_message) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action_info();
  if (popup_message) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(popup_message);
    if (message_arena != submessage_arena) {
      popup_message = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, popup_message, submessage_arena);
    }
    set_has_popup_message();
    action_info_.popup_message_ = popup_message;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ActionProto.popup_message)
}
void ActionProto::set_allocated_wait_for_document(::autofill_assistant::WaitForDocumentProto* wait_for_document) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action_info();
  if (wait_for_document) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(wait_for_document);
    if (message_arena != submessage_arena) {
      wait_for_document = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, wait_for_document, submessage_arena);
    }
    set_has_wait_for_document();
    action_info_.wait_for_document_ = wait_for_document;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ActionProto.wait_for_document)
}
void ActionProto::set_allocated_show_generic_ui(::autofill_assistant::ShowGenericUiProto* show_generic_ui) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action_info();
  if (show_generic_ui) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(show_generic_ui);
    if (message_arena != submessage_arena) {
      show_generic_ui = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, show_generic_ui, submessage_arena);
    }
    set_has_show_generic_ui();
    action_info_.show_generic_ui_ = show_generic_ui;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ActionProto.show_generic_ui)
}
void ActionProto::set_allocated_generate_password_for_form_field(::autofill_assistant::GeneratePasswordForFormFieldProto* generate_password_for_form_field) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action_info();
  if (generate_password_for_form_field) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(generate_password_for_form_field);
    if (message_arena != submessage_arena) {
      generate_password_for_form_field = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, generate_password_for_form_field, submessage_arena);
    }
    set_has_generate_password_for_form_field();
    action_info_.generate_password_for_form_field_ = generate_password_for_form_field;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ActionProto.generate_password_for_form_field)
}
void ActionProto::set_allocated_save_generated_password(::autofill_assistant::SaveGeneratedPasswordProto* save_generated_password) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action_info();
  if (save_generated_password) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(save_generated_password);
    if (message_arena != submessage_arena) {
      save_generated_password = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, save_generated_password, submessage_arena);
    }
    set_has_save_generated_password();
    action_info_.save_generated_password_ = save_generated_password;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ActionProto.save_generated_password)
}
void ActionProto::set_allocated_configure_ui_state(::autofill_assistant::ConfigureUiStateProto* configure_ui_state) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action_info();
  if (configure_ui_state) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(configure_ui_state);
    if (message_arena != submessage_arena) {
      configure_ui_state = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, configure_ui_state, submessage_arena);
    }
    set_has_configure_ui_state();
    action_info_.configure_ui_state_ = configure_ui_state;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ActionProto.configure_ui_state)
}
void ActionProto::set_allocated_presave_generated_password(::autofill_assistant::PresaveGeneratedPasswordProto* presave_generated_password) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action_info();
  if (presave_generated_password) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(presave_generated_password);
    if (message_arena != submessage_arena) {
      presave_generated_password = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, presave_generated_password, submessage_arena);
    }
    set_has_presave_generated_password();
    action_info_.presave_generated_password_ = presave_generated_password;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ActionProto.presave_generated_password)
}
void ActionProto::set_allocated_get_element_status(::autofill_assistant::GetElementStatusProto* get_element_status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action_info();
  if (get_element_status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(get_element_status);
    if (message_arena != submessage_arena) {
      get_element_status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, get_element_status, submessage_arena);
    }
    set_has_get_element_status();
    action_info_.get_element_status_ = get_element_status;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ActionProto.get_element_status)
}
void ActionProto::set_allocated_scroll_into_view(::autofill_assistant::ScrollIntoViewProto* scroll_into_view) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action_info();
  if (scroll_into_view) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(scroll_into_view));
    if (message_arena != submessage_arena) {
      scroll_into_view = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, scroll_into_view, submessage_arena);
    }
    set_has_scroll_into_view();
    action_info_.scroll_into_view_ = scroll_into_view;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ActionProto.scroll_into_view)
}
void ActionProto::clear_scroll_into_view() {
  if (_internal_has_scroll_into_view()) {
    if (GetArenaForAllocation() == nullptr) {
      delete action_info_.scroll_into_view_;
    }
    clear_has_action_info();
  }
}
void ActionProto::set_allocated_wait_for_document_to_become_interactive(::autofill_assistant::WaitForDocumentToBecomeInteractiveProto* wait_for_document_to_become_interactive) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action_info();
  if (wait_for_document_to_become_interactive) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(wait_for_document_to_become_interactive));
    if (message_arena != submessage_arena) {
      wait_for_document_to_become_interactive = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, wait_for_document_to_become_interactive, submessage_arena);
    }
    set_has_wait_for_document_to_become_interactive();
    action_info_.wait_for_document_to_become_interactive_ = wait_for_document_to_become_interactive;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ActionProto.wait_for_document_to_become_interactive)
}
void ActionProto::clear_wait_for_document_to_become_interactive() {
  if (_internal_has_wait_for_document_to_become_interactive()) {
    if (GetArenaForAllocation() == nullptr) {
      delete action_info_.wait_for_document_to_become_interactive_;
    }
    clear_has_action_info();
  }
}
void ActionProto::set_allocated_wait_for_document_to_become_complete(::autofill_assistant::WaitForDocumentToBecomeCompleteProto* wait_for_document_to_become_complete) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action_info();
  if (wait_for_document_to_become_complete) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(wait_for_document_to_become_complete));
    if (message_arena != submessage_arena) {
      wait_for_document_to_become_complete = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, wait_for_document_to_become_complete, submessage_arena);
    }
    set_has_wait_for_document_to_become_complete();
    action_info_.wait_for_document_to_become_complete_ = wait_for_document_to_become_complete;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ActionProto.wait_for_document_to_become_complete)
}
void ActionProto::clear_wait_for_document_to_become_complete() {
  if (_internal_has_wait_for_document_to_become_complete()) {
    if (GetArenaForAllocation() == nullptr) {
      delete action_info_.wait_for_document_to_become_complete_;
    }
    clear_has_action_info();
  }
}
void ActionProto::set_allocated_send_click_event(::autofill_assistant::SendClickEventProto* send_click_event) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action_info();
  if (send_click_event) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(send_click_event));
    if (message_arena != submessage_arena) {
      send_click_event = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, send_click_event, submessage_arena);
    }
    set_has_send_click_event();
    action_info_.send_click_event_ = send_click_event;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ActionProto.send_click_event)
}
void ActionProto::clear_send_click_event() {
  if (_internal_has_send_click_event()) {
    if (GetArenaForAllocation() == nullptr) {
      delete action_info_.send_click_event_;
    }
    clear_has_action_info();
  }
}
void ActionProto::set_allocated_send_tap_event(::autofill_assistant::SendTapEventProto* send_tap_event) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action_info();
  if (send_tap_event) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(send_tap_event));
    if (message_arena != submessage_arena) {
      send_tap_event = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, send_tap_event, submessage_arena);
    }
    set_has_send_tap_event();
    action_info_.send_tap_event_ = send_tap_event;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ActionProto.send_tap_event)
}
void ActionProto::clear_send_tap_event() {
  if (_internal_has_send_tap_event()) {
    if (GetArenaForAllocation() == nullptr) {
      delete action_info_.send_tap_event_;
    }
    clear_has_action_info();
  }
}
void ActionProto::set_allocated_js_click(::autofill_assistant::JsClickProto* js_click) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action_info();
  if (js_click) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(js_click));
    if (message_arena != submessage_arena) {
      js_click = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, js_click, submessage_arena);
    }
    set_has_js_click();
    action_info_.js_click_ = js_click;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ActionProto.js_click)
}
void ActionProto::clear_js_click() {
  if (_internal_has_js_click()) {
    if (GetArenaForAllocation() == nullptr) {
      delete action_info_.js_click_;
    }
    clear_has_action_info();
  }
}
void ActionProto::set_allocated_send_keystroke_events(::autofill_assistant::SendKeystrokeEventsProto* send_keystroke_events) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action_info();
  if (send_keystroke_events) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(send_keystroke_events));
    if (message_arena != submessage_arena) {
      send_keystroke_events = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, send_keystroke_events, submessage_arena);
    }
    set_has_send_keystroke_events();
    action_info_.send_keystroke_events_ = send_keystroke_events;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ActionProto.send_keystroke_events)
}
void ActionProto::clear_send_keystroke_events() {
  if (_internal_has_send_keystroke_events()) {
    if (GetArenaForAllocation() == nullptr) {
      delete action_info_.send_keystroke_events_;
    }
    clear_has_action_info();
  }
}
void ActionProto::set_allocated_send_change_event(::autofill_assistant::SendChangeEventProto* send_change_event) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action_info();
  if (send_change_event) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(send_change_event));
    if (message_arena != submessage_arena) {
      send_change_event = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, send_change_event, submessage_arena);
    }
    set_has_send_change_event();
    action_info_.send_change_event_ = send_change_event;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ActionProto.send_change_event)
}
void ActionProto::clear_send_change_event() {
  if (_internal_has_send_change_event()) {
    if (GetArenaForAllocation() == nullptr) {
      delete action_info_.send_change_event_;
    }
    clear_has_action_info();
  }
}
void ActionProto::set_allocated_set_element_attribute(::autofill_assistant::SetElementAttributeProto* set_element_attribute) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action_info();
  if (set_element_attribute) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(set_element_attribute));
    if (message_arena != submessage_arena) {
      set_element_attribute = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, set_element_attribute, submessage_arena);
    }
    set_has_set_element_attribute();
    action_info_.set_element_attribute_ = set_element_attribute;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ActionProto.set_element_attribute)
}
void ActionProto::clear_set_element_attribute() {
  if (_internal_has_set_element_attribute()) {
    if (GetArenaForAllocation() == nullptr) {
      delete action_info_.set_element_attribute_;
    }
    clear_has_action_info();
  }
}
void ActionProto::set_allocated_select_field_value(::autofill_assistant::SelectFieldValueProto* select_field_value) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action_info();
  if (select_field_value) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(select_field_value));
    if (message_arena != submessage_arena) {
      select_field_value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, select_field_value, submessage_arena);
    }
    set_has_select_field_value();
    action_info_.select_field_value_ = select_field_value;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ActionProto.select_field_value)
}
void ActionProto::clear_select_field_value() {
  if (_internal_has_select_field_value()) {
    if (GetArenaForAllocation() == nullptr) {
      delete action_info_.select_field_value_;
    }
    clear_has_action_info();
  }
}
void ActionProto::set_allocated_focus_field(::autofill_assistant::FocusFieldProto* focus_field) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action_info();
  if (focus_field) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(focus_field));
    if (message_arena != submessage_arena) {
      focus_field = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, focus_field, submessage_arena);
    }
    set_has_focus_field();
    action_info_.focus_field_ = focus_field;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ActionProto.focus_field)
}
void ActionProto::clear_focus_field() {
  if (_internal_has_focus_field()) {
    if (GetArenaForAllocation() == nullptr) {
      delete action_info_.focus_field_;
    }
    clear_has_action_info();
  }
}
void ActionProto::set_allocated_wait_for_element_to_become_stable(::autofill_assistant::WaitForElementToBecomeStableProto* wait_for_element_to_become_stable) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action_info();
  if (wait_for_element_to_become_stable) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(wait_for_element_to_become_stable));
    if (message_arena != submessage_arena) {
      wait_for_element_to_become_stable = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, wait_for_element_to_become_stable, submessage_arena);
    }
    set_has_wait_for_element_to_become_stable();
    action_info_.wait_for_element_to_become_stable_ = wait_for_element_to_become_stable;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ActionProto.wait_for_element_to_become_stable)
}
void ActionProto::clear_wait_for_element_to_become_stable() {
  if (_internal_has_wait_for_element_to_become_stable()) {
    if (GetArenaForAllocation() == nullptr) {
      delete action_info_.wait_for_element_to_become_stable_;
    }
    clear_has_action_info();
  }
}
void ActionProto::set_allocated_check_element_is_on_top(::autofill_assistant::CheckElementIsOnTopProto* check_element_is_on_top) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action_info();
  if (check_element_is_on_top) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(check_element_is_on_top));
    if (message_arena != submessage_arena) {
      check_element_is_on_top = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, check_element_is_on_top, submessage_arena);
    }
    set_has_check_element_is_on_top();
    action_info_.check_element_is_on_top_ = check_element_is_on_top;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ActionProto.check_element_is_on_top)
}
void ActionProto::clear_check_element_is_on_top() {
  if (_internal_has_check_element_is_on_top()) {
    if (GetArenaForAllocation() == nullptr) {
      delete action_info_.check_element_is_on_top_;
    }
    clear_has_action_info();
  }
}
void ActionProto::set_allocated_release_elements(::autofill_assistant::ReleaseElementsProto* release_elements) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action_info();
  if (release_elements) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(release_elements);
    if (message_arena != submessage_arena) {
      release_elements = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, release_elements, submessage_arena);
    }
    set_has_release_elements();
    action_info_.release_elements_ = release_elements;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ActionProto.release_elements)
}
void ActionProto::set_allocated_dispatch_js_event(::autofill_assistant::DispatchJsEventProto* dispatch_js_event) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action_info();
  if (dispatch_js_event) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(dispatch_js_event);
    if (message_arena != submessage_arena) {
      dispatch_js_event = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, dispatch_js_event, submessage_arena);
    }
    set_has_dispatch_js_event();
    action_info_.dispatch_js_event_ = dispatch_js_event;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ActionProto.dispatch_js_event)
}
void ActionProto::set_allocated_send_key_event(::autofill_assistant::SendKeyEventProto* send_key_event) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action_info();
  if (send_key_event) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(send_key_event));
    if (message_arena != submessage_arena) {
      send_key_event = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, send_key_event, submessage_arena);
    }
    set_has_send_key_event();
    action_info_.send_key_event_ = send_key_event;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ActionProto.send_key_event)
}
void ActionProto::clear_send_key_event() {
  if (_internal_has_send_key_event()) {
    if (GetArenaForAllocation() == nullptr) {
      delete action_info_.send_key_event_;
    }
    clear_has_action_info();
  }
}
void ActionProto::set_allocated_select_option_element(::autofill_assistant::SelectOptionElementProto* select_option_element) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action_info();
  if (select_option_element) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(select_option_element));
    if (message_arena != submessage_arena) {
      select_option_element = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, select_option_element, submessage_arena);
    }
    set_has_select_option_element();
    action_info_.select_option_element_ = select_option_element;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ActionProto.select_option_element)
}
void ActionProto::clear_select_option_element() {
  if (_internal_has_select_option_element()) {
    if (GetArenaForAllocation() == nullptr) {
      delete action_info_.select_option_element_;
    }
    clear_has_action_info();
  }
}
void ActionProto::set_allocated_check_element_tag(::autofill_assistant::CheckElementTagProto* check_element_tag) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action_info();
  if (check_element_tag) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(check_element_tag));
    if (message_arena != submessage_arena) {
      check_element_tag = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, check_element_tag, submessage_arena);
    }
    set_has_check_element_tag();
    action_info_.check_element_tag_ = check_element_tag;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ActionProto.check_element_tag)
}
void ActionProto::clear_check_element_tag() {
  if (_internal_has_check_element_tag()) {
    if (GetArenaForAllocation() == nullptr) {
      delete action_info_.check_element_tag_;
    }
    clear_has_action_info();
  }
}
void ActionProto::set_allocated_check_option_element(::autofill_assistant::CheckOptionElementProto* check_option_element) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action_info();
  if (check_option_element) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(check_option_element));
    if (message_arena != submessage_arena) {
      check_option_element = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, check_option_element, submessage_arena);
    }
    set_has_check_option_element();
    action_info_.check_option_element_ = check_option_element;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ActionProto.check_option_element)
}
void ActionProto::clear_check_option_element() {
  if (_internal_has_check_option_element()) {
    if (GetArenaForAllocation() == nullptr) {
      delete action_info_.check_option_element_;
    }
    clear_has_action_info();
  }
}
void ActionProto::set_allocated_set_persistent_ui(::autofill_assistant::SetPersistentUiProto* set_persistent_ui) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action_info();
  if (set_persistent_ui) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(set_persistent_ui);
    if (message_arena != submessage_arena) {
      set_persistent_ui = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, set_persistent_ui, submessage_arena);
    }
    set_has_set_persistent_ui();
    action_info_.set_persistent_ui_ = set_persistent_ui;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ActionProto.set_persistent_ui)
}
void ActionProto::set_allocated_clear_persistent_ui(::autofill_assistant::ClearPersistentUiProto* clear_persistent_ui) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action_info();
  if (clear_persistent_ui) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(clear_persistent_ui);
    if (message_arena != submessage_arena) {
      clear_persistent_ui = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, clear_persistent_ui, submessage_arena);
    }
    set_has_clear_persistent_ui();
    action_info_.clear_persistent_ui_ = clear_persistent_ui;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ActionProto.clear_persistent_ui)
}
void ActionProto::set_allocated_scroll_into_view_if_needed(::autofill_assistant::ScrollIntoViewIfNeededProto* scroll_into_view_if_needed) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action_info();
  if (scroll_into_view_if_needed) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(scroll_into_view_if_needed));
    if (message_arena != submessage_arena) {
      scroll_into_view_if_needed = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, scroll_into_view_if_needed, submessage_arena);
    }
    set_has_scroll_into_view_if_needed();
    action_info_.scroll_into_view_if_needed_ = scroll_into_view_if_needed;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ActionProto.scroll_into_view_if_needed)
}
void ActionProto::clear_scroll_into_view_if_needed() {
  if (_internal_has_scroll_into_view_if_needed()) {
    if (GetArenaForAllocation() == nullptr) {
      delete action_info_.scroll_into_view_if_needed_;
    }
    clear_has_action_info();
  }
}
void ActionProto::set_allocated_scroll_window(::autofill_assistant::ScrollWindowProto* scroll_window) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action_info();
  if (scroll_window) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(scroll_window));
    if (message_arena != submessage_arena) {
      scroll_window = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, scroll_window, submessage_arena);
    }
    set_has_scroll_window();
    action_info_.scroll_window_ = scroll_window;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ActionProto.scroll_window)
}
void ActionProto::clear_scroll_window() {
  if (_internal_has_scroll_window()) {
    if (GetArenaForAllocation() == nullptr) {
      delete action_info_.scroll_window_;
    }
    clear_has_action_info();
  }
}
void ActionProto::set_allocated_scroll_container(::autofill_assistant::ScrollContainerProto* scroll_container) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action_info();
  if (scroll_container) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(scroll_container));
    if (message_arena != submessage_arena) {
      scroll_container = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, scroll_container, submessage_arena);
    }
    set_has_scroll_container();
    action_info_.scroll_container_ = scroll_container;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ActionProto.scroll_container)
}
void ActionProto::clear_scroll_container() {
  if (_internal_has_scroll_container()) {
    if (GetArenaForAllocation() == nullptr) {
      delete action_info_.scroll_container_;
    }
    clear_has_action_info();
  }
}
void ActionProto::set_allocated_set_touchable_area(::autofill_assistant::SetTouchableAreaProto* set_touchable_area) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action_info();
  if (set_touchable_area) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(set_touchable_area);
    if (message_arena != submessage_arena) {
      set_touchable_area = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, set_touchable_area, submessage_arena);
    }
    set_has_set_touchable_area();
    action_info_.set_touchable_area_ = set_touchable_area;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ActionProto.set_touchable_area)
}
void ActionProto::set_allocated_delete_password(::autofill_assistant::DeleteSelectedPasswordProto* delete_password) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action_info();
  if (delete_password) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(delete_password);
    if (message_arena != submessage_arena) {
      delete_password = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, delete_password, submessage_arena);
    }
    set_has_delete_password();
    action_info_.delete_password_ = delete_password;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ActionProto.delete_password)
}
void ActionProto::set_allocated_edit_password(::autofill_assistant::EditSelectedPasswordProto* edit_password) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action_info();
  if (edit_password) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(edit_password);
    if (message_arena != submessage_arena) {
      edit_password = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, edit_password, submessage_arena);
    }
    set_has_edit_password();
    action_info_.edit_password_ = edit_password;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ActionProto.edit_password)
}
void ActionProto::set_allocated_blur_field(::autofill_assistant::BlurFieldProto* blur_field) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action_info();
  if (blur_field) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(blur_field));
    if (message_arena != submessage_arena) {
      blur_field = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, blur_field, submessage_arena);
    }
    set_has_blur_field();
    action_info_.blur_field_ = blur_field;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ActionProto.blur_field)
}
void ActionProto::clear_blur_field() {
  if (_internal_has_blur_field()) {
    if (GetArenaForAllocation() == nullptr) {
      delete action_info_.blur_field_;
    }
    clear_has_action_info();
  }
}
void ActionProto::set_allocated_reset_pending_credentials(::autofill_assistant::ResetPendingCredentialsProto* reset_pending_credentials) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action_info();
  if (reset_pending_credentials) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(reset_pending_credentials);
    if (message_arena != submessage_arena) {
      reset_pending_credentials = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, reset_pending_credentials, submessage_arena);
    }
    set_has_reset_pending_credentials();
    action_info_.reset_pending_credentials_ = reset_pending_credentials;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ActionProto.reset_pending_credentials)
}
void ActionProto::set_allocated_save_submitted_password(::autofill_assistant::SaveSubmittedPasswordProto* save_submitted_password) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action_info();
  if (save_submitted_password) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(save_submitted_password);
    if (message_arena != submessage_arena) {
      save_submitted_password = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, save_submitted_password, submessage_arena);
    }
    set_has_save_submitted_password();
    action_info_.save_submitted_password_ = save_submitted_password;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ActionProto.save_submitted_password)
}
void ActionProto::set_allocated_update_client_settings(::autofill_assistant::UpdateClientSettingsProto* update_client_settings) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action_info();
  if (update_client_settings) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(update_client_settings);
    if (message_arena != submessage_arena) {
      update_client_settings = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, update_client_settings, submessage_arena);
    }
    set_has_update_client_settings();
    action_info_.update_client_settings_ = update_client_settings;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ActionProto.update_client_settings)
}
void ActionProto::set_allocated_js_flow(::autofill_assistant::JsFlowProto* js_flow) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action_info();
  if (js_flow) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(js_flow);
    if (message_arena != submessage_arena) {
      js_flow = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, js_flow, submessage_arena);
    }
    set_has_js_flow();
    action_info_.js_flow_ = js_flow;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ActionProto.js_flow)
}
void ActionProto::set_allocated_execute_js(::autofill_assistant::ExecuteJsProto* execute_js) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action_info();
  if (execute_js) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(execute_js));
    if (message_arena != submessage_arena) {
      execute_js = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, execute_js, submessage_arena);
    }
    set_has_execute_js();
    action_info_.execute_js_ = execute_js;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ActionProto.execute_js)
}
void ActionProto::clear_execute_js() {
  if (_internal_has_execute_js()) {
    if (GetArenaForAllocation() == nullptr) {
      delete action_info_.execute_js_;
    }
    clear_has_action_info();
  }
}
void ActionProto::set_allocated_register_password_reset_request(::autofill_assistant::RegisterPasswordResetRequestProto* register_password_reset_request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action_info();
  if (register_password_reset_request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(register_password_reset_request);
    if (message_arena != submessage_arena) {
      register_password_reset_request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, register_password_reset_request, submessage_arena);
    }
    set_has_register_password_reset_request();
    action_info_.register_password_reset_request_ = register_password_reset_request;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ActionProto.register_password_reset_request)
}
void ActionProto::set_allocated_external_action(::autofill_assistant::ExternalActionProto* external_action) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action_info();
  if (external_action) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(external_action);
    if (message_arena != submessage_arena) {
      external_action = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, external_action, submessage_arena);
    }
    set_has_external_action();
    action_info_.external_action_ = external_action;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ActionProto.external_action)
}
void ActionProto::set_allocated_set_native_value(::autofill_assistant::SetNativeValueProto* set_native_value) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action_info();
  if (set_native_value) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(set_native_value));
    if (message_arena != submessage_arena) {
      set_native_value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, set_native_value, submessage_arena);
    }
    set_has_set_native_value();
    action_info_.set_native_value_ = set_native_value;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ActionProto.set_native_value)
}
void ActionProto::clear_set_native_value() {
  if (_internal_has_set_native_value()) {
    if (GetArenaForAllocation() == nullptr) {
      delete action_info_.set_native_value_;
    }
    clear_has_action_info();
  }
}
void ActionProto::set_allocated_set_native_checked(::autofill_assistant::SetNativeCheckedProto* set_native_checked) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action_info();
  if (set_native_checked) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(set_native_checked));
    if (message_arena != submessage_arena) {
      set_native_checked = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, set_native_checked, submessage_arena);
    }
    set_has_set_native_checked();
    action_info_.set_native_checked_ = set_native_checked;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ActionProto.set_native_checked)
}
void ActionProto::clear_set_native_checked() {
  if (_internal_has_set_native_checked()) {
    if (GetArenaForAllocation() == nullptr) {
      delete action_info_.set_native_checked_;
    }
    clear_has_action_info();
  }
}
void ActionProto::set_allocated_prompt_qr_code_scan(::autofill_assistant::PromptQrCodeScanProto* prompt_qr_code_scan) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_action_info();
  if (prompt_qr_code_scan) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(prompt_qr_code_scan);
    if (message_arena != submessage_arena) {
      prompt_qr_code_scan = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, prompt_qr_code_scan, submessage_arena);
    }
    set_has_prompt_qr_code_scan();
    action_info_.prompt_qr_code_scan_ = prompt_qr_code_scan;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ActionProto.prompt_qr_code_scan)
}
ActionProto::ActionProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.ActionProto)
}
ActionProto::ActionProto(const ActionProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  server_payload_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    server_payload_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_server_payload()) {
    server_payload_.Set(from._internal_server_payload(), 
      GetArenaForAllocation());
  }
  ::memcpy(&action_delay_ms_, &from.action_delay_ms_,
    static_cast<size_t>(reinterpret_cast<char*>(&clean_contextual_ui_) -
    reinterpret_cast<char*>(&action_delay_ms_)) + sizeof(clean_contextual_ui_));
  clear_has_action_info();
  switch (from.action_info_case()) {
    case kSelectOption: {
      _internal_mutable_select_option()->::autofill_assistant::SelectOptionProto::MergeFrom(from._internal_select_option());
      break;
    }
    case kNavigate: {
      _internal_mutable_navigate()->::autofill_assistant::NavigateProto::MergeFrom(from._internal_navigate());
      break;
    }
    case kPrompt: {
      _internal_mutable_prompt()->::autofill_assistant::PromptProto::MergeFrom(from._internal_prompt());
      break;
    }
    case kTell: {
      _internal_mutable_tell()->::autofill_assistant::TellProto::MergeFrom(from._internal_tell());
      break;
    }
    case kShowCast: {
      _internal_mutable_show_cast()->::autofill_assistant::ShowCastProto::MergeFrom(from._internal_show_cast());
      break;
    }
    case kWaitForDom: {
      _internal_mutable_wait_for_dom()->::autofill_assistant::WaitForDomProto::MergeFrom(from._internal_wait_for_dom());
      break;
    }
    case kUseCard: {
      _internal_mutable_use_card()->::autofill_assistant::UseCreditCardProto::MergeFrom(from._internal_use_card());
      break;
    }
    case kUseAddress: {
      _internal_mutable_use_address()->::autofill_assistant::UseAddressProto::MergeFrom(from._internal_use_address());
      break;
    }
    case kUploadDom: {
      _internal_mutable_upload_dom()->::autofill_assistant::UploadDomProto::MergeFrom(from._internal_upload_dom());
      break;
    }
    case kShowProgressBar: {
      _internal_mutable_show_progress_bar()->::autofill_assistant::ShowProgressBarProto::MergeFrom(from._internal_show_progress_bar());
      break;
    }
    case kShowDetails: {
      _internal_mutable_show_details()->::autofill_assistant::ShowDetailsProto::MergeFrom(from._internal_show_details());
      break;
    }
    case kStop: {
      _internal_mutable_stop()->::autofill_assistant::StopProto::MergeFrom(from._internal_stop());
      break;
    }
    case kCollectUserData: {
      _internal_mutable_collect_user_data()->::autofill_assistant::CollectUserDataProto::MergeFrom(from._internal_collect_user_data());
      break;
    }
    case kSetAttribute: {
      _internal_mutable_set_attribute()->::autofill_assistant::SetAttributeProto::MergeFrom(from._internal_set_attribute());
      break;
    }
    case kShowInfoBox: {
      _internal_mutable_show_info_box()->::autofill_assistant::ShowInfoBoxProto::MergeFrom(from._internal_show_info_box());
      break;
    }
    case kExpectNavigation: {
      _internal_mutable_expect_navigation()->::autofill_assistant::ExpectNavigationProto::MergeFrom(from._internal_expect_navigation());
      break;
    }
    case kWaitForNavigation: {
      _internal_mutable_wait_for_navigation()->::autofill_assistant::WaitForNavigationProto::MergeFrom(from._internal_wait_for_navigation());
      break;
    }
    case kConfigureBottomSheet: {
      _internal_mutable_configure_bottom_sheet()->::autofill_assistant::ConfigureBottomSheetProto::MergeFrom(from._internal_configure_bottom_sheet());
      break;
    }
    case kShowForm: {
      _internal_mutable_show_form()->::autofill_assistant::ShowFormProto::MergeFrom(from._internal_show_form());
      break;
    }
    case kPopupMessage: {
      _internal_mutable_popup_message()->::autofill_assistant::PopupMessageProto::MergeFrom(from._internal_popup_message());
      break;
    }
    case kWaitForDocument: {
      _internal_mutable_wait_for_document()->::autofill_assistant::WaitForDocumentProto::MergeFrom(from._internal_wait_for_document());
      break;
    }
    case kShowGenericUi: {
      _internal_mutable_show_generic_ui()->::autofill_assistant::ShowGenericUiProto::MergeFrom(from._internal_show_generic_ui());
      break;
    }
    case kGeneratePasswordForFormField: {
      _internal_mutable_generate_password_for_form_field()->::autofill_assistant::GeneratePasswordForFormFieldProto::MergeFrom(from._internal_generate_password_for_form_field());
      break;
    }
    case kSaveGeneratedPassword: {
      _internal_mutable_save_generated_password()->::autofill_assistant::SaveGeneratedPasswordProto::MergeFrom(from._internal_save_generated_password());
      break;
    }
    case kConfigureUiState: {
      _internal_mutable_configure_ui_state()->::autofill_assistant::ConfigureUiStateProto::MergeFrom(from._internal_configure_ui_state());
      break;
    }
    case kPresaveGeneratedPassword: {
      _internal_mutable_presave_generated_password()->::autofill_assistant::PresaveGeneratedPasswordProto::MergeFrom(from._internal_presave_generated_password());
      break;
    }
    case kGetElementStatus: {
      _internal_mutable_get_element_status()->::autofill_assistant::GetElementStatusProto::MergeFrom(from._internal_get_element_status());
      break;
    }
    case kScrollIntoView: {
      _internal_mutable_scroll_into_view()->::autofill_assistant::ScrollIntoViewProto::MergeFrom(from._internal_scroll_into_view());
      break;
    }
    case kWaitForDocumentToBecomeInteractive: {
      _internal_mutable_wait_for_document_to_become_interactive()->::autofill_assistant::WaitForDocumentToBecomeInteractiveProto::MergeFrom(from._internal_wait_for_document_to_become_interactive());
      break;
    }
    case kWaitForDocumentToBecomeComplete: {
      _internal_mutable_wait_for_document_to_become_complete()->::autofill_assistant::WaitForDocumentToBecomeCompleteProto::MergeFrom(from._internal_wait_for_document_to_become_complete());
      break;
    }
    case kSendClickEvent: {
      _internal_mutable_send_click_event()->::autofill_assistant::SendClickEventProto::MergeFrom(from._internal_send_click_event());
      break;
    }
    case kSendTapEvent: {
      _internal_mutable_send_tap_event()->::autofill_assistant::SendTapEventProto::MergeFrom(from._internal_send_tap_event());
      break;
    }
    case kJsClick: {
      _internal_mutable_js_click()->::autofill_assistant::JsClickProto::MergeFrom(from._internal_js_click());
      break;
    }
    case kSendKeystrokeEvents: {
      _internal_mutable_send_keystroke_events()->::autofill_assistant::SendKeystrokeEventsProto::MergeFrom(from._internal_send_keystroke_events());
      break;
    }
    case kSendChangeEvent: {
      _internal_mutable_send_change_event()->::autofill_assistant::SendChangeEventProto::MergeFrom(from._internal_send_change_event());
      break;
    }
    case kSetElementAttribute: {
      _internal_mutable_set_element_attribute()->::autofill_assistant::SetElementAttributeProto::MergeFrom(from._internal_set_element_attribute());
      break;
    }
    case kSelectFieldValue: {
      _internal_mutable_select_field_value()->::autofill_assistant::SelectFieldValueProto::MergeFrom(from._internal_select_field_value());
      break;
    }
    case kFocusField: {
      _internal_mutable_focus_field()->::autofill_assistant::FocusFieldProto::MergeFrom(from._internal_focus_field());
      break;
    }
    case kWaitForElementToBecomeStable: {
      _internal_mutable_wait_for_element_to_become_stable()->::autofill_assistant::WaitForElementToBecomeStableProto::MergeFrom(from._internal_wait_for_element_to_become_stable());
      break;
    }
    case kCheckElementIsOnTop: {
      _internal_mutable_check_element_is_on_top()->::autofill_assistant::CheckElementIsOnTopProto::MergeFrom(from._internal_check_element_is_on_top());
      break;
    }
    case kReleaseElements: {
      _internal_mutable_release_elements()->::autofill_assistant::ReleaseElementsProto::MergeFrom(from._internal_release_elements());
      break;
    }
    case kDispatchJsEvent: {
      _internal_mutable_dispatch_js_event()->::autofill_assistant::DispatchJsEventProto::MergeFrom(from._internal_dispatch_js_event());
      break;
    }
    case kSendKeyEvent: {
      _internal_mutable_send_key_event()->::autofill_assistant::SendKeyEventProto::MergeFrom(from._internal_send_key_event());
      break;
    }
    case kSelectOptionElement: {
      _internal_mutable_select_option_element()->::autofill_assistant::SelectOptionElementProto::MergeFrom(from._internal_select_option_element());
      break;
    }
    case kCheckElementTag: {
      _internal_mutable_check_element_tag()->::autofill_assistant::CheckElementTagProto::MergeFrom(from._internal_check_element_tag());
      break;
    }
    case kCheckOptionElement: {
      _internal_mutable_check_option_element()->::autofill_assistant::CheckOptionElementProto::MergeFrom(from._internal_check_option_element());
      break;
    }
    case kSetPersistentUi: {
      _internal_mutable_set_persistent_ui()->::autofill_assistant::SetPersistentUiProto::MergeFrom(from._internal_set_persistent_ui());
      break;
    }
    case kClearPersistentUi: {
      _internal_mutable_clear_persistent_ui()->::autofill_assistant::ClearPersistentUiProto::MergeFrom(from._internal_clear_persistent_ui());
      break;
    }
    case kScrollIntoViewIfNeeded: {
      _internal_mutable_scroll_into_view_if_needed()->::autofill_assistant::ScrollIntoViewIfNeededProto::MergeFrom(from._internal_scroll_into_view_if_needed());
      break;
    }
    case kScrollWindow: {
      _internal_mutable_scroll_window()->::autofill_assistant::ScrollWindowProto::MergeFrom(from._internal_scroll_window());
      break;
    }
    case kScrollContainer: {
      _internal_mutable_scroll_container()->::autofill_assistant::ScrollContainerProto::MergeFrom(from._internal_scroll_container());
      break;
    }
    case kSetTouchableArea: {
      _internal_mutable_set_touchable_area()->::autofill_assistant::SetTouchableAreaProto::MergeFrom(from._internal_set_touchable_area());
      break;
    }
    case kDeletePassword: {
      _internal_mutable_delete_password()->::autofill_assistant::DeleteSelectedPasswordProto::MergeFrom(from._internal_delete_password());
      break;
    }
    case kEditPassword: {
      _internal_mutable_edit_password()->::autofill_assistant::EditSelectedPasswordProto::MergeFrom(from._internal_edit_password());
      break;
    }
    case kBlurField: {
      _internal_mutable_blur_field()->::autofill_assistant::BlurFieldProto::MergeFrom(from._internal_blur_field());
      break;
    }
    case kResetPendingCredentials: {
      _internal_mutable_reset_pending_credentials()->::autofill_assistant::ResetPendingCredentialsProto::MergeFrom(from._internal_reset_pending_credentials());
      break;
    }
    case kSaveSubmittedPassword: {
      _internal_mutable_save_submitted_password()->::autofill_assistant::SaveSubmittedPasswordProto::MergeFrom(from._internal_save_submitted_password());
      break;
    }
    case kUpdateClientSettings: {
      _internal_mutable_update_client_settings()->::autofill_assistant::UpdateClientSettingsProto::MergeFrom(from._internal_update_client_settings());
      break;
    }
    case kJsFlow: {
      _internal_mutable_js_flow()->::autofill_assistant::JsFlowProto::MergeFrom(from._internal_js_flow());
      break;
    }
    case kExecuteJs: {
      _internal_mutable_execute_js()->::autofill_assistant::ExecuteJsProto::MergeFrom(from._internal_execute_js());
      break;
    }
    case kRegisterPasswordResetRequest: {
      _internal_mutable_register_password_reset_request()->::autofill_assistant::RegisterPasswordResetRequestProto::MergeFrom(from._internal_register_password_reset_request());
      break;
    }
    case kExternalAction: {
      _internal_mutable_external_action()->::autofill_assistant::ExternalActionProto::MergeFrom(from._internal_external_action());
      break;
    }
    case kSetNativeValue: {
      _internal_mutable_set_native_value()->::autofill_assistant::SetNativeValueProto::MergeFrom(from._internal_set_native_value());
      break;
    }
    case kSetNativeChecked: {
      _internal_mutable_set_native_checked()->::autofill_assistant::SetNativeCheckedProto::MergeFrom(from._internal_set_native_checked());
      break;
    }
    case kPromptQrCodeScan: {
      _internal_mutable_prompt_qr_code_scan()->::autofill_assistant::PromptQrCodeScanProto::MergeFrom(from._internal_prompt_qr_code_scan());
      break;
    }
    case ACTION_INFO_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.ActionProto)
}

inline void ActionProto::SharedCtor() {
server_payload_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  server_payload_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&action_delay_ms_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&clean_contextual_ui_) -
    reinterpret_cast<char*>(&action_delay_ms_)) + sizeof(clean_contextual_ui_));
clear_has_action_info();
}

ActionProto::~ActionProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.ActionProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ActionProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  server_payload_.Destroy();
  if (has_action_info()) {
    clear_action_info();
  }
}

void ActionProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ActionProto::clear_action_info() {
// @@protoc_insertion_point(one_of_clear_start:autofill_assistant.ActionProto)
  switch (action_info_case()) {
    case kSelectOption: {
      if (GetArenaForAllocation() == nullptr) {
        delete action_info_.select_option_;
      }
      break;
    }
    case kNavigate: {
      if (GetArenaForAllocation() == nullptr) {
        delete action_info_.navigate_;
      }
      break;
    }
    case kPrompt: {
      if (GetArenaForAllocation() == nullptr) {
        delete action_info_.prompt_;
      }
      break;
    }
    case kTell: {
      if (GetArenaForAllocation() == nullptr) {
        delete action_info_.tell_;
      }
      break;
    }
    case kShowCast: {
      if (GetArenaForAllocation() == nullptr) {
        delete action_info_.show_cast_;
      }
      break;
    }
    case kWaitForDom: {
      if (GetArenaForAllocation() == nullptr) {
        delete action_info_.wait_for_dom_;
      }
      break;
    }
    case kUseCard: {
      if (GetArenaForAllocation() == nullptr) {
        delete action_info_.use_card_;
      }
      break;
    }
    case kUseAddress: {
      if (GetArenaForAllocation() == nullptr) {
        delete action_info_.use_address_;
      }
      break;
    }
    case kUploadDom: {
      if (GetArenaForAllocation() == nullptr) {
        delete action_info_.upload_dom_;
      }
      break;
    }
    case kShowProgressBar: {
      if (GetArenaForAllocation() == nullptr) {
        delete action_info_.show_progress_bar_;
      }
      break;
    }
    case kShowDetails: {
      if (GetArenaForAllocation() == nullptr) {
        delete action_info_.show_details_;
      }
      break;
    }
    case kStop: {
      if (GetArenaForAllocation() == nullptr) {
        delete action_info_.stop_;
      }
      break;
    }
    case kCollectUserData: {
      if (GetArenaForAllocation() == nullptr) {
        delete action_info_.collect_user_data_;
      }
      break;
    }
    case kSetAttribute: {
      if (GetArenaForAllocation() == nullptr) {
        delete action_info_.set_attribute_;
      }
      break;
    }
    case kShowInfoBox: {
      if (GetArenaForAllocation() == nullptr) {
        delete action_info_.show_info_box_;
      }
      break;
    }
    case kExpectNavigation: {
      if (GetArenaForAllocation() == nullptr) {
        delete action_info_.expect_navigation_;
      }
      break;
    }
    case kWaitForNavigation: {
      if (GetArenaForAllocation() == nullptr) {
        delete action_info_.wait_for_navigation_;
      }
      break;
    }
    case kConfigureBottomSheet: {
      if (GetArenaForAllocation() == nullptr) {
        delete action_info_.configure_bottom_sheet_;
      }
      break;
    }
    case kShowForm: {
      if (GetArenaForAllocation() == nullptr) {
        delete action_info_.show_form_;
      }
      break;
    }
    case kPopupMessage: {
      if (GetArenaForAllocation() == nullptr) {
        delete action_info_.popup_message_;
      }
      break;
    }
    case kWaitForDocument: {
      if (GetArenaForAllocation() == nullptr) {
        delete action_info_.wait_for_document_;
      }
      break;
    }
    case kShowGenericUi: {
      if (GetArenaForAllocation() == nullptr) {
        delete action_info_.show_generic_ui_;
      }
      break;
    }
    case kGeneratePasswordForFormField: {
      if (GetArenaForAllocation() == nullptr) {
        delete action_info_.generate_password_for_form_field_;
      }
      break;
    }
    case kSaveGeneratedPassword: {
      if (GetArenaForAllocation() == nullptr) {
        delete action_info_.save_generated_password_;
      }
      break;
    }
    case kConfigureUiState: {
      if (GetArenaForAllocation() == nullptr) {
        delete action_info_.configure_ui_state_;
      }
      break;
    }
    case kPresaveGeneratedPassword: {
      if (GetArenaForAllocation() == nullptr) {
        delete action_info_.presave_generated_password_;
      }
      break;
    }
    case kGetElementStatus: {
      if (GetArenaForAllocation() == nullptr) {
        delete action_info_.get_element_status_;
      }
      break;
    }
    case kScrollIntoView: {
      if (GetArenaForAllocation() == nullptr) {
        delete action_info_.scroll_into_view_;
      }
      break;
    }
    case kWaitForDocumentToBecomeInteractive: {
      if (GetArenaForAllocation() == nullptr) {
        delete action_info_.wait_for_document_to_become_interactive_;
      }
      break;
    }
    case kWaitForDocumentToBecomeComplete: {
      if (GetArenaForAllocation() == nullptr) {
        delete action_info_.wait_for_document_to_become_complete_;
      }
      break;
    }
    case kSendClickEvent: {
      if (GetArenaForAllocation() == nullptr) {
        delete action_info_.send_click_event_;
      }
      break;
    }
    case kSendTapEvent: {
      if (GetArenaForAllocation() == nullptr) {
        delete action_info_.send_tap_event_;
      }
      break;
    }
    case kJsClick: {
      if (GetArenaForAllocation() == nullptr) {
        delete action_info_.js_click_;
      }
      break;
    }
    case kSendKeystrokeEvents: {
      if (GetArenaForAllocation() == nullptr) {
        delete action_info_.send_keystroke_events_;
      }
      break;
    }
    case kSendChangeEvent: {
      if (GetArenaForAllocation() == nullptr) {
        delete action_info_.send_change_event_;
      }
      break;
    }
    case kSetElementAttribute: {
      if (GetArenaForAllocation() == nullptr) {
        delete action_info_.set_element_attribute_;
      }
      break;
    }
    case kSelectFieldValue: {
      if (GetArenaForAllocation() == nullptr) {
        delete action_info_.select_field_value_;
      }
      break;
    }
    case kFocusField: {
      if (GetArenaForAllocation() == nullptr) {
        delete action_info_.focus_field_;
      }
      break;
    }
    case kWaitForElementToBecomeStable: {
      if (GetArenaForAllocation() == nullptr) {
        delete action_info_.wait_for_element_to_become_stable_;
      }
      break;
    }
    case kCheckElementIsOnTop: {
      if (GetArenaForAllocation() == nullptr) {
        delete action_info_.check_element_is_on_top_;
      }
      break;
    }
    case kReleaseElements: {
      if (GetArenaForAllocation() == nullptr) {
        delete action_info_.release_elements_;
      }
      break;
    }
    case kDispatchJsEvent: {
      if (GetArenaForAllocation() == nullptr) {
        delete action_info_.dispatch_js_event_;
      }
      break;
    }
    case kSendKeyEvent: {
      if (GetArenaForAllocation() == nullptr) {
        delete action_info_.send_key_event_;
      }
      break;
    }
    case kSelectOptionElement: {
      if (GetArenaForAllocation() == nullptr) {
        delete action_info_.select_option_element_;
      }
      break;
    }
    case kCheckElementTag: {
      if (GetArenaForAllocation() == nullptr) {
        delete action_info_.check_element_tag_;
      }
      break;
    }
    case kCheckOptionElement: {
      if (GetArenaForAllocation() == nullptr) {
        delete action_info_.check_option_element_;
      }
      break;
    }
    case kSetPersistentUi: {
      if (GetArenaForAllocation() == nullptr) {
        delete action_info_.set_persistent_ui_;
      }
      break;
    }
    case kClearPersistentUi: {
      if (GetArenaForAllocation() == nullptr) {
        delete action_info_.clear_persistent_ui_;
      }
      break;
    }
    case kScrollIntoViewIfNeeded: {
      if (GetArenaForAllocation() == nullptr) {
        delete action_info_.scroll_into_view_if_needed_;
      }
      break;
    }
    case kScrollWindow: {
      if (GetArenaForAllocation() == nullptr) {
        delete action_info_.scroll_window_;
      }
      break;
    }
    case kScrollContainer: {
      if (GetArenaForAllocation() == nullptr) {
        delete action_info_.scroll_container_;
      }
      break;
    }
    case kSetTouchableArea: {
      if (GetArenaForAllocation() == nullptr) {
        delete action_info_.set_touchable_area_;
      }
      break;
    }
    case kDeletePassword: {
      if (GetArenaForAllocation() == nullptr) {
        delete action_info_.delete_password_;
      }
      break;
    }
    case kEditPassword: {
      if (GetArenaForAllocation() == nullptr) {
        delete action_info_.edit_password_;
      }
      break;
    }
    case kBlurField: {
      if (GetArenaForAllocation() == nullptr) {
        delete action_info_.blur_field_;
      }
      break;
    }
    case kResetPendingCredentials: {
      if (GetArenaForAllocation() == nullptr) {
        delete action_info_.reset_pending_credentials_;
      }
      break;
    }
    case kSaveSubmittedPassword: {
      if (GetArenaForAllocation() == nullptr) {
        delete action_info_.save_submitted_password_;
      }
      break;
    }
    case kUpdateClientSettings: {
      if (GetArenaForAllocation() == nullptr) {
        delete action_info_.update_client_settings_;
      }
      break;
    }
    case kJsFlow: {
      if (GetArenaForAllocation() == nullptr) {
        delete action_info_.js_flow_;
      }
      break;
    }
    case kExecuteJs: {
      if (GetArenaForAllocation() == nullptr) {
        delete action_info_.execute_js_;
      }
      break;
    }
    case kRegisterPasswordResetRequest: {
      if (GetArenaForAllocation() == nullptr) {
        delete action_info_.register_password_reset_request_;
      }
      break;
    }
    case kExternalAction: {
      if (GetArenaForAllocation() == nullptr) {
        delete action_info_.external_action_;
      }
      break;
    }
    case kSetNativeValue: {
      if (GetArenaForAllocation() == nullptr) {
        delete action_info_.set_native_value_;
      }
      break;
    }
    case kSetNativeChecked: {
      if (GetArenaForAllocation() == nullptr) {
        delete action_info_.set_native_checked_;
      }
      break;
    }
    case kPromptQrCodeScan: {
      if (GetArenaForAllocation() == nullptr) {
        delete action_info_.prompt_qr_code_scan_;
      }
      break;
    }
    case ACTION_INFO_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = ACTION_INFO_NOT_SET;
}


void ActionProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.ActionProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    server_payload_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&action_delay_ms_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&clean_contextual_ui_) -
        reinterpret_cast<char*>(&action_delay_ms_)) + sizeof(clean_contextual_ui_));
  }
  clear_action_info();
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ActionProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 action_delay_ms = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_action_delay_ms(&has_bits);
          action_delay_ms_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes server_payload = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_server_payload();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.SelectOptionProto select_option = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_select_option(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.NavigateProto navigate = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_navigate(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.PromptProto prompt = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_prompt(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.TellProto tell = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_tell(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.ShowCastProto show_cast = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          ptr = ctx->ParseMessage(_internal_mutable_show_cast(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.UploadDomProto upload_dom = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 146)) {
          ptr = ctx->ParseMessage(_internal_mutable_upload_dom(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.WaitForDomProto wait_for_dom = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 154)) {
          ptr = ctx->ParseMessage(_internal_mutable_wait_for_dom(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.ShowProgressBarProto show_progress_bar = 24;
      case 24:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 194)) {
          ptr = ctx->ParseMessage(_internal_mutable_show_progress_bar(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.UseCreditCardProto use_card = 28;
      case 28:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 226)) {
          ptr = ctx->ParseMessage(_internal_mutable_use_card(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.UseAddressProto use_address = 29;
      case 29:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 234)) {
          ptr = ctx->ParseMessage(_internal_mutable_use_address(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.ShowDetailsProto show_details = 32;
      case 32:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 2)) {
          ptr = ctx->ParseMessage(_internal_mutable_show_details(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool clean_contextual_ui = 33;
      case 33:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_clean_contextual_ui(&has_bits);
          clean_contextual_ui_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.StopProto stop = 35;
      case 35:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_stop(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.CollectUserDataProto collect_user_data = 36;
      case 36:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_collect_user_data(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.SetAttributeProto set_attribute = 37;
      case 37:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_set_attribute(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.ShowInfoBoxProto show_info_box = 39;
      case 39:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_show_info_box(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.ExpectNavigationProto expect_navigation = 40;
      case 40:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_expect_navigation(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.WaitForNavigationProto wait_for_navigation = 41;
      case 41:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_wait_for_navigation(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.ConfigureBottomSheetProto configure_bottom_sheet = 42;
      case 42:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_configure_bottom_sheet(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.ShowFormProto show_form = 43;
      case 43:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_show_form(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.PopupMessageProto popup_message = 44;
      case 44:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          ptr = ctx->ParseMessage(_internal_mutable_popup_message(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.WaitForDocumentProto wait_for_document = 45;
      case 45:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          ptr = ctx->ParseMessage(_internal_mutable_wait_for_document(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.ShowGenericUiProto show_generic_ui = 49;
      case 49:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 138)) {
          ptr = ctx->ParseMessage(_internal_mutable_show_generic_ui(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.GeneratePasswordForFormFieldProto generate_password_for_form_field = 52;
      case 52:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
          ptr = ctx->ParseMessage(_internal_mutable_generate_password_for_form_field(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.SaveGeneratedPasswordProto save_generated_password = 53;
      case 53:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 170)) {
          ptr = ctx->ParseMessage(_internal_mutable_save_generated_password(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.ConfigureUiStateProto configure_ui_state = 54;
      case 54:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 178)) {
          ptr = ctx->ParseMessage(_internal_mutable_configure_ui_state(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.PresaveGeneratedPasswordProto presave_generated_password = 55;
      case 55:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 186)) {
          ptr = ctx->ParseMessage(_internal_mutable_presave_generated_password(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.GetElementStatusProto get_element_status = 56;
      case 56:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 194)) {
          ptr = ctx->ParseMessage(_internal_mutable_get_element_status(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.ScrollIntoViewProto scroll_into_view = 57;
      case 57:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 202)) {
          ptr = ctx->ParseMessage(_internal_mutable_scroll_into_view(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.WaitForDocumentToBecomeInteractiveProto wait_for_document_to_become_interactive = 58;
      case 58:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 210)) {
          ptr = ctx->ParseMessage(_internal_mutable_wait_for_document_to_become_interactive(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.WaitForDocumentToBecomeCompleteProto wait_for_document_to_become_complete = 59;
      case 59:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 218)) {
          ptr = ctx->ParseMessage(_internal_mutable_wait_for_document_to_become_complete(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.SendClickEventProto send_click_event = 60;
      case 60:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 226)) {
          ptr = ctx->ParseMessage(_internal_mutable_send_click_event(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.SendTapEventProto send_tap_event = 61;
      case 61:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 234)) {
          ptr = ctx->ParseMessage(_internal_mutable_send_tap_event(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.JsClickProto js_click = 62;
      case 62:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 242)) {
          ptr = ctx->ParseMessage(_internal_mutable_js_click(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.SendKeystrokeEventsProto send_keystroke_events = 63;
      case 63:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 250)) {
          ptr = ctx->ParseMessage(_internal_mutable_send_keystroke_events(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.SendChangeEventProto send_change_event = 64;
      case 64:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 2)) {
          ptr = ctx->ParseMessage(_internal_mutable_send_change_event(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.SetElementAttributeProto set_element_attribute = 65;
      case 65:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_set_element_attribute(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.SelectFieldValueProto select_field_value = 66;
      case 66:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_select_field_value(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.FocusFieldProto focus_field = 67;
      case 67:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_focus_field(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.WaitForElementToBecomeStableProto wait_for_element_to_become_stable = 68;
      case 68:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_wait_for_element_to_become_stable(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.CheckElementIsOnTopProto check_element_is_on_top = 69;
      case 69:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_check_element_is_on_top(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.ReleaseElementsProto release_elements = 70;
      case 70:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_release_elements(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.DispatchJsEventProto dispatch_js_event = 72;
      case 72:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_dispatch_js_event(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.SendKeyEventProto send_key_event = 73;
      case 73:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_send_key_event(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.SelectOptionElementProto select_option_element = 74;
      case 74:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_select_option_element(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.CheckElementTagProto check_element_tag = 75;
      case 75:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_check_element_tag(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.CheckOptionElementProto check_option_element = 76;
      case 76:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          ptr = ctx->ParseMessage(_internal_mutable_check_option_element(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.SetPersistentUiProto set_persistent_ui = 77;
      case 77:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          ptr = ctx->ParseMessage(_internal_mutable_set_persistent_ui(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.ClearPersistentUiProto clear_persistent_ui = 78;
      case 78:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 114)) {
          ptr = ctx->ParseMessage(_internal_mutable_clear_persistent_ui(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.ScrollIntoViewIfNeededProto scroll_into_view_if_needed = 79;
      case 79:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 122)) {
          ptr = ctx->ParseMessage(_internal_mutable_scroll_into_view_if_needed(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.ScrollWindowProto scroll_window = 80;
      case 80:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 130)) {
          ptr = ctx->ParseMessage(_internal_mutable_scroll_window(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.ScrollContainerProto scroll_container = 81;
      case 81:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 138)) {
          ptr = ctx->ParseMessage(_internal_mutable_scroll_container(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.SetTouchableAreaProto set_touchable_area = 82;
      case 82:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 146)) {
          ptr = ctx->ParseMessage(_internal_mutable_set_touchable_area(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.DeleteSelectedPasswordProto delete_password = 83;
      case 83:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 154)) {
          ptr = ctx->ParseMessage(_internal_mutable_delete_password(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.EditSelectedPasswordProto edit_password = 84;
      case 84:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
          ptr = ctx->ParseMessage(_internal_mutable_edit_password(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.BlurFieldProto blur_field = 85;
      case 85:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 170)) {
          ptr = ctx->ParseMessage(_internal_mutable_blur_field(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.ResetPendingCredentialsProto reset_pending_credentials = 86;
      case 86:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 178)) {
          ptr = ctx->ParseMessage(_internal_mutable_reset_pending_credentials(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.SaveSubmittedPasswordProto save_submitted_password = 87;
      case 87:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 186)) {
          ptr = ctx->ParseMessage(_internal_mutable_save_submitted_password(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.UpdateClientSettingsProto update_client_settings = 89;
      case 89:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 202)) {
          ptr = ctx->ParseMessage(_internal_mutable_update_client_settings(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.JsFlowProto js_flow = 92;
      case 92:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 226)) {
          ptr = ctx->ParseMessage(_internal_mutable_js_flow(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.ExecuteJsProto execute_js = 93;
      case 93:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 234)) {
          ptr = ctx->ParseMessage(_internal_mutable_execute_js(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.RegisterPasswordResetRequestProto register_password_reset_request = 94;
      case 94:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 242)) {
          ptr = ctx->ParseMessage(_internal_mutable_register_password_reset_request(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.ExternalActionProto external_action = 95;
      case 95:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 250)) {
          ptr = ctx->ParseMessage(_internal_mutable_external_action(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.SetNativeValueProto set_native_value = 96;
      case 96:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 2)) {
          ptr = ctx->ParseMessage(_internal_mutable_set_native_value(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.SetNativeCheckedProto set_native_checked = 97;
      case 97:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_set_native_checked(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.PromptQrCodeScanProto prompt_qr_code_scan = 98;
      case 98:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_prompt_qr_code_scan(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ActionProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.ActionProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 action_delay_ms = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_action_delay_ms(), target);
  }

  // optional bytes server_payload = 4;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        4, this->_internal_server_payload(), target);
  }

  switch (action_info_case()) {
    case kSelectOption: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(7, _Internal::select_option(this),
          _Internal::select_option(this).GetCachedSize(), target, stream);
      break;
    }
    case kNavigate: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(9, _Internal::navigate(this),
          _Internal::navigate(this).GetCachedSize(), target, stream);
      break;
    }
    case kPrompt: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(10, _Internal::prompt(this),
          _Internal::prompt(this).GetCachedSize(), target, stream);
      break;
    }
    case kTell: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(11, _Internal::tell(this),
          _Internal::tell(this).GetCachedSize(), target, stream);
      break;
    }
    case kShowCast: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(12, _Internal::show_cast(this),
          _Internal::show_cast(this).GetCachedSize(), target, stream);
      break;
    }
    case kUploadDom: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(18, _Internal::upload_dom(this),
          _Internal::upload_dom(this).GetCachedSize(), target, stream);
      break;
    }
    case kWaitForDom: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(19, _Internal::wait_for_dom(this),
          _Internal::wait_for_dom(this).GetCachedSize(), target, stream);
      break;
    }
    case kShowProgressBar: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(24, _Internal::show_progress_bar(this),
          _Internal::show_progress_bar(this).GetCachedSize(), target, stream);
      break;
    }
    case kUseCard: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(28, _Internal::use_card(this),
          _Internal::use_card(this).GetCachedSize(), target, stream);
      break;
    }
    case kUseAddress: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(29, _Internal::use_address(this),
          _Internal::use_address(this).GetCachedSize(), target, stream);
      break;
    }
    case kShowDetails: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(32, _Internal::show_details(this),
          _Internal::show_details(this).GetCachedSize(), target, stream);
      break;
    }
    default: ;
  }
  // optional bool clean_contextual_ui = 33;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(33, this->_internal_clean_contextual_ui(), target);
  }

  switch (action_info_case()) {
    case kStop: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(35, _Internal::stop(this),
          _Internal::stop(this).GetCachedSize(), target, stream);
      break;
    }
    case kCollectUserData: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(36, _Internal::collect_user_data(this),
          _Internal::collect_user_data(this).GetCachedSize(), target, stream);
      break;
    }
    case kSetAttribute: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(37, _Internal::set_attribute(this),
          _Internal::set_attribute(this).GetCachedSize(), target, stream);
      break;
    }
    case kShowInfoBox: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(39, _Internal::show_info_box(this),
          _Internal::show_info_box(this).GetCachedSize(), target, stream);
      break;
    }
    case kExpectNavigation: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(40, _Internal::expect_navigation(this),
          _Internal::expect_navigation(this).GetCachedSize(), target, stream);
      break;
    }
    case kWaitForNavigation: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(41, _Internal::wait_for_navigation(this),
          _Internal::wait_for_navigation(this).GetCachedSize(), target, stream);
      break;
    }
    case kConfigureBottomSheet: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(42, _Internal::configure_bottom_sheet(this),
          _Internal::configure_bottom_sheet(this).GetCachedSize(), target, stream);
      break;
    }
    case kShowForm: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(43, _Internal::show_form(this),
          _Internal::show_form(this).GetCachedSize(), target, stream);
      break;
    }
    case kPopupMessage: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(44, _Internal::popup_message(this),
          _Internal::popup_message(this).GetCachedSize(), target, stream);
      break;
    }
    case kWaitForDocument: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(45, _Internal::wait_for_document(this),
          _Internal::wait_for_document(this).GetCachedSize(), target, stream);
      break;
    }
    case kShowGenericUi: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(49, _Internal::show_generic_ui(this),
          _Internal::show_generic_ui(this).GetCachedSize(), target, stream);
      break;
    }
    case kGeneratePasswordForFormField: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(52, _Internal::generate_password_for_form_field(this),
          _Internal::generate_password_for_form_field(this).GetCachedSize(), target, stream);
      break;
    }
    case kSaveGeneratedPassword: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(53, _Internal::save_generated_password(this),
          _Internal::save_generated_password(this).GetCachedSize(), target, stream);
      break;
    }
    case kConfigureUiState: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(54, _Internal::configure_ui_state(this),
          _Internal::configure_ui_state(this).GetCachedSize(), target, stream);
      break;
    }
    case kPresaveGeneratedPassword: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(55, _Internal::presave_generated_password(this),
          _Internal::presave_generated_password(this).GetCachedSize(), target, stream);
      break;
    }
    case kGetElementStatus: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(56, _Internal::get_element_status(this),
          _Internal::get_element_status(this).GetCachedSize(), target, stream);
      break;
    }
    case kScrollIntoView: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(57, _Internal::scroll_into_view(this),
          _Internal::scroll_into_view(this).GetCachedSize(), target, stream);
      break;
    }
    case kWaitForDocumentToBecomeInteractive: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(58, _Internal::wait_for_document_to_become_interactive(this),
          _Internal::wait_for_document_to_become_interactive(this).GetCachedSize(), target, stream);
      break;
    }
    case kWaitForDocumentToBecomeComplete: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(59, _Internal::wait_for_document_to_become_complete(this),
          _Internal::wait_for_document_to_become_complete(this).GetCachedSize(), target, stream);
      break;
    }
    case kSendClickEvent: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(60, _Internal::send_click_event(this),
          _Internal::send_click_event(this).GetCachedSize(), target, stream);
      break;
    }
    case kSendTapEvent: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(61, _Internal::send_tap_event(this),
          _Internal::send_tap_event(this).GetCachedSize(), target, stream);
      break;
    }
    case kJsClick: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(62, _Internal::js_click(this),
          _Internal::js_click(this).GetCachedSize(), target, stream);
      break;
    }
    case kSendKeystrokeEvents: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(63, _Internal::send_keystroke_events(this),
          _Internal::send_keystroke_events(this).GetCachedSize(), target, stream);
      break;
    }
    case kSendChangeEvent: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(64, _Internal::send_change_event(this),
          _Internal::send_change_event(this).GetCachedSize(), target, stream);
      break;
    }
    case kSetElementAttribute: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(65, _Internal::set_element_attribute(this),
          _Internal::set_element_attribute(this).GetCachedSize(), target, stream);
      break;
    }
    case kSelectFieldValue: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(66, _Internal::select_field_value(this),
          _Internal::select_field_value(this).GetCachedSize(), target, stream);
      break;
    }
    case kFocusField: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(67, _Internal::focus_field(this),
          _Internal::focus_field(this).GetCachedSize(), target, stream);
      break;
    }
    case kWaitForElementToBecomeStable: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(68, _Internal::wait_for_element_to_become_stable(this),
          _Internal::wait_for_element_to_become_stable(this).GetCachedSize(), target, stream);
      break;
    }
    case kCheckElementIsOnTop: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(69, _Internal::check_element_is_on_top(this),
          _Internal::check_element_is_on_top(this).GetCachedSize(), target, stream);
      break;
    }
    case kReleaseElements: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(70, _Internal::release_elements(this),
          _Internal::release_elements(this).GetCachedSize(), target, stream);
      break;
    }
    case kDispatchJsEvent: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(72, _Internal::dispatch_js_event(this),
          _Internal::dispatch_js_event(this).GetCachedSize(), target, stream);
      break;
    }
    case kSendKeyEvent: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(73, _Internal::send_key_event(this),
          _Internal::send_key_event(this).GetCachedSize(), target, stream);
      break;
    }
    case kSelectOptionElement: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(74, _Internal::select_option_element(this),
          _Internal::select_option_element(this).GetCachedSize(), target, stream);
      break;
    }
    case kCheckElementTag: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(75, _Internal::check_element_tag(this),
          _Internal::check_element_tag(this).GetCachedSize(), target, stream);
      break;
    }
    case kCheckOptionElement: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(76, _Internal::check_option_element(this),
          _Internal::check_option_element(this).GetCachedSize(), target, stream);
      break;
    }
    case kSetPersistentUi: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(77, _Internal::set_persistent_ui(this),
          _Internal::set_persistent_ui(this).GetCachedSize(), target, stream);
      break;
    }
    case kClearPersistentUi: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(78, _Internal::clear_persistent_ui(this),
          _Internal::clear_persistent_ui(this).GetCachedSize(), target, stream);
      break;
    }
    case kScrollIntoViewIfNeeded: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(79, _Internal::scroll_into_view_if_needed(this),
          _Internal::scroll_into_view_if_needed(this).GetCachedSize(), target, stream);
      break;
    }
    case kScrollWindow: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(80, _Internal::scroll_window(this),
          _Internal::scroll_window(this).GetCachedSize(), target, stream);
      break;
    }
    case kScrollContainer: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(81, _Internal::scroll_container(this),
          _Internal::scroll_container(this).GetCachedSize(), target, stream);
      break;
    }
    case kSetTouchableArea: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(82, _Internal::set_touchable_area(this),
          _Internal::set_touchable_area(this).GetCachedSize(), target, stream);
      break;
    }
    case kDeletePassword: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(83, _Internal::delete_password(this),
          _Internal::delete_password(this).GetCachedSize(), target, stream);
      break;
    }
    case kEditPassword: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(84, _Internal::edit_password(this),
          _Internal::edit_password(this).GetCachedSize(), target, stream);
      break;
    }
    case kBlurField: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(85, _Internal::blur_field(this),
          _Internal::blur_field(this).GetCachedSize(), target, stream);
      break;
    }
    case kResetPendingCredentials: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(86, _Internal::reset_pending_credentials(this),
          _Internal::reset_pending_credentials(this).GetCachedSize(), target, stream);
      break;
    }
    case kSaveSubmittedPassword: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(87, _Internal::save_submitted_password(this),
          _Internal::save_submitted_password(this).GetCachedSize(), target, stream);
      break;
    }
    case kUpdateClientSettings: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(89, _Internal::update_client_settings(this),
          _Internal::update_client_settings(this).GetCachedSize(), target, stream);
      break;
    }
    case kJsFlow: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(92, _Internal::js_flow(this),
          _Internal::js_flow(this).GetCachedSize(), target, stream);
      break;
    }
    case kExecuteJs: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(93, _Internal::execute_js(this),
          _Internal::execute_js(this).GetCachedSize(), target, stream);
      break;
    }
    case kRegisterPasswordResetRequest: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(94, _Internal::register_password_reset_request(this),
          _Internal::register_password_reset_request(this).GetCachedSize(), target, stream);
      break;
    }
    case kExternalAction: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(95, _Internal::external_action(this),
          _Internal::external_action(this).GetCachedSize(), target, stream);
      break;
    }
    case kSetNativeValue: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(96, _Internal::set_native_value(this),
          _Internal::set_native_value(this).GetCachedSize(), target, stream);
      break;
    }
    case kSetNativeChecked: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(97, _Internal::set_native_checked(this),
          _Internal::set_native_checked(this).GetCachedSize(), target, stream);
      break;
    }
    case kPromptQrCodeScan: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(98, _Internal::prompt_qr_code_scan(this),
          _Internal::prompt_qr_code_scan(this).GetCachedSize(), target, stream);
      break;
    }
    default: ;
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.ActionProto)
  return target;
}

size_t ActionProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.ActionProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional bytes server_payload = 4;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_server_payload());
    }

    // optional int32 action_delay_ms = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_action_delay_ms());
    }

    // optional bool clean_contextual_ui = 33;
    if (cached_has_bits & 0x00000004u) {
      total_size += 2 + 1;
    }

  }
  switch (action_info_case()) {
    // .autofill_assistant.SelectOptionProto select_option = 7;
    case kSelectOption: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *action_info_.select_option_);
      break;
    }
    // .autofill_assistant.NavigateProto navigate = 9;
    case kNavigate: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *action_info_.navigate_);
      break;
    }
    // .autofill_assistant.PromptProto prompt = 10;
    case kPrompt: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *action_info_.prompt_);
      break;
    }
    // .autofill_assistant.TellProto tell = 11;
    case kTell: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *action_info_.tell_);
      break;
    }
    // .autofill_assistant.ShowCastProto show_cast = 12;
    case kShowCast: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *action_info_.show_cast_);
      break;
    }
    // .autofill_assistant.WaitForDomProto wait_for_dom = 19;
    case kWaitForDom: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *action_info_.wait_for_dom_);
      break;
    }
    // .autofill_assistant.UseCreditCardProto use_card = 28;
    case kUseCard: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *action_info_.use_card_);
      break;
    }
    // .autofill_assistant.UseAddressProto use_address = 29;
    case kUseAddress: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *action_info_.use_address_);
      break;
    }
    // .autofill_assistant.UploadDomProto upload_dom = 18;
    case kUploadDom: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *action_info_.upload_dom_);
      break;
    }
    // .autofill_assistant.ShowProgressBarProto show_progress_bar = 24;
    case kShowProgressBar: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *action_info_.show_progress_bar_);
      break;
    }
    // .autofill_assistant.ShowDetailsProto show_details = 32;
    case kShowDetails: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *action_info_.show_details_);
      break;
    }
    // .autofill_assistant.StopProto stop = 35;
    case kStop: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *action_info_.stop_);
      break;
    }
    // .autofill_assistant.CollectUserDataProto collect_user_data = 36;
    case kCollectUserData: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *action_info_.collect_user_data_);
      break;
    }
    // .autofill_assistant.SetAttributeProto set_attribute = 37;
    case kSetAttribute: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *action_info_.set_attribute_);
      break;
    }
    // .autofill_assistant.ShowInfoBoxProto show_info_box = 39;
    case kShowInfoBox: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *action_info_.show_info_box_);
      break;
    }
    // .autofill_assistant.ExpectNavigationProto expect_navigation = 40;
    case kExpectNavigation: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *action_info_.expect_navigation_);
      break;
    }
    // .autofill_assistant.WaitForNavigationProto wait_for_navigation = 41;
    case kWaitForNavigation: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *action_info_.wait_for_navigation_);
      break;
    }
    // .autofill_assistant.ConfigureBottomSheetProto configure_bottom_sheet = 42;
    case kConfigureBottomSheet: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *action_info_.configure_bottom_sheet_);
      break;
    }
    // .autofill_assistant.ShowFormProto show_form = 43;
    case kShowForm: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *action_info_.show_form_);
      break;
    }
    // .autofill_assistant.PopupMessageProto popup_message = 44;
    case kPopupMessage: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *action_info_.popup_message_);
      break;
    }
    // .autofill_assistant.WaitForDocumentProto wait_for_document = 45;
    case kWaitForDocument: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *action_info_.wait_for_document_);
      break;
    }
    // .autofill_assistant.ShowGenericUiProto show_generic_ui = 49;
    case kShowGenericUi: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *action_info_.show_generic_ui_);
      break;
    }
    // .autofill_assistant.GeneratePasswordForFormFieldProto generate_password_for_form_field = 52;
    case kGeneratePasswordForFormField: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *action_info_.generate_password_for_form_field_);
      break;
    }
    // .autofill_assistant.SaveGeneratedPasswordProto save_generated_password = 53;
    case kSaveGeneratedPassword: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *action_info_.save_generated_password_);
      break;
    }
    // .autofill_assistant.ConfigureUiStateProto configure_ui_state = 54;
    case kConfigureUiState: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *action_info_.configure_ui_state_);
      break;
    }
    // .autofill_assistant.PresaveGeneratedPasswordProto presave_generated_password = 55;
    case kPresaveGeneratedPassword: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *action_info_.presave_generated_password_);
      break;
    }
    // .autofill_assistant.GetElementStatusProto get_element_status = 56;
    case kGetElementStatus: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *action_info_.get_element_status_);
      break;
    }
    // .autofill_assistant.ScrollIntoViewProto scroll_into_view = 57;
    case kScrollIntoView: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *action_info_.scroll_into_view_);
      break;
    }
    // .autofill_assistant.WaitForDocumentToBecomeInteractiveProto wait_for_document_to_become_interactive = 58;
    case kWaitForDocumentToBecomeInteractive: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *action_info_.wait_for_document_to_become_interactive_);
      break;
    }
    // .autofill_assistant.WaitForDocumentToBecomeCompleteProto wait_for_document_to_become_complete = 59;
    case kWaitForDocumentToBecomeComplete: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *action_info_.wait_for_document_to_become_complete_);
      break;
    }
    // .autofill_assistant.SendClickEventProto send_click_event = 60;
    case kSendClickEvent: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *action_info_.send_click_event_);
      break;
    }
    // .autofill_assistant.SendTapEventProto send_tap_event = 61;
    case kSendTapEvent: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *action_info_.send_tap_event_);
      break;
    }
    // .autofill_assistant.JsClickProto js_click = 62;
    case kJsClick: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *action_info_.js_click_);
      break;
    }
    // .autofill_assistant.SendKeystrokeEventsProto send_keystroke_events = 63;
    case kSendKeystrokeEvents: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *action_info_.send_keystroke_events_);
      break;
    }
    // .autofill_assistant.SendChangeEventProto send_change_event = 64;
    case kSendChangeEvent: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *action_info_.send_change_event_);
      break;
    }
    // .autofill_assistant.SetElementAttributeProto set_element_attribute = 65;
    case kSetElementAttribute: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *action_info_.set_element_attribute_);
      break;
    }
    // .autofill_assistant.SelectFieldValueProto select_field_value = 66;
    case kSelectFieldValue: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *action_info_.select_field_value_);
      break;
    }
    // .autofill_assistant.FocusFieldProto focus_field = 67;
    case kFocusField: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *action_info_.focus_field_);
      break;
    }
    // .autofill_assistant.WaitForElementToBecomeStableProto wait_for_element_to_become_stable = 68;
    case kWaitForElementToBecomeStable: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *action_info_.wait_for_element_to_become_stable_);
      break;
    }
    // .autofill_assistant.CheckElementIsOnTopProto check_element_is_on_top = 69;
    case kCheckElementIsOnTop: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *action_info_.check_element_is_on_top_);
      break;
    }
    // .autofill_assistant.ReleaseElementsProto release_elements = 70;
    case kReleaseElements: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *action_info_.release_elements_);
      break;
    }
    // .autofill_assistant.DispatchJsEventProto dispatch_js_event = 72;
    case kDispatchJsEvent: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *action_info_.dispatch_js_event_);
      break;
    }
    // .autofill_assistant.SendKeyEventProto send_key_event = 73;
    case kSendKeyEvent: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *action_info_.send_key_event_);
      break;
    }
    // .autofill_assistant.SelectOptionElementProto select_option_element = 74;
    case kSelectOptionElement: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *action_info_.select_option_element_);
      break;
    }
    // .autofill_assistant.CheckElementTagProto check_element_tag = 75;
    case kCheckElementTag: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *action_info_.check_element_tag_);
      break;
    }
    // .autofill_assistant.CheckOptionElementProto check_option_element = 76;
    case kCheckOptionElement: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *action_info_.check_option_element_);
      break;
    }
    // .autofill_assistant.SetPersistentUiProto set_persistent_ui = 77;
    case kSetPersistentUi: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *action_info_.set_persistent_ui_);
      break;
    }
    // .autofill_assistant.ClearPersistentUiProto clear_persistent_ui = 78;
    case kClearPersistentUi: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *action_info_.clear_persistent_ui_);
      break;
    }
    // .autofill_assistant.ScrollIntoViewIfNeededProto scroll_into_view_if_needed = 79;
    case kScrollIntoViewIfNeeded: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *action_info_.scroll_into_view_if_needed_);
      break;
    }
    // .autofill_assistant.ScrollWindowProto scroll_window = 80;
    case kScrollWindow: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *action_info_.scroll_window_);
      break;
    }
    // .autofill_assistant.ScrollContainerProto scroll_container = 81;
    case kScrollContainer: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *action_info_.scroll_container_);
      break;
    }
    // .autofill_assistant.SetTouchableAreaProto set_touchable_area = 82;
    case kSetTouchableArea: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *action_info_.set_touchable_area_);
      break;
    }
    // .autofill_assistant.DeleteSelectedPasswordProto delete_password = 83;
    case kDeletePassword: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *action_info_.delete_password_);
      break;
    }
    // .autofill_assistant.EditSelectedPasswordProto edit_password = 84;
    case kEditPassword: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *action_info_.edit_password_);
      break;
    }
    // .autofill_assistant.BlurFieldProto blur_field = 85;
    case kBlurField: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *action_info_.blur_field_);
      break;
    }
    // .autofill_assistant.ResetPendingCredentialsProto reset_pending_credentials = 86;
    case kResetPendingCredentials: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *action_info_.reset_pending_credentials_);
      break;
    }
    // .autofill_assistant.SaveSubmittedPasswordProto save_submitted_password = 87;
    case kSaveSubmittedPassword: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *action_info_.save_submitted_password_);
      break;
    }
    // .autofill_assistant.UpdateClientSettingsProto update_client_settings = 89;
    case kUpdateClientSettings: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *action_info_.update_client_settings_);
      break;
    }
    // .autofill_assistant.JsFlowProto js_flow = 92;
    case kJsFlow: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *action_info_.js_flow_);
      break;
    }
    // .autofill_assistant.ExecuteJsProto execute_js = 93;
    case kExecuteJs: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *action_info_.execute_js_);
      break;
    }
    // .autofill_assistant.RegisterPasswordResetRequestProto register_password_reset_request = 94;
    case kRegisterPasswordResetRequest: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *action_info_.register_password_reset_request_);
      break;
    }
    // .autofill_assistant.ExternalActionProto external_action = 95;
    case kExternalAction: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *action_info_.external_action_);
      break;
    }
    // .autofill_assistant.SetNativeValueProto set_native_value = 96;
    case kSetNativeValue: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *action_info_.set_native_value_);
      break;
    }
    // .autofill_assistant.SetNativeCheckedProto set_native_checked = 97;
    case kSetNativeChecked: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *action_info_.set_native_checked_);
      break;
    }
    // .autofill_assistant.PromptQrCodeScanProto prompt_qr_code_scan = 98;
    case kPromptQrCodeScan: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *action_info_.prompt_qr_code_scan_);
      break;
    }
    case ACTION_INFO_NOT_SET: {
      break;
    }
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ActionProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ActionProto*>(
      &from));
}

void ActionProto::MergeFrom(const ActionProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.ActionProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_server_payload(from._internal_server_payload());
    }
    if (cached_has_bits & 0x00000002u) {
      action_delay_ms_ = from.action_delay_ms_;
    }
    if (cached_has_bits & 0x00000004u) {
      clean_contextual_ui_ = from.clean_contextual_ui_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  switch (from.action_info_case()) {
    case kSelectOption: {
      _internal_mutable_select_option()->::autofill_assistant::SelectOptionProto::MergeFrom(from._internal_select_option());
      break;
    }
    case kNavigate: {
      _internal_mutable_navigate()->::autofill_assistant::NavigateProto::MergeFrom(from._internal_navigate());
      break;
    }
    case kPrompt: {
      _internal_mutable_prompt()->::autofill_assistant::PromptProto::MergeFrom(from._internal_prompt());
      break;
    }
    case kTell: {
      _internal_mutable_tell()->::autofill_assistant::TellProto::MergeFrom(from._internal_tell());
      break;
    }
    case kShowCast: {
      _internal_mutable_show_cast()->::autofill_assistant::ShowCastProto::MergeFrom(from._internal_show_cast());
      break;
    }
    case kWaitForDom: {
      _internal_mutable_wait_for_dom()->::autofill_assistant::WaitForDomProto::MergeFrom(from._internal_wait_for_dom());
      break;
    }
    case kUseCard: {
      _internal_mutable_use_card()->::autofill_assistant::UseCreditCardProto::MergeFrom(from._internal_use_card());
      break;
    }
    case kUseAddress: {
      _internal_mutable_use_address()->::autofill_assistant::UseAddressProto::MergeFrom(from._internal_use_address());
      break;
    }
    case kUploadDom: {
      _internal_mutable_upload_dom()->::autofill_assistant::UploadDomProto::MergeFrom(from._internal_upload_dom());
      break;
    }
    case kShowProgressBar: {
      _internal_mutable_show_progress_bar()->::autofill_assistant::ShowProgressBarProto::MergeFrom(from._internal_show_progress_bar());
      break;
    }
    case kShowDetails: {
      _internal_mutable_show_details()->::autofill_assistant::ShowDetailsProto::MergeFrom(from._internal_show_details());
      break;
    }
    case kStop: {
      _internal_mutable_stop()->::autofill_assistant::StopProto::MergeFrom(from._internal_stop());
      break;
    }
    case kCollectUserData: {
      _internal_mutable_collect_user_data()->::autofill_assistant::CollectUserDataProto::MergeFrom(from._internal_collect_user_data());
      break;
    }
    case kSetAttribute: {
      _internal_mutable_set_attribute()->::autofill_assistant::SetAttributeProto::MergeFrom(from._internal_set_attribute());
      break;
    }
    case kShowInfoBox: {
      _internal_mutable_show_info_box()->::autofill_assistant::ShowInfoBoxProto::MergeFrom(from._internal_show_info_box());
      break;
    }
    case kExpectNavigation: {
      _internal_mutable_expect_navigation()->::autofill_assistant::ExpectNavigationProto::MergeFrom(from._internal_expect_navigation());
      break;
    }
    case kWaitForNavigation: {
      _internal_mutable_wait_for_navigation()->::autofill_assistant::WaitForNavigationProto::MergeFrom(from._internal_wait_for_navigation());
      break;
    }
    case kConfigureBottomSheet: {
      _internal_mutable_configure_bottom_sheet()->::autofill_assistant::ConfigureBottomSheetProto::MergeFrom(from._internal_configure_bottom_sheet());
      break;
    }
    case kShowForm: {
      _internal_mutable_show_form()->::autofill_assistant::ShowFormProto::MergeFrom(from._internal_show_form());
      break;
    }
    case kPopupMessage: {
      _internal_mutable_popup_message()->::autofill_assistant::PopupMessageProto::MergeFrom(from._internal_popup_message());
      break;
    }
    case kWaitForDocument: {
      _internal_mutable_wait_for_document()->::autofill_assistant::WaitForDocumentProto::MergeFrom(from._internal_wait_for_document());
      break;
    }
    case kShowGenericUi: {
      _internal_mutable_show_generic_ui()->::autofill_assistant::ShowGenericUiProto::MergeFrom(from._internal_show_generic_ui());
      break;
    }
    case kGeneratePasswordForFormField: {
      _internal_mutable_generate_password_for_form_field()->::autofill_assistant::GeneratePasswordForFormFieldProto::MergeFrom(from._internal_generate_password_for_form_field());
      break;
    }
    case kSaveGeneratedPassword: {
      _internal_mutable_save_generated_password()->::autofill_assistant::SaveGeneratedPasswordProto::MergeFrom(from._internal_save_generated_password());
      break;
    }
    case kConfigureUiState: {
      _internal_mutable_configure_ui_state()->::autofill_assistant::ConfigureUiStateProto::MergeFrom(from._internal_configure_ui_state());
      break;
    }
    case kPresaveGeneratedPassword: {
      _internal_mutable_presave_generated_password()->::autofill_assistant::PresaveGeneratedPasswordProto::MergeFrom(from._internal_presave_generated_password());
      break;
    }
    case kGetElementStatus: {
      _internal_mutable_get_element_status()->::autofill_assistant::GetElementStatusProto::MergeFrom(from._internal_get_element_status());
      break;
    }
    case kScrollIntoView: {
      _internal_mutable_scroll_into_view()->::autofill_assistant::ScrollIntoViewProto::MergeFrom(from._internal_scroll_into_view());
      break;
    }
    case kWaitForDocumentToBecomeInteractive: {
      _internal_mutable_wait_for_document_to_become_interactive()->::autofill_assistant::WaitForDocumentToBecomeInteractiveProto::MergeFrom(from._internal_wait_for_document_to_become_interactive());
      break;
    }
    case kWaitForDocumentToBecomeComplete: {
      _internal_mutable_wait_for_document_to_become_complete()->::autofill_assistant::WaitForDocumentToBecomeCompleteProto::MergeFrom(from._internal_wait_for_document_to_become_complete());
      break;
    }
    case kSendClickEvent: {
      _internal_mutable_send_click_event()->::autofill_assistant::SendClickEventProto::MergeFrom(from._internal_send_click_event());
      break;
    }
    case kSendTapEvent: {
      _internal_mutable_send_tap_event()->::autofill_assistant::SendTapEventProto::MergeFrom(from._internal_send_tap_event());
      break;
    }
    case kJsClick: {
      _internal_mutable_js_click()->::autofill_assistant::JsClickProto::MergeFrom(from._internal_js_click());
      break;
    }
    case kSendKeystrokeEvents: {
      _internal_mutable_send_keystroke_events()->::autofill_assistant::SendKeystrokeEventsProto::MergeFrom(from._internal_send_keystroke_events());
      break;
    }
    case kSendChangeEvent: {
      _internal_mutable_send_change_event()->::autofill_assistant::SendChangeEventProto::MergeFrom(from._internal_send_change_event());
      break;
    }
    case kSetElementAttribute: {
      _internal_mutable_set_element_attribute()->::autofill_assistant::SetElementAttributeProto::MergeFrom(from._internal_set_element_attribute());
      break;
    }
    case kSelectFieldValue: {
      _internal_mutable_select_field_value()->::autofill_assistant::SelectFieldValueProto::MergeFrom(from._internal_select_field_value());
      break;
    }
    case kFocusField: {
      _internal_mutable_focus_field()->::autofill_assistant::FocusFieldProto::MergeFrom(from._internal_focus_field());
      break;
    }
    case kWaitForElementToBecomeStable: {
      _internal_mutable_wait_for_element_to_become_stable()->::autofill_assistant::WaitForElementToBecomeStableProto::MergeFrom(from._internal_wait_for_element_to_become_stable());
      break;
    }
    case kCheckElementIsOnTop: {
      _internal_mutable_check_element_is_on_top()->::autofill_assistant::CheckElementIsOnTopProto::MergeFrom(from._internal_check_element_is_on_top());
      break;
    }
    case kReleaseElements: {
      _internal_mutable_release_elements()->::autofill_assistant::ReleaseElementsProto::MergeFrom(from._internal_release_elements());
      break;
    }
    case kDispatchJsEvent: {
      _internal_mutable_dispatch_js_event()->::autofill_assistant::DispatchJsEventProto::MergeFrom(from._internal_dispatch_js_event());
      break;
    }
    case kSendKeyEvent: {
      _internal_mutable_send_key_event()->::autofill_assistant::SendKeyEventProto::MergeFrom(from._internal_send_key_event());
      break;
    }
    case kSelectOptionElement: {
      _internal_mutable_select_option_element()->::autofill_assistant::SelectOptionElementProto::MergeFrom(from._internal_select_option_element());
      break;
    }
    case kCheckElementTag: {
      _internal_mutable_check_element_tag()->::autofill_assistant::CheckElementTagProto::MergeFrom(from._internal_check_element_tag());
      break;
    }
    case kCheckOptionElement: {
      _internal_mutable_check_option_element()->::autofill_assistant::CheckOptionElementProto::MergeFrom(from._internal_check_option_element());
      break;
    }
    case kSetPersistentUi: {
      _internal_mutable_set_persistent_ui()->::autofill_assistant::SetPersistentUiProto::MergeFrom(from._internal_set_persistent_ui());
      break;
    }
    case kClearPersistentUi: {
      _internal_mutable_clear_persistent_ui()->::autofill_assistant::ClearPersistentUiProto::MergeFrom(from._internal_clear_persistent_ui());
      break;
    }
    case kScrollIntoViewIfNeeded: {
      _internal_mutable_scroll_into_view_if_needed()->::autofill_assistant::ScrollIntoViewIfNeededProto::MergeFrom(from._internal_scroll_into_view_if_needed());
      break;
    }
    case kScrollWindow: {
      _internal_mutable_scroll_window()->::autofill_assistant::ScrollWindowProto::MergeFrom(from._internal_scroll_window());
      break;
    }
    case kScrollContainer: {
      _internal_mutable_scroll_container()->::autofill_assistant::ScrollContainerProto::MergeFrom(from._internal_scroll_container());
      break;
    }
    case kSetTouchableArea: {
      _internal_mutable_set_touchable_area()->::autofill_assistant::SetTouchableAreaProto::MergeFrom(from._internal_set_touchable_area());
      break;
    }
    case kDeletePassword: {
      _internal_mutable_delete_password()->::autofill_assistant::DeleteSelectedPasswordProto::MergeFrom(from._internal_delete_password());
      break;
    }
    case kEditPassword: {
      _internal_mutable_edit_password()->::autofill_assistant::EditSelectedPasswordProto::MergeFrom(from._internal_edit_password());
      break;
    }
    case kBlurField: {
      _internal_mutable_blur_field()->::autofill_assistant::BlurFieldProto::MergeFrom(from._internal_blur_field());
      break;
    }
    case kResetPendingCredentials: {
      _internal_mutable_reset_pending_credentials()->::autofill_assistant::ResetPendingCredentialsProto::MergeFrom(from._internal_reset_pending_credentials());
      break;
    }
    case kSaveSubmittedPassword: {
      _internal_mutable_save_submitted_password()->::autofill_assistant::SaveSubmittedPasswordProto::MergeFrom(from._internal_save_submitted_password());
      break;
    }
    case kUpdateClientSettings: {
      _internal_mutable_update_client_settings()->::autofill_assistant::UpdateClientSettingsProto::MergeFrom(from._internal_update_client_settings());
      break;
    }
    case kJsFlow: {
      _internal_mutable_js_flow()->::autofill_assistant::JsFlowProto::MergeFrom(from._internal_js_flow());
      break;
    }
    case kExecuteJs: {
      _internal_mutable_execute_js()->::autofill_assistant::ExecuteJsProto::MergeFrom(from._internal_execute_js());
      break;
    }
    case kRegisterPasswordResetRequest: {
      _internal_mutable_register_password_reset_request()->::autofill_assistant::RegisterPasswordResetRequestProto::MergeFrom(from._internal_register_password_reset_request());
      break;
    }
    case kExternalAction: {
      _internal_mutable_external_action()->::autofill_assistant::ExternalActionProto::MergeFrom(from._internal_external_action());
      break;
    }
    case kSetNativeValue: {
      _internal_mutable_set_native_value()->::autofill_assistant::SetNativeValueProto::MergeFrom(from._internal_set_native_value());
      break;
    }
    case kSetNativeChecked: {
      _internal_mutable_set_native_checked()->::autofill_assistant::SetNativeCheckedProto::MergeFrom(from._internal_set_native_checked());
      break;
    }
    case kPromptQrCodeScan: {
      _internal_mutable_prompt_qr_code_scan()->::autofill_assistant::PromptQrCodeScanProto::MergeFrom(from._internal_prompt_qr_code_scan());
      break;
    }
    case ACTION_INFO_NOT_SET: {
      break;
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ActionProto::CopyFrom(const ActionProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.ActionProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ActionProto::IsInitialized() const {
  switch (action_info_case()) {
    case kSelectOption: {
      break;
    }
    case kNavigate: {
      break;
    }
    case kPrompt: {
      break;
    }
    case kTell: {
      break;
    }
    case kShowCast: {
      break;
    }
    case kWaitForDom: {
      break;
    }
    case kUseCard: {
      break;
    }
    case kUseAddress: {
      break;
    }
    case kUploadDom: {
      break;
    }
    case kShowProgressBar: {
      break;
    }
    case kShowDetails: {
      break;
    }
    case kStop: {
      break;
    }
    case kCollectUserData: {
      break;
    }
    case kSetAttribute: {
      break;
    }
    case kShowInfoBox: {
      break;
    }
    case kExpectNavigation: {
      break;
    }
    case kWaitForNavigation: {
      break;
    }
    case kConfigureBottomSheet: {
      break;
    }
    case kShowForm: {
      break;
    }
    case kPopupMessage: {
      break;
    }
    case kWaitForDocument: {
      break;
    }
    case kShowGenericUi: {
      break;
    }
    case kGeneratePasswordForFormField: {
      break;
    }
    case kSaveGeneratedPassword: {
      break;
    }
    case kConfigureUiState: {
      break;
    }
    case kPresaveGeneratedPassword: {
      break;
    }
    case kGetElementStatus: {
      break;
    }
    case kScrollIntoView: {
      break;
    }
    case kWaitForDocumentToBecomeInteractive: {
      break;
    }
    case kWaitForDocumentToBecomeComplete: {
      break;
    }
    case kSendClickEvent: {
      break;
    }
    case kSendTapEvent: {
      break;
    }
    case kJsClick: {
      break;
    }
    case kSendKeystrokeEvents: {
      break;
    }
    case kSendChangeEvent: {
      break;
    }
    case kSetElementAttribute: {
      break;
    }
    case kSelectFieldValue: {
      break;
    }
    case kFocusField: {
      break;
    }
    case kWaitForElementToBecomeStable: {
      break;
    }
    case kCheckElementIsOnTop: {
      break;
    }
    case kReleaseElements: {
      break;
    }
    case kDispatchJsEvent: {
      break;
    }
    case kSendKeyEvent: {
      break;
    }
    case kSelectOptionElement: {
      break;
    }
    case kCheckElementTag: {
      break;
    }
    case kCheckOptionElement: {
      break;
    }
    case kSetPersistentUi: {
      break;
    }
    case kClearPersistentUi: {
      break;
    }
    case kScrollIntoViewIfNeeded: {
      break;
    }
    case kScrollWindow: {
      break;
    }
    case kScrollContainer: {
      break;
    }
    case kSetTouchableArea: {
      break;
    }
    case kDeletePassword: {
      break;
    }
    case kEditPassword: {
      break;
    }
    case kBlurField: {
      break;
    }
    case kResetPendingCredentials: {
      break;
    }
    case kSaveSubmittedPassword: {
      break;
    }
    case kUpdateClientSettings: {
      break;
    }
    case kJsFlow: {
      break;
    }
    case kExecuteJs: {
      break;
    }
    case kRegisterPasswordResetRequest: {
      break;
    }
    case kExternalAction: {
      if (_internal_has_external_action()) {
        if (!action_info_.external_action_->IsInitialized()) return false;
      }
      break;
    }
    case kSetNativeValue: {
      break;
    }
    case kSetNativeChecked: {
      break;
    }
    case kPromptQrCodeScan: {
      break;
    }
    case ACTION_INFO_NOT_SET: {
      break;
    }
  }
  return true;
}

void ActionProto::InternalSwap(ActionProto* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &server_payload_, lhs_arena,
      &other->server_payload_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ActionProto, clean_contextual_ui_)
      + sizeof(ActionProto::clean_contextual_ui_)
      - PROTOBUF_FIELD_OFFSET(ActionProto, action_delay_ms_)>(
          reinterpret_cast<char*>(&action_delay_ms_),
          reinterpret_cast<char*>(&other->action_delay_ms_));
  swap(action_info_, other->action_info_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

std::string ActionProto::GetTypeName() const {
  return "autofill_assistant.ActionProto";
}


// ===================================================================

class CollectUserDataResultProto::_Internal {
 public:
  using HasBits = decltype(std::declval<CollectUserDataResultProto>()._has_bits_);
  static void set_has_card_issuer_network(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_is_terms_and_conditions_accepted(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_payer_email(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_additional_action_index(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_terms_link(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::autofill_assistant::ModelProto& model(const CollectUserDataResultProto* msg);
  static void set_has_model(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_shown_to_user(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_login_missing_username(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
};

const ::autofill_assistant::ModelProto&
CollectUserDataResultProto::_Internal::model(const CollectUserDataResultProto* msg) {
  return *msg->model_;
}
void CollectUserDataResultProto::clear_model() {
  if (model_ != nullptr) model_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
void CollectUserDataResultProto::clear_additional_sections_values() {
  additional_sections_values_.Clear();
}
CollectUserDataResultProto::CollectUserDataResultProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  set_text_input_memory_keys_(arena),
  additional_sections_values_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.CollectUserDataResultProto)
}
CollectUserDataResultProto::CollectUserDataResultProto(const CollectUserDataResultProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      set_text_input_memory_keys_(from.set_text_input_memory_keys_),
      additional_sections_values_(from.additional_sections_values_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  card_issuer_network_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    card_issuer_network_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_card_issuer_network()) {
    card_issuer_network_.Set(from._internal_card_issuer_network(), 
      GetArenaForAllocation());
  }
  payer_email_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    payer_email_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_payer_email()) {
    payer_email_.Set(from._internal_payer_email(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_model()) {
    model_ = new ::autofill_assistant::ModelProto(*from.model_);
  } else {
    model_ = nullptr;
  }
  ::memcpy(&additional_action_index_, &from.additional_action_index_,
    static_cast<size_t>(reinterpret_cast<char*>(&login_missing_username_) -
    reinterpret_cast<char*>(&additional_action_index_)) + sizeof(login_missing_username_));
  clear_has_payload_or_tag();
  switch (from.payload_or_tag_case()) {
    case kLoginPayload: {
      _internal_set_login_payload(from._internal_login_payload());
      break;
    }
    case kLoginTag: {
      _internal_set_login_tag(from._internal_login_tag());
      break;
    }
    case PAYLOAD_OR_TAG_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.CollectUserDataResultProto)
}

inline void CollectUserDataResultProto::SharedCtor() {
card_issuer_network_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  card_issuer_network_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
payer_email_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  payer_email_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&model_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&login_missing_username_) -
    reinterpret_cast<char*>(&model_)) + sizeof(login_missing_username_));
clear_has_payload_or_tag();
}

CollectUserDataResultProto::~CollectUserDataResultProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.CollectUserDataResultProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CollectUserDataResultProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  card_issuer_network_.Destroy();
  payer_email_.Destroy();
  if (this != internal_default_instance()) delete model_;
  if (has_payload_or_tag()) {
    clear_payload_or_tag();
  }
}

void CollectUserDataResultProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CollectUserDataResultProto::clear_payload_or_tag() {
// @@protoc_insertion_point(one_of_clear_start:autofill_assistant.CollectUserDataResultProto)
  switch (payload_or_tag_case()) {
    case kLoginPayload: {
      payload_or_tag_.login_payload_.Destroy();
      break;
    }
    case kLoginTag: {
      payload_or_tag_.login_tag_.Destroy();
      break;
    }
    case PAYLOAD_OR_TAG_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = PAYLOAD_OR_TAG_NOT_SET;
}


void CollectUserDataResultProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.CollectUserDataResultProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  set_text_input_memory_keys_.Clear();
  additional_sections_values_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      card_issuer_network_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      payer_email_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(model_ != nullptr);
      model_->Clear();
    }
  }
  if (cached_has_bits & 0x000000f8u) {
    ::memset(&additional_action_index_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&login_missing_username_) -
        reinterpret_cast<char*>(&additional_action_index_)) + sizeof(login_missing_username_));
  }
  clear_payload_or_tag();
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CollectUserDataResultProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string card_issuer_network = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_card_issuer_network();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_terms_and_conditions_accepted = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_is_terms_and_conditions_accepted(&has_bits);
          is_terms_and_conditions_accepted_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string payer_email = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_payer_email();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 additional_action_index = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_additional_action_index(&has_bits);
          additional_action_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 terms_link = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_terms_link(&has_bits);
          terms_link_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes login_payload = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_login_payload();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .autofill_assistant.ModelProto model = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_model(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated string set_text_input_memory_keys = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_set_text_input_memory_keys();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<82>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .autofill_assistant.ModelProto.ModelValue additional_sections_values = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 122)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_additional_sections_values(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<122>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional bool shown_to_user = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 128)) {
          _Internal::set_has_shown_to_user(&has_bits);
          shown_to_user_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool login_missing_username = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 136)) {
          _Internal::set_has_login_missing_username(&has_bits);
          login_missing_username_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string login_tag = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 170)) {
          auto str = _internal_mutable_login_tag();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CollectUserDataResultProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.CollectUserDataResultProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string card_issuer_network = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_card_issuer_network(), target);
  }

  // optional bool is_terms_and_conditions_accepted = 2;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_is_terms_and_conditions_accepted(), target);
  }

  // optional string payer_email = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_payer_email(), target);
  }

  // optional int32 additional_action_index = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_additional_action_index(), target);
  }

  // optional int32 terms_link = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_terms_link(), target);
  }

  // bytes login_payload = 6;
  if (_internal_has_login_payload()) {
    target = stream->WriteBytesMaybeAliased(
        6, this->_internal_login_payload(), target);
  }

  // optional .autofill_assistant.ModelProto model = 9;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(9, _Internal::model(this),
        _Internal::model(this).GetCachedSize(), target, stream);
  }

  // repeated string set_text_input_memory_keys = 10;
  for (int i = 0, n = this->_internal_set_text_input_memory_keys_size(); i < n; i++) {
    const auto& s = this->_internal_set_text_input_memory_keys(i);
    target = stream->WriteString(10, s, target);
  }

  // repeated .autofill_assistant.ModelProto.ModelValue additional_sections_values = 15;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_additional_sections_values_size()); i < n; i++) {
    const auto& repfield = this->_internal_additional_sections_values(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(15, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional bool shown_to_user = 16;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(16, this->_internal_shown_to_user(), target);
  }

  // optional bool login_missing_username = 17;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(17, this->_internal_login_missing_username(), target);
  }

  // string login_tag = 21;
  if (_internal_has_login_tag()) {
    target = stream->WriteStringMaybeAliased(
        21, this->_internal_login_tag(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.CollectUserDataResultProto)
  return target;
}

size_t CollectUserDataResultProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.CollectUserDataResultProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string set_text_input_memory_keys = 10;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(set_text_input_memory_keys_.size());
  for (int i = 0, n = set_text_input_memory_keys_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      set_text_input_memory_keys_.Get(i));
  }

  // repeated .autofill_assistant.ModelProto.ModelValue additional_sections_values = 15;
  total_size += 1UL * this->_internal_additional_sections_values_size();
  for (const auto& msg : this->additional_sections_values_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string card_issuer_network = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_card_issuer_network());
    }

    // optional string payer_email = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_payer_email());
    }

    // optional .autofill_assistant.ModelProto model = 9;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *model_);
    }

    // optional int32 additional_action_index = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_additional_action_index());
    }

    // optional int32 terms_link = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_terms_link());
    }

    // optional bool is_terms_and_conditions_accepted = 2;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 1;
    }

    // optional bool shown_to_user = 16;
    if (cached_has_bits & 0x00000040u) {
      total_size += 2 + 1;
    }

    // optional bool login_missing_username = 17;
    if (cached_has_bits & 0x00000080u) {
      total_size += 2 + 1;
    }

  }
  switch (payload_or_tag_case()) {
    // bytes login_payload = 6;
    case kLoginPayload: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_login_payload());
      break;
    }
    // string login_tag = 21;
    case kLoginTag: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_login_tag());
      break;
    }
    case PAYLOAD_OR_TAG_NOT_SET: {
      break;
    }
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CollectUserDataResultProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CollectUserDataResultProto*>(
      &from));
}

void CollectUserDataResultProto::MergeFrom(const CollectUserDataResultProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.CollectUserDataResultProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  set_text_input_memory_keys_.MergeFrom(from.set_text_input_memory_keys_);
  additional_sections_values_.MergeFrom(from.additional_sections_values_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_card_issuer_network(from._internal_card_issuer_network());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_payer_email(from._internal_payer_email());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_model()->::autofill_assistant::ModelProto::MergeFrom(from._internal_model());
    }
    if (cached_has_bits & 0x00000008u) {
      additional_action_index_ = from.additional_action_index_;
    }
    if (cached_has_bits & 0x00000010u) {
      terms_link_ = from.terms_link_;
    }
    if (cached_has_bits & 0x00000020u) {
      is_terms_and_conditions_accepted_ = from.is_terms_and_conditions_accepted_;
    }
    if (cached_has_bits & 0x00000040u) {
      shown_to_user_ = from.shown_to_user_;
    }
    if (cached_has_bits & 0x00000080u) {
      login_missing_username_ = from.login_missing_username_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  switch (from.payload_or_tag_case()) {
    case kLoginPayload: {
      _internal_set_login_payload(from._internal_login_payload());
      break;
    }
    case kLoginTag: {
      _internal_set_login_tag(from._internal_login_tag());
      break;
    }
    case PAYLOAD_OR_TAG_NOT_SET: {
      break;
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CollectUserDataResultProto::CopyFrom(const CollectUserDataResultProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.CollectUserDataResultProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CollectUserDataResultProto::IsInitialized() const {
  return true;
}

void CollectUserDataResultProto::InternalSwap(CollectUserDataResultProto* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  set_text_input_memory_keys_.InternalSwap(&other->set_text_input_memory_keys_);
  additional_sections_values_.InternalSwap(&other->additional_sections_values_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &card_issuer_network_, lhs_arena,
      &other->card_issuer_network_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &payer_email_, lhs_arena,
      &other->payer_email_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CollectUserDataResultProto, login_missing_username_)
      + sizeof(CollectUserDataResultProto::login_missing_username_)
      - PROTOBUF_FIELD_OFFSET(CollectUserDataResultProto, model_)>(
          reinterpret_cast<char*>(&model_),
          reinterpret_cast<char*>(&other->model_));
  swap(payload_or_tag_, other->payload_or_tag_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

std::string CollectUserDataResultProto::GetTypeName() const {
  return "autofill_assistant.CollectUserDataResultProto";
}


// ===================================================================

class ActionTimingStats::_Internal {
 public:
  using HasBits = decltype(std::declval<ActionTimingStats>()._has_bits_);
  static void set_has_delay_ms(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_active_time_ms(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_wait_time_ms(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

ActionTimingStats::ActionTimingStats(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.ActionTimingStats)
}
ActionTimingStats::ActionTimingStats(const ActionTimingStats& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&delay_ms_, &from.delay_ms_,
    static_cast<size_t>(reinterpret_cast<char*>(&wait_time_ms_) -
    reinterpret_cast<char*>(&delay_ms_)) + sizeof(wait_time_ms_));
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.ActionTimingStats)
}

inline void ActionTimingStats::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&delay_ms_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&wait_time_ms_) -
    reinterpret_cast<char*>(&delay_ms_)) + sizeof(wait_time_ms_));
}

ActionTimingStats::~ActionTimingStats() {
  // @@protoc_insertion_point(destructor:autofill_assistant.ActionTimingStats)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ActionTimingStats::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ActionTimingStats::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ActionTimingStats::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.ActionTimingStats)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&delay_ms_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&wait_time_ms_) -
        reinterpret_cast<char*>(&delay_ms_)) + sizeof(wait_time_ms_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ActionTimingStats::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 delay_ms = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_delay_ms(&has_bits);
          delay_ms_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 active_time_ms = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_active_time_ms(&has_bits);
          active_time_ms_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 wait_time_ms = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_wait_time_ms(&has_bits);
          wait_time_ms_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ActionTimingStats::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.ActionTimingStats)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int64 delay_ms = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_delay_ms(), target);
  }

  // optional int64 active_time_ms = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_active_time_ms(), target);
  }

  // optional int64 wait_time_ms = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_wait_time_ms(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.ActionTimingStats)
  return target;
}

size_t ActionTimingStats::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.ActionTimingStats)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional int64 delay_ms = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_delay_ms());
    }

    // optional int64 active_time_ms = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_active_time_ms());
    }

    // optional int64 wait_time_ms = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_wait_time_ms());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ActionTimingStats::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ActionTimingStats*>(
      &from));
}

void ActionTimingStats::MergeFrom(const ActionTimingStats& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.ActionTimingStats)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      delay_ms_ = from.delay_ms_;
    }
    if (cached_has_bits & 0x00000002u) {
      active_time_ms_ = from.active_time_ms_;
    }
    if (cached_has_bits & 0x00000004u) {
      wait_time_ms_ = from.wait_time_ms_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ActionTimingStats::CopyFrom(const ActionTimingStats& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.ActionTimingStats)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ActionTimingStats::IsInitialized() const {
  return true;
}

void ActionTimingStats::InternalSwap(ActionTimingStats* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ActionTimingStats, wait_time_ms_)
      + sizeof(ActionTimingStats::wait_time_ms_)
      - PROTOBUF_FIELD_OFFSET(ActionTimingStats, delay_ms_)>(
          reinterpret_cast<char*>(&delay_ms_),
          reinterpret_cast<char*>(&other->delay_ms_));
}

std::string ActionTimingStats::GetTypeName() const {
  return "autofill_assistant.ActionTimingStats";
}


// ===================================================================

class ProcessedActionProto::_Internal {
 public:
  using HasBits = decltype(std::declval<ProcessedActionProto>()._has_bits_);
  static const ::autofill_assistant::ActionProto& action(const ProcessedActionProto* msg);
  static void set_has_action(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_status(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::autofill_assistant::ProcessedActionStatusDetailsProto& status_details(const ProcessedActionProto* msg);
  static void set_has_status_details(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::autofill_assistant::PromptProto_Result& prompt_choice(const ProcessedActionProto* msg);
  static const ::autofill_assistant::CollectUserDataResultProto& collect_user_data_result(const ProcessedActionProto* msg);
  static const ::autofill_assistant::WaitForDomProto_Result& wait_for_dom_result(const ProcessedActionProto* msg);
  static const ::autofill_assistant::FormProto_Result& form_result(const ProcessedActionProto* msg);
  static const ::autofill_assistant::WaitForDocumentProto_Result& wait_for_document_result(const ProcessedActionProto* msg);
  static const ::autofill_assistant::ShowGenericUiProto_Result& show_generic_ui_result(const ProcessedActionProto* msg);
  static const ::autofill_assistant::GetElementStatusProto_Result& get_element_status_result(const ProcessedActionProto* msg);
  static const ::autofill_assistant::UploadDomProto_Result& upload_dom_result(const ProcessedActionProto* msg);
  static const ::autofill_assistant::CheckOptionElementProto_Result& check_option_element_result(const ProcessedActionProto* msg);
  static const ::autofill_assistant::SendKeystrokeEventsProto_Result& send_key_stroke_events_result(const ProcessedActionProto* msg);
  static const ::autofill_assistant::JsFlowProto_Result& js_flow_result(const ProcessedActionProto* msg);
  static const ::autofill_assistant::SaveSubmittedPasswordProto_Result& save_submitted_password_result(const ProcessedActionProto* msg);
  static const ::autofill_assistant::ExternalActionProto_Result& external_action_result(const ProcessedActionProto* msg);
  static const ::autofill_assistant::NavigationInfoProto& navigation_info(const ProcessedActionProto* msg);
  static void set_has_navigation_info(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_run_time_ms(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static const ::autofill_assistant::ActionTimingStats& timing_stats(const ProcessedActionProto* msg);
  static void set_has_timing_stats(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_slow_warning_status(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

const ::autofill_assistant::ActionProto&
ProcessedActionProto::_Internal::action(const ProcessedActionProto* msg) {
  return *msg->action_;
}
const ::autofill_assistant::ProcessedActionStatusDetailsProto&
ProcessedActionProto::_Internal::status_details(const ProcessedActionProto* msg) {
  return *msg->status_details_;
}
const ::autofill_assistant::PromptProto_Result&
ProcessedActionProto::_Internal::prompt_choice(const ProcessedActionProto* msg) {
  return *msg->result_data_.prompt_choice_;
}
const ::autofill_assistant::CollectUserDataResultProto&
ProcessedActionProto::_Internal::collect_user_data_result(const ProcessedActionProto* msg) {
  return *msg->result_data_.collect_user_data_result_;
}
const ::autofill_assistant::WaitForDomProto_Result&
ProcessedActionProto::_Internal::wait_for_dom_result(const ProcessedActionProto* msg) {
  return *msg->result_data_.wait_for_dom_result_;
}
const ::autofill_assistant::FormProto_Result&
ProcessedActionProto::_Internal::form_result(const ProcessedActionProto* msg) {
  return *msg->result_data_.form_result_;
}
const ::autofill_assistant::WaitForDocumentProto_Result&
ProcessedActionProto::_Internal::wait_for_document_result(const ProcessedActionProto* msg) {
  return *msg->result_data_.wait_for_document_result_;
}
const ::autofill_assistant::ShowGenericUiProto_Result&
ProcessedActionProto::_Internal::show_generic_ui_result(const ProcessedActionProto* msg) {
  return *msg->result_data_.show_generic_ui_result_;
}
const ::autofill_assistant::GetElementStatusProto_Result&
ProcessedActionProto::_Internal::get_element_status_result(const ProcessedActionProto* msg) {
  return *msg->result_data_.get_element_status_result_;
}
const ::autofill_assistant::UploadDomProto_Result&
ProcessedActionProto::_Internal::upload_dom_result(const ProcessedActionProto* msg) {
  return *msg->result_data_.upload_dom_result_;
}
const ::autofill_assistant::CheckOptionElementProto_Result&
ProcessedActionProto::_Internal::check_option_element_result(const ProcessedActionProto* msg) {
  return *msg->result_data_.check_option_element_result_;
}
const ::autofill_assistant::SendKeystrokeEventsProto_Result&
ProcessedActionProto::_Internal::send_key_stroke_events_result(const ProcessedActionProto* msg) {
  return *msg->result_data_.send_key_stroke_events_result_;
}
const ::autofill_assistant::JsFlowProto_Result&
ProcessedActionProto::_Internal::js_flow_result(const ProcessedActionProto* msg) {
  return *msg->result_data_.js_flow_result_;
}
const ::autofill_assistant::SaveSubmittedPasswordProto_Result&
ProcessedActionProto::_Internal::save_submitted_password_result(const ProcessedActionProto* msg) {
  return *msg->result_data_.save_submitted_password_result_;
}
const ::autofill_assistant::ExternalActionProto_Result&
ProcessedActionProto::_Internal::external_action_result(const ProcessedActionProto* msg) {
  return *msg->result_data_.external_action_result_;
}
const ::autofill_assistant::NavigationInfoProto&
ProcessedActionProto::_Internal::navigation_info(const ProcessedActionProto* msg) {
  return *msg->navigation_info_;
}
const ::autofill_assistant::ActionTimingStats&
ProcessedActionProto::_Internal::timing_stats(const ProcessedActionProto* msg) {
  return *msg->timing_stats_;
}
void ProcessedActionProto::set_allocated_prompt_choice(::autofill_assistant::PromptProto_Result* prompt_choice) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_result_data();
  if (prompt_choice) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(prompt_choice);
    if (message_arena != submessage_arena) {
      prompt_choice = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, prompt_choice, submessage_arena);
    }
    set_has_prompt_choice();
    result_data_.prompt_choice_ = prompt_choice;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ProcessedActionProto.prompt_choice)
}
void ProcessedActionProto::set_allocated_collect_user_data_result(::autofill_assistant::CollectUserDataResultProto* collect_user_data_result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_result_data();
  if (collect_user_data_result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(collect_user_data_result);
    if (message_arena != submessage_arena) {
      collect_user_data_result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, collect_user_data_result, submessage_arena);
    }
    set_has_collect_user_data_result();
    result_data_.collect_user_data_result_ = collect_user_data_result;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ProcessedActionProto.collect_user_data_result)
}
void ProcessedActionProto::set_allocated_wait_for_dom_result(::autofill_assistant::WaitForDomProto_Result* wait_for_dom_result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_result_data();
  if (wait_for_dom_result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(wait_for_dom_result);
    if (message_arena != submessage_arena) {
      wait_for_dom_result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, wait_for_dom_result, submessage_arena);
    }
    set_has_wait_for_dom_result();
    result_data_.wait_for_dom_result_ = wait_for_dom_result;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ProcessedActionProto.wait_for_dom_result)
}
void ProcessedActionProto::set_allocated_form_result(::autofill_assistant::FormProto_Result* form_result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_result_data();
  if (form_result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(form_result);
    if (message_arena != submessage_arena) {
      form_result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, form_result, submessage_arena);
    }
    set_has_form_result();
    result_data_.form_result_ = form_result;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ProcessedActionProto.form_result)
}
void ProcessedActionProto::set_allocated_wait_for_document_result(::autofill_assistant::WaitForDocumentProto_Result* wait_for_document_result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_result_data();
  if (wait_for_document_result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(wait_for_document_result);
    if (message_arena != submessage_arena) {
      wait_for_document_result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, wait_for_document_result, submessage_arena);
    }
    set_has_wait_for_document_result();
    result_data_.wait_for_document_result_ = wait_for_document_result;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ProcessedActionProto.wait_for_document_result)
}
void ProcessedActionProto::set_allocated_show_generic_ui_result(::autofill_assistant::ShowGenericUiProto_Result* show_generic_ui_result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_result_data();
  if (show_generic_ui_result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(show_generic_ui_result);
    if (message_arena != submessage_arena) {
      show_generic_ui_result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, show_generic_ui_result, submessage_arena);
    }
    set_has_show_generic_ui_result();
    result_data_.show_generic_ui_result_ = show_generic_ui_result;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ProcessedActionProto.show_generic_ui_result)
}
void ProcessedActionProto::set_allocated_get_element_status_result(::autofill_assistant::GetElementStatusProto_Result* get_element_status_result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_result_data();
  if (get_element_status_result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(get_element_status_result);
    if (message_arena != submessage_arena) {
      get_element_status_result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, get_element_status_result, submessage_arena);
    }
    set_has_get_element_status_result();
    result_data_.get_element_status_result_ = get_element_status_result;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ProcessedActionProto.get_element_status_result)
}
void ProcessedActionProto::set_allocated_upload_dom_result(::autofill_assistant::UploadDomProto_Result* upload_dom_result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_result_data();
  if (upload_dom_result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(upload_dom_result);
    if (message_arena != submessage_arena) {
      upload_dom_result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, upload_dom_result, submessage_arena);
    }
    set_has_upload_dom_result();
    result_data_.upload_dom_result_ = upload_dom_result;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ProcessedActionProto.upload_dom_result)
}
void ProcessedActionProto::set_allocated_check_option_element_result(::autofill_assistant::CheckOptionElementProto_Result* check_option_element_result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_result_data();
  if (check_option_element_result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(check_option_element_result));
    if (message_arena != submessage_arena) {
      check_option_element_result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, check_option_element_result, submessage_arena);
    }
    set_has_check_option_element_result();
    result_data_.check_option_element_result_ = check_option_element_result;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ProcessedActionProto.check_option_element_result)
}
void ProcessedActionProto::clear_check_option_element_result() {
  if (_internal_has_check_option_element_result()) {
    if (GetArenaForAllocation() == nullptr) {
      delete result_data_.check_option_element_result_;
    }
    clear_has_result_data();
  }
}
void ProcessedActionProto::set_allocated_send_key_stroke_events_result(::autofill_assistant::SendKeystrokeEventsProto_Result* send_key_stroke_events_result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_result_data();
  if (send_key_stroke_events_result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(send_key_stroke_events_result));
    if (message_arena != submessage_arena) {
      send_key_stroke_events_result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, send_key_stroke_events_result, submessage_arena);
    }
    set_has_send_key_stroke_events_result();
    result_data_.send_key_stroke_events_result_ = send_key_stroke_events_result;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ProcessedActionProto.send_key_stroke_events_result)
}
void ProcessedActionProto::clear_send_key_stroke_events_result() {
  if (_internal_has_send_key_stroke_events_result()) {
    if (GetArenaForAllocation() == nullptr) {
      delete result_data_.send_key_stroke_events_result_;
    }
    clear_has_result_data();
  }
}
void ProcessedActionProto::set_allocated_js_flow_result(::autofill_assistant::JsFlowProto_Result* js_flow_result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_result_data();
  if (js_flow_result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(js_flow_result);
    if (message_arena != submessage_arena) {
      js_flow_result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, js_flow_result, submessage_arena);
    }
    set_has_js_flow_result();
    result_data_.js_flow_result_ = js_flow_result;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ProcessedActionProto.js_flow_result)
}
void ProcessedActionProto::set_allocated_save_submitted_password_result(::autofill_assistant::SaveSubmittedPasswordProto_Result* save_submitted_password_result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_result_data();
  if (save_submitted_password_result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(save_submitted_password_result);
    if (message_arena != submessage_arena) {
      save_submitted_password_result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, save_submitted_password_result, submessage_arena);
    }
    set_has_save_submitted_password_result();
    result_data_.save_submitted_password_result_ = save_submitted_password_result;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ProcessedActionProto.save_submitted_password_result)
}
void ProcessedActionProto::set_allocated_external_action_result(::autofill_assistant::ExternalActionProto_Result* external_action_result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_result_data();
  if (external_action_result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(external_action_result);
    if (message_arena != submessage_arena) {
      external_action_result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, external_action_result, submessage_arena);
    }
    set_has_external_action_result();
    result_data_.external_action_result_ = external_action_result;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ProcessedActionProto.external_action_result)
}
ProcessedActionProto::ProcessedActionProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.ProcessedActionProto)
}
ProcessedActionProto::ProcessedActionProto(const ProcessedActionProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_action()) {
    action_ = new ::autofill_assistant::ActionProto(*from.action_);
  } else {
    action_ = nullptr;
  }
  if (from._internal_has_status_details()) {
    status_details_ = new ::autofill_assistant::ProcessedActionStatusDetailsProto(*from.status_details_);
  } else {
    status_details_ = nullptr;
  }
  if (from._internal_has_navigation_info()) {
    navigation_info_ = new ::autofill_assistant::NavigationInfoProto(*from.navigation_info_);
  } else {
    navigation_info_ = nullptr;
  }
  if (from._internal_has_timing_stats()) {
    timing_stats_ = new ::autofill_assistant::ActionTimingStats(*from.timing_stats_);
  } else {
    timing_stats_ = nullptr;
  }
  ::memcpy(&status_, &from.status_,
    static_cast<size_t>(reinterpret_cast<char*>(&run_time_ms_) -
    reinterpret_cast<char*>(&status_)) + sizeof(run_time_ms_));
  clear_has_result_data();
  switch (from.result_data_case()) {
    case kPromptChoice: {
      _internal_mutable_prompt_choice()->::autofill_assistant::PromptProto_Result::MergeFrom(from._internal_prompt_choice());
      break;
    }
    case kCollectUserDataResult: {
      _internal_mutable_collect_user_data_result()->::autofill_assistant::CollectUserDataResultProto::MergeFrom(from._internal_collect_user_data_result());
      break;
    }
    case kWaitForDomResult: {
      _internal_mutable_wait_for_dom_result()->::autofill_assistant::WaitForDomProto_Result::MergeFrom(from._internal_wait_for_dom_result());
      break;
    }
    case kFormResult: {
      _internal_mutable_form_result()->::autofill_assistant::FormProto_Result::MergeFrom(from._internal_form_result());
      break;
    }
    case kWaitForDocumentResult: {
      _internal_mutable_wait_for_document_result()->::autofill_assistant::WaitForDocumentProto_Result::MergeFrom(from._internal_wait_for_document_result());
      break;
    }
    case kShowGenericUiResult: {
      _internal_mutable_show_generic_ui_result()->::autofill_assistant::ShowGenericUiProto_Result::MergeFrom(from._internal_show_generic_ui_result());
      break;
    }
    case kGetElementStatusResult: {
      _internal_mutable_get_element_status_result()->::autofill_assistant::GetElementStatusProto_Result::MergeFrom(from._internal_get_element_status_result());
      break;
    }
    case kUploadDomResult: {
      _internal_mutable_upload_dom_result()->::autofill_assistant::UploadDomProto_Result::MergeFrom(from._internal_upload_dom_result());
      break;
    }
    case kCheckOptionElementResult: {
      _internal_mutable_check_option_element_result()->::autofill_assistant::CheckOptionElementProto_Result::MergeFrom(from._internal_check_option_element_result());
      break;
    }
    case kSendKeyStrokeEventsResult: {
      _internal_mutable_send_key_stroke_events_result()->::autofill_assistant::SendKeystrokeEventsProto_Result::MergeFrom(from._internal_send_key_stroke_events_result());
      break;
    }
    case kJsFlowResult: {
      _internal_mutable_js_flow_result()->::autofill_assistant::JsFlowProto_Result::MergeFrom(from._internal_js_flow_result());
      break;
    }
    case kSaveSubmittedPasswordResult: {
      _internal_mutable_save_submitted_password_result()->::autofill_assistant::SaveSubmittedPasswordProto_Result::MergeFrom(from._internal_save_submitted_password_result());
      break;
    }
    case kExternalActionResult: {
      _internal_mutable_external_action_result()->::autofill_assistant::ExternalActionProto_Result::MergeFrom(from._internal_external_action_result());
      break;
    }
    case RESULT_DATA_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.ProcessedActionProto)
}

inline void ProcessedActionProto::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&action_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&run_time_ms_) -
    reinterpret_cast<char*>(&action_)) + sizeof(run_time_ms_));
clear_has_result_data();
}

ProcessedActionProto::~ProcessedActionProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.ProcessedActionProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ProcessedActionProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete action_;
  if (this != internal_default_instance()) delete status_details_;
  if (this != internal_default_instance()) delete navigation_info_;
  if (this != internal_default_instance()) delete timing_stats_;
  if (has_result_data()) {
    clear_result_data();
  }
}

void ProcessedActionProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ProcessedActionProto::clear_result_data() {
// @@protoc_insertion_point(one_of_clear_start:autofill_assistant.ProcessedActionProto)
  switch (result_data_case()) {
    case kPromptChoice: {
      if (GetArenaForAllocation() == nullptr) {
        delete result_data_.prompt_choice_;
      }
      break;
    }
    case kCollectUserDataResult: {
      if (GetArenaForAllocation() == nullptr) {
        delete result_data_.collect_user_data_result_;
      }
      break;
    }
    case kWaitForDomResult: {
      if (GetArenaForAllocation() == nullptr) {
        delete result_data_.wait_for_dom_result_;
      }
      break;
    }
    case kFormResult: {
      if (GetArenaForAllocation() == nullptr) {
        delete result_data_.form_result_;
      }
      break;
    }
    case kWaitForDocumentResult: {
      if (GetArenaForAllocation() == nullptr) {
        delete result_data_.wait_for_document_result_;
      }
      break;
    }
    case kShowGenericUiResult: {
      if (GetArenaForAllocation() == nullptr) {
        delete result_data_.show_generic_ui_result_;
      }
      break;
    }
    case kGetElementStatusResult: {
      if (GetArenaForAllocation() == nullptr) {
        delete result_data_.get_element_status_result_;
      }
      break;
    }
    case kUploadDomResult: {
      if (GetArenaForAllocation() == nullptr) {
        delete result_data_.upload_dom_result_;
      }
      break;
    }
    case kCheckOptionElementResult: {
      if (GetArenaForAllocation() == nullptr) {
        delete result_data_.check_option_element_result_;
      }
      break;
    }
    case kSendKeyStrokeEventsResult: {
      if (GetArenaForAllocation() == nullptr) {
        delete result_data_.send_key_stroke_events_result_;
      }
      break;
    }
    case kJsFlowResult: {
      if (GetArenaForAllocation() == nullptr) {
        delete result_data_.js_flow_result_;
      }
      break;
    }
    case kSaveSubmittedPasswordResult: {
      if (GetArenaForAllocation() == nullptr) {
        delete result_data_.save_submitted_password_result_;
      }
      break;
    }
    case kExternalActionResult: {
      if (GetArenaForAllocation() == nullptr) {
        delete result_data_.external_action_result_;
      }
      break;
    }
    case RESULT_DATA_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = RESULT_DATA_NOT_SET;
}


void ProcessedActionProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.ProcessedActionProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(action_ != nullptr);
      action_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(status_details_ != nullptr);
      status_details_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(navigation_info_ != nullptr);
      navigation_info_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(timing_stats_ != nullptr);
      timing_stats_->Clear();
    }
  }
  if (cached_has_bits & 0x00000070u) {
    ::memset(&status_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&run_time_ms_) -
        reinterpret_cast<char*>(&status_)) + sizeof(run_time_ms_));
  }
  clear_result_data();
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ProcessedActionProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .autofill_assistant.ActionProto action = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_action(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .autofill_assistant.ProcessedActionStatusProto status = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::autofill_assistant::ProcessedActionStatusProto_IsValid(val))) {
            _internal_set_status(static_cast<::autofill_assistant::ProcessedActionStatusProto>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.PromptProto.Result prompt_choice = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_prompt_choice(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.CollectUserDataResultProto collect_user_data_result = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 122)) {
          ptr = ctx->ParseMessage(_internal_mutable_collect_user_data_result(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .autofill_assistant.ProcessedActionStatusDetailsProto status_details = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 154)) {
          ptr = ctx->ParseMessage(_internal_mutable_status_details(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .autofill_assistant.NavigationInfoProto navigation_info = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
          ptr = ctx->ParseMessage(_internal_mutable_navigation_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.FormProto.Result form_result = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 170)) {
          ptr = ctx->ParseMessage(_internal_mutable_form_result(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.WaitForDomProto.Result wait_for_dom_result = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 178)) {
          ptr = ctx->ParseMessage(_internal_mutable_wait_for_dom_result(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 run_time_ms = 23;
      case 23:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 184)) {
          _Internal::set_has_run_time_ms(&has_bits);
          run_time_ms_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.WaitForDocumentProto.Result wait_for_document_result = 25;
      case 25:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 202)) {
          ptr = ctx->ParseMessage(_internal_mutable_wait_for_document_result(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.ShowGenericUiProto.Result show_generic_ui_result = 28;
      case 28:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 226)) {
          ptr = ctx->ParseMessage(_internal_mutable_show_generic_ui_result(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.GetElementStatusProto.Result get_element_status_result = 31;
      case 31:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 250)) {
          ptr = ctx->ParseMessage(_internal_mutable_get_element_status_result(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .autofill_assistant.ActionTimingStats timing_stats = 32;
      case 32:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 2)) {
          ptr = ctx->ParseMessage(_internal_mutable_timing_stats(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.UploadDomProto.Result upload_dom_result = 33;
      case 33:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_upload_dom_result(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .autofill_assistant.SlowWarningStatus slow_warning_status = 34;
      case 34:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::autofill_assistant::SlowWarningStatus_IsValid(val))) {
            _internal_set_slow_warning_status(static_cast<::autofill_assistant::SlowWarningStatus>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(34, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.CheckOptionElementProto.Result check_option_element_result = 35;
      case 35:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_check_option_element_result(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.SendKeystrokeEventsProto.Result send_key_stroke_events_result = 36;
      case 36:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_send_key_stroke_events_result(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.JsFlowProto.Result js_flow_result = 37;
      case 37:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_js_flow_result(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.SaveSubmittedPasswordProto.Result save_submitted_password_result = 38;
      case 38:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_save_submitted_password_result(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.ExternalActionProto.Result external_action_result = 39;
      case 39:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_external_action_result(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ProcessedActionProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.ProcessedActionProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .autofill_assistant.ActionProto action = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::action(this),
        _Internal::action(this).GetCachedSize(), target, stream);
  }

  // optional .autofill_assistant.ProcessedActionStatusProto status = 2;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_status(), target);
  }

  switch (result_data_case()) {
    case kPromptChoice: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(5, _Internal::prompt_choice(this),
          _Internal::prompt_choice(this).GetCachedSize(), target, stream);
      break;
    }
    case kCollectUserDataResult: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(15, _Internal::collect_user_data_result(this),
          _Internal::collect_user_data_result(this).GetCachedSize(), target, stream);
      break;
    }
    default: ;
  }
  // optional .autofill_assistant.ProcessedActionStatusDetailsProto status_details = 19;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(19, _Internal::status_details(this),
        _Internal::status_details(this).GetCachedSize(), target, stream);
  }

  // optional .autofill_assistant.NavigationInfoProto navigation_info = 20;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(20, _Internal::navigation_info(this),
        _Internal::navigation_info(this).GetCachedSize(), target, stream);
  }

  switch (result_data_case()) {
    case kFormResult: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(21, _Internal::form_result(this),
          _Internal::form_result(this).GetCachedSize(), target, stream);
      break;
    }
    case kWaitForDomResult: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(22, _Internal::wait_for_dom_result(this),
          _Internal::wait_for_dom_result(this).GetCachedSize(), target, stream);
      break;
    }
    default: ;
  }
  // optional int64 run_time_ms = 23;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(23, this->_internal_run_time_ms(), target);
  }

  switch (result_data_case()) {
    case kWaitForDocumentResult: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(25, _Internal::wait_for_document_result(this),
          _Internal::wait_for_document_result(this).GetCachedSize(), target, stream);
      break;
    }
    case kShowGenericUiResult: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(28, _Internal::show_generic_ui_result(this),
          _Internal::show_generic_ui_result(this).GetCachedSize(), target, stream);
      break;
    }
    case kGetElementStatusResult: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(31, _Internal::get_element_status_result(this),
          _Internal::get_element_status_result(this).GetCachedSize(), target, stream);
      break;
    }
    default: ;
  }
  // optional .autofill_assistant.ActionTimingStats timing_stats = 32;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(32, _Internal::timing_stats(this),
        _Internal::timing_stats(this).GetCachedSize(), target, stream);
  }

  // .autofill_assistant.UploadDomProto.Result upload_dom_result = 33;
  if (_internal_has_upload_dom_result()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(33, _Internal::upload_dom_result(this),
        _Internal::upload_dom_result(this).GetCachedSize(), target, stream);
  }

  // optional .autofill_assistant.SlowWarningStatus slow_warning_status = 34;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      34, this->_internal_slow_warning_status(), target);
  }

  switch (result_data_case()) {
    case kCheckOptionElementResult: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(35, _Internal::check_option_element_result(this),
          _Internal::check_option_element_result(this).GetCachedSize(), target, stream);
      break;
    }
    case kSendKeyStrokeEventsResult: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(36, _Internal::send_key_stroke_events_result(this),
          _Internal::send_key_stroke_events_result(this).GetCachedSize(), target, stream);
      break;
    }
    case kJsFlowResult: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(37, _Internal::js_flow_result(this),
          _Internal::js_flow_result(this).GetCachedSize(), target, stream);
      break;
    }
    case kSaveSubmittedPasswordResult: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(38, _Internal::save_submitted_password_result(this),
          _Internal::save_submitted_password_result(this).GetCachedSize(), target, stream);
      break;
    }
    case kExternalActionResult: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(39, _Internal::external_action_result(this),
          _Internal::external_action_result(this).GetCachedSize(), target, stream);
      break;
    }
    default: ;
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.ProcessedActionProto)
  return target;
}

size_t ProcessedActionProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.ProcessedActionProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // optional .autofill_assistant.ActionProto action = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *action_);
    }

    // optional .autofill_assistant.ProcessedActionStatusDetailsProto status_details = 19;
    if (cached_has_bits & 0x00000002u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *status_details_);
    }

    // optional .autofill_assistant.NavigationInfoProto navigation_info = 20;
    if (cached_has_bits & 0x00000004u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *navigation_info_);
    }

    // optional .autofill_assistant.ActionTimingStats timing_stats = 32;
    if (cached_has_bits & 0x00000008u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *timing_stats_);
    }

    // optional .autofill_assistant.ProcessedActionStatusProto status = 2;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_status());
    }

    // optional .autofill_assistant.SlowWarningStatus slow_warning_status = 34;
    if (cached_has_bits & 0x00000020u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_slow_warning_status());
    }

    // optional int64 run_time_ms = 23;
    if (cached_has_bits & 0x00000040u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int64Size(
          this->_internal_run_time_ms());
    }

  }
  switch (result_data_case()) {
    // .autofill_assistant.PromptProto.Result prompt_choice = 5;
    case kPromptChoice: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *result_data_.prompt_choice_);
      break;
    }
    // .autofill_assistant.CollectUserDataResultProto collect_user_data_result = 15;
    case kCollectUserDataResult: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *result_data_.collect_user_data_result_);
      break;
    }
    // .autofill_assistant.WaitForDomProto.Result wait_for_dom_result = 22;
    case kWaitForDomResult: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *result_data_.wait_for_dom_result_);
      break;
    }
    // .autofill_assistant.FormProto.Result form_result = 21;
    case kFormResult: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *result_data_.form_result_);
      break;
    }
    // .autofill_assistant.WaitForDocumentProto.Result wait_for_document_result = 25;
    case kWaitForDocumentResult: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *result_data_.wait_for_document_result_);
      break;
    }
    // .autofill_assistant.ShowGenericUiProto.Result show_generic_ui_result = 28;
    case kShowGenericUiResult: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *result_data_.show_generic_ui_result_);
      break;
    }
    // .autofill_assistant.GetElementStatusProto.Result get_element_status_result = 31;
    case kGetElementStatusResult: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *result_data_.get_element_status_result_);
      break;
    }
    // .autofill_assistant.UploadDomProto.Result upload_dom_result = 33;
    case kUploadDomResult: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *result_data_.upload_dom_result_);
      break;
    }
    // .autofill_assistant.CheckOptionElementProto.Result check_option_element_result = 35;
    case kCheckOptionElementResult: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *result_data_.check_option_element_result_);
      break;
    }
    // .autofill_assistant.SendKeystrokeEventsProto.Result send_key_stroke_events_result = 36;
    case kSendKeyStrokeEventsResult: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *result_data_.send_key_stroke_events_result_);
      break;
    }
    // .autofill_assistant.JsFlowProto.Result js_flow_result = 37;
    case kJsFlowResult: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *result_data_.js_flow_result_);
      break;
    }
    // .autofill_assistant.SaveSubmittedPasswordProto.Result save_submitted_password_result = 38;
    case kSaveSubmittedPasswordResult: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *result_data_.save_submitted_password_result_);
      break;
    }
    // .autofill_assistant.ExternalActionProto.Result external_action_result = 39;
    case kExternalActionResult: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *result_data_.external_action_result_);
      break;
    }
    case RESULT_DATA_NOT_SET: {
      break;
    }
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ProcessedActionProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ProcessedActionProto*>(
      &from));
}

void ProcessedActionProto::MergeFrom(const ProcessedActionProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.ProcessedActionProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_action()->::autofill_assistant::ActionProto::MergeFrom(from._internal_action());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_status_details()->::autofill_assistant::ProcessedActionStatusDetailsProto::MergeFrom(from._internal_status_details());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_navigation_info()->::autofill_assistant::NavigationInfoProto::MergeFrom(from._internal_navigation_info());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_mutable_timing_stats()->::autofill_assistant::ActionTimingStats::MergeFrom(from._internal_timing_stats());
    }
    if (cached_has_bits & 0x00000010u) {
      status_ = from.status_;
    }
    if (cached_has_bits & 0x00000020u) {
      slow_warning_status_ = from.slow_warning_status_;
    }
    if (cached_has_bits & 0x00000040u) {
      run_time_ms_ = from.run_time_ms_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  switch (from.result_data_case()) {
    case kPromptChoice: {
      _internal_mutable_prompt_choice()->::autofill_assistant::PromptProto_Result::MergeFrom(from._internal_prompt_choice());
      break;
    }
    case kCollectUserDataResult: {
      _internal_mutable_collect_user_data_result()->::autofill_assistant::CollectUserDataResultProto::MergeFrom(from._internal_collect_user_data_result());
      break;
    }
    case kWaitForDomResult: {
      _internal_mutable_wait_for_dom_result()->::autofill_assistant::WaitForDomProto_Result::MergeFrom(from._internal_wait_for_dom_result());
      break;
    }
    case kFormResult: {
      _internal_mutable_form_result()->::autofill_assistant::FormProto_Result::MergeFrom(from._internal_form_result());
      break;
    }
    case kWaitForDocumentResult: {
      _internal_mutable_wait_for_document_result()->::autofill_assistant::WaitForDocumentProto_Result::MergeFrom(from._internal_wait_for_document_result());
      break;
    }
    case kShowGenericUiResult: {
      _internal_mutable_show_generic_ui_result()->::autofill_assistant::ShowGenericUiProto_Result::MergeFrom(from._internal_show_generic_ui_result());
      break;
    }
    case kGetElementStatusResult: {
      _internal_mutable_get_element_status_result()->::autofill_assistant::GetElementStatusProto_Result::MergeFrom(from._internal_get_element_status_result());
      break;
    }
    case kUploadDomResult: {
      _internal_mutable_upload_dom_result()->::autofill_assistant::UploadDomProto_Result::MergeFrom(from._internal_upload_dom_result());
      break;
    }
    case kCheckOptionElementResult: {
      _internal_mutable_check_option_element_result()->::autofill_assistant::CheckOptionElementProto_Result::MergeFrom(from._internal_check_option_element_result());
      break;
    }
    case kSendKeyStrokeEventsResult: {
      _internal_mutable_send_key_stroke_events_result()->::autofill_assistant::SendKeystrokeEventsProto_Result::MergeFrom(from._internal_send_key_stroke_events_result());
      break;
    }
    case kJsFlowResult: {
      _internal_mutable_js_flow_result()->::autofill_assistant::JsFlowProto_Result::MergeFrom(from._internal_js_flow_result());
      break;
    }
    case kSaveSubmittedPasswordResult: {
      _internal_mutable_save_submitted_password_result()->::autofill_assistant::SaveSubmittedPasswordProto_Result::MergeFrom(from._internal_save_submitted_password_result());
      break;
    }
    case kExternalActionResult: {
      _internal_mutable_external_action_result()->::autofill_assistant::ExternalActionProto_Result::MergeFrom(from._internal_external_action_result());
      break;
    }
    case RESULT_DATA_NOT_SET: {
      break;
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ProcessedActionProto::CopyFrom(const ProcessedActionProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.ProcessedActionProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ProcessedActionProto::IsInitialized() const {
  if (_internal_has_action()) {
    if (!action_->IsInitialized()) return false;
  }
  switch (result_data_case()) {
    case kPromptChoice: {
      break;
    }
    case kCollectUserDataResult: {
      break;
    }
    case kWaitForDomResult: {
      break;
    }
    case kFormResult: {
      break;
    }
    case kWaitForDocumentResult: {
      break;
    }
    case kShowGenericUiResult: {
      break;
    }
    case kGetElementStatusResult: {
      break;
    }
    case kUploadDomResult: {
      break;
    }
    case kCheckOptionElementResult: {
      break;
    }
    case kSendKeyStrokeEventsResult: {
      break;
    }
    case kJsFlowResult: {
      break;
    }
    case kSaveSubmittedPasswordResult: {
      break;
    }
    case kExternalActionResult: {
      if (_internal_has_external_action_result()) {
        if (!result_data_.external_action_result_->IsInitialized()) return false;
      }
      break;
    }
    case RESULT_DATA_NOT_SET: {
      break;
    }
  }
  return true;
}

void ProcessedActionProto::InternalSwap(ProcessedActionProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ProcessedActionProto, run_time_ms_)
      + sizeof(ProcessedActionProto::run_time_ms_)
      - PROTOBUF_FIELD_OFFSET(ProcessedActionProto, action_)>(
          reinterpret_cast<char*>(&action_),
          reinterpret_cast<char*>(&other->action_));
  swap(result_data_, other->result_data_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

std::string ProcessedActionProto::GetTypeName() const {
  return "autofill_assistant.ProcessedActionProto";
}


// ===================================================================

class ProcessedActionStatusDetailsProto::_Internal {
 public:
  using HasBits = decltype(std::declval<ProcessedActionStatusDetailsProto>()._has_bits_);
  static const ::autofill_assistant::UnexpectedErrorInfoProto& unexpected_error_info(const ProcessedActionStatusDetailsProto* msg);
  static void set_has_unexpected_error_info(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_original_status(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::autofill_assistant::AutofillErrorInfoProto& autofill_error_info(const ProcessedActionStatusDetailsProto* msg);
  static void set_has_autofill_error_info(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::autofill_assistant::WebControllerErrorInfoProto& web_controller_error_info(const ProcessedActionStatusDetailsProto* msg);
  static void set_has_web_controller_error_info(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::autofill_assistant::UnexpectedErrorInfoProto&
ProcessedActionStatusDetailsProto::_Internal::unexpected_error_info(const ProcessedActionStatusDetailsProto* msg) {
  return *msg->unexpected_error_info_;
}
const ::autofill_assistant::AutofillErrorInfoProto&
ProcessedActionStatusDetailsProto::_Internal::autofill_error_info(const ProcessedActionStatusDetailsProto* msg) {
  return *msg->autofill_error_info_;
}
const ::autofill_assistant::WebControllerErrorInfoProto&
ProcessedActionStatusDetailsProto::_Internal::web_controller_error_info(const ProcessedActionStatusDetailsProto* msg) {
  return *msg->web_controller_error_info_;
}
ProcessedActionStatusDetailsProto::ProcessedActionStatusDetailsProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  element_finder_info_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.ProcessedActionStatusDetailsProto)
}
ProcessedActionStatusDetailsProto::ProcessedActionStatusDetailsProto(const ProcessedActionStatusDetailsProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      element_finder_info_(from.element_finder_info_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_unexpected_error_info()) {
    unexpected_error_info_ = new ::autofill_assistant::UnexpectedErrorInfoProto(*from.unexpected_error_info_);
  } else {
    unexpected_error_info_ = nullptr;
  }
  if (from._internal_has_autofill_error_info()) {
    autofill_error_info_ = new ::autofill_assistant::AutofillErrorInfoProto(*from.autofill_error_info_);
  } else {
    autofill_error_info_ = nullptr;
  }
  if (from._internal_has_web_controller_error_info()) {
    web_controller_error_info_ = new ::autofill_assistant::WebControllerErrorInfoProto(*from.web_controller_error_info_);
  } else {
    web_controller_error_info_ = nullptr;
  }
  original_status_ = from.original_status_;
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.ProcessedActionStatusDetailsProto)
}

inline void ProcessedActionStatusDetailsProto::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&unexpected_error_info_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&original_status_) -
    reinterpret_cast<char*>(&unexpected_error_info_)) + sizeof(original_status_));
}

ProcessedActionStatusDetailsProto::~ProcessedActionStatusDetailsProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.ProcessedActionStatusDetailsProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ProcessedActionStatusDetailsProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete unexpected_error_info_;
  if (this != internal_default_instance()) delete autofill_error_info_;
  if (this != internal_default_instance()) delete web_controller_error_info_;
}

void ProcessedActionStatusDetailsProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ProcessedActionStatusDetailsProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.ProcessedActionStatusDetailsProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  element_finder_info_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(unexpected_error_info_ != nullptr);
      unexpected_error_info_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(autofill_error_info_ != nullptr);
      autofill_error_info_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(web_controller_error_info_ != nullptr);
      web_controller_error_info_->Clear();
    }
  }
  original_status_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ProcessedActionStatusDetailsProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .autofill_assistant.UnexpectedErrorInfoProto unexpected_error_info = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_unexpected_error_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .autofill_assistant.ProcessedActionStatusProto original_status = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::autofill_assistant::ProcessedActionStatusProto_IsValid(val))) {
            _internal_set_original_status(static_cast<::autofill_assistant::ProcessedActionStatusProto>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .autofill_assistant.AutofillErrorInfoProto autofill_error_info = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_autofill_error_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .autofill_assistant.WebControllerErrorInfoProto web_controller_error_info = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_web_controller_error_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .autofill_assistant.ElementFinderInfoProto element_finder_info = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_element_finder_info(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ProcessedActionStatusDetailsProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.ProcessedActionStatusDetailsProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .autofill_assistant.UnexpectedErrorInfoProto unexpected_error_info = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::unexpected_error_info(this),
        _Internal::unexpected_error_info(this).GetCachedSize(), target, stream);
  }

  // optional .autofill_assistant.ProcessedActionStatusProto original_status = 2;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_original_status(), target);
  }

  // optional .autofill_assistant.AutofillErrorInfoProto autofill_error_info = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::autofill_error_info(this),
        _Internal::autofill_error_info(this).GetCachedSize(), target, stream);
  }

  // optional .autofill_assistant.WebControllerErrorInfoProto web_controller_error_info = 5;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::web_controller_error_info(this),
        _Internal::web_controller_error_info(this).GetCachedSize(), target, stream);
  }

  // repeated .autofill_assistant.ElementFinderInfoProto element_finder_info = 6;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_element_finder_info_size()); i < n; i++) {
    const auto& repfield = this->_internal_element_finder_info(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(6, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.ProcessedActionStatusDetailsProto)
  return target;
}

size_t ProcessedActionStatusDetailsProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.ProcessedActionStatusDetailsProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .autofill_assistant.ElementFinderInfoProto element_finder_info = 6;
  total_size += 1UL * this->_internal_element_finder_info_size();
  for (const auto& msg : this->element_finder_info_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional .autofill_assistant.UnexpectedErrorInfoProto unexpected_error_info = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *unexpected_error_info_);
    }

    // optional .autofill_assistant.AutofillErrorInfoProto autofill_error_info = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *autofill_error_info_);
    }

    // optional .autofill_assistant.WebControllerErrorInfoProto web_controller_error_info = 5;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *web_controller_error_info_);
    }

    // optional .autofill_assistant.ProcessedActionStatusProto original_status = 2;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_original_status());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ProcessedActionStatusDetailsProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ProcessedActionStatusDetailsProto*>(
      &from));
}

void ProcessedActionStatusDetailsProto::MergeFrom(const ProcessedActionStatusDetailsProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.ProcessedActionStatusDetailsProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  element_finder_info_.MergeFrom(from.element_finder_info_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_unexpected_error_info()->::autofill_assistant::UnexpectedErrorInfoProto::MergeFrom(from._internal_unexpected_error_info());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_autofill_error_info()->::autofill_assistant::AutofillErrorInfoProto::MergeFrom(from._internal_autofill_error_info());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_web_controller_error_info()->::autofill_assistant::WebControllerErrorInfoProto::MergeFrom(from._internal_web_controller_error_info());
    }
    if (cached_has_bits & 0x00000008u) {
      original_status_ = from.original_status_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ProcessedActionStatusDetailsProto::CopyFrom(const ProcessedActionStatusDetailsProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.ProcessedActionStatusDetailsProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ProcessedActionStatusDetailsProto::IsInitialized() const {
  return true;
}

void ProcessedActionStatusDetailsProto::InternalSwap(ProcessedActionStatusDetailsProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  element_finder_info_.InternalSwap(&other->element_finder_info_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ProcessedActionStatusDetailsProto, original_status_)
      + sizeof(ProcessedActionStatusDetailsProto::original_status_)
      - PROTOBUF_FIELD_OFFSET(ProcessedActionStatusDetailsProto, unexpected_error_info_)>(
          reinterpret_cast<char*>(&unexpected_error_info_),
          reinterpret_cast<char*>(&other->unexpected_error_info_));
}

std::string ProcessedActionStatusDetailsProto::GetTypeName() const {
  return "autofill_assistant.ProcessedActionStatusDetailsProto";
}


// ===================================================================

class NavigationInfoProto::_Internal {
 public:
  using HasBits = decltype(std::declval<NavigationInfoProto>()._has_bits_);
  static void set_has_started(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ended(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_has_error(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_unexpected(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

NavigationInfoProto::NavigationInfoProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.NavigationInfoProto)
}
NavigationInfoProto::NavigationInfoProto(const NavigationInfoProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&started_, &from.started_,
    static_cast<size_t>(reinterpret_cast<char*>(&unexpected_) -
    reinterpret_cast<char*>(&started_)) + sizeof(unexpected_));
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.NavigationInfoProto)
}

inline void NavigationInfoProto::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&started_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&unexpected_) -
    reinterpret_cast<char*>(&started_)) + sizeof(unexpected_));
}

NavigationInfoProto::~NavigationInfoProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.NavigationInfoProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void NavigationInfoProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void NavigationInfoProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void NavigationInfoProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.NavigationInfoProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&started_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&unexpected_) -
      reinterpret_cast<char*>(&started_)) + sizeof(unexpected_));
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* NavigationInfoProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool started = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_started(&has_bits);
          started_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool ended = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ended(&has_bits);
          ended_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool has_error = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_has_error(&has_bits);
          has_error_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool unexpected = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_unexpected(&has_bits);
          unexpected_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NavigationInfoProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.NavigationInfoProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bool started = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_started(), target);
  }

  // optional bool ended = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_ended(), target);
  }

  // optional bool has_error = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_has_error(), target);
  }

  // optional bool unexpected = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_unexpected(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.NavigationInfoProto)
  return target;
}

size_t NavigationInfoProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.NavigationInfoProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional bool started = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 1;
    }

    // optional bool ended = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

    // optional bool has_error = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

    // optional bool unexpected = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void NavigationInfoProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const NavigationInfoProto*>(
      &from));
}

void NavigationInfoProto::MergeFrom(const NavigationInfoProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.NavigationInfoProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      started_ = from.started_;
    }
    if (cached_has_bits & 0x00000002u) {
      ended_ = from.ended_;
    }
    if (cached_has_bits & 0x00000004u) {
      has_error_ = from.has_error_;
    }
    if (cached_has_bits & 0x00000008u) {
      unexpected_ = from.unexpected_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void NavigationInfoProto::CopyFrom(const NavigationInfoProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.NavigationInfoProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NavigationInfoProto::IsInitialized() const {
  return true;
}

void NavigationInfoProto::InternalSwap(NavigationInfoProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(NavigationInfoProto, unexpected_)
      + sizeof(NavigationInfoProto::unexpected_)
      - PROTOBUF_FIELD_OFFSET(NavigationInfoProto, started_)>(
          reinterpret_cast<char*>(&started_),
          reinterpret_cast<char*>(&other->started_));
}

std::string NavigationInfoProto::GetTypeName() const {
  return "autofill_assistant.NavigationInfoProto";
}


// ===================================================================

class UnexpectedErrorInfoProto::_Internal {
 public:
  using HasBits = decltype(std::declval<UnexpectedErrorInfoProto>()._has_bits_);
  static void set_has_source_file(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_source_line_number(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_js_exception_classname(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_devtools_error_code(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_devtools_error_message(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

UnexpectedErrorInfoProto::UnexpectedErrorInfoProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  js_exception_line_numbers_(arena),
  js_exception_column_numbers_(arena),
  js_exception_locations_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.UnexpectedErrorInfoProto)
}
UnexpectedErrorInfoProto::UnexpectedErrorInfoProto(const UnexpectedErrorInfoProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      js_exception_line_numbers_(from.js_exception_line_numbers_),
      js_exception_column_numbers_(from.js_exception_column_numbers_),
      js_exception_locations_(from.js_exception_locations_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  source_file_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    source_file_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_source_file()) {
    source_file_.Set(from._internal_source_file(), 
      GetArenaForAllocation());
  }
  js_exception_classname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    js_exception_classname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_js_exception_classname()) {
    js_exception_classname_.Set(from._internal_js_exception_classname(), 
      GetArenaForAllocation());
  }
  devtools_error_message_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    devtools_error_message_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_devtools_error_message()) {
    devtools_error_message_.Set(from._internal_devtools_error_message(), 
      GetArenaForAllocation());
  }
  ::memcpy(&source_line_number_, &from.source_line_number_,
    static_cast<size_t>(reinterpret_cast<char*>(&devtools_error_code_) -
    reinterpret_cast<char*>(&source_line_number_)) + sizeof(devtools_error_code_));
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.UnexpectedErrorInfoProto)
}

inline void UnexpectedErrorInfoProto::SharedCtor() {
source_file_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  source_file_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
js_exception_classname_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  js_exception_classname_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
devtools_error_message_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  devtools_error_message_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&source_line_number_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&devtools_error_code_) -
    reinterpret_cast<char*>(&source_line_number_)) + sizeof(devtools_error_code_));
}

UnexpectedErrorInfoProto::~UnexpectedErrorInfoProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.UnexpectedErrorInfoProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void UnexpectedErrorInfoProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  source_file_.Destroy();
  js_exception_classname_.Destroy();
  devtools_error_message_.Destroy();
}

void UnexpectedErrorInfoProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void UnexpectedErrorInfoProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.UnexpectedErrorInfoProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  js_exception_line_numbers_.Clear();
  js_exception_column_numbers_.Clear();
  js_exception_locations_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      source_file_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      js_exception_classname_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      devtools_error_message_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x00000018u) {
    ::memset(&source_line_number_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&devtools_error_code_) -
        reinterpret_cast<char*>(&source_line_number_)) + sizeof(devtools_error_code_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* UnexpectedErrorInfoProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string source_file = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_source_file();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 source_line_number = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_source_line_number(&has_bits);
          source_line_number_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string js_exception_classname = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_js_exception_classname();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated int32 js_exception_line_numbers = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_js_exception_line_numbers(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<32>(ptr));
        } else if (static_cast<uint8_t>(tag) == 34) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_js_exception_line_numbers(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated int32 js_exception_column_numbers = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_js_exception_column_numbers(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<40>(ptr));
        } else if (static_cast<uint8_t>(tag) == 42) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_js_exception_column_numbers(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 devtools_error_code = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_devtools_error_code(&has_bits);
          devtools_error_code_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string devtools_error_message = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_devtools_error_message();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .autofill_assistant.UnexpectedErrorInfoProto.JsExceptionLocation js_exception_locations = 8 [packed = true];
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedEnumParser<std::string>(_internal_mutable_js_exception_locations(), ptr, ctx, ::autofill_assistant::UnexpectedErrorInfoProto_JsExceptionLocation_IsValid, &_internal_metadata_, 8);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 64) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::autofill_assistant::UnexpectedErrorInfoProto_JsExceptionLocation_IsValid(val))) {
            _internal_add_js_exception_locations(static_cast<::autofill_assistant::UnexpectedErrorInfoProto_JsExceptionLocation>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(8, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UnexpectedErrorInfoProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.UnexpectedErrorInfoProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string source_file = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_source_file(), target);
  }

  // optional int32 source_line_number = 2;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_source_line_number(), target);
  }

  // optional string js_exception_classname = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_js_exception_classname(), target);
  }

  // repeated int32 js_exception_line_numbers = 4;
  for (int i = 0, n = this->_internal_js_exception_line_numbers_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_js_exception_line_numbers(i), target);
  }

  // repeated int32 js_exception_column_numbers = 5;
  for (int i = 0, n = this->_internal_js_exception_column_numbers_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_js_exception_column_numbers(i), target);
  }

  // optional int32 devtools_error_code = 6;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(6, this->_internal_devtools_error_code(), target);
  }

  // optional string devtools_error_message = 7;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteStringMaybeAliased(
        7, this->_internal_devtools_error_message(), target);
  }

  // repeated .autofill_assistant.UnexpectedErrorInfoProto.JsExceptionLocation js_exception_locations = 8 [packed = true];
  {
    int byte_size = _js_exception_locations_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteEnumPacked(
          8, js_exception_locations_, byte_size, target);
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.UnexpectedErrorInfoProto)
  return target;
}

size_t UnexpectedErrorInfoProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.UnexpectedErrorInfoProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int32 js_exception_line_numbers = 4;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int32Size(this->js_exception_line_numbers_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_js_exception_line_numbers_size());
    total_size += data_size;
  }

  // repeated int32 js_exception_column_numbers = 5;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int32Size(this->js_exception_column_numbers_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_js_exception_column_numbers_size());
    total_size += data_size;
  }

  // repeated .autofill_assistant.UnexpectedErrorInfoProto.JsExceptionLocation js_exception_locations = 8 [packed = true];
  {
    size_t data_size = 0;
    unsigned int count = static_cast<unsigned int>(this->_internal_js_exception_locations_size());for (unsigned int i = 0; i < count; i++) {
      data_size += ::_pbi::WireFormatLite::EnumSize(
        this->_internal_js_exception_locations(static_cast<int>(i)));
    }
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    int cached_size = ::_pbi::ToCachedSize(data_size);
    _js_exception_locations_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional string source_file = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_source_file());
    }

    // optional string js_exception_classname = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_js_exception_classname());
    }

    // optional string devtools_error_message = 7;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_devtools_error_message());
    }

    // optional int32 source_line_number = 2;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_source_line_number());
    }

    // optional int32 devtools_error_code = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_devtools_error_code());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void UnexpectedErrorInfoProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const UnexpectedErrorInfoProto*>(
      &from));
}

void UnexpectedErrorInfoProto::MergeFrom(const UnexpectedErrorInfoProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.UnexpectedErrorInfoProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  js_exception_line_numbers_.MergeFrom(from.js_exception_line_numbers_);
  js_exception_column_numbers_.MergeFrom(from.js_exception_column_numbers_);
  js_exception_locations_.MergeFrom(from.js_exception_locations_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_source_file(from._internal_source_file());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_js_exception_classname(from._internal_js_exception_classname());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_devtools_error_message(from._internal_devtools_error_message());
    }
    if (cached_has_bits & 0x00000008u) {
      source_line_number_ = from.source_line_number_;
    }
    if (cached_has_bits & 0x00000010u) {
      devtools_error_code_ = from.devtools_error_code_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void UnexpectedErrorInfoProto::CopyFrom(const UnexpectedErrorInfoProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.UnexpectedErrorInfoProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UnexpectedErrorInfoProto::IsInitialized() const {
  return true;
}

void UnexpectedErrorInfoProto::InternalSwap(UnexpectedErrorInfoProto* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  js_exception_line_numbers_.InternalSwap(&other->js_exception_line_numbers_);
  js_exception_column_numbers_.InternalSwap(&other->js_exception_column_numbers_);
  js_exception_locations_.InternalSwap(&other->js_exception_locations_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &source_file_, lhs_arena,
      &other->source_file_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &js_exception_classname_, lhs_arena,
      &other->js_exception_classname_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &devtools_error_message_, lhs_arena,
      &other->devtools_error_message_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(UnexpectedErrorInfoProto, devtools_error_code_)
      + sizeof(UnexpectedErrorInfoProto::devtools_error_code_)
      - PROTOBUF_FIELD_OFFSET(UnexpectedErrorInfoProto, source_line_number_)>(
          reinterpret_cast<char*>(&source_line_number_),
          reinterpret_cast<char*>(&other->source_line_number_));
}

std::string UnexpectedErrorInfoProto::GetTypeName() const {
  return "autofill_assistant.UnexpectedErrorInfoProto";
}


// ===================================================================

class AutofillErrorInfoProto_AutofillFieldError::_Internal {
 public:
  using HasBits = decltype(std::declval<AutofillErrorInfoProto_AutofillFieldError>()._has_bits_);
  static const ::autofill_assistant::SelectorProto& field(const AutofillErrorInfoProto_AutofillFieldError* msg);
  static void set_has_field(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_value_expression(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::autofill_assistant::SelectorProto&
AutofillErrorInfoProto_AutofillFieldError::_Internal::field(const AutofillErrorInfoProto_AutofillFieldError* msg) {
  return *msg->field_;
}
AutofillErrorInfoProto_AutofillFieldError::AutofillErrorInfoProto_AutofillFieldError(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.AutofillErrorInfoProto.AutofillFieldError)
}
AutofillErrorInfoProto_AutofillFieldError::AutofillErrorInfoProto_AutofillFieldError(const AutofillErrorInfoProto_AutofillFieldError& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  value_expression_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    value_expression_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_value_expression()) {
    value_expression_.Set(from._internal_value_expression(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_field()) {
    field_ = new ::autofill_assistant::SelectorProto(*from.field_);
  } else {
    field_ = nullptr;
  }
  clear_has_error_type();
  switch (from.error_type_case()) {
    case kNoFallbackValue: {
      _internal_set_no_fallback_value(from._internal_no_fallback_value());
      break;
    }
    case kStatus: {
      _internal_set_status(from._internal_status());
      break;
    }
    case kEmptyAfterFallback: {
      _internal_set_empty_after_fallback(from._internal_empty_after_fallback());
      break;
    }
    case kFilledAfterClear: {
      _internal_set_filled_after_clear(from._internal_filled_after_clear());
      break;
    }
    case ERROR_TYPE_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.AutofillErrorInfoProto.AutofillFieldError)
}

inline void AutofillErrorInfoProto_AutofillFieldError::SharedCtor() {
value_expression_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  value_expression_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
field_ = nullptr;
clear_has_error_type();
}

AutofillErrorInfoProto_AutofillFieldError::~AutofillErrorInfoProto_AutofillFieldError() {
  // @@protoc_insertion_point(destructor:autofill_assistant.AutofillErrorInfoProto.AutofillFieldError)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AutofillErrorInfoProto_AutofillFieldError::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  value_expression_.Destroy();
  if (this != internal_default_instance()) delete field_;
  if (has_error_type()) {
    clear_error_type();
  }
}

void AutofillErrorInfoProto_AutofillFieldError::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void AutofillErrorInfoProto_AutofillFieldError::clear_error_type() {
// @@protoc_insertion_point(one_of_clear_start:autofill_assistant.AutofillErrorInfoProto.AutofillFieldError)
  switch (error_type_case()) {
    case kNoFallbackValue: {
      // No need to clear
      break;
    }
    case kStatus: {
      // No need to clear
      break;
    }
    case kEmptyAfterFallback: {
      // No need to clear
      break;
    }
    case kFilledAfterClear: {
      // No need to clear
      break;
    }
    case ERROR_TYPE_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = ERROR_TYPE_NOT_SET;
}


void AutofillErrorInfoProto_AutofillFieldError::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.AutofillErrorInfoProto.AutofillFieldError)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      value_expression_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(field_ != nullptr);
      field_->Clear();
    }
  }
  clear_error_type();
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* AutofillErrorInfoProto_AutofillFieldError::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .autofill_assistant.SelectorProto field = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_field(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool no_fallback_value = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _internal_set_no_fallback_value(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.ProcessedActionStatusProto status = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::autofill_assistant::ProcessedActionStatusProto_IsValid(val))) {
            _internal_set_status(static_cast<::autofill_assistant::ProcessedActionStatusProto>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional string value_expression = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_value_expression();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool empty_after_fallback = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _internal_set_empty_after_fallback(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool filled_after_clear = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _internal_set_filled_after_clear(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AutofillErrorInfoProto_AutofillFieldError::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.AutofillErrorInfoProto.AutofillFieldError)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .autofill_assistant.SelectorProto field = 1;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::field(this),
        _Internal::field(this).GetCachedSize(), target, stream);
  }

  switch (error_type_case()) {
    case kNoFallbackValue: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_no_fallback_value(), target);
      break;
    }
    case kStatus: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteEnumToArray(
        4, this->_internal_status(), target);
      break;
    }
    default: ;
  }
  // optional string value_expression = 5;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_value_expression(), target);
  }

  switch (error_type_case()) {
    case kEmptyAfterFallback: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteBoolToArray(6, this->_internal_empty_after_fallback(), target);
      break;
    }
    case kFilledAfterClear: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteBoolToArray(7, this->_internal_filled_after_clear(), target);
      break;
    }
    default: ;
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.AutofillErrorInfoProto.AutofillFieldError)
  return target;
}

size_t AutofillErrorInfoProto_AutofillFieldError::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.AutofillErrorInfoProto.AutofillFieldError)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string value_expression = 5;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_value_expression());
    }

    // optional .autofill_assistant.SelectorProto field = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *field_);
    }

  }
  switch (error_type_case()) {
    // bool no_fallback_value = 3;
    case kNoFallbackValue: {
      total_size += 1 + 1;
      break;
    }
    // .autofill_assistant.ProcessedActionStatusProto status = 4;
    case kStatus: {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_status());
      break;
    }
    // bool empty_after_fallback = 6;
    case kEmptyAfterFallback: {
      total_size += 1 + 1;
      break;
    }
    // bool filled_after_clear = 7;
    case kFilledAfterClear: {
      total_size += 1 + 1;
      break;
    }
    case ERROR_TYPE_NOT_SET: {
      break;
    }
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void AutofillErrorInfoProto_AutofillFieldError::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const AutofillErrorInfoProto_AutofillFieldError*>(
      &from));
}

void AutofillErrorInfoProto_AutofillFieldError::MergeFrom(const AutofillErrorInfoProto_AutofillFieldError& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.AutofillErrorInfoProto.AutofillFieldError)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_value_expression(from._internal_value_expression());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_field()->::autofill_assistant::SelectorProto::MergeFrom(from._internal_field());
    }
  }
  switch (from.error_type_case()) {
    case kNoFallbackValue: {
      _internal_set_no_fallback_value(from._internal_no_fallback_value());
      break;
    }
    case kStatus: {
      _internal_set_status(from._internal_status());
      break;
    }
    case kEmptyAfterFallback: {
      _internal_set_empty_after_fallback(from._internal_empty_after_fallback());
      break;
    }
    case kFilledAfterClear: {
      _internal_set_filled_after_clear(from._internal_filled_after_clear());
      break;
    }
    case ERROR_TYPE_NOT_SET: {
      break;
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void AutofillErrorInfoProto_AutofillFieldError::CopyFrom(const AutofillErrorInfoProto_AutofillFieldError& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.AutofillErrorInfoProto.AutofillFieldError)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AutofillErrorInfoProto_AutofillFieldError::IsInitialized() const {
  return true;
}

void AutofillErrorInfoProto_AutofillFieldError::InternalSwap(AutofillErrorInfoProto_AutofillFieldError* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &value_expression_, lhs_arena,
      &other->value_expression_, rhs_arena
  );
  swap(field_, other->field_);
  swap(error_type_, other->error_type_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

std::string AutofillErrorInfoProto_AutofillFieldError::GetTypeName() const {
  return "autofill_assistant.AutofillErrorInfoProto.AutofillFieldError";
}


// ===================================================================

class AutofillErrorInfoProto::_Internal {
 public:
  using HasBits = decltype(std::declval<AutofillErrorInfoProto>()._has_bits_);
  static void set_has_client_memory_address_key_names(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_address_key_requested(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_address_pointee_was_null(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_autofill_error_status(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_get_full_card_failure_type(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

AutofillErrorInfoProto::AutofillErrorInfoProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  autofill_field_error_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.AutofillErrorInfoProto)
}
AutofillErrorInfoProto::AutofillErrorInfoProto(const AutofillErrorInfoProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      autofill_field_error_(from.autofill_field_error_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  client_memory_address_key_names_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    client_memory_address_key_names_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_client_memory_address_key_names()) {
    client_memory_address_key_names_.Set(from._internal_client_memory_address_key_names(), 
      GetArenaForAllocation());
  }
  address_key_requested_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    address_key_requested_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_address_key_requested()) {
    address_key_requested_.Set(from._internal_address_key_requested(), 
      GetArenaForAllocation());
  }
  ::memcpy(&address_pointee_was_null_, &from.address_pointee_was_null_,
    static_cast<size_t>(reinterpret_cast<char*>(&get_full_card_failure_type_) -
    reinterpret_cast<char*>(&address_pointee_was_null_)) + sizeof(get_full_card_failure_type_));
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.AutofillErrorInfoProto)
}

inline void AutofillErrorInfoProto::SharedCtor() {
client_memory_address_key_names_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  client_memory_address_key_names_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
address_key_requested_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  address_key_requested_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&address_pointee_was_null_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&get_full_card_failure_type_) -
    reinterpret_cast<char*>(&address_pointee_was_null_)) + sizeof(get_full_card_failure_type_));
}

AutofillErrorInfoProto::~AutofillErrorInfoProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.AutofillErrorInfoProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AutofillErrorInfoProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  client_memory_address_key_names_.Destroy();
  address_key_requested_.Destroy();
}

void AutofillErrorInfoProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void AutofillErrorInfoProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.AutofillErrorInfoProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  autofill_field_error_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      client_memory_address_key_names_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      address_key_requested_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000001cu) {
    ::memset(&address_pointee_was_null_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&get_full_card_failure_type_) -
        reinterpret_cast<char*>(&address_pointee_was_null_)) + sizeof(get_full_card_failure_type_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* AutofillErrorInfoProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string client_memory_address_key_names = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_client_memory_address_key_names();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string address_key_requested = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_address_key_requested();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool address_pointee_was_null = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_address_pointee_was_null(&has_bits);
          address_pointee_was_null_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .autofill_assistant.ProcessedActionStatusProto autofill_error_status = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::autofill_assistant::ProcessedActionStatusProto_IsValid(val))) {
            _internal_set_autofill_error_status(static_cast<::autofill_assistant::ProcessedActionStatusProto>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // repeated .autofill_assistant.AutofillErrorInfoProto.AutofillFieldError autofill_field_error = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_autofill_field_error(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .autofill_assistant.AutofillErrorInfoProto.GetFullCardFailureType get_full_card_failure_type = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::autofill_assistant::AutofillErrorInfoProto_GetFullCardFailureType_IsValid(val))) {
            _internal_set_get_full_card_failure_type(static_cast<::autofill_assistant::AutofillErrorInfoProto_GetFullCardFailureType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(6, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AutofillErrorInfoProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.AutofillErrorInfoProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string client_memory_address_key_names = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_client_memory_address_key_names(), target);
  }

  // optional string address_key_requested = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_address_key_requested(), target);
  }

  // optional bool address_pointee_was_null = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_address_pointee_was_null(), target);
  }

  // optional .autofill_assistant.ProcessedActionStatusProto autofill_error_status = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      4, this->_internal_autofill_error_status(), target);
  }

  // repeated .autofill_assistant.AutofillErrorInfoProto.AutofillFieldError autofill_field_error = 5;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_autofill_field_error_size()); i < n; i++) {
    const auto& repfield = this->_internal_autofill_field_error(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(5, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional .autofill_assistant.AutofillErrorInfoProto.GetFullCardFailureType get_full_card_failure_type = 6;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      6, this->_internal_get_full_card_failure_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.AutofillErrorInfoProto)
  return target;
}

size_t AutofillErrorInfoProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.AutofillErrorInfoProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .autofill_assistant.AutofillErrorInfoProto.AutofillFieldError autofill_field_error = 5;
  total_size += 1UL * this->_internal_autofill_field_error_size();
  for (const auto& msg : this->autofill_field_error_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional string client_memory_address_key_names = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_client_memory_address_key_names());
    }

    // optional string address_key_requested = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_address_key_requested());
    }

    // optional bool address_pointee_was_null = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

    // optional .autofill_assistant.ProcessedActionStatusProto autofill_error_status = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_autofill_error_status());
    }

    // optional .autofill_assistant.AutofillErrorInfoProto.GetFullCardFailureType get_full_card_failure_type = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_get_full_card_failure_type());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void AutofillErrorInfoProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const AutofillErrorInfoProto*>(
      &from));
}

void AutofillErrorInfoProto::MergeFrom(const AutofillErrorInfoProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.AutofillErrorInfoProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  autofill_field_error_.MergeFrom(from.autofill_field_error_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_client_memory_address_key_names(from._internal_client_memory_address_key_names());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_address_key_requested(from._internal_address_key_requested());
    }
    if (cached_has_bits & 0x00000004u) {
      address_pointee_was_null_ = from.address_pointee_was_null_;
    }
    if (cached_has_bits & 0x00000008u) {
      autofill_error_status_ = from.autofill_error_status_;
    }
    if (cached_has_bits & 0x00000010u) {
      get_full_card_failure_type_ = from.get_full_card_failure_type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void AutofillErrorInfoProto::CopyFrom(const AutofillErrorInfoProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.AutofillErrorInfoProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AutofillErrorInfoProto::IsInitialized() const {
  return true;
}

void AutofillErrorInfoProto::InternalSwap(AutofillErrorInfoProto* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  autofill_field_error_.InternalSwap(&other->autofill_field_error_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &client_memory_address_key_names_, lhs_arena,
      &other->client_memory_address_key_names_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &address_key_requested_, lhs_arena,
      &other->address_key_requested_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AutofillErrorInfoProto, get_full_card_failure_type_)
      + sizeof(AutofillErrorInfoProto::get_full_card_failure_type_)
      - PROTOBUF_FIELD_OFFSET(AutofillErrorInfoProto, address_pointee_was_null_)>(
          reinterpret_cast<char*>(&address_pointee_was_null_),
          reinterpret_cast<char*>(&other->address_pointee_was_null_));
}

std::string AutofillErrorInfoProto::GetTypeName() const {
  return "autofill_assistant.AutofillErrorInfoProto";
}


// ===================================================================

class WebControllerErrorInfoProto::_Internal {
 public:
  using HasBits = decltype(std::declval<WebControllerErrorInfoProto>()._has_bits_);
  static void set_has_failed_web_action(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

WebControllerErrorInfoProto::WebControllerErrorInfoProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.WebControllerErrorInfoProto)
}
WebControllerErrorInfoProto::WebControllerErrorInfoProto(const WebControllerErrorInfoProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  failed_web_action_ = from.failed_web_action_;
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.WebControllerErrorInfoProto)
}

inline void WebControllerErrorInfoProto::SharedCtor() {
failed_web_action_ = 0;
}

WebControllerErrorInfoProto::~WebControllerErrorInfoProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.WebControllerErrorInfoProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void WebControllerErrorInfoProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void WebControllerErrorInfoProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void WebControllerErrorInfoProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.WebControllerErrorInfoProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  failed_web_action_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* WebControllerErrorInfoProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .autofill_assistant.WebControllerErrorInfoProto.WebAction failed_web_action = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::autofill_assistant::WebControllerErrorInfoProto_WebAction_IsValid(val))) {
            _internal_set_failed_web_action(static_cast<::autofill_assistant::WebControllerErrorInfoProto_WebAction>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* WebControllerErrorInfoProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.WebControllerErrorInfoProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .autofill_assistant.WebControllerErrorInfoProto.WebAction failed_web_action = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_failed_web_action(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.WebControllerErrorInfoProto)
  return target;
}

size_t WebControllerErrorInfoProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.WebControllerErrorInfoProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .autofill_assistant.WebControllerErrorInfoProto.WebAction failed_web_action = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_failed_web_action());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void WebControllerErrorInfoProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const WebControllerErrorInfoProto*>(
      &from));
}

void WebControllerErrorInfoProto::MergeFrom(const WebControllerErrorInfoProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.WebControllerErrorInfoProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_failed_web_action()) {
    _internal_set_failed_web_action(from._internal_failed_web_action());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void WebControllerErrorInfoProto::CopyFrom(const WebControllerErrorInfoProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.WebControllerErrorInfoProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool WebControllerErrorInfoProto::IsInitialized() const {
  return true;
}

void WebControllerErrorInfoProto::InternalSwap(WebControllerErrorInfoProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(failed_web_action_, other->failed_web_action_);
}

std::string WebControllerErrorInfoProto::GetTypeName() const {
  return "autofill_assistant.WebControllerErrorInfoProto";
}


// ===================================================================

class ElementFinderInfoProto_PredictedElement::_Internal {
 public:
  using HasBits = decltype(std::declval<ElementFinderInfoProto_PredictedElement>()._has_bits_);
  static const ::autofill_assistant::SelectorProto_SemanticFilter& semantic_filter(const ElementFinderInfoProto_PredictedElement* msg);
  static void set_has_semantic_filter(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_backend_node_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::autofill_assistant::SelectorProto_SemanticFilter&
ElementFinderInfoProto_PredictedElement::_Internal::semantic_filter(const ElementFinderInfoProto_PredictedElement* msg) {
  return *msg->semantic_filter_;
}
ElementFinderInfoProto_PredictedElement::ElementFinderInfoProto_PredictedElement(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.ElementFinderInfoProto.PredictedElement)
}
ElementFinderInfoProto_PredictedElement::ElementFinderInfoProto_PredictedElement(const ElementFinderInfoProto_PredictedElement& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_semantic_filter()) {
    semantic_filter_ = new ::autofill_assistant::SelectorProto_SemanticFilter(*from.semantic_filter_);
  } else {
    semantic_filter_ = nullptr;
  }
  backend_node_id_ = from.backend_node_id_;
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.ElementFinderInfoProto.PredictedElement)
}

inline void ElementFinderInfoProto_PredictedElement::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&semantic_filter_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&backend_node_id_) -
    reinterpret_cast<char*>(&semantic_filter_)) + sizeof(backend_node_id_));
}

ElementFinderInfoProto_PredictedElement::~ElementFinderInfoProto_PredictedElement() {
  // @@protoc_insertion_point(destructor:autofill_assistant.ElementFinderInfoProto.PredictedElement)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ElementFinderInfoProto_PredictedElement::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete semantic_filter_;
}

void ElementFinderInfoProto_PredictedElement::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ElementFinderInfoProto_PredictedElement::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.ElementFinderInfoProto.PredictedElement)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(semantic_filter_ != nullptr);
    semantic_filter_->Clear();
  }
  backend_node_id_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ElementFinderInfoProto_PredictedElement::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 backend_node_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_backend_node_id(&has_bits);
          backend_node_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .autofill_assistant.SelectorProto.SemanticFilter semantic_filter = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_semantic_filter(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ElementFinderInfoProto_PredictedElement::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.ElementFinderInfoProto.PredictedElement)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 backend_node_id = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_backend_node_id(), target);
  }

  // optional .autofill_assistant.SelectorProto.SemanticFilter semantic_filter = 4;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::semantic_filter(this),
        _Internal::semantic_filter(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.ElementFinderInfoProto.PredictedElement)
  return target;
}

size_t ElementFinderInfoProto_PredictedElement::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.ElementFinderInfoProto.PredictedElement)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .autofill_assistant.SelectorProto.SemanticFilter semantic_filter = 4;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *semantic_filter_);
    }

    // optional int32 backend_node_id = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_backend_node_id());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ElementFinderInfoProto_PredictedElement::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ElementFinderInfoProto_PredictedElement*>(
      &from));
}

void ElementFinderInfoProto_PredictedElement::MergeFrom(const ElementFinderInfoProto_PredictedElement& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.ElementFinderInfoProto.PredictedElement)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_semantic_filter()->::autofill_assistant::SelectorProto_SemanticFilter::MergeFrom(from._internal_semantic_filter());
    }
    if (cached_has_bits & 0x00000002u) {
      backend_node_id_ = from.backend_node_id_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ElementFinderInfoProto_PredictedElement::CopyFrom(const ElementFinderInfoProto_PredictedElement& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.ElementFinderInfoProto.PredictedElement)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ElementFinderInfoProto_PredictedElement::IsInitialized() const {
  return true;
}

void ElementFinderInfoProto_PredictedElement::InternalSwap(ElementFinderInfoProto_PredictedElement* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ElementFinderInfoProto_PredictedElement, backend_node_id_)
      + sizeof(ElementFinderInfoProto_PredictedElement::backend_node_id_)
      - PROTOBUF_FIELD_OFFSET(ElementFinderInfoProto_PredictedElement, semantic_filter_)>(
          reinterpret_cast<char*>(&semantic_filter_),
          reinterpret_cast<char*>(&other->semantic_filter_));
}

std::string ElementFinderInfoProto_PredictedElement::GetTypeName() const {
  return "autofill_assistant.ElementFinderInfoProto.PredictedElement";
}


// ===================================================================

class ElementFinderInfoProto_SemanticInferenceResult::_Internal {
 public:
};

ElementFinderInfoProto_SemanticInferenceResult::ElementFinderInfoProto_SemanticInferenceResult(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  predicted_elements_(arena),
  status_per_frame_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.ElementFinderInfoProto.SemanticInferenceResult)
}
ElementFinderInfoProto_SemanticInferenceResult::ElementFinderInfoProto_SemanticInferenceResult(const ElementFinderInfoProto_SemanticInferenceResult& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      predicted_elements_(from.predicted_elements_),
      status_per_frame_(from.status_per_frame_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.ElementFinderInfoProto.SemanticInferenceResult)
}

inline void ElementFinderInfoProto_SemanticInferenceResult::SharedCtor() {
}

ElementFinderInfoProto_SemanticInferenceResult::~ElementFinderInfoProto_SemanticInferenceResult() {
  // @@protoc_insertion_point(destructor:autofill_assistant.ElementFinderInfoProto.SemanticInferenceResult)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ElementFinderInfoProto_SemanticInferenceResult::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ElementFinderInfoProto_SemanticInferenceResult::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ElementFinderInfoProto_SemanticInferenceResult::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.ElementFinderInfoProto.SemanticInferenceResult)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  predicted_elements_.Clear();
  status_per_frame_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ElementFinderInfoProto_SemanticInferenceResult::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .autofill_assistant.ElementFinderInfoProto.PredictedElement predicted_elements = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_predicted_elements(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .autofill_assistant.ElementFinderInfoProto.SemanticInferenceStatus status_per_frame = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          ptr -= 1;
          do {
            ptr += 1;
            uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
            CHK_(ptr);
            if (PROTOBUF_PREDICT_TRUE(::autofill_assistant::ElementFinderInfoProto_SemanticInferenceStatus_IsValid(val))) {
              _internal_add_status_per_frame(static_cast<::autofill_assistant::ElementFinderInfoProto_SemanticInferenceStatus>(val));
            } else {
              ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
            }
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<16>(ptr));
        } else if (static_cast<uint8_t>(tag) == 18) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedEnumParser<std::string>(_internal_mutable_status_per_frame(), ptr, ctx, ::autofill_assistant::ElementFinderInfoProto_SemanticInferenceStatus_IsValid, &_internal_metadata_, 2);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ElementFinderInfoProto_SemanticInferenceResult::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.ElementFinderInfoProto.SemanticInferenceResult)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .autofill_assistant.ElementFinderInfoProto.PredictedElement predicted_elements = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_predicted_elements_size()); i < n; i++) {
    const auto& repfield = this->_internal_predicted_elements(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .autofill_assistant.ElementFinderInfoProto.SemanticInferenceStatus status_per_frame = 2;
  for (int i = 0, n = this->_internal_status_per_frame_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        2, this->_internal_status_per_frame(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.ElementFinderInfoProto.SemanticInferenceResult)
  return target;
}

size_t ElementFinderInfoProto_SemanticInferenceResult::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.ElementFinderInfoProto.SemanticInferenceResult)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .autofill_assistant.ElementFinderInfoProto.PredictedElement predicted_elements = 1;
  total_size += 1UL * this->_internal_predicted_elements_size();
  for (const auto& msg : this->predicted_elements_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .autofill_assistant.ElementFinderInfoProto.SemanticInferenceStatus status_per_frame = 2;
  {
    size_t data_size = 0;
    unsigned int count = static_cast<unsigned int>(this->_internal_status_per_frame_size());for (unsigned int i = 0; i < count; i++) {
      data_size += ::_pbi::WireFormatLite::EnumSize(
        this->_internal_status_per_frame(static_cast<int>(i)));
    }
    total_size += (1UL * count) + data_size;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ElementFinderInfoProto_SemanticInferenceResult::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ElementFinderInfoProto_SemanticInferenceResult*>(
      &from));
}

void ElementFinderInfoProto_SemanticInferenceResult::MergeFrom(const ElementFinderInfoProto_SemanticInferenceResult& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.ElementFinderInfoProto.SemanticInferenceResult)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  predicted_elements_.MergeFrom(from.predicted_elements_);
  status_per_frame_.MergeFrom(from.status_per_frame_);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ElementFinderInfoProto_SemanticInferenceResult::CopyFrom(const ElementFinderInfoProto_SemanticInferenceResult& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.ElementFinderInfoProto.SemanticInferenceResult)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ElementFinderInfoProto_SemanticInferenceResult::IsInitialized() const {
  return true;
}

void ElementFinderInfoProto_SemanticInferenceResult::InternalSwap(ElementFinderInfoProto_SemanticInferenceResult* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  predicted_elements_.InternalSwap(&other->predicted_elements_);
  status_per_frame_.InternalSwap(&other->status_per_frame_);
}

std::string ElementFinderInfoProto_SemanticInferenceResult::GetTypeName() const {
  return "autofill_assistant.ElementFinderInfoProto.SemanticInferenceResult";
}


// ===================================================================

class ElementFinderInfoProto::_Internal {
 public:
  using HasBits = decltype(std::declval<ElementFinderInfoProto>()._has_bits_);
  static void set_has_tracking_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_failed_filter_index_range_start(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_failed_filter_index_range_end(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_status(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_get_document_failed(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static const ::autofill_assistant::ElementFinderInfoProto_SemanticInferenceResult& semantic_inference_result(const ElementFinderInfoProto* msg);
  static void set_has_semantic_inference_result(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::autofill_assistant::ElementFinderInfoProto_SemanticInferenceResult&
ElementFinderInfoProto::_Internal::semantic_inference_result(const ElementFinderInfoProto* msg) {
  return *msg->semantic_inference_result_;
}
ElementFinderInfoProto::ElementFinderInfoProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.ElementFinderInfoProto)
}
ElementFinderInfoProto::ElementFinderInfoProto(const ElementFinderInfoProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_semantic_inference_result()) {
    semantic_inference_result_ = new ::autofill_assistant::ElementFinderInfoProto_SemanticInferenceResult(*from.semantic_inference_result_);
  } else {
    semantic_inference_result_ = nullptr;
  }
  ::memcpy(&tracking_id_, &from.tracking_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&get_document_failed_) -
    reinterpret_cast<char*>(&tracking_id_)) + sizeof(get_document_failed_));
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.ElementFinderInfoProto)
}

inline void ElementFinderInfoProto::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&semantic_inference_result_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&get_document_failed_) -
    reinterpret_cast<char*>(&semantic_inference_result_)) + sizeof(get_document_failed_));
}

ElementFinderInfoProto::~ElementFinderInfoProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.ElementFinderInfoProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ElementFinderInfoProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete semantic_inference_result_;
}

void ElementFinderInfoProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ElementFinderInfoProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.ElementFinderInfoProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(semantic_inference_result_ != nullptr);
    semantic_inference_result_->Clear();
  }
  if (cached_has_bits & 0x0000003eu) {
    ::memset(&tracking_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&get_document_failed_) -
        reinterpret_cast<char*>(&tracking_id_)) + sizeof(get_document_failed_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ElementFinderInfoProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 tracking_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_tracking_id(&has_bits);
          tracking_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 failed_filter_index_range_start = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_failed_filter_index_range_start(&has_bits);
          failed_filter_index_range_start_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 failed_filter_index_range_end = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_failed_filter_index_range_end(&has_bits);
          failed_filter_index_range_end_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .autofill_assistant.ProcessedActionStatusProto status = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::autofill_assistant::ProcessedActionStatusProto_IsValid(val))) {
            _internal_set_status(static_cast<::autofill_assistant::ProcessedActionStatusProto>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional bool get_document_failed = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_get_document_failed(&has_bits);
          get_document_failed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .autofill_assistant.ElementFinderInfoProto.SemanticInferenceResult semantic_inference_result = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_semantic_inference_result(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ElementFinderInfoProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.ElementFinderInfoProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int64 tracking_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_tracking_id(), target);
  }

  // optional int32 failed_filter_index_range_start = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_failed_filter_index_range_start(), target);
  }

  // optional int32 failed_filter_index_range_end = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_failed_filter_index_range_end(), target);
  }

  // optional .autofill_assistant.ProcessedActionStatusProto status = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      4, this->_internal_status(), target);
  }

  // optional bool get_document_failed = 5;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_get_document_failed(), target);
  }

  // optional .autofill_assistant.ElementFinderInfoProto.SemanticInferenceResult semantic_inference_result = 6;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::semantic_inference_result(this),
        _Internal::semantic_inference_result(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.ElementFinderInfoProto)
  return target;
}

size_t ElementFinderInfoProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.ElementFinderInfoProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional .autofill_assistant.ElementFinderInfoProto.SemanticInferenceResult semantic_inference_result = 6;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *semantic_inference_result_);
    }

    // optional int64 tracking_id = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_tracking_id());
    }

    // optional int32 failed_filter_index_range_start = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_failed_filter_index_range_start());
    }

    // optional int32 failed_filter_index_range_end = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_failed_filter_index_range_end());
    }

    // optional .autofill_assistant.ProcessedActionStatusProto status = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_status());
    }

    // optional bool get_document_failed = 5;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 1;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ElementFinderInfoProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ElementFinderInfoProto*>(
      &from));
}

void ElementFinderInfoProto::MergeFrom(const ElementFinderInfoProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.ElementFinderInfoProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_semantic_inference_result()->::autofill_assistant::ElementFinderInfoProto_SemanticInferenceResult::MergeFrom(from._internal_semantic_inference_result());
    }
    if (cached_has_bits & 0x00000002u) {
      tracking_id_ = from.tracking_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      failed_filter_index_range_start_ = from.failed_filter_index_range_start_;
    }
    if (cached_has_bits & 0x00000008u) {
      failed_filter_index_range_end_ = from.failed_filter_index_range_end_;
    }
    if (cached_has_bits & 0x00000010u) {
      status_ = from.status_;
    }
    if (cached_has_bits & 0x00000020u) {
      get_document_failed_ = from.get_document_failed_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ElementFinderInfoProto::CopyFrom(const ElementFinderInfoProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.ElementFinderInfoProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ElementFinderInfoProto::IsInitialized() const {
  return true;
}

void ElementFinderInfoProto::InternalSwap(ElementFinderInfoProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ElementFinderInfoProto, get_document_failed_)
      + sizeof(ElementFinderInfoProto::get_document_failed_)
      - PROTOBUF_FIELD_OFFSET(ElementFinderInfoProto, semantic_inference_result_)>(
          reinterpret_cast<char*>(&semantic_inference_result_),
          reinterpret_cast<char*>(&other->semantic_inference_result_));
}

std::string ElementFinderInfoProto::GetTypeName() const {
  return "autofill_assistant.ElementFinderInfoProto";
}


// ===================================================================

class SelectorProto_Filter::_Internal {
 public:
  static const ::autofill_assistant::SelectorProto_EmptyFilter& enter_frame(const SelectorProto_Filter* msg);
  static const ::autofill_assistant::TextFilter& inner_text(const SelectorProto_Filter* msg);
  static const ::autofill_assistant::TextFilter& value(const SelectorProto_Filter* msg);
  static const ::autofill_assistant::SelectorProto_BoundingBoxFilter& bounding_box(const SelectorProto_Filter* msg);
  static const ::autofill_assistant::SelectorProto_NthMatchFilter& nth_match(const SelectorProto_Filter* msg);
  static const ::autofill_assistant::SelectorProto_PseudoElementContent& pseudo_element_content(const SelectorProto_Filter* msg);
  static const ::autofill_assistant::SelectorProto_EmptyFilter& labelled(const SelectorProto_Filter* msg);
  static const ::autofill_assistant::SelectorProto_CssStyleFilter& css_style(const SelectorProto_Filter* msg);
  static const ::autofill_assistant::SelectorProto_OnTopFilter& on_top(const SelectorProto_Filter* msg);
  static const ::autofill_assistant::SelectorProto_PropertyFilter& property(const SelectorProto_Filter* msg);
  static const ::autofill_assistant::SelectorProto_EmptyFilter& parent(const SelectorProto_Filter* msg);
  static const ::autofill_assistant::SelectorProto_SemanticFilter& semantic(const SelectorProto_Filter* msg);
};

const ::autofill_assistant::SelectorProto_EmptyFilter&
SelectorProto_Filter::_Internal::enter_frame(const SelectorProto_Filter* msg) {
  return *msg->filter_.enter_frame_;
}
const ::autofill_assistant::TextFilter&
SelectorProto_Filter::_Internal::inner_text(const SelectorProto_Filter* msg) {
  return *msg->filter_.inner_text_;
}
const ::autofill_assistant::TextFilter&
SelectorProto_Filter::_Internal::value(const SelectorProto_Filter* msg) {
  return *msg->filter_.value_;
}
const ::autofill_assistant::SelectorProto_BoundingBoxFilter&
SelectorProto_Filter::_Internal::bounding_box(const SelectorProto_Filter* msg) {
  return *msg->filter_.bounding_box_;
}
const ::autofill_assistant::SelectorProto_NthMatchFilter&
SelectorProto_Filter::_Internal::nth_match(const SelectorProto_Filter* msg) {
  return *msg->filter_.nth_match_;
}
const ::autofill_assistant::SelectorProto_PseudoElementContent&
SelectorProto_Filter::_Internal::pseudo_element_content(const SelectorProto_Filter* msg) {
  return *msg->filter_.pseudo_element_content_;
}
const ::autofill_assistant::SelectorProto_EmptyFilter&
SelectorProto_Filter::_Internal::labelled(const SelectorProto_Filter* msg) {
  return *msg->filter_.labelled_;
}
const ::autofill_assistant::SelectorProto_CssStyleFilter&
SelectorProto_Filter::_Internal::css_style(const SelectorProto_Filter* msg) {
  return *msg->filter_.css_style_;
}
const ::autofill_assistant::SelectorProto_OnTopFilter&
SelectorProto_Filter::_Internal::on_top(const SelectorProto_Filter* msg) {
  return *msg->filter_.on_top_;
}
const ::autofill_assistant::SelectorProto_PropertyFilter&
SelectorProto_Filter::_Internal::property(const SelectorProto_Filter* msg) {
  return *msg->filter_.property_;
}
const ::autofill_assistant::SelectorProto_EmptyFilter&
SelectorProto_Filter::_Internal::parent(const SelectorProto_Filter* msg) {
  return *msg->filter_.parent_;
}
const ::autofill_assistant::SelectorProto_SemanticFilter&
SelectorProto_Filter::_Internal::semantic(const SelectorProto_Filter* msg) {
  return *msg->filter_.semantic_;
}
void SelectorProto_Filter::set_allocated_enter_frame(::autofill_assistant::SelectorProto_EmptyFilter* enter_frame) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_filter();
  if (enter_frame) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(enter_frame);
    if (message_arena != submessage_arena) {
      enter_frame = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, enter_frame, submessage_arena);
    }
    set_has_enter_frame();
    filter_.enter_frame_ = enter_frame;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.SelectorProto.Filter.enter_frame)
}
void SelectorProto_Filter::set_allocated_inner_text(::autofill_assistant::TextFilter* inner_text) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_filter();
  if (inner_text) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(inner_text));
    if (message_arena != submessage_arena) {
      inner_text = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, inner_text, submessage_arena);
    }
    set_has_inner_text();
    filter_.inner_text_ = inner_text;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.SelectorProto.Filter.inner_text)
}
void SelectorProto_Filter::clear_inner_text() {
  if (_internal_has_inner_text()) {
    if (GetArenaForAllocation() == nullptr) {
      delete filter_.inner_text_;
    }
    clear_has_filter();
  }
}
void SelectorProto_Filter::set_allocated_value(::autofill_assistant::TextFilter* value) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_filter();
  if (value) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(value));
    if (message_arena != submessage_arena) {
      value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    set_has_value();
    filter_.value_ = value;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.SelectorProto.Filter.value)
}
void SelectorProto_Filter::clear_value() {
  if (_internal_has_value()) {
    if (GetArenaForAllocation() == nullptr) {
      delete filter_.value_;
    }
    clear_has_filter();
  }
}
void SelectorProto_Filter::set_allocated_bounding_box(::autofill_assistant::SelectorProto_BoundingBoxFilter* bounding_box) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_filter();
  if (bounding_box) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(bounding_box);
    if (message_arena != submessage_arena) {
      bounding_box = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, bounding_box, submessage_arena);
    }
    set_has_bounding_box();
    filter_.bounding_box_ = bounding_box;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.SelectorProto.Filter.bounding_box)
}
void SelectorProto_Filter::set_allocated_nth_match(::autofill_assistant::SelectorProto_NthMatchFilter* nth_match) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_filter();
  if (nth_match) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(nth_match);
    if (message_arena != submessage_arena) {
      nth_match = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, nth_match, submessage_arena);
    }
    set_has_nth_match();
    filter_.nth_match_ = nth_match;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.SelectorProto.Filter.nth_match)
}
void SelectorProto_Filter::set_allocated_pseudo_element_content(::autofill_assistant::SelectorProto_PseudoElementContent* pseudo_element_content) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_filter();
  if (pseudo_element_content) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(pseudo_element_content);
    if (message_arena != submessage_arena) {
      pseudo_element_content = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pseudo_element_content, submessage_arena);
    }
    set_has_pseudo_element_content();
    filter_.pseudo_element_content_ = pseudo_element_content;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.SelectorProto.Filter.pseudo_element_content)
}
void SelectorProto_Filter::set_allocated_labelled(::autofill_assistant::SelectorProto_EmptyFilter* labelled) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_filter();
  if (labelled) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(labelled);
    if (message_arena != submessage_arena) {
      labelled = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, labelled, submessage_arena);
    }
    set_has_labelled();
    filter_.labelled_ = labelled;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.SelectorProto.Filter.labelled)
}
void SelectorProto_Filter::set_allocated_css_style(::autofill_assistant::SelectorProto_CssStyleFilter* css_style) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_filter();
  if (css_style) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(css_style);
    if (message_arena != submessage_arena) {
      css_style = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, css_style, submessage_arena);
    }
    set_has_css_style();
    filter_.css_style_ = css_style;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.SelectorProto.Filter.css_style)
}
void SelectorProto_Filter::set_allocated_on_top(::autofill_assistant::SelectorProto_OnTopFilter* on_top) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_filter();
  if (on_top) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(on_top);
    if (message_arena != submessage_arena) {
      on_top = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, on_top, submessage_arena);
    }
    set_has_on_top();
    filter_.on_top_ = on_top;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.SelectorProto.Filter.on_top)
}
void SelectorProto_Filter::set_allocated_property(::autofill_assistant::SelectorProto_PropertyFilter* property) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_filter();
  if (property) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(property);
    if (message_arena != submessage_arena) {
      property = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, property, submessage_arena);
    }
    set_has_property();
    filter_.property_ = property;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.SelectorProto.Filter.property)
}
void SelectorProto_Filter::set_allocated_parent(::autofill_assistant::SelectorProto_EmptyFilter* parent) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_filter();
  if (parent) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(parent);
    if (message_arena != submessage_arena) {
      parent = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, parent, submessage_arena);
    }
    set_has_parent();
    filter_.parent_ = parent;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.SelectorProto.Filter.parent)
}
void SelectorProto_Filter::set_allocated_semantic(::autofill_assistant::SelectorProto_SemanticFilter* semantic) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_filter();
  if (semantic) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(semantic);
    if (message_arena != submessage_arena) {
      semantic = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, semantic, submessage_arena);
    }
    set_has_semantic();
    filter_.semantic_ = semantic;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.SelectorProto.Filter.semantic)
}
SelectorProto_Filter::SelectorProto_Filter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.SelectorProto.Filter)
}
SelectorProto_Filter::SelectorProto_Filter(const SelectorProto_Filter& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  clear_has_filter();
  switch (from.filter_case()) {
    case kEnterFrame: {
      _internal_mutable_enter_frame()->::autofill_assistant::SelectorProto_EmptyFilter::MergeFrom(from._internal_enter_frame());
      break;
    }
    case kCssSelector: {
      _internal_set_css_selector(from._internal_css_selector());
      break;
    }
    case kInnerText: {
      _internal_mutable_inner_text()->::autofill_assistant::TextFilter::MergeFrom(from._internal_inner_text());
      break;
    }
    case kValue: {
      _internal_mutable_value()->::autofill_assistant::TextFilter::MergeFrom(from._internal_value());
      break;
    }
    case kPseudoType: {
      _internal_set_pseudo_type(from._internal_pseudo_type());
      break;
    }
    case kBoundingBox: {
      _internal_mutable_bounding_box()->::autofill_assistant::SelectorProto_BoundingBoxFilter::MergeFrom(from._internal_bounding_box());
      break;
    }
    case kNthMatch: {
      _internal_mutable_nth_match()->::autofill_assistant::SelectorProto_NthMatchFilter::MergeFrom(from._internal_nth_match());
      break;
    }
    case kPseudoElementContent: {
      _internal_mutable_pseudo_element_content()->::autofill_assistant::SelectorProto_PseudoElementContent::MergeFrom(from._internal_pseudo_element_content());
      break;
    }
    case kLabelled: {
      _internal_mutable_labelled()->::autofill_assistant::SelectorProto_EmptyFilter::MergeFrom(from._internal_labelled());
      break;
    }
    case kMatchCssSelector: {
      _internal_set_match_css_selector(from._internal_match_css_selector());
      break;
    }
    case kCssStyle: {
      _internal_mutable_css_style()->::autofill_assistant::SelectorProto_CssStyleFilter::MergeFrom(from._internal_css_style());
      break;
    }
    case kOnTop: {
      _internal_mutable_on_top()->::autofill_assistant::SelectorProto_OnTopFilter::MergeFrom(from._internal_on_top());
      break;
    }
    case kProperty: {
      _internal_mutable_property()->::autofill_assistant::SelectorProto_PropertyFilter::MergeFrom(from._internal_property());
      break;
    }
    case kParent: {
      _internal_mutable_parent()->::autofill_assistant::SelectorProto_EmptyFilter::MergeFrom(from._internal_parent());
      break;
    }
    case kSemantic: {
      _internal_mutable_semantic()->::autofill_assistant::SelectorProto_SemanticFilter::MergeFrom(from._internal_semantic());
      break;
    }
    case FILTER_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.SelectorProto.Filter)
}

inline void SelectorProto_Filter::SharedCtor() {
clear_has_filter();
}

SelectorProto_Filter::~SelectorProto_Filter() {
  // @@protoc_insertion_point(destructor:autofill_assistant.SelectorProto.Filter)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SelectorProto_Filter::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_filter()) {
    clear_filter();
  }
}

void SelectorProto_Filter::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SelectorProto_Filter::clear_filter() {
// @@protoc_insertion_point(one_of_clear_start:autofill_assistant.SelectorProto.Filter)
  switch (filter_case()) {
    case kEnterFrame: {
      if (GetArenaForAllocation() == nullptr) {
        delete filter_.enter_frame_;
      }
      break;
    }
    case kCssSelector: {
      filter_.css_selector_.Destroy();
      break;
    }
    case kInnerText: {
      if (GetArenaForAllocation() == nullptr) {
        delete filter_.inner_text_;
      }
      break;
    }
    case kValue: {
      if (GetArenaForAllocation() == nullptr) {
        delete filter_.value_;
      }
      break;
    }
    case kPseudoType: {
      // No need to clear
      break;
    }
    case kBoundingBox: {
      if (GetArenaForAllocation() == nullptr) {
        delete filter_.bounding_box_;
      }
      break;
    }
    case kNthMatch: {
      if (GetArenaForAllocation() == nullptr) {
        delete filter_.nth_match_;
      }
      break;
    }
    case kPseudoElementContent: {
      if (GetArenaForAllocation() == nullptr) {
        delete filter_.pseudo_element_content_;
      }
      break;
    }
    case kLabelled: {
      if (GetArenaForAllocation() == nullptr) {
        delete filter_.labelled_;
      }
      break;
    }
    case kMatchCssSelector: {
      filter_.match_css_selector_.Destroy();
      break;
    }
    case kCssStyle: {
      if (GetArenaForAllocation() == nullptr) {
        delete filter_.css_style_;
      }
      break;
    }
    case kOnTop: {
      if (GetArenaForAllocation() == nullptr) {
        delete filter_.on_top_;
      }
      break;
    }
    case kProperty: {
      if (GetArenaForAllocation() == nullptr) {
        delete filter_.property_;
      }
      break;
    }
    case kParent: {
      if (GetArenaForAllocation() == nullptr) {
        delete filter_.parent_;
      }
      break;
    }
    case kSemantic: {
      if (GetArenaForAllocation() == nullptr) {
        delete filter_.semantic_;
      }
      break;
    }
    case FILTER_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = FILTER_NOT_SET;
}


void SelectorProto_Filter::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.SelectorProto.Filter)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_filter();
  _internal_metadata_.Clear<std::string>();
}

const char* SelectorProto_Filter::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .autofill_assistant.SelectorProto.EmptyFilter enter_frame = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_enter_frame(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string css_selector = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_css_selector();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.TextFilter inner_text = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_inner_text(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.TextFilter value = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_value(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.PseudoType pseudo_type = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::autofill_assistant::PseudoType_IsValid(val))) {
            _internal_set_pseudo_type(static_cast<::autofill_assistant::PseudoType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(5, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.SelectorProto.BoundingBoxFilter bounding_box = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_bounding_box(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.SelectorProto.NthMatchFilter nth_match = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_nth_match(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.SelectorProto.PseudoElementContent pseudo_element_content = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_pseudo_element_content(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.SelectorProto.EmptyFilter labelled = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_labelled(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string match_css_selector = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          auto str = _internal_mutable_match_css_selector();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.SelectorProto.CssStyleFilter css_style = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          ptr = ctx->ParseMessage(_internal_mutable_css_style(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.SelectorProto.OnTopFilter on_top = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          ptr = ctx->ParseMessage(_internal_mutable_on_top(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.SelectorProto.PropertyFilter property = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 114)) {
          ptr = ctx->ParseMessage(_internal_mutable_property(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.SelectorProto.EmptyFilter parent = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 122)) {
          ptr = ctx->ParseMessage(_internal_mutable_parent(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.SelectorProto.SemanticFilter semantic = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 130)) {
          ptr = ctx->ParseMessage(_internal_mutable_semantic(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SelectorProto_Filter::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.SelectorProto.Filter)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (filter_case()) {
    case kEnterFrame: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, _Internal::enter_frame(this),
          _Internal::enter_frame(this).GetCachedSize(), target, stream);
      break;
    }
    case kCssSelector: {
      target = stream->WriteStringMaybeAliased(
          2, this->_internal_css_selector(), target);
      break;
    }
    case kInnerText: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, _Internal::inner_text(this),
          _Internal::inner_text(this).GetCachedSize(), target, stream);
      break;
    }
    case kValue: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, _Internal::value(this),
          _Internal::value(this).GetCachedSize(), target, stream);
      break;
    }
    case kPseudoType: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteEnumToArray(
        5, this->_internal_pseudo_type(), target);
      break;
    }
    case kBoundingBox: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(6, _Internal::bounding_box(this),
          _Internal::bounding_box(this).GetCachedSize(), target, stream);
      break;
    }
    case kNthMatch: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(7, _Internal::nth_match(this),
          _Internal::nth_match(this).GetCachedSize(), target, stream);
      break;
    }
    case kPseudoElementContent: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(8, _Internal::pseudo_element_content(this),
          _Internal::pseudo_element_content(this).GetCachedSize(), target, stream);
      break;
    }
    case kLabelled: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(9, _Internal::labelled(this),
          _Internal::labelled(this).GetCachedSize(), target, stream);
      break;
    }
    case kMatchCssSelector: {
      target = stream->WriteStringMaybeAliased(
          11, this->_internal_match_css_selector(), target);
      break;
    }
    case kCssStyle: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(12, _Internal::css_style(this),
          _Internal::css_style(this).GetCachedSize(), target, stream);
      break;
    }
    case kOnTop: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(13, _Internal::on_top(this),
          _Internal::on_top(this).GetCachedSize(), target, stream);
      break;
    }
    case kProperty: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(14, _Internal::property(this),
          _Internal::property(this).GetCachedSize(), target, stream);
      break;
    }
    case kParent: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(15, _Internal::parent(this),
          _Internal::parent(this).GetCachedSize(), target, stream);
      break;
    }
    case kSemantic: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(16, _Internal::semantic(this),
          _Internal::semantic(this).GetCachedSize(), target, stream);
      break;
    }
    default: ;
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.SelectorProto.Filter)
  return target;
}

size_t SelectorProto_Filter::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.SelectorProto.Filter)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (filter_case()) {
    // .autofill_assistant.SelectorProto.EmptyFilter enter_frame = 1;
    case kEnterFrame: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *filter_.enter_frame_);
      break;
    }
    // string css_selector = 2;
    case kCssSelector: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_css_selector());
      break;
    }
    // .autofill_assistant.TextFilter inner_text = 3;
    case kInnerText: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *filter_.inner_text_);
      break;
    }
    // .autofill_assistant.TextFilter value = 4;
    case kValue: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *filter_.value_);
      break;
    }
    // .autofill_assistant.PseudoType pseudo_type = 5;
    case kPseudoType: {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_pseudo_type());
      break;
    }
    // .autofill_assistant.SelectorProto.BoundingBoxFilter bounding_box = 6;
    case kBoundingBox: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *filter_.bounding_box_);
      break;
    }
    // .autofill_assistant.SelectorProto.NthMatchFilter nth_match = 7;
    case kNthMatch: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *filter_.nth_match_);
      break;
    }
    // .autofill_assistant.SelectorProto.PseudoElementContent pseudo_element_content = 8;
    case kPseudoElementContent: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *filter_.pseudo_element_content_);
      break;
    }
    // .autofill_assistant.SelectorProto.EmptyFilter labelled = 9;
    case kLabelled: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *filter_.labelled_);
      break;
    }
    // string match_css_selector = 11;
    case kMatchCssSelector: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_match_css_selector());
      break;
    }
    // .autofill_assistant.SelectorProto.CssStyleFilter css_style = 12;
    case kCssStyle: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *filter_.css_style_);
      break;
    }
    // .autofill_assistant.SelectorProto.OnTopFilter on_top = 13;
    case kOnTop: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *filter_.on_top_);
      break;
    }
    // .autofill_assistant.SelectorProto.PropertyFilter property = 14;
    case kProperty: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *filter_.property_);
      break;
    }
    // .autofill_assistant.SelectorProto.EmptyFilter parent = 15;
    case kParent: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *filter_.parent_);
      break;
    }
    // .autofill_assistant.SelectorProto.SemanticFilter semantic = 16;
    case kSemantic: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *filter_.semantic_);
      break;
    }
    case FILTER_NOT_SET: {
      break;
    }
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SelectorProto_Filter::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const SelectorProto_Filter*>(
      &from));
}

void SelectorProto_Filter::MergeFrom(const SelectorProto_Filter& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.SelectorProto.Filter)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.filter_case()) {
    case kEnterFrame: {
      _internal_mutable_enter_frame()->::autofill_assistant::SelectorProto_EmptyFilter::MergeFrom(from._internal_enter_frame());
      break;
    }
    case kCssSelector: {
      _internal_set_css_selector(from._internal_css_selector());
      break;
    }
    case kInnerText: {
      _internal_mutable_inner_text()->::autofill_assistant::TextFilter::MergeFrom(from._internal_inner_text());
      break;
    }
    case kValue: {
      _internal_mutable_value()->::autofill_assistant::TextFilter::MergeFrom(from._internal_value());
      break;
    }
    case kPseudoType: {
      _internal_set_pseudo_type(from._internal_pseudo_type());
      break;
    }
    case kBoundingBox: {
      _internal_mutable_bounding_box()->::autofill_assistant::SelectorProto_BoundingBoxFilter::MergeFrom(from._internal_bounding_box());
      break;
    }
    case kNthMatch: {
      _internal_mutable_nth_match()->::autofill_assistant::SelectorProto_NthMatchFilter::MergeFrom(from._internal_nth_match());
      break;
    }
    case kPseudoElementContent: {
      _internal_mutable_pseudo_element_content()->::autofill_assistant::SelectorProto_PseudoElementContent::MergeFrom(from._internal_pseudo_element_content());
      break;
    }
    case kLabelled: {
      _internal_mutable_labelled()->::autofill_assistant::SelectorProto_EmptyFilter::MergeFrom(from._internal_labelled());
      break;
    }
    case kMatchCssSelector: {
      _internal_set_match_css_selector(from._internal_match_css_selector());
      break;
    }
    case kCssStyle: {
      _internal_mutable_css_style()->::autofill_assistant::SelectorProto_CssStyleFilter::MergeFrom(from._internal_css_style());
      break;
    }
    case kOnTop: {
      _internal_mutable_on_top()->::autofill_assistant::SelectorProto_OnTopFilter::MergeFrom(from._internal_on_top());
      break;
    }
    case kProperty: {
      _internal_mutable_property()->::autofill_assistant::SelectorProto_PropertyFilter::MergeFrom(from._internal_property());
      break;
    }
    case kParent: {
      _internal_mutable_parent()->::autofill_assistant::SelectorProto_EmptyFilter::MergeFrom(from._internal_parent());
      break;
    }
    case kSemantic: {
      _internal_mutable_semantic()->::autofill_assistant::SelectorProto_SemanticFilter::MergeFrom(from._internal_semantic());
      break;
    }
    case FILTER_NOT_SET: {
      break;
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SelectorProto_Filter::CopyFrom(const SelectorProto_Filter& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.SelectorProto.Filter)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SelectorProto_Filter::IsInitialized() const {
  return true;
}

void SelectorProto_Filter::InternalSwap(SelectorProto_Filter* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(filter_, other->filter_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

std::string SelectorProto_Filter::GetTypeName() const {
  return "autofill_assistant.SelectorProto.Filter";
}


// ===================================================================

class SelectorProto_PropertyFilter::_Internal {
 public:
  using HasBits = decltype(std::declval<SelectorProto_PropertyFilter>()._has_bits_);
  static void set_has_property(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::autofill_assistant::TextFilter& text_filter(const SelectorProto_PropertyFilter* msg);
  static const ::autofill_assistant::AutofillValueRegexp& autofill_value_regexp(const SelectorProto_PropertyFilter* msg);
};

const ::autofill_assistant::TextFilter&
SelectorProto_PropertyFilter::_Internal::text_filter(const SelectorProto_PropertyFilter* msg) {
  return *msg->value_.text_filter_;
}
const ::autofill_assistant::AutofillValueRegexp&
SelectorProto_PropertyFilter::_Internal::autofill_value_regexp(const SelectorProto_PropertyFilter* msg) {
  return *msg->value_.autofill_value_regexp_;
}
void SelectorProto_PropertyFilter::set_allocated_text_filter(::autofill_assistant::TextFilter* text_filter) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_value();
  if (text_filter) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(text_filter));
    if (message_arena != submessage_arena) {
      text_filter = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, text_filter, submessage_arena);
    }
    set_has_text_filter();
    value_.text_filter_ = text_filter;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.SelectorProto.PropertyFilter.text_filter)
}
void SelectorProto_PropertyFilter::clear_text_filter() {
  if (_internal_has_text_filter()) {
    if (GetArenaForAllocation() == nullptr) {
      delete value_.text_filter_;
    }
    clear_has_value();
  }
}
void SelectorProto_PropertyFilter::set_allocated_autofill_value_regexp(::autofill_assistant::AutofillValueRegexp* autofill_value_regexp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_value();
  if (autofill_value_regexp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(autofill_value_regexp));
    if (message_arena != submessage_arena) {
      autofill_value_regexp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, autofill_value_regexp, submessage_arena);
    }
    set_has_autofill_value_regexp();
    value_.autofill_value_regexp_ = autofill_value_regexp;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.SelectorProto.PropertyFilter.autofill_value_regexp)
}
void SelectorProto_PropertyFilter::clear_autofill_value_regexp() {
  if (_internal_has_autofill_value_regexp()) {
    if (GetArenaForAllocation() == nullptr) {
      delete value_.autofill_value_regexp_;
    }
    clear_has_value();
  }
}
SelectorProto_PropertyFilter::SelectorProto_PropertyFilter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.SelectorProto.PropertyFilter)
}
SelectorProto_PropertyFilter::SelectorProto_PropertyFilter(const SelectorProto_PropertyFilter& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  property_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    property_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_property()) {
    property_.Set(from._internal_property(), 
      GetArenaForAllocation());
  }
  clear_has_value();
  switch (from.value_case()) {
    case kTextFilter: {
      _internal_mutable_text_filter()->::autofill_assistant::TextFilter::MergeFrom(from._internal_text_filter());
      break;
    }
    case kAutofillValueRegexp: {
      _internal_mutable_autofill_value_regexp()->::autofill_assistant::AutofillValueRegexp::MergeFrom(from._internal_autofill_value_regexp());
      break;
    }
    case VALUE_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.SelectorProto.PropertyFilter)
}

inline void SelectorProto_PropertyFilter::SharedCtor() {
property_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  property_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
clear_has_value();
}

SelectorProto_PropertyFilter::~SelectorProto_PropertyFilter() {
  // @@protoc_insertion_point(destructor:autofill_assistant.SelectorProto.PropertyFilter)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SelectorProto_PropertyFilter::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  property_.Destroy();
  if (has_value()) {
    clear_value();
  }
}

void SelectorProto_PropertyFilter::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SelectorProto_PropertyFilter::clear_value() {
// @@protoc_insertion_point(one_of_clear_start:autofill_assistant.SelectorProto.PropertyFilter)
  switch (value_case()) {
    case kTextFilter: {
      if (GetArenaForAllocation() == nullptr) {
        delete value_.text_filter_;
      }
      break;
    }
    case kAutofillValueRegexp: {
      if (GetArenaForAllocation() == nullptr) {
        delete value_.autofill_value_regexp_;
      }
      break;
    }
    case VALUE_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = VALUE_NOT_SET;
}


void SelectorProto_PropertyFilter::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.SelectorProto.PropertyFilter)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    property_.ClearNonDefaultToEmpty();
  }
  clear_value();
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* SelectorProto_PropertyFilter::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string property = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_property();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.TextFilter text_filter = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_text_filter(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.AutofillValueRegexp autofill_value_regexp = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_autofill_value_regexp(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SelectorProto_PropertyFilter::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.SelectorProto.PropertyFilter)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string property = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_property(), target);
  }

  switch (value_case()) {
    case kTextFilter: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, _Internal::text_filter(this),
          _Internal::text_filter(this).GetCachedSize(), target, stream);
      break;
    }
    case kAutofillValueRegexp: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, _Internal::autofill_value_regexp(this),
          _Internal::autofill_value_regexp(this).GetCachedSize(), target, stream);
      break;
    }
    default: ;
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.SelectorProto.PropertyFilter)
  return target;
}

size_t SelectorProto_PropertyFilter::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.SelectorProto.PropertyFilter)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string property = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_property());
  }

  switch (value_case()) {
    // .autofill_assistant.TextFilter text_filter = 2;
    case kTextFilter: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *value_.text_filter_);
      break;
    }
    // .autofill_assistant.AutofillValueRegexp autofill_value_regexp = 3;
    case kAutofillValueRegexp: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *value_.autofill_value_regexp_);
      break;
    }
    case VALUE_NOT_SET: {
      break;
    }
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SelectorProto_PropertyFilter::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const SelectorProto_PropertyFilter*>(
      &from));
}

void SelectorProto_PropertyFilter::MergeFrom(const SelectorProto_PropertyFilter& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.SelectorProto.PropertyFilter)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_property()) {
    _internal_set_property(from._internal_property());
  }
  switch (from.value_case()) {
    case kTextFilter: {
      _internal_mutable_text_filter()->::autofill_assistant::TextFilter::MergeFrom(from._internal_text_filter());
      break;
    }
    case kAutofillValueRegexp: {
      _internal_mutable_autofill_value_regexp()->::autofill_assistant::AutofillValueRegexp::MergeFrom(from._internal_autofill_value_regexp());
      break;
    }
    case VALUE_NOT_SET: {
      break;
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SelectorProto_PropertyFilter::CopyFrom(const SelectorProto_PropertyFilter& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.SelectorProto.PropertyFilter)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SelectorProto_PropertyFilter::IsInitialized() const {
  return true;
}

void SelectorProto_PropertyFilter::InternalSwap(SelectorProto_PropertyFilter* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &property_, lhs_arena,
      &other->property_, rhs_arena
  );
  swap(value_, other->value_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

std::string SelectorProto_PropertyFilter::GetTypeName() const {
  return "autofill_assistant.SelectorProto.PropertyFilter";
}


// ===================================================================

class SelectorProto_PseudoElementContent::_Internal {
 public:
  using HasBits = decltype(std::declval<SelectorProto_PseudoElementContent>()._has_bits_);
  static void set_has_pseudo_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::autofill_assistant::TextFilter& content(const SelectorProto_PseudoElementContent* msg);
  static void set_has_content(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::autofill_assistant::TextFilter&
SelectorProto_PseudoElementContent::_Internal::content(const SelectorProto_PseudoElementContent* msg) {
  return *msg->content_;
}
void SelectorProto_PseudoElementContent::clear_content() {
  if (content_ != nullptr) content_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
SelectorProto_PseudoElementContent::SelectorProto_PseudoElementContent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.SelectorProto.PseudoElementContent)
}
SelectorProto_PseudoElementContent::SelectorProto_PseudoElementContent(const SelectorProto_PseudoElementContent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_content()) {
    content_ = new ::autofill_assistant::TextFilter(*from.content_);
  } else {
    content_ = nullptr;
  }
  pseudo_type_ = from.pseudo_type_;
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.SelectorProto.PseudoElementContent)
}

inline void SelectorProto_PseudoElementContent::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&content_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&pseudo_type_) -
    reinterpret_cast<char*>(&content_)) + sizeof(pseudo_type_));
}

SelectorProto_PseudoElementContent::~SelectorProto_PseudoElementContent() {
  // @@protoc_insertion_point(destructor:autofill_assistant.SelectorProto.PseudoElementContent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SelectorProto_PseudoElementContent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete content_;
}

void SelectorProto_PseudoElementContent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SelectorProto_PseudoElementContent::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.SelectorProto.PseudoElementContent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(content_ != nullptr);
    content_->Clear();
  }
  pseudo_type_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* SelectorProto_PseudoElementContent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .autofill_assistant.PseudoType pseudo_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::autofill_assistant::PseudoType_IsValid(val))) {
            _internal_set_pseudo_type(static_cast<::autofill_assistant::PseudoType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .autofill_assistant.TextFilter content = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_content(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SelectorProto_PseudoElementContent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.SelectorProto.PseudoElementContent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .autofill_assistant.PseudoType pseudo_type = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_pseudo_type(), target);
  }

  // optional .autofill_assistant.TextFilter content = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::content(this),
        _Internal::content(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.SelectorProto.PseudoElementContent)
  return target;
}

size_t SelectorProto_PseudoElementContent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.SelectorProto.PseudoElementContent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .autofill_assistant.TextFilter content = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *content_);
    }

    // optional .autofill_assistant.PseudoType pseudo_type = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_pseudo_type());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SelectorProto_PseudoElementContent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const SelectorProto_PseudoElementContent*>(
      &from));
}

void SelectorProto_PseudoElementContent::MergeFrom(const SelectorProto_PseudoElementContent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.SelectorProto.PseudoElementContent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_content()->::autofill_assistant::TextFilter::MergeFrom(from._internal_content());
    }
    if (cached_has_bits & 0x00000002u) {
      pseudo_type_ = from.pseudo_type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SelectorProto_PseudoElementContent::CopyFrom(const SelectorProto_PseudoElementContent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.SelectorProto.PseudoElementContent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SelectorProto_PseudoElementContent::IsInitialized() const {
  return true;
}

void SelectorProto_PseudoElementContent::InternalSwap(SelectorProto_PseudoElementContent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SelectorProto_PseudoElementContent, pseudo_type_)
      + sizeof(SelectorProto_PseudoElementContent::pseudo_type_)
      - PROTOBUF_FIELD_OFFSET(SelectorProto_PseudoElementContent, content_)>(
          reinterpret_cast<char*>(&content_),
          reinterpret_cast<char*>(&other->content_));
}

std::string SelectorProto_PseudoElementContent::GetTypeName() const {
  return "autofill_assistant.SelectorProto.PseudoElementContent";
}


// ===================================================================

class SelectorProto_CssStyleFilter::_Internal {
 public:
  using HasBits = decltype(std::declval<SelectorProto_CssStyleFilter>()._has_bits_);
  static void set_has_property(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_pseudo_element(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_should_match(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::autofill_assistant::TextFilter& value(const SelectorProto_CssStyleFilter* msg);
  static void set_has_value(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::autofill_assistant::TextFilter&
SelectorProto_CssStyleFilter::_Internal::value(const SelectorProto_CssStyleFilter* msg) {
  return *msg->value_;
}
void SelectorProto_CssStyleFilter::clear_value() {
  if (value_ != nullptr) value_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
SelectorProto_CssStyleFilter::SelectorProto_CssStyleFilter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.SelectorProto.CssStyleFilter)
}
SelectorProto_CssStyleFilter::SelectorProto_CssStyleFilter(const SelectorProto_CssStyleFilter& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  property_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    property_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_property()) {
    property_.Set(from._internal_property(), 
      GetArenaForAllocation());
  }
  pseudo_element_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    pseudo_element_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_pseudo_element()) {
    pseudo_element_.Set(from._internal_pseudo_element(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_value()) {
    value_ = new ::autofill_assistant::TextFilter(*from.value_);
  } else {
    value_ = nullptr;
  }
  should_match_ = from.should_match_;
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.SelectorProto.CssStyleFilter)
}

inline void SelectorProto_CssStyleFilter::SharedCtor() {
property_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  property_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
pseudo_element_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  pseudo_element_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
value_ = nullptr;
should_match_ = true;
}

SelectorProto_CssStyleFilter::~SelectorProto_CssStyleFilter() {
  // @@protoc_insertion_point(destructor:autofill_assistant.SelectorProto.CssStyleFilter)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SelectorProto_CssStyleFilter::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  property_.Destroy();
  pseudo_element_.Destroy();
  if (this != internal_default_instance()) delete value_;
}

void SelectorProto_CssStyleFilter::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SelectorProto_CssStyleFilter::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.SelectorProto.CssStyleFilter)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      property_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      pseudo_element_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(value_ != nullptr);
      value_->Clear();
    }
    should_match_ = true;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* SelectorProto_CssStyleFilter::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string property = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_property();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string pseudo_element = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_pseudo_element();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool should_match = 5 [default = true];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_should_match(&has_bits);
          should_match_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .autofill_assistant.TextFilter value = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_value(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SelectorProto_CssStyleFilter::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.SelectorProto.CssStyleFilter)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string property = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_property(), target);
  }

  // optional string pseudo_element = 4;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_pseudo_element(), target);
  }

  // optional bool should_match = 5 [default = true];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_should_match(), target);
  }

  // optional .autofill_assistant.TextFilter value = 6;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::value(this),
        _Internal::value(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.SelectorProto.CssStyleFilter)
  return target;
}

size_t SelectorProto_CssStyleFilter::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.SelectorProto.CssStyleFilter)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string property = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_property());
    }

    // optional string pseudo_element = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_pseudo_element());
    }

    // optional .autofill_assistant.TextFilter value = 6;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *value_);
    }

    // optional bool should_match = 5 [default = true];
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SelectorProto_CssStyleFilter::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const SelectorProto_CssStyleFilter*>(
      &from));
}

void SelectorProto_CssStyleFilter::MergeFrom(const SelectorProto_CssStyleFilter& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.SelectorProto.CssStyleFilter)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_property(from._internal_property());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_pseudo_element(from._internal_pseudo_element());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_value()->::autofill_assistant::TextFilter::MergeFrom(from._internal_value());
    }
    if (cached_has_bits & 0x00000008u) {
      should_match_ = from.should_match_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SelectorProto_CssStyleFilter::CopyFrom(const SelectorProto_CssStyleFilter& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.SelectorProto.CssStyleFilter)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SelectorProto_CssStyleFilter::IsInitialized() const {
  return true;
}

void SelectorProto_CssStyleFilter::InternalSwap(SelectorProto_CssStyleFilter* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &property_, lhs_arena,
      &other->property_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &pseudo_element_, lhs_arena,
      &other->pseudo_element_, rhs_arena
  );
  swap(value_, other->value_);
  swap(should_match_, other->should_match_);
}

std::string SelectorProto_CssStyleFilter::GetTypeName() const {
  return "autofill_assistant.SelectorProto.CssStyleFilter";
}


// ===================================================================

class SelectorProto_BoundingBoxFilter::_Internal {
 public:
  using HasBits = decltype(std::declval<SelectorProto_BoundingBoxFilter>()._has_bits_);
  static void set_has_require_nonempty(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

SelectorProto_BoundingBoxFilter::SelectorProto_BoundingBoxFilter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.SelectorProto.BoundingBoxFilter)
}
SelectorProto_BoundingBoxFilter::SelectorProto_BoundingBoxFilter(const SelectorProto_BoundingBoxFilter& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  require_nonempty_ = from.require_nonempty_;
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.SelectorProto.BoundingBoxFilter)
}

inline void SelectorProto_BoundingBoxFilter::SharedCtor() {
require_nonempty_ = false;
}

SelectorProto_BoundingBoxFilter::~SelectorProto_BoundingBoxFilter() {
  // @@protoc_insertion_point(destructor:autofill_assistant.SelectorProto.BoundingBoxFilter)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SelectorProto_BoundingBoxFilter::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void SelectorProto_BoundingBoxFilter::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SelectorProto_BoundingBoxFilter::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.SelectorProto.BoundingBoxFilter)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  require_nonempty_ = false;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* SelectorProto_BoundingBoxFilter::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool require_nonempty = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_require_nonempty(&has_bits);
          require_nonempty_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SelectorProto_BoundingBoxFilter::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.SelectorProto.BoundingBoxFilter)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bool require_nonempty = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_require_nonempty(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.SelectorProto.BoundingBoxFilter)
  return target;
}

size_t SelectorProto_BoundingBoxFilter::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.SelectorProto.BoundingBoxFilter)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bool require_nonempty = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 1;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SelectorProto_BoundingBoxFilter::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const SelectorProto_BoundingBoxFilter*>(
      &from));
}

void SelectorProto_BoundingBoxFilter::MergeFrom(const SelectorProto_BoundingBoxFilter& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.SelectorProto.BoundingBoxFilter)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_require_nonempty()) {
    _internal_set_require_nonempty(from._internal_require_nonempty());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SelectorProto_BoundingBoxFilter::CopyFrom(const SelectorProto_BoundingBoxFilter& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.SelectorProto.BoundingBoxFilter)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SelectorProto_BoundingBoxFilter::IsInitialized() const {
  return true;
}

void SelectorProto_BoundingBoxFilter::InternalSwap(SelectorProto_BoundingBoxFilter* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(require_nonempty_, other->require_nonempty_);
}

std::string SelectorProto_BoundingBoxFilter::GetTypeName() const {
  return "autofill_assistant.SelectorProto.BoundingBoxFilter";
}


// ===================================================================

class SelectorProto_OnTopFilter::_Internal {
 public:
  using HasBits = decltype(std::declval<SelectorProto_OnTopFilter>()._has_bits_);
  static void set_has_scroll_into_view_if_needed(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_accept_element_if_not_in_view(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

SelectorProto_OnTopFilter::SelectorProto_OnTopFilter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.SelectorProto.OnTopFilter)
}
SelectorProto_OnTopFilter::SelectorProto_OnTopFilter(const SelectorProto_OnTopFilter& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&accept_element_if_not_in_view_, &from.accept_element_if_not_in_view_,
    static_cast<size_t>(reinterpret_cast<char*>(&scroll_into_view_if_needed_) -
    reinterpret_cast<char*>(&accept_element_if_not_in_view_)) + sizeof(scroll_into_view_if_needed_));
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.SelectorProto.OnTopFilter)
}

inline void SelectorProto_OnTopFilter::SharedCtor() {
accept_element_if_not_in_view_ = false;
scroll_into_view_if_needed_ = true;
}

SelectorProto_OnTopFilter::~SelectorProto_OnTopFilter() {
  // @@protoc_insertion_point(destructor:autofill_assistant.SelectorProto.OnTopFilter)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SelectorProto_OnTopFilter::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void SelectorProto_OnTopFilter::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SelectorProto_OnTopFilter::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.SelectorProto.OnTopFilter)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    accept_element_if_not_in_view_ = false;
    scroll_into_view_if_needed_ = true;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* SelectorProto_OnTopFilter::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool scroll_into_view_if_needed = 1 [default = true];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_scroll_into_view_if_needed(&has_bits);
          scroll_into_view_if_needed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool accept_element_if_not_in_view = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_accept_element_if_not_in_view(&has_bits);
          accept_element_if_not_in_view_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SelectorProto_OnTopFilter::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.SelectorProto.OnTopFilter)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bool scroll_into_view_if_needed = 1 [default = true];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_scroll_into_view_if_needed(), target);
  }

  // optional bool accept_element_if_not_in_view = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_accept_element_if_not_in_view(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.SelectorProto.OnTopFilter)
  return target;
}

size_t SelectorProto_OnTopFilter::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.SelectorProto.OnTopFilter)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional bool accept_element_if_not_in_view = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 1;
    }

    // optional bool scroll_into_view_if_needed = 1 [default = true];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SelectorProto_OnTopFilter::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const SelectorProto_OnTopFilter*>(
      &from));
}

void SelectorProto_OnTopFilter::MergeFrom(const SelectorProto_OnTopFilter& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.SelectorProto.OnTopFilter)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      accept_element_if_not_in_view_ = from.accept_element_if_not_in_view_;
    }
    if (cached_has_bits & 0x00000002u) {
      scroll_into_view_if_needed_ = from.scroll_into_view_if_needed_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SelectorProto_OnTopFilter::CopyFrom(const SelectorProto_OnTopFilter& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.SelectorProto.OnTopFilter)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SelectorProto_OnTopFilter::IsInitialized() const {
  return true;
}

void SelectorProto_OnTopFilter::InternalSwap(SelectorProto_OnTopFilter* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(accept_element_if_not_in_view_, other->accept_element_if_not_in_view_);
  swap(scroll_into_view_if_needed_, other->scroll_into_view_if_needed_);
}

std::string SelectorProto_OnTopFilter::GetTypeName() const {
  return "autofill_assistant.SelectorProto.OnTopFilter";
}


// ===================================================================

class SelectorProto_EmptyFilter::_Internal {
 public:
};

SelectorProto_EmptyFilter::SelectorProto_EmptyFilter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.SelectorProto.EmptyFilter)
}
SelectorProto_EmptyFilter::SelectorProto_EmptyFilter(const SelectorProto_EmptyFilter& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.SelectorProto.EmptyFilter)
}

inline void SelectorProto_EmptyFilter::SharedCtor() {
}

SelectorProto_EmptyFilter::~SelectorProto_EmptyFilter() {
  // @@protoc_insertion_point(destructor:autofill_assistant.SelectorProto.EmptyFilter)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SelectorProto_EmptyFilter::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void SelectorProto_EmptyFilter::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SelectorProto_EmptyFilter::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.SelectorProto.EmptyFilter)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_metadata_.Clear<std::string>();
}

const char* SelectorProto_EmptyFilter::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SelectorProto_EmptyFilter::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.SelectorProto.EmptyFilter)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.SelectorProto.EmptyFilter)
  return target;
}

size_t SelectorProto_EmptyFilter::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.SelectorProto.EmptyFilter)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SelectorProto_EmptyFilter::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const SelectorProto_EmptyFilter*>(
      &from));
}

void SelectorProto_EmptyFilter::MergeFrom(const SelectorProto_EmptyFilter& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.SelectorProto.EmptyFilter)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SelectorProto_EmptyFilter::CopyFrom(const SelectorProto_EmptyFilter& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.SelectorProto.EmptyFilter)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SelectorProto_EmptyFilter::IsInitialized() const {
  return true;
}

void SelectorProto_EmptyFilter::InternalSwap(SelectorProto_EmptyFilter* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
}

std::string SelectorProto_EmptyFilter::GetTypeName() const {
  return "autofill_assistant.SelectorProto.EmptyFilter";
}


// ===================================================================

class SelectorProto_NthMatchFilter::_Internal {
 public:
  using HasBits = decltype(std::declval<SelectorProto_NthMatchFilter>()._has_bits_);
  static void set_has_index(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

SelectorProto_NthMatchFilter::SelectorProto_NthMatchFilter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.SelectorProto.NthMatchFilter)
}
SelectorProto_NthMatchFilter::SelectorProto_NthMatchFilter(const SelectorProto_NthMatchFilter& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  index_ = from.index_;
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.SelectorProto.NthMatchFilter)
}

inline void SelectorProto_NthMatchFilter::SharedCtor() {
index_ = 0;
}

SelectorProto_NthMatchFilter::~SelectorProto_NthMatchFilter() {
  // @@protoc_insertion_point(destructor:autofill_assistant.SelectorProto.NthMatchFilter)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SelectorProto_NthMatchFilter::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void SelectorProto_NthMatchFilter::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SelectorProto_NthMatchFilter::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.SelectorProto.NthMatchFilter)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  index_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* SelectorProto_NthMatchFilter::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 index = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_index(&has_bits);
          index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SelectorProto_NthMatchFilter::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.SelectorProto.NthMatchFilter)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 index = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_index(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.SelectorProto.NthMatchFilter)
  return target;
}

size_t SelectorProto_NthMatchFilter::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.SelectorProto.NthMatchFilter)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional int32 index = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_index());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SelectorProto_NthMatchFilter::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const SelectorProto_NthMatchFilter*>(
      &from));
}

void SelectorProto_NthMatchFilter::MergeFrom(const SelectorProto_NthMatchFilter& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.SelectorProto.NthMatchFilter)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_index()) {
    _internal_set_index(from._internal_index());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SelectorProto_NthMatchFilter::CopyFrom(const SelectorProto_NthMatchFilter& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.SelectorProto.NthMatchFilter)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SelectorProto_NthMatchFilter::IsInitialized() const {
  return true;
}

void SelectorProto_NthMatchFilter::InternalSwap(SelectorProto_NthMatchFilter* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(index_, other->index_);
}

std::string SelectorProto_NthMatchFilter::GetTypeName() const {
  return "autofill_assistant.SelectorProto.NthMatchFilter";
}


// ===================================================================

class SelectorProto_SemanticFilter::_Internal {
 public:
  using HasBits = decltype(std::declval<SelectorProto_SemanticFilter>()._has_bits_);
  static void set_has_objective(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_role(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_model_timeout_ms(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_ignore_objective(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

SelectorProto_SemanticFilter::SelectorProto_SemanticFilter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.SelectorProto.SemanticFilter)
}
SelectorProto_SemanticFilter::SelectorProto_SemanticFilter(const SelectorProto_SemanticFilter& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&objective_, &from.objective_,
    static_cast<size_t>(reinterpret_cast<char*>(&model_timeout_ms_) -
    reinterpret_cast<char*>(&objective_)) + sizeof(model_timeout_ms_));
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.SelectorProto.SemanticFilter)
}

inline void SelectorProto_SemanticFilter::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&objective_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&ignore_objective_) -
    reinterpret_cast<char*>(&objective_)) + sizeof(ignore_objective_));
model_timeout_ms_ = 5000;
}

SelectorProto_SemanticFilter::~SelectorProto_SemanticFilter() {
  // @@protoc_insertion_point(destructor:autofill_assistant.SelectorProto.SemanticFilter)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SelectorProto_SemanticFilter::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void SelectorProto_SemanticFilter::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SelectorProto_SemanticFilter::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.SelectorProto.SemanticFilter)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&objective_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&ignore_objective_) -
        reinterpret_cast<char*>(&objective_)) + sizeof(ignore_objective_));
    model_timeout_ms_ = 5000;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* SelectorProto_SemanticFilter::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 objective = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_objective(&has_bits);
          objective_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 role = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_role(&has_bits);
          role_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 model_timeout_ms = 3 [default = 5000];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_model_timeout_ms(&has_bits);
          model_timeout_ms_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool ignore_objective = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_ignore_objective(&has_bits);
          ignore_objective_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SelectorProto_SemanticFilter::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.SelectorProto.SemanticFilter)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 objective = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_objective(), target);
  }

  // optional int32 role = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_role(), target);
  }

  // optional int32 model_timeout_ms = 3 [default = 5000];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_model_timeout_ms(), target);
  }

  // optional bool ignore_objective = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_ignore_objective(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.SelectorProto.SemanticFilter)
  return target;
}

size_t SelectorProto_SemanticFilter::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.SelectorProto.SemanticFilter)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional int32 objective = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_objective());
    }

    // optional int32 role = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_role());
    }

    // optional bool ignore_objective = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

    // optional int32 model_timeout_ms = 3 [default = 5000];
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_model_timeout_ms());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SelectorProto_SemanticFilter::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const SelectorProto_SemanticFilter*>(
      &from));
}

void SelectorProto_SemanticFilter::MergeFrom(const SelectorProto_SemanticFilter& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.SelectorProto.SemanticFilter)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      objective_ = from.objective_;
    }
    if (cached_has_bits & 0x00000002u) {
      role_ = from.role_;
    }
    if (cached_has_bits & 0x00000004u) {
      ignore_objective_ = from.ignore_objective_;
    }
    if (cached_has_bits & 0x00000008u) {
      model_timeout_ms_ = from.model_timeout_ms_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SelectorProto_SemanticFilter::CopyFrom(const SelectorProto_SemanticFilter& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.SelectorProto.SemanticFilter)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SelectorProto_SemanticFilter::IsInitialized() const {
  return true;
}

void SelectorProto_SemanticFilter::InternalSwap(SelectorProto_SemanticFilter* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SelectorProto_SemanticFilter, ignore_objective_)
      + sizeof(SelectorProto_SemanticFilter::ignore_objective_)
      - PROTOBUF_FIELD_OFFSET(SelectorProto_SemanticFilter, objective_)>(
          reinterpret_cast<char*>(&objective_),
          reinterpret_cast<char*>(&other->objective_));
  swap(model_timeout_ms_, other->model_timeout_ms_);
}

std::string SelectorProto_SemanticFilter::GetTypeName() const {
  return "autofill_assistant.SelectorProto.SemanticFilter";
}


// ===================================================================

class SelectorProto::_Internal {
 public:
  using HasBits = decltype(std::declval<SelectorProto>()._has_bits_);
  static void set_has_tracking_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

SelectorProto::SelectorProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  filters_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.SelectorProto)
}
SelectorProto::SelectorProto(const SelectorProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      filters_(from.filters_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  tracking_id_ = from.tracking_id_;
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.SelectorProto)
}

inline void SelectorProto::SharedCtor() {
tracking_id_ = int64_t{0};
}

SelectorProto::~SelectorProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.SelectorProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SelectorProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void SelectorProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SelectorProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.SelectorProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  filters_.Clear();
  tracking_id_ = int64_t{0};
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* SelectorProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .autofill_assistant.SelectorProto.Filter filters = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_filters(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<74>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional int64 tracking_id = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_tracking_id(&has_bits);
          tracking_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SelectorProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.SelectorProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .autofill_assistant.SelectorProto.Filter filters = 9;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_filters_size()); i < n; i++) {
    const auto& repfield = this->_internal_filters(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(9, repfield, repfield.GetCachedSize(), target, stream);
  }

  cached_has_bits = _has_bits_[0];
  // optional int64 tracking_id = 10;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(10, this->_internal_tracking_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.SelectorProto)
  return target;
}

size_t SelectorProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.SelectorProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .autofill_assistant.SelectorProto.Filter filters = 9;
  total_size += 1UL * this->_internal_filters_size();
  for (const auto& msg : this->filters_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional int64 tracking_id = 10;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_tracking_id());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SelectorProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const SelectorProto*>(
      &from));
}

void SelectorProto::MergeFrom(const SelectorProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.SelectorProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  filters_.MergeFrom(from.filters_);
  if (from._internal_has_tracking_id()) {
    _internal_set_tracking_id(from._internal_tracking_id());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SelectorProto::CopyFrom(const SelectorProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.SelectorProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SelectorProto::IsInitialized() const {
  return true;
}

void SelectorProto::InternalSwap(SelectorProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  filters_.InternalSwap(&other->filters_);
  swap(tracking_id_, other->tracking_id_);
}

std::string SelectorProto::GetTypeName() const {
  return "autofill_assistant.SelectorProto";
}


// ===================================================================

class SelectOptionProto::_Internal {
 public:
  using HasBits = decltype(std::declval<SelectOptionProto>()._has_bits_);
  static const ::autofill_assistant::SelectorProto& element(const SelectOptionProto* msg);
  static void set_has_element(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::autofill_assistant::TextFilter& text_filter_value(const SelectOptionProto* msg);
  static const ::autofill_assistant::AutofillValueRegexp& autofill_regexp_value(const SelectOptionProto* msg);
  static void set_has_option_comparison_attribute(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_strict(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::autofill_assistant::SelectorProto&
SelectOptionProto::_Internal::element(const SelectOptionProto* msg) {
  return *msg->element_;
}
const ::autofill_assistant::TextFilter&
SelectOptionProto::_Internal::text_filter_value(const SelectOptionProto* msg) {
  return *msg->value_.text_filter_value_;
}
const ::autofill_assistant::AutofillValueRegexp&
SelectOptionProto::_Internal::autofill_regexp_value(const SelectOptionProto* msg) {
  return *msg->value_.autofill_regexp_value_;
}
void SelectOptionProto::set_allocated_text_filter_value(::autofill_assistant::TextFilter* text_filter_value) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_value();
  if (text_filter_value) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(text_filter_value));
    if (message_arena != submessage_arena) {
      text_filter_value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, text_filter_value, submessage_arena);
    }
    set_has_text_filter_value();
    value_.text_filter_value_ = text_filter_value;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.SelectOptionProto.text_filter_value)
}
void SelectOptionProto::clear_text_filter_value() {
  if (_internal_has_text_filter_value()) {
    if (GetArenaForAllocation() == nullptr) {
      delete value_.text_filter_value_;
    }
    clear_has_value();
  }
}
void SelectOptionProto::set_allocated_autofill_regexp_value(::autofill_assistant::AutofillValueRegexp* autofill_regexp_value) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_value();
  if (autofill_regexp_value) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(autofill_regexp_value));
    if (message_arena != submessage_arena) {
      autofill_regexp_value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, autofill_regexp_value, submessage_arena);
    }
    set_has_autofill_regexp_value();
    value_.autofill_regexp_value_ = autofill_regexp_value;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.SelectOptionProto.autofill_regexp_value)
}
void SelectOptionProto::clear_autofill_regexp_value() {
  if (_internal_has_autofill_regexp_value()) {
    if (GetArenaForAllocation() == nullptr) {
      delete value_.autofill_regexp_value_;
    }
    clear_has_value();
  }
}
SelectOptionProto::SelectOptionProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.SelectOptionProto)
}
SelectOptionProto::SelectOptionProto(const SelectOptionProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_element()) {
    element_ = new ::autofill_assistant::SelectorProto(*from.element_);
  } else {
    element_ = nullptr;
  }
  ::memcpy(&option_comparison_attribute_, &from.option_comparison_attribute_,
    static_cast<size_t>(reinterpret_cast<char*>(&strict_) -
    reinterpret_cast<char*>(&option_comparison_attribute_)) + sizeof(strict_));
  clear_has_value();
  switch (from.value_case()) {
    case kTextFilterValue: {
      _internal_mutable_text_filter_value()->::autofill_assistant::TextFilter::MergeFrom(from._internal_text_filter_value());
      break;
    }
    case kAutofillRegexpValue: {
      _internal_mutable_autofill_regexp_value()->::autofill_assistant::AutofillValueRegexp::MergeFrom(from._internal_autofill_regexp_value());
      break;
    }
    case VALUE_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.SelectOptionProto)
}

inline void SelectOptionProto::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&element_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&strict_) -
    reinterpret_cast<char*>(&element_)) + sizeof(strict_));
clear_has_value();
}

SelectOptionProto::~SelectOptionProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.SelectOptionProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SelectOptionProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete element_;
  if (has_value()) {
    clear_value();
  }
}

void SelectOptionProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SelectOptionProto::clear_value() {
// @@protoc_insertion_point(one_of_clear_start:autofill_assistant.SelectOptionProto)
  switch (value_case()) {
    case kTextFilterValue: {
      if (GetArenaForAllocation() == nullptr) {
        delete value_.text_filter_value_;
      }
      break;
    }
    case kAutofillRegexpValue: {
      if (GetArenaForAllocation() == nullptr) {
        delete value_.autofill_regexp_value_;
      }
      break;
    }
    case VALUE_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = VALUE_NOT_SET;
}


void SelectOptionProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.SelectOptionProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(element_ != nullptr);
    element_->Clear();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&option_comparison_attribute_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&strict_) -
        reinterpret_cast<char*>(&option_comparison_attribute_)) + sizeof(strict_));
  }
  clear_value();
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* SelectOptionProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .autofill_assistant.SelectorProto element = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_element(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .autofill_assistant.SelectOptionProto.OptionComparisonAttribute option_comparison_attribute = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::autofill_assistant::SelectOptionProto_OptionComparisonAttribute_IsValid(val))) {
            _internal_set_option_comparison_attribute(static_cast<::autofill_assistant::SelectOptionProto_OptionComparisonAttribute>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(6, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.TextFilter text_filter_value = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_text_filter_value(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.AutofillValueRegexp autofill_regexp_value = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_autofill_regexp_value(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool strict = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_strict(&has_bits);
          strict_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SelectOptionProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.SelectOptionProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .autofill_assistant.SelectorProto element = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::element(this),
        _Internal::element(this).GetCachedSize(), target, stream);
  }

  // optional .autofill_assistant.SelectOptionProto.OptionComparisonAttribute option_comparison_attribute = 6;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      6, this->_internal_option_comparison_attribute(), target);
  }

  switch (value_case()) {
    case kTextFilterValue: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(7, _Internal::text_filter_value(this),
          _Internal::text_filter_value(this).GetCachedSize(), target, stream);
      break;
    }
    case kAutofillRegexpValue: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(8, _Internal::autofill_regexp_value(this),
          _Internal::autofill_regexp_value(this).GetCachedSize(), target, stream);
      break;
    }
    default: ;
  }
  // optional bool strict = 9;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(9, this->_internal_strict(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.SelectOptionProto)
  return target;
}

size_t SelectOptionProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.SelectOptionProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .autofill_assistant.SelectorProto element = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *element_);
    }

    // optional .autofill_assistant.SelectOptionProto.OptionComparisonAttribute option_comparison_attribute = 6;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_option_comparison_attribute());
    }

    // optional bool strict = 9;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

  }
  switch (value_case()) {
    // .autofill_assistant.TextFilter text_filter_value = 7;
    case kTextFilterValue: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *value_.text_filter_value_);
      break;
    }
    // .autofill_assistant.AutofillValueRegexp autofill_regexp_value = 8;
    case kAutofillRegexpValue: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *value_.autofill_regexp_value_);
      break;
    }
    case VALUE_NOT_SET: {
      break;
    }
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SelectOptionProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const SelectOptionProto*>(
      &from));
}

void SelectOptionProto::MergeFrom(const SelectOptionProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.SelectOptionProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_element()->::autofill_assistant::SelectorProto::MergeFrom(from._internal_element());
    }
    if (cached_has_bits & 0x00000002u) {
      option_comparison_attribute_ = from.option_comparison_attribute_;
    }
    if (cached_has_bits & 0x00000004u) {
      strict_ = from.strict_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  switch (from.value_case()) {
    case kTextFilterValue: {
      _internal_mutable_text_filter_value()->::autofill_assistant::TextFilter::MergeFrom(from._internal_text_filter_value());
      break;
    }
    case kAutofillRegexpValue: {
      _internal_mutable_autofill_regexp_value()->::autofill_assistant::AutofillValueRegexp::MergeFrom(from._internal_autofill_regexp_value());
      break;
    }
    case VALUE_NOT_SET: {
      break;
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SelectOptionProto::CopyFrom(const SelectOptionProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.SelectOptionProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SelectOptionProto::IsInitialized() const {
  return true;
}

void SelectOptionProto::InternalSwap(SelectOptionProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SelectOptionProto, strict_)
      + sizeof(SelectOptionProto::strict_)
      - PROTOBUF_FIELD_OFFSET(SelectOptionProto, element_)>(
          reinterpret_cast<char*>(&element_),
          reinterpret_cast<char*>(&other->element_));
  swap(value_, other->value_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

std::string SelectOptionProto::GetTypeName() const {
  return "autofill_assistant.SelectOptionProto";
}


// ===================================================================

class UpdateClientSettingsProto::_Internal {
 public:
  using HasBits = decltype(std::declval<UpdateClientSettingsProto>()._has_bits_);
  static const ::autofill_assistant::ClientSettingsProto& client_settings(const UpdateClientSettingsProto* msg);
  static void set_has_client_settings(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::autofill_assistant::ClientSettingsProto&
UpdateClientSettingsProto::_Internal::client_settings(const UpdateClientSettingsProto* msg) {
  return *msg->client_settings_;
}
UpdateClientSettingsProto::UpdateClientSettingsProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.UpdateClientSettingsProto)
}
UpdateClientSettingsProto::UpdateClientSettingsProto(const UpdateClientSettingsProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_client_settings()) {
    client_settings_ = new ::autofill_assistant::ClientSettingsProto(*from.client_settings_);
  } else {
    client_settings_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.UpdateClientSettingsProto)
}

inline void UpdateClientSettingsProto::SharedCtor() {
client_settings_ = nullptr;
}

UpdateClientSettingsProto::~UpdateClientSettingsProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.UpdateClientSettingsProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void UpdateClientSettingsProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete client_settings_;
}

void UpdateClientSettingsProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void UpdateClientSettingsProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.UpdateClientSettingsProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(client_settings_ != nullptr);
    client_settings_->Clear();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* UpdateClientSettingsProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .autofill_assistant.ClientSettingsProto client_settings = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_client_settings(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UpdateClientSettingsProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.UpdateClientSettingsProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .autofill_assistant.ClientSettingsProto client_settings = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::client_settings(this),
        _Internal::client_settings(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.UpdateClientSettingsProto)
  return target;
}

size_t UpdateClientSettingsProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.UpdateClientSettingsProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .autofill_assistant.ClientSettingsProto client_settings = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *client_settings_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void UpdateClientSettingsProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const UpdateClientSettingsProto*>(
      &from));
}

void UpdateClientSettingsProto::MergeFrom(const UpdateClientSettingsProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.UpdateClientSettingsProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_client_settings()) {
    _internal_mutable_client_settings()->::autofill_assistant::ClientSettingsProto::MergeFrom(from._internal_client_settings());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void UpdateClientSettingsProto::CopyFrom(const UpdateClientSettingsProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.UpdateClientSettingsProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UpdateClientSettingsProto::IsInitialized() const {
  return true;
}

void UpdateClientSettingsProto::InternalSwap(UpdateClientSettingsProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(client_settings_, other->client_settings_);
}

std::string UpdateClientSettingsProto::GetTypeName() const {
  return "autofill_assistant.UpdateClientSettingsProto";
}


// ===================================================================

class PromptQrCodeScanProto_CameraScanUiStrings::_Internal {
 public:
  using HasBits = decltype(std::declval<PromptQrCodeScanProto_CameraScanUiStrings>()._has_bits_);
  static void set_has_title_text(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_permission_text(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_permission_button_text(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_open_settings_text(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_open_settings_button_text(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_camera_preview_instruction_text(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_camera_preview_security_text(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
};

PromptQrCodeScanProto_CameraScanUiStrings::PromptQrCodeScanProto_CameraScanUiStrings(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.PromptQrCodeScanProto.CameraScanUiStrings)
}
PromptQrCodeScanProto_CameraScanUiStrings::PromptQrCodeScanProto_CameraScanUiStrings(const PromptQrCodeScanProto_CameraScanUiStrings& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  title_text_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    title_text_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_title_text()) {
    title_text_.Set(from._internal_title_text(), 
      GetArenaForAllocation());
  }
  permission_text_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    permission_text_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_permission_text()) {
    permission_text_.Set(from._internal_permission_text(), 
      GetArenaForAllocation());
  }
  permission_button_text_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    permission_button_text_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_permission_button_text()) {
    permission_button_text_.Set(from._internal_permission_button_text(), 
      GetArenaForAllocation());
  }
  open_settings_text_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    open_settings_text_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_open_settings_text()) {
    open_settings_text_.Set(from._internal_open_settings_text(), 
      GetArenaForAllocation());
  }
  open_settings_button_text_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    open_settings_button_text_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_open_settings_button_text()) {
    open_settings_button_text_.Set(from._internal_open_settings_button_text(), 
      GetArenaForAllocation());
  }
  camera_preview_instruction_text_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    camera_preview_instruction_text_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_camera_preview_instruction_text()) {
    camera_preview_instruction_text_.Set(from._internal_camera_preview_instruction_text(), 
      GetArenaForAllocation());
  }
  camera_preview_security_text_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    camera_preview_security_text_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_camera_preview_security_text()) {
    camera_preview_security_text_.Set(from._internal_camera_preview_security_text(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.PromptQrCodeScanProto.CameraScanUiStrings)
}

inline void PromptQrCodeScanProto_CameraScanUiStrings::SharedCtor() {
title_text_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  title_text_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
permission_text_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  permission_text_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
permission_button_text_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  permission_button_text_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
open_settings_text_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  open_settings_text_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
open_settings_button_text_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  open_settings_button_text_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
camera_preview_instruction_text_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  camera_preview_instruction_text_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
camera_preview_security_text_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  camera_preview_security_text_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

PromptQrCodeScanProto_CameraScanUiStrings::~PromptQrCodeScanProto_CameraScanUiStrings() {
  // @@protoc_insertion_point(destructor:autofill_assistant.PromptQrCodeScanProto.CameraScanUiStrings)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PromptQrCodeScanProto_CameraScanUiStrings::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  title_text_.Destroy();
  permission_text_.Destroy();
  permission_button_text_.Destroy();
  open_settings_text_.Destroy();
  open_settings_button_text_.Destroy();
  camera_preview_instruction_text_.Destroy();
  camera_preview_security_text_.Destroy();
}

void PromptQrCodeScanProto_CameraScanUiStrings::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void PromptQrCodeScanProto_CameraScanUiStrings::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.PromptQrCodeScanProto.CameraScanUiStrings)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      title_text_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      permission_text_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      permission_button_text_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      open_settings_text_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      open_settings_button_text_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000020u) {
      camera_preview_instruction_text_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000040u) {
      camera_preview_security_text_.ClearNonDefaultToEmpty();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* PromptQrCodeScanProto_CameraScanUiStrings::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string title_text = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_title_text();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string permission_text = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_permission_text();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string permission_button_text = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_permission_button_text();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string open_settings_text = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_open_settings_text();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string open_settings_button_text = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_open_settings_button_text();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string camera_preview_instruction_text = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_camera_preview_instruction_text();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string camera_preview_security_text = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_camera_preview_security_text();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PromptQrCodeScanProto_CameraScanUiStrings::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.PromptQrCodeScanProto.CameraScanUiStrings)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string title_text = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_title_text(), target);
  }

  // optional string permission_text = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_permission_text(), target);
  }

  // optional string permission_button_text = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_permission_button_text(), target);
  }

  // optional string open_settings_text = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_open_settings_text(), target);
  }

  // optional string open_settings_button_text = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_open_settings_button_text(), target);
  }

  // optional string camera_preview_instruction_text = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_camera_preview_instruction_text(), target);
  }

  // optional string camera_preview_security_text = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->WriteStringMaybeAliased(
        7, this->_internal_camera_preview_security_text(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.PromptQrCodeScanProto.CameraScanUiStrings)
  return target;
}

size_t PromptQrCodeScanProto_CameraScanUiStrings::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.PromptQrCodeScanProto.CameraScanUiStrings)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // optional string title_text = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_title_text());
    }

    // optional string permission_text = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_permission_text());
    }

    // optional string permission_button_text = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_permission_button_text());
    }

    // optional string open_settings_text = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_open_settings_text());
    }

    // optional string open_settings_button_text = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_open_settings_button_text());
    }

    // optional string camera_preview_instruction_text = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_camera_preview_instruction_text());
    }

    // optional string camera_preview_security_text = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_camera_preview_security_text());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void PromptQrCodeScanProto_CameraScanUiStrings::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const PromptQrCodeScanProto_CameraScanUiStrings*>(
      &from));
}

void PromptQrCodeScanProto_CameraScanUiStrings::MergeFrom(const PromptQrCodeScanProto_CameraScanUiStrings& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.PromptQrCodeScanProto.CameraScanUiStrings)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_title_text(from._internal_title_text());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_permission_text(from._internal_permission_text());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_permission_button_text(from._internal_permission_button_text());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_set_open_settings_text(from._internal_open_settings_text());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_set_open_settings_button_text(from._internal_open_settings_button_text());
    }
    if (cached_has_bits & 0x00000020u) {
      _internal_set_camera_preview_instruction_text(from._internal_camera_preview_instruction_text());
    }
    if (cached_has_bits & 0x00000040u) {
      _internal_set_camera_preview_security_text(from._internal_camera_preview_security_text());
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void PromptQrCodeScanProto_CameraScanUiStrings::CopyFrom(const PromptQrCodeScanProto_CameraScanUiStrings& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.PromptQrCodeScanProto.CameraScanUiStrings)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PromptQrCodeScanProto_CameraScanUiStrings::IsInitialized() const {
  return true;
}

void PromptQrCodeScanProto_CameraScanUiStrings::InternalSwap(PromptQrCodeScanProto_CameraScanUiStrings* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &title_text_, lhs_arena,
      &other->title_text_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &permission_text_, lhs_arena,
      &other->permission_text_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &permission_button_text_, lhs_arena,
      &other->permission_button_text_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &open_settings_text_, lhs_arena,
      &other->open_settings_text_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &open_settings_button_text_, lhs_arena,
      &other->open_settings_button_text_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &camera_preview_instruction_text_, lhs_arena,
      &other->camera_preview_instruction_text_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &camera_preview_security_text_, lhs_arena,
      &other->camera_preview_security_text_, rhs_arena
  );
}

std::string PromptQrCodeScanProto_CameraScanUiStrings::GetTypeName() const {
  return "autofill_assistant.PromptQrCodeScanProto.CameraScanUiStrings";
}


// ===================================================================

class PromptQrCodeScanProto_ImagePickerUiStrings::_Internal {
 public:
  using HasBits = decltype(std::declval<PromptQrCodeScanProto_ImagePickerUiStrings>()._has_bits_);
  static void set_has_title_text(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_permission_text(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_permission_button_text(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_open_settings_text(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_open_settings_button_text(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

PromptQrCodeScanProto_ImagePickerUiStrings::PromptQrCodeScanProto_ImagePickerUiStrings(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.PromptQrCodeScanProto.ImagePickerUiStrings)
}
PromptQrCodeScanProto_ImagePickerUiStrings::PromptQrCodeScanProto_ImagePickerUiStrings(const PromptQrCodeScanProto_ImagePickerUiStrings& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  title_text_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    title_text_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_title_text()) {
    title_text_.Set(from._internal_title_text(), 
      GetArenaForAllocation());
  }
  permission_text_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    permission_text_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_permission_text()) {
    permission_text_.Set(from._internal_permission_text(), 
      GetArenaForAllocation());
  }
  permission_button_text_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    permission_button_text_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_permission_button_text()) {
    permission_button_text_.Set(from._internal_permission_button_text(), 
      GetArenaForAllocation());
  }
  open_settings_text_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    open_settings_text_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_open_settings_text()) {
    open_settings_text_.Set(from._internal_open_settings_text(), 
      GetArenaForAllocation());
  }
  open_settings_button_text_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    open_settings_button_text_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_open_settings_button_text()) {
    open_settings_button_text_.Set(from._internal_open_settings_button_text(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.PromptQrCodeScanProto.ImagePickerUiStrings)
}

inline void PromptQrCodeScanProto_ImagePickerUiStrings::SharedCtor() {
title_text_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  title_text_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
permission_text_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  permission_text_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
permission_button_text_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  permission_button_text_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
open_settings_text_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  open_settings_text_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
open_settings_button_text_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  open_settings_button_text_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

PromptQrCodeScanProto_ImagePickerUiStrings::~PromptQrCodeScanProto_ImagePickerUiStrings() {
  // @@protoc_insertion_point(destructor:autofill_assistant.PromptQrCodeScanProto.ImagePickerUiStrings)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PromptQrCodeScanProto_ImagePickerUiStrings::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  title_text_.Destroy();
  permission_text_.Destroy();
  permission_button_text_.Destroy();
  open_settings_text_.Destroy();
  open_settings_button_text_.Destroy();
}

void PromptQrCodeScanProto_ImagePickerUiStrings::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void PromptQrCodeScanProto_ImagePickerUiStrings::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.PromptQrCodeScanProto.ImagePickerUiStrings)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      title_text_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      permission_text_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      permission_button_text_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      open_settings_text_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      open_settings_button_text_.ClearNonDefaultToEmpty();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* PromptQrCodeScanProto_ImagePickerUiStrings::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string title_text = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_title_text();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string permission_text = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_permission_text();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string permission_button_text = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_permission_button_text();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string open_settings_text = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_open_settings_text();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string open_settings_button_text = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_open_settings_button_text();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PromptQrCodeScanProto_ImagePickerUiStrings::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.PromptQrCodeScanProto.ImagePickerUiStrings)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string title_text = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_title_text(), target);
  }

  // optional string permission_text = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_permission_text(), target);
  }

  // optional string permission_button_text = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_permission_button_text(), target);
  }

  // optional string open_settings_text = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_open_settings_text(), target);
  }

  // optional string open_settings_button_text = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_open_settings_button_text(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.PromptQrCodeScanProto.ImagePickerUiStrings)
  return target;
}

size_t PromptQrCodeScanProto_ImagePickerUiStrings::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.PromptQrCodeScanProto.ImagePickerUiStrings)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional string title_text = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_title_text());
    }

    // optional string permission_text = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_permission_text());
    }

    // optional string permission_button_text = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_permission_button_text());
    }

    // optional string open_settings_text = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_open_settings_text());
    }

    // optional string open_settings_button_text = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_open_settings_button_text());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void PromptQrCodeScanProto_ImagePickerUiStrings::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const PromptQrCodeScanProto_ImagePickerUiStrings*>(
      &from));
}

void PromptQrCodeScanProto_ImagePickerUiStrings::MergeFrom(const PromptQrCodeScanProto_ImagePickerUiStrings& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.PromptQrCodeScanProto.ImagePickerUiStrings)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_title_text(from._internal_title_text());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_permission_text(from._internal_permission_text());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_permission_button_text(from._internal_permission_button_text());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_set_open_settings_text(from._internal_open_settings_text());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_set_open_settings_button_text(from._internal_open_settings_button_text());
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void PromptQrCodeScanProto_ImagePickerUiStrings::CopyFrom(const PromptQrCodeScanProto_ImagePickerUiStrings& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.PromptQrCodeScanProto.ImagePickerUiStrings)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PromptQrCodeScanProto_ImagePickerUiStrings::IsInitialized() const {
  return true;
}

void PromptQrCodeScanProto_ImagePickerUiStrings::InternalSwap(PromptQrCodeScanProto_ImagePickerUiStrings* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &title_text_, lhs_arena,
      &other->title_text_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &permission_text_, lhs_arena,
      &other->permission_text_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &permission_button_text_, lhs_arena,
      &other->permission_button_text_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &open_settings_text_, lhs_arena,
      &other->open_settings_text_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &open_settings_button_text_, lhs_arena,
      &other->open_settings_button_text_, rhs_arena
  );
}

std::string PromptQrCodeScanProto_ImagePickerUiStrings::GetTypeName() const {
  return "autofill_assistant.PromptQrCodeScanProto.ImagePickerUiStrings";
}


// ===================================================================

class PromptQrCodeScanProto::_Internal {
 public:
  using HasBits = decltype(std::declval<PromptQrCodeScanProto>()._has_bits_);
  static void set_has_use_gallery(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_output_client_memory_key(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::autofill_assistant::PromptQrCodeScanProto_CameraScanUiStrings& camera_scan_ui_strings(const PromptQrCodeScanProto* msg);
  static void set_has_camera_scan_ui_strings(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::autofill_assistant::PromptQrCodeScanProto_ImagePickerUiStrings& image_picker_ui_strings(const PromptQrCodeScanProto* msg);
  static void set_has_image_picker_ui_strings(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::autofill_assistant::PromptQrCodeScanProto_CameraScanUiStrings&
PromptQrCodeScanProto::_Internal::camera_scan_ui_strings(const PromptQrCodeScanProto* msg) {
  return *msg->camera_scan_ui_strings_;
}
const ::autofill_assistant::PromptQrCodeScanProto_ImagePickerUiStrings&
PromptQrCodeScanProto::_Internal::image_picker_ui_strings(const PromptQrCodeScanProto* msg) {
  return *msg->image_picker_ui_strings_;
}
PromptQrCodeScanProto::PromptQrCodeScanProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.PromptQrCodeScanProto)
}
PromptQrCodeScanProto::PromptQrCodeScanProto(const PromptQrCodeScanProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  output_client_memory_key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    output_client_memory_key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_output_client_memory_key()) {
    output_client_memory_key_.Set(from._internal_output_client_memory_key(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_camera_scan_ui_strings()) {
    camera_scan_ui_strings_ = new ::autofill_assistant::PromptQrCodeScanProto_CameraScanUiStrings(*from.camera_scan_ui_strings_);
  } else {
    camera_scan_ui_strings_ = nullptr;
  }
  if (from._internal_has_image_picker_ui_strings()) {
    image_picker_ui_strings_ = new ::autofill_assistant::PromptQrCodeScanProto_ImagePickerUiStrings(*from.image_picker_ui_strings_);
  } else {
    image_picker_ui_strings_ = nullptr;
  }
  use_gallery_ = from.use_gallery_;
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.PromptQrCodeScanProto)
}

inline void PromptQrCodeScanProto::SharedCtor() {
output_client_memory_key_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  output_client_memory_key_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&camera_scan_ui_strings_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&use_gallery_) -
    reinterpret_cast<char*>(&camera_scan_ui_strings_)) + sizeof(use_gallery_));
}

PromptQrCodeScanProto::~PromptQrCodeScanProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.PromptQrCodeScanProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PromptQrCodeScanProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  output_client_memory_key_.Destroy();
  if (this != internal_default_instance()) delete camera_scan_ui_strings_;
  if (this != internal_default_instance()) delete image_picker_ui_strings_;
}

void PromptQrCodeScanProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void PromptQrCodeScanProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.PromptQrCodeScanProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      output_client_memory_key_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(camera_scan_ui_strings_ != nullptr);
      camera_scan_ui_strings_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(image_picker_ui_strings_ != nullptr);
      image_picker_ui_strings_->Clear();
    }
  }
  use_gallery_ = false;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* PromptQrCodeScanProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool use_gallery = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_use_gallery(&has_bits);
          use_gallery_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string output_client_memory_key = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_output_client_memory_key();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .autofill_assistant.PromptQrCodeScanProto.CameraScanUiStrings camera_scan_ui_strings = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_camera_scan_ui_strings(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .autofill_assistant.PromptQrCodeScanProto.ImagePickerUiStrings image_picker_ui_strings = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_image_picker_ui_strings(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PromptQrCodeScanProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.PromptQrCodeScanProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bool use_gallery = 1;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_use_gallery(), target);
  }

  // optional string output_client_memory_key = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_output_client_memory_key(), target);
  }

  // optional .autofill_assistant.PromptQrCodeScanProto.CameraScanUiStrings camera_scan_ui_strings = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::camera_scan_ui_strings(this),
        _Internal::camera_scan_ui_strings(this).GetCachedSize(), target, stream);
  }

  // optional .autofill_assistant.PromptQrCodeScanProto.ImagePickerUiStrings image_picker_ui_strings = 4;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::image_picker_ui_strings(this),
        _Internal::image_picker_ui_strings(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.PromptQrCodeScanProto)
  return target;
}

size_t PromptQrCodeScanProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.PromptQrCodeScanProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string output_client_memory_key = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_output_client_memory_key());
    }

    // optional .autofill_assistant.PromptQrCodeScanProto.CameraScanUiStrings camera_scan_ui_strings = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *camera_scan_ui_strings_);
    }

    // optional .autofill_assistant.PromptQrCodeScanProto.ImagePickerUiStrings image_picker_ui_strings = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *image_picker_ui_strings_);
    }

    // optional bool use_gallery = 1;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void PromptQrCodeScanProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const PromptQrCodeScanProto*>(
      &from));
}

void PromptQrCodeScanProto::MergeFrom(const PromptQrCodeScanProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.PromptQrCodeScanProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_output_client_memory_key(from._internal_output_client_memory_key());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_camera_scan_ui_strings()->::autofill_assistant::PromptQrCodeScanProto_CameraScanUiStrings::MergeFrom(from._internal_camera_scan_ui_strings());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_image_picker_ui_strings()->::autofill_assistant::PromptQrCodeScanProto_ImagePickerUiStrings::MergeFrom(from._internal_image_picker_ui_strings());
    }
    if (cached_has_bits & 0x00000008u) {
      use_gallery_ = from.use_gallery_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void PromptQrCodeScanProto::CopyFrom(const PromptQrCodeScanProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.PromptQrCodeScanProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PromptQrCodeScanProto::IsInitialized() const {
  return true;
}

void PromptQrCodeScanProto::InternalSwap(PromptQrCodeScanProto* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &output_client_memory_key_, lhs_arena,
      &other->output_client_memory_key_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PromptQrCodeScanProto, use_gallery_)
      + sizeof(PromptQrCodeScanProto::use_gallery_)
      - PROTOBUF_FIELD_OFFSET(PromptQrCodeScanProto, camera_scan_ui_strings_)>(
          reinterpret_cast<char*>(&camera_scan_ui_strings_),
          reinterpret_cast<char*>(&other->camera_scan_ui_strings_));
}

std::string PromptQrCodeScanProto::GetTypeName() const {
  return "autofill_assistant.PromptQrCodeScanProto";
}


// ===================================================================

class TellProto_TextToSpeech::_Internal {
 public:
  using HasBits = decltype(std::declval<TellProto_TextToSpeech>()._has_bits_);
  static void set_has_tts_message(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_play_now(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

TellProto_TextToSpeech::TellProto_TextToSpeech(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.TellProto.TextToSpeech)
}
TellProto_TextToSpeech::TellProto_TextToSpeech(const TellProto_TextToSpeech& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  tts_message_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    tts_message_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_tts_message()) {
    tts_message_.Set(from._internal_tts_message(), 
      GetArenaForAllocation());
  }
  play_now_ = from.play_now_;
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.TellProto.TextToSpeech)
}

inline void TellProto_TextToSpeech::SharedCtor() {
tts_message_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  tts_message_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
play_now_ = false;
}

TellProto_TextToSpeech::~TellProto_TextToSpeech() {
  // @@protoc_insertion_point(destructor:autofill_assistant.TellProto.TextToSpeech)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TellProto_TextToSpeech::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  tts_message_.Destroy();
}

void TellProto_TextToSpeech::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void TellProto_TextToSpeech::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.TellProto.TextToSpeech)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    tts_message_.ClearNonDefaultToEmpty();
  }
  play_now_ = false;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* TellProto_TextToSpeech::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string tts_message = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_tts_message();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool play_now = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_play_now(&has_bits);
          play_now_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TellProto_TextToSpeech::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.TellProto.TextToSpeech)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string tts_message = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_tts_message(), target);
  }

  // optional bool play_now = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_play_now(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.TellProto.TextToSpeech)
  return target;
}

size_t TellProto_TextToSpeech::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.TellProto.TextToSpeech)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string tts_message = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_tts_message());
    }

    // optional bool play_now = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TellProto_TextToSpeech::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const TellProto_TextToSpeech*>(
      &from));
}

void TellProto_TextToSpeech::MergeFrom(const TellProto_TextToSpeech& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.TellProto.TextToSpeech)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_tts_message(from._internal_tts_message());
    }
    if (cached_has_bits & 0x00000002u) {
      play_now_ = from.play_now_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TellProto_TextToSpeech::CopyFrom(const TellProto_TextToSpeech& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.TellProto.TextToSpeech)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TellProto_TextToSpeech::IsInitialized() const {
  return true;
}

void TellProto_TextToSpeech::InternalSwap(TellProto_TextToSpeech* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &tts_message_, lhs_arena,
      &other->tts_message_, rhs_arena
  );
  swap(play_now_, other->play_now_);
}

std::string TellProto_TextToSpeech::GetTypeName() const {
  return "autofill_assistant.TellProto.TextToSpeech";
}


// ===================================================================

class TellProto::_Internal {
 public:
  using HasBits = decltype(std::declval<TellProto>()._has_bits_);
  static void set_has_message(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_needs_ui(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::autofill_assistant::TellProto_TextToSpeech& text_to_speech(const TellProto* msg);
  static void set_has_text_to_speech(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::autofill_assistant::TellProto_TextToSpeech&
TellProto::_Internal::text_to_speech(const TellProto* msg) {
  return *msg->text_to_speech_;
}
TellProto::TellProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.TellProto)
}
TellProto::TellProto(const TellProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  message_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    message_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_message()) {
    message_.Set(from._internal_message(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_text_to_speech()) {
    text_to_speech_ = new ::autofill_assistant::TellProto_TextToSpeech(*from.text_to_speech_);
  } else {
    text_to_speech_ = nullptr;
  }
  needs_ui_ = from.needs_ui_;
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.TellProto)
}

inline void TellProto::SharedCtor() {
message_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  message_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
text_to_speech_ = nullptr;
needs_ui_ = true;
}

TellProto::~TellProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.TellProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TellProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  message_.Destroy();
  if (this != internal_default_instance()) delete text_to_speech_;
}

void TellProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void TellProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.TellProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      message_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(text_to_speech_ != nullptr);
      text_to_speech_->Clear();
    }
    needs_ui_ = true;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* TellProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string message = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_message();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool needs_ui = 2 [default = true];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_needs_ui(&has_bits);
          needs_ui_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .autofill_assistant.TellProto.TextToSpeech text_to_speech = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_text_to_speech(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TellProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.TellProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string message = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_message(), target);
  }

  // optional bool needs_ui = 2 [default = true];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_needs_ui(), target);
  }

  // optional .autofill_assistant.TellProto.TextToSpeech text_to_speech = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::text_to_speech(this),
        _Internal::text_to_speech(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.TellProto)
  return target;
}

size_t TellProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.TellProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string message = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_message());
    }

    // optional .autofill_assistant.TellProto.TextToSpeech text_to_speech = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *text_to_speech_);
    }

    // optional bool needs_ui = 2 [default = true];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TellProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const TellProto*>(
      &from));
}

void TellProto::MergeFrom(const TellProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.TellProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_message(from._internal_message());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_text_to_speech()->::autofill_assistant::TellProto_TextToSpeech::MergeFrom(from._internal_text_to_speech());
    }
    if (cached_has_bits & 0x00000004u) {
      needs_ui_ = from.needs_ui_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TellProto::CopyFrom(const TellProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.TellProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TellProto::IsInitialized() const {
  return true;
}

void TellProto::InternalSwap(TellProto* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &message_, lhs_arena,
      &other->message_, rhs_arena
  );
  swap(text_to_speech_, other->text_to_speech_);
  swap(needs_ui_, other->needs_ui_);
}

std::string TellProto::GetTypeName() const {
  return "autofill_assistant.TellProto";
}


// ===================================================================

class ShowCastProto_TopPadding::_Internal {
 public:
};

ShowCastProto_TopPadding::ShowCastProto_TopPadding(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.ShowCastProto.TopPadding)
}
ShowCastProto_TopPadding::ShowCastProto_TopPadding(const ShowCastProto_TopPadding& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  clear_has_top_padding();
  switch (from.top_padding_case()) {
    case kPixels: {
      _internal_set_pixels(from._internal_pixels());
      break;
    }
    case kRatio: {
      _internal_set_ratio(from._internal_ratio());
      break;
    }
    case TOP_PADDING_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.ShowCastProto.TopPadding)
}

inline void ShowCastProto_TopPadding::SharedCtor() {
clear_has_top_padding();
}

ShowCastProto_TopPadding::~ShowCastProto_TopPadding() {
  // @@protoc_insertion_point(destructor:autofill_assistant.ShowCastProto.TopPadding)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ShowCastProto_TopPadding::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_top_padding()) {
    clear_top_padding();
  }
}

void ShowCastProto_TopPadding::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ShowCastProto_TopPadding::clear_top_padding() {
// @@protoc_insertion_point(one_of_clear_start:autofill_assistant.ShowCastProto.TopPadding)
  switch (top_padding_case()) {
    case kPixels: {
      // No need to clear
      break;
    }
    case kRatio: {
      // No need to clear
      break;
    }
    case TOP_PADDING_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = TOP_PADDING_NOT_SET;
}


void ShowCastProto_TopPadding::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.ShowCastProto.TopPadding)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_top_padding();
  _internal_metadata_.Clear<std::string>();
}

const char* ShowCastProto_TopPadding::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 pixels = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _internal_set_pixels(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // float ratio = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _internal_set_ratio(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ShowCastProto_TopPadding::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.ShowCastProto.TopPadding)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (top_padding_case()) {
    case kPixels: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_pixels(), target);
      break;
    }
    case kRatio: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_ratio(), target);
      break;
    }
    default: ;
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.ShowCastProto.TopPadding)
  return target;
}

size_t ShowCastProto_TopPadding::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.ShowCastProto.TopPadding)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (top_padding_case()) {
    // int32 pixels = 1;
    case kPixels: {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_pixels());
      break;
    }
    // float ratio = 2;
    case kRatio: {
      total_size += 1 + 4;
      break;
    }
    case TOP_PADDING_NOT_SET: {
      break;
    }
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ShowCastProto_TopPadding::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ShowCastProto_TopPadding*>(
      &from));
}

void ShowCastProto_TopPadding::MergeFrom(const ShowCastProto_TopPadding& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.ShowCastProto.TopPadding)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.top_padding_case()) {
    case kPixels: {
      _internal_set_pixels(from._internal_pixels());
      break;
    }
    case kRatio: {
      _internal_set_ratio(from._internal_ratio());
      break;
    }
    case TOP_PADDING_NOT_SET: {
      break;
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ShowCastProto_TopPadding::CopyFrom(const ShowCastProto_TopPadding& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.ShowCastProto.TopPadding)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ShowCastProto_TopPadding::IsInitialized() const {
  return true;
}

void ShowCastProto_TopPadding::InternalSwap(ShowCastProto_TopPadding* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(top_padding_, other->top_padding_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

std::string ShowCastProto_TopPadding::GetTypeName() const {
  return "autofill_assistant.ShowCastProto.TopPadding";
}


// ===================================================================

class ShowCastProto::_Internal {
 public:
  using HasBits = decltype(std::declval<ShowCastProto>()._has_bits_);
  static const ::autofill_assistant::SelectorProto& element_to_present(const ShowCastProto* msg);
  static void set_has_element_to_present(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::autofill_assistant::ElementAreaProto& touchable_element_area(const ShowCastProto* msg);
  static void set_has_touchable_element_area(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::autofill_assistant::ShowCastProto_TopPadding& top_padding(const ShowCastProto* msg);
  static void set_has_top_padding(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_wait_for_stable_element(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_stable_check_max_rounds(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_stable_check_interval_ms(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static const ::autofill_assistant::SelectorProto& container(const ShowCastProto* msg);
  static void set_has_container(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::autofill_assistant::SelectorProto&
ShowCastProto::_Internal::element_to_present(const ShowCastProto* msg) {
  return *msg->element_to_present_;
}
const ::autofill_assistant::ElementAreaProto&
ShowCastProto::_Internal::touchable_element_area(const ShowCastProto* msg) {
  return *msg->touchable_element_area_;
}
const ::autofill_assistant::ShowCastProto_TopPadding&
ShowCastProto::_Internal::top_padding(const ShowCastProto* msg) {
  return *msg->top_padding_;
}
const ::autofill_assistant::SelectorProto&
ShowCastProto::_Internal::container(const ShowCastProto* msg) {
  return *msg->container_;
}
ShowCastProto::ShowCastProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.ShowCastProto)
}
ShowCastProto::ShowCastProto(const ShowCastProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_element_to_present()) {
    element_to_present_ = new ::autofill_assistant::SelectorProto(*from.element_to_present_);
  } else {
    element_to_present_ = nullptr;
  }
  if (from._internal_has_touchable_element_area()) {
    touchable_element_area_ = new ::autofill_assistant::ElementAreaProto(*from.touchable_element_area_);
  } else {
    touchable_element_area_ = nullptr;
  }
  if (from._internal_has_top_padding()) {
    top_padding_ = new ::autofill_assistant::ShowCastProto_TopPadding(*from.top_padding_);
  } else {
    top_padding_ = nullptr;
  }
  if (from._internal_has_container()) {
    container_ = new ::autofill_assistant::SelectorProto(*from.container_);
  } else {
    container_ = nullptr;
  }
  ::memcpy(&wait_for_stable_element_, &from.wait_for_stable_element_,
    static_cast<size_t>(reinterpret_cast<char*>(&stable_check_interval_ms_) -
    reinterpret_cast<char*>(&wait_for_stable_element_)) + sizeof(stable_check_interval_ms_));
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.ShowCastProto)
}

inline void ShowCastProto::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&element_to_present_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&wait_for_stable_element_) -
    reinterpret_cast<char*>(&element_to_present_)) + sizeof(wait_for_stable_element_));
stable_check_max_rounds_ = 50;
stable_check_interval_ms_ = 200;
}

ShowCastProto::~ShowCastProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.ShowCastProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ShowCastProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete element_to_present_;
  if (this != internal_default_instance()) delete touchable_element_area_;
  if (this != internal_default_instance()) delete top_padding_;
  if (this != internal_default_instance()) delete container_;
}

void ShowCastProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ShowCastProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.ShowCastProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(element_to_present_ != nullptr);
      element_to_present_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(touchable_element_area_ != nullptr);
      touchable_element_area_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(top_padding_ != nullptr);
      top_padding_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(container_ != nullptr);
      container_->Clear();
    }
  }
  if (cached_has_bits & 0x00000070u) {
    wait_for_stable_element_ = 0;
    stable_check_max_rounds_ = 50;
    stable_check_interval_ms_ = 200;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ShowCastProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .autofill_assistant.SelectorProto element_to_present = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_element_to_present(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .autofill_assistant.ElementAreaProto touchable_element_area = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_touchable_element_area(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .autofill_assistant.ShowCastProto.TopPadding top_padding = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_top_padding(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .autofill_assistant.OptionalStep wait_for_stable_element = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::autofill_assistant::OptionalStep_IsValid(val))) {
            _internal_set_wait_for_stable_element(static_cast<::autofill_assistant::OptionalStep>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(9, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional int32 stable_check_max_rounds = 10 [default = 50];
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_stable_check_max_rounds(&has_bits);
          stable_check_max_rounds_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 stable_check_interval_ms = 11 [default = 200];
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_stable_check_interval_ms(&has_bits);
          stable_check_interval_ms_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .autofill_assistant.SelectorProto container = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          ptr = ctx->ParseMessage(_internal_mutable_container(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ShowCastProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.ShowCastProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .autofill_assistant.SelectorProto element_to_present = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::element_to_present(this),
        _Internal::element_to_present(this).GetCachedSize(), target, stream);
  }

  // optional .autofill_assistant.ElementAreaProto touchable_element_area = 6;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::touchable_element_area(this),
        _Internal::touchable_element_area(this).GetCachedSize(), target, stream);
  }

  // optional .autofill_assistant.ShowCastProto.TopPadding top_padding = 7;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::top_padding(this),
        _Internal::top_padding(this).GetCachedSize(), target, stream);
  }

  // optional .autofill_assistant.OptionalStep wait_for_stable_element = 9;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      9, this->_internal_wait_for_stable_element(), target);
  }

  // optional int32 stable_check_max_rounds = 10 [default = 50];
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(10, this->_internal_stable_check_max_rounds(), target);
  }

  // optional int32 stable_check_interval_ms = 11 [default = 200];
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(11, this->_internal_stable_check_interval_ms(), target);
  }

  // optional .autofill_assistant.SelectorProto container = 12;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(12, _Internal::container(this),
        _Internal::container(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.ShowCastProto)
  return target;
}

size_t ShowCastProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.ShowCastProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // optional .autofill_assistant.SelectorProto element_to_present = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *element_to_present_);
    }

    // optional .autofill_assistant.ElementAreaProto touchable_element_area = 6;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *touchable_element_area_);
    }

    // optional .autofill_assistant.ShowCastProto.TopPadding top_padding = 7;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *top_padding_);
    }

    // optional .autofill_assistant.SelectorProto container = 12;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *container_);
    }

    // optional .autofill_assistant.OptionalStep wait_for_stable_element = 9;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_wait_for_stable_element());
    }

    // optional int32 stable_check_max_rounds = 10 [default = 50];
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_stable_check_max_rounds());
    }

    // optional int32 stable_check_interval_ms = 11 [default = 200];
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_stable_check_interval_ms());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ShowCastProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ShowCastProto*>(
      &from));
}

void ShowCastProto::MergeFrom(const ShowCastProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.ShowCastProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_element_to_present()->::autofill_assistant::SelectorProto::MergeFrom(from._internal_element_to_present());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_touchable_element_area()->::autofill_assistant::ElementAreaProto::MergeFrom(from._internal_touchable_element_area());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_top_padding()->::autofill_assistant::ShowCastProto_TopPadding::MergeFrom(from._internal_top_padding());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_mutable_container()->::autofill_assistant::SelectorProto::MergeFrom(from._internal_container());
    }
    if (cached_has_bits & 0x00000010u) {
      wait_for_stable_element_ = from.wait_for_stable_element_;
    }
    if (cached_has_bits & 0x00000020u) {
      stable_check_max_rounds_ = from.stable_check_max_rounds_;
    }
    if (cached_has_bits & 0x00000040u) {
      stable_check_interval_ms_ = from.stable_check_interval_ms_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ShowCastProto::CopyFrom(const ShowCastProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.ShowCastProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ShowCastProto::IsInitialized() const {
  return true;
}

void ShowCastProto::InternalSwap(ShowCastProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ShowCastProto, wait_for_stable_element_)
      + sizeof(ShowCastProto::wait_for_stable_element_)
      - PROTOBUF_FIELD_OFFSET(ShowCastProto, element_to_present_)>(
          reinterpret_cast<char*>(&element_to_present_),
          reinterpret_cast<char*>(&other->element_to_present_));
  swap(stable_check_max_rounds_, other->stable_check_max_rounds_);
  swap(stable_check_interval_ms_, other->stable_check_interval_ms_);
}

std::string ShowCastProto::GetTypeName() const {
  return "autofill_assistant.ShowCastProto";
}


// ===================================================================

class SetTouchableAreaProto::_Internal {
 public:
  using HasBits = decltype(std::declval<SetTouchableAreaProto>()._has_bits_);
  static const ::autofill_assistant::ElementAreaProto& element_area(const SetTouchableAreaProto* msg);
  static void set_has_element_area(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::autofill_assistant::ElementAreaProto&
SetTouchableAreaProto::_Internal::element_area(const SetTouchableAreaProto* msg) {
  return *msg->element_area_;
}
SetTouchableAreaProto::SetTouchableAreaProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.SetTouchableAreaProto)
}
SetTouchableAreaProto::SetTouchableAreaProto(const SetTouchableAreaProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_element_area()) {
    element_area_ = new ::autofill_assistant::ElementAreaProto(*from.element_area_);
  } else {
    element_area_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.SetTouchableAreaProto)
}

inline void SetTouchableAreaProto::SharedCtor() {
element_area_ = nullptr;
}

SetTouchableAreaProto::~SetTouchableAreaProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.SetTouchableAreaProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SetTouchableAreaProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete element_area_;
}

void SetTouchableAreaProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SetTouchableAreaProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.SetTouchableAreaProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(element_area_ != nullptr);
    element_area_->Clear();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* SetTouchableAreaProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .autofill_assistant.ElementAreaProto element_area = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_element_area(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SetTouchableAreaProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.SetTouchableAreaProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .autofill_assistant.ElementAreaProto element_area = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::element_area(this),
        _Internal::element_area(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.SetTouchableAreaProto)
  return target;
}

size_t SetTouchableAreaProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.SetTouchableAreaProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .autofill_assistant.ElementAreaProto element_area = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *element_area_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SetTouchableAreaProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const SetTouchableAreaProto*>(
      &from));
}

void SetTouchableAreaProto::MergeFrom(const SetTouchableAreaProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.SetTouchableAreaProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_element_area()) {
    _internal_mutable_element_area()->::autofill_assistant::ElementAreaProto::MergeFrom(from._internal_element_area());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SetTouchableAreaProto::CopyFrom(const SetTouchableAreaProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.SetTouchableAreaProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SetTouchableAreaProto::IsInitialized() const {
  return true;
}

void SetTouchableAreaProto::InternalSwap(SetTouchableAreaProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(element_area_, other->element_area_);
}

std::string SetTouchableAreaProto::GetTypeName() const {
  return "autofill_assistant.SetTouchableAreaProto";
}


// ===================================================================

class ElementAreaProto_Rectangle::_Internal {
 public:
  using HasBits = decltype(std::declval<ElementAreaProto_Rectangle>()._has_bits_);
  static void set_has_full_width(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

ElementAreaProto_Rectangle::ElementAreaProto_Rectangle(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  elements_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.ElementAreaProto.Rectangle)
}
ElementAreaProto_Rectangle::ElementAreaProto_Rectangle(const ElementAreaProto_Rectangle& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      elements_(from.elements_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  full_width_ = from.full_width_;
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.ElementAreaProto.Rectangle)
}

inline void ElementAreaProto_Rectangle::SharedCtor() {
full_width_ = false;
}

ElementAreaProto_Rectangle::~ElementAreaProto_Rectangle() {
  // @@protoc_insertion_point(destructor:autofill_assistant.ElementAreaProto.Rectangle)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ElementAreaProto_Rectangle::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ElementAreaProto_Rectangle::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ElementAreaProto_Rectangle::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.ElementAreaProto.Rectangle)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  elements_.Clear();
  full_width_ = false;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ElementAreaProto_Rectangle::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .autofill_assistant.SelectorProto elements = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_elements(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional bool full_width = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_full_width(&has_bits);
          full_width_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ElementAreaProto_Rectangle::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.ElementAreaProto.Rectangle)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .autofill_assistant.SelectorProto elements = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_elements_size()); i < n; i++) {
    const auto& repfield = this->_internal_elements(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  cached_has_bits = _has_bits_[0];
  // optional bool full_width = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_full_width(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.ElementAreaProto.Rectangle)
  return target;
}

size_t ElementAreaProto_Rectangle::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.ElementAreaProto.Rectangle)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .autofill_assistant.SelectorProto elements = 1;
  total_size += 1UL * this->_internal_elements_size();
  for (const auto& msg : this->elements_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional bool full_width = 2;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 1;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ElementAreaProto_Rectangle::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ElementAreaProto_Rectangle*>(
      &from));
}

void ElementAreaProto_Rectangle::MergeFrom(const ElementAreaProto_Rectangle& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.ElementAreaProto.Rectangle)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  elements_.MergeFrom(from.elements_);
  if (from._internal_has_full_width()) {
    _internal_set_full_width(from._internal_full_width());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ElementAreaProto_Rectangle::CopyFrom(const ElementAreaProto_Rectangle& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.ElementAreaProto.Rectangle)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ElementAreaProto_Rectangle::IsInitialized() const {
  return true;
}

void ElementAreaProto_Rectangle::InternalSwap(ElementAreaProto_Rectangle* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  elements_.InternalSwap(&other->elements_);
  swap(full_width_, other->full_width_);
}

std::string ElementAreaProto_Rectangle::GetTypeName() const {
  return "autofill_assistant.ElementAreaProto.Rectangle";
}


// ===================================================================

class ElementAreaProto::_Internal {
 public:
};

ElementAreaProto::ElementAreaProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  touchable_(arena),
  restricted_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.ElementAreaProto)
}
ElementAreaProto::ElementAreaProto(const ElementAreaProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      touchable_(from.touchable_),
      restricted_(from.restricted_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.ElementAreaProto)
}

inline void ElementAreaProto::SharedCtor() {
}

ElementAreaProto::~ElementAreaProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.ElementAreaProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ElementAreaProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ElementAreaProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ElementAreaProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.ElementAreaProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  touchable_.Clear();
  restricted_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ElementAreaProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .autofill_assistant.ElementAreaProto.Rectangle touchable = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_touchable(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .autofill_assistant.ElementAreaProto.Rectangle restricted = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_restricted(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ElementAreaProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.ElementAreaProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .autofill_assistant.ElementAreaProto.Rectangle touchable = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_touchable_size()); i < n; i++) {
    const auto& repfield = this->_internal_touchable(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .autofill_assistant.ElementAreaProto.Rectangle restricted = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_restricted_size()); i < n; i++) {
    const auto& repfield = this->_internal_restricted(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.ElementAreaProto)
  return target;
}

size_t ElementAreaProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.ElementAreaProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .autofill_assistant.ElementAreaProto.Rectangle touchable = 1;
  total_size += 1UL * this->_internal_touchable_size();
  for (const auto& msg : this->touchable_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .autofill_assistant.ElementAreaProto.Rectangle restricted = 2;
  total_size += 1UL * this->_internal_restricted_size();
  for (const auto& msg : this->restricted_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ElementAreaProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ElementAreaProto*>(
      &from));
}

void ElementAreaProto::MergeFrom(const ElementAreaProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.ElementAreaProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  touchable_.MergeFrom(from.touchable_);
  restricted_.MergeFrom(from.restricted_);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ElementAreaProto::CopyFrom(const ElementAreaProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.ElementAreaProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ElementAreaProto::IsInitialized() const {
  return true;
}

void ElementAreaProto::InternalSwap(ElementAreaProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  touchable_.InternalSwap(&other->touchable_);
  restricted_.InternalSwap(&other->restricted_);
}

std::string ElementAreaProto::GetTypeName() const {
  return "autofill_assistant.ElementAreaProto";
}


// ===================================================================

class RequiredFieldProto::_Internal {
 public:
  using HasBits = decltype(std::declval<RequiredFieldProto>()._has_bits_);
  static const ::autofill_assistant::ValueExpression& value_expression(const RequiredFieldProto* msg);
  static void set_has_value_expression(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::autofill_assistant::SelectorProto& element(const RequiredFieldProto* msg);
  static void set_has_element(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_fill_strategy(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_delay_in_millisecond(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_select_strategy(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_option_comparison_attribute(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static const ::autofill_assistant::ValueExpressionRegexp& option_comparison_value_expression_re2(const RequiredFieldProto* msg);
  static void set_has_option_comparison_value_expression_re2(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_forced(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_is_optional(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static const ::autofill_assistant::SelectorProto& option_element_to_click(const RequiredFieldProto* msg);
  static void set_has_option_element_to_click(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_click_type(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
};

const ::autofill_assistant::ValueExpression&
RequiredFieldProto::_Internal::value_expression(const RequiredFieldProto* msg) {
  return *msg->value_expression_;
}
const ::autofill_assistant::SelectorProto&
RequiredFieldProto::_Internal::element(const RequiredFieldProto* msg) {
  return *msg->element_;
}
const ::autofill_assistant::ValueExpressionRegexp&
RequiredFieldProto::_Internal::option_comparison_value_expression_re2(const RequiredFieldProto* msg) {
  return *msg->option_comparison_value_expression_re2_;
}
const ::autofill_assistant::SelectorProto&
RequiredFieldProto::_Internal::option_element_to_click(const RequiredFieldProto* msg) {
  return *msg->option_element_to_click_;
}
void RequiredFieldProto::clear_value_expression() {
  if (value_expression_ != nullptr) value_expression_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
void RequiredFieldProto::clear_option_comparison_value_expression_re2() {
  if (option_comparison_value_expression_re2_ != nullptr) option_comparison_value_expression_re2_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
RequiredFieldProto::RequiredFieldProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.RequiredFieldProto)
}
RequiredFieldProto::RequiredFieldProto(const RequiredFieldProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_element()) {
    element_ = new ::autofill_assistant::SelectorProto(*from.element_);
  } else {
    element_ = nullptr;
  }
  if (from._internal_has_option_element_to_click()) {
    option_element_to_click_ = new ::autofill_assistant::SelectorProto(*from.option_element_to_click_);
  } else {
    option_element_to_click_ = nullptr;
  }
  if (from._internal_has_value_expression()) {
    value_expression_ = new ::autofill_assistant::ValueExpression(*from.value_expression_);
  } else {
    value_expression_ = nullptr;
  }
  if (from._internal_has_option_comparison_value_expression_re2()) {
    option_comparison_value_expression_re2_ = new ::autofill_assistant::ValueExpressionRegexp(*from.option_comparison_value_expression_re2_);
  } else {
    option_comparison_value_expression_re2_ = nullptr;
  }
  ::memcpy(&fill_strategy_, &from.fill_strategy_,
    static_cast<size_t>(reinterpret_cast<char*>(&delay_in_millisecond_) -
    reinterpret_cast<char*>(&fill_strategy_)) + sizeof(delay_in_millisecond_));
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.RequiredFieldProto)
}

inline void RequiredFieldProto::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&element_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&option_comparison_attribute_) -
    reinterpret_cast<char*>(&element_)) + sizeof(option_comparison_attribute_));
delay_in_millisecond_ = 20;
}

RequiredFieldProto::~RequiredFieldProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.RequiredFieldProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RequiredFieldProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete element_;
  if (this != internal_default_instance()) delete option_element_to_click_;
  if (this != internal_default_instance()) delete value_expression_;
  if (this != internal_default_instance()) delete option_comparison_value_expression_re2_;
}

void RequiredFieldProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void RequiredFieldProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.RequiredFieldProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(element_ != nullptr);
      element_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(option_element_to_click_ != nullptr);
      option_element_to_click_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(value_expression_ != nullptr);
      value_expression_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(option_comparison_value_expression_re2_ != nullptr);
      option_comparison_value_expression_re2_->Clear();
    }
  }
  if (cached_has_bits & 0x000000f0u) {
    ::memset(&fill_strategy_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&is_optional_) -
        reinterpret_cast<char*>(&fill_strategy_)) + sizeof(is_optional_));
  }
  if (cached_has_bits & 0x00000700u) {
    ::memset(&click_type_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&option_comparison_attribute_) -
        reinterpret_cast<char*>(&click_type_)) + sizeof(option_comparison_attribute_));
    delay_in_millisecond_ = 20;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* RequiredFieldProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .autofill_assistant.SelectorProto element = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_element(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 delay_in_millisecond = 4 [default = 20];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_delay_in_millisecond(&has_bits);
          delay_in_millisecond_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool forced = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_forced(&has_bits);
          forced_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .autofill_assistant.KeyboardValueFillStrategy fill_strategy = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::autofill_assistant::KeyboardValueFillStrategy_IsValid(val))) {
            _internal_set_fill_strategy(static_cast<::autofill_assistant::KeyboardValueFillStrategy>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(7, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .autofill_assistant.DropdownSelectStrategy select_strategy = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::autofill_assistant::DropdownSelectStrategy_IsValid(val))) {
            _internal_set_select_strategy(static_cast<::autofill_assistant::DropdownSelectStrategy>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(8, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .autofill_assistant.SelectorProto option_element_to_click = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_option_element_to_click(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .autofill_assistant.ClickType click_type = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::autofill_assistant::ClickType_IsValid(val))) {
            _internal_set_click_type(static_cast<::autofill_assistant::ClickType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(10, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional bool is_optional = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_is_optional(&has_bits);
          is_optional_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .autofill_assistant.ValueExpression value_expression = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          ptr = ctx->ParseMessage(_internal_mutable_value_expression(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .autofill_assistant.SelectOptionProto.OptionComparisonAttribute option_comparison_attribute = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::autofill_assistant::SelectOptionProto_OptionComparisonAttribute_IsValid(val))) {
            _internal_set_option_comparison_attribute(static_cast<::autofill_assistant::SelectOptionProto_OptionComparisonAttribute>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(13, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .autofill_assistant.ValueExpressionRegexp option_comparison_value_expression_re2 = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 114)) {
          ptr = ctx->ParseMessage(_internal_mutable_option_comparison_value_expression_re2(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RequiredFieldProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.RequiredFieldProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .autofill_assistant.SelectorProto element = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::element(this),
        _Internal::element(this).GetCachedSize(), target, stream);
  }

  // optional int32 delay_in_millisecond = 4 [default = 20];
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_delay_in_millisecond(), target);
  }

  // optional bool forced = 5;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_forced(), target);
  }

  // optional .autofill_assistant.KeyboardValueFillStrategy fill_strategy = 7;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      7, this->_internal_fill_strategy(), target);
  }

  // optional .autofill_assistant.DropdownSelectStrategy select_strategy = 8;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      8, this->_internal_select_strategy(), target);
  }

  // optional .autofill_assistant.SelectorProto option_element_to_click = 9;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(9, _Internal::option_element_to_click(this),
        _Internal::option_element_to_click(this).GetCachedSize(), target, stream);
  }

  // optional .autofill_assistant.ClickType click_type = 10;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      10, this->_internal_click_type(), target);
  }

  // optional bool is_optional = 11;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(11, this->_internal_is_optional(), target);
  }

  // optional .autofill_assistant.ValueExpression value_expression = 12;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(12, _Internal::value_expression(this),
        _Internal::value_expression(this).GetCachedSize(), target, stream);
  }

  // optional .autofill_assistant.SelectOptionProto.OptionComparisonAttribute option_comparison_attribute = 13;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      13, this->_internal_option_comparison_attribute(), target);
  }

  // optional .autofill_assistant.ValueExpressionRegexp option_comparison_value_expression_re2 = 14;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(14, _Internal::option_comparison_value_expression_re2(this),
        _Internal::option_comparison_value_expression_re2(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.RequiredFieldProto)
  return target;
}

size_t RequiredFieldProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.RequiredFieldProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional .autofill_assistant.SelectorProto element = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *element_);
    }

    // optional .autofill_assistant.SelectorProto option_element_to_click = 9;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *option_element_to_click_);
    }

    // optional .autofill_assistant.ValueExpression value_expression = 12;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *value_expression_);
    }

    // optional .autofill_assistant.ValueExpressionRegexp option_comparison_value_expression_re2 = 14;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *option_comparison_value_expression_re2_);
    }

    // optional .autofill_assistant.KeyboardValueFillStrategy fill_strategy = 7;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_fill_strategy());
    }

    // optional .autofill_assistant.DropdownSelectStrategy select_strategy = 8;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_select_strategy());
    }

    // optional bool forced = 5;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 1;
    }

    // optional bool is_optional = 11;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 1;
    }

  }
  if (cached_has_bits & 0x00000700u) {
    // optional .autofill_assistant.ClickType click_type = 10;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_click_type());
    }

    // optional .autofill_assistant.SelectOptionProto.OptionComparisonAttribute option_comparison_attribute = 13;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_option_comparison_attribute());
    }

    // optional int32 delay_in_millisecond = 4 [default = 20];
    if (cached_has_bits & 0x00000400u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_delay_in_millisecond());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void RequiredFieldProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const RequiredFieldProto*>(
      &from));
}

void RequiredFieldProto::MergeFrom(const RequiredFieldProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.RequiredFieldProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_element()->::autofill_assistant::SelectorProto::MergeFrom(from._internal_element());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_option_element_to_click()->::autofill_assistant::SelectorProto::MergeFrom(from._internal_option_element_to_click());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_value_expression()->::autofill_assistant::ValueExpression::MergeFrom(from._internal_value_expression());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_mutable_option_comparison_value_expression_re2()->::autofill_assistant::ValueExpressionRegexp::MergeFrom(from._internal_option_comparison_value_expression_re2());
    }
    if (cached_has_bits & 0x00000010u) {
      fill_strategy_ = from.fill_strategy_;
    }
    if (cached_has_bits & 0x00000020u) {
      select_strategy_ = from.select_strategy_;
    }
    if (cached_has_bits & 0x00000040u) {
      forced_ = from.forced_;
    }
    if (cached_has_bits & 0x00000080u) {
      is_optional_ = from.is_optional_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000700u) {
    if (cached_has_bits & 0x00000100u) {
      click_type_ = from.click_type_;
    }
    if (cached_has_bits & 0x00000200u) {
      option_comparison_attribute_ = from.option_comparison_attribute_;
    }
    if (cached_has_bits & 0x00000400u) {
      delay_in_millisecond_ = from.delay_in_millisecond_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void RequiredFieldProto::CopyFrom(const RequiredFieldProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.RequiredFieldProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequiredFieldProto::IsInitialized() const {
  return true;
}

void RequiredFieldProto::InternalSwap(RequiredFieldProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RequiredFieldProto, option_comparison_attribute_)
      + sizeof(RequiredFieldProto::option_comparison_attribute_)
      - PROTOBUF_FIELD_OFFSET(RequiredFieldProto, element_)>(
          reinterpret_cast<char*>(&element_),
          reinterpret_cast<char*>(&other->element_));
  swap(delay_in_millisecond_, other->delay_in_millisecond_);
}

std::string RequiredFieldProto::GetTypeName() const {
  return "autofill_assistant.RequiredFieldProto";
}


// ===================================================================

class UseAddressProto::_Internal {
 public:
  using HasBits = decltype(std::declval<UseAddressProto>()._has_bits_);
  static const ::autofill_assistant::SelectorProto& form_field_element(const UseAddressProto* msg);
  static void set_has_form_field_element(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_skip_autofill(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::autofill_assistant::SelectorProto&
UseAddressProto::_Internal::form_field_element(const UseAddressProto* msg) {
  return *msg->form_field_element_;
}
UseAddressProto::UseAddressProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  required_fields_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.UseAddressProto)
}
UseAddressProto::UseAddressProto(const UseAddressProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      required_fields_(from.required_fields_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_form_field_element()) {
    form_field_element_ = new ::autofill_assistant::SelectorProto(*from.form_field_element_);
  } else {
    form_field_element_ = nullptr;
  }
  skip_autofill_ = from.skip_autofill_;
  clear_has_address_source();
  switch (from.address_source_case()) {
    case kName: {
      _internal_set_name(from._internal_name());
      break;
    }
    case kModelIdentifier: {
      _internal_set_model_identifier(from._internal_model_identifier());
      break;
    }
    case ADDRESS_SOURCE_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.UseAddressProto)
}

inline void UseAddressProto::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&form_field_element_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&skip_autofill_) -
    reinterpret_cast<char*>(&form_field_element_)) + sizeof(skip_autofill_));
clear_has_address_source();
}

UseAddressProto::~UseAddressProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.UseAddressProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void UseAddressProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete form_field_element_;
  if (has_address_source()) {
    clear_address_source();
  }
}

void UseAddressProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void UseAddressProto::clear_address_source() {
// @@protoc_insertion_point(one_of_clear_start:autofill_assistant.UseAddressProto)
  switch (address_source_case()) {
    case kName: {
      address_source_.name_.Destroy();
      break;
    }
    case kModelIdentifier: {
      address_source_.model_identifier_.Destroy();
      break;
    }
    case ADDRESS_SOURCE_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = ADDRESS_SOURCE_NOT_SET;
}


void UseAddressProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.UseAddressProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  required_fields_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(form_field_element_ != nullptr);
    form_field_element_->Clear();
  }
  skip_autofill_ = false;
  clear_address_source();
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* UseAddressProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .autofill_assistant.SelectorProto form_field_element = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_form_field_element(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .autofill_assistant.RequiredFieldProto required_fields = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_required_fields(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
        } else
          goto handle_unusual;
        continue;
      // string model_identifier = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          auto str = _internal_mutable_model_identifier();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool skip_autofill = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_skip_autofill(&has_bits);
          skip_autofill_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UseAddressProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.UseAddressProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1;
  if (_internal_has_name()) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  cached_has_bits = _has_bits_[0];
  // optional .autofill_assistant.SelectorProto form_field_element = 4;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::form_field_element(this),
        _Internal::form_field_element(this).GetCachedSize(), target, stream);
  }

  // repeated .autofill_assistant.RequiredFieldProto required_fields = 6;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_required_fields_size()); i < n; i++) {
    const auto& repfield = this->_internal_required_fields(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(6, repfield, repfield.GetCachedSize(), target, stream);
  }

  // string model_identifier = 9;
  if (_internal_has_model_identifier()) {
    target = stream->WriteStringMaybeAliased(
        9, this->_internal_model_identifier(), target);
  }

  // optional bool skip_autofill = 10;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(10, this->_internal_skip_autofill(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.UseAddressProto)
  return target;
}

size_t UseAddressProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.UseAddressProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .autofill_assistant.RequiredFieldProto required_fields = 6;
  total_size += 1UL * this->_internal_required_fields_size();
  for (const auto& msg : this->required_fields_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .autofill_assistant.SelectorProto form_field_element = 4;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *form_field_element_);
    }

    // optional bool skip_autofill = 10;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

  }
  switch (address_source_case()) {
    // string name = 1;
    case kName: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
      break;
    }
    // string model_identifier = 9;
    case kModelIdentifier: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_model_identifier());
      break;
    }
    case ADDRESS_SOURCE_NOT_SET: {
      break;
    }
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void UseAddressProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const UseAddressProto*>(
      &from));
}

void UseAddressProto::MergeFrom(const UseAddressProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.UseAddressProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  required_fields_.MergeFrom(from.required_fields_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_form_field_element()->::autofill_assistant::SelectorProto::MergeFrom(from._internal_form_field_element());
    }
    if (cached_has_bits & 0x00000002u) {
      skip_autofill_ = from.skip_autofill_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  switch (from.address_source_case()) {
    case kName: {
      _internal_set_name(from._internal_name());
      break;
    }
    case kModelIdentifier: {
      _internal_set_model_identifier(from._internal_model_identifier());
      break;
    }
    case ADDRESS_SOURCE_NOT_SET: {
      break;
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void UseAddressProto::CopyFrom(const UseAddressProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.UseAddressProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UseAddressProto::IsInitialized() const {
  return true;
}

void UseAddressProto::InternalSwap(UseAddressProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  required_fields_.InternalSwap(&other->required_fields_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(UseAddressProto, skip_autofill_)
      + sizeof(UseAddressProto::skip_autofill_)
      - PROTOBUF_FIELD_OFFSET(UseAddressProto, form_field_element_)>(
          reinterpret_cast<char*>(&form_field_element_),
          reinterpret_cast<char*>(&other->form_field_element_));
  swap(address_source_, other->address_source_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

std::string UseAddressProto::GetTypeName() const {
  return "autofill_assistant.UseAddressProto";
}


// ===================================================================

class UseCreditCardProto::_Internal {
 public:
  using HasBits = decltype(std::declval<UseCreditCardProto>()._has_bits_);
  static void set_has_model_identifier(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::autofill_assistant::SelectorProto& form_field_element(const UseCreditCardProto* msg);
  static void set_has_form_field_element(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_skip_autofill(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_skip_resolve(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::autofill_assistant::SelectorProto&
UseCreditCardProto::_Internal::form_field_element(const UseCreditCardProto* msg) {
  return *msg->form_field_element_;
}
UseCreditCardProto::UseCreditCardProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  required_fields_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.UseCreditCardProto)
}
UseCreditCardProto::UseCreditCardProto(const UseCreditCardProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      required_fields_(from.required_fields_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  model_identifier_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    model_identifier_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_model_identifier()) {
    model_identifier_.Set(from._internal_model_identifier(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_form_field_element()) {
    form_field_element_ = new ::autofill_assistant::SelectorProto(*from.form_field_element_);
  } else {
    form_field_element_ = nullptr;
  }
  ::memcpy(&skip_autofill_, &from.skip_autofill_,
    static_cast<size_t>(reinterpret_cast<char*>(&skip_resolve_) -
    reinterpret_cast<char*>(&skip_autofill_)) + sizeof(skip_resolve_));
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.UseCreditCardProto)
}

inline void UseCreditCardProto::SharedCtor() {
model_identifier_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  model_identifier_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&form_field_element_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&skip_resolve_) -
    reinterpret_cast<char*>(&form_field_element_)) + sizeof(skip_resolve_));
}

UseCreditCardProto::~UseCreditCardProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.UseCreditCardProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void UseCreditCardProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  model_identifier_.Destroy();
  if (this != internal_default_instance()) delete form_field_element_;
}

void UseCreditCardProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void UseCreditCardProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.UseCreditCardProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  required_fields_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      model_identifier_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(form_field_element_ != nullptr);
      form_field_element_->Clear();
    }
  }
  ::memset(&skip_autofill_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&skip_resolve_) -
      reinterpret_cast<char*>(&skip_autofill_)) + sizeof(skip_resolve_));
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* UseCreditCardProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .autofill_assistant.SelectorProto form_field_element = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_form_field_element(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string model_identifier = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_model_identifier();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .autofill_assistant.RequiredFieldProto required_fields = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_required_fields(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<58>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional bool skip_autofill = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_skip_autofill(&has_bits);
          skip_autofill_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool skip_resolve = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_skip_resolve(&has_bits);
          skip_resolve_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UseCreditCardProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.UseCreditCardProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .autofill_assistant.SelectorProto form_field_element = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::form_field_element(this),
        _Internal::form_field_element(this).GetCachedSize(), target, stream);
  }

  // optional string model_identifier = 4;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_model_identifier(), target);
  }

  // repeated .autofill_assistant.RequiredFieldProto required_fields = 7;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_required_fields_size()); i < n; i++) {
    const auto& repfield = this->_internal_required_fields(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(7, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional bool skip_autofill = 8;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(8, this->_internal_skip_autofill(), target);
  }

  // optional bool skip_resolve = 9;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(9, this->_internal_skip_resolve(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.UseCreditCardProto)
  return target;
}

size_t UseCreditCardProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.UseCreditCardProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .autofill_assistant.RequiredFieldProto required_fields = 7;
  total_size += 1UL * this->_internal_required_fields_size();
  for (const auto& msg : this->required_fields_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string model_identifier = 4;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_model_identifier());
    }

    // optional .autofill_assistant.SelectorProto form_field_element = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *form_field_element_);
    }

    // optional bool skip_autofill = 8;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

    // optional bool skip_resolve = 9;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void UseCreditCardProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const UseCreditCardProto*>(
      &from));
}

void UseCreditCardProto::MergeFrom(const UseCreditCardProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.UseCreditCardProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  required_fields_.MergeFrom(from.required_fields_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_model_identifier(from._internal_model_identifier());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_form_field_element()->::autofill_assistant::SelectorProto::MergeFrom(from._internal_form_field_element());
    }
    if (cached_has_bits & 0x00000004u) {
      skip_autofill_ = from.skip_autofill_;
    }
    if (cached_has_bits & 0x00000008u) {
      skip_resolve_ = from.skip_resolve_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void UseCreditCardProto::CopyFrom(const UseCreditCardProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.UseCreditCardProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UseCreditCardProto::IsInitialized() const {
  return true;
}

void UseCreditCardProto::InternalSwap(UseCreditCardProto* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  required_fields_.InternalSwap(&other->required_fields_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &model_identifier_, lhs_arena,
      &other->model_identifier_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(UseCreditCardProto, skip_resolve_)
      + sizeof(UseCreditCardProto::skip_resolve_)
      - PROTOBUF_FIELD_OFFSET(UseCreditCardProto, form_field_element_)>(
          reinterpret_cast<char*>(&form_field_element_),
          reinterpret_cast<char*>(&other->form_field_element_));
}

std::string UseCreditCardProto::GetTypeName() const {
  return "autofill_assistant.UseCreditCardProto";
}


// ===================================================================

class WaitForDomProto_Result::_Internal {
 public:
};

WaitForDomProto_Result::WaitForDomProto_Result(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  matching_condition_payloads_(arena),
  matching_condition_tags_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.WaitForDomProto.Result)
}
WaitForDomProto_Result::WaitForDomProto_Result(const WaitForDomProto_Result& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      matching_condition_payloads_(from.matching_condition_payloads_),
      matching_condition_tags_(from.matching_condition_tags_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.WaitForDomProto.Result)
}

inline void WaitForDomProto_Result::SharedCtor() {
}

WaitForDomProto_Result::~WaitForDomProto_Result() {
  // @@protoc_insertion_point(destructor:autofill_assistant.WaitForDomProto.Result)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void WaitForDomProto_Result::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void WaitForDomProto_Result::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void WaitForDomProto_Result::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.WaitForDomProto.Result)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  matching_condition_payloads_.Clear();
  matching_condition_tags_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* WaitForDomProto_Result::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated bytes matching_condition_payloads = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_matching_condition_payloads();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated string matching_condition_tags = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_matching_condition_tags();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* WaitForDomProto_Result::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.WaitForDomProto.Result)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated bytes matching_condition_payloads = 1;
  for (int i = 0, n = this->_internal_matching_condition_payloads_size(); i < n; i++) {
    const auto& s = this->_internal_matching_condition_payloads(i);
    target = stream->WriteBytes(1, s, target);
  }

  // repeated string matching_condition_tags = 2;
  for (int i = 0, n = this->_internal_matching_condition_tags_size(); i < n; i++) {
    const auto& s = this->_internal_matching_condition_tags(i);
    target = stream->WriteString(2, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.WaitForDomProto.Result)
  return target;
}

size_t WaitForDomProto_Result::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.WaitForDomProto.Result)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated bytes matching_condition_payloads = 1;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(matching_condition_payloads_.size());
  for (int i = 0, n = matching_condition_payloads_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
      matching_condition_payloads_.Get(i));
  }

  // repeated string matching_condition_tags = 2;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(matching_condition_tags_.size());
  for (int i = 0, n = matching_condition_tags_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      matching_condition_tags_.Get(i));
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void WaitForDomProto_Result::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const WaitForDomProto_Result*>(
      &from));
}

void WaitForDomProto_Result::MergeFrom(const WaitForDomProto_Result& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.WaitForDomProto.Result)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  matching_condition_payloads_.MergeFrom(from.matching_condition_payloads_);
  matching_condition_tags_.MergeFrom(from.matching_condition_tags_);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void WaitForDomProto_Result::CopyFrom(const WaitForDomProto_Result& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.WaitForDomProto.Result)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool WaitForDomProto_Result::IsInitialized() const {
  return true;
}

void WaitForDomProto_Result::InternalSwap(WaitForDomProto_Result* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  matching_condition_payloads_.InternalSwap(&other->matching_condition_payloads_);
  matching_condition_tags_.InternalSwap(&other->matching_condition_tags_);
}

std::string WaitForDomProto_Result::GetTypeName() const {
  return "autofill_assistant.WaitForDomProto.Result";
}


// ===================================================================

class WaitForDomProto::_Internal {
 public:
  using HasBits = decltype(std::declval<WaitForDomProto>()._has_bits_);
  static void set_has_timeout_ms(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::autofill_assistant::ElementConditionProto& wait_condition(const WaitForDomProto* msg);
  static void set_has_wait_condition(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_allow_interrupt(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::autofill_assistant::ElementConditionProto&
WaitForDomProto::_Internal::wait_condition(const WaitForDomProto* msg) {
  return *msg->wait_condition_;
}
WaitForDomProto::WaitForDomProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.WaitForDomProto)
}
WaitForDomProto::WaitForDomProto(const WaitForDomProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_wait_condition()) {
    wait_condition_ = new ::autofill_assistant::ElementConditionProto(*from.wait_condition_);
  } else {
    wait_condition_ = nullptr;
  }
  ::memcpy(&timeout_ms_, &from.timeout_ms_,
    static_cast<size_t>(reinterpret_cast<char*>(&allow_interrupt_) -
    reinterpret_cast<char*>(&timeout_ms_)) + sizeof(allow_interrupt_));
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.WaitForDomProto)
}

inline void WaitForDomProto::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&wait_condition_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&allow_interrupt_) -
    reinterpret_cast<char*>(&wait_condition_)) + sizeof(allow_interrupt_));
}

WaitForDomProto::~WaitForDomProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.WaitForDomProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void WaitForDomProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete wait_condition_;
}

void WaitForDomProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void WaitForDomProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.WaitForDomProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(wait_condition_ != nullptr);
    wait_condition_->Clear();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&timeout_ms_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&allow_interrupt_) -
        reinterpret_cast<char*>(&timeout_ms_)) + sizeof(allow_interrupt_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* WaitForDomProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 timeout_ms = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_timeout_ms(&has_bits);
          timeout_ms_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool allow_interrupt = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_allow_interrupt(&has_bits);
          allow_interrupt_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .autofill_assistant.ElementConditionProto wait_condition = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_wait_condition(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* WaitForDomProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.WaitForDomProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 timeout_ms = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_timeout_ms(), target);
  }

  // optional bool allow_interrupt = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_allow_interrupt(), target);
  }

  // optional .autofill_assistant.ElementConditionProto wait_condition = 9;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(9, _Internal::wait_condition(this),
        _Internal::wait_condition(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.WaitForDomProto)
  return target;
}

size_t WaitForDomProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.WaitForDomProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .autofill_assistant.ElementConditionProto wait_condition = 9;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *wait_condition_);
    }

    // optional int32 timeout_ms = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_timeout_ms());
    }

    // optional bool allow_interrupt = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void WaitForDomProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const WaitForDomProto*>(
      &from));
}

void WaitForDomProto::MergeFrom(const WaitForDomProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.WaitForDomProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_wait_condition()->::autofill_assistant::ElementConditionProto::MergeFrom(from._internal_wait_condition());
    }
    if (cached_has_bits & 0x00000002u) {
      timeout_ms_ = from.timeout_ms_;
    }
    if (cached_has_bits & 0x00000004u) {
      allow_interrupt_ = from.allow_interrupt_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void WaitForDomProto::CopyFrom(const WaitForDomProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.WaitForDomProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool WaitForDomProto::IsInitialized() const {
  return true;
}

void WaitForDomProto::InternalSwap(WaitForDomProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(WaitForDomProto, allow_interrupt_)
      + sizeof(WaitForDomProto::allow_interrupt_)
      - PROTOBUF_FIELD_OFFSET(WaitForDomProto, wait_condition_)>(
          reinterpret_cast<char*>(&wait_condition_),
          reinterpret_cast<char*>(&other->wait_condition_));
}

std::string WaitForDomProto::GetTypeName() const {
  return "autofill_assistant.WaitForDomProto";
}


// ===================================================================

class ElementConditionProto::_Internal {
 public:
  using HasBits = decltype(std::declval<ElementConditionProto>()._has_bits_);
  static const ::autofill_assistant::ElementConditionsProto& all_of(const ElementConditionProto* msg);
  static const ::autofill_assistant::ElementConditionsProto& any_of(const ElementConditionProto* msg);
  static const ::autofill_assistant::ElementConditionsProto& none_of(const ElementConditionProto* msg);
  static const ::autofill_assistant::SelectorProto& match(const ElementConditionProto* msg);
  static void set_has_payload(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_tag(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::autofill_assistant::ClientIdProto& client_id(const ElementConditionProto* msg);
  static void set_has_client_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_require_unique_element(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::autofill_assistant::ElementConditionsProto&
ElementConditionProto::_Internal::all_of(const ElementConditionProto* msg) {
  return *msg->type_.all_of_;
}
const ::autofill_assistant::ElementConditionsProto&
ElementConditionProto::_Internal::any_of(const ElementConditionProto* msg) {
  return *msg->type_.any_of_;
}
const ::autofill_assistant::ElementConditionsProto&
ElementConditionProto::_Internal::none_of(const ElementConditionProto* msg) {
  return *msg->type_.none_of_;
}
const ::autofill_assistant::SelectorProto&
ElementConditionProto::_Internal::match(const ElementConditionProto* msg) {
  return *msg->type_.match_;
}
const ::autofill_assistant::ClientIdProto&
ElementConditionProto::_Internal::client_id(const ElementConditionProto* msg) {
  return *msg->client_id_;
}
void ElementConditionProto::set_allocated_all_of(::autofill_assistant::ElementConditionsProto* all_of) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_type();
  if (all_of) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(all_of);
    if (message_arena != submessage_arena) {
      all_of = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, all_of, submessage_arena);
    }
    set_has_all_of();
    type_.all_of_ = all_of;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ElementConditionProto.all_of)
}
void ElementConditionProto::set_allocated_any_of(::autofill_assistant::ElementConditionsProto* any_of) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_type();
  if (any_of) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(any_of);
    if (message_arena != submessage_arena) {
      any_of = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, any_of, submessage_arena);
    }
    set_has_any_of();
    type_.any_of_ = any_of;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ElementConditionProto.any_of)
}
void ElementConditionProto::set_allocated_none_of(::autofill_assistant::ElementConditionsProto* none_of) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_type();
  if (none_of) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(none_of);
    if (message_arena != submessage_arena) {
      none_of = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, none_of, submessage_arena);
    }
    set_has_none_of();
    type_.none_of_ = none_of;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ElementConditionProto.none_of)
}
void ElementConditionProto::set_allocated_match(::autofill_assistant::SelectorProto* match) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_type();
  if (match) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(match);
    if (message_arena != submessage_arena) {
      match = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, match, submessage_arena);
    }
    set_has_match();
    type_.match_ = match;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ElementConditionProto.match)
}
void ElementConditionProto::clear_client_id() {
  if (client_id_ != nullptr) client_id_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
ElementConditionProto::ElementConditionProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.ElementConditionProto)
}
ElementConditionProto::ElementConditionProto(const ElementConditionProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  payload_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    payload_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_payload()) {
    payload_.Set(from._internal_payload(), 
      GetArenaForAllocation());
  }
  tag_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    tag_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_tag()) {
    tag_.Set(from._internal_tag(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_client_id()) {
    client_id_ = new ::autofill_assistant::ClientIdProto(*from.client_id_);
  } else {
    client_id_ = nullptr;
  }
  require_unique_element_ = from.require_unique_element_;
  clear_has_type();
  switch (from.type_case()) {
    case kAllOf: {
      _internal_mutable_all_of()->::autofill_assistant::ElementConditionsProto::MergeFrom(from._internal_all_of());
      break;
    }
    case kAnyOf: {
      _internal_mutable_any_of()->::autofill_assistant::ElementConditionsProto::MergeFrom(from._internal_any_of());
      break;
    }
    case kNoneOf: {
      _internal_mutable_none_of()->::autofill_assistant::ElementConditionsProto::MergeFrom(from._internal_none_of());
      break;
    }
    case kMatch: {
      _internal_mutable_match()->::autofill_assistant::SelectorProto::MergeFrom(from._internal_match());
      break;
    }
    case TYPE_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.ElementConditionProto)
}

inline void ElementConditionProto::SharedCtor() {
payload_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  payload_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
tag_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  tag_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&client_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&require_unique_element_) -
    reinterpret_cast<char*>(&client_id_)) + sizeof(require_unique_element_));
clear_has_type();
}

ElementConditionProto::~ElementConditionProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.ElementConditionProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ElementConditionProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  payload_.Destroy();
  tag_.Destroy();
  if (this != internal_default_instance()) delete client_id_;
  if (has_type()) {
    clear_type();
  }
}

void ElementConditionProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ElementConditionProto::clear_type() {
// @@protoc_insertion_point(one_of_clear_start:autofill_assistant.ElementConditionProto)
  switch (type_case()) {
    case kAllOf: {
      if (GetArenaForAllocation() == nullptr) {
        delete type_.all_of_;
      }
      break;
    }
    case kAnyOf: {
      if (GetArenaForAllocation() == nullptr) {
        delete type_.any_of_;
      }
      break;
    }
    case kNoneOf: {
      if (GetArenaForAllocation() == nullptr) {
        delete type_.none_of_;
      }
      break;
    }
    case kMatch: {
      if (GetArenaForAllocation() == nullptr) {
        delete type_.match_;
      }
      break;
    }
    case TYPE_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = TYPE_NOT_SET;
}


void ElementConditionProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.ElementConditionProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      payload_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      tag_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(client_id_ != nullptr);
      client_id_->Clear();
    }
  }
  require_unique_element_ = false;
  clear_type();
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ElementConditionProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .autofill_assistant.ElementConditionsProto all_of = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_all_of(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.ElementConditionsProto any_of = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_any_of(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.ElementConditionsProto none_of = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_none_of(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.SelectorProto match = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_match(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes payload = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_payload();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .autofill_assistant.ClientIdProto client_id = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_client_id(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool require_unique_element = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_require_unique_element(&has_bits);
          require_unique_element_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string tag = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          auto str = _internal_mutable_tag();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ElementConditionProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.ElementConditionProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (type_case()) {
    case kAllOf: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, _Internal::all_of(this),
          _Internal::all_of(this).GetCachedSize(), target, stream);
      break;
    }
    case kAnyOf: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, _Internal::any_of(this),
          _Internal::any_of(this).GetCachedSize(), target, stream);
      break;
    }
    case kNoneOf: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, _Internal::none_of(this),
          _Internal::none_of(this).GetCachedSize(), target, stream);
      break;
    }
    case kMatch: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, _Internal::match(this),
          _Internal::match(this).GetCachedSize(), target, stream);
      break;
    }
    default: ;
  }
  cached_has_bits = _has_bits_[0];
  // optional bytes payload = 5;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        5, this->_internal_payload(), target);
  }

  // optional .autofill_assistant.ClientIdProto client_id = 6;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::client_id(this),
        _Internal::client_id(this).GetCachedSize(), target, stream);
  }

  // optional bool require_unique_element = 7;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(7, this->_internal_require_unique_element(), target);
  }

  // optional string tag = 8;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        8, this->_internal_tag(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.ElementConditionProto)
  return target;
}

size_t ElementConditionProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.ElementConditionProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional bytes payload = 5;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_payload());
    }

    // optional string tag = 8;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_tag());
    }

    // optional .autofill_assistant.ClientIdProto client_id = 6;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *client_id_);
    }

    // optional bool require_unique_element = 7;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

  }
  switch (type_case()) {
    // .autofill_assistant.ElementConditionsProto all_of = 1;
    case kAllOf: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *type_.all_of_);
      break;
    }
    // .autofill_assistant.ElementConditionsProto any_of = 2;
    case kAnyOf: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *type_.any_of_);
      break;
    }
    // .autofill_assistant.ElementConditionsProto none_of = 3;
    case kNoneOf: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *type_.none_of_);
      break;
    }
    // .autofill_assistant.SelectorProto match = 4;
    case kMatch: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *type_.match_);
      break;
    }
    case TYPE_NOT_SET: {
      break;
    }
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ElementConditionProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ElementConditionProto*>(
      &from));
}

void ElementConditionProto::MergeFrom(const ElementConditionProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.ElementConditionProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_payload(from._internal_payload());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_tag(from._internal_tag());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_client_id()->::autofill_assistant::ClientIdProto::MergeFrom(from._internal_client_id());
    }
    if (cached_has_bits & 0x00000008u) {
      require_unique_element_ = from.require_unique_element_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  switch (from.type_case()) {
    case kAllOf: {
      _internal_mutable_all_of()->::autofill_assistant::ElementConditionsProto::MergeFrom(from._internal_all_of());
      break;
    }
    case kAnyOf: {
      _internal_mutable_any_of()->::autofill_assistant::ElementConditionsProto::MergeFrom(from._internal_any_of());
      break;
    }
    case kNoneOf: {
      _internal_mutable_none_of()->::autofill_assistant::ElementConditionsProto::MergeFrom(from._internal_none_of());
      break;
    }
    case kMatch: {
      _internal_mutable_match()->::autofill_assistant::SelectorProto::MergeFrom(from._internal_match());
      break;
    }
    case TYPE_NOT_SET: {
      break;
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ElementConditionProto::CopyFrom(const ElementConditionProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.ElementConditionProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ElementConditionProto::IsInitialized() const {
  return true;
}

void ElementConditionProto::InternalSwap(ElementConditionProto* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &payload_, lhs_arena,
      &other->payload_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &tag_, lhs_arena,
      &other->tag_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ElementConditionProto, require_unique_element_)
      + sizeof(ElementConditionProto::require_unique_element_)
      - PROTOBUF_FIELD_OFFSET(ElementConditionProto, client_id_)>(
          reinterpret_cast<char*>(&client_id_),
          reinterpret_cast<char*>(&other->client_id_));
  swap(type_, other->type_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

std::string ElementConditionProto::GetTypeName() const {
  return "autofill_assistant.ElementConditionProto";
}


// ===================================================================

class ElementConditionsProto::_Internal {
 public:
};

ElementConditionsProto::ElementConditionsProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  conditions_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.ElementConditionsProto)
}
ElementConditionsProto::ElementConditionsProto(const ElementConditionsProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      conditions_(from.conditions_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.ElementConditionsProto)
}

inline void ElementConditionsProto::SharedCtor() {
}

ElementConditionsProto::~ElementConditionsProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.ElementConditionsProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ElementConditionsProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ElementConditionsProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ElementConditionsProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.ElementConditionsProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  conditions_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ElementConditionsProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .autofill_assistant.ElementConditionProto conditions = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_conditions(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ElementConditionsProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.ElementConditionsProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .autofill_assistant.ElementConditionProto conditions = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_conditions_size()); i < n; i++) {
    const auto& repfield = this->_internal_conditions(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.ElementConditionsProto)
  return target;
}

size_t ElementConditionsProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.ElementConditionsProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .autofill_assistant.ElementConditionProto conditions = 1;
  total_size += 1UL * this->_internal_conditions_size();
  for (const auto& msg : this->conditions_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ElementConditionsProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ElementConditionsProto*>(
      &from));
}

void ElementConditionsProto::MergeFrom(const ElementConditionsProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.ElementConditionsProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  conditions_.MergeFrom(from.conditions_);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ElementConditionsProto::CopyFrom(const ElementConditionsProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.ElementConditionsProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ElementConditionsProto::IsInitialized() const {
  return true;
}

void ElementConditionsProto::InternalSwap(ElementConditionsProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  conditions_.InternalSwap(&other->conditions_);
}

std::string ElementConditionsProto::GetTypeName() const {
  return "autofill_assistant.ElementConditionsProto";
}


// ===================================================================

class UploadDomProto_Result::_Internal {
 public:
};

UploadDomProto_Result::UploadDomProto_Result(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  outer_htmls_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.UploadDomProto.Result)
}
UploadDomProto_Result::UploadDomProto_Result(const UploadDomProto_Result& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      outer_htmls_(from.outer_htmls_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.UploadDomProto.Result)
}

inline void UploadDomProto_Result::SharedCtor() {
}

UploadDomProto_Result::~UploadDomProto_Result() {
  // @@protoc_insertion_point(destructor:autofill_assistant.UploadDomProto.Result)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void UploadDomProto_Result::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void UploadDomProto_Result::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void UploadDomProto_Result::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.UploadDomProto.Result)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  outer_htmls_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* UploadDomProto_Result::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated string outer_htmls = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_outer_htmls();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UploadDomProto_Result::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.UploadDomProto.Result)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated string outer_htmls = 1;
  for (int i = 0, n = this->_internal_outer_htmls_size(); i < n; i++) {
    const auto& s = this->_internal_outer_htmls(i);
    target = stream->WriteString(1, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.UploadDomProto.Result)
  return target;
}

size_t UploadDomProto_Result::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.UploadDomProto.Result)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string outer_htmls = 1;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(outer_htmls_.size());
  for (int i = 0, n = outer_htmls_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      outer_htmls_.Get(i));
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void UploadDomProto_Result::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const UploadDomProto_Result*>(
      &from));
}

void UploadDomProto_Result::MergeFrom(const UploadDomProto_Result& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.UploadDomProto.Result)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  outer_htmls_.MergeFrom(from.outer_htmls_);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void UploadDomProto_Result::CopyFrom(const UploadDomProto_Result& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.UploadDomProto.Result)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UploadDomProto_Result::IsInitialized() const {
  return true;
}

void UploadDomProto_Result::InternalSwap(UploadDomProto_Result* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  outer_htmls_.InternalSwap(&other->outer_htmls_);
}

std::string UploadDomProto_Result::GetTypeName() const {
  return "autofill_assistant.UploadDomProto.Result";
}


// ===================================================================

class UploadDomProto::_Internal {
 public:
  using HasBits = decltype(std::declval<UploadDomProto>()._has_bits_);
  static const ::autofill_assistant::SelectorProto& tree_root(const UploadDomProto* msg);
  static void set_has_tree_root(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_can_match_multiple_elements(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_include_all_inner_text(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::autofill_assistant::SelectorProto&
UploadDomProto::_Internal::tree_root(const UploadDomProto* msg) {
  return *msg->tree_root_;
}
UploadDomProto::UploadDomProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.UploadDomProto)
}
UploadDomProto::UploadDomProto(const UploadDomProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_tree_root()) {
    tree_root_ = new ::autofill_assistant::SelectorProto(*from.tree_root_);
  } else {
    tree_root_ = nullptr;
  }
  ::memcpy(&can_match_multiple_elements_, &from.can_match_multiple_elements_,
    static_cast<size_t>(reinterpret_cast<char*>(&include_all_inner_text_) -
    reinterpret_cast<char*>(&can_match_multiple_elements_)) + sizeof(include_all_inner_text_));
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.UploadDomProto)
}

inline void UploadDomProto::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&tree_root_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&include_all_inner_text_) -
    reinterpret_cast<char*>(&tree_root_)) + sizeof(include_all_inner_text_));
}

UploadDomProto::~UploadDomProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.UploadDomProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void UploadDomProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete tree_root_;
}

void UploadDomProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void UploadDomProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.UploadDomProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(tree_root_ != nullptr);
    tree_root_->Clear();
  }
  ::memset(&can_match_multiple_elements_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&include_all_inner_text_) -
      reinterpret_cast<char*>(&can_match_multiple_elements_)) + sizeof(include_all_inner_text_));
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* UploadDomProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .autofill_assistant.SelectorProto tree_root = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_tree_root(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool can_match_multiple_elements = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_can_match_multiple_elements(&has_bits);
          can_match_multiple_elements_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool include_all_inner_text = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_include_all_inner_text(&has_bits);
          include_all_inner_text_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UploadDomProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.UploadDomProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .autofill_assistant.SelectorProto tree_root = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::tree_root(this),
        _Internal::tree_root(this).GetCachedSize(), target, stream);
  }

  // optional bool can_match_multiple_elements = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_can_match_multiple_elements(), target);
  }

  // optional bool include_all_inner_text = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_include_all_inner_text(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.UploadDomProto)
  return target;
}

size_t UploadDomProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.UploadDomProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .autofill_assistant.SelectorProto tree_root = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *tree_root_);
    }

    // optional bool can_match_multiple_elements = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

    // optional bool include_all_inner_text = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void UploadDomProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const UploadDomProto*>(
      &from));
}

void UploadDomProto::MergeFrom(const UploadDomProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.UploadDomProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_tree_root()->::autofill_assistant::SelectorProto::MergeFrom(from._internal_tree_root());
    }
    if (cached_has_bits & 0x00000002u) {
      can_match_multiple_elements_ = from.can_match_multiple_elements_;
    }
    if (cached_has_bits & 0x00000004u) {
      include_all_inner_text_ = from.include_all_inner_text_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void UploadDomProto::CopyFrom(const UploadDomProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.UploadDomProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UploadDomProto::IsInitialized() const {
  return true;
}

void UploadDomProto::InternalSwap(UploadDomProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(UploadDomProto, include_all_inner_text_)
      + sizeof(UploadDomProto::include_all_inner_text_)
      - PROTOBUF_FIELD_OFFSET(UploadDomProto, tree_root_)>(
          reinterpret_cast<char*>(&tree_root_),
          reinterpret_cast<char*>(&other->tree_root_));
}

std::string UploadDomProto::GetTypeName() const {
  return "autofill_assistant.UploadDomProto";
}


// ===================================================================

class ShowProgressBarProto_StepProgressBarIcon::_Internal {
 public:
  using HasBits = decltype(std::declval<ShowProgressBarProto_StepProgressBarIcon>()._has_bits_);
  static const ::autofill_assistant::DrawableProto& icon(const ShowProgressBarProto_StepProgressBarIcon* msg);
  static void set_has_icon(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_identifier(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::autofill_assistant::DrawableProto&
ShowProgressBarProto_StepProgressBarIcon::_Internal::icon(const ShowProgressBarProto_StepProgressBarIcon* msg) {
  return *msg->icon_;
}
void ShowProgressBarProto_StepProgressBarIcon::clear_icon() {
  if (icon_ != nullptr) icon_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
ShowProgressBarProto_StepProgressBarIcon::ShowProgressBarProto_StepProgressBarIcon(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.ShowProgressBarProto.StepProgressBarIcon)
}
ShowProgressBarProto_StepProgressBarIcon::ShowProgressBarProto_StepProgressBarIcon(const ShowProgressBarProto_StepProgressBarIcon& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  identifier_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    identifier_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_identifier()) {
    identifier_.Set(from._internal_identifier(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_icon()) {
    icon_ = new ::autofill_assistant::DrawableProto(*from.icon_);
  } else {
    icon_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.ShowProgressBarProto.StepProgressBarIcon)
}

inline void ShowProgressBarProto_StepProgressBarIcon::SharedCtor() {
identifier_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  identifier_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
icon_ = nullptr;
}

ShowProgressBarProto_StepProgressBarIcon::~ShowProgressBarProto_StepProgressBarIcon() {
  // @@protoc_insertion_point(destructor:autofill_assistant.ShowProgressBarProto.StepProgressBarIcon)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ShowProgressBarProto_StepProgressBarIcon::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  identifier_.Destroy();
  if (this != internal_default_instance()) delete icon_;
}

void ShowProgressBarProto_StepProgressBarIcon::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ShowProgressBarProto_StepProgressBarIcon::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.ShowProgressBarProto.StepProgressBarIcon)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      identifier_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(icon_ != nullptr);
      icon_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ShowProgressBarProto_StepProgressBarIcon::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .autofill_assistant.DrawableProto icon = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_icon(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string identifier = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_identifier();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ShowProgressBarProto_StepProgressBarIcon::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.ShowProgressBarProto.StepProgressBarIcon)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .autofill_assistant.DrawableProto icon = 1;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::icon(this),
        _Internal::icon(this).GetCachedSize(), target, stream);
  }

  // optional string identifier = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_identifier(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.ShowProgressBarProto.StepProgressBarIcon)
  return target;
}

size_t ShowProgressBarProto_StepProgressBarIcon::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.ShowProgressBarProto.StepProgressBarIcon)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string identifier = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_identifier());
    }

    // optional .autofill_assistant.DrawableProto icon = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *icon_);
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ShowProgressBarProto_StepProgressBarIcon::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ShowProgressBarProto_StepProgressBarIcon*>(
      &from));
}

void ShowProgressBarProto_StepProgressBarIcon::MergeFrom(const ShowProgressBarProto_StepProgressBarIcon& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.ShowProgressBarProto.StepProgressBarIcon)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_identifier(from._internal_identifier());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_icon()->::autofill_assistant::DrawableProto::MergeFrom(from._internal_icon());
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ShowProgressBarProto_StepProgressBarIcon::CopyFrom(const ShowProgressBarProto_StepProgressBarIcon& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.ShowProgressBarProto.StepProgressBarIcon)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ShowProgressBarProto_StepProgressBarIcon::IsInitialized() const {
  return true;
}

void ShowProgressBarProto_StepProgressBarIcon::InternalSwap(ShowProgressBarProto_StepProgressBarIcon* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &identifier_, lhs_arena,
      &other->identifier_, rhs_arena
  );
  swap(icon_, other->icon_);
}

std::string ShowProgressBarProto_StepProgressBarIcon::GetTypeName() const {
  return "autofill_assistant.ShowProgressBarProto.StepProgressBarIcon";
}


// ===================================================================

class ShowProgressBarProto_StepProgressBarConfiguration::_Internal {
 public:
};

ShowProgressBarProto_StepProgressBarConfiguration::ShowProgressBarProto_StepProgressBarConfiguration(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  annotated_step_icons_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.ShowProgressBarProto.StepProgressBarConfiguration)
}
ShowProgressBarProto_StepProgressBarConfiguration::ShowProgressBarProto_StepProgressBarConfiguration(const ShowProgressBarProto_StepProgressBarConfiguration& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      annotated_step_icons_(from.annotated_step_icons_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.ShowProgressBarProto.StepProgressBarConfiguration)
}

inline void ShowProgressBarProto_StepProgressBarConfiguration::SharedCtor() {
}

ShowProgressBarProto_StepProgressBarConfiguration::~ShowProgressBarProto_StepProgressBarConfiguration() {
  // @@protoc_insertion_point(destructor:autofill_assistant.ShowProgressBarProto.StepProgressBarConfiguration)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ShowProgressBarProto_StepProgressBarConfiguration::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ShowProgressBarProto_StepProgressBarConfiguration::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ShowProgressBarProto_StepProgressBarConfiguration::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.ShowProgressBarProto.StepProgressBarConfiguration)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  annotated_step_icons_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ShowProgressBarProto_StepProgressBarConfiguration::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .autofill_assistant.ShowProgressBarProto.StepProgressBarIcon annotated_step_icons = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_annotated_step_icons(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ShowProgressBarProto_StepProgressBarConfiguration::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.ShowProgressBarProto.StepProgressBarConfiguration)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .autofill_assistant.ShowProgressBarProto.StepProgressBarIcon annotated_step_icons = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_annotated_step_icons_size()); i < n; i++) {
    const auto& repfield = this->_internal_annotated_step_icons(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.ShowProgressBarProto.StepProgressBarConfiguration)
  return target;
}

size_t ShowProgressBarProto_StepProgressBarConfiguration::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.ShowProgressBarProto.StepProgressBarConfiguration)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .autofill_assistant.ShowProgressBarProto.StepProgressBarIcon annotated_step_icons = 3;
  total_size += 1UL * this->_internal_annotated_step_icons_size();
  for (const auto& msg : this->annotated_step_icons_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ShowProgressBarProto_StepProgressBarConfiguration::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ShowProgressBarProto_StepProgressBarConfiguration*>(
      &from));
}

void ShowProgressBarProto_StepProgressBarConfiguration::MergeFrom(const ShowProgressBarProto_StepProgressBarConfiguration& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.ShowProgressBarProto.StepProgressBarConfiguration)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  annotated_step_icons_.MergeFrom(from.annotated_step_icons_);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ShowProgressBarProto_StepProgressBarConfiguration::CopyFrom(const ShowProgressBarProto_StepProgressBarConfiguration& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.ShowProgressBarProto.StepProgressBarConfiguration)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ShowProgressBarProto_StepProgressBarConfiguration::IsInitialized() const {
  return true;
}

void ShowProgressBarProto_StepProgressBarConfiguration::InternalSwap(ShowProgressBarProto_StepProgressBarConfiguration* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  annotated_step_icons_.InternalSwap(&other->annotated_step_icons_);
}

std::string ShowProgressBarProto_StepProgressBarConfiguration::GetTypeName() const {
  return "autofill_assistant.ShowProgressBarProto.StepProgressBarConfiguration";
}


// ===================================================================

class ShowProgressBarProto::_Internal {
 public:
  using HasBits = decltype(std::declval<ShowProgressBarProto>()._has_bits_);
  static void set_has_error_state(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_hide(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::autofill_assistant::ShowProgressBarProto_StepProgressBarConfiguration& step_progress_bar_configuration(const ShowProgressBarProto* msg);
  static void set_has_step_progress_bar_configuration(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::autofill_assistant::ShowProgressBarProto_StepProgressBarConfiguration&
ShowProgressBarProto::_Internal::step_progress_bar_configuration(const ShowProgressBarProto* msg) {
  return *msg->step_progress_bar_configuration_;
}
ShowProgressBarProto::ShowProgressBarProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.ShowProgressBarProto)
}
ShowProgressBarProto::ShowProgressBarProto(const ShowProgressBarProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_step_progress_bar_configuration()) {
    step_progress_bar_configuration_ = new ::autofill_assistant::ShowProgressBarProto_StepProgressBarConfiguration(*from.step_progress_bar_configuration_);
  } else {
    step_progress_bar_configuration_ = nullptr;
  }
  ::memcpy(&error_state_, &from.error_state_,
    static_cast<size_t>(reinterpret_cast<char*>(&hide_) -
    reinterpret_cast<char*>(&error_state_)) + sizeof(hide_));
  clear_has_progress_indicator();
  switch (from.progress_indicator_case()) {
    case kActiveStep: {
      _internal_set_active_step(from._internal_active_step());
      break;
    }
    case kActiveStepIdentifier: {
      _internal_set_active_step_identifier(from._internal_active_step_identifier());
      break;
    }
    case kCompleteProgress: {
      _internal_set_complete_progress(from._internal_complete_progress());
      break;
    }
    case PROGRESS_INDICATOR_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.ShowProgressBarProto)
}

inline void ShowProgressBarProto::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&step_progress_bar_configuration_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&hide_) -
    reinterpret_cast<char*>(&step_progress_bar_configuration_)) + sizeof(hide_));
clear_has_progress_indicator();
}

ShowProgressBarProto::~ShowProgressBarProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.ShowProgressBarProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ShowProgressBarProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete step_progress_bar_configuration_;
  if (has_progress_indicator()) {
    clear_progress_indicator();
  }
}

void ShowProgressBarProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ShowProgressBarProto::clear_progress_indicator() {
// @@protoc_insertion_point(one_of_clear_start:autofill_assistant.ShowProgressBarProto)
  switch (progress_indicator_case()) {
    case kActiveStep: {
      // No need to clear
      break;
    }
    case kActiveStepIdentifier: {
      progress_indicator_.active_step_identifier_.Destroy();
      break;
    }
    case kCompleteProgress: {
      // No need to clear
      break;
    }
    case PROGRESS_INDICATOR_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = PROGRESS_INDICATOR_NOT_SET;
}


void ShowProgressBarProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.ShowProgressBarProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(step_progress_bar_configuration_ != nullptr);
    step_progress_bar_configuration_->Clear();
  }
  ::memset(&error_state_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&hide_) -
      reinterpret_cast<char*>(&error_state_)) + sizeof(hide_));
  clear_progress_indicator();
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ShowProgressBarProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool hide = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_hide(&has_bits);
          hide_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 active_step = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _internal_set_active_step(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .autofill_assistant.ShowProgressBarProto.StepProgressBarConfiguration step_progress_bar_configuration = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_step_progress_bar_configuration(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool error_state = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_error_state(&has_bits);
          error_state_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string active_step_identifier = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          auto str = _internal_mutable_active_step_identifier();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool complete_progress = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _internal_set_complete_progress(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ShowProgressBarProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.ShowProgressBarProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bool hide = 7;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(7, this->_internal_hide(), target);
  }

  // int32 active_step = 8;
  if (_internal_has_active_step()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(8, this->_internal_active_step(), target);
  }

  // optional .autofill_assistant.ShowProgressBarProto.StepProgressBarConfiguration step_progress_bar_configuration = 9;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(9, _Internal::step_progress_bar_configuration(this),
        _Internal::step_progress_bar_configuration(this).GetCachedSize(), target, stream);
  }

  // optional bool error_state = 10;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(10, this->_internal_error_state(), target);
  }

  switch (progress_indicator_case()) {
    case kActiveStepIdentifier: {
      target = stream->WriteStringMaybeAliased(
          11, this->_internal_active_step_identifier(), target);
      break;
    }
    case kCompleteProgress: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteBoolToArray(12, this->_internal_complete_progress(), target);
      break;
    }
    default: ;
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.ShowProgressBarProto)
  return target;
}

size_t ShowProgressBarProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.ShowProgressBarProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .autofill_assistant.ShowProgressBarProto.StepProgressBarConfiguration step_progress_bar_configuration = 9;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *step_progress_bar_configuration_);
    }

    // optional bool error_state = 10;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

    // optional bool hide = 7;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

  }
  switch (progress_indicator_case()) {
    // int32 active_step = 8;
    case kActiveStep: {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_active_step());
      break;
    }
    // string active_step_identifier = 11;
    case kActiveStepIdentifier: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_active_step_identifier());
      break;
    }
    // bool complete_progress = 12;
    case kCompleteProgress: {
      total_size += 1 + 1;
      break;
    }
    case PROGRESS_INDICATOR_NOT_SET: {
      break;
    }
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ShowProgressBarProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ShowProgressBarProto*>(
      &from));
}

void ShowProgressBarProto::MergeFrom(const ShowProgressBarProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.ShowProgressBarProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_step_progress_bar_configuration()->::autofill_assistant::ShowProgressBarProto_StepProgressBarConfiguration::MergeFrom(from._internal_step_progress_bar_configuration());
    }
    if (cached_has_bits & 0x00000002u) {
      error_state_ = from.error_state_;
    }
    if (cached_has_bits & 0x00000004u) {
      hide_ = from.hide_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  switch (from.progress_indicator_case()) {
    case kActiveStep: {
      _internal_set_active_step(from._internal_active_step());
      break;
    }
    case kActiveStepIdentifier: {
      _internal_set_active_step_identifier(from._internal_active_step_identifier());
      break;
    }
    case kCompleteProgress: {
      _internal_set_complete_progress(from._internal_complete_progress());
      break;
    }
    case PROGRESS_INDICATOR_NOT_SET: {
      break;
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ShowProgressBarProto::CopyFrom(const ShowProgressBarProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.ShowProgressBarProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ShowProgressBarProto::IsInitialized() const {
  return true;
}

void ShowProgressBarProto::InternalSwap(ShowProgressBarProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ShowProgressBarProto, hide_)
      + sizeof(ShowProgressBarProto::hide_)
      - PROTOBUF_FIELD_OFFSET(ShowProgressBarProto, step_progress_bar_configuration_)>(
          reinterpret_cast<char*>(&step_progress_bar_configuration_),
          reinterpret_cast<char*>(&other->step_progress_bar_configuration_));
  swap(progress_indicator_, other->progress_indicator_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

std::string ShowProgressBarProto::GetTypeName() const {
  return "autofill_assistant.ShowProgressBarProto";
}


// ===================================================================

class NavigateProto::_Internal {
 public:
};

NavigateProto::NavigateProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.NavigateProto)
}
NavigateProto::NavigateProto(const NavigateProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  clear_has_value();
  switch (from.value_case()) {
    case kUrl: {
      _internal_set_url(from._internal_url());
      break;
    }
    case kGoBackward: {
      _internal_set_go_backward(from._internal_go_backward());
      break;
    }
    case kGoForward: {
      _internal_set_go_forward(from._internal_go_forward());
      break;
    }
    case VALUE_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.NavigateProto)
}

inline void NavigateProto::SharedCtor() {
clear_has_value();
}

NavigateProto::~NavigateProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.NavigateProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void NavigateProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_value()) {
    clear_value();
  }
}

void NavigateProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void NavigateProto::clear_value() {
// @@protoc_insertion_point(one_of_clear_start:autofill_assistant.NavigateProto)
  switch (value_case()) {
    case kUrl: {
      value_.url_.Destroy();
      break;
    }
    case kGoBackward: {
      // No need to clear
      break;
    }
    case kGoForward: {
      // No need to clear
      break;
    }
    case VALUE_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = VALUE_NOT_SET;
}


void NavigateProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.NavigateProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_value();
  _internal_metadata_.Clear<std::string>();
}

const char* NavigateProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string url = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_url();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool go_backward = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _internal_set_go_backward(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool go_forward = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _internal_set_go_forward(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NavigateProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.NavigateProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (value_case()) {
    case kUrl: {
      target = stream->WriteStringMaybeAliased(
          1, this->_internal_url(), target);
      break;
    }
    case kGoBackward: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_go_backward(), target);
      break;
    }
    case kGoForward: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_go_forward(), target);
      break;
    }
    default: ;
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.NavigateProto)
  return target;
}

size_t NavigateProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.NavigateProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (value_case()) {
    // string url = 1;
    case kUrl: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_url());
      break;
    }
    // bool go_backward = 2;
    case kGoBackward: {
      total_size += 1 + 1;
      break;
    }
    // bool go_forward = 3;
    case kGoForward: {
      total_size += 1 + 1;
      break;
    }
    case VALUE_NOT_SET: {
      break;
    }
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void NavigateProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const NavigateProto*>(
      &from));
}

void NavigateProto::MergeFrom(const NavigateProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.NavigateProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.value_case()) {
    case kUrl: {
      _internal_set_url(from._internal_url());
      break;
    }
    case kGoBackward: {
      _internal_set_go_backward(from._internal_go_backward());
      break;
    }
    case kGoForward: {
      _internal_set_go_forward(from._internal_go_forward());
      break;
    }
    case VALUE_NOT_SET: {
      break;
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void NavigateProto::CopyFrom(const NavigateProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.NavigateProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NavigateProto::IsInitialized() const {
  return true;
}

void NavigateProto::InternalSwap(NavigateProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(value_, other->value_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

std::string NavigateProto::GetTypeName() const {
  return "autofill_assistant.NavigateProto";
}


// ===================================================================

class ExpectNavigationProto::_Internal {
 public:
};

ExpectNavigationProto::ExpectNavigationProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.ExpectNavigationProto)
}
ExpectNavigationProto::ExpectNavigationProto(const ExpectNavigationProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.ExpectNavigationProto)
}

inline void ExpectNavigationProto::SharedCtor() {
}

ExpectNavigationProto::~ExpectNavigationProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.ExpectNavigationProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ExpectNavigationProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ExpectNavigationProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ExpectNavigationProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.ExpectNavigationProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_metadata_.Clear<std::string>();
}

const char* ExpectNavigationProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ExpectNavigationProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.ExpectNavigationProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.ExpectNavigationProto)
  return target;
}

size_t ExpectNavigationProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.ExpectNavigationProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ExpectNavigationProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ExpectNavigationProto*>(
      &from));
}

void ExpectNavigationProto::MergeFrom(const ExpectNavigationProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.ExpectNavigationProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ExpectNavigationProto::CopyFrom(const ExpectNavigationProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.ExpectNavigationProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ExpectNavigationProto::IsInitialized() const {
  return true;
}

void ExpectNavigationProto::InternalSwap(ExpectNavigationProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
}

std::string ExpectNavigationProto::GetTypeName() const {
  return "autofill_assistant.ExpectNavigationProto";
}


// ===================================================================

class WaitForNavigationProto::_Internal {
 public:
  using HasBits = decltype(std::declval<WaitForNavigationProto>()._has_bits_);
  static void set_has_timeout_ms(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

WaitForNavigationProto::WaitForNavigationProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.WaitForNavigationProto)
}
WaitForNavigationProto::WaitForNavigationProto(const WaitForNavigationProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  timeout_ms_ = from.timeout_ms_;
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.WaitForNavigationProto)
}

inline void WaitForNavigationProto::SharedCtor() {
timeout_ms_ = 0;
}

WaitForNavigationProto::~WaitForNavigationProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.WaitForNavigationProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void WaitForNavigationProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void WaitForNavigationProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void WaitForNavigationProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.WaitForNavigationProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  timeout_ms_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* WaitForNavigationProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 timeout_ms = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_timeout_ms(&has_bits);
          timeout_ms_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* WaitForNavigationProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.WaitForNavigationProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 timeout_ms = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_timeout_ms(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.WaitForNavigationProto)
  return target;
}

size_t WaitForNavigationProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.WaitForNavigationProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional int32 timeout_ms = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_timeout_ms());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void WaitForNavigationProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const WaitForNavigationProto*>(
      &from));
}

void WaitForNavigationProto::MergeFrom(const WaitForNavigationProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.WaitForNavigationProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_timeout_ms()) {
    _internal_set_timeout_ms(from._internal_timeout_ms());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void WaitForNavigationProto::CopyFrom(const WaitForNavigationProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.WaitForNavigationProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool WaitForNavigationProto::IsInitialized() const {
  return true;
}

void WaitForNavigationProto::InternalSwap(WaitForNavigationProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(timeout_ms_, other->timeout_ms_);
}

std::string WaitForNavigationProto::GetTypeName() const {
  return "autofill_assistant.WaitForNavigationProto";
}


// ===================================================================

class WaitForDocumentProto_Result::_Internal {
 public:
  using HasBits = decltype(std::declval<WaitForDocumentProto_Result>()._has_bits_);
  static void set_has_start_ready_state(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_end_ready_state(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

WaitForDocumentProto_Result::WaitForDocumentProto_Result(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.WaitForDocumentProto.Result)
}
WaitForDocumentProto_Result::WaitForDocumentProto_Result(const WaitForDocumentProto_Result& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&start_ready_state_, &from.start_ready_state_,
    static_cast<size_t>(reinterpret_cast<char*>(&end_ready_state_) -
    reinterpret_cast<char*>(&start_ready_state_)) + sizeof(end_ready_state_));
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.WaitForDocumentProto.Result)
}

inline void WaitForDocumentProto_Result::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&start_ready_state_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&end_ready_state_) -
    reinterpret_cast<char*>(&start_ready_state_)) + sizeof(end_ready_state_));
}

WaitForDocumentProto_Result::~WaitForDocumentProto_Result() {
  // @@protoc_insertion_point(destructor:autofill_assistant.WaitForDocumentProto.Result)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void WaitForDocumentProto_Result::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void WaitForDocumentProto_Result::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void WaitForDocumentProto_Result::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.WaitForDocumentProto.Result)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&start_ready_state_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&end_ready_state_) -
        reinterpret_cast<char*>(&start_ready_state_)) + sizeof(end_ready_state_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* WaitForDocumentProto_Result::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .autofill_assistant.DocumentReadyState start_ready_state = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::autofill_assistant::DocumentReadyState_IsValid(val))) {
            _internal_set_start_ready_state(static_cast<::autofill_assistant::DocumentReadyState>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .autofill_assistant.DocumentReadyState end_ready_state = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::autofill_assistant::DocumentReadyState_IsValid(val))) {
            _internal_set_end_ready_state(static_cast<::autofill_assistant::DocumentReadyState>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* WaitForDocumentProto_Result::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.WaitForDocumentProto.Result)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .autofill_assistant.DocumentReadyState start_ready_state = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_start_ready_state(), target);
  }

  // optional .autofill_assistant.DocumentReadyState end_ready_state = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_end_ready_state(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.WaitForDocumentProto.Result)
  return target;
}

size_t WaitForDocumentProto_Result::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.WaitForDocumentProto.Result)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .autofill_assistant.DocumentReadyState start_ready_state = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_start_ready_state());
    }

    // optional .autofill_assistant.DocumentReadyState end_ready_state = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_end_ready_state());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void WaitForDocumentProto_Result::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const WaitForDocumentProto_Result*>(
      &from));
}

void WaitForDocumentProto_Result::MergeFrom(const WaitForDocumentProto_Result& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.WaitForDocumentProto.Result)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      start_ready_state_ = from.start_ready_state_;
    }
    if (cached_has_bits & 0x00000002u) {
      end_ready_state_ = from.end_ready_state_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void WaitForDocumentProto_Result::CopyFrom(const WaitForDocumentProto_Result& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.WaitForDocumentProto.Result)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool WaitForDocumentProto_Result::IsInitialized() const {
  return true;
}

void WaitForDocumentProto_Result::InternalSwap(WaitForDocumentProto_Result* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(WaitForDocumentProto_Result, end_ready_state_)
      + sizeof(WaitForDocumentProto_Result::end_ready_state_)
      - PROTOBUF_FIELD_OFFSET(WaitForDocumentProto_Result, start_ready_state_)>(
          reinterpret_cast<char*>(&start_ready_state_),
          reinterpret_cast<char*>(&other->start_ready_state_));
}

std::string WaitForDocumentProto_Result::GetTypeName() const {
  return "autofill_assistant.WaitForDocumentProto.Result";
}


// ===================================================================

class WaitForDocumentProto::_Internal {
 public:
  using HasBits = decltype(std::declval<WaitForDocumentProto>()._has_bits_);
  static void set_has_timeout_ms(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::autofill_assistant::SelectorProto& frame(const WaitForDocumentProto* msg);
  static void set_has_frame(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_min_ready_state(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::autofill_assistant::SelectorProto&
WaitForDocumentProto::_Internal::frame(const WaitForDocumentProto* msg) {
  return *msg->frame_;
}
WaitForDocumentProto::WaitForDocumentProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.WaitForDocumentProto)
}
WaitForDocumentProto::WaitForDocumentProto(const WaitForDocumentProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_frame()) {
    frame_ = new ::autofill_assistant::SelectorProto(*from.frame_);
  } else {
    frame_ = nullptr;
  }
  ::memcpy(&timeout_ms_, &from.timeout_ms_,
    static_cast<size_t>(reinterpret_cast<char*>(&min_ready_state_) -
    reinterpret_cast<char*>(&timeout_ms_)) + sizeof(min_ready_state_));
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.WaitForDocumentProto)
}

inline void WaitForDocumentProto::SharedCtor() {
frame_ = nullptr;
timeout_ms_ = 5000;
min_ready_state_ = 4;
}

WaitForDocumentProto::~WaitForDocumentProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.WaitForDocumentProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void WaitForDocumentProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete frame_;
}

void WaitForDocumentProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void WaitForDocumentProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.WaitForDocumentProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(frame_ != nullptr);
      frame_->Clear();
    }
    timeout_ms_ = 5000;
    min_ready_state_ = 4;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* WaitForDocumentProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 timeout_ms = 1 [default = 5000];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_timeout_ms(&has_bits);
          timeout_ms_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .autofill_assistant.SelectorProto frame = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_frame(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .autofill_assistant.DocumentReadyState min_ready_state = 3 [default = DOCUMENT_INTERACTIVE];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::autofill_assistant::DocumentReadyState_IsValid(val))) {
            _internal_set_min_ready_state(static_cast<::autofill_assistant::DocumentReadyState>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* WaitForDocumentProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.WaitForDocumentProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 timeout_ms = 1 [default = 5000];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_timeout_ms(), target);
  }

  // optional .autofill_assistant.SelectorProto frame = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::frame(this),
        _Internal::frame(this).GetCachedSize(), target, stream);
  }

  // optional .autofill_assistant.DocumentReadyState min_ready_state = 3 [default = DOCUMENT_INTERACTIVE];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_min_ready_state(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.WaitForDocumentProto)
  return target;
}

size_t WaitForDocumentProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.WaitForDocumentProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .autofill_assistant.SelectorProto frame = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *frame_);
    }

    // optional int32 timeout_ms = 1 [default = 5000];
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_timeout_ms());
    }

    // optional .autofill_assistant.DocumentReadyState min_ready_state = 3 [default = DOCUMENT_INTERACTIVE];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_min_ready_state());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void WaitForDocumentProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const WaitForDocumentProto*>(
      &from));
}

void WaitForDocumentProto::MergeFrom(const WaitForDocumentProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.WaitForDocumentProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_frame()->::autofill_assistant::SelectorProto::MergeFrom(from._internal_frame());
    }
    if (cached_has_bits & 0x00000002u) {
      timeout_ms_ = from.timeout_ms_;
    }
    if (cached_has_bits & 0x00000004u) {
      min_ready_state_ = from.min_ready_state_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void WaitForDocumentProto::CopyFrom(const WaitForDocumentProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.WaitForDocumentProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool WaitForDocumentProto::IsInitialized() const {
  return true;
}

void WaitForDocumentProto::InternalSwap(WaitForDocumentProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(frame_, other->frame_);
  swap(timeout_ms_, other->timeout_ms_);
  swap(min_ready_state_, other->min_ready_state_);
}

std::string WaitForDocumentProto::GetTypeName() const {
  return "autofill_assistant.WaitForDocumentProto";
}


// ===================================================================

class ShowGenericUiProto_RequestUserData_AdditionalValue::_Internal {
 public:
  using HasBits = decltype(std::declval<ShowGenericUiProto_RequestUserData_AdditionalValue>()._has_bits_);
  static void set_has_source_identifier(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_model_identifier(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

ShowGenericUiProto_RequestUserData_AdditionalValue::ShowGenericUiProto_RequestUserData_AdditionalValue(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.ShowGenericUiProto.RequestUserData.AdditionalValue)
}
ShowGenericUiProto_RequestUserData_AdditionalValue::ShowGenericUiProto_RequestUserData_AdditionalValue(const ShowGenericUiProto_RequestUserData_AdditionalValue& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  source_identifier_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    source_identifier_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_source_identifier()) {
    source_identifier_.Set(from._internal_source_identifier(), 
      GetArenaForAllocation());
  }
  model_identifier_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    model_identifier_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_model_identifier()) {
    model_identifier_.Set(from._internal_model_identifier(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.ShowGenericUiProto.RequestUserData.AdditionalValue)
}

inline void ShowGenericUiProto_RequestUserData_AdditionalValue::SharedCtor() {
source_identifier_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  source_identifier_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
model_identifier_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  model_identifier_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ShowGenericUiProto_RequestUserData_AdditionalValue::~ShowGenericUiProto_RequestUserData_AdditionalValue() {
  // @@protoc_insertion_point(destructor:autofill_assistant.ShowGenericUiProto.RequestUserData.AdditionalValue)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ShowGenericUiProto_RequestUserData_AdditionalValue::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  source_identifier_.Destroy();
  model_identifier_.Destroy();
}

void ShowGenericUiProto_RequestUserData_AdditionalValue::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ShowGenericUiProto_RequestUserData_AdditionalValue::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.ShowGenericUiProto.RequestUserData.AdditionalValue)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      source_identifier_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      model_identifier_.ClearNonDefaultToEmpty();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ShowGenericUiProto_RequestUserData_AdditionalValue::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string source_identifier = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_source_identifier();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string model_identifier = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_model_identifier();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ShowGenericUiProto_RequestUserData_AdditionalValue::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.ShowGenericUiProto.RequestUserData.AdditionalValue)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string source_identifier = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_source_identifier(), target);
  }

  // optional string model_identifier = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_model_identifier(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.ShowGenericUiProto.RequestUserData.AdditionalValue)
  return target;
}

size_t ShowGenericUiProto_RequestUserData_AdditionalValue::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.ShowGenericUiProto.RequestUserData.AdditionalValue)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string source_identifier = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_source_identifier());
    }

    // optional string model_identifier = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_model_identifier());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ShowGenericUiProto_RequestUserData_AdditionalValue::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ShowGenericUiProto_RequestUserData_AdditionalValue*>(
      &from));
}

void ShowGenericUiProto_RequestUserData_AdditionalValue::MergeFrom(const ShowGenericUiProto_RequestUserData_AdditionalValue& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.ShowGenericUiProto.RequestUserData.AdditionalValue)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_source_identifier(from._internal_source_identifier());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_model_identifier(from._internal_model_identifier());
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ShowGenericUiProto_RequestUserData_AdditionalValue::CopyFrom(const ShowGenericUiProto_RequestUserData_AdditionalValue& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.ShowGenericUiProto.RequestUserData.AdditionalValue)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ShowGenericUiProto_RequestUserData_AdditionalValue::IsInitialized() const {
  return true;
}

void ShowGenericUiProto_RequestUserData_AdditionalValue::InternalSwap(ShowGenericUiProto_RequestUserData_AdditionalValue* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &source_identifier_, lhs_arena,
      &other->source_identifier_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &model_identifier_, lhs_arena,
      &other->model_identifier_, rhs_arena
  );
}

std::string ShowGenericUiProto_RequestUserData_AdditionalValue::GetTypeName() const {
  return "autofill_assistant.ShowGenericUiProto.RequestUserData.AdditionalValue";
}


// ===================================================================

class ShowGenericUiProto_RequestUserData::_Internal {
 public:
};

ShowGenericUiProto_RequestUserData::ShowGenericUiProto_RequestUserData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  additional_values_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.ShowGenericUiProto.RequestUserData)
}
ShowGenericUiProto_RequestUserData::ShowGenericUiProto_RequestUserData(const ShowGenericUiProto_RequestUserData& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      additional_values_(from.additional_values_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.ShowGenericUiProto.RequestUserData)
}

inline void ShowGenericUiProto_RequestUserData::SharedCtor() {
}

ShowGenericUiProto_RequestUserData::~ShowGenericUiProto_RequestUserData() {
  // @@protoc_insertion_point(destructor:autofill_assistant.ShowGenericUiProto.RequestUserData)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ShowGenericUiProto_RequestUserData::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ShowGenericUiProto_RequestUserData::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ShowGenericUiProto_RequestUserData::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.ShowGenericUiProto.RequestUserData)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  additional_values_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ShowGenericUiProto_RequestUserData::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .autofill_assistant.ShowGenericUiProto.RequestUserData.AdditionalValue additional_values = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_additional_values(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ShowGenericUiProto_RequestUserData::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.ShowGenericUiProto.RequestUserData)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .autofill_assistant.ShowGenericUiProto.RequestUserData.AdditionalValue additional_values = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_additional_values_size()); i < n; i++) {
    const auto& repfield = this->_internal_additional_values(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.ShowGenericUiProto.RequestUserData)
  return target;
}

size_t ShowGenericUiProto_RequestUserData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.ShowGenericUiProto.RequestUserData)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .autofill_assistant.ShowGenericUiProto.RequestUserData.AdditionalValue additional_values = 1;
  total_size += 1UL * this->_internal_additional_values_size();
  for (const auto& msg : this->additional_values_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ShowGenericUiProto_RequestUserData::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ShowGenericUiProto_RequestUserData*>(
      &from));
}

void ShowGenericUiProto_RequestUserData::MergeFrom(const ShowGenericUiProto_RequestUserData& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.ShowGenericUiProto.RequestUserData)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  additional_values_.MergeFrom(from.additional_values_);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ShowGenericUiProto_RequestUserData::CopyFrom(const ShowGenericUiProto_RequestUserData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.ShowGenericUiProto.RequestUserData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ShowGenericUiProto_RequestUserData::IsInitialized() const {
  return true;
}

void ShowGenericUiProto_RequestUserData::InternalSwap(ShowGenericUiProto_RequestUserData* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  additional_values_.InternalSwap(&other->additional_values_);
}

std::string ShowGenericUiProto_RequestUserData::GetTypeName() const {
  return "autofill_assistant.ShowGenericUiProto.RequestUserData";
}


// ===================================================================

class ShowGenericUiProto_Result::_Internal {
 public:
  using HasBits = decltype(std::declval<ShowGenericUiProto_Result>()._has_bits_);
  static const ::autofill_assistant::ModelProto& model(const ShowGenericUiProto_Result* msg);
  static void set_has_model(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_navigation_ended(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::autofill_assistant::ModelProto&
ShowGenericUiProto_Result::_Internal::model(const ShowGenericUiProto_Result* msg) {
  return *msg->model_;
}
void ShowGenericUiProto_Result::clear_model() {
  if (model_ != nullptr) model_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
ShowGenericUiProto_Result::ShowGenericUiProto_Result(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.ShowGenericUiProto.Result)
}
ShowGenericUiProto_Result::ShowGenericUiProto_Result(const ShowGenericUiProto_Result& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_model()) {
    model_ = new ::autofill_assistant::ModelProto(*from.model_);
  } else {
    model_ = nullptr;
  }
  navigation_ended_ = from.navigation_ended_;
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.ShowGenericUiProto.Result)
}

inline void ShowGenericUiProto_Result::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&model_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&navigation_ended_) -
    reinterpret_cast<char*>(&model_)) + sizeof(navigation_ended_));
}

ShowGenericUiProto_Result::~ShowGenericUiProto_Result() {
  // @@protoc_insertion_point(destructor:autofill_assistant.ShowGenericUiProto.Result)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ShowGenericUiProto_Result::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete model_;
}

void ShowGenericUiProto_Result::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ShowGenericUiProto_Result::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.ShowGenericUiProto.Result)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(model_ != nullptr);
    model_->Clear();
  }
  navigation_ended_ = false;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ShowGenericUiProto_Result::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .autofill_assistant.ModelProto model = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_model(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool navigation_ended = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_navigation_ended(&has_bits);
          navigation_ended_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ShowGenericUiProto_Result::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.ShowGenericUiProto.Result)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .autofill_assistant.ModelProto model = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::model(this),
        _Internal::model(this).GetCachedSize(), target, stream);
  }

  // optional bool navigation_ended = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_navigation_ended(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.ShowGenericUiProto.Result)
  return target;
}

size_t ShowGenericUiProto_Result::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.ShowGenericUiProto.Result)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .autofill_assistant.ModelProto model = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *model_);
    }

    // optional bool navigation_ended = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ShowGenericUiProto_Result::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ShowGenericUiProto_Result*>(
      &from));
}

void ShowGenericUiProto_Result::MergeFrom(const ShowGenericUiProto_Result& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.ShowGenericUiProto.Result)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_model()->::autofill_assistant::ModelProto::MergeFrom(from._internal_model());
    }
    if (cached_has_bits & 0x00000002u) {
      navigation_ended_ = from.navigation_ended_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ShowGenericUiProto_Result::CopyFrom(const ShowGenericUiProto_Result& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.ShowGenericUiProto.Result)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ShowGenericUiProto_Result::IsInitialized() const {
  return true;
}

void ShowGenericUiProto_Result::InternalSwap(ShowGenericUiProto_Result* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ShowGenericUiProto_Result, navigation_ended_)
      + sizeof(ShowGenericUiProto_Result::navigation_ended_)
      - PROTOBUF_FIELD_OFFSET(ShowGenericUiProto_Result, model_)>(
          reinterpret_cast<char*>(&model_),
          reinterpret_cast<char*>(&other->model_));
}

std::string ShowGenericUiProto_Result::GetTypeName() const {
  return "autofill_assistant.ShowGenericUiProto.Result";
}


// ===================================================================

class ShowGenericUiProto_PeriodicElementChecks_ElementCheck::_Internal {
 public:
  using HasBits = decltype(std::declval<ShowGenericUiProto_PeriodicElementChecks_ElementCheck>()._has_bits_);
  static const ::autofill_assistant::ElementConditionProto& element_condition(const ShowGenericUiProto_PeriodicElementChecks_ElementCheck* msg);
  static void set_has_element_condition(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_model_identifier(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::autofill_assistant::ElementConditionProto&
ShowGenericUiProto_PeriodicElementChecks_ElementCheck::_Internal::element_condition(const ShowGenericUiProto_PeriodicElementChecks_ElementCheck* msg) {
  return *msg->element_condition_;
}
ShowGenericUiProto_PeriodicElementChecks_ElementCheck::ShowGenericUiProto_PeriodicElementChecks_ElementCheck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.ShowGenericUiProto.PeriodicElementChecks.ElementCheck)
}
ShowGenericUiProto_PeriodicElementChecks_ElementCheck::ShowGenericUiProto_PeriodicElementChecks_ElementCheck(const ShowGenericUiProto_PeriodicElementChecks_ElementCheck& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  model_identifier_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    model_identifier_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_model_identifier()) {
    model_identifier_.Set(from._internal_model_identifier(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_element_condition()) {
    element_condition_ = new ::autofill_assistant::ElementConditionProto(*from.element_condition_);
  } else {
    element_condition_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.ShowGenericUiProto.PeriodicElementChecks.ElementCheck)
}

inline void ShowGenericUiProto_PeriodicElementChecks_ElementCheck::SharedCtor() {
model_identifier_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  model_identifier_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
element_condition_ = nullptr;
}

ShowGenericUiProto_PeriodicElementChecks_ElementCheck::~ShowGenericUiProto_PeriodicElementChecks_ElementCheck() {
  // @@protoc_insertion_point(destructor:autofill_assistant.ShowGenericUiProto.PeriodicElementChecks.ElementCheck)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ShowGenericUiProto_PeriodicElementChecks_ElementCheck::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  model_identifier_.Destroy();
  if (this != internal_default_instance()) delete element_condition_;
}

void ShowGenericUiProto_PeriodicElementChecks_ElementCheck::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ShowGenericUiProto_PeriodicElementChecks_ElementCheck::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.ShowGenericUiProto.PeriodicElementChecks.ElementCheck)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      model_identifier_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(element_condition_ != nullptr);
      element_condition_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ShowGenericUiProto_PeriodicElementChecks_ElementCheck::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .autofill_assistant.ElementConditionProto element_condition = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_element_condition(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string model_identifier = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_model_identifier();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ShowGenericUiProto_PeriodicElementChecks_ElementCheck::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.ShowGenericUiProto.PeriodicElementChecks.ElementCheck)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .autofill_assistant.ElementConditionProto element_condition = 1;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::element_condition(this),
        _Internal::element_condition(this).GetCachedSize(), target, stream);
  }

  // optional string model_identifier = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_model_identifier(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.ShowGenericUiProto.PeriodicElementChecks.ElementCheck)
  return target;
}

size_t ShowGenericUiProto_PeriodicElementChecks_ElementCheck::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.ShowGenericUiProto.PeriodicElementChecks.ElementCheck)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string model_identifier = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_model_identifier());
    }

    // optional .autofill_assistant.ElementConditionProto element_condition = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *element_condition_);
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ShowGenericUiProto_PeriodicElementChecks_ElementCheck::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ShowGenericUiProto_PeriodicElementChecks_ElementCheck*>(
      &from));
}

void ShowGenericUiProto_PeriodicElementChecks_ElementCheck::MergeFrom(const ShowGenericUiProto_PeriodicElementChecks_ElementCheck& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.ShowGenericUiProto.PeriodicElementChecks.ElementCheck)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_model_identifier(from._internal_model_identifier());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_element_condition()->::autofill_assistant::ElementConditionProto::MergeFrom(from._internal_element_condition());
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ShowGenericUiProto_PeriodicElementChecks_ElementCheck::CopyFrom(const ShowGenericUiProto_PeriodicElementChecks_ElementCheck& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.ShowGenericUiProto.PeriodicElementChecks.ElementCheck)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ShowGenericUiProto_PeriodicElementChecks_ElementCheck::IsInitialized() const {
  return true;
}

void ShowGenericUiProto_PeriodicElementChecks_ElementCheck::InternalSwap(ShowGenericUiProto_PeriodicElementChecks_ElementCheck* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &model_identifier_, lhs_arena,
      &other->model_identifier_, rhs_arena
  );
  swap(element_condition_, other->element_condition_);
}

std::string ShowGenericUiProto_PeriodicElementChecks_ElementCheck::GetTypeName() const {
  return "autofill_assistant.ShowGenericUiProto.PeriodicElementChecks.ElementCheck";
}


// ===================================================================

class ShowGenericUiProto_PeriodicElementChecks::_Internal {
 public:
};

ShowGenericUiProto_PeriodicElementChecks::ShowGenericUiProto_PeriodicElementChecks(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  element_checks_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.ShowGenericUiProto.PeriodicElementChecks)
}
ShowGenericUiProto_PeriodicElementChecks::ShowGenericUiProto_PeriodicElementChecks(const ShowGenericUiProto_PeriodicElementChecks& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      element_checks_(from.element_checks_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.ShowGenericUiProto.PeriodicElementChecks)
}

inline void ShowGenericUiProto_PeriodicElementChecks::SharedCtor() {
}

ShowGenericUiProto_PeriodicElementChecks::~ShowGenericUiProto_PeriodicElementChecks() {
  // @@protoc_insertion_point(destructor:autofill_assistant.ShowGenericUiProto.PeriodicElementChecks)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ShowGenericUiProto_PeriodicElementChecks::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ShowGenericUiProto_PeriodicElementChecks::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ShowGenericUiProto_PeriodicElementChecks::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.ShowGenericUiProto.PeriodicElementChecks)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  element_checks_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ShowGenericUiProto_PeriodicElementChecks::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .autofill_assistant.ShowGenericUiProto.PeriodicElementChecks.ElementCheck element_checks = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_element_checks(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ShowGenericUiProto_PeriodicElementChecks::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.ShowGenericUiProto.PeriodicElementChecks)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .autofill_assistant.ShowGenericUiProto.PeriodicElementChecks.ElementCheck element_checks = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_element_checks_size()); i < n; i++) {
    const auto& repfield = this->_internal_element_checks(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.ShowGenericUiProto.PeriodicElementChecks)
  return target;
}

size_t ShowGenericUiProto_PeriodicElementChecks::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.ShowGenericUiProto.PeriodicElementChecks)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .autofill_assistant.ShowGenericUiProto.PeriodicElementChecks.ElementCheck element_checks = 1;
  total_size += 1UL * this->_internal_element_checks_size();
  for (const auto& msg : this->element_checks_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ShowGenericUiProto_PeriodicElementChecks::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ShowGenericUiProto_PeriodicElementChecks*>(
      &from));
}

void ShowGenericUiProto_PeriodicElementChecks::MergeFrom(const ShowGenericUiProto_PeriodicElementChecks& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.ShowGenericUiProto.PeriodicElementChecks)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  element_checks_.MergeFrom(from.element_checks_);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ShowGenericUiProto_PeriodicElementChecks::CopyFrom(const ShowGenericUiProto_PeriodicElementChecks& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.ShowGenericUiProto.PeriodicElementChecks)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ShowGenericUiProto_PeriodicElementChecks::IsInitialized() const {
  return true;
}

void ShowGenericUiProto_PeriodicElementChecks::InternalSwap(ShowGenericUiProto_PeriodicElementChecks* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  element_checks_.InternalSwap(&other->element_checks_);
}

std::string ShowGenericUiProto_PeriodicElementChecks::GetTypeName() const {
  return "autofill_assistant.ShowGenericUiProto.PeriodicElementChecks";
}


// ===================================================================

class ShowGenericUiProto::_Internal {
 public:
  using HasBits = decltype(std::declval<ShowGenericUiProto>()._has_bits_);
  static const ::autofill_assistant::GenericUserInterfaceProto& generic_user_interface(const ShowGenericUiProto* msg);
  static void set_has_generic_user_interface(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::autofill_assistant::ShowGenericUiProto_PeriodicElementChecks& periodic_element_checks(const ShowGenericUiProto* msg);
  static void set_has_periodic_element_checks(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_end_on_navigation(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_allow_interrupt(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::autofill_assistant::ShowGenericUiProto_RequestUserData& request_user_data(const ShowGenericUiProto* msg);
  static void set_has_request_user_data(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::autofill_assistant::GenericUserInterfaceProto&
ShowGenericUiProto::_Internal::generic_user_interface(const ShowGenericUiProto* msg) {
  return *msg->generic_user_interface_;
}
const ::autofill_assistant::ShowGenericUiProto_PeriodicElementChecks&
ShowGenericUiProto::_Internal::periodic_element_checks(const ShowGenericUiProto* msg) {
  return *msg->periodic_element_checks_;
}
const ::autofill_assistant::ShowGenericUiProto_RequestUserData&
ShowGenericUiProto::_Internal::request_user_data(const ShowGenericUiProto* msg) {
  return *msg->request_user_data_;
}
void ShowGenericUiProto::clear_generic_user_interface() {
  if (generic_user_interface_ != nullptr) generic_user_interface_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
ShowGenericUiProto::ShowGenericUiProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  output_model_identifiers_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.ShowGenericUiProto)
}
ShowGenericUiProto::ShowGenericUiProto(const ShowGenericUiProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      output_model_identifiers_(from.output_model_identifiers_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_generic_user_interface()) {
    generic_user_interface_ = new ::autofill_assistant::GenericUserInterfaceProto(*from.generic_user_interface_);
  } else {
    generic_user_interface_ = nullptr;
  }
  if (from._internal_has_periodic_element_checks()) {
    periodic_element_checks_ = new ::autofill_assistant::ShowGenericUiProto_PeriodicElementChecks(*from.periodic_element_checks_);
  } else {
    periodic_element_checks_ = nullptr;
  }
  if (from._internal_has_request_user_data()) {
    request_user_data_ = new ::autofill_assistant::ShowGenericUiProto_RequestUserData(*from.request_user_data_);
  } else {
    request_user_data_ = nullptr;
  }
  ::memcpy(&end_on_navigation_, &from.end_on_navigation_,
    static_cast<size_t>(reinterpret_cast<char*>(&allow_interrupt_) -
    reinterpret_cast<char*>(&end_on_navigation_)) + sizeof(allow_interrupt_));
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.ShowGenericUiProto)
}

inline void ShowGenericUiProto::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&generic_user_interface_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&allow_interrupt_) -
    reinterpret_cast<char*>(&generic_user_interface_)) + sizeof(allow_interrupt_));
}

ShowGenericUiProto::~ShowGenericUiProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.ShowGenericUiProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ShowGenericUiProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete generic_user_interface_;
  if (this != internal_default_instance()) delete periodic_element_checks_;
  if (this != internal_default_instance()) delete request_user_data_;
}

void ShowGenericUiProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ShowGenericUiProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.ShowGenericUiProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  output_model_identifiers_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(generic_user_interface_ != nullptr);
      generic_user_interface_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(periodic_element_checks_ != nullptr);
      periodic_element_checks_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(request_user_data_ != nullptr);
      request_user_data_->Clear();
    }
  }
  ::memset(&end_on_navigation_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&allow_interrupt_) -
      reinterpret_cast<char*>(&end_on_navigation_)) + sizeof(allow_interrupt_));
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ShowGenericUiProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .autofill_assistant.GenericUserInterfaceProto generic_user_interface = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_generic_user_interface(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated string output_model_identifiers = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_output_model_identifiers();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .autofill_assistant.ShowGenericUiProto.PeriodicElementChecks periodic_element_checks = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_periodic_element_checks(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool end_on_navigation = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_end_on_navigation(&has_bits);
          end_on_navigation_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool allow_interrupt = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_allow_interrupt(&has_bits);
          allow_interrupt_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .autofill_assistant.ShowGenericUiProto.RequestUserData request_user_data = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_request_user_data(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ShowGenericUiProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.ShowGenericUiProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .autofill_assistant.GenericUserInterfaceProto generic_user_interface = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::generic_user_interface(this),
        _Internal::generic_user_interface(this).GetCachedSize(), target, stream);
  }

  // repeated string output_model_identifiers = 2;
  for (int i = 0, n = this->_internal_output_model_identifiers_size(); i < n; i++) {
    const auto& s = this->_internal_output_model_identifiers(i);
    target = stream->WriteString(2, s, target);
  }

  // optional .autofill_assistant.ShowGenericUiProto.PeriodicElementChecks periodic_element_checks = 6;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::periodic_element_checks(this),
        _Internal::periodic_element_checks(this).GetCachedSize(), target, stream);
  }

  // optional bool end_on_navigation = 7;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(7, this->_internal_end_on_navigation(), target);
  }

  // optional bool allow_interrupt = 8;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(8, this->_internal_allow_interrupt(), target);
  }

  // optional .autofill_assistant.ShowGenericUiProto.RequestUserData request_user_data = 9;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(9, _Internal::request_user_data(this),
        _Internal::request_user_data(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.ShowGenericUiProto)
  return target;
}

size_t ShowGenericUiProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.ShowGenericUiProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string output_model_identifiers = 2;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(output_model_identifiers_.size());
  for (int i = 0, n = output_model_identifiers_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      output_model_identifiers_.Get(i));
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional .autofill_assistant.GenericUserInterfaceProto generic_user_interface = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *generic_user_interface_);
    }

    // optional .autofill_assistant.ShowGenericUiProto.PeriodicElementChecks periodic_element_checks = 6;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *periodic_element_checks_);
    }

    // optional .autofill_assistant.ShowGenericUiProto.RequestUserData request_user_data = 9;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *request_user_data_);
    }

    // optional bool end_on_navigation = 7;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

    // optional bool allow_interrupt = 8;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 1;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ShowGenericUiProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ShowGenericUiProto*>(
      &from));
}

void ShowGenericUiProto::MergeFrom(const ShowGenericUiProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.ShowGenericUiProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  output_model_identifiers_.MergeFrom(from.output_model_identifiers_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_generic_user_interface()->::autofill_assistant::GenericUserInterfaceProto::MergeFrom(from._internal_generic_user_interface());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_periodic_element_checks()->::autofill_assistant::ShowGenericUiProto_PeriodicElementChecks::MergeFrom(from._internal_periodic_element_checks());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_request_user_data()->::autofill_assistant::ShowGenericUiProto_RequestUserData::MergeFrom(from._internal_request_user_data());
    }
    if (cached_has_bits & 0x00000008u) {
      end_on_navigation_ = from.end_on_navigation_;
    }
    if (cached_has_bits & 0x00000010u) {
      allow_interrupt_ = from.allow_interrupt_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ShowGenericUiProto::CopyFrom(const ShowGenericUiProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.ShowGenericUiProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ShowGenericUiProto::IsInitialized() const {
  return true;
}

void ShowGenericUiProto::InternalSwap(ShowGenericUiProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  output_model_identifiers_.InternalSwap(&other->output_model_identifiers_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ShowGenericUiProto, allow_interrupt_)
      + sizeof(ShowGenericUiProto::allow_interrupt_)
      - PROTOBUF_FIELD_OFFSET(ShowGenericUiProto, generic_user_interface_)>(
          reinterpret_cast<char*>(&generic_user_interface_),
          reinterpret_cast<char*>(&other->generic_user_interface_));
}

std::string ShowGenericUiProto::GetTypeName() const {
  return "autofill_assistant.ShowGenericUiProto";
}


// ===================================================================

class SetPersistentUiProto::_Internal {
 public:
  using HasBits = decltype(std::declval<SetPersistentUiProto>()._has_bits_);
  static const ::autofill_assistant::GenericUserInterfaceProto& generic_user_interface(const SetPersistentUiProto* msg);
  static void set_has_generic_user_interface(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::autofill_assistant::GenericUserInterfaceProto&
SetPersistentUiProto::_Internal::generic_user_interface(const SetPersistentUiProto* msg) {
  return *msg->generic_user_interface_;
}
void SetPersistentUiProto::clear_generic_user_interface() {
  if (generic_user_interface_ != nullptr) generic_user_interface_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
SetPersistentUiProto::SetPersistentUiProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.SetPersistentUiProto)
}
SetPersistentUiProto::SetPersistentUiProto(const SetPersistentUiProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_generic_user_interface()) {
    generic_user_interface_ = new ::autofill_assistant::GenericUserInterfaceProto(*from.generic_user_interface_);
  } else {
    generic_user_interface_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.SetPersistentUiProto)
}

inline void SetPersistentUiProto::SharedCtor() {
generic_user_interface_ = nullptr;
}

SetPersistentUiProto::~SetPersistentUiProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.SetPersistentUiProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SetPersistentUiProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete generic_user_interface_;
}

void SetPersistentUiProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SetPersistentUiProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.SetPersistentUiProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(generic_user_interface_ != nullptr);
    generic_user_interface_->Clear();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* SetPersistentUiProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .autofill_assistant.GenericUserInterfaceProto generic_user_interface = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_generic_user_interface(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SetPersistentUiProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.SetPersistentUiProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .autofill_assistant.GenericUserInterfaceProto generic_user_interface = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::generic_user_interface(this),
        _Internal::generic_user_interface(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.SetPersistentUiProto)
  return target;
}

size_t SetPersistentUiProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.SetPersistentUiProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .autofill_assistant.GenericUserInterfaceProto generic_user_interface = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *generic_user_interface_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SetPersistentUiProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const SetPersistentUiProto*>(
      &from));
}

void SetPersistentUiProto::MergeFrom(const SetPersistentUiProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.SetPersistentUiProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_generic_user_interface()) {
    _internal_mutable_generic_user_interface()->::autofill_assistant::GenericUserInterfaceProto::MergeFrom(from._internal_generic_user_interface());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SetPersistentUiProto::CopyFrom(const SetPersistentUiProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.SetPersistentUiProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SetPersistentUiProto::IsInitialized() const {
  return true;
}

void SetPersistentUiProto::InternalSwap(SetPersistentUiProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(generic_user_interface_, other->generic_user_interface_);
}

std::string SetPersistentUiProto::GetTypeName() const {
  return "autofill_assistant.SetPersistentUiProto";
}


// ===================================================================

class ClearPersistentUiProto::_Internal {
 public:
};

ClearPersistentUiProto::ClearPersistentUiProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.ClearPersistentUiProto)
}
ClearPersistentUiProto::ClearPersistentUiProto(const ClearPersistentUiProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.ClearPersistentUiProto)
}

inline void ClearPersistentUiProto::SharedCtor() {
}

ClearPersistentUiProto::~ClearPersistentUiProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.ClearPersistentUiProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ClearPersistentUiProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ClearPersistentUiProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ClearPersistentUiProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.ClearPersistentUiProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_metadata_.Clear<std::string>();
}

const char* ClearPersistentUiProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ClearPersistentUiProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.ClearPersistentUiProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.ClearPersistentUiProto)
  return target;
}

size_t ClearPersistentUiProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.ClearPersistentUiProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ClearPersistentUiProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ClearPersistentUiProto*>(
      &from));
}

void ClearPersistentUiProto::MergeFrom(const ClearPersistentUiProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.ClearPersistentUiProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClearPersistentUiProto::CopyFrom(const ClearPersistentUiProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.ClearPersistentUiProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClearPersistentUiProto::IsInitialized() const {
  return true;
}

void ClearPersistentUiProto::InternalSwap(ClearPersistentUiProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
}

std::string ClearPersistentUiProto::GetTypeName() const {
  return "autofill_assistant.ClearPersistentUiProto";
}


// ===================================================================

class PromptProto_Choice::_Internal {
 public:
  using HasBits = decltype(std::declval<PromptProto_Choice>()._has_bits_);
  static const ::autofill_assistant::ChipProto& chip(const PromptProto_Choice* msg);
  static void set_has_chip(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::autofill_assistant::ElementConditionProto& auto_select_when(const PromptProto_Choice* msg);
  static void set_has_auto_select_when(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::autofill_assistant::ElementConditionProto& show_only_when(const PromptProto_Choice* msg);
  static void set_has_show_only_when(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_allow_disabling(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_server_payload(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_tag(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::autofill_assistant::ChipProto&
PromptProto_Choice::_Internal::chip(const PromptProto_Choice* msg) {
  return *msg->chip_;
}
const ::autofill_assistant::ElementConditionProto&
PromptProto_Choice::_Internal::auto_select_when(const PromptProto_Choice* msg) {
  return *msg->auto_select_when_;
}
const ::autofill_assistant::ElementConditionProto&
PromptProto_Choice::_Internal::show_only_when(const PromptProto_Choice* msg) {
  return *msg->show_only_when_;
}
void PromptProto_Choice::clear_chip() {
  if (chip_ != nullptr) chip_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
PromptProto_Choice::PromptProto_Choice(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.PromptProto.Choice)
}
PromptProto_Choice::PromptProto_Choice(const PromptProto_Choice& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  server_payload_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    server_payload_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_server_payload()) {
    server_payload_.Set(from._internal_server_payload(), 
      GetArenaForAllocation());
  }
  tag_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    tag_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_tag()) {
    tag_.Set(from._internal_tag(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_chip()) {
    chip_ = new ::autofill_assistant::ChipProto(*from.chip_);
  } else {
    chip_ = nullptr;
  }
  if (from._internal_has_auto_select_when()) {
    auto_select_when_ = new ::autofill_assistant::ElementConditionProto(*from.auto_select_when_);
  } else {
    auto_select_when_ = nullptr;
  }
  if (from._internal_has_show_only_when()) {
    show_only_when_ = new ::autofill_assistant::ElementConditionProto(*from.show_only_when_);
  } else {
    show_only_when_ = nullptr;
  }
  allow_disabling_ = from.allow_disabling_;
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.PromptProto.Choice)
}

inline void PromptProto_Choice::SharedCtor() {
server_payload_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  server_payload_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
tag_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  tag_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&chip_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&allow_disabling_) -
    reinterpret_cast<char*>(&chip_)) + sizeof(allow_disabling_));
}

PromptProto_Choice::~PromptProto_Choice() {
  // @@protoc_insertion_point(destructor:autofill_assistant.PromptProto.Choice)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PromptProto_Choice::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  server_payload_.Destroy();
  tag_.Destroy();
  if (this != internal_default_instance()) delete chip_;
  if (this != internal_default_instance()) delete auto_select_when_;
  if (this != internal_default_instance()) delete show_only_when_;
}

void PromptProto_Choice::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void PromptProto_Choice::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.PromptProto.Choice)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      server_payload_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      tag_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(chip_ != nullptr);
      chip_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(auto_select_when_ != nullptr);
      auto_select_when_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(show_only_when_ != nullptr);
      show_only_when_->Clear();
    }
  }
  allow_disabling_ = false;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* PromptProto_Choice::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes server_payload = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_server_payload();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool allow_disabling = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_allow_disabling(&has_bits);
          allow_disabling_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .autofill_assistant.ChipProto chip = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_chip(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .autofill_assistant.ElementConditionProto auto_select_when = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 122)) {
          ptr = ctx->ParseMessage(_internal_mutable_auto_select_when(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .autofill_assistant.ElementConditionProto show_only_when = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 130)) {
          ptr = ctx->ParseMessage(_internal_mutable_show_only_when(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string tag = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 146)) {
          auto str = _internal_mutable_tag();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PromptProto_Choice::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.PromptProto.Choice)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bytes server_payload = 5;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        5, this->_internal_server_payload(), target);
  }

  // optional bool allow_disabling = 9;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(9, this->_internal_allow_disabling(), target);
  }

  // optional .autofill_assistant.ChipProto chip = 11;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(11, _Internal::chip(this),
        _Internal::chip(this).GetCachedSize(), target, stream);
  }

  // optional .autofill_assistant.ElementConditionProto auto_select_when = 15;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(15, _Internal::auto_select_when(this),
        _Internal::auto_select_when(this).GetCachedSize(), target, stream);
  }

  // optional .autofill_assistant.ElementConditionProto show_only_when = 16;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(16, _Internal::show_only_when(this),
        _Internal::show_only_when(this).GetCachedSize(), target, stream);
  }

  // optional string tag = 18;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        18, this->_internal_tag(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.PromptProto.Choice)
  return target;
}

size_t PromptProto_Choice::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.PromptProto.Choice)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional bytes server_payload = 5;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_server_payload());
    }

    // optional string tag = 18;
    if (cached_has_bits & 0x00000002u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_tag());
    }

    // optional .autofill_assistant.ChipProto chip = 11;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *chip_);
    }

    // optional .autofill_assistant.ElementConditionProto auto_select_when = 15;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *auto_select_when_);
    }

    // optional .autofill_assistant.ElementConditionProto show_only_when = 16;
    if (cached_has_bits & 0x00000010u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *show_only_when_);
    }

    // optional bool allow_disabling = 9;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 1;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void PromptProto_Choice::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const PromptProto_Choice*>(
      &from));
}

void PromptProto_Choice::MergeFrom(const PromptProto_Choice& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.PromptProto.Choice)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_server_payload(from._internal_server_payload());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_tag(from._internal_tag());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_chip()->::autofill_assistant::ChipProto::MergeFrom(from._internal_chip());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_mutable_auto_select_when()->::autofill_assistant::ElementConditionProto::MergeFrom(from._internal_auto_select_when());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_mutable_show_only_when()->::autofill_assistant::ElementConditionProto::MergeFrom(from._internal_show_only_when());
    }
    if (cached_has_bits & 0x00000020u) {
      allow_disabling_ = from.allow_disabling_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void PromptProto_Choice::CopyFrom(const PromptProto_Choice& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.PromptProto.Choice)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PromptProto_Choice::IsInitialized() const {
  return true;
}

void PromptProto_Choice::InternalSwap(PromptProto_Choice* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &server_payload_, lhs_arena,
      &other->server_payload_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &tag_, lhs_arena,
      &other->tag_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PromptProto_Choice, allow_disabling_)
      + sizeof(PromptProto_Choice::allow_disabling_)
      - PROTOBUF_FIELD_OFFSET(PromptProto_Choice, chip_)>(
          reinterpret_cast<char*>(&chip_),
          reinterpret_cast<char*>(&other->chip_));
}

std::string PromptProto_Choice::GetTypeName() const {
  return "autofill_assistant.PromptProto.Choice";
}


// ===================================================================

class PromptProto_Result::_Internal {
 public:
  using HasBits = decltype(std::declval<PromptProto_Result>()._has_bits_);
  static void set_has_navigation_ended(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_server_payload(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_choice_tag(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

PromptProto_Result::PromptProto_Result(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.PromptProto.Result)
}
PromptProto_Result::PromptProto_Result(const PromptProto_Result& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  server_payload_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    server_payload_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_server_payload()) {
    server_payload_.Set(from._internal_server_payload(), 
      GetArenaForAllocation());
  }
  choice_tag_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    choice_tag_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_choice_tag()) {
    choice_tag_.Set(from._internal_choice_tag(), 
      GetArenaForAllocation());
  }
  navigation_ended_ = from.navigation_ended_;
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.PromptProto.Result)
}

inline void PromptProto_Result::SharedCtor() {
server_payload_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  server_payload_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
choice_tag_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  choice_tag_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
navigation_ended_ = false;
}

PromptProto_Result::~PromptProto_Result() {
  // @@protoc_insertion_point(destructor:autofill_assistant.PromptProto.Result)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PromptProto_Result::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  server_payload_.Destroy();
  choice_tag_.Destroy();
}

void PromptProto_Result::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void PromptProto_Result::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.PromptProto.Result)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      server_payload_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      choice_tag_.ClearNonDefaultToEmpty();
    }
  }
  navigation_ended_ = false;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* PromptProto_Result::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool navigation_ended = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_navigation_ended(&has_bits);
          navigation_ended_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes server_payload = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_server_payload();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string choice_tag = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_choice_tag();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PromptProto_Result::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.PromptProto.Result)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bool navigation_ended = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_navigation_ended(), target);
  }

  // optional bytes server_payload = 5;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        5, this->_internal_server_payload(), target);
  }

  // optional string choice_tag = 6;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_choice_tag(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.PromptProto.Result)
  return target;
}

size_t PromptProto_Result::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.PromptProto.Result)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional bytes server_payload = 5;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_server_payload());
    }

    // optional string choice_tag = 6;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_choice_tag());
    }

    // optional bool navigation_ended = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void PromptProto_Result::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const PromptProto_Result*>(
      &from));
}

void PromptProto_Result::MergeFrom(const PromptProto_Result& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.PromptProto.Result)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_server_payload(from._internal_server_payload());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_choice_tag(from._internal_choice_tag());
    }
    if (cached_has_bits & 0x00000004u) {
      navigation_ended_ = from.navigation_ended_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void PromptProto_Result::CopyFrom(const PromptProto_Result& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.PromptProto.Result)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PromptProto_Result::IsInitialized() const {
  return true;
}

void PromptProto_Result::InternalSwap(PromptProto_Result* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &server_payload_, lhs_arena,
      &other->server_payload_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &choice_tag_, lhs_arena,
      &other->choice_tag_, rhs_arena
  );
  swap(navigation_ended_, other->navigation_ended_);
}

std::string PromptProto_Result::GetTypeName() const {
  return "autofill_assistant.PromptProto.Result";
}


// ===================================================================

class PromptProto::_Internal {
 public:
  using HasBits = decltype(std::declval<PromptProto>()._has_bits_);
  static void set_has_message(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_allow_interrupt(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_disable_force_expand_sheet(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_browse_mode(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_browse_mode_invisible(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_end_on_navigation(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

PromptProto::PromptProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  choices_(arena),
  browse_domains_allowlist_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.PromptProto)
}
PromptProto::PromptProto(const PromptProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      choices_(from.choices_),
      browse_domains_allowlist_(from.browse_domains_allowlist_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  message_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    message_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_message()) {
    message_.Set(from._internal_message(), 
      GetArenaForAllocation());
  }
  ::memcpy(&allow_interrupt_, &from.allow_interrupt_,
    static_cast<size_t>(reinterpret_cast<char*>(&end_on_navigation_) -
    reinterpret_cast<char*>(&allow_interrupt_)) + sizeof(end_on_navigation_));
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.PromptProto)
}

inline void PromptProto::SharedCtor() {
message_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  message_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&allow_interrupt_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&end_on_navigation_) -
    reinterpret_cast<char*>(&allow_interrupt_)) + sizeof(end_on_navigation_));
}

PromptProto::~PromptProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.PromptProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PromptProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  message_.Destroy();
}

void PromptProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void PromptProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.PromptProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  choices_.Clear();
  browse_domains_allowlist_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    message_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000003eu) {
    ::memset(&allow_interrupt_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&end_on_navigation_) -
        reinterpret_cast<char*>(&allow_interrupt_)) + sizeof(end_on_navigation_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* PromptProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string message = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_message();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .autofill_assistant.PromptProto.Choice choices = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_choices(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional bool allow_interrupt = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_allow_interrupt(&has_bits);
          allow_interrupt_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool disable_force_expand_sheet = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_disable_force_expand_sheet(&has_bits);
          disable_force_expand_sheet_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool browse_mode = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_browse_mode(&has_bits);
          browse_mode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool end_on_navigation = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_end_on_navigation(&has_bits);
          end_on_navigation_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated string browse_domains_allowlist = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_browse_domains_allowlist();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<74>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional bool browse_mode_invisible = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_browse_mode_invisible(&has_bits);
          browse_mode_invisible_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PromptProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.PromptProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string message = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_message(), target);
  }

  // repeated .autofill_assistant.PromptProto.Choice choices = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_choices_size()); i < n; i++) {
    const auto& repfield = this->_internal_choices(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional bool allow_interrupt = 5;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_allow_interrupt(), target);
  }

  // optional bool disable_force_expand_sheet = 6;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(6, this->_internal_disable_force_expand_sheet(), target);
  }

  // optional bool browse_mode = 7;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(7, this->_internal_browse_mode(), target);
  }

  // optional bool end_on_navigation = 8;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(8, this->_internal_end_on_navigation(), target);
  }

  // repeated string browse_domains_allowlist = 9;
  for (int i = 0, n = this->_internal_browse_domains_allowlist_size(); i < n; i++) {
    const auto& s = this->_internal_browse_domains_allowlist(i);
    target = stream->WriteString(9, s, target);
  }

  // optional bool browse_mode_invisible = 10;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(10, this->_internal_browse_mode_invisible(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.PromptProto)
  return target;
}

size_t PromptProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.PromptProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .autofill_assistant.PromptProto.Choice choices = 4;
  total_size += 1UL * this->_internal_choices_size();
  for (const auto& msg : this->choices_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated string browse_domains_allowlist = 9;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(browse_domains_allowlist_.size());
  for (int i = 0, n = browse_domains_allowlist_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      browse_domains_allowlist_.Get(i));
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional string message = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_message());
    }

    // optional bool allow_interrupt = 5;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

    // optional bool disable_force_expand_sheet = 6;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

    // optional bool browse_mode = 7;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

    // optional bool browse_mode_invisible = 10;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 1;
    }

    // optional bool end_on_navigation = 8;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 1;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void PromptProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const PromptProto*>(
      &from));
}

void PromptProto::MergeFrom(const PromptProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.PromptProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  choices_.MergeFrom(from.choices_);
  browse_domains_allowlist_.MergeFrom(from.browse_domains_allowlist_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_message(from._internal_message());
    }
    if (cached_has_bits & 0x00000002u) {
      allow_interrupt_ = from.allow_interrupt_;
    }
    if (cached_has_bits & 0x00000004u) {
      disable_force_expand_sheet_ = from.disable_force_expand_sheet_;
    }
    if (cached_has_bits & 0x00000008u) {
      browse_mode_ = from.browse_mode_;
    }
    if (cached_has_bits & 0x00000010u) {
      browse_mode_invisible_ = from.browse_mode_invisible_;
    }
    if (cached_has_bits & 0x00000020u) {
      end_on_navigation_ = from.end_on_navigation_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void PromptProto::CopyFrom(const PromptProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.PromptProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PromptProto::IsInitialized() const {
  return true;
}

void PromptProto::InternalSwap(PromptProto* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  choices_.InternalSwap(&other->choices_);
  browse_domains_allowlist_.InternalSwap(&other->browse_domains_allowlist_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &message_, lhs_arena,
      &other->message_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PromptProto, end_on_navigation_)
      + sizeof(PromptProto::end_on_navigation_)
      - PROTOBUF_FIELD_OFFSET(PromptProto, allow_interrupt_)>(
          reinterpret_cast<char*>(&allow_interrupt_),
          reinterpret_cast<char*>(&other->allow_interrupt_));
}

std::string PromptProto::GetTypeName() const {
  return "autofill_assistant.PromptProto";
}


// ===================================================================

class ContactDetailsProto::_Internal {
 public:
  using HasBits = decltype(std::declval<ContactDetailsProto>()._has_bits_);
  static void set_has_contact_details_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_request_payer_name(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_request_payer_email(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_request_payer_phone(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_max_number_summary_lines(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_max_number_full_lines(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_contact_details_section_title(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_separate_phone_number_section(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_phone_number_section_title(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

void ContactDetailsProto::clear_required_data_piece() {
  required_data_piece_.Clear();
}
void ContactDetailsProto::clear_phone_number_required_data_piece() {
  phone_number_required_data_piece_.Clear();
}
ContactDetailsProto::ContactDetailsProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  summary_fields_(arena),
  full_fields_(arena),
  required_data_piece_(arena),
  phone_number_required_data_piece_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.ContactDetailsProto)
}
ContactDetailsProto::ContactDetailsProto(const ContactDetailsProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      summary_fields_(from.summary_fields_),
      full_fields_(from.full_fields_),
      required_data_piece_(from.required_data_piece_),
      phone_number_required_data_piece_(from.phone_number_required_data_piece_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  contact_details_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    contact_details_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_contact_details_name()) {
    contact_details_name_.Set(from._internal_contact_details_name(), 
      GetArenaForAllocation());
  }
  contact_details_section_title_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    contact_details_section_title_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_contact_details_section_title()) {
    contact_details_section_title_.Set(from._internal_contact_details_section_title(), 
      GetArenaForAllocation());
  }
  phone_number_section_title_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    phone_number_section_title_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_phone_number_section_title()) {
    phone_number_section_title_.Set(from._internal_phone_number_section_title(), 
      GetArenaForAllocation());
  }
  ::memcpy(&request_payer_name_, &from.request_payer_name_,
    static_cast<size_t>(reinterpret_cast<char*>(&max_number_full_lines_) -
    reinterpret_cast<char*>(&request_payer_name_)) + sizeof(max_number_full_lines_));
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.ContactDetailsProto)
}

inline void ContactDetailsProto::SharedCtor() {
contact_details_name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  contact_details_name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
contact_details_section_title_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  contact_details_section_title_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
phone_number_section_title_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  phone_number_section_title_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&request_payer_name_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&max_number_full_lines_) -
    reinterpret_cast<char*>(&request_payer_name_)) + sizeof(max_number_full_lines_));
}

ContactDetailsProto::~ContactDetailsProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.ContactDetailsProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ContactDetailsProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  contact_details_name_.Destroy();
  contact_details_section_title_.Destroy();
  phone_number_section_title_.Destroy();
}

void ContactDetailsProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ContactDetailsProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.ContactDetailsProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  summary_fields_.Clear();
  full_fields_.Clear();
  required_data_piece_.Clear();
  phone_number_required_data_piece_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      contact_details_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      contact_details_section_title_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      phone_number_section_title_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x000000f8u) {
    ::memset(&request_payer_name_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&max_number_summary_lines_) -
        reinterpret_cast<char*>(&request_payer_name_)) + sizeof(max_number_summary_lines_));
  }
  max_number_full_lines_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ContactDetailsProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string contact_details_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_contact_details_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool request_payer_name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_request_payer_name(&has_bits);
          request_payer_name_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool request_payer_email = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_request_payer_email(&has_bits);
          request_payer_email_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool request_payer_phone = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_request_payer_phone(&has_bits);
          request_payer_phone_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .autofill_assistant.ContactDetailsProto.AutofillContactField summary_fields = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          ptr -= 1;
          do {
            ptr += 1;
            uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
            CHK_(ptr);
            if (PROTOBUF_PREDICT_TRUE(::autofill_assistant::ContactDetailsProto_AutofillContactField_IsValid(val))) {
              _internal_add_summary_fields(static_cast<::autofill_assistant::ContactDetailsProto_AutofillContactField>(val));
            } else {
              ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(5, val, mutable_unknown_fields());
            }
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<40>(ptr));
        } else if (static_cast<uint8_t>(tag) == 42) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedEnumParser<std::string>(_internal_mutable_summary_fields(), ptr, ctx, ::autofill_assistant::ContactDetailsProto_AutofillContactField_IsValid, &_internal_metadata_, 5);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 max_number_summary_lines = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_max_number_summary_lines(&has_bits);
          max_number_summary_lines_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .autofill_assistant.ContactDetailsProto.AutofillContactField full_fields = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          ptr -= 1;
          do {
            ptr += 1;
            uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
            CHK_(ptr);
            if (PROTOBUF_PREDICT_TRUE(::autofill_assistant::ContactDetailsProto_AutofillContactField_IsValid(val))) {
              _internal_add_full_fields(static_cast<::autofill_assistant::ContactDetailsProto_AutofillContactField>(val));
            } else {
              ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(7, val, mutable_unknown_fields());
            }
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<56>(ptr));
        } else if (static_cast<uint8_t>(tag) == 58) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedEnumParser<std::string>(_internal_mutable_full_fields(), ptr, ctx, ::autofill_assistant::ContactDetailsProto_AutofillContactField_IsValid, &_internal_metadata_, 7);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 max_number_full_lines = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_max_number_full_lines(&has_bits);
          max_number_full_lines_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string contact_details_section_title = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          auto str = _internal_mutable_contact_details_section_title();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .autofill_assistant.RequiredDataPiece required_data_piece = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_required_data_piece(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<82>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional bool separate_phone_number_section = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_separate_phone_number_section(&has_bits);
          separate_phone_number_section_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string phone_number_section_title = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          auto str = _internal_mutable_phone_number_section_title();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .autofill_assistant.RequiredDataPiece phone_number_required_data_piece = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_phone_number_required_data_piece(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<106>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ContactDetailsProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.ContactDetailsProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string contact_details_name = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_contact_details_name(), target);
  }

  // optional bool request_payer_name = 2;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_request_payer_name(), target);
  }

  // optional bool request_payer_email = 3;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_request_payer_email(), target);
  }

  // optional bool request_payer_phone = 4;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_request_payer_phone(), target);
  }

  // repeated .autofill_assistant.ContactDetailsProto.AutofillContactField summary_fields = 5;
  for (int i = 0, n = this->_internal_summary_fields_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        5, this->_internal_summary_fields(i), target);
  }

  // optional int32 max_number_summary_lines = 6;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(6, this->_internal_max_number_summary_lines(), target);
  }

  // repeated .autofill_assistant.ContactDetailsProto.AutofillContactField full_fields = 7;
  for (int i = 0, n = this->_internal_full_fields_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        7, this->_internal_full_fields(i), target);
  }

  // optional int32 max_number_full_lines = 8;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(8, this->_internal_max_number_full_lines(), target);
  }

  // optional string contact_details_section_title = 9;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        9, this->_internal_contact_details_section_title(), target);
  }

  // repeated .autofill_assistant.RequiredDataPiece required_data_piece = 10;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_required_data_piece_size()); i < n; i++) {
    const auto& repfield = this->_internal_required_data_piece(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(10, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional bool separate_phone_number_section = 11;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(11, this->_internal_separate_phone_number_section(), target);
  }

  // optional string phone_number_section_title = 12;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteStringMaybeAliased(
        12, this->_internal_phone_number_section_title(), target);
  }

  // repeated .autofill_assistant.RequiredDataPiece phone_number_required_data_piece = 13;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_phone_number_required_data_piece_size()); i < n; i++) {
    const auto& repfield = this->_internal_phone_number_required_data_piece(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(13, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.ContactDetailsProto)
  return target;
}

size_t ContactDetailsProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.ContactDetailsProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .autofill_assistant.ContactDetailsProto.AutofillContactField summary_fields = 5;
  {
    size_t data_size = 0;
    unsigned int count = static_cast<unsigned int>(this->_internal_summary_fields_size());for (unsigned int i = 0; i < count; i++) {
      data_size += ::_pbi::WireFormatLite::EnumSize(
        this->_internal_summary_fields(static_cast<int>(i)));
    }
    total_size += (1UL * count) + data_size;
  }

  // repeated .autofill_assistant.ContactDetailsProto.AutofillContactField full_fields = 7;
  {
    size_t data_size = 0;
    unsigned int count = static_cast<unsigned int>(this->_internal_full_fields_size());for (unsigned int i = 0; i < count; i++) {
      data_size += ::_pbi::WireFormatLite::EnumSize(
        this->_internal_full_fields(static_cast<int>(i)));
    }
    total_size += (1UL * count) + data_size;
  }

  // repeated .autofill_assistant.RequiredDataPiece required_data_piece = 10;
  total_size += 1UL * this->_internal_required_data_piece_size();
  for (const auto& msg : this->required_data_piece_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .autofill_assistant.RequiredDataPiece phone_number_required_data_piece = 13;
  total_size += 1UL * this->_internal_phone_number_required_data_piece_size();
  for (const auto& msg : this->phone_number_required_data_piece_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string contact_details_name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_contact_details_name());
    }

    // optional string contact_details_section_title = 9;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_contact_details_section_title());
    }

    // optional string phone_number_section_title = 12;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_phone_number_section_title());
    }

    // optional bool request_payer_name = 2;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

    // optional bool request_payer_email = 3;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 1;
    }

    // optional bool request_payer_phone = 4;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 1;
    }

    // optional bool separate_phone_number_section = 11;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 1;
    }

    // optional int32 max_number_summary_lines = 6;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_max_number_summary_lines());
    }

  }
  // optional int32 max_number_full_lines = 8;
  if (cached_has_bits & 0x00000100u) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_max_number_full_lines());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ContactDetailsProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ContactDetailsProto*>(
      &from));
}

void ContactDetailsProto::MergeFrom(const ContactDetailsProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.ContactDetailsProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  summary_fields_.MergeFrom(from.summary_fields_);
  full_fields_.MergeFrom(from.full_fields_);
  required_data_piece_.MergeFrom(from.required_data_piece_);
  phone_number_required_data_piece_.MergeFrom(from.phone_number_required_data_piece_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_contact_details_name(from._internal_contact_details_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_contact_details_section_title(from._internal_contact_details_section_title());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_phone_number_section_title(from._internal_phone_number_section_title());
    }
    if (cached_has_bits & 0x00000008u) {
      request_payer_name_ = from.request_payer_name_;
    }
    if (cached_has_bits & 0x00000010u) {
      request_payer_email_ = from.request_payer_email_;
    }
    if (cached_has_bits & 0x00000020u) {
      request_payer_phone_ = from.request_payer_phone_;
    }
    if (cached_has_bits & 0x00000040u) {
      separate_phone_number_section_ = from.separate_phone_number_section_;
    }
    if (cached_has_bits & 0x00000080u) {
      max_number_summary_lines_ = from.max_number_summary_lines_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000100u) {
    _internal_set_max_number_full_lines(from._internal_max_number_full_lines());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ContactDetailsProto::CopyFrom(const ContactDetailsProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.ContactDetailsProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ContactDetailsProto::IsInitialized() const {
  return true;
}

void ContactDetailsProto::InternalSwap(ContactDetailsProto* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  summary_fields_.InternalSwap(&other->summary_fields_);
  full_fields_.InternalSwap(&other->full_fields_);
  required_data_piece_.InternalSwap(&other->required_data_piece_);
  phone_number_required_data_piece_.InternalSwap(&other->phone_number_required_data_piece_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &contact_details_name_, lhs_arena,
      &other->contact_details_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &contact_details_section_title_, lhs_arena,
      &other->contact_details_section_title_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &phone_number_section_title_, lhs_arena,
      &other->phone_number_section_title_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ContactDetailsProto, max_number_full_lines_)
      + sizeof(ContactDetailsProto::max_number_full_lines_)
      - PROTOBUF_FIELD_OFFSET(ContactDetailsProto, request_payer_name_)>(
          reinterpret_cast<char*>(&request_payer_name_),
          reinterpret_cast<char*>(&other->request_payer_name_));
}

std::string ContactDetailsProto::GetTypeName() const {
  return "autofill_assistant.ContactDetailsProto";
}


// ===================================================================

class LoginDetailsProto_LoginOptionCustomProto::_Internal {
 public:
  using HasBits = decltype(std::declval<LoginDetailsProto_LoginOptionCustomProto>()._has_bits_);
  static void set_has_label(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

LoginDetailsProto_LoginOptionCustomProto::LoginDetailsProto_LoginOptionCustomProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.LoginDetailsProto.LoginOptionCustomProto)
}
LoginDetailsProto_LoginOptionCustomProto::LoginDetailsProto_LoginOptionCustomProto(const LoginDetailsProto_LoginOptionCustomProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  label_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    label_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_label()) {
    label_.Set(from._internal_label(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.LoginDetailsProto.LoginOptionCustomProto)
}

inline void LoginDetailsProto_LoginOptionCustomProto::SharedCtor() {
label_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  label_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

LoginDetailsProto_LoginOptionCustomProto::~LoginDetailsProto_LoginOptionCustomProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.LoginDetailsProto.LoginOptionCustomProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LoginDetailsProto_LoginOptionCustomProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  label_.Destroy();
}

void LoginDetailsProto_LoginOptionCustomProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void LoginDetailsProto_LoginOptionCustomProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.LoginDetailsProto.LoginOptionCustomProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    label_.ClearNonDefaultToEmpty();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* LoginDetailsProto_LoginOptionCustomProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string label = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_label();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LoginDetailsProto_LoginOptionCustomProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.LoginDetailsProto.LoginOptionCustomProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string label = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_label(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.LoginDetailsProto.LoginOptionCustomProto)
  return target;
}

size_t LoginDetailsProto_LoginOptionCustomProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.LoginDetailsProto.LoginOptionCustomProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string label = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_label());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void LoginDetailsProto_LoginOptionCustomProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const LoginDetailsProto_LoginOptionCustomProto*>(
      &from));
}

void LoginDetailsProto_LoginOptionCustomProto::MergeFrom(const LoginDetailsProto_LoginOptionCustomProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.LoginDetailsProto.LoginOptionCustomProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_label()) {
    _internal_set_label(from._internal_label());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void LoginDetailsProto_LoginOptionCustomProto::CopyFrom(const LoginDetailsProto_LoginOptionCustomProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.LoginDetailsProto.LoginOptionCustomProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LoginDetailsProto_LoginOptionCustomProto::IsInitialized() const {
  return true;
}

void LoginDetailsProto_LoginOptionCustomProto::InternalSwap(LoginDetailsProto_LoginOptionCustomProto* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &label_, lhs_arena,
      &other->label_, rhs_arena
  );
}

std::string LoginDetailsProto_LoginOptionCustomProto::GetTypeName() const {
  return "autofill_assistant.LoginDetailsProto.LoginOptionCustomProto";
}


// ===================================================================

class LoginDetailsProto_LoginOptionPasswordManagerProto::_Internal {
 public:
};

LoginDetailsProto_LoginOptionPasswordManagerProto::LoginDetailsProto_LoginOptionPasswordManagerProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.LoginDetailsProto.LoginOptionPasswordManagerProto)
}
LoginDetailsProto_LoginOptionPasswordManagerProto::LoginDetailsProto_LoginOptionPasswordManagerProto(const LoginDetailsProto_LoginOptionPasswordManagerProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.LoginDetailsProto.LoginOptionPasswordManagerProto)
}

inline void LoginDetailsProto_LoginOptionPasswordManagerProto::SharedCtor() {
}

LoginDetailsProto_LoginOptionPasswordManagerProto::~LoginDetailsProto_LoginOptionPasswordManagerProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.LoginDetailsProto.LoginOptionPasswordManagerProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LoginDetailsProto_LoginOptionPasswordManagerProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void LoginDetailsProto_LoginOptionPasswordManagerProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void LoginDetailsProto_LoginOptionPasswordManagerProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.LoginDetailsProto.LoginOptionPasswordManagerProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_metadata_.Clear<std::string>();
}

const char* LoginDetailsProto_LoginOptionPasswordManagerProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LoginDetailsProto_LoginOptionPasswordManagerProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.LoginDetailsProto.LoginOptionPasswordManagerProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.LoginDetailsProto.LoginOptionPasswordManagerProto)
  return target;
}

size_t LoginDetailsProto_LoginOptionPasswordManagerProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.LoginDetailsProto.LoginOptionPasswordManagerProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void LoginDetailsProto_LoginOptionPasswordManagerProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const LoginDetailsProto_LoginOptionPasswordManagerProto*>(
      &from));
}

void LoginDetailsProto_LoginOptionPasswordManagerProto::MergeFrom(const LoginDetailsProto_LoginOptionPasswordManagerProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.LoginDetailsProto.LoginOptionPasswordManagerProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void LoginDetailsProto_LoginOptionPasswordManagerProto::CopyFrom(const LoginDetailsProto_LoginOptionPasswordManagerProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.LoginDetailsProto.LoginOptionPasswordManagerProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LoginDetailsProto_LoginOptionPasswordManagerProto::IsInitialized() const {
  return true;
}

void LoginDetailsProto_LoginOptionPasswordManagerProto::InternalSwap(LoginDetailsProto_LoginOptionPasswordManagerProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
}

std::string LoginDetailsProto_LoginOptionPasswordManagerProto::GetTypeName() const {
  return "autofill_assistant.LoginDetailsProto.LoginOptionPasswordManagerProto";
}


// ===================================================================

class LoginDetailsProto_LoginOptionProto::_Internal {
 public:
  using HasBits = decltype(std::declval<LoginDetailsProto_LoginOptionProto>()._has_bits_);
  static const ::autofill_assistant::InfoPopupProto& info_popup(const LoginDetailsProto_LoginOptionProto* msg);
  static void set_has_info_popup(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_sublabel(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_sublabel_accessibility_hint(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_edit_button_content_description(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_choose_automatically_if_no_stored_login(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_preselection_priority(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static const ::autofill_assistant::LoginDetailsProto_LoginOptionCustomProto& custom(const LoginDetailsProto_LoginOptionProto* msg);
  static const ::autofill_assistant::LoginDetailsProto_LoginOptionPasswordManagerProto& password_manager(const LoginDetailsProto_LoginOptionProto* msg);
};

const ::autofill_assistant::InfoPopupProto&
LoginDetailsProto_LoginOptionProto::_Internal::info_popup(const LoginDetailsProto_LoginOptionProto* msg) {
  return *msg->info_popup_;
}
const ::autofill_assistant::LoginDetailsProto_LoginOptionCustomProto&
LoginDetailsProto_LoginOptionProto::_Internal::custom(const LoginDetailsProto_LoginOptionProto* msg) {
  return *msg->type_.custom_;
}
const ::autofill_assistant::LoginDetailsProto_LoginOptionPasswordManagerProto&
LoginDetailsProto_LoginOptionProto::_Internal::password_manager(const LoginDetailsProto_LoginOptionProto* msg) {
  return *msg->type_.password_manager_;
}
void LoginDetailsProto_LoginOptionProto::clear_info_popup() {
  if (info_popup_ != nullptr) info_popup_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
void LoginDetailsProto_LoginOptionProto::set_allocated_custom(::autofill_assistant::LoginDetailsProto_LoginOptionCustomProto* custom) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_type();
  if (custom) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(custom);
    if (message_arena != submessage_arena) {
      custom = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, custom, submessage_arena);
    }
    set_has_custom();
    type_.custom_ = custom;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.LoginDetailsProto.LoginOptionProto.custom)
}
void LoginDetailsProto_LoginOptionProto::set_allocated_password_manager(::autofill_assistant::LoginDetailsProto_LoginOptionPasswordManagerProto* password_manager) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_type();
  if (password_manager) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(password_manager);
    if (message_arena != submessage_arena) {
      password_manager = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, password_manager, submessage_arena);
    }
    set_has_password_manager();
    type_.password_manager_ = password_manager;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.LoginDetailsProto.LoginOptionProto.password_manager)
}
LoginDetailsProto_LoginOptionProto::LoginDetailsProto_LoginOptionProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.LoginDetailsProto.LoginOptionProto)
}
LoginDetailsProto_LoginOptionProto::LoginDetailsProto_LoginOptionProto(const LoginDetailsProto_LoginOptionProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  sublabel_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    sublabel_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_sublabel()) {
    sublabel_.Set(from._internal_sublabel(), 
      GetArenaForAllocation());
  }
  sublabel_accessibility_hint_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    sublabel_accessibility_hint_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_sublabel_accessibility_hint()) {
    sublabel_accessibility_hint_.Set(from._internal_sublabel_accessibility_hint(), 
      GetArenaForAllocation());
  }
  edit_button_content_description_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    edit_button_content_description_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_edit_button_content_description()) {
    edit_button_content_description_.Set(from._internal_edit_button_content_description(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_info_popup()) {
    info_popup_ = new ::autofill_assistant::InfoPopupProto(*from.info_popup_);
  } else {
    info_popup_ = nullptr;
  }
  ::memcpy(&choose_automatically_if_no_stored_login_, &from.choose_automatically_if_no_stored_login_,
    static_cast<size_t>(reinterpret_cast<char*>(&preselection_priority_) -
    reinterpret_cast<char*>(&choose_automatically_if_no_stored_login_)) + sizeof(preselection_priority_));
  clear_has_payload_or_tag();
  switch (from.payload_or_tag_case()) {
    case kPayload: {
      _internal_set_payload(from._internal_payload());
      break;
    }
    case kTag: {
      _internal_set_tag(from._internal_tag());
      break;
    }
    case PAYLOAD_OR_TAG_NOT_SET: {
      break;
    }
  }
  clear_has_type();
  switch (from.type_case()) {
    case kCustom: {
      _internal_mutable_custom()->::autofill_assistant::LoginDetailsProto_LoginOptionCustomProto::MergeFrom(from._internal_custom());
      break;
    }
    case kPasswordManager: {
      _internal_mutable_password_manager()->::autofill_assistant::LoginDetailsProto_LoginOptionPasswordManagerProto::MergeFrom(from._internal_password_manager());
      break;
    }
    case TYPE_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.LoginDetailsProto.LoginOptionProto)
}

inline void LoginDetailsProto_LoginOptionProto::SharedCtor() {
sublabel_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  sublabel_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
sublabel_accessibility_hint_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  sublabel_accessibility_hint_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
edit_button_content_description_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  edit_button_content_description_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&info_popup_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&preselection_priority_) -
    reinterpret_cast<char*>(&info_popup_)) + sizeof(preselection_priority_));
clear_has_payload_or_tag();
clear_has_type();
}

LoginDetailsProto_LoginOptionProto::~LoginDetailsProto_LoginOptionProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.LoginDetailsProto.LoginOptionProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LoginDetailsProto_LoginOptionProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  sublabel_.Destroy();
  sublabel_accessibility_hint_.Destroy();
  edit_button_content_description_.Destroy();
  if (this != internal_default_instance()) delete info_popup_;
  if (has_payload_or_tag()) {
    clear_payload_or_tag();
  }
  if (has_type()) {
    clear_type();
  }
}

void LoginDetailsProto_LoginOptionProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void LoginDetailsProto_LoginOptionProto::clear_payload_or_tag() {
// @@protoc_insertion_point(one_of_clear_start:autofill_assistant.LoginDetailsProto.LoginOptionProto)
  switch (payload_or_tag_case()) {
    case kPayload: {
      payload_or_tag_.payload_.Destroy();
      break;
    }
    case kTag: {
      payload_or_tag_.tag_.Destroy();
      break;
    }
    case PAYLOAD_OR_TAG_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = PAYLOAD_OR_TAG_NOT_SET;
}

void LoginDetailsProto_LoginOptionProto::clear_type() {
// @@protoc_insertion_point(one_of_clear_start:autofill_assistant.LoginDetailsProto.LoginOptionProto)
  switch (type_case()) {
    case kCustom: {
      if (GetArenaForAllocation() == nullptr) {
        delete type_.custom_;
      }
      break;
    }
    case kPasswordManager: {
      if (GetArenaForAllocation() == nullptr) {
        delete type_.password_manager_;
      }
      break;
    }
    case TYPE_NOT_SET: {
      break;
    }
  }
  _oneof_case_[1] = TYPE_NOT_SET;
}


void LoginDetailsProto_LoginOptionProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.LoginDetailsProto.LoginOptionProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      sublabel_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      sublabel_accessibility_hint_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      edit_button_content_description_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(info_popup_ != nullptr);
      info_popup_->Clear();
    }
  }
  if (cached_has_bits & 0x00000030u) {
    ::memset(&choose_automatically_if_no_stored_login_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&preselection_priority_) -
        reinterpret_cast<char*>(&choose_automatically_if_no_stored_login_)) + sizeof(preselection_priority_));
  }
  clear_payload_or_tag();
  clear_type();
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* LoginDetailsProto_LoginOptionProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bytes payload = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_payload();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool choose_automatically_if_no_stored_login = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_choose_automatically_if_no_stored_login(&has_bits);
          choose_automatically_if_no_stored_login_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 preselection_priority = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_preselection_priority(&has_bits);
          preselection_priority_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.LoginDetailsProto.LoginOptionCustomProto custom = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_custom(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.LoginDetailsProto.LoginOptionPasswordManagerProto password_manager = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_password_manager(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .autofill_assistant.InfoPopupProto info_popup = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_info_popup(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string sublabel = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_sublabel();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string sublabel_accessibility_hint = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          auto str = _internal_mutable_sublabel_accessibility_hint();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string edit_button_content_description = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          auto str = _internal_mutable_edit_button_content_description();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string tag = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 170)) {
          auto str = _internal_mutable_tag();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LoginDetailsProto_LoginOptionProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.LoginDetailsProto.LoginOptionProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bytes payload = 1;
  if (_internal_has_payload()) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_payload(), target);
  }

  cached_has_bits = _has_bits_[0];
  // optional bool choose_automatically_if_no_stored_login = 2;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_choose_automatically_if_no_stored_login(), target);
  }

  // optional int32 preselection_priority = 3;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_preselection_priority(), target);
  }

  switch (type_case()) {
    case kCustom: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, _Internal::custom(this),
          _Internal::custom(this).GetCachedSize(), target, stream);
      break;
    }
    case kPasswordManager: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(5, _Internal::password_manager(this),
          _Internal::password_manager(this).GetCachedSize(), target, stream);
      break;
    }
    default: ;
  }
  // optional .autofill_assistant.InfoPopupProto info_popup = 6;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::info_popup(this),
        _Internal::info_popup(this).GetCachedSize(), target, stream);
  }

  // optional string sublabel = 7;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        7, this->_internal_sublabel(), target);
  }

  // optional string sublabel_accessibility_hint = 8;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        8, this->_internal_sublabel_accessibility_hint(), target);
  }

  // optional string edit_button_content_description = 10;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteStringMaybeAliased(
        10, this->_internal_edit_button_content_description(), target);
  }

  // string tag = 21;
  if (_internal_has_tag()) {
    target = stream->WriteStringMaybeAliased(
        21, this->_internal_tag(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.LoginDetailsProto.LoginOptionProto)
  return target;
}

size_t LoginDetailsProto_LoginOptionProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.LoginDetailsProto.LoginOptionProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional string sublabel = 7;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_sublabel());
    }

    // optional string sublabel_accessibility_hint = 8;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_sublabel_accessibility_hint());
    }

    // optional string edit_button_content_description = 10;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_edit_button_content_description());
    }

    // optional .autofill_assistant.InfoPopupProto info_popup = 6;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *info_popup_);
    }

    // optional bool choose_automatically_if_no_stored_login = 2;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 1;
    }

    // optional int32 preselection_priority = 3;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_preselection_priority());
    }

  }
  switch (payload_or_tag_case()) {
    // bytes payload = 1;
    case kPayload: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_payload());
      break;
    }
    // string tag = 21;
    case kTag: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_tag());
      break;
    }
    case PAYLOAD_OR_TAG_NOT_SET: {
      break;
    }
  }
  switch (type_case()) {
    // .autofill_assistant.LoginDetailsProto.LoginOptionCustomProto custom = 4;
    case kCustom: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *type_.custom_);
      break;
    }
    // .autofill_assistant.LoginDetailsProto.LoginOptionPasswordManagerProto password_manager = 5;
    case kPasswordManager: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *type_.password_manager_);
      break;
    }
    case TYPE_NOT_SET: {
      break;
    }
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void LoginDetailsProto_LoginOptionProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const LoginDetailsProto_LoginOptionProto*>(
      &from));
}

void LoginDetailsProto_LoginOptionProto::MergeFrom(const LoginDetailsProto_LoginOptionProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.LoginDetailsProto.LoginOptionProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_sublabel(from._internal_sublabel());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_sublabel_accessibility_hint(from._internal_sublabel_accessibility_hint());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_edit_button_content_description(from._internal_edit_button_content_description());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_mutable_info_popup()->::autofill_assistant::InfoPopupProto::MergeFrom(from._internal_info_popup());
    }
    if (cached_has_bits & 0x00000010u) {
      choose_automatically_if_no_stored_login_ = from.choose_automatically_if_no_stored_login_;
    }
    if (cached_has_bits & 0x00000020u) {
      preselection_priority_ = from.preselection_priority_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  switch (from.payload_or_tag_case()) {
    case kPayload: {
      _internal_set_payload(from._internal_payload());
      break;
    }
    case kTag: {
      _internal_set_tag(from._internal_tag());
      break;
    }
    case PAYLOAD_OR_TAG_NOT_SET: {
      break;
    }
  }
  switch (from.type_case()) {
    case kCustom: {
      _internal_mutable_custom()->::autofill_assistant::LoginDetailsProto_LoginOptionCustomProto::MergeFrom(from._internal_custom());
      break;
    }
    case kPasswordManager: {
      _internal_mutable_password_manager()->::autofill_assistant::LoginDetailsProto_LoginOptionPasswordManagerProto::MergeFrom(from._internal_password_manager());
      break;
    }
    case TYPE_NOT_SET: {
      break;
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void LoginDetailsProto_LoginOptionProto::CopyFrom(const LoginDetailsProto_LoginOptionProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.LoginDetailsProto.LoginOptionProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LoginDetailsProto_LoginOptionProto::IsInitialized() const {
  return true;
}

void LoginDetailsProto_LoginOptionProto::InternalSwap(LoginDetailsProto_LoginOptionProto* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &sublabel_, lhs_arena,
      &other->sublabel_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &sublabel_accessibility_hint_, lhs_arena,
      &other->sublabel_accessibility_hint_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &edit_button_content_description_, lhs_arena,
      &other->edit_button_content_description_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(LoginDetailsProto_LoginOptionProto, preselection_priority_)
      + sizeof(LoginDetailsProto_LoginOptionProto::preselection_priority_)
      - PROTOBUF_FIELD_OFFSET(LoginDetailsProto_LoginOptionProto, info_popup_)>(
          reinterpret_cast<char*>(&info_popup_),
          reinterpret_cast<char*>(&other->info_popup_));
  swap(payload_or_tag_, other->payload_or_tag_);
  swap(type_, other->type_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
  swap(_oneof_case_[1], other->_oneof_case_[1]);
}

std::string LoginDetailsProto_LoginOptionProto::GetTypeName() const {
  return "autofill_assistant.LoginDetailsProto.LoginOptionProto";
}


// ===================================================================

class LoginDetailsProto::_Internal {
 public:
  using HasBits = decltype(std::declval<LoginDetailsProto>()._has_bits_);
  static void set_has_section_title(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

LoginDetailsProto::LoginDetailsProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  login_options_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.LoginDetailsProto)
}
LoginDetailsProto::LoginDetailsProto(const LoginDetailsProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      login_options_(from.login_options_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  section_title_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    section_title_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_section_title()) {
    section_title_.Set(from._internal_section_title(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.LoginDetailsProto)
}

inline void LoginDetailsProto::SharedCtor() {
section_title_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  section_title_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

LoginDetailsProto::~LoginDetailsProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.LoginDetailsProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LoginDetailsProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  section_title_.Destroy();
}

void LoginDetailsProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void LoginDetailsProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.LoginDetailsProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  login_options_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    section_title_.ClearNonDefaultToEmpty();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* LoginDetailsProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string section_title = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_section_title();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .autofill_assistant.LoginDetailsProto.LoginOptionProto login_options = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_login_options(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LoginDetailsProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.LoginDetailsProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string section_title = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_section_title(), target);
  }

  // repeated .autofill_assistant.LoginDetailsProto.LoginOptionProto login_options = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_login_options_size()); i < n; i++) {
    const auto& repfield = this->_internal_login_options(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.LoginDetailsProto)
  return target;
}

size_t LoginDetailsProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.LoginDetailsProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .autofill_assistant.LoginDetailsProto.LoginOptionProto login_options = 2;
  total_size += 1UL * this->_internal_login_options_size();
  for (const auto& msg : this->login_options_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional string section_title = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_section_title());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void LoginDetailsProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const LoginDetailsProto*>(
      &from));
}

void LoginDetailsProto::MergeFrom(const LoginDetailsProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.LoginDetailsProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  login_options_.MergeFrom(from.login_options_);
  if (from._internal_has_section_title()) {
    _internal_set_section_title(from._internal_section_title());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void LoginDetailsProto::CopyFrom(const LoginDetailsProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.LoginDetailsProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LoginDetailsProto::IsInitialized() const {
  return true;
}

void LoginDetailsProto::InternalSwap(LoginDetailsProto* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  login_options_.InternalSwap(&other->login_options_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &section_title_, lhs_arena,
      &other->section_title_, rhs_arena
  );
}

std::string LoginDetailsProto::GetTypeName() const {
  return "autofill_assistant.LoginDetailsProto";
}


// ===================================================================

class StaticTextSectionProto::_Internal {
 public:
};

StaticTextSectionProto::StaticTextSectionProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.StaticTextSectionProto)
}
StaticTextSectionProto::StaticTextSectionProto(const StaticTextSectionProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  clear_has_value();
  switch (from.value_case()) {
    case kText: {
      _internal_set_text(from._internal_text());
      break;
    }
    case kClientMemoryKey: {
      _internal_set_client_memory_key(from._internal_client_memory_key());
      break;
    }
    case VALUE_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.StaticTextSectionProto)
}

inline void StaticTextSectionProto::SharedCtor() {
clear_has_value();
}

StaticTextSectionProto::~StaticTextSectionProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.StaticTextSectionProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StaticTextSectionProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_value()) {
    clear_value();
  }
}

void StaticTextSectionProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void StaticTextSectionProto::clear_value() {
// @@protoc_insertion_point(one_of_clear_start:autofill_assistant.StaticTextSectionProto)
  switch (value_case()) {
    case kText: {
      value_.text_.Destroy();
      break;
    }
    case kClientMemoryKey: {
      value_.client_memory_key_.Destroy();
      break;
    }
    case VALUE_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = VALUE_NOT_SET;
}


void StaticTextSectionProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.StaticTextSectionProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_value();
  _internal_metadata_.Clear<std::string>();
}

const char* StaticTextSectionProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string text = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_text();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string client_memory_key = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_client_memory_key();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StaticTextSectionProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.StaticTextSectionProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (value_case()) {
    case kText: {
      target = stream->WriteStringMaybeAliased(
          1, this->_internal_text(), target);
      break;
    }
    case kClientMemoryKey: {
      target = stream->WriteStringMaybeAliased(
          2, this->_internal_client_memory_key(), target);
      break;
    }
    default: ;
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.StaticTextSectionProto)
  return target;
}

size_t StaticTextSectionProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.StaticTextSectionProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (value_case()) {
    // string text = 1;
    case kText: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_text());
      break;
    }
    // string client_memory_key = 2;
    case kClientMemoryKey: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_client_memory_key());
      break;
    }
    case VALUE_NOT_SET: {
      break;
    }
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void StaticTextSectionProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const StaticTextSectionProto*>(
      &from));
}

void StaticTextSectionProto::MergeFrom(const StaticTextSectionProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.StaticTextSectionProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.value_case()) {
    case kText: {
      _internal_set_text(from._internal_text());
      break;
    }
    case kClientMemoryKey: {
      _internal_set_client_memory_key(from._internal_client_memory_key());
      break;
    }
    case VALUE_NOT_SET: {
      break;
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void StaticTextSectionProto::CopyFrom(const StaticTextSectionProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.StaticTextSectionProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StaticTextSectionProto::IsInitialized() const {
  return true;
}

void StaticTextSectionProto::InternalSwap(StaticTextSectionProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(value_, other->value_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

std::string StaticTextSectionProto::GetTypeName() const {
  return "autofill_assistant.StaticTextSectionProto";
}


// ===================================================================

class TextInputProto::_Internal {
 public:
  using HasBits = decltype(std::declval<TextInputProto>()._has_bits_);
  static void set_has_hint(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_input_type(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_client_memory_key(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_value(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

TextInputProto::TextInputProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.TextInputProto)
}
TextInputProto::TextInputProto(const TextInputProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  hint_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    hint_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_hint()) {
    hint_.Set(from._internal_hint(), 
      GetArenaForAllocation());
  }
  client_memory_key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    client_memory_key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_client_memory_key()) {
    client_memory_key_.Set(from._internal_client_memory_key(), 
      GetArenaForAllocation());
  }
  value_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    value_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_value()) {
    value_.Set(from._internal_value(), 
      GetArenaForAllocation());
  }
  input_type_ = from.input_type_;
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.TextInputProto)
}

inline void TextInputProto::SharedCtor() {
hint_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  hint_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
client_memory_key_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  client_memory_key_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
value_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  value_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
input_type_ = 0;
}

TextInputProto::~TextInputProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.TextInputProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TextInputProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  hint_.Destroy();
  client_memory_key_.Destroy();
  value_.Destroy();
}

void TextInputProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void TextInputProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.TextInputProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      hint_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      client_memory_key_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      value_.ClearNonDefaultToEmpty();
    }
  }
  input_type_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* TextInputProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string hint = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_hint();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .autofill_assistant.TextInputProto.InputType input_type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::autofill_assistant::TextInputProto_InputType_IsValid(val))) {
            _internal_set_input_type(static_cast<::autofill_assistant::TextInputProto_InputType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional string client_memory_key = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_client_memory_key();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string value = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_value();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TextInputProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.TextInputProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string hint = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_hint(), target);
  }

  // optional .autofill_assistant.TextInputProto.InputType input_type = 2;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_input_type(), target);
  }

  // optional string client_memory_key = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_client_memory_key(), target);
  }

  // optional string value = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_value(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.TextInputProto)
  return target;
}

size_t TextInputProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.TextInputProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string hint = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_hint());
    }

    // optional string client_memory_key = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_client_memory_key());
    }

    // optional string value = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_value());
    }

    // optional .autofill_assistant.TextInputProto.InputType input_type = 2;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_input_type());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TextInputProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const TextInputProto*>(
      &from));
}

void TextInputProto::MergeFrom(const TextInputProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.TextInputProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_hint(from._internal_hint());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_client_memory_key(from._internal_client_memory_key());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_value(from._internal_value());
    }
    if (cached_has_bits & 0x00000008u) {
      input_type_ = from.input_type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TextInputProto::CopyFrom(const TextInputProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.TextInputProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TextInputProto::IsInitialized() const {
  return true;
}

void TextInputProto::InternalSwap(TextInputProto* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &hint_, lhs_arena,
      &other->hint_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &client_memory_key_, lhs_arena,
      &other->client_memory_key_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &value_, lhs_arena,
      &other->value_, rhs_arena
  );
  swap(input_type_, other->input_type_);
}

std::string TextInputProto::GetTypeName() const {
  return "autofill_assistant.TextInputProto";
}


// ===================================================================

class TextInputSectionProto::_Internal {
 public:
};

TextInputSectionProto::TextInputSectionProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  input_fields_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.TextInputSectionProto)
}
TextInputSectionProto::TextInputSectionProto(const TextInputSectionProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      input_fields_(from.input_fields_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.TextInputSectionProto)
}

inline void TextInputSectionProto::SharedCtor() {
}

TextInputSectionProto::~TextInputSectionProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.TextInputSectionProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TextInputSectionProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void TextInputSectionProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void TextInputSectionProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.TextInputSectionProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  input_fields_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* TextInputSectionProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .autofill_assistant.TextInputProto input_fields = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_input_fields(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TextInputSectionProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.TextInputSectionProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .autofill_assistant.TextInputProto input_fields = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_input_fields_size()); i < n; i++) {
    const auto& repfield = this->_internal_input_fields(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.TextInputSectionProto)
  return target;
}

size_t TextInputSectionProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.TextInputSectionProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .autofill_assistant.TextInputProto input_fields = 1;
  total_size += 1UL * this->_internal_input_fields_size();
  for (const auto& msg : this->input_fields_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TextInputSectionProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const TextInputSectionProto*>(
      &from));
}

void TextInputSectionProto::MergeFrom(const TextInputSectionProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.TextInputSectionProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  input_fields_.MergeFrom(from.input_fields_);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TextInputSectionProto::CopyFrom(const TextInputSectionProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.TextInputSectionProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TextInputSectionProto::IsInitialized() const {
  return true;
}

void TextInputSectionProto::InternalSwap(TextInputSectionProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  input_fields_.InternalSwap(&other->input_fields_);
}

std::string TextInputSectionProto::GetTypeName() const {
  return "autofill_assistant.TextInputSectionProto";
}


// ===================================================================

class UserFormSectionProto::_Internal {
 public:
  using HasBits = decltype(std::declval<UserFormSectionProto>()._has_bits_);
  static void set_has_title(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::autofill_assistant::StaticTextSectionProto& static_text_section(const UserFormSectionProto* msg);
  static const ::autofill_assistant::TextInputSectionProto& text_input_section(const UserFormSectionProto* msg);
  static const ::autofill_assistant::PopupListSectionProto& popup_list_section(const UserFormSectionProto* msg);
  static void set_has_send_result_to_backend(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::autofill_assistant::StaticTextSectionProto&
UserFormSectionProto::_Internal::static_text_section(const UserFormSectionProto* msg) {
  return *msg->section_.static_text_section_;
}
const ::autofill_assistant::TextInputSectionProto&
UserFormSectionProto::_Internal::text_input_section(const UserFormSectionProto* msg) {
  return *msg->section_.text_input_section_;
}
const ::autofill_assistant::PopupListSectionProto&
UserFormSectionProto::_Internal::popup_list_section(const UserFormSectionProto* msg) {
  return *msg->section_.popup_list_section_;
}
void UserFormSectionProto::set_allocated_static_text_section(::autofill_assistant::StaticTextSectionProto* static_text_section) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_section();
  if (static_text_section) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(static_text_section);
    if (message_arena != submessage_arena) {
      static_text_section = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, static_text_section, submessage_arena);
    }
    set_has_static_text_section();
    section_.static_text_section_ = static_text_section;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.UserFormSectionProto.static_text_section)
}
void UserFormSectionProto::set_allocated_text_input_section(::autofill_assistant::TextInputSectionProto* text_input_section) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_section();
  if (text_input_section) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(text_input_section);
    if (message_arena != submessage_arena) {
      text_input_section = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, text_input_section, submessage_arena);
    }
    set_has_text_input_section();
    section_.text_input_section_ = text_input_section;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.UserFormSectionProto.text_input_section)
}
void UserFormSectionProto::set_allocated_popup_list_section(::autofill_assistant::PopupListSectionProto* popup_list_section) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_section();
  if (popup_list_section) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(popup_list_section);
    if (message_arena != submessage_arena) {
      popup_list_section = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, popup_list_section, submessage_arena);
    }
    set_has_popup_list_section();
    section_.popup_list_section_ = popup_list_section;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.UserFormSectionProto.popup_list_section)
}
UserFormSectionProto::UserFormSectionProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.UserFormSectionProto)
}
UserFormSectionProto::UserFormSectionProto(const UserFormSectionProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  title_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    title_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_title()) {
    title_.Set(from._internal_title(), 
      GetArenaForAllocation());
  }
  send_result_to_backend_ = from.send_result_to_backend_;
  clear_has_section();
  switch (from.section_case()) {
    case kStaticTextSection: {
      _internal_mutable_static_text_section()->::autofill_assistant::StaticTextSectionProto::MergeFrom(from._internal_static_text_section());
      break;
    }
    case kTextInputSection: {
      _internal_mutable_text_input_section()->::autofill_assistant::TextInputSectionProto::MergeFrom(from._internal_text_input_section());
      break;
    }
    case kPopupListSection: {
      _internal_mutable_popup_list_section()->::autofill_assistant::PopupListSectionProto::MergeFrom(from._internal_popup_list_section());
      break;
    }
    case SECTION_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.UserFormSectionProto)
}

inline void UserFormSectionProto::SharedCtor() {
title_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  title_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
send_result_to_backend_ = false;
clear_has_section();
}

UserFormSectionProto::~UserFormSectionProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.UserFormSectionProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void UserFormSectionProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  title_.Destroy();
  if (has_section()) {
    clear_section();
  }
}

void UserFormSectionProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void UserFormSectionProto::clear_section() {
// @@protoc_insertion_point(one_of_clear_start:autofill_assistant.UserFormSectionProto)
  switch (section_case()) {
    case kStaticTextSection: {
      if (GetArenaForAllocation() == nullptr) {
        delete section_.static_text_section_;
      }
      break;
    }
    case kTextInputSection: {
      if (GetArenaForAllocation() == nullptr) {
        delete section_.text_input_section_;
      }
      break;
    }
    case kPopupListSection: {
      if (GetArenaForAllocation() == nullptr) {
        delete section_.popup_list_section_;
      }
      break;
    }
    case SECTION_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = SECTION_NOT_SET;
}


void UserFormSectionProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.UserFormSectionProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    title_.ClearNonDefaultToEmpty();
  }
  send_result_to_backend_ = false;
  clear_section();
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* UserFormSectionProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string title = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_title();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.StaticTextSectionProto static_text_section = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_static_text_section(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.TextInputSectionProto text_input_section = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_text_input_section(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.PopupListSectionProto popup_list_section = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_popup_list_section(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool send_result_to_backend = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_send_result_to_backend(&has_bits);
          send_result_to_backend_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UserFormSectionProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.UserFormSectionProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string title = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_title(), target);
  }

  switch (section_case()) {
    case kStaticTextSection: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, _Internal::static_text_section(this),
          _Internal::static_text_section(this).GetCachedSize(), target, stream);
      break;
    }
    case kTextInputSection: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, _Internal::text_input_section(this),
          _Internal::text_input_section(this).GetCachedSize(), target, stream);
      break;
    }
    case kPopupListSection: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, _Internal::popup_list_section(this),
          _Internal::popup_list_section(this).GetCachedSize(), target, stream);
      break;
    }
    default: ;
  }
  // optional bool send_result_to_backend = 5;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_send_result_to_backend(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.UserFormSectionProto)
  return target;
}

size_t UserFormSectionProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.UserFormSectionProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string title = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_title());
    }

    // optional bool send_result_to_backend = 5;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

  }
  switch (section_case()) {
    // .autofill_assistant.StaticTextSectionProto static_text_section = 2;
    case kStaticTextSection: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *section_.static_text_section_);
      break;
    }
    // .autofill_assistant.TextInputSectionProto text_input_section = 3;
    case kTextInputSection: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *section_.text_input_section_);
      break;
    }
    // .autofill_assistant.PopupListSectionProto popup_list_section = 4;
    case kPopupListSection: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *section_.popup_list_section_);
      break;
    }
    case SECTION_NOT_SET: {
      break;
    }
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void UserFormSectionProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const UserFormSectionProto*>(
      &from));
}

void UserFormSectionProto::MergeFrom(const UserFormSectionProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.UserFormSectionProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_title(from._internal_title());
    }
    if (cached_has_bits & 0x00000002u) {
      send_result_to_backend_ = from.send_result_to_backend_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  switch (from.section_case()) {
    case kStaticTextSection: {
      _internal_mutable_static_text_section()->::autofill_assistant::StaticTextSectionProto::MergeFrom(from._internal_static_text_section());
      break;
    }
    case kTextInputSection: {
      _internal_mutable_text_input_section()->::autofill_assistant::TextInputSectionProto::MergeFrom(from._internal_text_input_section());
      break;
    }
    case kPopupListSection: {
      _internal_mutable_popup_list_section()->::autofill_assistant::PopupListSectionProto::MergeFrom(from._internal_popup_list_section());
      break;
    }
    case SECTION_NOT_SET: {
      break;
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void UserFormSectionProto::CopyFrom(const UserFormSectionProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.UserFormSectionProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UserFormSectionProto::IsInitialized() const {
  return true;
}

void UserFormSectionProto::InternalSwap(UserFormSectionProto* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &title_, lhs_arena,
      &other->title_, rhs_arena
  );
  swap(send_result_to_backend_, other->send_result_to_backend_);
  swap(section_, other->section_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

std::string UserFormSectionProto::GetTypeName() const {
  return "autofill_assistant.UserFormSectionProto";
}


// ===================================================================

class PopupListSectionProto::_Internal {
 public:
  using HasBits = decltype(std::declval<PopupListSectionProto>()._has_bits_);
  static void set_has_additional_value_key(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_allow_multiselect(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_selection_mandatory(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_no_selection_error_message(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

PopupListSectionProto::PopupListSectionProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  item_names_(arena),
  initial_selection_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.PopupListSectionProto)
}
PopupListSectionProto::PopupListSectionProto(const PopupListSectionProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      item_names_(from.item_names_),
      initial_selection_(from.initial_selection_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  additional_value_key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    additional_value_key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_additional_value_key()) {
    additional_value_key_.Set(from._internal_additional_value_key(), 
      GetArenaForAllocation());
  }
  no_selection_error_message_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    no_selection_error_message_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_no_selection_error_message()) {
    no_selection_error_message_.Set(from._internal_no_selection_error_message(), 
      GetArenaForAllocation());
  }
  ::memcpy(&allow_multiselect_, &from.allow_multiselect_,
    static_cast<size_t>(reinterpret_cast<char*>(&selection_mandatory_) -
    reinterpret_cast<char*>(&allow_multiselect_)) + sizeof(selection_mandatory_));
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.PopupListSectionProto)
}

inline void PopupListSectionProto::SharedCtor() {
additional_value_key_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  additional_value_key_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
no_selection_error_message_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  no_selection_error_message_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
allow_multiselect_ = false;
selection_mandatory_ = true;
}

PopupListSectionProto::~PopupListSectionProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.PopupListSectionProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PopupListSectionProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  additional_value_key_.Destroy();
  no_selection_error_message_.Destroy();
}

void PopupListSectionProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void PopupListSectionProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.PopupListSectionProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  item_names_.Clear();
  initial_selection_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      additional_value_key_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      no_selection_error_message_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000000cu) {
    allow_multiselect_ = false;
    selection_mandatory_ = true;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* PopupListSectionProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string additional_value_key = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_additional_value_key();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated string item_names = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_item_names();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated int32 initial_selection = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_initial_selection(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<24>(ptr));
        } else if (static_cast<uint8_t>(tag) == 26) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_initial_selection(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool allow_multiselect = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_allow_multiselect(&has_bits);
          allow_multiselect_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool selection_mandatory = 5 [default = true];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_selection_mandatory(&has_bits);
          selection_mandatory_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string no_selection_error_message = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_no_selection_error_message();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PopupListSectionProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.PopupListSectionProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string additional_value_key = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_additional_value_key(), target);
  }

  // repeated string item_names = 2;
  for (int i = 0, n = this->_internal_item_names_size(); i < n; i++) {
    const auto& s = this->_internal_item_names(i);
    target = stream->WriteString(2, s, target);
  }

  // repeated int32 initial_selection = 3;
  for (int i = 0, n = this->_internal_initial_selection_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_initial_selection(i), target);
  }

  // optional bool allow_multiselect = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_allow_multiselect(), target);
  }

  // optional bool selection_mandatory = 5 [default = true];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_selection_mandatory(), target);
  }

  // optional string no_selection_error_message = 6;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_no_selection_error_message(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.PopupListSectionProto)
  return target;
}

size_t PopupListSectionProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.PopupListSectionProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string item_names = 2;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(item_names_.size());
  for (int i = 0, n = item_names_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      item_names_.Get(i));
  }

  // repeated int32 initial_selection = 3;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int32Size(this->initial_selection_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_initial_selection_size());
    total_size += data_size;
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string additional_value_key = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_additional_value_key());
    }

    // optional string no_selection_error_message = 6;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_no_selection_error_message());
    }

    // optional bool allow_multiselect = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

    // optional bool selection_mandatory = 5 [default = true];
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void PopupListSectionProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const PopupListSectionProto*>(
      &from));
}

void PopupListSectionProto::MergeFrom(const PopupListSectionProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.PopupListSectionProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  item_names_.MergeFrom(from.item_names_);
  initial_selection_.MergeFrom(from.initial_selection_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_additional_value_key(from._internal_additional_value_key());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_no_selection_error_message(from._internal_no_selection_error_message());
    }
    if (cached_has_bits & 0x00000004u) {
      allow_multiselect_ = from.allow_multiselect_;
    }
    if (cached_has_bits & 0x00000008u) {
      selection_mandatory_ = from.selection_mandatory_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void PopupListSectionProto::CopyFrom(const PopupListSectionProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.PopupListSectionProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PopupListSectionProto::IsInitialized() const {
  return true;
}

void PopupListSectionProto::InternalSwap(PopupListSectionProto* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  item_names_.InternalSwap(&other->item_names_);
  initial_selection_.InternalSwap(&other->initial_selection_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &additional_value_key_, lhs_arena,
      &other->additional_value_key_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &no_selection_error_message_, lhs_arena,
      &other->no_selection_error_message_, rhs_arena
  );
  swap(allow_multiselect_, other->allow_multiselect_);
  swap(selection_mandatory_, other->selection_mandatory_);
}

std::string PopupListSectionProto::GetTypeName() const {
  return "autofill_assistant.PopupListSectionProto";
}


// ===================================================================

class AutofillEntryProto::_Internal {
 public:
  using HasBits = decltype(std::declval<AutofillEntryProto>()._has_bits_);
  static void set_has_value(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_raw(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

AutofillEntryProto::AutofillEntryProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.AutofillEntryProto)
}
AutofillEntryProto::AutofillEntryProto(const AutofillEntryProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  value_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    value_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_value()) {
    value_.Set(from._internal_value(), 
      GetArenaForAllocation());
  }
  raw_ = from.raw_;
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.AutofillEntryProto)
}

inline void AutofillEntryProto::SharedCtor() {
value_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  value_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
raw_ = false;
}

AutofillEntryProto::~AutofillEntryProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.AutofillEntryProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AutofillEntryProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  value_.Destroy();
}

void AutofillEntryProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void AutofillEntryProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.AutofillEntryProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    value_.ClearNonDefaultToEmpty();
  }
  raw_ = false;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* AutofillEntryProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string value = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_value();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool raw = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_raw(&has_bits);
          raw_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AutofillEntryProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.AutofillEntryProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string value = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_value(), target);
  }

  // optional bool raw = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_raw(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.AutofillEntryProto)
  return target;
}

size_t AutofillEntryProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.AutofillEntryProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string value = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_value());
    }

    // optional bool raw = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void AutofillEntryProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const AutofillEntryProto*>(
      &from));
}

void AutofillEntryProto::MergeFrom(const AutofillEntryProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.AutofillEntryProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_value(from._internal_value());
    }
    if (cached_has_bits & 0x00000002u) {
      raw_ = from.raw_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void AutofillEntryProto::CopyFrom(const AutofillEntryProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.AutofillEntryProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AutofillEntryProto::IsInitialized() const {
  return true;
}

void AutofillEntryProto::InternalSwap(AutofillEntryProto* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &value_, lhs_arena,
      &other->value_, rhs_arena
  );
  swap(raw_, other->raw_);
}

std::string AutofillEntryProto::GetTypeName() const {
  return "autofill_assistant.AutofillEntryProto";
}


// ===================================================================

ProfileProto_ValuesEntry_DoNotUse::ProfileProto_ValuesEntry_DoNotUse() {}
ProfileProto_ValuesEntry_DoNotUse::ProfileProto_ValuesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void ProfileProto_ValuesEntry_DoNotUse::MergeFrom(const ProfileProto_ValuesEntry_DoNotUse& other) {
  MergeFromInternal(other);
}

// ===================================================================

class ProfileProto::_Internal {
 public:
  using HasBits = decltype(std::declval<ProfileProto>()._has_bits_);
  static void set_has_identifier(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_edit_token(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

ProfileProto::ProfileProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  values_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.ProfileProto)
}
ProfileProto::ProfileProto(const ProfileProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  values_.MergeFrom(from.values_);
  identifier_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    identifier_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_identifier()) {
    identifier_.Set(from._internal_identifier(), 
      GetArenaForAllocation());
  }
  edit_token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    edit_token_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_edit_token()) {
    edit_token_.Set(from._internal_edit_token(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.ProfileProto)
}

inline void ProfileProto::SharedCtor() {
identifier_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  identifier_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
edit_token_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  edit_token_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ProfileProto::~ProfileProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.ProfileProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ProfileProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  values_.Destruct();
  identifier_.Destroy();
  edit_token_.Destroy();
}

void ProfileProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ProfileProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.ProfileProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  values_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      identifier_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      edit_token_.ClearNonDefaultToEmpty();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ProfileProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // map<int32, .autofill_assistant.AutofillEntryProto> values = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&values_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional string identifier = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_identifier();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes edit_token = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_edit_token();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ProfileProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.ProfileProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // map<int32, .autofill_assistant.AutofillEntryProto> values = 2;
  if (!this->_internal_values().empty()) {
    using MapType = ::_pb::Map<int32_t, ::autofill_assistant::AutofillEntryProto>;
    using WireHelper = ProfileProto_ValuesEntry_DoNotUse::Funcs;
    const auto& map_field = this->_internal_values();

    if (stream->IsSerializationDeterministic() && map_field.size() > 1) {
      for (const auto& entry : ::_pbi::MapSorterFlat<MapType>(map_field)) {
        target = WireHelper::InternalSerialize(2, entry.first, entry.second, target, stream);
      }
    } else {
      for (const auto& entry : map_field) {
        target = WireHelper::InternalSerialize(2, entry.first, entry.second, target, stream);
      }
    }
  }

  cached_has_bits = _has_bits_[0];
  // optional string identifier = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_identifier(), target);
  }

  // optional bytes edit_token = 4;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        4, this->_internal_edit_token(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.ProfileProto)
  return target;
}

size_t ProfileProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.ProfileProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // map<int32, .autofill_assistant.AutofillEntryProto> values = 2;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_values_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::autofill_assistant::AutofillEntryProto >::const_iterator
      it = this->_internal_values().begin();
      it != this->_internal_values().end(); ++it) {
    total_size += ProfileProto_ValuesEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string identifier = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_identifier());
    }

    // optional bytes edit_token = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_edit_token());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ProfileProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ProfileProto*>(
      &from));
}

void ProfileProto::MergeFrom(const ProfileProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.ProfileProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  values_.MergeFrom(from.values_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_identifier(from._internal_identifier());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_edit_token(from._internal_edit_token());
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ProfileProto::CopyFrom(const ProfileProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.ProfileProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ProfileProto::IsInitialized() const {
  return true;
}

void ProfileProto::InternalSwap(ProfileProto* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  values_.InternalSwap(&other->values_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &identifier_, lhs_arena,
      &other->identifier_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &edit_token_, lhs_arena,
      &other->edit_token_, rhs_arena
  );
}

std::string ProfileProto::GetTypeName() const {
  return "autofill_assistant.ProfileProto";
}


// ===================================================================

class PhoneNumberProto::_Internal {
 public:
  using HasBits = decltype(std::declval<PhoneNumberProto>()._has_bits_);
  static void set_has_identifier(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::autofill_assistant::AutofillEntryProto& value(const PhoneNumberProto* msg);
  static void set_has_value(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::autofill_assistant::AutofillEntryProto&
PhoneNumberProto::_Internal::value(const PhoneNumberProto* msg) {
  return *msg->value_;
}
PhoneNumberProto::PhoneNumberProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.PhoneNumberProto)
}
PhoneNumberProto::PhoneNumberProto(const PhoneNumberProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  identifier_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    identifier_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_identifier()) {
    identifier_.Set(from._internal_identifier(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_value()) {
    value_ = new ::autofill_assistant::AutofillEntryProto(*from.value_);
  } else {
    value_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.PhoneNumberProto)
}

inline void PhoneNumberProto::SharedCtor() {
identifier_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  identifier_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
value_ = nullptr;
}

PhoneNumberProto::~PhoneNumberProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.PhoneNumberProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PhoneNumberProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  identifier_.Destroy();
  if (this != internal_default_instance()) delete value_;
}

void PhoneNumberProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void PhoneNumberProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.PhoneNumberProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      identifier_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(value_ != nullptr);
      value_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* PhoneNumberProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string identifier = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_identifier();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .autofill_assistant.AutofillEntryProto value = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_value(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PhoneNumberProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.PhoneNumberProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string identifier = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_identifier(), target);
  }

  // optional .autofill_assistant.AutofillEntryProto value = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::value(this),
        _Internal::value(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.PhoneNumberProto)
  return target;
}

size_t PhoneNumberProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.PhoneNumberProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string identifier = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_identifier());
    }

    // optional .autofill_assistant.AutofillEntryProto value = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *value_);
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void PhoneNumberProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const PhoneNumberProto*>(
      &from));
}

void PhoneNumberProto::MergeFrom(const PhoneNumberProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.PhoneNumberProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_identifier(from._internal_identifier());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_value()->::autofill_assistant::AutofillEntryProto::MergeFrom(from._internal_value());
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void PhoneNumberProto::CopyFrom(const PhoneNumberProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.PhoneNumberProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PhoneNumberProto::IsInitialized() const {
  return true;
}

void PhoneNumberProto::InternalSwap(PhoneNumberProto* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &identifier_, lhs_arena,
      &other->identifier_, rhs_arena
  );
  swap(value_, other->value_);
}

std::string PhoneNumberProto::GetTypeName() const {
  return "autofill_assistant.PhoneNumberProto";
}


// ===================================================================

PaymentInstrumentProto_CardValuesEntry_DoNotUse::PaymentInstrumentProto_CardValuesEntry_DoNotUse() {}
PaymentInstrumentProto_CardValuesEntry_DoNotUse::PaymentInstrumentProto_CardValuesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void PaymentInstrumentProto_CardValuesEntry_DoNotUse::MergeFrom(const PaymentInstrumentProto_CardValuesEntry_DoNotUse& other) {
  MergeFromInternal(other);
}

// ===================================================================

PaymentInstrumentProto_AddressValuesEntry_DoNotUse::PaymentInstrumentProto_AddressValuesEntry_DoNotUse() {}
PaymentInstrumentProto_AddressValuesEntry_DoNotUse::PaymentInstrumentProto_AddressValuesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void PaymentInstrumentProto_AddressValuesEntry_DoNotUse::MergeFrom(const PaymentInstrumentProto_AddressValuesEntry_DoNotUse& other) {
  MergeFromInternal(other);
}

// ===================================================================

class PaymentInstrumentProto::_Internal {
 public:
  using HasBits = decltype(std::declval<PaymentInstrumentProto>()._has_bits_);
  static void set_has_instrument_id(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_network(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_last_four_digits(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_identifier(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_edit_token(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

PaymentInstrumentProto::PaymentInstrumentProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  card_values_(arena),
  address_values_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.PaymentInstrumentProto)
}
PaymentInstrumentProto::PaymentInstrumentProto(const PaymentInstrumentProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  card_values_.MergeFrom(from.card_values_);
  address_values_.MergeFrom(from.address_values_);
  identifier_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    identifier_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_identifier()) {
    identifier_.Set(from._internal_identifier(), 
      GetArenaForAllocation());
  }
  network_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    network_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_network()) {
    network_.Set(from._internal_network(), 
      GetArenaForAllocation());
  }
  last_four_digits_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    last_four_digits_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_last_four_digits()) {
    last_four_digits_.Set(from._internal_last_four_digits(), 
      GetArenaForAllocation());
  }
  edit_token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    edit_token_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_edit_token()) {
    edit_token_.Set(from._internal_edit_token(), 
      GetArenaForAllocation());
  }
  instrument_id_ = from.instrument_id_;
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.PaymentInstrumentProto)
}

inline void PaymentInstrumentProto::SharedCtor() {
identifier_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  identifier_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
network_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  network_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
last_four_digits_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  last_four_digits_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
edit_token_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  edit_token_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
instrument_id_ = int64_t{0};
}

PaymentInstrumentProto::~PaymentInstrumentProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.PaymentInstrumentProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PaymentInstrumentProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  card_values_.Destruct();
  address_values_.Destruct();
  identifier_.Destroy();
  network_.Destroy();
  last_four_digits_.Destroy();
  edit_token_.Destroy();
}

void PaymentInstrumentProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void PaymentInstrumentProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.PaymentInstrumentProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  card_values_.Clear();
  address_values_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      identifier_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      network_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      last_four_digits_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      edit_token_.ClearNonDefaultToEmpty();
    }
  }
  instrument_id_ = int64_t{0};
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* PaymentInstrumentProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // map<int32, .autofill_assistant.AutofillEntryProto> card_values = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&card_values_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // map<int32, .autofill_assistant.AutofillEntryProto> address_values = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&address_values_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional string identifier = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_identifier();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string network = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_network();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string last_four_digits = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_last_four_digits();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 instrument_id = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_instrument_id(&has_bits);
          instrument_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes edit_token = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          auto str = _internal_mutable_edit_token();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PaymentInstrumentProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.PaymentInstrumentProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // map<int32, .autofill_assistant.AutofillEntryProto> card_values = 2;
  if (!this->_internal_card_values().empty()) {
    using MapType = ::_pb::Map<int32_t, ::autofill_assistant::AutofillEntryProto>;
    using WireHelper = PaymentInstrumentProto_CardValuesEntry_DoNotUse::Funcs;
    const auto& map_field = this->_internal_card_values();

    if (stream->IsSerializationDeterministic() && map_field.size() > 1) {
      for (const auto& entry : ::_pbi::MapSorterFlat<MapType>(map_field)) {
        target = WireHelper::InternalSerialize(2, entry.first, entry.second, target, stream);
      }
    } else {
      for (const auto& entry : map_field) {
        target = WireHelper::InternalSerialize(2, entry.first, entry.second, target, stream);
      }
    }
  }

  // map<int32, .autofill_assistant.AutofillEntryProto> address_values = 3;
  if (!this->_internal_address_values().empty()) {
    using MapType = ::_pb::Map<int32_t, ::autofill_assistant::AutofillEntryProto>;
    using WireHelper = PaymentInstrumentProto_AddressValuesEntry_DoNotUse::Funcs;
    const auto& map_field = this->_internal_address_values();

    if (stream->IsSerializationDeterministic() && map_field.size() > 1) {
      for (const auto& entry : ::_pbi::MapSorterFlat<MapType>(map_field)) {
        target = WireHelper::InternalSerialize(3, entry.first, entry.second, target, stream);
      }
    } else {
      for (const auto& entry : map_field) {
        target = WireHelper::InternalSerialize(3, entry.first, entry.second, target, stream);
      }
    }
  }

  cached_has_bits = _has_bits_[0];
  // optional string identifier = 4;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_identifier(), target);
  }

  // optional string network = 5;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_network(), target);
  }

  // optional string last_four_digits = 6;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_last_four_digits(), target);
  }

  // optional int64 instrument_id = 7;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(7, this->_internal_instrument_id(), target);
  }

  // optional bytes edit_token = 8;
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteBytesMaybeAliased(
        8, this->_internal_edit_token(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.PaymentInstrumentProto)
  return target;
}

size_t PaymentInstrumentProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.PaymentInstrumentProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // map<int32, .autofill_assistant.AutofillEntryProto> card_values = 2;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_card_values_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::autofill_assistant::AutofillEntryProto >::const_iterator
      it = this->_internal_card_values().begin();
      it != this->_internal_card_values().end(); ++it) {
    total_size += PaymentInstrumentProto_CardValuesEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  // map<int32, .autofill_assistant.AutofillEntryProto> address_values = 3;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_address_values_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::autofill_assistant::AutofillEntryProto >::const_iterator
      it = this->_internal_address_values().begin();
      it != this->_internal_address_values().end(); ++it) {
    total_size += PaymentInstrumentProto_AddressValuesEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional string identifier = 4;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_identifier());
    }

    // optional string network = 5;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_network());
    }

    // optional string last_four_digits = 6;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_last_four_digits());
    }

    // optional bytes edit_token = 8;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_edit_token());
    }

    // optional int64 instrument_id = 7;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_instrument_id());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void PaymentInstrumentProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const PaymentInstrumentProto*>(
      &from));
}

void PaymentInstrumentProto::MergeFrom(const PaymentInstrumentProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.PaymentInstrumentProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  card_values_.MergeFrom(from.card_values_);
  address_values_.MergeFrom(from.address_values_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_identifier(from._internal_identifier());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_network(from._internal_network());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_last_four_digits(from._internal_last_four_digits());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_set_edit_token(from._internal_edit_token());
    }
    if (cached_has_bits & 0x00000010u) {
      instrument_id_ = from.instrument_id_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void PaymentInstrumentProto::CopyFrom(const PaymentInstrumentProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.PaymentInstrumentProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PaymentInstrumentProto::IsInitialized() const {
  return true;
}

void PaymentInstrumentProto::InternalSwap(PaymentInstrumentProto* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  card_values_.InternalSwap(&other->card_values_);
  address_values_.InternalSwap(&other->address_values_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &identifier_, lhs_arena,
      &other->identifier_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &network_, lhs_arena,
      &other->network_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &last_four_digits_, lhs_arena,
      &other->last_four_digits_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &edit_token_, lhs_arena,
      &other->edit_token_, rhs_arena
  );
  swap(instrument_id_, other->instrument_id_);
}

std::string PaymentInstrumentProto::GetTypeName() const {
  return "autofill_assistant.PaymentInstrumentProto";
}


// ===================================================================

class DataOriginNoticeProto::_Internal {
 public:
  using HasBits = decltype(std::declval<DataOriginNoticeProto>()._has_bits_);
  static void set_has_link_text(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_dialog_title(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_dialog_text(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_dialog_button_text(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

DataOriginNoticeProto::DataOriginNoticeProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.DataOriginNoticeProto)
}
DataOriginNoticeProto::DataOriginNoticeProto(const DataOriginNoticeProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  link_text_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    link_text_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_link_text()) {
    link_text_.Set(from._internal_link_text(), 
      GetArenaForAllocation());
  }
  dialog_title_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    dialog_title_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_dialog_title()) {
    dialog_title_.Set(from._internal_dialog_title(), 
      GetArenaForAllocation());
  }
  dialog_text_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    dialog_text_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_dialog_text()) {
    dialog_text_.Set(from._internal_dialog_text(), 
      GetArenaForAllocation());
  }
  dialog_button_text_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    dialog_button_text_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_dialog_button_text()) {
    dialog_button_text_.Set(from._internal_dialog_button_text(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.DataOriginNoticeProto)
}

inline void DataOriginNoticeProto::SharedCtor() {
link_text_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  link_text_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
dialog_title_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  dialog_title_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
dialog_text_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  dialog_text_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
dialog_button_text_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  dialog_button_text_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

DataOriginNoticeProto::~DataOriginNoticeProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.DataOriginNoticeProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DataOriginNoticeProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  link_text_.Destroy();
  dialog_title_.Destroy();
  dialog_text_.Destroy();
  dialog_button_text_.Destroy();
}

void DataOriginNoticeProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void DataOriginNoticeProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.DataOriginNoticeProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      link_text_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      dialog_title_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      dialog_text_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      dialog_button_text_.ClearNonDefaultToEmpty();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* DataOriginNoticeProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string link_text = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_link_text();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string dialog_title = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_dialog_title();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string dialog_text = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_dialog_text();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string dialog_button_text = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_dialog_button_text();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DataOriginNoticeProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.DataOriginNoticeProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string link_text = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_link_text(), target);
  }

  // optional string dialog_title = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_dialog_title(), target);
  }

  // optional string dialog_text = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_dialog_text(), target);
  }

  // optional string dialog_button_text = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_dialog_button_text(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.DataOriginNoticeProto)
  return target;
}

size_t DataOriginNoticeProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.DataOriginNoticeProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string link_text = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_link_text());
    }

    // optional string dialog_title = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_dialog_title());
    }

    // optional string dialog_text = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_dialog_text());
    }

    // optional string dialog_button_text = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_dialog_button_text());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DataOriginNoticeProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DataOriginNoticeProto*>(
      &from));
}

void DataOriginNoticeProto::MergeFrom(const DataOriginNoticeProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.DataOriginNoticeProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_link_text(from._internal_link_text());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_dialog_title(from._internal_dialog_title());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_dialog_text(from._internal_dialog_text());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_set_dialog_button_text(from._internal_dialog_button_text());
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DataOriginNoticeProto::CopyFrom(const DataOriginNoticeProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.DataOriginNoticeProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DataOriginNoticeProto::IsInitialized() const {
  return true;
}

void DataOriginNoticeProto::InternalSwap(DataOriginNoticeProto* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &link_text_, lhs_arena,
      &other->link_text_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &dialog_title_, lhs_arena,
      &other->dialog_title_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &dialog_text_, lhs_arena,
      &other->dialog_text_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &dialog_button_text_, lhs_arena,
      &other->dialog_button_text_, rhs_arena
  );
}

std::string DataOriginNoticeProto::GetTypeName() const {
  return "autofill_assistant.DataOriginNoticeProto";
}


// ===================================================================

class CollectUserDataProto_DataSource::_Internal {
 public:
  using HasBits = decltype(std::declval<CollectUserDataProto_DataSource>()._has_bits_);
  static void set_has_allow_fallback(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CollectUserDataProto_DataSource::CollectUserDataProto_DataSource(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.CollectUserDataProto.DataSource)
}
CollectUserDataProto_DataSource::CollectUserDataProto_DataSource(const CollectUserDataProto_DataSource& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  allow_fallback_ = from.allow_fallback_;
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.CollectUserDataProto.DataSource)
}

inline void CollectUserDataProto_DataSource::SharedCtor() {
allow_fallback_ = true;
}

CollectUserDataProto_DataSource::~CollectUserDataProto_DataSource() {
  // @@protoc_insertion_point(destructor:autofill_assistant.CollectUserDataProto.DataSource)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CollectUserDataProto_DataSource::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CollectUserDataProto_DataSource::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CollectUserDataProto_DataSource::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.CollectUserDataProto.DataSource)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  allow_fallback_ = true;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CollectUserDataProto_DataSource::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool allow_fallback = 1 [default = true];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_allow_fallback(&has_bits);
          allow_fallback_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CollectUserDataProto_DataSource::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.CollectUserDataProto.DataSource)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bool allow_fallback = 1 [default = true];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_allow_fallback(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.CollectUserDataProto.DataSource)
  return target;
}

size_t CollectUserDataProto_DataSource::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.CollectUserDataProto.DataSource)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bool allow_fallback = 1 [default = true];
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 1;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CollectUserDataProto_DataSource::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CollectUserDataProto_DataSource*>(
      &from));
}

void CollectUserDataProto_DataSource::MergeFrom(const CollectUserDataProto_DataSource& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.CollectUserDataProto.DataSource)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_allow_fallback()) {
    _internal_set_allow_fallback(from._internal_allow_fallback());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CollectUserDataProto_DataSource::CopyFrom(const CollectUserDataProto_DataSource& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.CollectUserDataProto.DataSource)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CollectUserDataProto_DataSource::IsInitialized() const {
  return true;
}

void CollectUserDataProto_DataSource::InternalSwap(CollectUserDataProto_DataSource* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(allow_fallback_, other->allow_fallback_);
}

std::string CollectUserDataProto_DataSource::GetTypeName() const {
  return "autofill_assistant.CollectUserDataProto.DataSource";
}


// ===================================================================

class CollectUserDataProto::_Internal {
 public:
  using HasBits = decltype(std::declval<CollectUserDataProto>()._has_bits_);
  static void set_has_prompt(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_billing_address_name(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_shipping_address_name(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_shipping_address_section_title(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_request_payment_method(HasBits* has_bits) {
    (*has_bits)[0] |= 262144u;
  }
  static const ::autofill_assistant::ContactDetailsProto& contact_details(const CollectUserDataProto* msg);
  static void set_has_contact_details(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static const ::autofill_assistant::ChipProto& confirm_chip(const CollectUserDataProto* msg);
  static void set_has_confirm_chip(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_terms_and_conditions_state(HasBits* has_bits) {
    (*has_bits)[0] |= 131072u;
  }
  static void set_has_request_terms_and_conditions(HasBits* has_bits) {
    (*has_bits)[0] |= 8388608u;
  }
  static void set_has_show_terms_as_checkbox(HasBits* has_bits) {
    (*has_bits)[0] |= 524288u;
  }
  static void set_has_accept_terms_and_conditions_text(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_terms_require_review_text(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_privacy_notice_text(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_credit_card_expired_text(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static const ::autofill_assistant::LoginDetailsProto& login_details(const CollectUserDataProto* msg);
  static void set_has_login_details(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static const ::autofill_assistant::DataOriginNoticeProto& data_origin_notice(const CollectUserDataProto* msg);
  static void set_has_data_origin_notice(HasBits* has_bits) {
    (*has_bits)[0] |= 65536u;
  }
  static const ::autofill_assistant::GenericUserInterfaceProto& generic_user_interface_prepended(const CollectUserDataProto* msg);
  static void set_has_generic_user_interface_prepended(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static const ::autofill_assistant::GenericUserInterfaceProto& generic_user_interface_appended(const CollectUserDataProto* msg);
  static void set_has_generic_user_interface_appended(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_info_section_text(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_info_section_text_center(HasBits* has_bits) {
    (*has_bits)[0] |= 1048576u;
  }
  static void set_has_additional_model_identifier_to_check(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_clear_previous_credit_card_selection(HasBits* has_bits) {
    (*has_bits)[0] |= 2097152u;
  }
  static void set_has_clear_previous_login_selection(HasBits* has_bits) {
    (*has_bits)[0] |= 4194304u;
  }
  static const ::autofill_assistant::CollectUserDataProto_DataSource& data_source(const CollectUserDataProto* msg);
  static void set_has_data_source(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
};

const ::autofill_assistant::ContactDetailsProto&
CollectUserDataProto::_Internal::contact_details(const CollectUserDataProto* msg) {
  return *msg->contact_details_;
}
const ::autofill_assistant::ChipProto&
CollectUserDataProto::_Internal::confirm_chip(const CollectUserDataProto* msg) {
  return *msg->confirm_chip_;
}
const ::autofill_assistant::LoginDetailsProto&
CollectUserDataProto::_Internal::login_details(const CollectUserDataProto* msg) {
  return *msg->login_details_;
}
const ::autofill_assistant::DataOriginNoticeProto&
CollectUserDataProto::_Internal::data_origin_notice(const CollectUserDataProto* msg) {
  return *msg->data_origin_notice_;
}
const ::autofill_assistant::GenericUserInterfaceProto&
CollectUserDataProto::_Internal::generic_user_interface_prepended(const CollectUserDataProto* msg) {
  return *msg->generic_user_interface_prepended_;
}
const ::autofill_assistant::GenericUserInterfaceProto&
CollectUserDataProto::_Internal::generic_user_interface_appended(const CollectUserDataProto* msg) {
  return *msg->generic_user_interface_appended_;
}
const ::autofill_assistant::CollectUserDataProto_DataSource&
CollectUserDataProto::_Internal::data_source(const CollectUserDataProto* msg) {
  return *msg->data_source_;
}
void CollectUserDataProto::clear_confirm_chip() {
  if (confirm_chip_ != nullptr) confirm_chip_->Clear();
  _has_bits_[0] &= ~0x00004000u;
}
void CollectUserDataProto::clear_additional_actions() {
  additional_actions_.Clear();
}
void CollectUserDataProto::clear_generic_user_interface_prepended() {
  if (generic_user_interface_prepended_ != nullptr) generic_user_interface_prepended_->Clear();
  _has_bits_[0] &= ~0x00001000u;
}
void CollectUserDataProto::clear_generic_user_interface_appended() {
  if (generic_user_interface_appended_ != nullptr) generic_user_interface_appended_->Clear();
  _has_bits_[0] &= ~0x00002000u;
}
void CollectUserDataProto::clear_required_shipping_address_data_piece() {
  required_shipping_address_data_piece_.Clear();
}
void CollectUserDataProto::clear_required_credit_card_data_piece() {
  required_credit_card_data_piece_.Clear();
}
void CollectUserDataProto::clear_required_billing_address_data_piece() {
  required_billing_address_data_piece_.Clear();
}
CollectUserDataProto::CollectUserDataProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  supported_basic_card_networks_(arena),
  additional_actions_(arena),
  additional_prepended_sections_(arena),
  additional_appended_sections_(arena),
  clear_previous_profile_selection_(arena),
  required_shipping_address_data_piece_(arena),
  required_credit_card_data_piece_(arena),
  required_billing_address_data_piece_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.CollectUserDataProto)
}
CollectUserDataProto::CollectUserDataProto(const CollectUserDataProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      supported_basic_card_networks_(from.supported_basic_card_networks_),
      additional_actions_(from.additional_actions_),
      additional_prepended_sections_(from.additional_prepended_sections_),
      additional_appended_sections_(from.additional_appended_sections_),
      clear_previous_profile_selection_(from.clear_previous_profile_selection_),
      required_shipping_address_data_piece_(from.required_shipping_address_data_piece_),
      required_credit_card_data_piece_(from.required_credit_card_data_piece_),
      required_billing_address_data_piece_(from.required_billing_address_data_piece_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  prompt_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    prompt_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_prompt()) {
    prompt_.Set(from._internal_prompt(), 
      GetArenaForAllocation());
  }
  billing_address_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    billing_address_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_billing_address_name()) {
    billing_address_name_.Set(from._internal_billing_address_name(), 
      GetArenaForAllocation());
  }
  shipping_address_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    shipping_address_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_shipping_address_name()) {
    shipping_address_name_.Set(from._internal_shipping_address_name(), 
      GetArenaForAllocation());
  }
  accept_terms_and_conditions_text_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    accept_terms_and_conditions_text_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_accept_terms_and_conditions_text()) {
    accept_terms_and_conditions_text_.Set(from._internal_accept_terms_and_conditions_text(), 
      GetArenaForAllocation());
  }
  terms_require_review_text_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    terms_require_review_text_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_terms_require_review_text()) {
    terms_require_review_text_.Set(from._internal_terms_require_review_text(), 
      GetArenaForAllocation());
  }
  privacy_notice_text_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    privacy_notice_text_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_privacy_notice_text()) {
    privacy_notice_text_.Set(from._internal_privacy_notice_text(), 
      GetArenaForAllocation());
  }
  credit_card_expired_text_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    credit_card_expired_text_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_credit_card_expired_text()) {
    credit_card_expired_text_.Set(from._internal_credit_card_expired_text(), 
      GetArenaForAllocation());
  }
  info_section_text_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    info_section_text_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_info_section_text()) {
    info_section_text_.Set(from._internal_info_section_text(), 
      GetArenaForAllocation());
  }
  additional_model_identifier_to_check_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    additional_model_identifier_to_check_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_additional_model_identifier_to_check()) {
    additional_model_identifier_to_check_.Set(from._internal_additional_model_identifier_to_check(), 
      GetArenaForAllocation());
  }
  shipping_address_section_title_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    shipping_address_section_title_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_shipping_address_section_title()) {
    shipping_address_section_title_.Set(from._internal_shipping_address_section_title(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_contact_details()) {
    contact_details_ = new ::autofill_assistant::ContactDetailsProto(*from.contact_details_);
  } else {
    contact_details_ = nullptr;
  }
  if (from._internal_has_login_details()) {
    login_details_ = new ::autofill_assistant::LoginDetailsProto(*from.login_details_);
  } else {
    login_details_ = nullptr;
  }
  if (from._internal_has_generic_user_interface_prepended()) {
    generic_user_interface_prepended_ = new ::autofill_assistant::GenericUserInterfaceProto(*from.generic_user_interface_prepended_);
  } else {
    generic_user_interface_prepended_ = nullptr;
  }
  if (from._internal_has_generic_user_interface_appended()) {
    generic_user_interface_appended_ = new ::autofill_assistant::GenericUserInterfaceProto(*from.generic_user_interface_appended_);
  } else {
    generic_user_interface_appended_ = nullptr;
  }
  if (from._internal_has_confirm_chip()) {
    confirm_chip_ = new ::autofill_assistant::ChipProto(*from.confirm_chip_);
  } else {
    confirm_chip_ = nullptr;
  }
  if (from._internal_has_data_source()) {
    data_source_ = new ::autofill_assistant::CollectUserDataProto_DataSource(*from.data_source_);
  } else {
    data_source_ = nullptr;
  }
  if (from._internal_has_data_origin_notice()) {
    data_origin_notice_ = new ::autofill_assistant::DataOriginNoticeProto(*from.data_origin_notice_);
  } else {
    data_origin_notice_ = nullptr;
  }
  ::memcpy(&terms_and_conditions_state_, &from.terms_and_conditions_state_,
    static_cast<size_t>(reinterpret_cast<char*>(&request_terms_and_conditions_) -
    reinterpret_cast<char*>(&terms_and_conditions_state_)) + sizeof(request_terms_and_conditions_));
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.CollectUserDataProto)
}

inline void CollectUserDataProto::SharedCtor() {
prompt_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  prompt_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
billing_address_name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  billing_address_name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
shipping_address_name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  shipping_address_name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
accept_terms_and_conditions_text_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  accept_terms_and_conditions_text_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
terms_require_review_text_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  terms_require_review_text_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
privacy_notice_text_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  privacy_notice_text_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
credit_card_expired_text_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  credit_card_expired_text_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
info_section_text_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  info_section_text_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
additional_model_identifier_to_check_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  additional_model_identifier_to_check_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
shipping_address_section_title_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  shipping_address_section_title_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&contact_details_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&clear_previous_login_selection_) -
    reinterpret_cast<char*>(&contact_details_)) + sizeof(clear_previous_login_selection_));
request_terms_and_conditions_ = true;
}

CollectUserDataProto::~CollectUserDataProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.CollectUserDataProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CollectUserDataProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  prompt_.Destroy();
  billing_address_name_.Destroy();
  shipping_address_name_.Destroy();
  accept_terms_and_conditions_text_.Destroy();
  terms_require_review_text_.Destroy();
  privacy_notice_text_.Destroy();
  credit_card_expired_text_.Destroy();
  info_section_text_.Destroy();
  additional_model_identifier_to_check_.Destroy();
  shipping_address_section_title_.Destroy();
  if (this != internal_default_instance()) delete contact_details_;
  if (this != internal_default_instance()) delete login_details_;
  if (this != internal_default_instance()) delete generic_user_interface_prepended_;
  if (this != internal_default_instance()) delete generic_user_interface_appended_;
  if (this != internal_default_instance()) delete confirm_chip_;
  if (this != internal_default_instance()) delete data_source_;
  if (this != internal_default_instance()) delete data_origin_notice_;
}

void CollectUserDataProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CollectUserDataProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.CollectUserDataProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  supported_basic_card_networks_.Clear();
  additional_actions_.Clear();
  additional_prepended_sections_.Clear();
  additional_appended_sections_.Clear();
  clear_previous_profile_selection_.Clear();
  required_shipping_address_data_piece_.Clear();
  required_credit_card_data_piece_.Clear();
  required_billing_address_data_piece_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      prompt_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      billing_address_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      shipping_address_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      accept_terms_and_conditions_text_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      terms_require_review_text_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000020u) {
      privacy_notice_text_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000040u) {
      credit_card_expired_text_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000080u) {
      info_section_text_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      additional_model_identifier_to_check_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000200u) {
      shipping_address_section_title_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000400u) {
      GOOGLE_DCHECK(contact_details_ != nullptr);
      contact_details_->Clear();
    }
    if (cached_has_bits & 0x00000800u) {
      GOOGLE_DCHECK(login_details_ != nullptr);
      login_details_->Clear();
    }
    if (cached_has_bits & 0x00001000u) {
      GOOGLE_DCHECK(generic_user_interface_prepended_ != nullptr);
      generic_user_interface_prepended_->Clear();
    }
    if (cached_has_bits & 0x00002000u) {
      GOOGLE_DCHECK(generic_user_interface_appended_ != nullptr);
      generic_user_interface_appended_->Clear();
    }
    if (cached_has_bits & 0x00004000u) {
      GOOGLE_DCHECK(confirm_chip_ != nullptr);
      confirm_chip_->Clear();
    }
    if (cached_has_bits & 0x00008000u) {
      GOOGLE_DCHECK(data_source_ != nullptr);
      data_source_->Clear();
    }
  }
  if (cached_has_bits & 0x00010000u) {
    GOOGLE_DCHECK(data_origin_notice_ != nullptr);
    data_origin_notice_->Clear();
  }
  if (cached_has_bits & 0x00fe0000u) {
    ::memset(&terms_and_conditions_state_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&clear_previous_login_selection_) -
        reinterpret_cast<char*>(&terms_and_conditions_state_)) + sizeof(clear_previous_login_selection_));
    request_terms_and_conditions_ = true;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CollectUserDataProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string prompt = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_prompt();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string billing_address_name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_billing_address_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string shipping_address_name = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_shipping_address_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool request_payment_method = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_request_payment_method(&has_bits);
          request_payment_method_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .autofill_assistant.ContactDetailsProto contact_details = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_contact_details(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated string supported_basic_card_networks = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_supported_basic_card_networks();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .autofill_assistant.CollectUserDataProto.TermsAndConditionsState terms_and_conditions_state = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::autofill_assistant::CollectUserDataProto_TermsAndConditionsState_IsValid(val))) {
            _internal_set_terms_and_conditions_state(static_cast<::autofill_assistant::CollectUserDataProto_TermsAndConditionsState>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(8, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional bool request_terms_and_conditions = 9 [default = true];
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_request_terms_and_conditions(&has_bits);
          request_terms_and_conditions_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .autofill_assistant.UserActionProto additional_actions = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_additional_actions(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<90>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional bool show_terms_as_checkbox = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_show_terms_as_checkbox(&has_bits);
          show_terms_as_checkbox_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string accept_terms_and_conditions_text = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          auto str = _internal_mutable_accept_terms_and_conditions_text();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .autofill_assistant.LoginDetailsProto login_details = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 130)) {
          ptr = ctx->ParseMessage(_internal_mutable_login_details(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .autofill_assistant.UserFormSectionProto additional_prepended_sections = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 146)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_additional_prepended_sections(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<146>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .autofill_assistant.UserFormSectionProto additional_appended_sections = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 154)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_additional_appended_sections(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<154>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional string terms_require_review_text = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
          auto str = _internal_mutable_terms_require_review_text();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string privacy_notice_text = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 170)) {
          auto str = _internal_mutable_privacy_notice_text();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .autofill_assistant.GenericUserInterfaceProto generic_user_interface_prepended = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 178)) {
          ptr = ctx->ParseMessage(_internal_mutable_generic_user_interface_prepended(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string credit_card_expired_text = 23;
      case 23:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 186)) {
          auto str = _internal_mutable_credit_card_expired_text();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string info_section_text = 24;
      case 24:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 194)) {
          auto str = _internal_mutable_info_section_text();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .autofill_assistant.GenericUserInterfaceProto generic_user_interface_appended = 25;
      case 25:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 202)) {
          ptr = ctx->ParseMessage(_internal_mutable_generic_user_interface_appended(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string additional_model_identifier_to_check = 27;
      case 27:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 218)) {
          auto str = _internal_mutable_additional_model_identifier_to_check();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool clear_previous_credit_card_selection = 28;
      case 28:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 224)) {
          _Internal::set_has_clear_previous_credit_card_selection(&has_bits);
          clear_previous_credit_card_selection_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool clear_previous_login_selection = 29;
      case 29:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 232)) {
          _Internal::set_has_clear_previous_login_selection(&has_bits);
          clear_previous_login_selection_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated string clear_previous_profile_selection = 30;
      case 30:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 242)) {
          ptr -= 2;
          do {
            ptr += 2;
            auto str = _internal_add_clear_previous_profile_selection();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<242>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional bool info_section_text_center = 31;
      case 31:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 248)) {
          _Internal::set_has_info_section_text_center(&has_bits);
          info_section_text_center_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string shipping_address_section_title = 32;
      case 32:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 2)) {
          auto str = _internal_mutable_shipping_address_section_title();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .autofill_assistant.ChipProto confirm_chip = 33;
      case 33:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_confirm_chip(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .autofill_assistant.RequiredDataPiece required_shipping_address_data_piece = 34;
      case 34:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_required_shipping_address_data_piece(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<274>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .autofill_assistant.RequiredDataPiece required_credit_card_data_piece = 35;
      case 35:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_required_credit_card_data_piece(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<282>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .autofill_assistant.RequiredDataPiece required_billing_address_data_piece = 36;
      case 36:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_required_billing_address_data_piece(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<290>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .autofill_assistant.CollectUserDataProto.DataSource data_source = 38;
      case 38:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_data_source(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .autofill_assistant.DataOriginNoticeProto data_origin_notice = 39;
      case 39:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_data_origin_notice(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CollectUserDataProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.CollectUserDataProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string prompt = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_prompt(), target);
  }

  // optional string billing_address_name = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_billing_address_name(), target);
  }

  // optional string shipping_address_name = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_shipping_address_name(), target);
  }

  // optional bool request_payment_method = 4;
  if (cached_has_bits & 0x00040000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_request_payment_method(), target);
  }

  // optional .autofill_assistant.ContactDetailsProto contact_details = 5;
  if (cached_has_bits & 0x00000400u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::contact_details(this),
        _Internal::contact_details(this).GetCachedSize(), target, stream);
  }

  // repeated string supported_basic_card_networks = 6;
  for (int i = 0, n = this->_internal_supported_basic_card_networks_size(); i < n; i++) {
    const auto& s = this->_internal_supported_basic_card_networks(i);
    target = stream->WriteString(6, s, target);
  }

  // optional .autofill_assistant.CollectUserDataProto.TermsAndConditionsState terms_and_conditions_state = 8;
  if (cached_has_bits & 0x00020000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      8, this->_internal_terms_and_conditions_state(), target);
  }

  // optional bool request_terms_and_conditions = 9 [default = true];
  if (cached_has_bits & 0x00800000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(9, this->_internal_request_terms_and_conditions(), target);
  }

  // repeated .autofill_assistant.UserActionProto additional_actions = 11;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_additional_actions_size()); i < n; i++) {
    const auto& repfield = this->_internal_additional_actions(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(11, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional bool show_terms_as_checkbox = 12;
  if (cached_has_bits & 0x00080000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(12, this->_internal_show_terms_as_checkbox(), target);
  }

  // optional string accept_terms_and_conditions_text = 13;
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteStringMaybeAliased(
        13, this->_internal_accept_terms_and_conditions_text(), target);
  }

  // optional .autofill_assistant.LoginDetailsProto login_details = 16;
  if (cached_has_bits & 0x00000800u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(16, _Internal::login_details(this),
        _Internal::login_details(this).GetCachedSize(), target, stream);
  }

  // repeated .autofill_assistant.UserFormSectionProto additional_prepended_sections = 18;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_additional_prepended_sections_size()); i < n; i++) {
    const auto& repfield = this->_internal_additional_prepended_sections(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(18, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .autofill_assistant.UserFormSectionProto additional_appended_sections = 19;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_additional_appended_sections_size()); i < n; i++) {
    const auto& repfield = this->_internal_additional_appended_sections(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(19, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional string terms_require_review_text = 20;
  if (cached_has_bits & 0x00000010u) {
    target = stream->WriteStringMaybeAliased(
        20, this->_internal_terms_require_review_text(), target);
  }

  // optional string privacy_notice_text = 21;
  if (cached_has_bits & 0x00000020u) {
    target = stream->WriteStringMaybeAliased(
        21, this->_internal_privacy_notice_text(), target);
  }

  // optional .autofill_assistant.GenericUserInterfaceProto generic_user_interface_prepended = 22;
  if (cached_has_bits & 0x00001000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(22, _Internal::generic_user_interface_prepended(this),
        _Internal::generic_user_interface_prepended(this).GetCachedSize(), target, stream);
  }

  // optional string credit_card_expired_text = 23;
  if (cached_has_bits & 0x00000040u) {
    target = stream->WriteStringMaybeAliased(
        23, this->_internal_credit_card_expired_text(), target);
  }

  // optional string info_section_text = 24;
  if (cached_has_bits & 0x00000080u) {
    target = stream->WriteStringMaybeAliased(
        24, this->_internal_info_section_text(), target);
  }

  // optional .autofill_assistant.GenericUserInterfaceProto generic_user_interface_appended = 25;
  if (cached_has_bits & 0x00002000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(25, _Internal::generic_user_interface_appended(this),
        _Internal::generic_user_interface_appended(this).GetCachedSize(), target, stream);
  }

  // optional string additional_model_identifier_to_check = 27;
  if (cached_has_bits & 0x00000100u) {
    target = stream->WriteStringMaybeAliased(
        27, this->_internal_additional_model_identifier_to_check(), target);
  }

  // optional bool clear_previous_credit_card_selection = 28;
  if (cached_has_bits & 0x00200000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(28, this->_internal_clear_previous_credit_card_selection(), target);
  }

  // optional bool clear_previous_login_selection = 29;
  if (cached_has_bits & 0x00400000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(29, this->_internal_clear_previous_login_selection(), target);
  }

  // repeated string clear_previous_profile_selection = 30;
  for (int i = 0, n = this->_internal_clear_previous_profile_selection_size(); i < n; i++) {
    const auto& s = this->_internal_clear_previous_profile_selection(i);
    target = stream->WriteString(30, s, target);
  }

  // optional bool info_section_text_center = 31;
  if (cached_has_bits & 0x00100000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(31, this->_internal_info_section_text_center(), target);
  }

  // optional string shipping_address_section_title = 32;
  if (cached_has_bits & 0x00000200u) {
    target = stream->WriteStringMaybeAliased(
        32, this->_internal_shipping_address_section_title(), target);
  }

  // optional .autofill_assistant.ChipProto confirm_chip = 33;
  if (cached_has_bits & 0x00004000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(33, _Internal::confirm_chip(this),
        _Internal::confirm_chip(this).GetCachedSize(), target, stream);
  }

  // repeated .autofill_assistant.RequiredDataPiece required_shipping_address_data_piece = 34;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_required_shipping_address_data_piece_size()); i < n; i++) {
    const auto& repfield = this->_internal_required_shipping_address_data_piece(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(34, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .autofill_assistant.RequiredDataPiece required_credit_card_data_piece = 35;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_required_credit_card_data_piece_size()); i < n; i++) {
    const auto& repfield = this->_internal_required_credit_card_data_piece(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(35, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .autofill_assistant.RequiredDataPiece required_billing_address_data_piece = 36;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_required_billing_address_data_piece_size()); i < n; i++) {
    const auto& repfield = this->_internal_required_billing_address_data_piece(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(36, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional .autofill_assistant.CollectUserDataProto.DataSource data_source = 38;
  if (cached_has_bits & 0x00008000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(38, _Internal::data_source(this),
        _Internal::data_source(this).GetCachedSize(), target, stream);
  }

  // optional .autofill_assistant.DataOriginNoticeProto data_origin_notice = 39;
  if (cached_has_bits & 0x00010000u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(39, _Internal::data_origin_notice(this),
        _Internal::data_origin_notice(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.CollectUserDataProto)
  return target;
}

size_t CollectUserDataProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.CollectUserDataProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string supported_basic_card_networks = 6;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(supported_basic_card_networks_.size());
  for (int i = 0, n = supported_basic_card_networks_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      supported_basic_card_networks_.Get(i));
  }

  // repeated .autofill_assistant.UserActionProto additional_actions = 11;
  total_size += 1UL * this->_internal_additional_actions_size();
  for (const auto& msg : this->additional_actions_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .autofill_assistant.UserFormSectionProto additional_prepended_sections = 18;
  total_size += 2UL * this->_internal_additional_prepended_sections_size();
  for (const auto& msg : this->additional_prepended_sections_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .autofill_assistant.UserFormSectionProto additional_appended_sections = 19;
  total_size += 2UL * this->_internal_additional_appended_sections_size();
  for (const auto& msg : this->additional_appended_sections_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated string clear_previous_profile_selection = 30;
  total_size += 2 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(clear_previous_profile_selection_.size());
  for (int i = 0, n = clear_previous_profile_selection_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      clear_previous_profile_selection_.Get(i));
  }

  // repeated .autofill_assistant.RequiredDataPiece required_shipping_address_data_piece = 34;
  total_size += 2UL * this->_internal_required_shipping_address_data_piece_size();
  for (const auto& msg : this->required_shipping_address_data_piece_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .autofill_assistant.RequiredDataPiece required_credit_card_data_piece = 35;
  total_size += 2UL * this->_internal_required_credit_card_data_piece_size();
  for (const auto& msg : this->required_credit_card_data_piece_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .autofill_assistant.RequiredDataPiece required_billing_address_data_piece = 36;
  total_size += 2UL * this->_internal_required_billing_address_data_piece_size();
  for (const auto& msg : this->required_billing_address_data_piece_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string prompt = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_prompt());
    }

    // optional string billing_address_name = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_billing_address_name());
    }

    // optional string shipping_address_name = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_shipping_address_name());
    }

    // optional string accept_terms_and_conditions_text = 13;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_accept_terms_and_conditions_text());
    }

    // optional string terms_require_review_text = 20;
    if (cached_has_bits & 0x00000010u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_terms_require_review_text());
    }

    // optional string privacy_notice_text = 21;
    if (cached_has_bits & 0x00000020u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_privacy_notice_text());
    }

    // optional string credit_card_expired_text = 23;
    if (cached_has_bits & 0x00000040u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_credit_card_expired_text());
    }

    // optional string info_section_text = 24;
    if (cached_has_bits & 0x00000080u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_info_section_text());
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional string additional_model_identifier_to_check = 27;
    if (cached_has_bits & 0x00000100u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_additional_model_identifier_to_check());
    }

    // optional string shipping_address_section_title = 32;
    if (cached_has_bits & 0x00000200u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_shipping_address_section_title());
    }

    // optional .autofill_assistant.ContactDetailsProto contact_details = 5;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *contact_details_);
    }

    // optional .autofill_assistant.LoginDetailsProto login_details = 16;
    if (cached_has_bits & 0x00000800u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *login_details_);
    }

    // optional .autofill_assistant.GenericUserInterfaceProto generic_user_interface_prepended = 22;
    if (cached_has_bits & 0x00001000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *generic_user_interface_prepended_);
    }

    // optional .autofill_assistant.GenericUserInterfaceProto generic_user_interface_appended = 25;
    if (cached_has_bits & 0x00002000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *generic_user_interface_appended_);
    }

    // optional .autofill_assistant.ChipProto confirm_chip = 33;
    if (cached_has_bits & 0x00004000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *confirm_chip_);
    }

    // optional .autofill_assistant.CollectUserDataProto.DataSource data_source = 38;
    if (cached_has_bits & 0x00008000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *data_source_);
    }

  }
  if (cached_has_bits & 0x00ff0000u) {
    // optional .autofill_assistant.DataOriginNoticeProto data_origin_notice = 39;
    if (cached_has_bits & 0x00010000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *data_origin_notice_);
    }

    // optional .autofill_assistant.CollectUserDataProto.TermsAndConditionsState terms_and_conditions_state = 8;
    if (cached_has_bits & 0x00020000u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_terms_and_conditions_state());
    }

    // optional bool request_payment_method = 4;
    if (cached_has_bits & 0x00040000u) {
      total_size += 1 + 1;
    }

    // optional bool show_terms_as_checkbox = 12;
    if (cached_has_bits & 0x00080000u) {
      total_size += 1 + 1;
    }

    // optional bool info_section_text_center = 31;
    if (cached_has_bits & 0x00100000u) {
      total_size += 2 + 1;
    }

    // optional bool clear_previous_credit_card_selection = 28;
    if (cached_has_bits & 0x00200000u) {
      total_size += 2 + 1;
    }

    // optional bool clear_previous_login_selection = 29;
    if (cached_has_bits & 0x00400000u) {
      total_size += 2 + 1;
    }

    // optional bool request_terms_and_conditions = 9 [default = true];
    if (cached_has_bits & 0x00800000u) {
      total_size += 1 + 1;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CollectUserDataProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CollectUserDataProto*>(
      &from));
}

void CollectUserDataProto::MergeFrom(const CollectUserDataProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.CollectUserDataProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  supported_basic_card_networks_.MergeFrom(from.supported_basic_card_networks_);
  additional_actions_.MergeFrom(from.additional_actions_);
  additional_prepended_sections_.MergeFrom(from.additional_prepended_sections_);
  additional_appended_sections_.MergeFrom(from.additional_appended_sections_);
  clear_previous_profile_selection_.MergeFrom(from.clear_previous_profile_selection_);
  required_shipping_address_data_piece_.MergeFrom(from.required_shipping_address_data_piece_);
  required_credit_card_data_piece_.MergeFrom(from.required_credit_card_data_piece_);
  required_billing_address_data_piece_.MergeFrom(from.required_billing_address_data_piece_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_prompt(from._internal_prompt());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_billing_address_name(from._internal_billing_address_name());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_shipping_address_name(from._internal_shipping_address_name());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_set_accept_terms_and_conditions_text(from._internal_accept_terms_and_conditions_text());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_set_terms_require_review_text(from._internal_terms_require_review_text());
    }
    if (cached_has_bits & 0x00000020u) {
      _internal_set_privacy_notice_text(from._internal_privacy_notice_text());
    }
    if (cached_has_bits & 0x00000040u) {
      _internal_set_credit_card_expired_text(from._internal_credit_card_expired_text());
    }
    if (cached_has_bits & 0x00000080u) {
      _internal_set_info_section_text(from._internal_info_section_text());
    }
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      _internal_set_additional_model_identifier_to_check(from._internal_additional_model_identifier_to_check());
    }
    if (cached_has_bits & 0x00000200u) {
      _internal_set_shipping_address_section_title(from._internal_shipping_address_section_title());
    }
    if (cached_has_bits & 0x00000400u) {
      _internal_mutable_contact_details()->::autofill_assistant::ContactDetailsProto::MergeFrom(from._internal_contact_details());
    }
    if (cached_has_bits & 0x00000800u) {
      _internal_mutable_login_details()->::autofill_assistant::LoginDetailsProto::MergeFrom(from._internal_login_details());
    }
    if (cached_has_bits & 0x00001000u) {
      _internal_mutable_generic_user_interface_prepended()->::autofill_assistant::GenericUserInterfaceProto::MergeFrom(from._internal_generic_user_interface_prepended());
    }
    if (cached_has_bits & 0x00002000u) {
      _internal_mutable_generic_user_interface_appended()->::autofill_assistant::GenericUserInterfaceProto::MergeFrom(from._internal_generic_user_interface_appended());
    }
    if (cached_has_bits & 0x00004000u) {
      _internal_mutable_confirm_chip()->::autofill_assistant::ChipProto::MergeFrom(from._internal_confirm_chip());
    }
    if (cached_has_bits & 0x00008000u) {
      _internal_mutable_data_source()->::autofill_assistant::CollectUserDataProto_DataSource::MergeFrom(from._internal_data_source());
    }
  }
  if (cached_has_bits & 0x00ff0000u) {
    if (cached_has_bits & 0x00010000u) {
      _internal_mutable_data_origin_notice()->::autofill_assistant::DataOriginNoticeProto::MergeFrom(from._internal_data_origin_notice());
    }
    if (cached_has_bits & 0x00020000u) {
      terms_and_conditions_state_ = from.terms_and_conditions_state_;
    }
    if (cached_has_bits & 0x00040000u) {
      request_payment_method_ = from.request_payment_method_;
    }
    if (cached_has_bits & 0x00080000u) {
      show_terms_as_checkbox_ = from.show_terms_as_checkbox_;
    }
    if (cached_has_bits & 0x00100000u) {
      info_section_text_center_ = from.info_section_text_center_;
    }
    if (cached_has_bits & 0x00200000u) {
      clear_previous_credit_card_selection_ = from.clear_previous_credit_card_selection_;
    }
    if (cached_has_bits & 0x00400000u) {
      clear_previous_login_selection_ = from.clear_previous_login_selection_;
    }
    if (cached_has_bits & 0x00800000u) {
      request_terms_and_conditions_ = from.request_terms_and_conditions_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CollectUserDataProto::CopyFrom(const CollectUserDataProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.CollectUserDataProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CollectUserDataProto::IsInitialized() const {
  return true;
}

void CollectUserDataProto::InternalSwap(CollectUserDataProto* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  supported_basic_card_networks_.InternalSwap(&other->supported_basic_card_networks_);
  additional_actions_.InternalSwap(&other->additional_actions_);
  additional_prepended_sections_.InternalSwap(&other->additional_prepended_sections_);
  additional_appended_sections_.InternalSwap(&other->additional_appended_sections_);
  clear_previous_profile_selection_.InternalSwap(&other->clear_previous_profile_selection_);
  required_shipping_address_data_piece_.InternalSwap(&other->required_shipping_address_data_piece_);
  required_credit_card_data_piece_.InternalSwap(&other->required_credit_card_data_piece_);
  required_billing_address_data_piece_.InternalSwap(&other->required_billing_address_data_piece_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &prompt_, lhs_arena,
      &other->prompt_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &billing_address_name_, lhs_arena,
      &other->billing_address_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &shipping_address_name_, lhs_arena,
      &other->shipping_address_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &accept_terms_and_conditions_text_, lhs_arena,
      &other->accept_terms_and_conditions_text_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &terms_require_review_text_, lhs_arena,
      &other->terms_require_review_text_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &privacy_notice_text_, lhs_arena,
      &other->privacy_notice_text_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &credit_card_expired_text_, lhs_arena,
      &other->credit_card_expired_text_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &info_section_text_, lhs_arena,
      &other->info_section_text_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &additional_model_identifier_to_check_, lhs_arena,
      &other->additional_model_identifier_to_check_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &shipping_address_section_title_, lhs_arena,
      &other->shipping_address_section_title_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CollectUserDataProto, clear_previous_login_selection_)
      + sizeof(CollectUserDataProto::clear_previous_login_selection_)
      - PROTOBUF_FIELD_OFFSET(CollectUserDataProto, contact_details_)>(
          reinterpret_cast<char*>(&contact_details_),
          reinterpret_cast<char*>(&other->contact_details_));
  swap(request_terms_and_conditions_, other->request_terms_and_conditions_);
}

std::string CollectUserDataProto::GetTypeName() const {
  return "autofill_assistant.CollectUserDataProto";
}


// ===================================================================

class StopProto::_Internal {
 public:
  using HasBits = decltype(std::declval<StopProto>()._has_bits_);
  static void set_has_close_cct(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_show_feedback_chip(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

StopProto::StopProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.StopProto)
}
StopProto::StopProto(const StopProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&close_cct_, &from.close_cct_,
    static_cast<size_t>(reinterpret_cast<char*>(&show_feedback_chip_) -
    reinterpret_cast<char*>(&close_cct_)) + sizeof(show_feedback_chip_));
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.StopProto)
}

inline void StopProto::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&close_cct_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&show_feedback_chip_) -
    reinterpret_cast<char*>(&close_cct_)) + sizeof(show_feedback_chip_));
}

StopProto::~StopProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.StopProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StopProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void StopProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void StopProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.StopProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&close_cct_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&show_feedback_chip_) -
      reinterpret_cast<char*>(&close_cct_)) + sizeof(show_feedback_chip_));
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* StopProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool close_cct = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_close_cct(&has_bits);
          close_cct_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool show_feedback_chip = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_show_feedback_chip(&has_bits);
          show_feedback_chip_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StopProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.StopProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bool close_cct = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_close_cct(), target);
  }

  // optional bool show_feedback_chip = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_show_feedback_chip(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.StopProto)
  return target;
}

size_t StopProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.StopProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional bool close_cct = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 1;
    }

    // optional bool show_feedback_chip = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void StopProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const StopProto*>(
      &from));
}

void StopProto::MergeFrom(const StopProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.StopProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      close_cct_ = from.close_cct_;
    }
    if (cached_has_bits & 0x00000002u) {
      show_feedback_chip_ = from.show_feedback_chip_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void StopProto::CopyFrom(const StopProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.StopProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StopProto::IsInitialized() const {
  return true;
}

void StopProto::InternalSwap(StopProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(StopProto, show_feedback_chip_)
      + sizeof(StopProto::show_feedback_chip_)
      - PROTOBUF_FIELD_OFFSET(StopProto, close_cct_)>(
          reinterpret_cast<char*>(&close_cct_),
          reinterpret_cast<char*>(&other->close_cct_));
}

std::string StopProto::GetTypeName() const {
  return "autofill_assistant.StopProto";
}


// ===================================================================

class DetailsChangesProto::_Internal {
 public:
  using HasBits = decltype(std::declval<DetailsChangesProto>()._has_bits_);
  static void set_has_user_approval_required(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_highlight_title(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_highlight_line1(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_highlight_line2(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_highlight_line3(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

DetailsChangesProto::DetailsChangesProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.DetailsChangesProto)
}
DetailsChangesProto::DetailsChangesProto(const DetailsChangesProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&user_approval_required_, &from.user_approval_required_,
    static_cast<size_t>(reinterpret_cast<char*>(&highlight_line3_) -
    reinterpret_cast<char*>(&user_approval_required_)) + sizeof(highlight_line3_));
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.DetailsChangesProto)
}

inline void DetailsChangesProto::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&user_approval_required_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&highlight_line3_) -
    reinterpret_cast<char*>(&user_approval_required_)) + sizeof(highlight_line3_));
}

DetailsChangesProto::~DetailsChangesProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.DetailsChangesProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DetailsChangesProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void DetailsChangesProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void DetailsChangesProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.DetailsChangesProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&user_approval_required_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&highlight_line3_) -
        reinterpret_cast<char*>(&user_approval_required_)) + sizeof(highlight_line3_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* DetailsChangesProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool user_approval_required = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_user_approval_required(&has_bits);
          user_approval_required_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool highlight_title = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_highlight_title(&has_bits);
          highlight_title_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool highlight_line1 = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_highlight_line1(&has_bits);
          highlight_line1_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool highlight_line2 = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_highlight_line2(&has_bits);
          highlight_line2_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool highlight_line3 = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_highlight_line3(&has_bits);
          highlight_line3_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DetailsChangesProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.DetailsChangesProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bool user_approval_required = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_user_approval_required(), target);
  }

  // optional bool highlight_title = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_highlight_title(), target);
  }

  // optional bool highlight_line1 = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_highlight_line1(), target);
  }

  // optional bool highlight_line2 = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_highlight_line2(), target);
  }

  // optional bool highlight_line3 = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_highlight_line3(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.DetailsChangesProto)
  return target;
}

size_t DetailsChangesProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.DetailsChangesProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional bool user_approval_required = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 1;
    }

    // optional bool highlight_title = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

    // optional bool highlight_line1 = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

    // optional bool highlight_line2 = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

    // optional bool highlight_line3 = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 1;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DetailsChangesProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DetailsChangesProto*>(
      &from));
}

void DetailsChangesProto::MergeFrom(const DetailsChangesProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.DetailsChangesProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      user_approval_required_ = from.user_approval_required_;
    }
    if (cached_has_bits & 0x00000002u) {
      highlight_title_ = from.highlight_title_;
    }
    if (cached_has_bits & 0x00000004u) {
      highlight_line1_ = from.highlight_line1_;
    }
    if (cached_has_bits & 0x00000008u) {
      highlight_line2_ = from.highlight_line2_;
    }
    if (cached_has_bits & 0x00000010u) {
      highlight_line3_ = from.highlight_line3_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DetailsChangesProto::CopyFrom(const DetailsChangesProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.DetailsChangesProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DetailsChangesProto::IsInitialized() const {
  return true;
}

void DetailsChangesProto::InternalSwap(DetailsChangesProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DetailsChangesProto, highlight_line3_)
      + sizeof(DetailsChangesProto::highlight_line3_)
      - PROTOBUF_FIELD_OFFSET(DetailsChangesProto, user_approval_required_)>(
          reinterpret_cast<char*>(&user_approval_required_),
          reinterpret_cast<char*>(&other->user_approval_required_));
}

std::string DetailsChangesProto::GetTypeName() const {
  return "autofill_assistant.DetailsChangesProto";
}


// ===================================================================

class DetailsProto_ImageClickthroughData::_Internal {
 public:
  using HasBits = decltype(std::declval<DetailsProto_ImageClickthroughData>()._has_bits_);
  static void set_has_allow_clickthrough(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_description(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_positive_text(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_negative_text(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_clickthrough_url(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

DetailsProto_ImageClickthroughData::DetailsProto_ImageClickthroughData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.DetailsProto.ImageClickthroughData)
}
DetailsProto_ImageClickthroughData::DetailsProto_ImageClickthroughData(const DetailsProto_ImageClickthroughData& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  description_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    description_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_description()) {
    description_.Set(from._internal_description(), 
      GetArenaForAllocation());
  }
  positive_text_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    positive_text_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_positive_text()) {
    positive_text_.Set(from._internal_positive_text(), 
      GetArenaForAllocation());
  }
  negative_text_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    negative_text_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_negative_text()) {
    negative_text_.Set(from._internal_negative_text(), 
      GetArenaForAllocation());
  }
  clickthrough_url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    clickthrough_url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_clickthrough_url()) {
    clickthrough_url_.Set(from._internal_clickthrough_url(), 
      GetArenaForAllocation());
  }
  allow_clickthrough_ = from.allow_clickthrough_;
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.DetailsProto.ImageClickthroughData)
}

inline void DetailsProto_ImageClickthroughData::SharedCtor() {
description_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  description_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
positive_text_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  positive_text_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
negative_text_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  negative_text_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
clickthrough_url_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  clickthrough_url_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
allow_clickthrough_ = false;
}

DetailsProto_ImageClickthroughData::~DetailsProto_ImageClickthroughData() {
  // @@protoc_insertion_point(destructor:autofill_assistant.DetailsProto.ImageClickthroughData)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DetailsProto_ImageClickthroughData::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  description_.Destroy();
  positive_text_.Destroy();
  negative_text_.Destroy();
  clickthrough_url_.Destroy();
}

void DetailsProto_ImageClickthroughData::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void DetailsProto_ImageClickthroughData::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.DetailsProto.ImageClickthroughData)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      description_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      positive_text_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      negative_text_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      clickthrough_url_.ClearNonDefaultToEmpty();
    }
  }
  allow_clickthrough_ = false;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* DetailsProto_ImageClickthroughData::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool allow_clickthrough = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_allow_clickthrough(&has_bits);
          allow_clickthrough_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string description = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_description();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string positive_text = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_positive_text();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string negative_text = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_negative_text();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string clickthrough_url = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_clickthrough_url();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DetailsProto_ImageClickthroughData::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.DetailsProto.ImageClickthroughData)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bool allow_clickthrough = 1;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_allow_clickthrough(), target);
  }

  // optional string description = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_description(), target);
  }

  // optional string positive_text = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_positive_text(), target);
  }

  // optional string negative_text = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_negative_text(), target);
  }

  // optional string clickthrough_url = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_clickthrough_url(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.DetailsProto.ImageClickthroughData)
  return target;
}

size_t DetailsProto_ImageClickthroughData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.DetailsProto.ImageClickthroughData)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional string description = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_description());
    }

    // optional string positive_text = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_positive_text());
    }

    // optional string negative_text = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_negative_text());
    }

    // optional string clickthrough_url = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_clickthrough_url());
    }

    // optional bool allow_clickthrough = 1;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 1;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DetailsProto_ImageClickthroughData::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DetailsProto_ImageClickthroughData*>(
      &from));
}

void DetailsProto_ImageClickthroughData::MergeFrom(const DetailsProto_ImageClickthroughData& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.DetailsProto.ImageClickthroughData)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_description(from._internal_description());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_positive_text(from._internal_positive_text());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_negative_text(from._internal_negative_text());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_set_clickthrough_url(from._internal_clickthrough_url());
    }
    if (cached_has_bits & 0x00000010u) {
      allow_clickthrough_ = from.allow_clickthrough_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DetailsProto_ImageClickthroughData::CopyFrom(const DetailsProto_ImageClickthroughData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.DetailsProto.ImageClickthroughData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DetailsProto_ImageClickthroughData::IsInitialized() const {
  return true;
}

void DetailsProto_ImageClickthroughData::InternalSwap(DetailsProto_ImageClickthroughData* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &description_, lhs_arena,
      &other->description_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &positive_text_, lhs_arena,
      &other->positive_text_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &negative_text_, lhs_arena,
      &other->negative_text_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &clickthrough_url_, lhs_arena,
      &other->clickthrough_url_, rhs_arena
  );
  swap(allow_clickthrough_, other->allow_clickthrough_);
}

std::string DetailsProto_ImageClickthroughData::GetTypeName() const {
  return "autofill_assistant.DetailsProto.ImageClickthroughData";
}


// ===================================================================

class DetailsProto_PlaceholdersConfiguration::_Internal {
 public:
  using HasBits = decltype(std::declval<DetailsProto_PlaceholdersConfiguration>()._has_bits_);
  static void set_has_show_image_placeholder(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_show_title_placeholder(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_show_description_line_1_placeholder(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_show_description_line_2_placeholder(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_show_description_line_3_placeholder(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

DetailsProto_PlaceholdersConfiguration::DetailsProto_PlaceholdersConfiguration(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.DetailsProto.PlaceholdersConfiguration)
}
DetailsProto_PlaceholdersConfiguration::DetailsProto_PlaceholdersConfiguration(const DetailsProto_PlaceholdersConfiguration& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&show_image_placeholder_, &from.show_image_placeholder_,
    static_cast<size_t>(reinterpret_cast<char*>(&show_description_line_3_placeholder_) -
    reinterpret_cast<char*>(&show_image_placeholder_)) + sizeof(show_description_line_3_placeholder_));
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.DetailsProto.PlaceholdersConfiguration)
}

inline void DetailsProto_PlaceholdersConfiguration::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&show_image_placeholder_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&show_description_line_3_placeholder_) -
    reinterpret_cast<char*>(&show_image_placeholder_)) + sizeof(show_description_line_3_placeholder_));
}

DetailsProto_PlaceholdersConfiguration::~DetailsProto_PlaceholdersConfiguration() {
  // @@protoc_insertion_point(destructor:autofill_assistant.DetailsProto.PlaceholdersConfiguration)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DetailsProto_PlaceholdersConfiguration::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void DetailsProto_PlaceholdersConfiguration::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void DetailsProto_PlaceholdersConfiguration::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.DetailsProto.PlaceholdersConfiguration)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&show_image_placeholder_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&show_description_line_3_placeholder_) -
        reinterpret_cast<char*>(&show_image_placeholder_)) + sizeof(show_description_line_3_placeholder_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* DetailsProto_PlaceholdersConfiguration::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool show_image_placeholder = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_show_image_placeholder(&has_bits);
          show_image_placeholder_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool show_title_placeholder = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_show_title_placeholder(&has_bits);
          show_title_placeholder_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool show_description_line_1_placeholder = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_show_description_line_1_placeholder(&has_bits);
          show_description_line_1_placeholder_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool show_description_line_2_placeholder = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_show_description_line_2_placeholder(&has_bits);
          show_description_line_2_placeholder_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool show_description_line_3_placeholder = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_show_description_line_3_placeholder(&has_bits);
          show_description_line_3_placeholder_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DetailsProto_PlaceholdersConfiguration::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.DetailsProto.PlaceholdersConfiguration)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bool show_image_placeholder = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_show_image_placeholder(), target);
  }

  // optional bool show_title_placeholder = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_show_title_placeholder(), target);
  }

  // optional bool show_description_line_1_placeholder = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_show_description_line_1_placeholder(), target);
  }

  // optional bool show_description_line_2_placeholder = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_show_description_line_2_placeholder(), target);
  }

  // optional bool show_description_line_3_placeholder = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_show_description_line_3_placeholder(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.DetailsProto.PlaceholdersConfiguration)
  return target;
}

size_t DetailsProto_PlaceholdersConfiguration::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.DetailsProto.PlaceholdersConfiguration)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional bool show_image_placeholder = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 1;
    }

    // optional bool show_title_placeholder = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

    // optional bool show_description_line_1_placeholder = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

    // optional bool show_description_line_2_placeholder = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

    // optional bool show_description_line_3_placeholder = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 1;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DetailsProto_PlaceholdersConfiguration::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DetailsProto_PlaceholdersConfiguration*>(
      &from));
}

void DetailsProto_PlaceholdersConfiguration::MergeFrom(const DetailsProto_PlaceholdersConfiguration& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.DetailsProto.PlaceholdersConfiguration)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      show_image_placeholder_ = from.show_image_placeholder_;
    }
    if (cached_has_bits & 0x00000002u) {
      show_title_placeholder_ = from.show_title_placeholder_;
    }
    if (cached_has_bits & 0x00000004u) {
      show_description_line_1_placeholder_ = from.show_description_line_1_placeholder_;
    }
    if (cached_has_bits & 0x00000008u) {
      show_description_line_2_placeholder_ = from.show_description_line_2_placeholder_;
    }
    if (cached_has_bits & 0x00000010u) {
      show_description_line_3_placeholder_ = from.show_description_line_3_placeholder_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DetailsProto_PlaceholdersConfiguration::CopyFrom(const DetailsProto_PlaceholdersConfiguration& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.DetailsProto.PlaceholdersConfiguration)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DetailsProto_PlaceholdersConfiguration::IsInitialized() const {
  return true;
}

void DetailsProto_PlaceholdersConfiguration::InternalSwap(DetailsProto_PlaceholdersConfiguration* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DetailsProto_PlaceholdersConfiguration, show_description_line_3_placeholder_)
      + sizeof(DetailsProto_PlaceholdersConfiguration::show_description_line_3_placeholder_)
      - PROTOBUF_FIELD_OFFSET(DetailsProto_PlaceholdersConfiguration, show_image_placeholder_)>(
          reinterpret_cast<char*>(&show_image_placeholder_),
          reinterpret_cast<char*>(&other->show_image_placeholder_));
}

std::string DetailsProto_PlaceholdersConfiguration::GetTypeName() const {
  return "autofill_assistant.DetailsProto.PlaceholdersConfiguration";
}


// ===================================================================

class DetailsProto::_Internal {
 public:
  using HasBits = decltype(std::declval<DetailsProto>()._has_bits_);
  static void set_has_title(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_image_url(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_image_accessibility_hint(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static const ::autofill_assistant::DetailsProto_ImageClickthroughData& image_clickthrough_data(const DetailsProto* msg);
  static void set_has_image_clickthrough_data(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_total_price_label(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_total_price(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_description_line_1(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_description_line_2(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_description_line_3(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static const ::autofill_assistant::DateTimeProto& datetime(const DetailsProto* msg);
  static void set_has_datetime(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_description(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::autofill_assistant::DetailsProto_PlaceholdersConfiguration& placeholders(const DetailsProto* msg);
  static void set_has_placeholders(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
};

const ::autofill_assistant::DetailsProto_ImageClickthroughData&
DetailsProto::_Internal::image_clickthrough_data(const DetailsProto* msg) {
  return *msg->image_clickthrough_data_;
}
const ::autofill_assistant::DateTimeProto&
DetailsProto::_Internal::datetime(const DetailsProto* msg) {
  return *msg->datetime_;
}
const ::autofill_assistant::DetailsProto_PlaceholdersConfiguration&
DetailsProto::_Internal::placeholders(const DetailsProto* msg) {
  return *msg->placeholders_;
}
void DetailsProto::clear_datetime() {
  if (datetime_ != nullptr) datetime_->Clear();
  _has_bits_[0] &= ~0x00000200u;
}
DetailsProto::DetailsProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.DetailsProto)
}
DetailsProto::DetailsProto(const DetailsProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  title_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    title_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_title()) {
    title_.Set(from._internal_title(), 
      GetArenaForAllocation());
  }
  image_url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    image_url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_image_url()) {
    image_url_.Set(from._internal_image_url(), 
      GetArenaForAllocation());
  }
  description_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    description_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_description()) {
    description_.Set(from._internal_description(), 
      GetArenaForAllocation());
  }
  total_price_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    total_price_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_total_price()) {
    total_price_.Set(from._internal_total_price(), 
      GetArenaForAllocation());
  }
  description_line_1_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    description_line_1_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_description_line_1()) {
    description_line_1_.Set(from._internal_description_line_1(), 
      GetArenaForAllocation());
  }
  description_line_2_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    description_line_2_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_description_line_2()) {
    description_line_2_.Set(from._internal_description_line_2(), 
      GetArenaForAllocation());
  }
  total_price_label_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    total_price_label_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_total_price_label()) {
    total_price_label_.Set(from._internal_total_price_label(), 
      GetArenaForAllocation());
  }
  description_line_3_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    description_line_3_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_description_line_3()) {
    description_line_3_.Set(from._internal_description_line_3(), 
      GetArenaForAllocation());
  }
  image_accessibility_hint_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    image_accessibility_hint_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_image_accessibility_hint()) {
    image_accessibility_hint_.Set(from._internal_image_accessibility_hint(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_datetime()) {
    datetime_ = new ::autofill_assistant::DateTimeProto(*from.datetime_);
  } else {
    datetime_ = nullptr;
  }
  if (from._internal_has_image_clickthrough_data()) {
    image_clickthrough_data_ = new ::autofill_assistant::DetailsProto_ImageClickthroughData(*from.image_clickthrough_data_);
  } else {
    image_clickthrough_data_ = nullptr;
  }
  if (from._internal_has_placeholders()) {
    placeholders_ = new ::autofill_assistant::DetailsProto_PlaceholdersConfiguration(*from.placeholders_);
  } else {
    placeholders_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.DetailsProto)
}

inline void DetailsProto::SharedCtor() {
title_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  title_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
image_url_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  image_url_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
description_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  description_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
total_price_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  total_price_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
description_line_1_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  description_line_1_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
description_line_2_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  description_line_2_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
total_price_label_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  total_price_label_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
description_line_3_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  description_line_3_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
image_accessibility_hint_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  image_accessibility_hint_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&datetime_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&placeholders_) -
    reinterpret_cast<char*>(&datetime_)) + sizeof(placeholders_));
}

DetailsProto::~DetailsProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.DetailsProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DetailsProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  title_.Destroy();
  image_url_.Destroy();
  description_.Destroy();
  total_price_.Destroy();
  description_line_1_.Destroy();
  description_line_2_.Destroy();
  total_price_label_.Destroy();
  description_line_3_.Destroy();
  image_accessibility_hint_.Destroy();
  if (this != internal_default_instance()) delete datetime_;
  if (this != internal_default_instance()) delete image_clickthrough_data_;
  if (this != internal_default_instance()) delete placeholders_;
}

void DetailsProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void DetailsProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.DetailsProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      title_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      image_url_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      description_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      total_price_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      description_line_1_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000020u) {
      description_line_2_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000040u) {
      total_price_label_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000080u) {
      description_line_3_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x00000f00u) {
    if (cached_has_bits & 0x00000100u) {
      image_accessibility_hint_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000200u) {
      GOOGLE_DCHECK(datetime_ != nullptr);
      datetime_->Clear();
    }
    if (cached_has_bits & 0x00000400u) {
      GOOGLE_DCHECK(image_clickthrough_data_ != nullptr);
      image_clickthrough_data_->Clear();
    }
    if (cached_has_bits & 0x00000800u) {
      GOOGLE_DCHECK(placeholders_ != nullptr);
      placeholders_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* DetailsProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string title = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_title();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string image_url = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_image_url();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .autofill_assistant.DateTimeProto datetime = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_datetime(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string description = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_description();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string total_price = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_total_price();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string description_line_1 = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_description_line_1();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string description_line_2 = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          auto str = _internal_mutable_description_line_2();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string total_price_label = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          auto str = _internal_mutable_total_price_label();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .autofill_assistant.DetailsProto.ImageClickthroughData image_clickthrough_data = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          ptr = ctx->ParseMessage(_internal_mutable_image_clickthrough_data(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string description_line_3 = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          auto str = _internal_mutable_description_line_3();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string image_accessibility_hint = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 114)) {
          auto str = _internal_mutable_image_accessibility_hint();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .autofill_assistant.DetailsProto.PlaceholdersConfiguration placeholders = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 122)) {
          ptr = ctx->ParseMessage(_internal_mutable_placeholders(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DetailsProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.DetailsProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string title = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_title(), target);
  }

  // optional string image_url = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_image_url(), target);
  }

  // optional .autofill_assistant.DateTimeProto datetime = 3;
  if (cached_has_bits & 0x00000200u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::datetime(this),
        _Internal::datetime(this).GetCachedSize(), target, stream);
  }

  // optional string description = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_description(), target);
  }

  // optional string total_price = 6;
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_total_price(), target);
  }

  // optional string description_line_1 = 7;
  if (cached_has_bits & 0x00000010u) {
    target = stream->WriteStringMaybeAliased(
        7, this->_internal_description_line_1(), target);
  }

  // optional string description_line_2 = 8;
  if (cached_has_bits & 0x00000020u) {
    target = stream->WriteStringMaybeAliased(
        8, this->_internal_description_line_2(), target);
  }

  // optional string total_price_label = 9;
  if (cached_has_bits & 0x00000040u) {
    target = stream->WriteStringMaybeAliased(
        9, this->_internal_total_price_label(), target);
  }

  // optional .autofill_assistant.DetailsProto.ImageClickthroughData image_clickthrough_data = 12;
  if (cached_has_bits & 0x00000400u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(12, _Internal::image_clickthrough_data(this),
        _Internal::image_clickthrough_data(this).GetCachedSize(), target, stream);
  }

  // optional string description_line_3 = 13;
  if (cached_has_bits & 0x00000080u) {
    target = stream->WriteStringMaybeAliased(
        13, this->_internal_description_line_3(), target);
  }

  // optional string image_accessibility_hint = 14;
  if (cached_has_bits & 0x00000100u) {
    target = stream->WriteStringMaybeAliased(
        14, this->_internal_image_accessibility_hint(), target);
  }

  // optional .autofill_assistant.DetailsProto.PlaceholdersConfiguration placeholders = 15;
  if (cached_has_bits & 0x00000800u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(15, _Internal::placeholders(this),
        _Internal::placeholders(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.DetailsProto)
  return target;
}

size_t DetailsProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.DetailsProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string title = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_title());
    }

    // optional string image_url = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_image_url());
    }

    // optional string description = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_description());
    }

    // optional string total_price = 6;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_total_price());
    }

    // optional string description_line_1 = 7;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_description_line_1());
    }

    // optional string description_line_2 = 8;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_description_line_2());
    }

    // optional string total_price_label = 9;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_total_price_label());
    }

    // optional string description_line_3 = 13;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_description_line_3());
    }

  }
  if (cached_has_bits & 0x00000f00u) {
    // optional string image_accessibility_hint = 14;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_image_accessibility_hint());
    }

    // optional .autofill_assistant.DateTimeProto datetime = 3;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *datetime_);
    }

    // optional .autofill_assistant.DetailsProto.ImageClickthroughData image_clickthrough_data = 12;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *image_clickthrough_data_);
    }

    // optional .autofill_assistant.DetailsProto.PlaceholdersConfiguration placeholders = 15;
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *placeholders_);
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DetailsProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DetailsProto*>(
      &from));
}

void DetailsProto::MergeFrom(const DetailsProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.DetailsProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_title(from._internal_title());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_image_url(from._internal_image_url());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_description(from._internal_description());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_set_total_price(from._internal_total_price());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_set_description_line_1(from._internal_description_line_1());
    }
    if (cached_has_bits & 0x00000020u) {
      _internal_set_description_line_2(from._internal_description_line_2());
    }
    if (cached_has_bits & 0x00000040u) {
      _internal_set_total_price_label(from._internal_total_price_label());
    }
    if (cached_has_bits & 0x00000080u) {
      _internal_set_description_line_3(from._internal_description_line_3());
    }
  }
  if (cached_has_bits & 0x00000f00u) {
    if (cached_has_bits & 0x00000100u) {
      _internal_set_image_accessibility_hint(from._internal_image_accessibility_hint());
    }
    if (cached_has_bits & 0x00000200u) {
      _internal_mutable_datetime()->::autofill_assistant::DateTimeProto::MergeFrom(from._internal_datetime());
    }
    if (cached_has_bits & 0x00000400u) {
      _internal_mutable_image_clickthrough_data()->::autofill_assistant::DetailsProto_ImageClickthroughData::MergeFrom(from._internal_image_clickthrough_data());
    }
    if (cached_has_bits & 0x00000800u) {
      _internal_mutable_placeholders()->::autofill_assistant::DetailsProto_PlaceholdersConfiguration::MergeFrom(from._internal_placeholders());
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DetailsProto::CopyFrom(const DetailsProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.DetailsProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DetailsProto::IsInitialized() const {
  return true;
}

void DetailsProto::InternalSwap(DetailsProto* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &title_, lhs_arena,
      &other->title_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &image_url_, lhs_arena,
      &other->image_url_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &description_, lhs_arena,
      &other->description_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &total_price_, lhs_arena,
      &other->total_price_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &description_line_1_, lhs_arena,
      &other->description_line_1_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &description_line_2_, lhs_arena,
      &other->description_line_2_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &total_price_label_, lhs_arena,
      &other->total_price_label_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &description_line_3_, lhs_arena,
      &other->description_line_3_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &image_accessibility_hint_, lhs_arena,
      &other->image_accessibility_hint_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DetailsProto, placeholders_)
      + sizeof(DetailsProto::placeholders_)
      - PROTOBUF_FIELD_OFFSET(DetailsProto, datetime_)>(
          reinterpret_cast<char*>(&datetime_),
          reinterpret_cast<char*>(&other->datetime_));
}

std::string DetailsProto::GetTypeName() const {
  return "autofill_assistant.DetailsProto";
}


// ===================================================================

class ShowDetailsProto::_Internal {
 public:
  using HasBits = decltype(std::declval<ShowDetailsProto>()._has_bits_);
  static const ::autofill_assistant::DetailsProto& details(const ShowDetailsProto* msg);
  static const ::autofill_assistant::DetailsChangesProto& change_flags(const ShowDetailsProto* msg);
  static void set_has_change_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_append(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_delay_ms(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::autofill_assistant::DetailsProto&
ShowDetailsProto::_Internal::details(const ShowDetailsProto* msg) {
  return *msg->data_to_show_.details_;
}
const ::autofill_assistant::DetailsChangesProto&
ShowDetailsProto::_Internal::change_flags(const ShowDetailsProto* msg) {
  return *msg->change_flags_;
}
void ShowDetailsProto::set_allocated_details(::autofill_assistant::DetailsProto* details) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_data_to_show();
  if (details) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(details);
    if (message_arena != submessage_arena) {
      details = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, details, submessage_arena);
    }
    set_has_details();
    data_to_show_.details_ = details;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ShowDetailsProto.details)
}
ShowDetailsProto::ShowDetailsProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.ShowDetailsProto)
}
ShowDetailsProto::ShowDetailsProto(const ShowDetailsProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_change_flags()) {
    change_flags_ = new ::autofill_assistant::DetailsChangesProto(*from.change_flags_);
  } else {
    change_flags_ = nullptr;
  }
  ::memcpy(&append_, &from.append_,
    static_cast<size_t>(reinterpret_cast<char*>(&delay_ms_) -
    reinterpret_cast<char*>(&append_)) + sizeof(delay_ms_));
  clear_has_data_to_show();
  switch (from.data_to_show_case()) {
    case kDetails: {
      _internal_mutable_details()->::autofill_assistant::DetailsProto::MergeFrom(from._internal_details());
      break;
    }
    case kContactDetails: {
      _internal_set_contact_details(from._internal_contact_details());
      break;
    }
    case kCreditCard: {
      _internal_set_credit_card(from._internal_credit_card());
      break;
    }
    case kShippingAddress: {
      _internal_set_shipping_address(from._internal_shipping_address());
      break;
    }
    case DATA_TO_SHOW_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.ShowDetailsProto)
}

inline void ShowDetailsProto::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&change_flags_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&delay_ms_) -
    reinterpret_cast<char*>(&change_flags_)) + sizeof(delay_ms_));
clear_has_data_to_show();
}

ShowDetailsProto::~ShowDetailsProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.ShowDetailsProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ShowDetailsProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete change_flags_;
  if (has_data_to_show()) {
    clear_data_to_show();
  }
}

void ShowDetailsProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ShowDetailsProto::clear_data_to_show() {
// @@protoc_insertion_point(one_of_clear_start:autofill_assistant.ShowDetailsProto)
  switch (data_to_show_case()) {
    case kDetails: {
      if (GetArenaForAllocation() == nullptr) {
        delete data_to_show_.details_;
      }
      break;
    }
    case kContactDetails: {
      data_to_show_.contact_details_.Destroy();
      break;
    }
    case kCreditCard: {
      // No need to clear
      break;
    }
    case kShippingAddress: {
      data_to_show_.shipping_address_.Destroy();
      break;
    }
    case DATA_TO_SHOW_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = DATA_TO_SHOW_NOT_SET;
}


void ShowDetailsProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.ShowDetailsProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(change_flags_ != nullptr);
    change_flags_->Clear();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&append_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&delay_ms_) -
        reinterpret_cast<char*>(&append_)) + sizeof(delay_ms_));
  }
  clear_data_to_show();
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ShowDetailsProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .autofill_assistant.DetailsProto details = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_details(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .autofill_assistant.DetailsChangesProto change_flags = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_change_flags(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string contact_details = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_contact_details();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool credit_card = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _internal_set_credit_card(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string shipping_address = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_shipping_address();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool append = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_append(&has_bits);
          append_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 delay_ms = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_delay_ms(&has_bits);
          delay_ms_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ShowDetailsProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.ShowDetailsProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .autofill_assistant.DetailsProto details = 1;
  if (_internal_has_details()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::details(this),
        _Internal::details(this).GetCachedSize(), target, stream);
  }

  cached_has_bits = _has_bits_[0];
  // optional .autofill_assistant.DetailsChangesProto change_flags = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::change_flags(this),
        _Internal::change_flags(this).GetCachedSize(), target, stream);
  }

  switch (data_to_show_case()) {
    case kContactDetails: {
      target = stream->WriteStringMaybeAliased(
          3, this->_internal_contact_details(), target);
      break;
    }
    case kCreditCard: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_credit_card(), target);
      break;
    }
    case kShippingAddress: {
      target = stream->WriteStringMaybeAliased(
          5, this->_internal_shipping_address(), target);
      break;
    }
    default: ;
  }
  // optional bool append = 6;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(6, this->_internal_append(), target);
  }

  // optional int32 delay_ms = 7;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(7, this->_internal_delay_ms(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.ShowDetailsProto)
  return target;
}

size_t ShowDetailsProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.ShowDetailsProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .autofill_assistant.DetailsChangesProto change_flags = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *change_flags_);
    }

    // optional bool append = 6;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

    // optional int32 delay_ms = 7;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_delay_ms());
    }

  }
  switch (data_to_show_case()) {
    // .autofill_assistant.DetailsProto details = 1;
    case kDetails: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *data_to_show_.details_);
      break;
    }
    // string contact_details = 3;
    case kContactDetails: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_contact_details());
      break;
    }
    // bool credit_card = 4;
    case kCreditCard: {
      total_size += 1 + 1;
      break;
    }
    // string shipping_address = 5;
    case kShippingAddress: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_shipping_address());
      break;
    }
    case DATA_TO_SHOW_NOT_SET: {
      break;
    }
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ShowDetailsProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ShowDetailsProto*>(
      &from));
}

void ShowDetailsProto::MergeFrom(const ShowDetailsProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.ShowDetailsProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_change_flags()->::autofill_assistant::DetailsChangesProto::MergeFrom(from._internal_change_flags());
    }
    if (cached_has_bits & 0x00000002u) {
      append_ = from.append_;
    }
    if (cached_has_bits & 0x00000004u) {
      delay_ms_ = from.delay_ms_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  switch (from.data_to_show_case()) {
    case kDetails: {
      _internal_mutable_details()->::autofill_assistant::DetailsProto::MergeFrom(from._internal_details());
      break;
    }
    case kContactDetails: {
      _internal_set_contact_details(from._internal_contact_details());
      break;
    }
    case kCreditCard: {
      _internal_set_credit_card(from._internal_credit_card());
      break;
    }
    case kShippingAddress: {
      _internal_set_shipping_address(from._internal_shipping_address());
      break;
    }
    case DATA_TO_SHOW_NOT_SET: {
      break;
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ShowDetailsProto::CopyFrom(const ShowDetailsProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.ShowDetailsProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ShowDetailsProto::IsInitialized() const {
  return true;
}

void ShowDetailsProto::InternalSwap(ShowDetailsProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ShowDetailsProto, delay_ms_)
      + sizeof(ShowDetailsProto::delay_ms_)
      - PROTOBUF_FIELD_OFFSET(ShowDetailsProto, change_flags_)>(
          reinterpret_cast<char*>(&change_flags_),
          reinterpret_cast<char*>(&other->change_flags_));
  swap(data_to_show_, other->data_to_show_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

std::string ShowDetailsProto::GetTypeName() const {
  return "autofill_assistant.ShowDetailsProto";
}


// ===================================================================

class GeneratePasswordForFormFieldProto::_Internal {
 public:
  using HasBits = decltype(std::declval<GeneratePasswordForFormFieldProto>()._has_bits_);
  static const ::autofill_assistant::SelectorProto& element(const GeneratePasswordForFormFieldProto* msg);
  static void set_has_element(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_memory_key(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::autofill_assistant::SelectorProto&
GeneratePasswordForFormFieldProto::_Internal::element(const GeneratePasswordForFormFieldProto* msg) {
  return *msg->element_;
}
GeneratePasswordForFormFieldProto::GeneratePasswordForFormFieldProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.GeneratePasswordForFormFieldProto)
}
GeneratePasswordForFormFieldProto::GeneratePasswordForFormFieldProto(const GeneratePasswordForFormFieldProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  memory_key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    memory_key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_memory_key()) {
    memory_key_.Set(from._internal_memory_key(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_element()) {
    element_ = new ::autofill_assistant::SelectorProto(*from.element_);
  } else {
    element_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.GeneratePasswordForFormFieldProto)
}

inline void GeneratePasswordForFormFieldProto::SharedCtor() {
memory_key_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  memory_key_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
element_ = nullptr;
}

GeneratePasswordForFormFieldProto::~GeneratePasswordForFormFieldProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.GeneratePasswordForFormFieldProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GeneratePasswordForFormFieldProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  memory_key_.Destroy();
  if (this != internal_default_instance()) delete element_;
}

void GeneratePasswordForFormFieldProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void GeneratePasswordForFormFieldProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.GeneratePasswordForFormFieldProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      memory_key_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(element_ != nullptr);
      element_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* GeneratePasswordForFormFieldProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .autofill_assistant.SelectorProto element = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_element(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string memory_key = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_memory_key();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GeneratePasswordForFormFieldProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.GeneratePasswordForFormFieldProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .autofill_assistant.SelectorProto element = 1;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::element(this),
        _Internal::element(this).GetCachedSize(), target, stream);
  }

  // optional string memory_key = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_memory_key(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.GeneratePasswordForFormFieldProto)
  return target;
}

size_t GeneratePasswordForFormFieldProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.GeneratePasswordForFormFieldProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string memory_key = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_memory_key());
    }

    // optional .autofill_assistant.SelectorProto element = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *element_);
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void GeneratePasswordForFormFieldProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const GeneratePasswordForFormFieldProto*>(
      &from));
}

void GeneratePasswordForFormFieldProto::MergeFrom(const GeneratePasswordForFormFieldProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.GeneratePasswordForFormFieldProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_memory_key(from._internal_memory_key());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_element()->::autofill_assistant::SelectorProto::MergeFrom(from._internal_element());
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void GeneratePasswordForFormFieldProto::CopyFrom(const GeneratePasswordForFormFieldProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.GeneratePasswordForFormFieldProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GeneratePasswordForFormFieldProto::IsInitialized() const {
  return true;
}

void GeneratePasswordForFormFieldProto::InternalSwap(GeneratePasswordForFormFieldProto* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &memory_key_, lhs_arena,
      &other->memory_key_, rhs_arena
  );
  swap(element_, other->element_);
}

std::string GeneratePasswordForFormFieldProto::GetTypeName() const {
  return "autofill_assistant.GeneratePasswordForFormFieldProto";
}


// ===================================================================

class PresaveGeneratedPasswordProto::_Internal {
 public:
  using HasBits = decltype(std::declval<PresaveGeneratedPasswordProto>()._has_bits_);
  static void set_has_memory_key(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

PresaveGeneratedPasswordProto::PresaveGeneratedPasswordProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.PresaveGeneratedPasswordProto)
}
PresaveGeneratedPasswordProto::PresaveGeneratedPasswordProto(const PresaveGeneratedPasswordProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  memory_key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    memory_key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_memory_key()) {
    memory_key_.Set(from._internal_memory_key(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.PresaveGeneratedPasswordProto)
}

inline void PresaveGeneratedPasswordProto::SharedCtor() {
memory_key_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  memory_key_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

PresaveGeneratedPasswordProto::~PresaveGeneratedPasswordProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.PresaveGeneratedPasswordProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PresaveGeneratedPasswordProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  memory_key_.Destroy();
}

void PresaveGeneratedPasswordProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void PresaveGeneratedPasswordProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.PresaveGeneratedPasswordProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    memory_key_.ClearNonDefaultToEmpty();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* PresaveGeneratedPasswordProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string memory_key = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_memory_key();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PresaveGeneratedPasswordProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.PresaveGeneratedPasswordProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string memory_key = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_memory_key(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.PresaveGeneratedPasswordProto)
  return target;
}

size_t PresaveGeneratedPasswordProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.PresaveGeneratedPasswordProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string memory_key = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_memory_key());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void PresaveGeneratedPasswordProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const PresaveGeneratedPasswordProto*>(
      &from));
}

void PresaveGeneratedPasswordProto::MergeFrom(const PresaveGeneratedPasswordProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.PresaveGeneratedPasswordProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_memory_key()) {
    _internal_set_memory_key(from._internal_memory_key());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void PresaveGeneratedPasswordProto::CopyFrom(const PresaveGeneratedPasswordProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.PresaveGeneratedPasswordProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PresaveGeneratedPasswordProto::IsInitialized() const {
  return true;
}

void PresaveGeneratedPasswordProto::InternalSwap(PresaveGeneratedPasswordProto* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &memory_key_, lhs_arena,
      &other->memory_key_, rhs_arena
  );
}

std::string PresaveGeneratedPasswordProto::GetTypeName() const {
  return "autofill_assistant.PresaveGeneratedPasswordProto";
}


// ===================================================================

class SaveGeneratedPasswordProto::_Internal {
 public:
  using HasBits = decltype(std::declval<SaveGeneratedPasswordProto>()._has_bits_);
  static void set_has_memory_key(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

SaveGeneratedPasswordProto::SaveGeneratedPasswordProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.SaveGeneratedPasswordProto)
}
SaveGeneratedPasswordProto::SaveGeneratedPasswordProto(const SaveGeneratedPasswordProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  memory_key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    memory_key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_memory_key()) {
    memory_key_.Set(from._internal_memory_key(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.SaveGeneratedPasswordProto)
}

inline void SaveGeneratedPasswordProto::SharedCtor() {
memory_key_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  memory_key_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SaveGeneratedPasswordProto::~SaveGeneratedPasswordProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.SaveGeneratedPasswordProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SaveGeneratedPasswordProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  memory_key_.Destroy();
}

void SaveGeneratedPasswordProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SaveGeneratedPasswordProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.SaveGeneratedPasswordProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    memory_key_.ClearNonDefaultToEmpty();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* SaveGeneratedPasswordProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string memory_key = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_memory_key();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SaveGeneratedPasswordProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.SaveGeneratedPasswordProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string memory_key = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_memory_key(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.SaveGeneratedPasswordProto)
  return target;
}

size_t SaveGeneratedPasswordProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.SaveGeneratedPasswordProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string memory_key = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_memory_key());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SaveGeneratedPasswordProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const SaveGeneratedPasswordProto*>(
      &from));
}

void SaveGeneratedPasswordProto::MergeFrom(const SaveGeneratedPasswordProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.SaveGeneratedPasswordProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_memory_key()) {
    _internal_set_memory_key(from._internal_memory_key());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SaveGeneratedPasswordProto::CopyFrom(const SaveGeneratedPasswordProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.SaveGeneratedPasswordProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SaveGeneratedPasswordProto::IsInitialized() const {
  return true;
}

void SaveGeneratedPasswordProto::InternalSwap(SaveGeneratedPasswordProto* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &memory_key_, lhs_arena,
      &other->memory_key_, rhs_arena
  );
}

std::string SaveGeneratedPasswordProto::GetTypeName() const {
  return "autofill_assistant.SaveGeneratedPasswordProto";
}


// ===================================================================

class DeleteSelectedPasswordProto::_Internal {
 public:
};

DeleteSelectedPasswordProto::DeleteSelectedPasswordProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.DeleteSelectedPasswordProto)
}
DeleteSelectedPasswordProto::DeleteSelectedPasswordProto(const DeleteSelectedPasswordProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.DeleteSelectedPasswordProto)
}

inline void DeleteSelectedPasswordProto::SharedCtor() {
}

DeleteSelectedPasswordProto::~DeleteSelectedPasswordProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.DeleteSelectedPasswordProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DeleteSelectedPasswordProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void DeleteSelectedPasswordProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void DeleteSelectedPasswordProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.DeleteSelectedPasswordProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_metadata_.Clear<std::string>();
}

const char* DeleteSelectedPasswordProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DeleteSelectedPasswordProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.DeleteSelectedPasswordProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.DeleteSelectedPasswordProto)
  return target;
}

size_t DeleteSelectedPasswordProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.DeleteSelectedPasswordProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DeleteSelectedPasswordProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DeleteSelectedPasswordProto*>(
      &from));
}

void DeleteSelectedPasswordProto::MergeFrom(const DeleteSelectedPasswordProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.DeleteSelectedPasswordProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DeleteSelectedPasswordProto::CopyFrom(const DeleteSelectedPasswordProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.DeleteSelectedPasswordProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeleteSelectedPasswordProto::IsInitialized() const {
  return true;
}

void DeleteSelectedPasswordProto::InternalSwap(DeleteSelectedPasswordProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
}

std::string DeleteSelectedPasswordProto::GetTypeName() const {
  return "autofill_assistant.DeleteSelectedPasswordProto";
}


// ===================================================================

class EditSelectedPasswordProto::_Internal {
 public:
  using HasBits = decltype(std::declval<EditSelectedPasswordProto>()._has_bits_);
  static void set_has_memory_key(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

EditSelectedPasswordProto::EditSelectedPasswordProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.EditSelectedPasswordProto)
}
EditSelectedPasswordProto::EditSelectedPasswordProto(const EditSelectedPasswordProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  memory_key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    memory_key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_memory_key()) {
    memory_key_.Set(from._internal_memory_key(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.EditSelectedPasswordProto)
}

inline void EditSelectedPasswordProto::SharedCtor() {
memory_key_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  memory_key_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

EditSelectedPasswordProto::~EditSelectedPasswordProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.EditSelectedPasswordProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void EditSelectedPasswordProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  memory_key_.Destroy();
}

void EditSelectedPasswordProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void EditSelectedPasswordProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.EditSelectedPasswordProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    memory_key_.ClearNonDefaultToEmpty();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* EditSelectedPasswordProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string memory_key = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_memory_key();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* EditSelectedPasswordProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.EditSelectedPasswordProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string memory_key = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_memory_key(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.EditSelectedPasswordProto)
  return target;
}

size_t EditSelectedPasswordProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.EditSelectedPasswordProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string memory_key = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_memory_key());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void EditSelectedPasswordProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const EditSelectedPasswordProto*>(
      &from));
}

void EditSelectedPasswordProto::MergeFrom(const EditSelectedPasswordProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.EditSelectedPasswordProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_memory_key()) {
    _internal_set_memory_key(from._internal_memory_key());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void EditSelectedPasswordProto::CopyFrom(const EditSelectedPasswordProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.EditSelectedPasswordProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EditSelectedPasswordProto::IsInitialized() const {
  return true;
}

void EditSelectedPasswordProto::InternalSwap(EditSelectedPasswordProto* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &memory_key_, lhs_arena,
      &other->memory_key_, rhs_arena
  );
}

std::string EditSelectedPasswordProto::GetTypeName() const {
  return "autofill_assistant.EditSelectedPasswordProto";
}


// ===================================================================

class ResetPendingCredentialsProto::_Internal {
 public:
};

ResetPendingCredentialsProto::ResetPendingCredentialsProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.ResetPendingCredentialsProto)
}
ResetPendingCredentialsProto::ResetPendingCredentialsProto(const ResetPendingCredentialsProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.ResetPendingCredentialsProto)
}

inline void ResetPendingCredentialsProto::SharedCtor() {
}

ResetPendingCredentialsProto::~ResetPendingCredentialsProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.ResetPendingCredentialsProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ResetPendingCredentialsProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ResetPendingCredentialsProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ResetPendingCredentialsProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.ResetPendingCredentialsProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_metadata_.Clear<std::string>();
}

const char* ResetPendingCredentialsProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ResetPendingCredentialsProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.ResetPendingCredentialsProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.ResetPendingCredentialsProto)
  return target;
}

size_t ResetPendingCredentialsProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.ResetPendingCredentialsProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ResetPendingCredentialsProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ResetPendingCredentialsProto*>(
      &from));
}

void ResetPendingCredentialsProto::MergeFrom(const ResetPendingCredentialsProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.ResetPendingCredentialsProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ResetPendingCredentialsProto::CopyFrom(const ResetPendingCredentialsProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.ResetPendingCredentialsProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResetPendingCredentialsProto::IsInitialized() const {
  return true;
}

void ResetPendingCredentialsProto::InternalSwap(ResetPendingCredentialsProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
}

std::string ResetPendingCredentialsProto::GetTypeName() const {
  return "autofill_assistant.ResetPendingCredentialsProto";
}


// ===================================================================

class SaveSubmittedPasswordProto_Result::_Internal {
 public:
  using HasBits = decltype(std::declval<SaveSubmittedPasswordProto_Result>()._has_bits_);
  static void set_has_used_same_password(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_used_leaked_credential(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

SaveSubmittedPasswordProto_Result::SaveSubmittedPasswordProto_Result(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.SaveSubmittedPasswordProto.Result)
}
SaveSubmittedPasswordProto_Result::SaveSubmittedPasswordProto_Result(const SaveSubmittedPasswordProto_Result& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&used_same_password_, &from.used_same_password_,
    static_cast<size_t>(reinterpret_cast<char*>(&used_leaked_credential_) -
    reinterpret_cast<char*>(&used_same_password_)) + sizeof(used_leaked_credential_));
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.SaveSubmittedPasswordProto.Result)
}

inline void SaveSubmittedPasswordProto_Result::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&used_same_password_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&used_leaked_credential_) -
    reinterpret_cast<char*>(&used_same_password_)) + sizeof(used_leaked_credential_));
}

SaveSubmittedPasswordProto_Result::~SaveSubmittedPasswordProto_Result() {
  // @@protoc_insertion_point(destructor:autofill_assistant.SaveSubmittedPasswordProto.Result)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SaveSubmittedPasswordProto_Result::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void SaveSubmittedPasswordProto_Result::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SaveSubmittedPasswordProto_Result::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.SaveSubmittedPasswordProto.Result)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&used_same_password_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&used_leaked_credential_) -
      reinterpret_cast<char*>(&used_same_password_)) + sizeof(used_leaked_credential_));
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* SaveSubmittedPasswordProto_Result::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool used_same_password = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_used_same_password(&has_bits);
          used_same_password_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool used_leaked_credential = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_used_leaked_credential(&has_bits);
          used_leaked_credential_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SaveSubmittedPasswordProto_Result::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.SaveSubmittedPasswordProto.Result)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bool used_same_password = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_used_same_password(), target);
  }

  // optional bool used_leaked_credential = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_used_leaked_credential(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.SaveSubmittedPasswordProto.Result)
  return target;
}

size_t SaveSubmittedPasswordProto_Result::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.SaveSubmittedPasswordProto.Result)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional bool used_same_password = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 1;
    }

    // optional bool used_leaked_credential = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SaveSubmittedPasswordProto_Result::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const SaveSubmittedPasswordProto_Result*>(
      &from));
}

void SaveSubmittedPasswordProto_Result::MergeFrom(const SaveSubmittedPasswordProto_Result& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.SaveSubmittedPasswordProto.Result)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      used_same_password_ = from.used_same_password_;
    }
    if (cached_has_bits & 0x00000002u) {
      used_leaked_credential_ = from.used_leaked_credential_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SaveSubmittedPasswordProto_Result::CopyFrom(const SaveSubmittedPasswordProto_Result& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.SaveSubmittedPasswordProto.Result)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SaveSubmittedPasswordProto_Result::IsInitialized() const {
  return true;
}

void SaveSubmittedPasswordProto_Result::InternalSwap(SaveSubmittedPasswordProto_Result* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SaveSubmittedPasswordProto_Result, used_leaked_credential_)
      + sizeof(SaveSubmittedPasswordProto_Result::used_leaked_credential_)
      - PROTOBUF_FIELD_OFFSET(SaveSubmittedPasswordProto_Result, used_same_password_)>(
          reinterpret_cast<char*>(&used_same_password_),
          reinterpret_cast<char*>(&other->used_same_password_));
}

std::string SaveSubmittedPasswordProto_Result::GetTypeName() const {
  return "autofill_assistant.SaveSubmittedPasswordProto.Result";
}


// ===================================================================

class SaveSubmittedPasswordProto::_Internal {
 public:
  using HasBits = decltype(std::declval<SaveSubmittedPasswordProto>()._has_bits_);
  static void set_has_leak_detection_timeout_ms(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

SaveSubmittedPasswordProto::SaveSubmittedPasswordProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.SaveSubmittedPasswordProto)
}
SaveSubmittedPasswordProto::SaveSubmittedPasswordProto(const SaveSubmittedPasswordProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  leak_detection_timeout_ms_ = from.leak_detection_timeout_ms_;
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.SaveSubmittedPasswordProto)
}

inline void SaveSubmittedPasswordProto::SharedCtor() {
leak_detection_timeout_ms_ = 0;
}

SaveSubmittedPasswordProto::~SaveSubmittedPasswordProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.SaveSubmittedPasswordProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SaveSubmittedPasswordProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void SaveSubmittedPasswordProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SaveSubmittedPasswordProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.SaveSubmittedPasswordProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  leak_detection_timeout_ms_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* SaveSubmittedPasswordProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 leak_detection_timeout_ms = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_leak_detection_timeout_ms(&has_bits);
          leak_detection_timeout_ms_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SaveSubmittedPasswordProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.SaveSubmittedPasswordProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 leak_detection_timeout_ms = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_leak_detection_timeout_ms(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.SaveSubmittedPasswordProto)
  return target;
}

size_t SaveSubmittedPasswordProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.SaveSubmittedPasswordProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional int32 leak_detection_timeout_ms = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_leak_detection_timeout_ms());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SaveSubmittedPasswordProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const SaveSubmittedPasswordProto*>(
      &from));
}

void SaveSubmittedPasswordProto::MergeFrom(const SaveSubmittedPasswordProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.SaveSubmittedPasswordProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_leak_detection_timeout_ms()) {
    _internal_set_leak_detection_timeout_ms(from._internal_leak_detection_timeout_ms());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SaveSubmittedPasswordProto::CopyFrom(const SaveSubmittedPasswordProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.SaveSubmittedPasswordProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SaveSubmittedPasswordProto::IsInitialized() const {
  return true;
}

void SaveSubmittedPasswordProto::InternalSwap(SaveSubmittedPasswordProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(leak_detection_timeout_ms_, other->leak_detection_timeout_ms_);
}

std::string SaveSubmittedPasswordProto::GetTypeName() const {
  return "autofill_assistant.SaveSubmittedPasswordProto";
}


// ===================================================================

class RegisterPasswordResetRequestProto::_Internal {
 public:
};

RegisterPasswordResetRequestProto::RegisterPasswordResetRequestProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.RegisterPasswordResetRequestProto)
}
RegisterPasswordResetRequestProto::RegisterPasswordResetRequestProto(const RegisterPasswordResetRequestProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.RegisterPasswordResetRequestProto)
}

inline void RegisterPasswordResetRequestProto::SharedCtor() {
}

RegisterPasswordResetRequestProto::~RegisterPasswordResetRequestProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.RegisterPasswordResetRequestProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RegisterPasswordResetRequestProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void RegisterPasswordResetRequestProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void RegisterPasswordResetRequestProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.RegisterPasswordResetRequestProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_metadata_.Clear<std::string>();
}

const char* RegisterPasswordResetRequestProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RegisterPasswordResetRequestProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.RegisterPasswordResetRequestProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.RegisterPasswordResetRequestProto)
  return target;
}

size_t RegisterPasswordResetRequestProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.RegisterPasswordResetRequestProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void RegisterPasswordResetRequestProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const RegisterPasswordResetRequestProto*>(
      &from));
}

void RegisterPasswordResetRequestProto::MergeFrom(const RegisterPasswordResetRequestProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.RegisterPasswordResetRequestProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void RegisterPasswordResetRequestProto::CopyFrom(const RegisterPasswordResetRequestProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.RegisterPasswordResetRequestProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RegisterPasswordResetRequestProto::IsInitialized() const {
  return true;
}

void RegisterPasswordResetRequestProto::InternalSwap(RegisterPasswordResetRequestProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
}

std::string RegisterPasswordResetRequestProto::GetTypeName() const {
  return "autofill_assistant.RegisterPasswordResetRequestProto";
}


// ===================================================================

class ConfigureUiStateProto::_Internal {
 public:
  using HasBits = decltype(std::declval<ConfigureUiStateProto>()._has_bits_);
  static void set_has_overlay_behavior(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

ConfigureUiStateProto::ConfigureUiStateProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.ConfigureUiStateProto)
}
ConfigureUiStateProto::ConfigureUiStateProto(const ConfigureUiStateProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  overlay_behavior_ = from.overlay_behavior_;
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.ConfigureUiStateProto)
}

inline void ConfigureUiStateProto::SharedCtor() {
overlay_behavior_ = 0;
}

ConfigureUiStateProto::~ConfigureUiStateProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.ConfigureUiStateProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ConfigureUiStateProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ConfigureUiStateProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ConfigureUiStateProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.ConfigureUiStateProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  overlay_behavior_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ConfigureUiStateProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .autofill_assistant.ConfigureUiStateProto.OverlayBehavior overlay_behavior = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::autofill_assistant::ConfigureUiStateProto_OverlayBehavior_IsValid(val))) {
            _internal_set_overlay_behavior(static_cast<::autofill_assistant::ConfigureUiStateProto_OverlayBehavior>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ConfigureUiStateProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.ConfigureUiStateProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .autofill_assistant.ConfigureUiStateProto.OverlayBehavior overlay_behavior = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_overlay_behavior(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.ConfigureUiStateProto)
  return target;
}

size_t ConfigureUiStateProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.ConfigureUiStateProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .autofill_assistant.ConfigureUiStateProto.OverlayBehavior overlay_behavior = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_overlay_behavior());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ConfigureUiStateProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ConfigureUiStateProto*>(
      &from));
}

void ConfigureUiStateProto::MergeFrom(const ConfigureUiStateProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.ConfigureUiStateProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_overlay_behavior()) {
    _internal_set_overlay_behavior(from._internal_overlay_behavior());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ConfigureUiStateProto::CopyFrom(const ConfigureUiStateProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.ConfigureUiStateProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ConfigureUiStateProto::IsInitialized() const {
  return true;
}

void ConfigureUiStateProto::InternalSwap(ConfigureUiStateProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(overlay_behavior_, other->overlay_behavior_);
}

std::string ConfigureUiStateProto::GetTypeName() const {
  return "autofill_assistant.ConfigureUiStateProto";
}


// ===================================================================

class SetAttributeProto::_Internal {
 public:
  using HasBits = decltype(std::declval<SetAttributeProto>()._has_bits_);
  static const ::autofill_assistant::SelectorProto& element(const SetAttributeProto* msg);
  static void set_has_element(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_value(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::autofill_assistant::SelectorProto&
SetAttributeProto::_Internal::element(const SetAttributeProto* msg) {
  return *msg->element_;
}
SetAttributeProto::SetAttributeProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  attribute_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.SetAttributeProto)
}
SetAttributeProto::SetAttributeProto(const SetAttributeProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      attribute_(from.attribute_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  value_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    value_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_value()) {
    value_.Set(from._internal_value(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_element()) {
    element_ = new ::autofill_assistant::SelectorProto(*from.element_);
  } else {
    element_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.SetAttributeProto)
}

inline void SetAttributeProto::SharedCtor() {
value_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  value_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
element_ = nullptr;
}

SetAttributeProto::~SetAttributeProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.SetAttributeProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SetAttributeProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  value_.Destroy();
  if (this != internal_default_instance()) delete element_;
}

void SetAttributeProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SetAttributeProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.SetAttributeProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  attribute_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      value_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(element_ != nullptr);
      element_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* SetAttributeProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .autofill_assistant.SelectorProto element = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_element(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated string attribute = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_attribute();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional string value = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_value();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SetAttributeProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.SetAttributeProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .autofill_assistant.SelectorProto element = 1;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::element(this),
        _Internal::element(this).GetCachedSize(), target, stream);
  }

  // repeated string attribute = 2;
  for (int i = 0, n = this->_internal_attribute_size(); i < n; i++) {
    const auto& s = this->_internal_attribute(i);
    target = stream->WriteString(2, s, target);
  }

  // optional string value = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_value(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.SetAttributeProto)
  return target;
}

size_t SetAttributeProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.SetAttributeProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string attribute = 2;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(attribute_.size());
  for (int i = 0, n = attribute_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      attribute_.Get(i));
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string value = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_value());
    }

    // optional .autofill_assistant.SelectorProto element = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *element_);
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SetAttributeProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const SetAttributeProto*>(
      &from));
}

void SetAttributeProto::MergeFrom(const SetAttributeProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.SetAttributeProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  attribute_.MergeFrom(from.attribute_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_value(from._internal_value());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_element()->::autofill_assistant::SelectorProto::MergeFrom(from._internal_element());
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SetAttributeProto::CopyFrom(const SetAttributeProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.SetAttributeProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SetAttributeProto::IsInitialized() const {
  return true;
}

void SetAttributeProto::InternalSwap(SetAttributeProto* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  attribute_.InternalSwap(&other->attribute_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &value_, lhs_arena,
      &other->value_, rhs_arena
  );
  swap(element_, other->element_);
}

std::string SetAttributeProto::GetTypeName() const {
  return "autofill_assistant.SetAttributeProto";
}


// ===================================================================

class InfoBoxProto::_Internal {
 public:
  using HasBits = decltype(std::declval<InfoBoxProto>()._has_bits_);
  static const ::autofill_assistant::DrawableProto& drawable(const InfoBoxProto* msg);
  static void set_has_explanation(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::autofill_assistant::DrawableProto&
InfoBoxProto::_Internal::drawable(const InfoBoxProto* msg) {
  return *msg->image_.drawable_;
}
void InfoBoxProto::set_allocated_drawable(::autofill_assistant::DrawableProto* drawable) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_image();
  if (drawable) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(drawable));
    if (message_arena != submessage_arena) {
      drawable = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, drawable, submessage_arena);
    }
    set_has_drawable();
    image_.drawable_ = drawable;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.InfoBoxProto.drawable)
}
void InfoBoxProto::clear_drawable() {
  if (_internal_has_drawable()) {
    if (GetArenaForAllocation() == nullptr) {
      delete image_.drawable_;
    }
    clear_has_image();
  }
}
InfoBoxProto::InfoBoxProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.InfoBoxProto)
}
InfoBoxProto::InfoBoxProto(const InfoBoxProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  explanation_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    explanation_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_explanation()) {
    explanation_.Set(from._internal_explanation(), 
      GetArenaForAllocation());
  }
  clear_has_image();
  switch (from.image_case()) {
    case kImagePath: {
      _internal_set_image_path(from._internal_image_path());
      break;
    }
    case kDrawable: {
      _internal_mutable_drawable()->::autofill_assistant::DrawableProto::MergeFrom(from._internal_drawable());
      break;
    }
    case IMAGE_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.InfoBoxProto)
}

inline void InfoBoxProto::SharedCtor() {
explanation_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  explanation_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
clear_has_image();
}

InfoBoxProto::~InfoBoxProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.InfoBoxProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void InfoBoxProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  explanation_.Destroy();
  if (has_image()) {
    clear_image();
  }
}

void InfoBoxProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void InfoBoxProto::clear_image() {
// @@protoc_insertion_point(one_of_clear_start:autofill_assistant.InfoBoxProto)
  switch (image_case()) {
    case kImagePath: {
      image_.image_path_.Destroy();
      break;
    }
    case kDrawable: {
      if (GetArenaForAllocation() == nullptr) {
        delete image_.drawable_;
      }
      break;
    }
    case IMAGE_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = IMAGE_NOT_SET;
}


void InfoBoxProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.InfoBoxProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    explanation_.ClearNonDefaultToEmpty();
  }
  clear_image();
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* InfoBoxProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string image_path = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_image_path();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string explanation = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_explanation();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.DrawableProto drawable = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_drawable(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* InfoBoxProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.InfoBoxProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string image_path = 1;
  if (_internal_has_image_path()) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_image_path(), target);
  }

  cached_has_bits = _has_bits_[0];
  // optional string explanation = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_explanation(), target);
  }

  // .autofill_assistant.DrawableProto drawable = 4;
  if (_internal_has_drawable()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::drawable(this),
        _Internal::drawable(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.InfoBoxProto)
  return target;
}

size_t InfoBoxProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.InfoBoxProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string explanation = 2;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_explanation());
  }

  switch (image_case()) {
    // string image_path = 1;
    case kImagePath: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_image_path());
      break;
    }
    // .autofill_assistant.DrawableProto drawable = 4;
    case kDrawable: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *image_.drawable_);
      break;
    }
    case IMAGE_NOT_SET: {
      break;
    }
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void InfoBoxProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const InfoBoxProto*>(
      &from));
}

void InfoBoxProto::MergeFrom(const InfoBoxProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.InfoBoxProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_explanation()) {
    _internal_set_explanation(from._internal_explanation());
  }
  switch (from.image_case()) {
    case kImagePath: {
      _internal_set_image_path(from._internal_image_path());
      break;
    }
    case kDrawable: {
      _internal_mutable_drawable()->::autofill_assistant::DrawableProto::MergeFrom(from._internal_drawable());
      break;
    }
    case IMAGE_NOT_SET: {
      break;
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void InfoBoxProto::CopyFrom(const InfoBoxProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.InfoBoxProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool InfoBoxProto::IsInitialized() const {
  return true;
}

void InfoBoxProto::InternalSwap(InfoBoxProto* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &explanation_, lhs_arena,
      &other->explanation_, rhs_arena
  );
  swap(image_, other->image_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

std::string InfoBoxProto::GetTypeName() const {
  return "autofill_assistant.InfoBoxProto";
}


// ===================================================================

class ShowInfoBoxProto::_Internal {
 public:
  using HasBits = decltype(std::declval<ShowInfoBoxProto>()._has_bits_);
  static const ::autofill_assistant::InfoBoxProto& info_box(const ShowInfoBoxProto* msg);
  static void set_has_info_box(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::autofill_assistant::InfoBoxProto&
ShowInfoBoxProto::_Internal::info_box(const ShowInfoBoxProto* msg) {
  return *msg->info_box_;
}
ShowInfoBoxProto::ShowInfoBoxProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.ShowInfoBoxProto)
}
ShowInfoBoxProto::ShowInfoBoxProto(const ShowInfoBoxProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_info_box()) {
    info_box_ = new ::autofill_assistant::InfoBoxProto(*from.info_box_);
  } else {
    info_box_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.ShowInfoBoxProto)
}

inline void ShowInfoBoxProto::SharedCtor() {
info_box_ = nullptr;
}

ShowInfoBoxProto::~ShowInfoBoxProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.ShowInfoBoxProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ShowInfoBoxProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete info_box_;
}

void ShowInfoBoxProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ShowInfoBoxProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.ShowInfoBoxProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(info_box_ != nullptr);
    info_box_->Clear();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ShowInfoBoxProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .autofill_assistant.InfoBoxProto info_box = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_info_box(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ShowInfoBoxProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.ShowInfoBoxProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .autofill_assistant.InfoBoxProto info_box = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::info_box(this),
        _Internal::info_box(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.ShowInfoBoxProto)
  return target;
}

size_t ShowInfoBoxProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.ShowInfoBoxProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .autofill_assistant.InfoBoxProto info_box = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *info_box_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ShowInfoBoxProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ShowInfoBoxProto*>(
      &from));
}

void ShowInfoBoxProto::MergeFrom(const ShowInfoBoxProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.ShowInfoBoxProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_info_box()) {
    _internal_mutable_info_box()->::autofill_assistant::InfoBoxProto::MergeFrom(from._internal_info_box());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ShowInfoBoxProto::CopyFrom(const ShowInfoBoxProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.ShowInfoBoxProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ShowInfoBoxProto::IsInitialized() const {
  return true;
}

void ShowInfoBoxProto::InternalSwap(ShowInfoBoxProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(info_box_, other->info_box_);
}

std::string ShowInfoBoxProto::GetTypeName() const {
  return "autofill_assistant.ShowInfoBoxProto";
}


// ===================================================================

class ConfigureBottomSheetProto::_Internal {
 public:
  using HasBits = decltype(std::declval<ConfigureBottomSheetProto>()._has_bits_);
  static void set_has_viewport_resizing(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_peek_mode(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_resize_timeout_ms(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

ConfigureBottomSheetProto::ConfigureBottomSheetProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.ConfigureBottomSheetProto)
}
ConfigureBottomSheetProto::ConfigureBottomSheetProto(const ConfigureBottomSheetProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&viewport_resizing_, &from.viewport_resizing_,
    static_cast<size_t>(reinterpret_cast<char*>(&resize_timeout_ms_) -
    reinterpret_cast<char*>(&viewport_resizing_)) + sizeof(resize_timeout_ms_));
  clear_has_apply_state();
  switch (from.apply_state_case()) {
    case kExpand: {
      _internal_set_expand(from._internal_expand());
      break;
    }
    case kCollapse: {
      _internal_set_collapse(from._internal_collapse());
      break;
    }
    case APPLY_STATE_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.ConfigureBottomSheetProto)
}

inline void ConfigureBottomSheetProto::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&viewport_resizing_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&resize_timeout_ms_) -
    reinterpret_cast<char*>(&viewport_resizing_)) + sizeof(resize_timeout_ms_));
clear_has_apply_state();
}

ConfigureBottomSheetProto::~ConfigureBottomSheetProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.ConfigureBottomSheetProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ConfigureBottomSheetProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_apply_state()) {
    clear_apply_state();
  }
}

void ConfigureBottomSheetProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ConfigureBottomSheetProto::clear_apply_state() {
// @@protoc_insertion_point(one_of_clear_start:autofill_assistant.ConfigureBottomSheetProto)
  switch (apply_state_case()) {
    case kExpand: {
      // No need to clear
      break;
    }
    case kCollapse: {
      // No need to clear
      break;
    }
    case APPLY_STATE_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = APPLY_STATE_NOT_SET;
}


void ConfigureBottomSheetProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.ConfigureBottomSheetProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&viewport_resizing_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&resize_timeout_ms_) -
        reinterpret_cast<char*>(&viewport_resizing_)) + sizeof(resize_timeout_ms_));
  }
  clear_apply_state();
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ConfigureBottomSheetProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .autofill_assistant.ConfigureBottomSheetProto.ViewportResizing viewport_resizing = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::autofill_assistant::ConfigureBottomSheetProto_ViewportResizing_IsValid(val))) {
            _internal_set_viewport_resizing(static_cast<::autofill_assistant::ConfigureBottomSheetProto_ViewportResizing>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .autofill_assistant.ConfigureBottomSheetProto.PeekMode peek_mode = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::autofill_assistant::ConfigureBottomSheetProto_PeekMode_IsValid(val))) {
            _internal_set_peek_mode(static_cast<::autofill_assistant::ConfigureBottomSheetProto_PeekMode>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional int32 resize_timeout_ms = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_resize_timeout_ms(&has_bits);
          resize_timeout_ms_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool expand = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _internal_set_expand(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool collapse = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _internal_set_collapse(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ConfigureBottomSheetProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.ConfigureBottomSheetProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .autofill_assistant.ConfigureBottomSheetProto.ViewportResizing viewport_resizing = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_viewport_resizing(), target);
  }

  // optional .autofill_assistant.ConfigureBottomSheetProto.PeekMode peek_mode = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_peek_mode(), target);
  }

  // optional int32 resize_timeout_ms = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_resize_timeout_ms(), target);
  }

  switch (apply_state_case()) {
    case kExpand: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_expand(), target);
      break;
    }
    case kCollapse: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_collapse(), target);
      break;
    }
    default: ;
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.ConfigureBottomSheetProto)
  return target;
}

size_t ConfigureBottomSheetProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.ConfigureBottomSheetProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .autofill_assistant.ConfigureBottomSheetProto.ViewportResizing viewport_resizing = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_viewport_resizing());
    }

    // optional .autofill_assistant.ConfigureBottomSheetProto.PeekMode peek_mode = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_peek_mode());
    }

    // optional int32 resize_timeout_ms = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_resize_timeout_ms());
    }

  }
  switch (apply_state_case()) {
    // bool expand = 4;
    case kExpand: {
      total_size += 1 + 1;
      break;
    }
    // bool collapse = 5;
    case kCollapse: {
      total_size += 1 + 1;
      break;
    }
    case APPLY_STATE_NOT_SET: {
      break;
    }
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ConfigureBottomSheetProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ConfigureBottomSheetProto*>(
      &from));
}

void ConfigureBottomSheetProto::MergeFrom(const ConfigureBottomSheetProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.ConfigureBottomSheetProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      viewport_resizing_ = from.viewport_resizing_;
    }
    if (cached_has_bits & 0x00000002u) {
      peek_mode_ = from.peek_mode_;
    }
    if (cached_has_bits & 0x00000004u) {
      resize_timeout_ms_ = from.resize_timeout_ms_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  switch (from.apply_state_case()) {
    case kExpand: {
      _internal_set_expand(from._internal_expand());
      break;
    }
    case kCollapse: {
      _internal_set_collapse(from._internal_collapse());
      break;
    }
    case APPLY_STATE_NOT_SET: {
      break;
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ConfigureBottomSheetProto::CopyFrom(const ConfigureBottomSheetProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.ConfigureBottomSheetProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ConfigureBottomSheetProto::IsInitialized() const {
  return true;
}

void ConfigureBottomSheetProto::InternalSwap(ConfigureBottomSheetProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ConfigureBottomSheetProto, resize_timeout_ms_)
      + sizeof(ConfigureBottomSheetProto::resize_timeout_ms_)
      - PROTOBUF_FIELD_OFFSET(ConfigureBottomSheetProto, viewport_resizing_)>(
          reinterpret_cast<char*>(&viewport_resizing_),
          reinterpret_cast<char*>(&other->viewport_resizing_));
  swap(apply_state_, other->apply_state_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

std::string ConfigureBottomSheetProto::GetTypeName() const {
  return "autofill_assistant.ConfigureBottomSheetProto";
}


// ===================================================================

class ShowFormProto::_Internal {
 public:
  using HasBits = decltype(std::declval<ShowFormProto>()._has_bits_);
  static const ::autofill_assistant::FormProto& form(const ShowFormProto* msg);
  static void set_has_form(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::autofill_assistant::ChipProto& chip(const ShowFormProto* msg);
  static void set_has_chip(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::autofill_assistant::FormProto&
ShowFormProto::_Internal::form(const ShowFormProto* msg) {
  return *msg->form_;
}
const ::autofill_assistant::ChipProto&
ShowFormProto::_Internal::chip(const ShowFormProto* msg) {
  return *msg->chip_;
}
void ShowFormProto::clear_chip() {
  if (chip_ != nullptr) chip_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
ShowFormProto::ShowFormProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.ShowFormProto)
}
ShowFormProto::ShowFormProto(const ShowFormProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_form()) {
    form_ = new ::autofill_assistant::FormProto(*from.form_);
  } else {
    form_ = nullptr;
  }
  if (from._internal_has_chip()) {
    chip_ = new ::autofill_assistant::ChipProto(*from.chip_);
  } else {
    chip_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.ShowFormProto)
}

inline void ShowFormProto::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&form_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&chip_) -
    reinterpret_cast<char*>(&form_)) + sizeof(chip_));
}

ShowFormProto::~ShowFormProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.ShowFormProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ShowFormProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete form_;
  if (this != internal_default_instance()) delete chip_;
}

void ShowFormProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ShowFormProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.ShowFormProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(form_ != nullptr);
      form_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(chip_ != nullptr);
      chip_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ShowFormProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .autofill_assistant.FormProto form = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_form(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .autofill_assistant.ChipProto chip = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_chip(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ShowFormProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.ShowFormProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .autofill_assistant.FormProto form = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::form(this),
        _Internal::form(this).GetCachedSize(), target, stream);
  }

  // optional .autofill_assistant.ChipProto chip = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::chip(this),
        _Internal::chip(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.ShowFormProto)
  return target;
}

size_t ShowFormProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.ShowFormProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .autofill_assistant.FormProto form = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *form_);
    }

    // optional .autofill_assistant.ChipProto chip = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *chip_);
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ShowFormProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ShowFormProto*>(
      &from));
}

void ShowFormProto::MergeFrom(const ShowFormProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.ShowFormProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_form()->::autofill_assistant::FormProto::MergeFrom(from._internal_form());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_chip()->::autofill_assistant::ChipProto::MergeFrom(from._internal_chip());
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ShowFormProto::CopyFrom(const ShowFormProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.ShowFormProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ShowFormProto::IsInitialized() const {
  return true;
}

void ShowFormProto::InternalSwap(ShowFormProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ShowFormProto, chip_)
      + sizeof(ShowFormProto::chip_)
      - PROTOBUF_FIELD_OFFSET(ShowFormProto, form_)>(
          reinterpret_cast<char*>(&form_),
          reinterpret_cast<char*>(&other->form_));
}

std::string ShowFormProto::GetTypeName() const {
  return "autofill_assistant.ShowFormProto";
}


// ===================================================================

class FormProto_Result::_Internal {
 public:
  using HasBits = decltype(std::declval<FormProto_Result>()._has_bits_);
  static void set_has_link(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

FormProto_Result::FormProto_Result(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  input_results_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.FormProto.Result)
}
FormProto_Result::FormProto_Result(const FormProto_Result& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      input_results_(from.input_results_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  link_ = from.link_;
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.FormProto.Result)
}

inline void FormProto_Result::SharedCtor() {
link_ = 0;
}

FormProto_Result::~FormProto_Result() {
  // @@protoc_insertion_point(destructor:autofill_assistant.FormProto.Result)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void FormProto_Result::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void FormProto_Result::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void FormProto_Result::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.FormProto.Result)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  input_results_.Clear();
  link_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* FormProto_Result::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .autofill_assistant.FormInputProto.Result input_results = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_input_results(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional int32 link = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_link(&has_bits);
          link_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FormProto_Result::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.FormProto.Result)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .autofill_assistant.FormInputProto.Result input_results = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_input_results_size()); i < n; i++) {
    const auto& repfield = this->_internal_input_results(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  cached_has_bits = _has_bits_[0];
  // optional int32 link = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_link(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.FormProto.Result)
  return target;
}

size_t FormProto_Result::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.FormProto.Result)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .autofill_assistant.FormInputProto.Result input_results = 1;
  total_size += 1UL * this->_internal_input_results_size();
  for (const auto& msg : this->input_results_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional int32 link = 2;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_link());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void FormProto_Result::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const FormProto_Result*>(
      &from));
}

void FormProto_Result::MergeFrom(const FormProto_Result& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.FormProto.Result)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  input_results_.MergeFrom(from.input_results_);
  if (from._internal_has_link()) {
    _internal_set_link(from._internal_link());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void FormProto_Result::CopyFrom(const FormProto_Result& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.FormProto.Result)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FormProto_Result::IsInitialized() const {
  return true;
}

void FormProto_Result::InternalSwap(FormProto_Result* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  input_results_.InternalSwap(&other->input_results_);
  swap(link_, other->link_);
}

std::string FormProto_Result::GetTypeName() const {
  return "autofill_assistant.FormProto.Result";
}


// ===================================================================

class FormProto::_Internal {
 public:
  using HasBits = decltype(std::declval<FormProto>()._has_bits_);
  static void set_has_info_label(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::autofill_assistant::InfoPopupProto& info_popup(const FormProto* msg);
  static void set_has_info_popup(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::autofill_assistant::InfoPopupProto&
FormProto::_Internal::info_popup(const FormProto* msg) {
  return *msg->info_popup_;
}
void FormProto::clear_info_popup() {
  if (info_popup_ != nullptr) info_popup_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
FormProto::FormProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  inputs_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.FormProto)
}
FormProto::FormProto(const FormProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      inputs_(from.inputs_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  info_label_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    info_label_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_info_label()) {
    info_label_.Set(from._internal_info_label(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_info_popup()) {
    info_popup_ = new ::autofill_assistant::InfoPopupProto(*from.info_popup_);
  } else {
    info_popup_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.FormProto)
}

inline void FormProto::SharedCtor() {
info_label_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  info_label_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
info_popup_ = nullptr;
}

FormProto::~FormProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.FormProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void FormProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  info_label_.Destroy();
  if (this != internal_default_instance()) delete info_popup_;
}

void FormProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void FormProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.FormProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  inputs_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      info_label_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(info_popup_ != nullptr);
      info_popup_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* FormProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .autofill_assistant.FormInputProto inputs = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_inputs(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional string info_label = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_info_label();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .autofill_assistant.InfoPopupProto info_popup = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_info_popup(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FormProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.FormProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .autofill_assistant.FormInputProto inputs = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_inputs_size()); i < n; i++) {
    const auto& repfield = this->_internal_inputs(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  cached_has_bits = _has_bits_[0];
  // optional string info_label = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_info_label(), target);
  }

  // optional .autofill_assistant.InfoPopupProto info_popup = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::info_popup(this),
        _Internal::info_popup(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.FormProto)
  return target;
}

size_t FormProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.FormProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .autofill_assistant.FormInputProto inputs = 1;
  total_size += 1UL * this->_internal_inputs_size();
  for (const auto& msg : this->inputs_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string info_label = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_info_label());
    }

    // optional .autofill_assistant.InfoPopupProto info_popup = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *info_popup_);
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void FormProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const FormProto*>(
      &from));
}

void FormProto::MergeFrom(const FormProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.FormProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  inputs_.MergeFrom(from.inputs_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_info_label(from._internal_info_label());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_info_popup()->::autofill_assistant::InfoPopupProto::MergeFrom(from._internal_info_popup());
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void FormProto::CopyFrom(const FormProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.FormProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FormProto::IsInitialized() const {
  return true;
}

void FormProto::InternalSwap(FormProto* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  inputs_.InternalSwap(&other->inputs_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &info_label_, lhs_arena,
      &other->info_label_, rhs_arena
  );
  swap(info_popup_, other->info_popup_);
}

std::string FormProto::GetTypeName() const {
  return "autofill_assistant.FormProto";
}


// ===================================================================

class FormInputProto_Result::_Internal {
 public:
  static const ::autofill_assistant::CounterInputProto_Result& counter(const FormInputProto_Result* msg);
  static const ::autofill_assistant::SelectionInputProto_Result& selection(const FormInputProto_Result* msg);
};

const ::autofill_assistant::CounterInputProto_Result&
FormInputProto_Result::_Internal::counter(const FormInputProto_Result* msg) {
  return *msg->input_type_.counter_;
}
const ::autofill_assistant::SelectionInputProto_Result&
FormInputProto_Result::_Internal::selection(const FormInputProto_Result* msg) {
  return *msg->input_type_.selection_;
}
void FormInputProto_Result::set_allocated_counter(::autofill_assistant::CounterInputProto_Result* counter) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_input_type();
  if (counter) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(counter);
    if (message_arena != submessage_arena) {
      counter = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, counter, submessage_arena);
    }
    set_has_counter();
    input_type_.counter_ = counter;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.FormInputProto.Result.counter)
}
void FormInputProto_Result::set_allocated_selection(::autofill_assistant::SelectionInputProto_Result* selection) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_input_type();
  if (selection) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(selection);
    if (message_arena != submessage_arena) {
      selection = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, selection, submessage_arena);
    }
    set_has_selection();
    input_type_.selection_ = selection;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.FormInputProto.Result.selection)
}
FormInputProto_Result::FormInputProto_Result(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.FormInputProto.Result)
}
FormInputProto_Result::FormInputProto_Result(const FormInputProto_Result& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  clear_has_input_type();
  switch (from.input_type_case()) {
    case kCounter: {
      _internal_mutable_counter()->::autofill_assistant::CounterInputProto_Result::MergeFrom(from._internal_counter());
      break;
    }
    case kSelection: {
      _internal_mutable_selection()->::autofill_assistant::SelectionInputProto_Result::MergeFrom(from._internal_selection());
      break;
    }
    case INPUT_TYPE_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.FormInputProto.Result)
}

inline void FormInputProto_Result::SharedCtor() {
clear_has_input_type();
}

FormInputProto_Result::~FormInputProto_Result() {
  // @@protoc_insertion_point(destructor:autofill_assistant.FormInputProto.Result)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void FormInputProto_Result::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_input_type()) {
    clear_input_type();
  }
}

void FormInputProto_Result::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void FormInputProto_Result::clear_input_type() {
// @@protoc_insertion_point(one_of_clear_start:autofill_assistant.FormInputProto.Result)
  switch (input_type_case()) {
    case kCounter: {
      if (GetArenaForAllocation() == nullptr) {
        delete input_type_.counter_;
      }
      break;
    }
    case kSelection: {
      if (GetArenaForAllocation() == nullptr) {
        delete input_type_.selection_;
      }
      break;
    }
    case INPUT_TYPE_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = INPUT_TYPE_NOT_SET;
}


void FormInputProto_Result::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.FormInputProto.Result)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_input_type();
  _internal_metadata_.Clear<std::string>();
}

const char* FormInputProto_Result::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .autofill_assistant.CounterInputProto.Result counter = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_counter(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.SelectionInputProto.Result selection = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_selection(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FormInputProto_Result::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.FormInputProto.Result)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (input_type_case()) {
    case kCounter: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, _Internal::counter(this),
          _Internal::counter(this).GetCachedSize(), target, stream);
      break;
    }
    case kSelection: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, _Internal::selection(this),
          _Internal::selection(this).GetCachedSize(), target, stream);
      break;
    }
    default: ;
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.FormInputProto.Result)
  return target;
}

size_t FormInputProto_Result::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.FormInputProto.Result)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (input_type_case()) {
    // .autofill_assistant.CounterInputProto.Result counter = 1;
    case kCounter: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *input_type_.counter_);
      break;
    }
    // .autofill_assistant.SelectionInputProto.Result selection = 2;
    case kSelection: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *input_type_.selection_);
      break;
    }
    case INPUT_TYPE_NOT_SET: {
      break;
    }
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void FormInputProto_Result::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const FormInputProto_Result*>(
      &from));
}

void FormInputProto_Result::MergeFrom(const FormInputProto_Result& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.FormInputProto.Result)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.input_type_case()) {
    case kCounter: {
      _internal_mutable_counter()->::autofill_assistant::CounterInputProto_Result::MergeFrom(from._internal_counter());
      break;
    }
    case kSelection: {
      _internal_mutable_selection()->::autofill_assistant::SelectionInputProto_Result::MergeFrom(from._internal_selection());
      break;
    }
    case INPUT_TYPE_NOT_SET: {
      break;
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void FormInputProto_Result::CopyFrom(const FormInputProto_Result& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.FormInputProto.Result)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FormInputProto_Result::IsInitialized() const {
  return true;
}

void FormInputProto_Result::InternalSwap(FormInputProto_Result* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(input_type_, other->input_type_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

std::string FormInputProto_Result::GetTypeName() const {
  return "autofill_assistant.FormInputProto.Result";
}


// ===================================================================

class FormInputProto::_Internal {
 public:
  static const ::autofill_assistant::CounterInputProto& counter(const FormInputProto* msg);
  static const ::autofill_assistant::SelectionInputProto& selection(const FormInputProto* msg);
};

const ::autofill_assistant::CounterInputProto&
FormInputProto::_Internal::counter(const FormInputProto* msg) {
  return *msg->input_type_.counter_;
}
const ::autofill_assistant::SelectionInputProto&
FormInputProto::_Internal::selection(const FormInputProto* msg) {
  return *msg->input_type_.selection_;
}
void FormInputProto::set_allocated_counter(::autofill_assistant::CounterInputProto* counter) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_input_type();
  if (counter) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(counter);
    if (message_arena != submessage_arena) {
      counter = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, counter, submessage_arena);
    }
    set_has_counter();
    input_type_.counter_ = counter;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.FormInputProto.counter)
}
void FormInputProto::set_allocated_selection(::autofill_assistant::SelectionInputProto* selection) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_input_type();
  if (selection) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(selection);
    if (message_arena != submessage_arena) {
      selection = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, selection, submessage_arena);
    }
    set_has_selection();
    input_type_.selection_ = selection;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.FormInputProto.selection)
}
FormInputProto::FormInputProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.FormInputProto)
}
FormInputProto::FormInputProto(const FormInputProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  clear_has_input_type();
  switch (from.input_type_case()) {
    case kCounter: {
      _internal_mutable_counter()->::autofill_assistant::CounterInputProto::MergeFrom(from._internal_counter());
      break;
    }
    case kSelection: {
      _internal_mutable_selection()->::autofill_assistant::SelectionInputProto::MergeFrom(from._internal_selection());
      break;
    }
    case INPUT_TYPE_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.FormInputProto)
}

inline void FormInputProto::SharedCtor() {
clear_has_input_type();
}

FormInputProto::~FormInputProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.FormInputProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void FormInputProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_input_type()) {
    clear_input_type();
  }
}

void FormInputProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void FormInputProto::clear_input_type() {
// @@protoc_insertion_point(one_of_clear_start:autofill_assistant.FormInputProto)
  switch (input_type_case()) {
    case kCounter: {
      if (GetArenaForAllocation() == nullptr) {
        delete input_type_.counter_;
      }
      break;
    }
    case kSelection: {
      if (GetArenaForAllocation() == nullptr) {
        delete input_type_.selection_;
      }
      break;
    }
    case INPUT_TYPE_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = INPUT_TYPE_NOT_SET;
}


void FormInputProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.FormInputProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_input_type();
  _internal_metadata_.Clear<std::string>();
}

const char* FormInputProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .autofill_assistant.CounterInputProto counter = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_counter(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.SelectionInputProto selection = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_selection(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FormInputProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.FormInputProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (input_type_case()) {
    case kCounter: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, _Internal::counter(this),
          _Internal::counter(this).GetCachedSize(), target, stream);
      break;
    }
    case kSelection: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, _Internal::selection(this),
          _Internal::selection(this).GetCachedSize(), target, stream);
      break;
    }
    default: ;
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.FormInputProto)
  return target;
}

size_t FormInputProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.FormInputProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (input_type_case()) {
    // .autofill_assistant.CounterInputProto counter = 1;
    case kCounter: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *input_type_.counter_);
      break;
    }
    // .autofill_assistant.SelectionInputProto selection = 2;
    case kSelection: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *input_type_.selection_);
      break;
    }
    case INPUT_TYPE_NOT_SET: {
      break;
    }
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void FormInputProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const FormInputProto*>(
      &from));
}

void FormInputProto::MergeFrom(const FormInputProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.FormInputProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.input_type_case()) {
    case kCounter: {
      _internal_mutable_counter()->::autofill_assistant::CounterInputProto::MergeFrom(from._internal_counter());
      break;
    }
    case kSelection: {
      _internal_mutable_selection()->::autofill_assistant::SelectionInputProto::MergeFrom(from._internal_selection());
      break;
    }
    case INPUT_TYPE_NOT_SET: {
      break;
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void FormInputProto::CopyFrom(const FormInputProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.FormInputProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FormInputProto::IsInitialized() const {
  return true;
}

void FormInputProto::InternalSwap(FormInputProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(input_type_, other->input_type_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

std::string FormInputProto::GetTypeName() const {
  return "autofill_assistant.FormInputProto";
}


// ===================================================================

class CounterInputProto_Counter::_Internal {
 public:
  using HasBits = decltype(std::declval<CounterInputProto_Counter>()._has_bits_);
  static void set_has_label(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_description_line_1(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_description_line_2(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_min_value(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_max_value(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_initial_value(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_size(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

CounterInputProto_Counter::CounterInputProto_Counter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  allowed_values_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.CounterInputProto.Counter)
}
CounterInputProto_Counter::CounterInputProto_Counter(const CounterInputProto_Counter& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      allowed_values_(from.allowed_values_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  label_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    label_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_label()) {
    label_.Set(from._internal_label(), 
      GetArenaForAllocation());
  }
  description_line_1_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    description_line_1_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_description_line_1()) {
    description_line_1_.Set(from._internal_description_line_1(), 
      GetArenaForAllocation());
  }
  description_line_2_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    description_line_2_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_description_line_2()) {
    description_line_2_.Set(from._internal_description_line_2(), 
      GetArenaForAllocation());
  }
  ::memcpy(&initial_value_, &from.initial_value_,
    static_cast<size_t>(reinterpret_cast<char*>(&max_value_) -
    reinterpret_cast<char*>(&initial_value_)) + sizeof(max_value_));
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.CounterInputProto.Counter)
}

inline void CounterInputProto_Counter::SharedCtor() {
label_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  label_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
description_line_1_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  description_line_1_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
description_line_2_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  description_line_2_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
initial_value_ = 0;
size_ = 1;
min_value_ = -2147483647 - 1;
max_value_ = 2147483647;
}

CounterInputProto_Counter::~CounterInputProto_Counter() {
  // @@protoc_insertion_point(destructor:autofill_assistant.CounterInputProto.Counter)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CounterInputProto_Counter::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  label_.Destroy();
  description_line_1_.Destroy();
  description_line_2_.Destroy();
}

void CounterInputProto_Counter::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CounterInputProto_Counter::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.CounterInputProto.Counter)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  allowed_values_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      label_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      description_line_1_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      description_line_2_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x00000078u) {
    initial_value_ = 0;
    size_ = 1;
    min_value_ = -2147483647 - 1;
    max_value_ = 2147483647;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CounterInputProto_Counter::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string label = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_label();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 min_value = 2 [default = -2147483648];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_min_value(&has_bits);
          min_value_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 max_value = 3 [default = 2147483647];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_max_value(&has_bits);
          max_value_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 initial_value = 4 [default = 0];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_initial_value(&has_bits);
          initial_value_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string description_line_1 = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_description_line_1();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated int32 allowed_values = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_allowed_values(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<48>(ptr));
        } else if (static_cast<uint8_t>(tag) == 50) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_allowed_values(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string description_line_2 = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          auto str = _internal_mutable_description_line_2();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 size = 9 [default = 1];
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_size(&has_bits);
          size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CounterInputProto_Counter::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.CounterInputProto.Counter)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string label = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_label(), target);
  }

  // optional int32 min_value = 2 [default = -2147483648];
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_min_value(), target);
  }

  // optional int32 max_value = 3 [default = 2147483647];
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_max_value(), target);
  }

  // optional int32 initial_value = 4 [default = 0];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_initial_value(), target);
  }

  // optional string description_line_1 = 5;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_description_line_1(), target);
  }

  // repeated int32 allowed_values = 6;
  for (int i = 0, n = this->_internal_allowed_values_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(6, this->_internal_allowed_values(i), target);
  }

  // optional string description_line_2 = 8;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteStringMaybeAliased(
        8, this->_internal_description_line_2(), target);
  }

  // optional int32 size = 9 [default = 1];
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(9, this->_internal_size(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.CounterInputProto.Counter)
  return target;
}

size_t CounterInputProto_Counter::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.CounterInputProto.Counter)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int32 allowed_values = 6;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int32Size(this->allowed_values_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_allowed_values_size());
    total_size += data_size;
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // optional string label = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_label());
    }

    // optional string description_line_1 = 5;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_description_line_1());
    }

    // optional string description_line_2 = 8;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_description_line_2());
    }

    // optional int32 initial_value = 4 [default = 0];
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_initial_value());
    }

    // optional int32 size = 9 [default = 1];
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_size());
    }

    // optional int32 min_value = 2 [default = -2147483648];
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_min_value());
    }

    // optional int32 max_value = 3 [default = 2147483647];
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_max_value());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CounterInputProto_Counter::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CounterInputProto_Counter*>(
      &from));
}

void CounterInputProto_Counter::MergeFrom(const CounterInputProto_Counter& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.CounterInputProto.Counter)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  allowed_values_.MergeFrom(from.allowed_values_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_label(from._internal_label());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_description_line_1(from._internal_description_line_1());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_description_line_2(from._internal_description_line_2());
    }
    if (cached_has_bits & 0x00000008u) {
      initial_value_ = from.initial_value_;
    }
    if (cached_has_bits & 0x00000010u) {
      size_ = from.size_;
    }
    if (cached_has_bits & 0x00000020u) {
      min_value_ = from.min_value_;
    }
    if (cached_has_bits & 0x00000040u) {
      max_value_ = from.max_value_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CounterInputProto_Counter::CopyFrom(const CounterInputProto_Counter& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.CounterInputProto.Counter)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CounterInputProto_Counter::IsInitialized() const {
  return true;
}

void CounterInputProto_Counter::InternalSwap(CounterInputProto_Counter* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  allowed_values_.InternalSwap(&other->allowed_values_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &label_, lhs_arena,
      &other->label_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &description_line_1_, lhs_arena,
      &other->description_line_1_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &description_line_2_, lhs_arena,
      &other->description_line_2_, rhs_arena
  );
  swap(initial_value_, other->initial_value_);
  swap(size_, other->size_);
  swap(min_value_, other->min_value_);
  swap(max_value_, other->max_value_);
}

std::string CounterInputProto_Counter::GetTypeName() const {
  return "autofill_assistant.CounterInputProto.Counter";
}


// ===================================================================

class CounterInputProto_Result::_Internal {
 public:
};

CounterInputProto_Result::CounterInputProto_Result(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  values_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.CounterInputProto.Result)
}
CounterInputProto_Result::CounterInputProto_Result(const CounterInputProto_Result& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      values_(from.values_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.CounterInputProto.Result)
}

inline void CounterInputProto_Result::SharedCtor() {
}

CounterInputProto_Result::~CounterInputProto_Result() {
  // @@protoc_insertion_point(destructor:autofill_assistant.CounterInputProto.Result)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CounterInputProto_Result::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CounterInputProto_Result::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CounterInputProto_Result::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.CounterInputProto.Result)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  values_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CounterInputProto_Result::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated int32 values = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_values(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<8>(ptr));
        } else if (static_cast<uint8_t>(tag) == 10) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_values(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CounterInputProto_Result::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.CounterInputProto.Result)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated int32 values = 1;
  for (int i = 0, n = this->_internal_values_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_values(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.CounterInputProto.Result)
  return target;
}

size_t CounterInputProto_Result::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.CounterInputProto.Result)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int32 values = 1;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int32Size(this->values_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_values_size());
    total_size += data_size;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CounterInputProto_Result::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CounterInputProto_Result*>(
      &from));
}

void CounterInputProto_Result::MergeFrom(const CounterInputProto_Result& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.CounterInputProto.Result)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  values_.MergeFrom(from.values_);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CounterInputProto_Result::CopyFrom(const CounterInputProto_Result& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.CounterInputProto.Result)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CounterInputProto_Result::IsInitialized() const {
  return true;
}

void CounterInputProto_Result::InternalSwap(CounterInputProto_Result* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  values_.InternalSwap(&other->values_);
}

std::string CounterInputProto_Result::GetTypeName() const {
  return "autofill_assistant.CounterInputProto.Result";
}


// ===================================================================

class CounterInputProto_ValidationRule_BooleanRule::_Internal {
 public:
  using HasBits = decltype(std::declval<CounterInputProto_ValidationRule_BooleanRule>()._has_bits_);
  static void set_has_min_satisfied_rules(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_max_satisfied_rules(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CounterInputProto_ValidationRule_BooleanRule::CounterInputProto_ValidationRule_BooleanRule(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  sub_rules_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.CounterInputProto.ValidationRule.BooleanRule)
}
CounterInputProto_ValidationRule_BooleanRule::CounterInputProto_ValidationRule_BooleanRule(const CounterInputProto_ValidationRule_BooleanRule& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      sub_rules_(from.sub_rules_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&min_satisfied_rules_, &from.min_satisfied_rules_,
    static_cast<size_t>(reinterpret_cast<char*>(&max_satisfied_rules_) -
    reinterpret_cast<char*>(&min_satisfied_rules_)) + sizeof(max_satisfied_rules_));
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.CounterInputProto.ValidationRule.BooleanRule)
}

inline void CounterInputProto_ValidationRule_BooleanRule::SharedCtor() {
min_satisfied_rules_ = 0;
max_satisfied_rules_ = 2147483647;
}

CounterInputProto_ValidationRule_BooleanRule::~CounterInputProto_ValidationRule_BooleanRule() {
  // @@protoc_insertion_point(destructor:autofill_assistant.CounterInputProto.ValidationRule.BooleanRule)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CounterInputProto_ValidationRule_BooleanRule::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CounterInputProto_ValidationRule_BooleanRule::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CounterInputProto_ValidationRule_BooleanRule::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.CounterInputProto.ValidationRule.BooleanRule)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  sub_rules_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    min_satisfied_rules_ = 0;
    max_satisfied_rules_ = 2147483647;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CounterInputProto_ValidationRule_BooleanRule::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .autofill_assistant.CounterInputProto.ValidationRule sub_rules = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_sub_rules(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional int32 min_satisfied_rules = 2 [default = 0];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_min_satisfied_rules(&has_bits);
          min_satisfied_rules_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 max_satisfied_rules = 3 [default = 2147483647];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_max_satisfied_rules(&has_bits);
          max_satisfied_rules_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CounterInputProto_ValidationRule_BooleanRule::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.CounterInputProto.ValidationRule.BooleanRule)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .autofill_assistant.CounterInputProto.ValidationRule sub_rules = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_sub_rules_size()); i < n; i++) {
    const auto& repfield = this->_internal_sub_rules(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  cached_has_bits = _has_bits_[0];
  // optional int32 min_satisfied_rules = 2 [default = 0];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_min_satisfied_rules(), target);
  }

  // optional int32 max_satisfied_rules = 3 [default = 2147483647];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_max_satisfied_rules(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.CounterInputProto.ValidationRule.BooleanRule)
  return target;
}

size_t CounterInputProto_ValidationRule_BooleanRule::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.CounterInputProto.ValidationRule.BooleanRule)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .autofill_assistant.CounterInputProto.ValidationRule sub_rules = 1;
  total_size += 1UL * this->_internal_sub_rules_size();
  for (const auto& msg : this->sub_rules_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional int32 min_satisfied_rules = 2 [default = 0];
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_min_satisfied_rules());
    }

    // optional int32 max_satisfied_rules = 3 [default = 2147483647];
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_max_satisfied_rules());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CounterInputProto_ValidationRule_BooleanRule::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CounterInputProto_ValidationRule_BooleanRule*>(
      &from));
}

void CounterInputProto_ValidationRule_BooleanRule::MergeFrom(const CounterInputProto_ValidationRule_BooleanRule& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.CounterInputProto.ValidationRule.BooleanRule)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  sub_rules_.MergeFrom(from.sub_rules_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      min_satisfied_rules_ = from.min_satisfied_rules_;
    }
    if (cached_has_bits & 0x00000002u) {
      max_satisfied_rules_ = from.max_satisfied_rules_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CounterInputProto_ValidationRule_BooleanRule::CopyFrom(const CounterInputProto_ValidationRule_BooleanRule& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.CounterInputProto.ValidationRule.BooleanRule)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CounterInputProto_ValidationRule_BooleanRule::IsInitialized() const {
  return true;
}

void CounterInputProto_ValidationRule_BooleanRule::InternalSwap(CounterInputProto_ValidationRule_BooleanRule* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  sub_rules_.InternalSwap(&other->sub_rules_);
  swap(min_satisfied_rules_, other->min_satisfied_rules_);
  swap(max_satisfied_rules_, other->max_satisfied_rules_);
}

std::string CounterInputProto_ValidationRule_BooleanRule::GetTypeName() const {
  return "autofill_assistant.CounterInputProto.ValidationRule.BooleanRule";
}


// ===================================================================

class CounterInputProto_ValidationRule_CounterRule::_Internal {
 public:
  using HasBits = decltype(std::declval<CounterInputProto_ValidationRule_CounterRule>()._has_bits_);
  static void set_has_counter_index(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_min_value(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_max_value(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

CounterInputProto_ValidationRule_CounterRule::CounterInputProto_ValidationRule_CounterRule(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.CounterInputProto.ValidationRule.CounterRule)
}
CounterInputProto_ValidationRule_CounterRule::CounterInputProto_ValidationRule_CounterRule(const CounterInputProto_ValidationRule_CounterRule& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&counter_index_, &from.counter_index_,
    static_cast<size_t>(reinterpret_cast<char*>(&max_value_) -
    reinterpret_cast<char*>(&counter_index_)) + sizeof(max_value_));
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.CounterInputProto.ValidationRule.CounterRule)
}

inline void CounterInputProto_ValidationRule_CounterRule::SharedCtor() {
counter_index_ = 0;
min_value_ = -2147483647 - 1;
max_value_ = 2147483647;
}

CounterInputProto_ValidationRule_CounterRule::~CounterInputProto_ValidationRule_CounterRule() {
  // @@protoc_insertion_point(destructor:autofill_assistant.CounterInputProto.ValidationRule.CounterRule)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CounterInputProto_ValidationRule_CounterRule::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CounterInputProto_ValidationRule_CounterRule::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CounterInputProto_ValidationRule_CounterRule::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.CounterInputProto.ValidationRule.CounterRule)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    counter_index_ = 0;
    min_value_ = -2147483647 - 1;
    max_value_ = 2147483647;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CounterInputProto_ValidationRule_CounterRule::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 counter_index = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_counter_index(&has_bits);
          counter_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 min_value = 2 [default = -2147483648];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_min_value(&has_bits);
          min_value_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 max_value = 3 [default = 2147483647];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_max_value(&has_bits);
          max_value_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CounterInputProto_ValidationRule_CounterRule::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.CounterInputProto.ValidationRule.CounterRule)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 counter_index = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_counter_index(), target);
  }

  // optional int32 min_value = 2 [default = -2147483648];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_min_value(), target);
  }

  // optional int32 max_value = 3 [default = 2147483647];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_max_value(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.CounterInputProto.ValidationRule.CounterRule)
  return target;
}

size_t CounterInputProto_ValidationRule_CounterRule::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.CounterInputProto.ValidationRule.CounterRule)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional int32 counter_index = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_counter_index());
    }

    // optional int32 min_value = 2 [default = -2147483648];
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_min_value());
    }

    // optional int32 max_value = 3 [default = 2147483647];
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_max_value());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CounterInputProto_ValidationRule_CounterRule::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CounterInputProto_ValidationRule_CounterRule*>(
      &from));
}

void CounterInputProto_ValidationRule_CounterRule::MergeFrom(const CounterInputProto_ValidationRule_CounterRule& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.CounterInputProto.ValidationRule.CounterRule)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      counter_index_ = from.counter_index_;
    }
    if (cached_has_bits & 0x00000002u) {
      min_value_ = from.min_value_;
    }
    if (cached_has_bits & 0x00000004u) {
      max_value_ = from.max_value_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CounterInputProto_ValidationRule_CounterRule::CopyFrom(const CounterInputProto_ValidationRule_CounterRule& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.CounterInputProto.ValidationRule.CounterRule)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CounterInputProto_ValidationRule_CounterRule::IsInitialized() const {
  return true;
}

void CounterInputProto_ValidationRule_CounterRule::InternalSwap(CounterInputProto_ValidationRule_CounterRule* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(counter_index_, other->counter_index_);
  swap(min_value_, other->min_value_);
  swap(max_value_, other->max_value_);
}

std::string CounterInputProto_ValidationRule_CounterRule::GetTypeName() const {
  return "autofill_assistant.CounterInputProto.ValidationRule.CounterRule";
}


// ===================================================================

class CounterInputProto_ValidationRule_CountersSumRule::_Internal {
 public:
  using HasBits = decltype(std::declval<CounterInputProto_ValidationRule_CountersSumRule>()._has_bits_);
  static void set_has_min_value(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_max_value(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CounterInputProto_ValidationRule_CountersSumRule::CounterInputProto_ValidationRule_CountersSumRule(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.CounterInputProto.ValidationRule.CountersSumRule)
}
CounterInputProto_ValidationRule_CountersSumRule::CounterInputProto_ValidationRule_CountersSumRule(const CounterInputProto_ValidationRule_CountersSumRule& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&min_value_, &from.min_value_,
    static_cast<size_t>(reinterpret_cast<char*>(&max_value_) -
    reinterpret_cast<char*>(&min_value_)) + sizeof(max_value_));
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.CounterInputProto.ValidationRule.CountersSumRule)
}

inline void CounterInputProto_ValidationRule_CountersSumRule::SharedCtor() {
min_value_ = int64_t{-9223372036854775807} - 1;
max_value_ = int64_t{9223372036854775807};
}

CounterInputProto_ValidationRule_CountersSumRule::~CounterInputProto_ValidationRule_CountersSumRule() {
  // @@protoc_insertion_point(destructor:autofill_assistant.CounterInputProto.ValidationRule.CountersSumRule)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CounterInputProto_ValidationRule_CountersSumRule::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CounterInputProto_ValidationRule_CountersSumRule::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CounterInputProto_ValidationRule_CountersSumRule::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.CounterInputProto.ValidationRule.CountersSumRule)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    min_value_ = int64_t{-9223372036854775807} - 1;
    max_value_ = int64_t{9223372036854775807};
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CounterInputProto_ValidationRule_CountersSumRule::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 min_value = 1 [default = -9223372036854775808];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_min_value(&has_bits);
          min_value_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 max_value = 2 [default = 9223372036854775807];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_max_value(&has_bits);
          max_value_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CounterInputProto_ValidationRule_CountersSumRule::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.CounterInputProto.ValidationRule.CountersSumRule)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int64 min_value = 1 [default = -9223372036854775808];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_min_value(), target);
  }

  // optional int64 max_value = 2 [default = 9223372036854775807];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_max_value(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.CounterInputProto.ValidationRule.CountersSumRule)
  return target;
}

size_t CounterInputProto_ValidationRule_CountersSumRule::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.CounterInputProto.ValidationRule.CountersSumRule)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional int64 min_value = 1 [default = -9223372036854775808];
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_min_value());
    }

    // optional int64 max_value = 2 [default = 9223372036854775807];
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_max_value());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CounterInputProto_ValidationRule_CountersSumRule::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CounterInputProto_ValidationRule_CountersSumRule*>(
      &from));
}

void CounterInputProto_ValidationRule_CountersSumRule::MergeFrom(const CounterInputProto_ValidationRule_CountersSumRule& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.CounterInputProto.ValidationRule.CountersSumRule)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      min_value_ = from.min_value_;
    }
    if (cached_has_bits & 0x00000002u) {
      max_value_ = from.max_value_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CounterInputProto_ValidationRule_CountersSumRule::CopyFrom(const CounterInputProto_ValidationRule_CountersSumRule& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.CounterInputProto.ValidationRule.CountersSumRule)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CounterInputProto_ValidationRule_CountersSumRule::IsInitialized() const {
  return true;
}

void CounterInputProto_ValidationRule_CountersSumRule::InternalSwap(CounterInputProto_ValidationRule_CountersSumRule* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(min_value_, other->min_value_);
  swap(max_value_, other->max_value_);
}

std::string CounterInputProto_ValidationRule_CountersSumRule::GetTypeName() const {
  return "autofill_assistant.CounterInputProto.ValidationRule.CountersSumRule";
}


// ===================================================================

class CounterInputProto_ValidationRule::_Internal {
 public:
  static const ::autofill_assistant::CounterInputProto_ValidationRule_BooleanRule& boolean(const CounterInputProto_ValidationRule* msg);
  static const ::autofill_assistant::CounterInputProto_ValidationRule_CounterRule& counter(const CounterInputProto_ValidationRule* msg);
  static const ::autofill_assistant::CounterInputProto_ValidationRule_CountersSumRule& counters_sum(const CounterInputProto_ValidationRule* msg);
};

const ::autofill_assistant::CounterInputProto_ValidationRule_BooleanRule&
CounterInputProto_ValidationRule::_Internal::boolean(const CounterInputProto_ValidationRule* msg) {
  return *msg->rule_type_.boolean_;
}
const ::autofill_assistant::CounterInputProto_ValidationRule_CounterRule&
CounterInputProto_ValidationRule::_Internal::counter(const CounterInputProto_ValidationRule* msg) {
  return *msg->rule_type_.counter_;
}
const ::autofill_assistant::CounterInputProto_ValidationRule_CountersSumRule&
CounterInputProto_ValidationRule::_Internal::counters_sum(const CounterInputProto_ValidationRule* msg) {
  return *msg->rule_type_.counters_sum_;
}
void CounterInputProto_ValidationRule::set_allocated_boolean(::autofill_assistant::CounterInputProto_ValidationRule_BooleanRule* boolean) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_rule_type();
  if (boolean) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(boolean);
    if (message_arena != submessage_arena) {
      boolean = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, boolean, submessage_arena);
    }
    set_has_boolean();
    rule_type_.boolean_ = boolean;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.CounterInputProto.ValidationRule.boolean)
}
void CounterInputProto_ValidationRule::set_allocated_counter(::autofill_assistant::CounterInputProto_ValidationRule_CounterRule* counter) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_rule_type();
  if (counter) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(counter);
    if (message_arena != submessage_arena) {
      counter = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, counter, submessage_arena);
    }
    set_has_counter();
    rule_type_.counter_ = counter;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.CounterInputProto.ValidationRule.counter)
}
void CounterInputProto_ValidationRule::set_allocated_counters_sum(::autofill_assistant::CounterInputProto_ValidationRule_CountersSumRule* counters_sum) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_rule_type();
  if (counters_sum) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(counters_sum);
    if (message_arena != submessage_arena) {
      counters_sum = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, counters_sum, submessage_arena);
    }
    set_has_counters_sum();
    rule_type_.counters_sum_ = counters_sum;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.CounterInputProto.ValidationRule.counters_sum)
}
CounterInputProto_ValidationRule::CounterInputProto_ValidationRule(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.CounterInputProto.ValidationRule)
}
CounterInputProto_ValidationRule::CounterInputProto_ValidationRule(const CounterInputProto_ValidationRule& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  clear_has_rule_type();
  switch (from.rule_type_case()) {
    case kBoolean: {
      _internal_mutable_boolean()->::autofill_assistant::CounterInputProto_ValidationRule_BooleanRule::MergeFrom(from._internal_boolean());
      break;
    }
    case kCounter: {
      _internal_mutable_counter()->::autofill_assistant::CounterInputProto_ValidationRule_CounterRule::MergeFrom(from._internal_counter());
      break;
    }
    case kCountersSum: {
      _internal_mutable_counters_sum()->::autofill_assistant::CounterInputProto_ValidationRule_CountersSumRule::MergeFrom(from._internal_counters_sum());
      break;
    }
    case RULE_TYPE_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.CounterInputProto.ValidationRule)
}

inline void CounterInputProto_ValidationRule::SharedCtor() {
clear_has_rule_type();
}

CounterInputProto_ValidationRule::~CounterInputProto_ValidationRule() {
  // @@protoc_insertion_point(destructor:autofill_assistant.CounterInputProto.ValidationRule)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CounterInputProto_ValidationRule::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_rule_type()) {
    clear_rule_type();
  }
}

void CounterInputProto_ValidationRule::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CounterInputProto_ValidationRule::clear_rule_type() {
// @@protoc_insertion_point(one_of_clear_start:autofill_assistant.CounterInputProto.ValidationRule)
  switch (rule_type_case()) {
    case kBoolean: {
      if (GetArenaForAllocation() == nullptr) {
        delete rule_type_.boolean_;
      }
      break;
    }
    case kCounter: {
      if (GetArenaForAllocation() == nullptr) {
        delete rule_type_.counter_;
      }
      break;
    }
    case kCountersSum: {
      if (GetArenaForAllocation() == nullptr) {
        delete rule_type_.counters_sum_;
      }
      break;
    }
    case RULE_TYPE_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = RULE_TYPE_NOT_SET;
}


void CounterInputProto_ValidationRule::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.CounterInputProto.ValidationRule)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_rule_type();
  _internal_metadata_.Clear<std::string>();
}

const char* CounterInputProto_ValidationRule::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .autofill_assistant.CounterInputProto.ValidationRule.BooleanRule boolean = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_boolean(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.CounterInputProto.ValidationRule.CounterRule counter = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_counter(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.CounterInputProto.ValidationRule.CountersSumRule counters_sum = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_counters_sum(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CounterInputProto_ValidationRule::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.CounterInputProto.ValidationRule)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (rule_type_case()) {
    case kBoolean: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, _Internal::boolean(this),
          _Internal::boolean(this).GetCachedSize(), target, stream);
      break;
    }
    case kCounter: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, _Internal::counter(this),
          _Internal::counter(this).GetCachedSize(), target, stream);
      break;
    }
    case kCountersSum: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, _Internal::counters_sum(this),
          _Internal::counters_sum(this).GetCachedSize(), target, stream);
      break;
    }
    default: ;
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.CounterInputProto.ValidationRule)
  return target;
}

size_t CounterInputProto_ValidationRule::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.CounterInputProto.ValidationRule)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (rule_type_case()) {
    // .autofill_assistant.CounterInputProto.ValidationRule.BooleanRule boolean = 1;
    case kBoolean: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *rule_type_.boolean_);
      break;
    }
    // .autofill_assistant.CounterInputProto.ValidationRule.CounterRule counter = 2;
    case kCounter: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *rule_type_.counter_);
      break;
    }
    // .autofill_assistant.CounterInputProto.ValidationRule.CountersSumRule counters_sum = 3;
    case kCountersSum: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *rule_type_.counters_sum_);
      break;
    }
    case RULE_TYPE_NOT_SET: {
      break;
    }
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CounterInputProto_ValidationRule::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CounterInputProto_ValidationRule*>(
      &from));
}

void CounterInputProto_ValidationRule::MergeFrom(const CounterInputProto_ValidationRule& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.CounterInputProto.ValidationRule)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.rule_type_case()) {
    case kBoolean: {
      _internal_mutable_boolean()->::autofill_assistant::CounterInputProto_ValidationRule_BooleanRule::MergeFrom(from._internal_boolean());
      break;
    }
    case kCounter: {
      _internal_mutable_counter()->::autofill_assistant::CounterInputProto_ValidationRule_CounterRule::MergeFrom(from._internal_counter());
      break;
    }
    case kCountersSum: {
      _internal_mutable_counters_sum()->::autofill_assistant::CounterInputProto_ValidationRule_CountersSumRule::MergeFrom(from._internal_counters_sum());
      break;
    }
    case RULE_TYPE_NOT_SET: {
      break;
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CounterInputProto_ValidationRule::CopyFrom(const CounterInputProto_ValidationRule& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.CounterInputProto.ValidationRule)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CounterInputProto_ValidationRule::IsInitialized() const {
  return true;
}

void CounterInputProto_ValidationRule::InternalSwap(CounterInputProto_ValidationRule* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(rule_type_, other->rule_type_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

std::string CounterInputProto_ValidationRule::GetTypeName() const {
  return "autofill_assistant.CounterInputProto.ValidationRule";
}


// ===================================================================

class CounterInputProto::_Internal {
 public:
  using HasBits = decltype(std::declval<CounterInputProto>()._has_bits_);
  static void set_has_label(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_minimized_count(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_expand_text(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_minimize_text(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::autofill_assistant::CounterInputProto_ValidationRule& validation_rule(const CounterInputProto* msg);
  static void set_has_validation_rule(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_min_counters_sum(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_max_counters_sum(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
};

const ::autofill_assistant::CounterInputProto_ValidationRule&
CounterInputProto::_Internal::validation_rule(const CounterInputProto* msg) {
  return *msg->validation_rule_;
}
CounterInputProto::CounterInputProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  counters_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.CounterInputProto)
}
CounterInputProto::CounterInputProto(const CounterInputProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      counters_(from.counters_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  label_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    label_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_label()) {
    label_.Set(from._internal_label(), 
      GetArenaForAllocation());
  }
  expand_text_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    expand_text_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_expand_text()) {
    expand_text_.Set(from._internal_expand_text(), 
      GetArenaForAllocation());
  }
  minimize_text_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    minimize_text_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_minimize_text()) {
    minimize_text_.Set(from._internal_minimize_text(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_validation_rule()) {
    validation_rule_ = new ::autofill_assistant::CounterInputProto_ValidationRule(*from.validation_rule_);
  } else {
    validation_rule_ = nullptr;
  }
  ::memcpy(&minimized_count_, &from.minimized_count_,
    static_cast<size_t>(reinterpret_cast<char*>(&max_counters_sum_) -
    reinterpret_cast<char*>(&minimized_count_)) + sizeof(max_counters_sum_));
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.CounterInputProto)
}

inline void CounterInputProto::SharedCtor() {
label_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  label_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
expand_text_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  expand_text_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
minimize_text_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  minimize_text_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
validation_rule_ = nullptr;
minimized_count_ = 2147483647;
min_counters_sum_ = int64_t{-9223372036854775807} - 1;
max_counters_sum_ = int64_t{9223372036854775807};
}

CounterInputProto::~CounterInputProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.CounterInputProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CounterInputProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  label_.Destroy();
  expand_text_.Destroy();
  minimize_text_.Destroy();
  if (this != internal_default_instance()) delete validation_rule_;
}

void CounterInputProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CounterInputProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.CounterInputProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  counters_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      label_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      expand_text_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      minimize_text_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(validation_rule_ != nullptr);
      validation_rule_->Clear();
    }
    minimized_count_ = 2147483647;
    min_counters_sum_ = int64_t{-9223372036854775807} - 1;
    max_counters_sum_ = int64_t{9223372036854775807};
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CounterInputProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string label = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_label();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .autofill_assistant.CounterInputProto.Counter counters = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_counters(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional int32 minimized_count = 3 [default = 2147483647];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_minimized_count(&has_bits);
          minimized_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string expand_text = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_expand_text();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string minimize_text = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_minimize_text();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .autofill_assistant.CounterInputProto.ValidationRule validation_rule = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_validation_rule(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 min_counters_sum = 7 [default = -9223372036854775808];
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_min_counters_sum(&has_bits);
          min_counters_sum_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 max_counters_sum = 8 [default = 9223372036854775807];
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_max_counters_sum(&has_bits);
          max_counters_sum_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CounterInputProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.CounterInputProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string label = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_label(), target);
  }

  // repeated .autofill_assistant.CounterInputProto.Counter counters = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_counters_size()); i < n; i++) {
    const auto& repfield = this->_internal_counters(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional int32 minimized_count = 3 [default = 2147483647];
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_minimized_count(), target);
  }

  // optional string expand_text = 4;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_expand_text(), target);
  }

  // optional string minimize_text = 5;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_minimize_text(), target);
  }

  // optional .autofill_assistant.CounterInputProto.ValidationRule validation_rule = 6;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::validation_rule(this),
        _Internal::validation_rule(this).GetCachedSize(), target, stream);
  }

  // optional int64 min_counters_sum = 7 [default = -9223372036854775808];
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(7, this->_internal_min_counters_sum(), target);
  }

  // optional int64 max_counters_sum = 8 [default = 9223372036854775807];
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(8, this->_internal_max_counters_sum(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.CounterInputProto)
  return target;
}

size_t CounterInputProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.CounterInputProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .autofill_assistant.CounterInputProto.Counter counters = 2;
  total_size += 1UL * this->_internal_counters_size();
  for (const auto& msg : this->counters_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // optional string label = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_label());
    }

    // optional string expand_text = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_expand_text());
    }

    // optional string minimize_text = 5;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_minimize_text());
    }

    // optional .autofill_assistant.CounterInputProto.ValidationRule validation_rule = 6;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *validation_rule_);
    }

    // optional int32 minimized_count = 3 [default = 2147483647];
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_minimized_count());
    }

    // optional int64 min_counters_sum = 7 [default = -9223372036854775808];
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_min_counters_sum());
    }

    // optional int64 max_counters_sum = 8 [default = 9223372036854775807];
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_max_counters_sum());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CounterInputProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CounterInputProto*>(
      &from));
}

void CounterInputProto::MergeFrom(const CounterInputProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.CounterInputProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  counters_.MergeFrom(from.counters_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_label(from._internal_label());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_expand_text(from._internal_expand_text());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_minimize_text(from._internal_minimize_text());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_mutable_validation_rule()->::autofill_assistant::CounterInputProto_ValidationRule::MergeFrom(from._internal_validation_rule());
    }
    if (cached_has_bits & 0x00000010u) {
      minimized_count_ = from.minimized_count_;
    }
    if (cached_has_bits & 0x00000020u) {
      min_counters_sum_ = from.min_counters_sum_;
    }
    if (cached_has_bits & 0x00000040u) {
      max_counters_sum_ = from.max_counters_sum_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CounterInputProto::CopyFrom(const CounterInputProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.CounterInputProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CounterInputProto::IsInitialized() const {
  return true;
}

void CounterInputProto::InternalSwap(CounterInputProto* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  counters_.InternalSwap(&other->counters_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &label_, lhs_arena,
      &other->label_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &expand_text_, lhs_arena,
      &other->expand_text_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &minimize_text_, lhs_arena,
      &other->minimize_text_, rhs_arena
  );
  swap(validation_rule_, other->validation_rule_);
  swap(minimized_count_, other->minimized_count_);
  swap(min_counters_sum_, other->min_counters_sum_);
  swap(max_counters_sum_, other->max_counters_sum_);
}

std::string CounterInputProto::GetTypeName() const {
  return "autofill_assistant.CounterInputProto";
}


// ===================================================================

class SelectionInputProto_Choice::_Internal {
 public:
  using HasBits = decltype(std::declval<SelectionInputProto_Choice>()._has_bits_);
  static void set_has_label(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_description_line_1(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_description_line_2(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_selected(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

SelectionInputProto_Choice::SelectionInputProto_Choice(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.SelectionInputProto.Choice)
}
SelectionInputProto_Choice::SelectionInputProto_Choice(const SelectionInputProto_Choice& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  label_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    label_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_label()) {
    label_.Set(from._internal_label(), 
      GetArenaForAllocation());
  }
  description_line_1_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    description_line_1_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_description_line_1()) {
    description_line_1_.Set(from._internal_description_line_1(), 
      GetArenaForAllocation());
  }
  description_line_2_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    description_line_2_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_description_line_2()) {
    description_line_2_.Set(from._internal_description_line_2(), 
      GetArenaForAllocation());
  }
  selected_ = from.selected_;
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.SelectionInputProto.Choice)
}

inline void SelectionInputProto_Choice::SharedCtor() {
label_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  label_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
description_line_1_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  description_line_1_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
description_line_2_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  description_line_2_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
selected_ = false;
}

SelectionInputProto_Choice::~SelectionInputProto_Choice() {
  // @@protoc_insertion_point(destructor:autofill_assistant.SelectionInputProto.Choice)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SelectionInputProto_Choice::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  label_.Destroy();
  description_line_1_.Destroy();
  description_line_2_.Destroy();
}

void SelectionInputProto_Choice::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SelectionInputProto_Choice::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.SelectionInputProto.Choice)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      label_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      description_line_1_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      description_line_2_.ClearNonDefaultToEmpty();
    }
  }
  selected_ = false;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* SelectionInputProto_Choice::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string label = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_label();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool selected = 2 [default = false];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_selected(&has_bits);
          selected_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string description_line_1 = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_description_line_1();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string description_line_2 = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_description_line_2();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SelectionInputProto_Choice::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.SelectionInputProto.Choice)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string label = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_label(), target);
  }

  // optional bool selected = 2 [default = false];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_selected(), target);
  }

  // optional string description_line_1 = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_description_line_1(), target);
  }

  // optional string description_line_2 = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_description_line_2(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.SelectionInputProto.Choice)
  return target;
}

size_t SelectionInputProto_Choice::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.SelectionInputProto.Choice)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string label = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_label());
    }

    // optional string description_line_1 = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_description_line_1());
    }

    // optional string description_line_2 = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_description_line_2());
    }

    // optional bool selected = 2 [default = false];
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SelectionInputProto_Choice::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const SelectionInputProto_Choice*>(
      &from));
}

void SelectionInputProto_Choice::MergeFrom(const SelectionInputProto_Choice& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.SelectionInputProto.Choice)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_label(from._internal_label());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_description_line_1(from._internal_description_line_1());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_description_line_2(from._internal_description_line_2());
    }
    if (cached_has_bits & 0x00000008u) {
      selected_ = from.selected_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SelectionInputProto_Choice::CopyFrom(const SelectionInputProto_Choice& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.SelectionInputProto.Choice)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SelectionInputProto_Choice::IsInitialized() const {
  return true;
}

void SelectionInputProto_Choice::InternalSwap(SelectionInputProto_Choice* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &label_, lhs_arena,
      &other->label_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &description_line_1_, lhs_arena,
      &other->description_line_1_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &description_line_2_, lhs_arena,
      &other->description_line_2_, rhs_arena
  );
  swap(selected_, other->selected_);
}

std::string SelectionInputProto_Choice::GetTypeName() const {
  return "autofill_assistant.SelectionInputProto.Choice";
}


// ===================================================================

class SelectionInputProto_Result::_Internal {
 public:
};

SelectionInputProto_Result::SelectionInputProto_Result(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  selected_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.SelectionInputProto.Result)
}
SelectionInputProto_Result::SelectionInputProto_Result(const SelectionInputProto_Result& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      selected_(from.selected_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.SelectionInputProto.Result)
}

inline void SelectionInputProto_Result::SharedCtor() {
}

SelectionInputProto_Result::~SelectionInputProto_Result() {
  // @@protoc_insertion_point(destructor:autofill_assistant.SelectionInputProto.Result)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SelectionInputProto_Result::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void SelectionInputProto_Result::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SelectionInputProto_Result::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.SelectionInputProto.Result)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  selected_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* SelectionInputProto_Result::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated bool selected = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_selected(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<8>(ptr));
        } else if (static_cast<uint8_t>(tag) == 10) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedBoolParser(_internal_mutable_selected(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SelectionInputProto_Result::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.SelectionInputProto.Result)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated bool selected = 1;
  for (int i = 0, n = this->_internal_selected_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_selected(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.SelectionInputProto.Result)
  return target;
}

size_t SelectionInputProto_Result::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.SelectionInputProto.Result)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated bool selected = 1;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_selected_size());
    size_t data_size = 1UL * count;
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_selected_size());
    total_size += data_size;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SelectionInputProto_Result::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const SelectionInputProto_Result*>(
      &from));
}

void SelectionInputProto_Result::MergeFrom(const SelectionInputProto_Result& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.SelectionInputProto.Result)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  selected_.MergeFrom(from.selected_);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SelectionInputProto_Result::CopyFrom(const SelectionInputProto_Result& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.SelectionInputProto.Result)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SelectionInputProto_Result::IsInitialized() const {
  return true;
}

void SelectionInputProto_Result::InternalSwap(SelectionInputProto_Result* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  selected_.InternalSwap(&other->selected_);
}

std::string SelectionInputProto_Result::GetTypeName() const {
  return "autofill_assistant.SelectionInputProto.Result";
}


// ===================================================================

class SelectionInputProto::_Internal {
 public:
  using HasBits = decltype(std::declval<SelectionInputProto>()._has_bits_);
  static void set_has_label(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_allow_multiple(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_min_selected_choices(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

SelectionInputProto::SelectionInputProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  choices_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.SelectionInputProto)
}
SelectionInputProto::SelectionInputProto(const SelectionInputProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      choices_(from.choices_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  label_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    label_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_label()) {
    label_.Set(from._internal_label(), 
      GetArenaForAllocation());
  }
  ::memcpy(&allow_multiple_, &from.allow_multiple_,
    static_cast<size_t>(reinterpret_cast<char*>(&min_selected_choices_) -
    reinterpret_cast<char*>(&allow_multiple_)) + sizeof(min_selected_choices_));
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.SelectionInputProto)
}

inline void SelectionInputProto::SharedCtor() {
label_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  label_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
allow_multiple_ = false;
min_selected_choices_ = 1;
}

SelectionInputProto::~SelectionInputProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.SelectionInputProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SelectionInputProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  label_.Destroy();
}

void SelectionInputProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SelectionInputProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.SelectionInputProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  choices_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    label_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    allow_multiple_ = false;
    min_selected_choices_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* SelectionInputProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string label = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_label();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .autofill_assistant.SelectionInputProto.Choice choices = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_choices(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional bool allow_multiple = 3 [default = false];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_allow_multiple(&has_bits);
          allow_multiple_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 min_selected_choices = 4 [default = 1];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_min_selected_choices(&has_bits);
          min_selected_choices_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SelectionInputProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.SelectionInputProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string label = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_label(), target);
  }

  // repeated .autofill_assistant.SelectionInputProto.Choice choices = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_choices_size()); i < n; i++) {
    const auto& repfield = this->_internal_choices(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional bool allow_multiple = 3 [default = false];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_allow_multiple(), target);
  }

  // optional int32 min_selected_choices = 4 [default = 1];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_min_selected_choices(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.SelectionInputProto)
  return target;
}

size_t SelectionInputProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.SelectionInputProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .autofill_assistant.SelectionInputProto.Choice choices = 2;
  total_size += 1UL * this->_internal_choices_size();
  for (const auto& msg : this->choices_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string label = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_label());
    }

    // optional bool allow_multiple = 3 [default = false];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

    // optional int32 min_selected_choices = 4 [default = 1];
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_min_selected_choices());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SelectionInputProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const SelectionInputProto*>(
      &from));
}

void SelectionInputProto::MergeFrom(const SelectionInputProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.SelectionInputProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  choices_.MergeFrom(from.choices_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_label(from._internal_label());
    }
    if (cached_has_bits & 0x00000002u) {
      allow_multiple_ = from.allow_multiple_;
    }
    if (cached_has_bits & 0x00000004u) {
      min_selected_choices_ = from.min_selected_choices_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SelectionInputProto::CopyFrom(const SelectionInputProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.SelectionInputProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SelectionInputProto::IsInitialized() const {
  return true;
}

void SelectionInputProto::InternalSwap(SelectionInputProto* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  choices_.InternalSwap(&other->choices_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &label_, lhs_arena,
      &other->label_, rhs_arena
  );
  swap(allow_multiple_, other->allow_multiple_);
  swap(min_selected_choices_, other->min_selected_choices_);
}

std::string SelectionInputProto::GetTypeName() const {
  return "autofill_assistant.SelectionInputProto";
}


// ===================================================================

class PopupMessageProto::_Internal {
 public:
  using HasBits = decltype(std::declval<PopupMessageProto>()._has_bits_);
  static void set_has_message(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

PopupMessageProto::PopupMessageProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.PopupMessageProto)
}
PopupMessageProto::PopupMessageProto(const PopupMessageProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  message_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    message_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_message()) {
    message_.Set(from._internal_message(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.PopupMessageProto)
}

inline void PopupMessageProto::SharedCtor() {
message_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  message_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

PopupMessageProto::~PopupMessageProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.PopupMessageProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PopupMessageProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  message_.Destroy();
}

void PopupMessageProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void PopupMessageProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.PopupMessageProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    message_.ClearNonDefaultToEmpty();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* PopupMessageProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string message = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_message();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PopupMessageProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.PopupMessageProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string message = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_message(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.PopupMessageProto)
  return target;
}

size_t PopupMessageProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.PopupMessageProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string message = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_message());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void PopupMessageProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const PopupMessageProto*>(
      &from));
}

void PopupMessageProto::MergeFrom(const PopupMessageProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.PopupMessageProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_message()) {
    _internal_set_message(from._internal_message());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void PopupMessageProto::CopyFrom(const PopupMessageProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.PopupMessageProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PopupMessageProto::IsInitialized() const {
  return true;
}

void PopupMessageProto::InternalSwap(PopupMessageProto* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &message_, lhs_arena,
      &other->message_, rhs_arena
  );
}

std::string PopupMessageProto::GetTypeName() const {
  return "autofill_assistant.PopupMessageProto";
}


// ===================================================================

class GetElementStatusProto_Result::_Internal {
 public:
  using HasBits = decltype(std::declval<GetElementStatusProto_Result>()._has_bits_);
  static void set_has_not_empty(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_match_success(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_expected_empty_match(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

GetElementStatusProto_Result::GetElementStatusProto_Result(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  reports_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.GetElementStatusProto.Result)
}
GetElementStatusProto_Result::GetElementStatusProto_Result(const GetElementStatusProto_Result& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      reports_(from.reports_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&not_empty_, &from.not_empty_,
    static_cast<size_t>(reinterpret_cast<char*>(&expected_empty_match_) -
    reinterpret_cast<char*>(&not_empty_)) + sizeof(expected_empty_match_));
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.GetElementStatusProto.Result)
}

inline void GetElementStatusProto_Result::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&not_empty_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&expected_empty_match_) -
    reinterpret_cast<char*>(&not_empty_)) + sizeof(expected_empty_match_));
}

GetElementStatusProto_Result::~GetElementStatusProto_Result() {
  // @@protoc_insertion_point(destructor:autofill_assistant.GetElementStatusProto.Result)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GetElementStatusProto_Result::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void GetElementStatusProto_Result::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void GetElementStatusProto_Result::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.GetElementStatusProto.Result)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  reports_.Clear();
  ::memset(&not_empty_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&expected_empty_match_) -
      reinterpret_cast<char*>(&not_empty_)) + sizeof(expected_empty_match_));
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* GetElementStatusProto_Result::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool not_empty = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_not_empty(&has_bits);
          not_empty_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool match_success = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_match_success(&has_bits);
          match_success_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .autofill_assistant.GetElementStatusProto.ComparisonReport reports = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_reports(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional bool expected_empty_match = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_expected_empty_match(&has_bits);
          expected_empty_match_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GetElementStatusProto_Result::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.GetElementStatusProto.Result)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bool not_empty = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_not_empty(), target);
  }

  // optional bool match_success = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_match_success(), target);
  }

  // repeated .autofill_assistant.GetElementStatusProto.ComparisonReport reports = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_reports_size()); i < n; i++) {
    const auto& repfield = this->_internal_reports(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional bool expected_empty_match = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_expected_empty_match(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.GetElementStatusProto.Result)
  return target;
}

size_t GetElementStatusProto_Result::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.GetElementStatusProto.Result)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .autofill_assistant.GetElementStatusProto.ComparisonReport reports = 3;
  total_size += 1UL * this->_internal_reports_size();
  for (const auto& msg : this->reports_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional bool not_empty = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 1;
    }

    // optional bool match_success = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

    // optional bool expected_empty_match = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void GetElementStatusProto_Result::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const GetElementStatusProto_Result*>(
      &from));
}

void GetElementStatusProto_Result::MergeFrom(const GetElementStatusProto_Result& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.GetElementStatusProto.Result)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  reports_.MergeFrom(from.reports_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      not_empty_ = from.not_empty_;
    }
    if (cached_has_bits & 0x00000002u) {
      match_success_ = from.match_success_;
    }
    if (cached_has_bits & 0x00000004u) {
      expected_empty_match_ = from.expected_empty_match_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void GetElementStatusProto_Result::CopyFrom(const GetElementStatusProto_Result& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.GetElementStatusProto.Result)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetElementStatusProto_Result::IsInitialized() const {
  return true;
}

void GetElementStatusProto_Result::InternalSwap(GetElementStatusProto_Result* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  reports_.InternalSwap(&other->reports_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(GetElementStatusProto_Result, expected_empty_match_)
      + sizeof(GetElementStatusProto_Result::expected_empty_match_)
      - PROTOBUF_FIELD_OFFSET(GetElementStatusProto_Result, not_empty_)>(
          reinterpret_cast<char*>(&not_empty_),
          reinterpret_cast<char*>(&other->not_empty_));
}

std::string GetElementStatusProto_Result::GetTypeName() const {
  return "autofill_assistant.GetElementStatusProto.Result";
}


// ===================================================================

class GetElementStatusProto_MatchOptions::_Internal {
 public:
  using HasBits = decltype(std::declval<GetElementStatusProto_MatchOptions>()._has_bits_);
  static void set_has_case_sensitive(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_remove_space(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_find_and_remove_re2(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

GetElementStatusProto_MatchOptions::GetElementStatusProto_MatchOptions(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.GetElementStatusProto.MatchOptions)
}
GetElementStatusProto_MatchOptions::GetElementStatusProto_MatchOptions(const GetElementStatusProto_MatchOptions& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  find_and_remove_re2_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    find_and_remove_re2_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_find_and_remove_re2()) {
    find_and_remove_re2_.Set(from._internal_find_and_remove_re2(), 
      GetArenaForAllocation());
  }
  ::memcpy(&case_sensitive_, &from.case_sensitive_,
    static_cast<size_t>(reinterpret_cast<char*>(&remove_space_) -
    reinterpret_cast<char*>(&case_sensitive_)) + sizeof(remove_space_));
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.GetElementStatusProto.MatchOptions)
}

inline void GetElementStatusProto_MatchOptions::SharedCtor() {
find_and_remove_re2_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  find_and_remove_re2_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&case_sensitive_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&remove_space_) -
    reinterpret_cast<char*>(&case_sensitive_)) + sizeof(remove_space_));
}

GetElementStatusProto_MatchOptions::~GetElementStatusProto_MatchOptions() {
  // @@protoc_insertion_point(destructor:autofill_assistant.GetElementStatusProto.MatchOptions)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GetElementStatusProto_MatchOptions::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  find_and_remove_re2_.Destroy();
}

void GetElementStatusProto_MatchOptions::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void GetElementStatusProto_MatchOptions::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.GetElementStatusProto.MatchOptions)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    find_and_remove_re2_.ClearNonDefaultToEmpty();
  }
  ::memset(&case_sensitive_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&remove_space_) -
      reinterpret_cast<char*>(&case_sensitive_)) + sizeof(remove_space_));
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* GetElementStatusProto_MatchOptions::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool case_sensitive = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_case_sensitive(&has_bits);
          case_sensitive_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool remove_space = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_remove_space(&has_bits);
          remove_space_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string find_and_remove_re2 = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_find_and_remove_re2();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GetElementStatusProto_MatchOptions::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.GetElementStatusProto.MatchOptions)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bool case_sensitive = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_case_sensitive(), target);
  }

  // optional bool remove_space = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_remove_space(), target);
  }

  // optional string find_and_remove_re2 = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_find_and_remove_re2(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.GetElementStatusProto.MatchOptions)
  return target;
}

size_t GetElementStatusProto_MatchOptions::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.GetElementStatusProto.MatchOptions)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string find_and_remove_re2 = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_find_and_remove_re2());
    }

    // optional bool case_sensitive = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

    // optional bool remove_space = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void GetElementStatusProto_MatchOptions::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const GetElementStatusProto_MatchOptions*>(
      &from));
}

void GetElementStatusProto_MatchOptions::MergeFrom(const GetElementStatusProto_MatchOptions& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.GetElementStatusProto.MatchOptions)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_find_and_remove_re2(from._internal_find_and_remove_re2());
    }
    if (cached_has_bits & 0x00000002u) {
      case_sensitive_ = from.case_sensitive_;
    }
    if (cached_has_bits & 0x00000004u) {
      remove_space_ = from.remove_space_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void GetElementStatusProto_MatchOptions::CopyFrom(const GetElementStatusProto_MatchOptions& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.GetElementStatusProto.MatchOptions)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetElementStatusProto_MatchOptions::IsInitialized() const {
  return true;
}

void GetElementStatusProto_MatchOptions::InternalSwap(GetElementStatusProto_MatchOptions* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &find_and_remove_re2_, lhs_arena,
      &other->find_and_remove_re2_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(GetElementStatusProto_MatchOptions, remove_space_)
      + sizeof(GetElementStatusProto_MatchOptions::remove_space_)
      - PROTOBUF_FIELD_OFFSET(GetElementStatusProto_MatchOptions, case_sensitive_)>(
          reinterpret_cast<char*>(&case_sensitive_),
          reinterpret_cast<char*>(&other->case_sensitive_));
}

std::string GetElementStatusProto_MatchOptions::GetTypeName() const {
  return "autofill_assistant.GetElementStatusProto.MatchOptions";
}


// ===================================================================

class GetElementStatusProto_MatchExpectation::_Internal {
 public:
  using HasBits = decltype(std::declval<GetElementStatusProto_MatchExpectation>()._has_bits_);
  static const ::autofill_assistant::GetElementStatusProto_MatchOptions& match_options(const GetElementStatusProto_MatchExpectation* msg);
  static void set_has_match_options(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::autofill_assistant::GetElementStatusProto_MatchOptions&
GetElementStatusProto_MatchExpectation::_Internal::match_options(const GetElementStatusProto_MatchExpectation* msg) {
  return *msg->match_options_;
}
GetElementStatusProto_MatchExpectation::GetElementStatusProto_MatchExpectation(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.GetElementStatusProto.MatchExpectation)
}
GetElementStatusProto_MatchExpectation::GetElementStatusProto_MatchExpectation(const GetElementStatusProto_MatchExpectation& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_match_options()) {
    match_options_ = new ::autofill_assistant::GetElementStatusProto_MatchOptions(*from.match_options_);
  } else {
    match_options_ = nullptr;
  }
  clear_has_match_level();
  switch (from.match_level_case()) {
    case kFullMatch: {
      _internal_set_full_match(from._internal_full_match());
      break;
    }
    case kContains: {
      _internal_set_contains(from._internal_contains());
      break;
    }
    case kStartsWith: {
      _internal_set_starts_with(from._internal_starts_with());
      break;
    }
    case kEndsWith: {
      _internal_set_ends_with(from._internal_ends_with());
      break;
    }
    case MATCH_LEVEL_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.GetElementStatusProto.MatchExpectation)
}

inline void GetElementStatusProto_MatchExpectation::SharedCtor() {
match_options_ = nullptr;
clear_has_match_level();
}

GetElementStatusProto_MatchExpectation::~GetElementStatusProto_MatchExpectation() {
  // @@protoc_insertion_point(destructor:autofill_assistant.GetElementStatusProto.MatchExpectation)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GetElementStatusProto_MatchExpectation::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete match_options_;
  if (has_match_level()) {
    clear_match_level();
  }
}

void GetElementStatusProto_MatchExpectation::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void GetElementStatusProto_MatchExpectation::clear_match_level() {
// @@protoc_insertion_point(one_of_clear_start:autofill_assistant.GetElementStatusProto.MatchExpectation)
  switch (match_level_case()) {
    case kFullMatch: {
      // No need to clear
      break;
    }
    case kContains: {
      // No need to clear
      break;
    }
    case kStartsWith: {
      // No need to clear
      break;
    }
    case kEndsWith: {
      // No need to clear
      break;
    }
    case MATCH_LEVEL_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = MATCH_LEVEL_NOT_SET;
}


void GetElementStatusProto_MatchExpectation::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.GetElementStatusProto.MatchExpectation)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(match_options_ != nullptr);
    match_options_->Clear();
  }
  clear_match_level();
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* GetElementStatusProto_MatchExpectation::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .autofill_assistant.GetElementStatusProto.MatchOptions match_options = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_match_options(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool full_match = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _internal_set_full_match(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool contains = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _internal_set_contains(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool starts_with = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _internal_set_starts_with(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool ends_with = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _internal_set_ends_with(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GetElementStatusProto_MatchExpectation::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.GetElementStatusProto.MatchExpectation)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .autofill_assistant.GetElementStatusProto.MatchOptions match_options = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::match_options(this),
        _Internal::match_options(this).GetCachedSize(), target, stream);
  }

  switch (match_level_case()) {
    case kFullMatch: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_full_match(), target);
      break;
    }
    case kContains: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_contains(), target);
      break;
    }
    case kStartsWith: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_starts_with(), target);
      break;
    }
    case kEndsWith: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_ends_with(), target);
      break;
    }
    default: ;
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.GetElementStatusProto.MatchExpectation)
  return target;
}

size_t GetElementStatusProto_MatchExpectation::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.GetElementStatusProto.MatchExpectation)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .autofill_assistant.GetElementStatusProto.MatchOptions match_options = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *match_options_);
  }

  switch (match_level_case()) {
    // bool full_match = 2;
    case kFullMatch: {
      total_size += 1 + 1;
      break;
    }
    // bool contains = 3;
    case kContains: {
      total_size += 1 + 1;
      break;
    }
    // bool starts_with = 4;
    case kStartsWith: {
      total_size += 1 + 1;
      break;
    }
    // bool ends_with = 5;
    case kEndsWith: {
      total_size += 1 + 1;
      break;
    }
    case MATCH_LEVEL_NOT_SET: {
      break;
    }
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void GetElementStatusProto_MatchExpectation::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const GetElementStatusProto_MatchExpectation*>(
      &from));
}

void GetElementStatusProto_MatchExpectation::MergeFrom(const GetElementStatusProto_MatchExpectation& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.GetElementStatusProto.MatchExpectation)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_match_options()) {
    _internal_mutable_match_options()->::autofill_assistant::GetElementStatusProto_MatchOptions::MergeFrom(from._internal_match_options());
  }
  switch (from.match_level_case()) {
    case kFullMatch: {
      _internal_set_full_match(from._internal_full_match());
      break;
    }
    case kContains: {
      _internal_set_contains(from._internal_contains());
      break;
    }
    case kStartsWith: {
      _internal_set_starts_with(from._internal_starts_with());
      break;
    }
    case kEndsWith: {
      _internal_set_ends_with(from._internal_ends_with());
      break;
    }
    case MATCH_LEVEL_NOT_SET: {
      break;
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void GetElementStatusProto_MatchExpectation::CopyFrom(const GetElementStatusProto_MatchExpectation& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.GetElementStatusProto.MatchExpectation)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetElementStatusProto_MatchExpectation::IsInitialized() const {
  return true;
}

void GetElementStatusProto_MatchExpectation::InternalSwap(GetElementStatusProto_MatchExpectation* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(match_options_, other->match_options_);
  swap(match_level_, other->match_level_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

std::string GetElementStatusProto_MatchExpectation::GetTypeName() const {
  return "autofill_assistant.GetElementStatusProto.MatchExpectation";
}


// ===================================================================

class GetElementStatusProto_TextMatch::_Internal {
 public:
  using HasBits = decltype(std::declval<GetElementStatusProto_TextMatch>()._has_bits_);
  static const ::autofill_assistant::TextValue& text_value(const GetElementStatusProto_TextMatch* msg);
  static const ::autofill_assistant::GetElementStatusProto_MatchExpectation& match_expectation(const GetElementStatusProto_TextMatch* msg);
  static void set_has_match_expectation(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::autofill_assistant::TextValue&
GetElementStatusProto_TextMatch::_Internal::text_value(const GetElementStatusProto_TextMatch* msg) {
  return *msg->value_source_.text_value_;
}
const ::autofill_assistant::GetElementStatusProto_MatchExpectation&
GetElementStatusProto_TextMatch::_Internal::match_expectation(const GetElementStatusProto_TextMatch* msg) {
  return *msg->match_expectation_;
}
void GetElementStatusProto_TextMatch::set_allocated_text_value(::autofill_assistant::TextValue* text_value) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_value_source();
  if (text_value) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(text_value));
    if (message_arena != submessage_arena) {
      text_value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, text_value, submessage_arena);
    }
    set_has_text_value();
    value_source_.text_value_ = text_value;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.GetElementStatusProto.TextMatch.text_value)
}
void GetElementStatusProto_TextMatch::clear_text_value() {
  if (_internal_has_text_value()) {
    if (GetArenaForAllocation() == nullptr) {
      delete value_source_.text_value_;
    }
    clear_has_value_source();
  }
}
GetElementStatusProto_TextMatch::GetElementStatusProto_TextMatch(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.GetElementStatusProto.TextMatch)
}
GetElementStatusProto_TextMatch::GetElementStatusProto_TextMatch(const GetElementStatusProto_TextMatch& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_match_expectation()) {
    match_expectation_ = new ::autofill_assistant::GetElementStatusProto_MatchExpectation(*from.match_expectation_);
  } else {
    match_expectation_ = nullptr;
  }
  clear_has_value_source();
  switch (from.value_source_case()) {
    case kRe2: {
      _internal_set_re2(from._internal_re2());
      break;
    }
    case kTextValue: {
      _internal_mutable_text_value()->::autofill_assistant::TextValue::MergeFrom(from._internal_text_value());
      break;
    }
    case VALUE_SOURCE_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.GetElementStatusProto.TextMatch)
}

inline void GetElementStatusProto_TextMatch::SharedCtor() {
match_expectation_ = nullptr;
clear_has_value_source();
}

GetElementStatusProto_TextMatch::~GetElementStatusProto_TextMatch() {
  // @@protoc_insertion_point(destructor:autofill_assistant.GetElementStatusProto.TextMatch)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GetElementStatusProto_TextMatch::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete match_expectation_;
  if (has_value_source()) {
    clear_value_source();
  }
}

void GetElementStatusProto_TextMatch::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void GetElementStatusProto_TextMatch::clear_value_source() {
// @@protoc_insertion_point(one_of_clear_start:autofill_assistant.GetElementStatusProto.TextMatch)
  switch (value_source_case()) {
    case kRe2: {
      value_source_.re2_.Destroy();
      break;
    }
    case kTextValue: {
      if (GetArenaForAllocation() == nullptr) {
        delete value_source_.text_value_;
      }
      break;
    }
    case VALUE_SOURCE_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = VALUE_SOURCE_NOT_SET;
}


void GetElementStatusProto_TextMatch::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.GetElementStatusProto.TextMatch)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(match_expectation_ != nullptr);
    match_expectation_->Clear();
  }
  clear_value_source();
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* GetElementStatusProto_TextMatch::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .autofill_assistant.GetElementStatusProto.MatchExpectation match_expectation = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_match_expectation(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string re2 = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_re2();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.TextValue text_value = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_text_value(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GetElementStatusProto_TextMatch::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.GetElementStatusProto.TextMatch)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .autofill_assistant.GetElementStatusProto.MatchExpectation match_expectation = 3;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::match_expectation(this),
        _Internal::match_expectation(this).GetCachedSize(), target, stream);
  }

  switch (value_source_case()) {
    case kRe2: {
      target = stream->WriteStringMaybeAliased(
          4, this->_internal_re2(), target);
      break;
    }
    case kTextValue: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(5, _Internal::text_value(this),
          _Internal::text_value(this).GetCachedSize(), target, stream);
      break;
    }
    default: ;
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.GetElementStatusProto.TextMatch)
  return target;
}

size_t GetElementStatusProto_TextMatch::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.GetElementStatusProto.TextMatch)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .autofill_assistant.GetElementStatusProto.MatchExpectation match_expectation = 3;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *match_expectation_);
  }

  switch (value_source_case()) {
    // string re2 = 4;
    case kRe2: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_re2());
      break;
    }
    // .autofill_assistant.TextValue text_value = 5;
    case kTextValue: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *value_source_.text_value_);
      break;
    }
    case VALUE_SOURCE_NOT_SET: {
      break;
    }
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void GetElementStatusProto_TextMatch::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const GetElementStatusProto_TextMatch*>(
      &from));
}

void GetElementStatusProto_TextMatch::MergeFrom(const GetElementStatusProto_TextMatch& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.GetElementStatusProto.TextMatch)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_match_expectation()) {
    _internal_mutable_match_expectation()->::autofill_assistant::GetElementStatusProto_MatchExpectation::MergeFrom(from._internal_match_expectation());
  }
  switch (from.value_source_case()) {
    case kRe2: {
      _internal_set_re2(from._internal_re2());
      break;
    }
    case kTextValue: {
      _internal_mutable_text_value()->::autofill_assistant::TextValue::MergeFrom(from._internal_text_value());
      break;
    }
    case VALUE_SOURCE_NOT_SET: {
      break;
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void GetElementStatusProto_TextMatch::CopyFrom(const GetElementStatusProto_TextMatch& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.GetElementStatusProto.TextMatch)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetElementStatusProto_TextMatch::IsInitialized() const {
  return true;
}

void GetElementStatusProto_TextMatch::InternalSwap(GetElementStatusProto_TextMatch* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(match_expectation_, other->match_expectation_);
  swap(value_source_, other->value_source_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

std::string GetElementStatusProto_TextMatch::GetTypeName() const {
  return "autofill_assistant.GetElementStatusProto.TextMatch";
}


// ===================================================================

class GetElementStatusProto_ValueMatch::_Internal {
 public:
  using HasBits = decltype(std::declval<GetElementStatusProto_ValueMatch>()._has_bits_);
  static const ::autofill_assistant::GetElementStatusProto_TextMatch& text_match(const GetElementStatusProto_ValueMatch* msg);
  static void set_has_text_match(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::autofill_assistant::GetElementStatusProto_TextMatch&
GetElementStatusProto_ValueMatch::_Internal::text_match(const GetElementStatusProto_ValueMatch* msg) {
  return *msg->text_match_;
}
GetElementStatusProto_ValueMatch::GetElementStatusProto_ValueMatch(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.GetElementStatusProto.ValueMatch)
}
GetElementStatusProto_ValueMatch::GetElementStatusProto_ValueMatch(const GetElementStatusProto_ValueMatch& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_text_match()) {
    text_match_ = new ::autofill_assistant::GetElementStatusProto_TextMatch(*from.text_match_);
  } else {
    text_match_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.GetElementStatusProto.ValueMatch)
}

inline void GetElementStatusProto_ValueMatch::SharedCtor() {
text_match_ = nullptr;
}

GetElementStatusProto_ValueMatch::~GetElementStatusProto_ValueMatch() {
  // @@protoc_insertion_point(destructor:autofill_assistant.GetElementStatusProto.ValueMatch)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GetElementStatusProto_ValueMatch::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete text_match_;
}

void GetElementStatusProto_ValueMatch::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void GetElementStatusProto_ValueMatch::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.GetElementStatusProto.ValueMatch)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(text_match_ != nullptr);
    text_match_->Clear();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* GetElementStatusProto_ValueMatch::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .autofill_assistant.GetElementStatusProto.TextMatch text_match = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_text_match(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GetElementStatusProto_ValueMatch::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.GetElementStatusProto.ValueMatch)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .autofill_assistant.GetElementStatusProto.TextMatch text_match = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::text_match(this),
        _Internal::text_match(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.GetElementStatusProto.ValueMatch)
  return target;
}

size_t GetElementStatusProto_ValueMatch::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.GetElementStatusProto.ValueMatch)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .autofill_assistant.GetElementStatusProto.TextMatch text_match = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *text_match_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void GetElementStatusProto_ValueMatch::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const GetElementStatusProto_ValueMatch*>(
      &from));
}

void GetElementStatusProto_ValueMatch::MergeFrom(const GetElementStatusProto_ValueMatch& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.GetElementStatusProto.ValueMatch)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_text_match()) {
    _internal_mutable_text_match()->::autofill_assistant::GetElementStatusProto_TextMatch::MergeFrom(from._internal_text_match());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void GetElementStatusProto_ValueMatch::CopyFrom(const GetElementStatusProto_ValueMatch& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.GetElementStatusProto.ValueMatch)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetElementStatusProto_ValueMatch::IsInitialized() const {
  return true;
}

void GetElementStatusProto_ValueMatch::InternalSwap(GetElementStatusProto_ValueMatch* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(text_match_, other->text_match_);
}

std::string GetElementStatusProto_ValueMatch::GetTypeName() const {
  return "autofill_assistant.GetElementStatusProto.ValueMatch";
}


// ===================================================================

class GetElementStatusProto_ComparisonReport::_Internal {
 public:
  using HasBits = decltype(std::declval<GetElementStatusProto_ComparisonReport>()._has_bits_);
  static const ::autofill_assistant::GetElementStatusProto_MatchOptions& match_options(const GetElementStatusProto_ComparisonReport* msg);
  static void set_has_match_options(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_full_match(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_contains(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_starts_with(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_ends_with(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_empty(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_expected_empty_match(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
};

const ::autofill_assistant::GetElementStatusProto_MatchOptions&
GetElementStatusProto_ComparisonReport::_Internal::match_options(const GetElementStatusProto_ComparisonReport* msg) {
  return *msg->match_options_;
}
GetElementStatusProto_ComparisonReport::GetElementStatusProto_ComparisonReport(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.GetElementStatusProto.ComparisonReport)
}
GetElementStatusProto_ComparisonReport::GetElementStatusProto_ComparisonReport(const GetElementStatusProto_ComparisonReport& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_match_options()) {
    match_options_ = new ::autofill_assistant::GetElementStatusProto_MatchOptions(*from.match_options_);
  } else {
    match_options_ = nullptr;
  }
  ::memcpy(&full_match_, &from.full_match_,
    static_cast<size_t>(reinterpret_cast<char*>(&expected_empty_match_) -
    reinterpret_cast<char*>(&full_match_)) + sizeof(expected_empty_match_));
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.GetElementStatusProto.ComparisonReport)
}

inline void GetElementStatusProto_ComparisonReport::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&match_options_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&expected_empty_match_) -
    reinterpret_cast<char*>(&match_options_)) + sizeof(expected_empty_match_));
}

GetElementStatusProto_ComparisonReport::~GetElementStatusProto_ComparisonReport() {
  // @@protoc_insertion_point(destructor:autofill_assistant.GetElementStatusProto.ComparisonReport)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GetElementStatusProto_ComparisonReport::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete match_options_;
}

void GetElementStatusProto_ComparisonReport::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void GetElementStatusProto_ComparisonReport::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.GetElementStatusProto.ComparisonReport)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(match_options_ != nullptr);
    match_options_->Clear();
  }
  if (cached_has_bits & 0x0000007eu) {
    ::memset(&full_match_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&expected_empty_match_) -
        reinterpret_cast<char*>(&full_match_)) + sizeof(expected_empty_match_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* GetElementStatusProto_ComparisonReport::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .autofill_assistant.GetElementStatusProto.MatchOptions match_options = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_match_options(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool full_match = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_full_match(&has_bits);
          full_match_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool contains = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_contains(&has_bits);
          contains_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool starts_with = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_starts_with(&has_bits);
          starts_with_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool ends_with = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_ends_with(&has_bits);
          ends_with_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool empty = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_empty(&has_bits);
          empty_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool expected_empty_match = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_expected_empty_match(&has_bits);
          expected_empty_match_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GetElementStatusProto_ComparisonReport::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.GetElementStatusProto.ComparisonReport)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .autofill_assistant.GetElementStatusProto.MatchOptions match_options = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::match_options(this),
        _Internal::match_options(this).GetCachedSize(), target, stream);
  }

  // optional bool full_match = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_full_match(), target);
  }

  // optional bool contains = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_contains(), target);
  }

  // optional bool starts_with = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_starts_with(), target);
  }

  // optional bool ends_with = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_ends_with(), target);
  }

  // optional bool empty = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(6, this->_internal_empty(), target);
  }

  // optional bool expected_empty_match = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(7, this->_internal_expected_empty_match(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.GetElementStatusProto.ComparisonReport)
  return target;
}

size_t GetElementStatusProto_ComparisonReport::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.GetElementStatusProto.ComparisonReport)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // optional .autofill_assistant.GetElementStatusProto.MatchOptions match_options = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *match_options_);
    }

    // optional bool full_match = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

    // optional bool contains = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

    // optional bool starts_with = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

    // optional bool ends_with = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 1;
    }

    // optional bool empty = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 1;
    }

    // optional bool expected_empty_match = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 1;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void GetElementStatusProto_ComparisonReport::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const GetElementStatusProto_ComparisonReport*>(
      &from));
}

void GetElementStatusProto_ComparisonReport::MergeFrom(const GetElementStatusProto_ComparisonReport& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.GetElementStatusProto.ComparisonReport)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_match_options()->::autofill_assistant::GetElementStatusProto_MatchOptions::MergeFrom(from._internal_match_options());
    }
    if (cached_has_bits & 0x00000002u) {
      full_match_ = from.full_match_;
    }
    if (cached_has_bits & 0x00000004u) {
      contains_ = from.contains_;
    }
    if (cached_has_bits & 0x00000008u) {
      starts_with_ = from.starts_with_;
    }
    if (cached_has_bits & 0x00000010u) {
      ends_with_ = from.ends_with_;
    }
    if (cached_has_bits & 0x00000020u) {
      empty_ = from.empty_;
    }
    if (cached_has_bits & 0x00000040u) {
      expected_empty_match_ = from.expected_empty_match_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void GetElementStatusProto_ComparisonReport::CopyFrom(const GetElementStatusProto_ComparisonReport& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.GetElementStatusProto.ComparisonReport)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetElementStatusProto_ComparisonReport::IsInitialized() const {
  return true;
}

void GetElementStatusProto_ComparisonReport::InternalSwap(GetElementStatusProto_ComparisonReport* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(GetElementStatusProto_ComparisonReport, expected_empty_match_)
      + sizeof(GetElementStatusProto_ComparisonReport::expected_empty_match_)
      - PROTOBUF_FIELD_OFFSET(GetElementStatusProto_ComparisonReport, match_options_)>(
          reinterpret_cast<char*>(&match_options_),
          reinterpret_cast<char*>(&other->match_options_));
}

std::string GetElementStatusProto_ComparisonReport::GetTypeName() const {
  return "autofill_assistant.GetElementStatusProto.ComparisonReport";
}


// ===================================================================

class GetElementStatusProto::_Internal {
 public:
  using HasBits = decltype(std::declval<GetElementStatusProto>()._has_bits_);
  static const ::autofill_assistant::SelectorProto& selector(const GetElementStatusProto* msg);
  static const ::autofill_assistant::ClientIdProto& client_id(const GetElementStatusProto* msg);
  static const ::autofill_assistant::GetElementStatusProto_ValueMatch& expected_value_match(const GetElementStatusProto* msg);
  static void set_has_expected_value_match(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_value_source(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_mismatch_should_fail(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::autofill_assistant::SelectorProto&
GetElementStatusProto::_Internal::selector(const GetElementStatusProto* msg) {
  return *msg->element_.selector_;
}
const ::autofill_assistant::ClientIdProto&
GetElementStatusProto::_Internal::client_id(const GetElementStatusProto* msg) {
  return *msg->element_.client_id_;
}
const ::autofill_assistant::GetElementStatusProto_ValueMatch&
GetElementStatusProto::_Internal::expected_value_match(const GetElementStatusProto* msg) {
  return *msg->expected_value_match_;
}
void GetElementStatusProto::set_allocated_selector(::autofill_assistant::SelectorProto* selector) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_element();
  if (selector) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(selector);
    if (message_arena != submessage_arena) {
      selector = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, selector, submessage_arena);
    }
    set_has_selector();
    element_.selector_ = selector;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.GetElementStatusProto.selector)
}
void GetElementStatusProto::set_allocated_client_id(::autofill_assistant::ClientIdProto* client_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_element();
  if (client_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(client_id));
    if (message_arena != submessage_arena) {
      client_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, client_id, submessage_arena);
    }
    set_has_client_id();
    element_.client_id_ = client_id;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.GetElementStatusProto.client_id)
}
void GetElementStatusProto::clear_client_id() {
  if (_internal_has_client_id()) {
    if (GetArenaForAllocation() == nullptr) {
      delete element_.client_id_;
    }
    clear_has_element();
  }
}
GetElementStatusProto::GetElementStatusProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.GetElementStatusProto)
}
GetElementStatusProto::GetElementStatusProto(const GetElementStatusProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_expected_value_match()) {
    expected_value_match_ = new ::autofill_assistant::GetElementStatusProto_ValueMatch(*from.expected_value_match_);
  } else {
    expected_value_match_ = nullptr;
  }
  ::memcpy(&mismatch_should_fail_, &from.mismatch_should_fail_,
    static_cast<size_t>(reinterpret_cast<char*>(&value_source_) -
    reinterpret_cast<char*>(&mismatch_should_fail_)) + sizeof(value_source_));
  clear_has_element();
  switch (from.element_case()) {
    case kSelector: {
      _internal_mutable_selector()->::autofill_assistant::SelectorProto::MergeFrom(from._internal_selector());
      break;
    }
    case kClientId: {
      _internal_mutable_client_id()->::autofill_assistant::ClientIdProto::MergeFrom(from._internal_client_id());
      break;
    }
    case ELEMENT_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.GetElementStatusProto)
}

inline void GetElementStatusProto::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&expected_value_match_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&value_source_) -
    reinterpret_cast<char*>(&expected_value_match_)) + sizeof(value_source_));
clear_has_element();
}

GetElementStatusProto::~GetElementStatusProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.GetElementStatusProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GetElementStatusProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete expected_value_match_;
  if (has_element()) {
    clear_element();
  }
}

void GetElementStatusProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void GetElementStatusProto::clear_element() {
// @@protoc_insertion_point(one_of_clear_start:autofill_assistant.GetElementStatusProto)
  switch (element_case()) {
    case kSelector: {
      if (GetArenaForAllocation() == nullptr) {
        delete element_.selector_;
      }
      break;
    }
    case kClientId: {
      if (GetArenaForAllocation() == nullptr) {
        delete element_.client_id_;
      }
      break;
    }
    case ELEMENT_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = ELEMENT_NOT_SET;
}


void GetElementStatusProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.GetElementStatusProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(expected_value_match_ != nullptr);
    expected_value_match_->Clear();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&mismatch_should_fail_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&value_source_) -
        reinterpret_cast<char*>(&mismatch_should_fail_)) + sizeof(value_source_));
  }
  clear_element();
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* GetElementStatusProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .autofill_assistant.SelectorProto selector = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_selector(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .autofill_assistant.GetElementStatusProto.ValueMatch expected_value_match = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_expected_value_match(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool mismatch_should_fail = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_mismatch_should_fail(&has_bits);
          mismatch_should_fail_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .autofill_assistant.GetElementStatusProto.ValueSource value_source = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::autofill_assistant::GetElementStatusProto_ValueSource_IsValid(val))) {
            _internal_set_value_source(static_cast<::autofill_assistant::GetElementStatusProto_ValueSource>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.ClientIdProto client_id = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_client_id(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GetElementStatusProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.GetElementStatusProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .autofill_assistant.SelectorProto selector = 1;
  if (_internal_has_selector()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::selector(this),
        _Internal::selector(this).GetCachedSize(), target, stream);
  }

  cached_has_bits = _has_bits_[0];
  // optional .autofill_assistant.GetElementStatusProto.ValueMatch expected_value_match = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::expected_value_match(this),
        _Internal::expected_value_match(this).GetCachedSize(), target, stream);
  }

  // optional bool mismatch_should_fail = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_mismatch_should_fail(), target);
  }

  // optional .autofill_assistant.GetElementStatusProto.ValueSource value_source = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      4, this->_internal_value_source(), target);
  }

  // .autofill_assistant.ClientIdProto client_id = 5;
  if (_internal_has_client_id()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::client_id(this),
        _Internal::client_id(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.GetElementStatusProto)
  return target;
}

size_t GetElementStatusProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.GetElementStatusProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .autofill_assistant.GetElementStatusProto.ValueMatch expected_value_match = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *expected_value_match_);
    }

    // optional bool mismatch_should_fail = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

    // optional .autofill_assistant.GetElementStatusProto.ValueSource value_source = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_value_source());
    }

  }
  switch (element_case()) {
    // .autofill_assistant.SelectorProto selector = 1;
    case kSelector: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *element_.selector_);
      break;
    }
    // .autofill_assistant.ClientIdProto client_id = 5;
    case kClientId: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *element_.client_id_);
      break;
    }
    case ELEMENT_NOT_SET: {
      break;
    }
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void GetElementStatusProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const GetElementStatusProto*>(
      &from));
}

void GetElementStatusProto::MergeFrom(const GetElementStatusProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.GetElementStatusProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_expected_value_match()->::autofill_assistant::GetElementStatusProto_ValueMatch::MergeFrom(from._internal_expected_value_match());
    }
    if (cached_has_bits & 0x00000002u) {
      mismatch_should_fail_ = from.mismatch_should_fail_;
    }
    if (cached_has_bits & 0x00000004u) {
      value_source_ = from.value_source_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  switch (from.element_case()) {
    case kSelector: {
      _internal_mutable_selector()->::autofill_assistant::SelectorProto::MergeFrom(from._internal_selector());
      break;
    }
    case kClientId: {
      _internal_mutable_client_id()->::autofill_assistant::ClientIdProto::MergeFrom(from._internal_client_id());
      break;
    }
    case ELEMENT_NOT_SET: {
      break;
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void GetElementStatusProto::CopyFrom(const GetElementStatusProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.GetElementStatusProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetElementStatusProto::IsInitialized() const {
  return true;
}

void GetElementStatusProto::InternalSwap(GetElementStatusProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(GetElementStatusProto, value_source_)
      + sizeof(GetElementStatusProto::value_source_)
      - PROTOBUF_FIELD_OFFSET(GetElementStatusProto, expected_value_match_)>(
          reinterpret_cast<char*>(&expected_value_match_),
          reinterpret_cast<char*>(&other->expected_value_match_));
  swap(element_, other->element_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

std::string GetElementStatusProto::GetTypeName() const {
  return "autofill_assistant.GetElementStatusProto";
}


// ===================================================================

class ReleaseElementsProto::_Internal {
 public:
};

void ReleaseElementsProto::clear_client_ids() {
  client_ids_.Clear();
}
ReleaseElementsProto::ReleaseElementsProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  client_ids_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.ReleaseElementsProto)
}
ReleaseElementsProto::ReleaseElementsProto(const ReleaseElementsProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      client_ids_(from.client_ids_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.ReleaseElementsProto)
}

inline void ReleaseElementsProto::SharedCtor() {
}

ReleaseElementsProto::~ReleaseElementsProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.ReleaseElementsProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ReleaseElementsProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ReleaseElementsProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ReleaseElementsProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.ReleaseElementsProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  client_ids_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ReleaseElementsProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .autofill_assistant.ClientIdProto client_ids = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_client_ids(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ReleaseElementsProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.ReleaseElementsProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .autofill_assistant.ClientIdProto client_ids = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_client_ids_size()); i < n; i++) {
    const auto& repfield = this->_internal_client_ids(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.ReleaseElementsProto)
  return target;
}

size_t ReleaseElementsProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.ReleaseElementsProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .autofill_assistant.ClientIdProto client_ids = 1;
  total_size += 1UL * this->_internal_client_ids_size();
  for (const auto& msg : this->client_ids_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ReleaseElementsProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ReleaseElementsProto*>(
      &from));
}

void ReleaseElementsProto::MergeFrom(const ReleaseElementsProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.ReleaseElementsProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  client_ids_.MergeFrom(from.client_ids_);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ReleaseElementsProto::CopyFrom(const ReleaseElementsProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.ReleaseElementsProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReleaseElementsProto::IsInitialized() const {
  return true;
}

void ReleaseElementsProto::InternalSwap(ReleaseElementsProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  client_ids_.InternalSwap(&other->client_ids_);
}

std::string ReleaseElementsProto::GetTypeName() const {
  return "autofill_assistant.ReleaseElementsProto";
}


// ===================================================================

class DispatchJsEventProto::_Internal {
 public:
};

DispatchJsEventProto::DispatchJsEventProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.DispatchJsEventProto)
}
DispatchJsEventProto::DispatchJsEventProto(const DispatchJsEventProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.DispatchJsEventProto)
}

inline void DispatchJsEventProto::SharedCtor() {
}

DispatchJsEventProto::~DispatchJsEventProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.DispatchJsEventProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DispatchJsEventProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void DispatchJsEventProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void DispatchJsEventProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.DispatchJsEventProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_metadata_.Clear<std::string>();
}

const char* DispatchJsEventProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DispatchJsEventProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.DispatchJsEventProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.DispatchJsEventProto)
  return target;
}

size_t DispatchJsEventProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.DispatchJsEventProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DispatchJsEventProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DispatchJsEventProto*>(
      &from));
}

void DispatchJsEventProto::MergeFrom(const DispatchJsEventProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.DispatchJsEventProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DispatchJsEventProto::CopyFrom(const DispatchJsEventProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.DispatchJsEventProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DispatchJsEventProto::IsInitialized() const {
  return true;
}

void DispatchJsEventProto::InternalSwap(DispatchJsEventProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
}

std::string DispatchJsEventProto::GetTypeName() const {
  return "autofill_assistant.DispatchJsEventProto";
}


// ===================================================================

class JsFlowProto_Result::_Internal {
 public:
  using HasBits = decltype(std::declval<JsFlowProto_Result>()._has_bits_);
  static void set_has_result_json(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

JsFlowProto_Result::JsFlowProto_Result(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.JsFlowProto.Result)
}
JsFlowProto_Result::JsFlowProto_Result(const JsFlowProto_Result& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  result_json_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    result_json_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_result_json()) {
    result_json_.Set(from._internal_result_json(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.JsFlowProto.Result)
}

inline void JsFlowProto_Result::SharedCtor() {
result_json_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  result_json_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

JsFlowProto_Result::~JsFlowProto_Result() {
  // @@protoc_insertion_point(destructor:autofill_assistant.JsFlowProto.Result)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void JsFlowProto_Result::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  result_json_.Destroy();
}

void JsFlowProto_Result::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void JsFlowProto_Result::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.JsFlowProto.Result)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    result_json_.ClearNonDefaultToEmpty();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* JsFlowProto_Result::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string result_json = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_result_json();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* JsFlowProto_Result::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.JsFlowProto.Result)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string result_json = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_result_json(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.JsFlowProto.Result)
  return target;
}

size_t JsFlowProto_Result::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.JsFlowProto.Result)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string result_json = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_result_json());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void JsFlowProto_Result::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const JsFlowProto_Result*>(
      &from));
}

void JsFlowProto_Result::MergeFrom(const JsFlowProto_Result& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.JsFlowProto.Result)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_result_json()) {
    _internal_set_result_json(from._internal_result_json());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void JsFlowProto_Result::CopyFrom(const JsFlowProto_Result& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.JsFlowProto.Result)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool JsFlowProto_Result::IsInitialized() const {
  return true;
}

void JsFlowProto_Result::InternalSwap(JsFlowProto_Result* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &result_json_, lhs_arena,
      &other->result_json_, rhs_arena
  );
}

std::string JsFlowProto_Result::GetTypeName() const {
  return "autofill_assistant.JsFlowProto.Result";
}


// ===================================================================

class JsFlowProto::_Internal {
 public:
  using HasBits = decltype(std::declval<JsFlowProto>()._has_bits_);
  static void set_has_js_flow(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

JsFlowProto::JsFlowProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.JsFlowProto)
}
JsFlowProto::JsFlowProto(const JsFlowProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  js_flow_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    js_flow_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_js_flow()) {
    js_flow_.Set(from._internal_js_flow(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.JsFlowProto)
}

inline void JsFlowProto::SharedCtor() {
js_flow_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  js_flow_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

JsFlowProto::~JsFlowProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.JsFlowProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void JsFlowProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  js_flow_.Destroy();
}

void JsFlowProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void JsFlowProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.JsFlowProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    js_flow_.ClearNonDefaultToEmpty();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* JsFlowProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string js_flow = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_js_flow();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* JsFlowProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.JsFlowProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string js_flow = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_js_flow(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.JsFlowProto)
  return target;
}

size_t JsFlowProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.JsFlowProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string js_flow = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_js_flow());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void JsFlowProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const JsFlowProto*>(
      &from));
}

void JsFlowProto::MergeFrom(const JsFlowProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.JsFlowProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_js_flow()) {
    _internal_set_js_flow(from._internal_js_flow());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void JsFlowProto::CopyFrom(const JsFlowProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.JsFlowProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool JsFlowProto::IsInitialized() const {
  return true;
}

void JsFlowProto::InternalSwap(JsFlowProto* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &js_flow_, lhs_arena,
      &other->js_flow_, rhs_arena
  );
}

std::string JsFlowProto::GetTypeName() const {
  return "autofill_assistant.JsFlowProto";
}


// ===================================================================

class ExternalActionProto_ExternalCondition::_Internal {
 public:
  using HasBits = decltype(std::declval<ExternalActionProto_ExternalCondition>()._has_bits_);
  static void set_has_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::autofill_assistant::ElementConditionProto& element_condition(const ExternalActionProto_ExternalCondition* msg);
  static void set_has_element_condition(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::autofill_assistant::ElementConditionProto&
ExternalActionProto_ExternalCondition::_Internal::element_condition(const ExternalActionProto_ExternalCondition* msg) {
  return *msg->element_condition_;
}
ExternalActionProto_ExternalCondition::ExternalActionProto_ExternalCondition(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.ExternalActionProto.ExternalCondition)
}
ExternalActionProto_ExternalCondition::ExternalActionProto_ExternalCondition(const ExternalActionProto_ExternalCondition& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_element_condition()) {
    element_condition_ = new ::autofill_assistant::ElementConditionProto(*from.element_condition_);
  } else {
    element_condition_ = nullptr;
  }
  id_ = from.id_;
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.ExternalActionProto.ExternalCondition)
}

inline void ExternalActionProto_ExternalCondition::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&element_condition_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&id_) -
    reinterpret_cast<char*>(&element_condition_)) + sizeof(id_));
}

ExternalActionProto_ExternalCondition::~ExternalActionProto_ExternalCondition() {
  // @@protoc_insertion_point(destructor:autofill_assistant.ExternalActionProto.ExternalCondition)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ExternalActionProto_ExternalCondition::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete element_condition_;
}

void ExternalActionProto_ExternalCondition::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ExternalActionProto_ExternalCondition::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.ExternalActionProto.ExternalCondition)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(element_condition_ != nullptr);
    element_condition_->Clear();
  }
  id_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ExternalActionProto_ExternalCondition::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_id(&has_bits);
          id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .autofill_assistant.ElementConditionProto element_condition = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_element_condition(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ExternalActionProto_ExternalCondition::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.ExternalActionProto.ExternalCondition)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_id(), target);
  }

  // optional .autofill_assistant.ElementConditionProto element_condition = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::element_condition(this),
        _Internal::element_condition(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.ExternalActionProto.ExternalCondition)
  return target;
}

size_t ExternalActionProto_ExternalCondition::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.ExternalActionProto.ExternalCondition)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .autofill_assistant.ElementConditionProto element_condition = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *element_condition_);
    }

    // optional int32 id = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_id());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ExternalActionProto_ExternalCondition::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ExternalActionProto_ExternalCondition*>(
      &from));
}

void ExternalActionProto_ExternalCondition::MergeFrom(const ExternalActionProto_ExternalCondition& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.ExternalActionProto.ExternalCondition)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_element_condition()->::autofill_assistant::ElementConditionProto::MergeFrom(from._internal_element_condition());
    }
    if (cached_has_bits & 0x00000002u) {
      id_ = from.id_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ExternalActionProto_ExternalCondition::CopyFrom(const ExternalActionProto_ExternalCondition& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.ExternalActionProto.ExternalCondition)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ExternalActionProto_ExternalCondition::IsInitialized() const {
  return true;
}

void ExternalActionProto_ExternalCondition::InternalSwap(ExternalActionProto_ExternalCondition* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ExternalActionProto_ExternalCondition, id_)
      + sizeof(ExternalActionProto_ExternalCondition::id_)
      - PROTOBUF_FIELD_OFFSET(ExternalActionProto_ExternalCondition, element_condition_)>(
          reinterpret_cast<char*>(&element_condition_),
          reinterpret_cast<char*>(&other->element_condition_));
}

std::string ExternalActionProto_ExternalCondition::GetTypeName() const {
  return "autofill_assistant.ExternalActionProto.ExternalCondition";
}


// ===================================================================

class ExternalActionProto_Result::_Internal {
 public:
  using HasBits = decltype(std::declval<ExternalActionProto_Result>()._has_bits_);
  static const ::autofill_assistant::external::ResultInfo& result_info(const ExternalActionProto_Result* msg);
  static void set_has_result_info(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::autofill_assistant::external::ResultInfo&
ExternalActionProto_Result::_Internal::result_info(const ExternalActionProto_Result* msg) {
  return *msg->result_info_;
}
void ExternalActionProto_Result::clear_result_info() {
  if (result_info_ != nullptr) result_info_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
ExternalActionProto_Result::ExternalActionProto_Result(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.ExternalActionProto.Result)
}
ExternalActionProto_Result::ExternalActionProto_Result(const ExternalActionProto_Result& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_result_info()) {
    result_info_ = new ::autofill_assistant::external::ResultInfo(*from.result_info_);
  } else {
    result_info_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.ExternalActionProto.Result)
}

inline void ExternalActionProto_Result::SharedCtor() {
result_info_ = nullptr;
}

ExternalActionProto_Result::~ExternalActionProto_Result() {
  // @@protoc_insertion_point(destructor:autofill_assistant.ExternalActionProto.Result)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ExternalActionProto_Result::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete result_info_;
}

void ExternalActionProto_Result::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ExternalActionProto_Result::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.ExternalActionProto.Result)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(result_info_ != nullptr);
    result_info_->Clear();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ExternalActionProto_Result::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .autofill_assistant.external.ResultInfo result_info = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_result_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ExternalActionProto_Result::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.ExternalActionProto.Result)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .autofill_assistant.external.ResultInfo result_info = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::result_info(this),
        _Internal::result_info(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.ExternalActionProto.Result)
  return target;
}

size_t ExternalActionProto_Result::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.ExternalActionProto.Result)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .autofill_assistant.external.ResultInfo result_info = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *result_info_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ExternalActionProto_Result::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ExternalActionProto_Result*>(
      &from));
}

void ExternalActionProto_Result::MergeFrom(const ExternalActionProto_Result& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.ExternalActionProto.Result)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_result_info()) {
    _internal_mutable_result_info()->::autofill_assistant::external::ResultInfo::MergeFrom(from._internal_result_info());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ExternalActionProto_Result::CopyFrom(const ExternalActionProto_Result& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.ExternalActionProto.Result)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ExternalActionProto_Result::IsInitialized() const {
  if (_internal_has_result_info()) {
    if (!result_info_->IsInitialized()) return false;
  }
  return true;
}

void ExternalActionProto_Result::InternalSwap(ExternalActionProto_Result* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(result_info_, other->result_info_);
}

std::string ExternalActionProto_Result::GetTypeName() const {
  return "autofill_assistant.ExternalActionProto.Result";
}


// ===================================================================

class ExternalActionProto::_Internal {
 public:
  using HasBits = decltype(std::declval<ExternalActionProto>()._has_bits_);
  static const ::autofill_assistant::external::ActionInfo& info(const ExternalActionProto* msg);
  static void set_has_info(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_show_touchable_area(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_allow_interrupt(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::autofill_assistant::external::ActionInfo&
ExternalActionProto::_Internal::info(const ExternalActionProto* msg) {
  return *msg->info_;
}
void ExternalActionProto::clear_info() {
  if (info_ != nullptr) info_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
ExternalActionProto::ExternalActionProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  conditions_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.ExternalActionProto)
}
ExternalActionProto::ExternalActionProto(const ExternalActionProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      conditions_(from.conditions_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_info()) {
    info_ = new ::autofill_assistant::external::ActionInfo(*from.info_);
  } else {
    info_ = nullptr;
  }
  ::memcpy(&show_touchable_area_, &from.show_touchable_area_,
    static_cast<size_t>(reinterpret_cast<char*>(&allow_interrupt_) -
    reinterpret_cast<char*>(&show_touchable_area_)) + sizeof(allow_interrupt_));
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.ExternalActionProto)
}

inline void ExternalActionProto::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&info_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&allow_interrupt_) -
    reinterpret_cast<char*>(&info_)) + sizeof(allow_interrupt_));
}

ExternalActionProto::~ExternalActionProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.ExternalActionProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ExternalActionProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete info_;
}

void ExternalActionProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ExternalActionProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.ExternalActionProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  conditions_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(info_ != nullptr);
    info_->Clear();
  }
  ::memset(&show_touchable_area_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&allow_interrupt_) -
      reinterpret_cast<char*>(&show_touchable_area_)) + sizeof(allow_interrupt_));
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ExternalActionProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .autofill_assistant.external.ActionInfo info = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool show_touchable_area = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_show_touchable_area(&has_bits);
          show_touchable_area_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool allow_interrupt = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_allow_interrupt(&has_bits);
          allow_interrupt_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .autofill_assistant.ExternalActionProto.ExternalCondition conditions = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_conditions(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ExternalActionProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.ExternalActionProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .autofill_assistant.external.ActionInfo info = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::info(this),
        _Internal::info(this).GetCachedSize(), target, stream);
  }

  // optional bool show_touchable_area = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_show_touchable_area(), target);
  }

  // optional bool allow_interrupt = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_allow_interrupt(), target);
  }

  // repeated .autofill_assistant.ExternalActionProto.ExternalCondition conditions = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_conditions_size()); i < n; i++) {
    const auto& repfield = this->_internal_conditions(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.ExternalActionProto)
  return target;
}

size_t ExternalActionProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.ExternalActionProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .autofill_assistant.ExternalActionProto.ExternalCondition conditions = 4;
  total_size += 1UL * this->_internal_conditions_size();
  for (const auto& msg : this->conditions_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .autofill_assistant.external.ActionInfo info = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *info_);
    }

    // optional bool show_touchable_area = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

    // optional bool allow_interrupt = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ExternalActionProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ExternalActionProto*>(
      &from));
}

void ExternalActionProto::MergeFrom(const ExternalActionProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.ExternalActionProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  conditions_.MergeFrom(from.conditions_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_info()->::autofill_assistant::external::ActionInfo::MergeFrom(from._internal_info());
    }
    if (cached_has_bits & 0x00000002u) {
      show_touchable_area_ = from.show_touchable_area_;
    }
    if (cached_has_bits & 0x00000004u) {
      allow_interrupt_ = from.allow_interrupt_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ExternalActionProto::CopyFrom(const ExternalActionProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.ExternalActionProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ExternalActionProto::IsInitialized() const {
  if (_internal_has_info()) {
    if (!info_->IsInitialized()) return false;
  }
  return true;
}

void ExternalActionProto::InternalSwap(ExternalActionProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  conditions_.InternalSwap(&other->conditions_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ExternalActionProto, allow_interrupt_)
      + sizeof(ExternalActionProto::allow_interrupt_)
      - PROTOBUF_FIELD_OFFSET(ExternalActionProto, info_)>(
          reinterpret_cast<char*>(&info_),
          reinterpret_cast<char*>(&other->info_));
}

std::string ExternalActionProto::GetTypeName() const {
  return "autofill_assistant.ExternalActionProto";
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace autofill_assistant
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::autofill_assistant::FieldTrialProto*
Arena::CreateMaybeMessage< ::autofill_assistant::FieldTrialProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::FieldTrialProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::ClientContextProto_Chrome*
Arena::CreateMaybeMessage< ::autofill_assistant::ClientContextProto_Chrome >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::ClientContextProto_Chrome >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::ClientContextProto_DeviceContextProto_VersionProto*
Arena::CreateMaybeMessage< ::autofill_assistant::ClientContextProto_DeviceContextProto_VersionProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::ClientContextProto_DeviceContextProto_VersionProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::ClientContextProto_DeviceContextProto*
Arena::CreateMaybeMessage< ::autofill_assistant::ClientContextProto_DeviceContextProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::ClientContextProto_DeviceContextProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::ClientContextProto_WindowSize*
Arena::CreateMaybeMessage< ::autofill_assistant::ClientContextProto_WindowSize >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::ClientContextProto_WindowSize >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::ClientContextProto_AnnotateDomModelContextProto*
Arena::CreateMaybeMessage< ::autofill_assistant::ClientContextProto_AnnotateDomModelContextProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::ClientContextProto_AnnotateDomModelContextProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::ClientContextProto*
Arena::CreateMaybeMessage< ::autofill_assistant::ClientContextProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::ClientContextProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::SupportsScriptRequestProto*
Arena::CreateMaybeMessage< ::autofill_assistant::SupportsScriptRequestProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::SupportsScriptRequestProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::ImplicitTriggeringDebugParametersProto*
Arena::CreateMaybeMessage< ::autofill_assistant::ImplicitTriggeringDebugParametersProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::ImplicitTriggeringDebugParametersProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::ScriptParameterProto*
Arena::CreateMaybeMessage< ::autofill_assistant::ScriptParameterProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::ScriptParameterProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::SupportsScriptResponseProto*
Arena::CreateMaybeMessage< ::autofill_assistant::SupportsScriptResponseProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::SupportsScriptResponseProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::GetCapabilitiesByHashPrefixRequestProto*
Arena::CreateMaybeMessage< ::autofill_assistant::GetCapabilitiesByHashPrefixRequestProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::GetCapabilitiesByHashPrefixRequestProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::GetCapabilitiesByHashPrefixResponseProto_MatchInfoProto*
Arena::CreateMaybeMessage< ::autofill_assistant::GetCapabilitiesByHashPrefixResponseProto_MatchInfoProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::GetCapabilitiesByHashPrefixResponseProto_MatchInfoProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::GetCapabilitiesByHashPrefixResponseProto*
Arena::CreateMaybeMessage< ::autofill_assistant::GetCapabilitiesByHashPrefixResponseProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::GetCapabilitiesByHashPrefixResponseProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::GetUserDataRequestProto_PaymentMethodRequest*
Arena::CreateMaybeMessage< ::autofill_assistant::GetUserDataRequestProto_PaymentMethodRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::GetUserDataRequestProto_PaymentMethodRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::GetUserDataRequestProto_AddressRequest*
Arena::CreateMaybeMessage< ::autofill_assistant::GetUserDataRequestProto_AddressRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::GetUserDataRequestProto_AddressRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::GetUserDataRequestProto*
Arena::CreateMaybeMessage< ::autofill_assistant::GetUserDataRequestProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::GetUserDataRequestProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::GetUserDataResponseProto*
Arena::CreateMaybeMessage< ::autofill_assistant::GetUserDataResponseProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::GetUserDataResponseProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::OverlayImageProto*
Arena::CreateMaybeMessage< ::autofill_assistant::OverlayImageProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::OverlayImageProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::ClientSettingsProto_IntegrationTestSettings*
Arena::CreateMaybeMessage< ::autofill_assistant::ClientSettingsProto_IntegrationTestSettings >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::ClientSettingsProto_IntegrationTestSettings >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::ClientSettingsProto_BackButtonSettings*
Arena::CreateMaybeMessage< ::autofill_assistant::ClientSettingsProto_BackButtonSettings >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::ClientSettingsProto_BackButtonSettings >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::ClientSettingsProto_SlowWarningSettings*
Arena::CreateMaybeMessage< ::autofill_assistant::ClientSettingsProto_SlowWarningSettings >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::ClientSettingsProto_SlowWarningSettings >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::ClientSettingsProto_DisplayString*
Arena::CreateMaybeMessage< ::autofill_assistant::ClientSettingsProto_DisplayString >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::ClientSettingsProto_DisplayString >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::ClientSettingsProto*
Arena::CreateMaybeMessage< ::autofill_assistant::ClientSettingsProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::ClientSettingsProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::ScriptTimeoutError*
Arena::CreateMaybeMessage< ::autofill_assistant::ScriptTimeoutError >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::ScriptTimeoutError >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::SupportedScriptProto_PresentationProto*
Arena::CreateMaybeMessage< ::autofill_assistant::SupportedScriptProto_PresentationProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::SupportedScriptProto_PresentationProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::SupportedScriptProto*
Arena::CreateMaybeMessage< ::autofill_assistant::SupportedScriptProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::SupportedScriptProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::ScriptPreconditionProto*
Arena::CreateMaybeMessage< ::autofill_assistant::ScriptPreconditionProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::ScriptPreconditionProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::ScriptParameterMatchProto*
Arena::CreateMaybeMessage< ::autofill_assistant::ScriptParameterMatchProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::ScriptParameterMatchProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::CUPRequestData*
Arena::CreateMaybeMessage< ::autofill_assistant::CUPRequestData >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::CUPRequestData >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::ScriptActionRequestProto*
Arena::CreateMaybeMessage< ::autofill_assistant::ScriptActionRequestProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::ScriptActionRequestProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::ScriptStoreConfig*
Arena::CreateMaybeMessage< ::autofill_assistant::ScriptStoreConfig >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::ScriptStoreConfig >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::InitialScriptActionsRequestProto_QueryProto*
Arena::CreateMaybeMessage< ::autofill_assistant::InitialScriptActionsRequestProto_QueryProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::InitialScriptActionsRequestProto_QueryProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::InitialScriptActionsRequestProto*
Arena::CreateMaybeMessage< ::autofill_assistant::InitialScriptActionsRequestProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::InitialScriptActionsRequestProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::RoundtripTimingStats*
Arena::CreateMaybeMessage< ::autofill_assistant::RoundtripTimingStats >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::RoundtripTimingStats >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::RoundtripNetworkStats_ActionNetworkStats*
Arena::CreateMaybeMessage< ::autofill_assistant::RoundtripNetworkStats_ActionNetworkStats >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::RoundtripNetworkStats_ActionNetworkStats >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::RoundtripNetworkStats*
Arena::CreateMaybeMessage< ::autofill_assistant::RoundtripNetworkStats >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::RoundtripNetworkStats >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::NextScriptActionsRequestProto*
Arena::CreateMaybeMessage< ::autofill_assistant::NextScriptActionsRequestProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::NextScriptActionsRequestProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::CUPResponseData*
Arena::CreateMaybeMessage< ::autofill_assistant::CUPResponseData >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::CUPResponseData >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::ActionsResponseProto_UpdateScriptListProto*
Arena::CreateMaybeMessage< ::autofill_assistant::ActionsResponseProto_UpdateScriptListProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::ActionsResponseProto_UpdateScriptListProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::ActionsResponseProto*
Arena::CreateMaybeMessage< ::autofill_assistant::ActionsResponseProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::ActionsResponseProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::GetTriggerScriptsRequestProto*
Arena::CreateMaybeMessage< ::autofill_assistant::GetTriggerScriptsRequestProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::GetTriggerScriptsRequestProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::GetTriggerScriptsResponseProto*
Arena::CreateMaybeMessage< ::autofill_assistant::GetTriggerScriptsResponseProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::GetTriggerScriptsResponseProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::TriggerScriptProto*
Arena::CreateMaybeMessage< ::autofill_assistant::TriggerScriptProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::TriggerScriptProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::TriggerScriptConditionProto_DocumentReadyStateCondition*
Arena::CreateMaybeMessage< ::autofill_assistant::TriggerScriptConditionProto_DocumentReadyStateCondition >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::TriggerScriptConditionProto_DocumentReadyStateCondition >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::TriggerScriptConditionProto*
Arena::CreateMaybeMessage< ::autofill_assistant::TriggerScriptConditionProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::TriggerScriptConditionProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::TriggerScriptConditionsProto*
Arena::CreateMaybeMessage< ::autofill_assistant::TriggerScriptConditionsProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::TriggerScriptConditionsProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::TriggerScriptUIProto_ProgressBar*
Arena::CreateMaybeMessage< ::autofill_assistant::TriggerScriptUIProto_ProgressBar >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::TriggerScriptUIProto_ProgressBar >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::TriggerScriptUIProto_TriggerChip*
Arena::CreateMaybeMessage< ::autofill_assistant::TriggerScriptUIProto_TriggerChip >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::TriggerScriptUIProto_TriggerChip >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::TriggerScriptUIProto_Popup_Choice*
Arena::CreateMaybeMessage< ::autofill_assistant::TriggerScriptUIProto_Popup_Choice >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::TriggerScriptUIProto_Popup_Choice >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::TriggerScriptUIProto_Popup*
Arena::CreateMaybeMessage< ::autofill_assistant::TriggerScriptUIProto_Popup >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::TriggerScriptUIProto_Popup >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::TriggerScriptUIProto*
Arena::CreateMaybeMessage< ::autofill_assistant::TriggerScriptUIProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::TriggerScriptUIProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::ActionProto*
Arena::CreateMaybeMessage< ::autofill_assistant::ActionProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::ActionProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::CollectUserDataResultProto*
Arena::CreateMaybeMessage< ::autofill_assistant::CollectUserDataResultProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::CollectUserDataResultProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::ActionTimingStats*
Arena::CreateMaybeMessage< ::autofill_assistant::ActionTimingStats >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::ActionTimingStats >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::ProcessedActionProto*
Arena::CreateMaybeMessage< ::autofill_assistant::ProcessedActionProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::ProcessedActionProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::ProcessedActionStatusDetailsProto*
Arena::CreateMaybeMessage< ::autofill_assistant::ProcessedActionStatusDetailsProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::ProcessedActionStatusDetailsProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::NavigationInfoProto*
Arena::CreateMaybeMessage< ::autofill_assistant::NavigationInfoProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::NavigationInfoProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::UnexpectedErrorInfoProto*
Arena::CreateMaybeMessage< ::autofill_assistant::UnexpectedErrorInfoProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::UnexpectedErrorInfoProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::AutofillErrorInfoProto_AutofillFieldError*
Arena::CreateMaybeMessage< ::autofill_assistant::AutofillErrorInfoProto_AutofillFieldError >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::AutofillErrorInfoProto_AutofillFieldError >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::AutofillErrorInfoProto*
Arena::CreateMaybeMessage< ::autofill_assistant::AutofillErrorInfoProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::AutofillErrorInfoProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::WebControllerErrorInfoProto*
Arena::CreateMaybeMessage< ::autofill_assistant::WebControllerErrorInfoProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::WebControllerErrorInfoProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::ElementFinderInfoProto_PredictedElement*
Arena::CreateMaybeMessage< ::autofill_assistant::ElementFinderInfoProto_PredictedElement >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::ElementFinderInfoProto_PredictedElement >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::ElementFinderInfoProto_SemanticInferenceResult*
Arena::CreateMaybeMessage< ::autofill_assistant::ElementFinderInfoProto_SemanticInferenceResult >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::ElementFinderInfoProto_SemanticInferenceResult >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::ElementFinderInfoProto*
Arena::CreateMaybeMessage< ::autofill_assistant::ElementFinderInfoProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::ElementFinderInfoProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::SelectorProto_Filter*
Arena::CreateMaybeMessage< ::autofill_assistant::SelectorProto_Filter >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::SelectorProto_Filter >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::SelectorProto_PropertyFilter*
Arena::CreateMaybeMessage< ::autofill_assistant::SelectorProto_PropertyFilter >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::SelectorProto_PropertyFilter >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::SelectorProto_PseudoElementContent*
Arena::CreateMaybeMessage< ::autofill_assistant::SelectorProto_PseudoElementContent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::SelectorProto_PseudoElementContent >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::SelectorProto_CssStyleFilter*
Arena::CreateMaybeMessage< ::autofill_assistant::SelectorProto_CssStyleFilter >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::SelectorProto_CssStyleFilter >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::SelectorProto_BoundingBoxFilter*
Arena::CreateMaybeMessage< ::autofill_assistant::SelectorProto_BoundingBoxFilter >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::SelectorProto_BoundingBoxFilter >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::SelectorProto_OnTopFilter*
Arena::CreateMaybeMessage< ::autofill_assistant::SelectorProto_OnTopFilter >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::SelectorProto_OnTopFilter >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::SelectorProto_EmptyFilter*
Arena::CreateMaybeMessage< ::autofill_assistant::SelectorProto_EmptyFilter >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::SelectorProto_EmptyFilter >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::SelectorProto_NthMatchFilter*
Arena::CreateMaybeMessage< ::autofill_assistant::SelectorProto_NthMatchFilter >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::SelectorProto_NthMatchFilter >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::SelectorProto_SemanticFilter*
Arena::CreateMaybeMessage< ::autofill_assistant::SelectorProto_SemanticFilter >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::SelectorProto_SemanticFilter >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::SelectorProto*
Arena::CreateMaybeMessage< ::autofill_assistant::SelectorProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::SelectorProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::SelectOptionProto*
Arena::CreateMaybeMessage< ::autofill_assistant::SelectOptionProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::SelectOptionProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::UpdateClientSettingsProto*
Arena::CreateMaybeMessage< ::autofill_assistant::UpdateClientSettingsProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::UpdateClientSettingsProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::PromptQrCodeScanProto_CameraScanUiStrings*
Arena::CreateMaybeMessage< ::autofill_assistant::PromptQrCodeScanProto_CameraScanUiStrings >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::PromptQrCodeScanProto_CameraScanUiStrings >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::PromptQrCodeScanProto_ImagePickerUiStrings*
Arena::CreateMaybeMessage< ::autofill_assistant::PromptQrCodeScanProto_ImagePickerUiStrings >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::PromptQrCodeScanProto_ImagePickerUiStrings >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::PromptQrCodeScanProto*
Arena::CreateMaybeMessage< ::autofill_assistant::PromptQrCodeScanProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::PromptQrCodeScanProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::TellProto_TextToSpeech*
Arena::CreateMaybeMessage< ::autofill_assistant::TellProto_TextToSpeech >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::TellProto_TextToSpeech >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::TellProto*
Arena::CreateMaybeMessage< ::autofill_assistant::TellProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::TellProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::ShowCastProto_TopPadding*
Arena::CreateMaybeMessage< ::autofill_assistant::ShowCastProto_TopPadding >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::ShowCastProto_TopPadding >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::ShowCastProto*
Arena::CreateMaybeMessage< ::autofill_assistant::ShowCastProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::ShowCastProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::SetTouchableAreaProto*
Arena::CreateMaybeMessage< ::autofill_assistant::SetTouchableAreaProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::SetTouchableAreaProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::ElementAreaProto_Rectangle*
Arena::CreateMaybeMessage< ::autofill_assistant::ElementAreaProto_Rectangle >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::ElementAreaProto_Rectangle >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::ElementAreaProto*
Arena::CreateMaybeMessage< ::autofill_assistant::ElementAreaProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::ElementAreaProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::RequiredFieldProto*
Arena::CreateMaybeMessage< ::autofill_assistant::RequiredFieldProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::RequiredFieldProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::UseAddressProto*
Arena::CreateMaybeMessage< ::autofill_assistant::UseAddressProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::UseAddressProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::UseCreditCardProto*
Arena::CreateMaybeMessage< ::autofill_assistant::UseCreditCardProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::UseCreditCardProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::WaitForDomProto_Result*
Arena::CreateMaybeMessage< ::autofill_assistant::WaitForDomProto_Result >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::WaitForDomProto_Result >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::WaitForDomProto*
Arena::CreateMaybeMessage< ::autofill_assistant::WaitForDomProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::WaitForDomProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::ElementConditionProto*
Arena::CreateMaybeMessage< ::autofill_assistant::ElementConditionProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::ElementConditionProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::ElementConditionsProto*
Arena::CreateMaybeMessage< ::autofill_assistant::ElementConditionsProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::ElementConditionsProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::UploadDomProto_Result*
Arena::CreateMaybeMessage< ::autofill_assistant::UploadDomProto_Result >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::UploadDomProto_Result >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::UploadDomProto*
Arena::CreateMaybeMessage< ::autofill_assistant::UploadDomProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::UploadDomProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::ShowProgressBarProto_StepProgressBarIcon*
Arena::CreateMaybeMessage< ::autofill_assistant::ShowProgressBarProto_StepProgressBarIcon >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::ShowProgressBarProto_StepProgressBarIcon >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::ShowProgressBarProto_StepProgressBarConfiguration*
Arena::CreateMaybeMessage< ::autofill_assistant::ShowProgressBarProto_StepProgressBarConfiguration >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::ShowProgressBarProto_StepProgressBarConfiguration >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::ShowProgressBarProto*
Arena::CreateMaybeMessage< ::autofill_assistant::ShowProgressBarProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::ShowProgressBarProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::NavigateProto*
Arena::CreateMaybeMessage< ::autofill_assistant::NavigateProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::NavigateProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::ExpectNavigationProto*
Arena::CreateMaybeMessage< ::autofill_assistant::ExpectNavigationProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::ExpectNavigationProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::WaitForNavigationProto*
Arena::CreateMaybeMessage< ::autofill_assistant::WaitForNavigationProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::WaitForNavigationProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::WaitForDocumentProto_Result*
Arena::CreateMaybeMessage< ::autofill_assistant::WaitForDocumentProto_Result >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::WaitForDocumentProto_Result >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::WaitForDocumentProto*
Arena::CreateMaybeMessage< ::autofill_assistant::WaitForDocumentProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::WaitForDocumentProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::ShowGenericUiProto_RequestUserData_AdditionalValue*
Arena::CreateMaybeMessage< ::autofill_assistant::ShowGenericUiProto_RequestUserData_AdditionalValue >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::ShowGenericUiProto_RequestUserData_AdditionalValue >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::ShowGenericUiProto_RequestUserData*
Arena::CreateMaybeMessage< ::autofill_assistant::ShowGenericUiProto_RequestUserData >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::ShowGenericUiProto_RequestUserData >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::ShowGenericUiProto_Result*
Arena::CreateMaybeMessage< ::autofill_assistant::ShowGenericUiProto_Result >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::ShowGenericUiProto_Result >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::ShowGenericUiProto_PeriodicElementChecks_ElementCheck*
Arena::CreateMaybeMessage< ::autofill_assistant::ShowGenericUiProto_PeriodicElementChecks_ElementCheck >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::ShowGenericUiProto_PeriodicElementChecks_ElementCheck >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::ShowGenericUiProto_PeriodicElementChecks*
Arena::CreateMaybeMessage< ::autofill_assistant::ShowGenericUiProto_PeriodicElementChecks >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::ShowGenericUiProto_PeriodicElementChecks >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::ShowGenericUiProto*
Arena::CreateMaybeMessage< ::autofill_assistant::ShowGenericUiProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::ShowGenericUiProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::SetPersistentUiProto*
Arena::CreateMaybeMessage< ::autofill_assistant::SetPersistentUiProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::SetPersistentUiProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::ClearPersistentUiProto*
Arena::CreateMaybeMessage< ::autofill_assistant::ClearPersistentUiProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::ClearPersistentUiProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::PromptProto_Choice*
Arena::CreateMaybeMessage< ::autofill_assistant::PromptProto_Choice >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::PromptProto_Choice >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::PromptProto_Result*
Arena::CreateMaybeMessage< ::autofill_assistant::PromptProto_Result >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::PromptProto_Result >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::PromptProto*
Arena::CreateMaybeMessage< ::autofill_assistant::PromptProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::PromptProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::ContactDetailsProto*
Arena::CreateMaybeMessage< ::autofill_assistant::ContactDetailsProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::ContactDetailsProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::LoginDetailsProto_LoginOptionCustomProto*
Arena::CreateMaybeMessage< ::autofill_assistant::LoginDetailsProto_LoginOptionCustomProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::LoginDetailsProto_LoginOptionCustomProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::LoginDetailsProto_LoginOptionPasswordManagerProto*
Arena::CreateMaybeMessage< ::autofill_assistant::LoginDetailsProto_LoginOptionPasswordManagerProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::LoginDetailsProto_LoginOptionPasswordManagerProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::LoginDetailsProto_LoginOptionProto*
Arena::CreateMaybeMessage< ::autofill_assistant::LoginDetailsProto_LoginOptionProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::LoginDetailsProto_LoginOptionProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::LoginDetailsProto*
Arena::CreateMaybeMessage< ::autofill_assistant::LoginDetailsProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::LoginDetailsProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::StaticTextSectionProto*
Arena::CreateMaybeMessage< ::autofill_assistant::StaticTextSectionProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::StaticTextSectionProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::TextInputProto*
Arena::CreateMaybeMessage< ::autofill_assistant::TextInputProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::TextInputProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::TextInputSectionProto*
Arena::CreateMaybeMessage< ::autofill_assistant::TextInputSectionProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::TextInputSectionProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::UserFormSectionProto*
Arena::CreateMaybeMessage< ::autofill_assistant::UserFormSectionProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::UserFormSectionProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::PopupListSectionProto*
Arena::CreateMaybeMessage< ::autofill_assistant::PopupListSectionProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::PopupListSectionProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::AutofillEntryProto*
Arena::CreateMaybeMessage< ::autofill_assistant::AutofillEntryProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::AutofillEntryProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::ProfileProto_ValuesEntry_DoNotUse*
Arena::CreateMaybeMessage< ::autofill_assistant::ProfileProto_ValuesEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::ProfileProto_ValuesEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::ProfileProto*
Arena::CreateMaybeMessage< ::autofill_assistant::ProfileProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::ProfileProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::PhoneNumberProto*
Arena::CreateMaybeMessage< ::autofill_assistant::PhoneNumberProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::PhoneNumberProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::PaymentInstrumentProto_CardValuesEntry_DoNotUse*
Arena::CreateMaybeMessage< ::autofill_assistant::PaymentInstrumentProto_CardValuesEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::PaymentInstrumentProto_CardValuesEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::PaymentInstrumentProto_AddressValuesEntry_DoNotUse*
Arena::CreateMaybeMessage< ::autofill_assistant::PaymentInstrumentProto_AddressValuesEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::PaymentInstrumentProto_AddressValuesEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::PaymentInstrumentProto*
Arena::CreateMaybeMessage< ::autofill_assistant::PaymentInstrumentProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::PaymentInstrumentProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::DataOriginNoticeProto*
Arena::CreateMaybeMessage< ::autofill_assistant::DataOriginNoticeProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::DataOriginNoticeProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::CollectUserDataProto_DataSource*
Arena::CreateMaybeMessage< ::autofill_assistant::CollectUserDataProto_DataSource >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::CollectUserDataProto_DataSource >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::CollectUserDataProto*
Arena::CreateMaybeMessage< ::autofill_assistant::CollectUserDataProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::CollectUserDataProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::StopProto*
Arena::CreateMaybeMessage< ::autofill_assistant::StopProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::StopProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::DetailsChangesProto*
Arena::CreateMaybeMessage< ::autofill_assistant::DetailsChangesProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::DetailsChangesProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::DetailsProto_ImageClickthroughData*
Arena::CreateMaybeMessage< ::autofill_assistant::DetailsProto_ImageClickthroughData >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::DetailsProto_ImageClickthroughData >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::DetailsProto_PlaceholdersConfiguration*
Arena::CreateMaybeMessage< ::autofill_assistant::DetailsProto_PlaceholdersConfiguration >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::DetailsProto_PlaceholdersConfiguration >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::DetailsProto*
Arena::CreateMaybeMessage< ::autofill_assistant::DetailsProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::DetailsProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::ShowDetailsProto*
Arena::CreateMaybeMessage< ::autofill_assistant::ShowDetailsProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::ShowDetailsProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::GeneratePasswordForFormFieldProto*
Arena::CreateMaybeMessage< ::autofill_assistant::GeneratePasswordForFormFieldProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::GeneratePasswordForFormFieldProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::PresaveGeneratedPasswordProto*
Arena::CreateMaybeMessage< ::autofill_assistant::PresaveGeneratedPasswordProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::PresaveGeneratedPasswordProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::SaveGeneratedPasswordProto*
Arena::CreateMaybeMessage< ::autofill_assistant::SaveGeneratedPasswordProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::SaveGeneratedPasswordProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::DeleteSelectedPasswordProto*
Arena::CreateMaybeMessage< ::autofill_assistant::DeleteSelectedPasswordProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::DeleteSelectedPasswordProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::EditSelectedPasswordProto*
Arena::CreateMaybeMessage< ::autofill_assistant::EditSelectedPasswordProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::EditSelectedPasswordProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::ResetPendingCredentialsProto*
Arena::CreateMaybeMessage< ::autofill_assistant::ResetPendingCredentialsProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::ResetPendingCredentialsProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::SaveSubmittedPasswordProto_Result*
Arena::CreateMaybeMessage< ::autofill_assistant::SaveSubmittedPasswordProto_Result >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::SaveSubmittedPasswordProto_Result >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::SaveSubmittedPasswordProto*
Arena::CreateMaybeMessage< ::autofill_assistant::SaveSubmittedPasswordProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::SaveSubmittedPasswordProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::RegisterPasswordResetRequestProto*
Arena::CreateMaybeMessage< ::autofill_assistant::RegisterPasswordResetRequestProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::RegisterPasswordResetRequestProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::ConfigureUiStateProto*
Arena::CreateMaybeMessage< ::autofill_assistant::ConfigureUiStateProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::ConfigureUiStateProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::SetAttributeProto*
Arena::CreateMaybeMessage< ::autofill_assistant::SetAttributeProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::SetAttributeProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::InfoBoxProto*
Arena::CreateMaybeMessage< ::autofill_assistant::InfoBoxProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::InfoBoxProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::ShowInfoBoxProto*
Arena::CreateMaybeMessage< ::autofill_assistant::ShowInfoBoxProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::ShowInfoBoxProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::ConfigureBottomSheetProto*
Arena::CreateMaybeMessage< ::autofill_assistant::ConfigureBottomSheetProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::ConfigureBottomSheetProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::ShowFormProto*
Arena::CreateMaybeMessage< ::autofill_assistant::ShowFormProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::ShowFormProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::FormProto_Result*
Arena::CreateMaybeMessage< ::autofill_assistant::FormProto_Result >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::FormProto_Result >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::FormProto*
Arena::CreateMaybeMessage< ::autofill_assistant::FormProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::FormProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::FormInputProto_Result*
Arena::CreateMaybeMessage< ::autofill_assistant::FormInputProto_Result >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::FormInputProto_Result >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::FormInputProto*
Arena::CreateMaybeMessage< ::autofill_assistant::FormInputProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::FormInputProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::CounterInputProto_Counter*
Arena::CreateMaybeMessage< ::autofill_assistant::CounterInputProto_Counter >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::CounterInputProto_Counter >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::CounterInputProto_Result*
Arena::CreateMaybeMessage< ::autofill_assistant::CounterInputProto_Result >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::CounterInputProto_Result >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::CounterInputProto_ValidationRule_BooleanRule*
Arena::CreateMaybeMessage< ::autofill_assistant::CounterInputProto_ValidationRule_BooleanRule >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::CounterInputProto_ValidationRule_BooleanRule >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::CounterInputProto_ValidationRule_CounterRule*
Arena::CreateMaybeMessage< ::autofill_assistant::CounterInputProto_ValidationRule_CounterRule >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::CounterInputProto_ValidationRule_CounterRule >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::CounterInputProto_ValidationRule_CountersSumRule*
Arena::CreateMaybeMessage< ::autofill_assistant::CounterInputProto_ValidationRule_CountersSumRule >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::CounterInputProto_ValidationRule_CountersSumRule >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::CounterInputProto_ValidationRule*
Arena::CreateMaybeMessage< ::autofill_assistant::CounterInputProto_ValidationRule >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::CounterInputProto_ValidationRule >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::CounterInputProto*
Arena::CreateMaybeMessage< ::autofill_assistant::CounterInputProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::CounterInputProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::SelectionInputProto_Choice*
Arena::CreateMaybeMessage< ::autofill_assistant::SelectionInputProto_Choice >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::SelectionInputProto_Choice >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::SelectionInputProto_Result*
Arena::CreateMaybeMessage< ::autofill_assistant::SelectionInputProto_Result >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::SelectionInputProto_Result >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::SelectionInputProto*
Arena::CreateMaybeMessage< ::autofill_assistant::SelectionInputProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::SelectionInputProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::PopupMessageProto*
Arena::CreateMaybeMessage< ::autofill_assistant::PopupMessageProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::PopupMessageProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::GetElementStatusProto_Result*
Arena::CreateMaybeMessage< ::autofill_assistant::GetElementStatusProto_Result >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::GetElementStatusProto_Result >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::GetElementStatusProto_MatchOptions*
Arena::CreateMaybeMessage< ::autofill_assistant::GetElementStatusProto_MatchOptions >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::GetElementStatusProto_MatchOptions >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::GetElementStatusProto_MatchExpectation*
Arena::CreateMaybeMessage< ::autofill_assistant::GetElementStatusProto_MatchExpectation >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::GetElementStatusProto_MatchExpectation >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::GetElementStatusProto_TextMatch*
Arena::CreateMaybeMessage< ::autofill_assistant::GetElementStatusProto_TextMatch >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::GetElementStatusProto_TextMatch >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::GetElementStatusProto_ValueMatch*
Arena::CreateMaybeMessage< ::autofill_assistant::GetElementStatusProto_ValueMatch >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::GetElementStatusProto_ValueMatch >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::GetElementStatusProto_ComparisonReport*
Arena::CreateMaybeMessage< ::autofill_assistant::GetElementStatusProto_ComparisonReport >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::GetElementStatusProto_ComparisonReport >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::GetElementStatusProto*
Arena::CreateMaybeMessage< ::autofill_assistant::GetElementStatusProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::GetElementStatusProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::ReleaseElementsProto*
Arena::CreateMaybeMessage< ::autofill_assistant::ReleaseElementsProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::ReleaseElementsProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::DispatchJsEventProto*
Arena::CreateMaybeMessage< ::autofill_assistant::DispatchJsEventProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::DispatchJsEventProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::JsFlowProto_Result*
Arena::CreateMaybeMessage< ::autofill_assistant::JsFlowProto_Result >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::JsFlowProto_Result >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::JsFlowProto*
Arena::CreateMaybeMessage< ::autofill_assistant::JsFlowProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::JsFlowProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::ExternalActionProto_ExternalCondition*
Arena::CreateMaybeMessage< ::autofill_assistant::ExternalActionProto_ExternalCondition >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::ExternalActionProto_ExternalCondition >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::ExternalActionProto_Result*
Arena::CreateMaybeMessage< ::autofill_assistant::ExternalActionProto_Result >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::ExternalActionProto_Result >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::ExternalActionProto*
Arena::CreateMaybeMessage< ::autofill_assistant::ExternalActionProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::ExternalActionProto >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
