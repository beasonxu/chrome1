// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: components/autofill_assistant/browser/dom_action.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_components_2fautofill_5fassistant_2fbrowser_2fdom_5faction_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_components_2fautofill_5fassistant_2fbrowser_2fdom_5faction_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3020000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3020000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include "components/autofill_assistant/browser/action_value.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_components_2fautofill_5fassistant_2fbrowser_2fdom_5faction_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_components_2fautofill_5fassistant_2fbrowser_2fdom_5faction_2eproto {
  static const uint32_t offsets[];
};
namespace autofill_assistant {
class BlurFieldProto;
struct BlurFieldProtoDefaultTypeInternal;
extern BlurFieldProtoDefaultTypeInternal _BlurFieldProto_default_instance_;
class CheckElementIsOnTopProto;
struct CheckElementIsOnTopProtoDefaultTypeInternal;
extern CheckElementIsOnTopProtoDefaultTypeInternal _CheckElementIsOnTopProto_default_instance_;
class CheckElementTagProto;
struct CheckElementTagProtoDefaultTypeInternal;
extern CheckElementTagProtoDefaultTypeInternal _CheckElementTagProto_default_instance_;
class CheckOptionElementProto;
struct CheckOptionElementProtoDefaultTypeInternal;
extern CheckOptionElementProtoDefaultTypeInternal _CheckOptionElementProto_default_instance_;
class CheckOptionElementProto_Result;
struct CheckOptionElementProto_ResultDefaultTypeInternal;
extern CheckOptionElementProto_ResultDefaultTypeInternal _CheckOptionElementProto_Result_default_instance_;
class ClientIdProto;
struct ClientIdProtoDefaultTypeInternal;
extern ClientIdProtoDefaultTypeInternal _ClientIdProto_default_instance_;
class ExecuteJsProto;
struct ExecuteJsProtoDefaultTypeInternal;
extern ExecuteJsProtoDefaultTypeInternal _ExecuteJsProto_default_instance_;
class FocusFieldProto;
struct FocusFieldProtoDefaultTypeInternal;
extern FocusFieldProtoDefaultTypeInternal _FocusFieldProto_default_instance_;
class JsClickProto;
struct JsClickProtoDefaultTypeInternal;
extern JsClickProtoDefaultTypeInternal _JsClickProto_default_instance_;
class ScrollContainerProto;
struct ScrollContainerProtoDefaultTypeInternal;
extern ScrollContainerProtoDefaultTypeInternal _ScrollContainerProto_default_instance_;
class ScrollDistance;
struct ScrollDistanceDefaultTypeInternal;
extern ScrollDistanceDefaultTypeInternal _ScrollDistance_default_instance_;
class ScrollIntoViewIfNeededProto;
struct ScrollIntoViewIfNeededProtoDefaultTypeInternal;
extern ScrollIntoViewIfNeededProtoDefaultTypeInternal _ScrollIntoViewIfNeededProto_default_instance_;
class ScrollIntoViewProto;
struct ScrollIntoViewProtoDefaultTypeInternal;
extern ScrollIntoViewProtoDefaultTypeInternal _ScrollIntoViewProto_default_instance_;
class ScrollWindowProto;
struct ScrollWindowProtoDefaultTypeInternal;
extern ScrollWindowProtoDefaultTypeInternal _ScrollWindowProto_default_instance_;
class SelectFieldValueProto;
struct SelectFieldValueProtoDefaultTypeInternal;
extern SelectFieldValueProtoDefaultTypeInternal _SelectFieldValueProto_default_instance_;
class SelectOptionElementProto;
struct SelectOptionElementProtoDefaultTypeInternal;
extern SelectOptionElementProtoDefaultTypeInternal _SelectOptionElementProto_default_instance_;
class SendChangeEventProto;
struct SendChangeEventProtoDefaultTypeInternal;
extern SendChangeEventProtoDefaultTypeInternal _SendChangeEventProto_default_instance_;
class SendClickEventProto;
struct SendClickEventProtoDefaultTypeInternal;
extern SendClickEventProtoDefaultTypeInternal _SendClickEventProto_default_instance_;
class SendKeyEventProto;
struct SendKeyEventProtoDefaultTypeInternal;
extern SendKeyEventProtoDefaultTypeInternal _SendKeyEventProto_default_instance_;
class SendKeystrokeEventsProto;
struct SendKeystrokeEventsProtoDefaultTypeInternal;
extern SendKeystrokeEventsProtoDefaultTypeInternal _SendKeystrokeEventsProto_default_instance_;
class SendKeystrokeEventsProto_Result;
struct SendKeystrokeEventsProto_ResultDefaultTypeInternal;
extern SendKeystrokeEventsProto_ResultDefaultTypeInternal _SendKeystrokeEventsProto_Result_default_instance_;
class SendTapEventProto;
struct SendTapEventProtoDefaultTypeInternal;
extern SendTapEventProtoDefaultTypeInternal _SendTapEventProto_default_instance_;
class SetElementAttributeProto;
struct SetElementAttributeProtoDefaultTypeInternal;
extern SetElementAttributeProtoDefaultTypeInternal _SetElementAttributeProto_default_instance_;
class SetNativeCheckedProto;
struct SetNativeCheckedProtoDefaultTypeInternal;
extern SetNativeCheckedProtoDefaultTypeInternal _SetNativeCheckedProto_default_instance_;
class SetNativeValueProto;
struct SetNativeValueProtoDefaultTypeInternal;
extern SetNativeValueProtoDefaultTypeInternal _SetNativeValueProto_default_instance_;
class WaitForDocumentToBecomeCompleteProto;
struct WaitForDocumentToBecomeCompleteProtoDefaultTypeInternal;
extern WaitForDocumentToBecomeCompleteProtoDefaultTypeInternal _WaitForDocumentToBecomeCompleteProto_default_instance_;
class WaitForDocumentToBecomeInteractiveProto;
struct WaitForDocumentToBecomeInteractiveProtoDefaultTypeInternal;
extern WaitForDocumentToBecomeInteractiveProtoDefaultTypeInternal _WaitForDocumentToBecomeInteractiveProto_default_instance_;
class WaitForElementToBecomeStableProto;
struct WaitForElementToBecomeStableProtoDefaultTypeInternal;
extern WaitForElementToBecomeStableProtoDefaultTypeInternal _WaitForElementToBecomeStableProto_default_instance_;
}  // namespace autofill_assistant
PROTOBUF_NAMESPACE_OPEN
template<> ::autofill_assistant::BlurFieldProto* Arena::CreateMaybeMessage<::autofill_assistant::BlurFieldProto>(Arena*);
template<> ::autofill_assistant::CheckElementIsOnTopProto* Arena::CreateMaybeMessage<::autofill_assistant::CheckElementIsOnTopProto>(Arena*);
template<> ::autofill_assistant::CheckElementTagProto* Arena::CreateMaybeMessage<::autofill_assistant::CheckElementTagProto>(Arena*);
template<> ::autofill_assistant::CheckOptionElementProto* Arena::CreateMaybeMessage<::autofill_assistant::CheckOptionElementProto>(Arena*);
template<> ::autofill_assistant::CheckOptionElementProto_Result* Arena::CreateMaybeMessage<::autofill_assistant::CheckOptionElementProto_Result>(Arena*);
template<> ::autofill_assistant::ClientIdProto* Arena::CreateMaybeMessage<::autofill_assistant::ClientIdProto>(Arena*);
template<> ::autofill_assistant::ExecuteJsProto* Arena::CreateMaybeMessage<::autofill_assistant::ExecuteJsProto>(Arena*);
template<> ::autofill_assistant::FocusFieldProto* Arena::CreateMaybeMessage<::autofill_assistant::FocusFieldProto>(Arena*);
template<> ::autofill_assistant::JsClickProto* Arena::CreateMaybeMessage<::autofill_assistant::JsClickProto>(Arena*);
template<> ::autofill_assistant::ScrollContainerProto* Arena::CreateMaybeMessage<::autofill_assistant::ScrollContainerProto>(Arena*);
template<> ::autofill_assistant::ScrollDistance* Arena::CreateMaybeMessage<::autofill_assistant::ScrollDistance>(Arena*);
template<> ::autofill_assistant::ScrollIntoViewIfNeededProto* Arena::CreateMaybeMessage<::autofill_assistant::ScrollIntoViewIfNeededProto>(Arena*);
template<> ::autofill_assistant::ScrollIntoViewProto* Arena::CreateMaybeMessage<::autofill_assistant::ScrollIntoViewProto>(Arena*);
template<> ::autofill_assistant::ScrollWindowProto* Arena::CreateMaybeMessage<::autofill_assistant::ScrollWindowProto>(Arena*);
template<> ::autofill_assistant::SelectFieldValueProto* Arena::CreateMaybeMessage<::autofill_assistant::SelectFieldValueProto>(Arena*);
template<> ::autofill_assistant::SelectOptionElementProto* Arena::CreateMaybeMessage<::autofill_assistant::SelectOptionElementProto>(Arena*);
template<> ::autofill_assistant::SendChangeEventProto* Arena::CreateMaybeMessage<::autofill_assistant::SendChangeEventProto>(Arena*);
template<> ::autofill_assistant::SendClickEventProto* Arena::CreateMaybeMessage<::autofill_assistant::SendClickEventProto>(Arena*);
template<> ::autofill_assistant::SendKeyEventProto* Arena::CreateMaybeMessage<::autofill_assistant::SendKeyEventProto>(Arena*);
template<> ::autofill_assistant::SendKeystrokeEventsProto* Arena::CreateMaybeMessage<::autofill_assistant::SendKeystrokeEventsProto>(Arena*);
template<> ::autofill_assistant::SendKeystrokeEventsProto_Result* Arena::CreateMaybeMessage<::autofill_assistant::SendKeystrokeEventsProto_Result>(Arena*);
template<> ::autofill_assistant::SendTapEventProto* Arena::CreateMaybeMessage<::autofill_assistant::SendTapEventProto>(Arena*);
template<> ::autofill_assistant::SetElementAttributeProto* Arena::CreateMaybeMessage<::autofill_assistant::SetElementAttributeProto>(Arena*);
template<> ::autofill_assistant::SetNativeCheckedProto* Arena::CreateMaybeMessage<::autofill_assistant::SetNativeCheckedProto>(Arena*);
template<> ::autofill_assistant::SetNativeValueProto* Arena::CreateMaybeMessage<::autofill_assistant::SetNativeValueProto>(Arena*);
template<> ::autofill_assistant::WaitForDocumentToBecomeCompleteProto* Arena::CreateMaybeMessage<::autofill_assistant::WaitForDocumentToBecomeCompleteProto>(Arena*);
template<> ::autofill_assistant::WaitForDocumentToBecomeInteractiveProto* Arena::CreateMaybeMessage<::autofill_assistant::WaitForDocumentToBecomeInteractiveProto>(Arena*);
template<> ::autofill_assistant::WaitForElementToBecomeStableProto* Arena::CreateMaybeMessage<::autofill_assistant::WaitForElementToBecomeStableProto>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace autofill_assistant {

// ===================================================================

class ClientIdProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.ClientIdProto) */ {
 public:
  inline ClientIdProto() : ClientIdProto(nullptr) {}
  ~ClientIdProto() override;
  explicit PROTOBUF_CONSTEXPR ClientIdProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ClientIdProto(const ClientIdProto& from);
  ClientIdProto(ClientIdProto&& from) noexcept
    : ClientIdProto() {
    *this = ::std::move(from);
  }

  inline ClientIdProto& operator=(const ClientIdProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClientIdProto& operator=(ClientIdProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ClientIdProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const ClientIdProto* internal_default_instance() {
    return reinterpret_cast<const ClientIdProto*>(
               &_ClientIdProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(ClientIdProto& a, ClientIdProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(ClientIdProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClientIdProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ClientIdProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ClientIdProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ClientIdProto& from);
  void MergeFrom(const ClientIdProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ClientIdProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.ClientIdProto";
  }
  protected:
  explicit ClientIdProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdentifierFieldNumber = 1,
  };
  // optional string identifier = 1;
  bool has_identifier() const;
  private:
  bool _internal_has_identifier() const;
  public:
  void clear_identifier();
  const std::string& identifier() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_identifier(ArgT0&& arg0, ArgT... args);
  std::string* mutable_identifier();
  PROTOBUF_NODISCARD std::string* release_identifier();
  void set_allocated_identifier(std::string* identifier);
  private:
  const std::string& _internal_identifier() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_identifier(const std::string& value);
  std::string* _internal_mutable_identifier();
  public:

  // @@protoc_insertion_point(class_scope:autofill_assistant.ClientIdProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr identifier_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fdom_5faction_2eproto;
};
// -------------------------------------------------------------------

class ScrollIntoViewProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.ScrollIntoViewProto) */ {
 public:
  inline ScrollIntoViewProto() : ScrollIntoViewProto(nullptr) {}
  ~ScrollIntoViewProto() override;
  explicit PROTOBUF_CONSTEXPR ScrollIntoViewProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ScrollIntoViewProto(const ScrollIntoViewProto& from);
  ScrollIntoViewProto(ScrollIntoViewProto&& from) noexcept
    : ScrollIntoViewProto() {
    *this = ::std::move(from);
  }

  inline ScrollIntoViewProto& operator=(const ScrollIntoViewProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline ScrollIntoViewProto& operator=(ScrollIntoViewProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ScrollIntoViewProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const ScrollIntoViewProto* internal_default_instance() {
    return reinterpret_cast<const ScrollIntoViewProto*>(
               &_ScrollIntoViewProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ScrollIntoViewProto& a, ScrollIntoViewProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(ScrollIntoViewProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ScrollIntoViewProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ScrollIntoViewProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ScrollIntoViewProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ScrollIntoViewProto& from);
  void MergeFrom(const ScrollIntoViewProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ScrollIntoViewProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.ScrollIntoViewProto";
  }
  protected:
  explicit ScrollIntoViewProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAnimationFieldNumber = 2,
    kVerticalAlignmentFieldNumber = 3,
    kHorizontalAlignmentFieldNumber = 4,
    kClientIdFieldNumber = 1,
  };
  // optional string animation = 2;
  bool has_animation() const;
  private:
  bool _internal_has_animation() const;
  public:
  void clear_animation();
  const std::string& animation() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_animation(ArgT0&& arg0, ArgT... args);
  std::string* mutable_animation();
  PROTOBUF_NODISCARD std::string* release_animation();
  void set_allocated_animation(std::string* animation);
  private:
  const std::string& _internal_animation() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_animation(const std::string& value);
  std::string* _internal_mutable_animation();
  public:

  // optional string vertical_alignment = 3;
  bool has_vertical_alignment() const;
  private:
  bool _internal_has_vertical_alignment() const;
  public:
  void clear_vertical_alignment();
  const std::string& vertical_alignment() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_vertical_alignment(ArgT0&& arg0, ArgT... args);
  std::string* mutable_vertical_alignment();
  PROTOBUF_NODISCARD std::string* release_vertical_alignment();
  void set_allocated_vertical_alignment(std::string* vertical_alignment);
  private:
  const std::string& _internal_vertical_alignment() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_vertical_alignment(const std::string& value);
  std::string* _internal_mutable_vertical_alignment();
  public:

  // optional string horizontal_alignment = 4;
  bool has_horizontal_alignment() const;
  private:
  bool _internal_has_horizontal_alignment() const;
  public:
  void clear_horizontal_alignment();
  const std::string& horizontal_alignment() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_horizontal_alignment(ArgT0&& arg0, ArgT... args);
  std::string* mutable_horizontal_alignment();
  PROTOBUF_NODISCARD std::string* release_horizontal_alignment();
  void set_allocated_horizontal_alignment(std::string* horizontal_alignment);
  private:
  const std::string& _internal_horizontal_alignment() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_horizontal_alignment(const std::string& value);
  std::string* _internal_mutable_horizontal_alignment();
  public:

  // optional .autofill_assistant.ClientIdProto client_id = 1;
  bool has_client_id() const;
  private:
  bool _internal_has_client_id() const;
  public:
  void clear_client_id();
  const ::autofill_assistant::ClientIdProto& client_id() const;
  PROTOBUF_NODISCARD ::autofill_assistant::ClientIdProto* release_client_id();
  ::autofill_assistant::ClientIdProto* mutable_client_id();
  void set_allocated_client_id(::autofill_assistant::ClientIdProto* client_id);
  private:
  const ::autofill_assistant::ClientIdProto& _internal_client_id() const;
  ::autofill_assistant::ClientIdProto* _internal_mutable_client_id();
  public:
  void unsafe_arena_set_allocated_client_id(
      ::autofill_assistant::ClientIdProto* client_id);
  ::autofill_assistant::ClientIdProto* unsafe_arena_release_client_id();

  // @@protoc_insertion_point(class_scope:autofill_assistant.ScrollIntoViewProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr animation_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr vertical_alignment_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr horizontal_alignment_;
  ::autofill_assistant::ClientIdProto* client_id_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fdom_5faction_2eproto;
};
// -------------------------------------------------------------------

class ScrollIntoViewIfNeededProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.ScrollIntoViewIfNeededProto) */ {
 public:
  inline ScrollIntoViewIfNeededProto() : ScrollIntoViewIfNeededProto(nullptr) {}
  ~ScrollIntoViewIfNeededProto() override;
  explicit PROTOBUF_CONSTEXPR ScrollIntoViewIfNeededProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ScrollIntoViewIfNeededProto(const ScrollIntoViewIfNeededProto& from);
  ScrollIntoViewIfNeededProto(ScrollIntoViewIfNeededProto&& from) noexcept
    : ScrollIntoViewIfNeededProto() {
    *this = ::std::move(from);
  }

  inline ScrollIntoViewIfNeededProto& operator=(const ScrollIntoViewIfNeededProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline ScrollIntoViewIfNeededProto& operator=(ScrollIntoViewIfNeededProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ScrollIntoViewIfNeededProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const ScrollIntoViewIfNeededProto* internal_default_instance() {
    return reinterpret_cast<const ScrollIntoViewIfNeededProto*>(
               &_ScrollIntoViewIfNeededProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ScrollIntoViewIfNeededProto& a, ScrollIntoViewIfNeededProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(ScrollIntoViewIfNeededProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ScrollIntoViewIfNeededProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ScrollIntoViewIfNeededProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ScrollIntoViewIfNeededProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ScrollIntoViewIfNeededProto& from);
  void MergeFrom(const ScrollIntoViewIfNeededProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ScrollIntoViewIfNeededProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.ScrollIntoViewIfNeededProto";
  }
  protected:
  explicit ScrollIntoViewIfNeededProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientIdFieldNumber = 1,
    kCenterFieldNumber = 2,
  };
  // optional .autofill_assistant.ClientIdProto client_id = 1;
  bool has_client_id() const;
  private:
  bool _internal_has_client_id() const;
  public:
  void clear_client_id();
  const ::autofill_assistant::ClientIdProto& client_id() const;
  PROTOBUF_NODISCARD ::autofill_assistant::ClientIdProto* release_client_id();
  ::autofill_assistant::ClientIdProto* mutable_client_id();
  void set_allocated_client_id(::autofill_assistant::ClientIdProto* client_id);
  private:
  const ::autofill_assistant::ClientIdProto& _internal_client_id() const;
  ::autofill_assistant::ClientIdProto* _internal_mutable_client_id();
  public:
  void unsafe_arena_set_allocated_client_id(
      ::autofill_assistant::ClientIdProto* client_id);
  ::autofill_assistant::ClientIdProto* unsafe_arena_release_client_id();

  // optional bool center = 2;
  bool has_center() const;
  private:
  bool _internal_has_center() const;
  public:
  void clear_center();
  bool center() const;
  void set_center(bool value);
  private:
  bool _internal_center() const;
  void _internal_set_center(bool value);
  public:

  // @@protoc_insertion_point(class_scope:autofill_assistant.ScrollIntoViewIfNeededProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::autofill_assistant::ClientIdProto* client_id_;
  bool center_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fdom_5faction_2eproto;
};
// -------------------------------------------------------------------

class ScrollDistance final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.ScrollDistance) */ {
 public:
  inline ScrollDistance() : ScrollDistance(nullptr) {}
  ~ScrollDistance() override;
  explicit PROTOBUF_CONSTEXPR ScrollDistance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ScrollDistance(const ScrollDistance& from);
  ScrollDistance(ScrollDistance&& from) noexcept
    : ScrollDistance() {
    *this = ::std::move(from);
  }

  inline ScrollDistance& operator=(const ScrollDistance& from) {
    CopyFrom(from);
    return *this;
  }
  inline ScrollDistance& operator=(ScrollDistance&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ScrollDistance& default_instance() {
    return *internal_default_instance();
  }
  enum ValueCase {
    kPixels = 1,
    kWindowRatio = 2,
    VALUE_NOT_SET = 0,
  };

  static inline const ScrollDistance* internal_default_instance() {
    return reinterpret_cast<const ScrollDistance*>(
               &_ScrollDistance_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ScrollDistance& a, ScrollDistance& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(ScrollDistance* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ScrollDistance* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ScrollDistance* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ScrollDistance>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ScrollDistance& from);
  void MergeFrom(const ScrollDistance& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ScrollDistance* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.ScrollDistance";
  }
  protected:
  explicit ScrollDistance(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPixelsFieldNumber = 1,
    kWindowRatioFieldNumber = 2,
  };
  // int32 pixels = 1;
  bool has_pixels() const;
  private:
  bool _internal_has_pixels() const;
  public:
  void clear_pixels();
  int32_t pixels() const;
  void set_pixels(int32_t value);
  private:
  int32_t _internal_pixels() const;
  void _internal_set_pixels(int32_t value);
  public:

  // float window_ratio = 2;
  bool has_window_ratio() const;
  private:
  bool _internal_has_window_ratio() const;
  public:
  void clear_window_ratio();
  float window_ratio() const;
  void set_window_ratio(float value);
  private:
  float _internal_window_ratio() const;
  void _internal_set_window_ratio(float value);
  public:

  void clear_value();
  ValueCase value_case() const;
  // @@protoc_insertion_point(class_scope:autofill_assistant.ScrollDistance)
 private:
  class _Internal;
  void set_has_pixels();
  void set_has_window_ratio();

  inline bool has_value() const;
  inline void clear_has_value();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union ValueUnion {
    constexpr ValueUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    int32_t pixels_;
    float window_ratio_;
  } value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fdom_5faction_2eproto;
};
// -------------------------------------------------------------------

class ScrollWindowProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.ScrollWindowProto) */ {
 public:
  inline ScrollWindowProto() : ScrollWindowProto(nullptr) {}
  ~ScrollWindowProto() override;
  explicit PROTOBUF_CONSTEXPR ScrollWindowProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ScrollWindowProto(const ScrollWindowProto& from);
  ScrollWindowProto(ScrollWindowProto&& from) noexcept
    : ScrollWindowProto() {
    *this = ::std::move(from);
  }

  inline ScrollWindowProto& operator=(const ScrollWindowProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline ScrollWindowProto& operator=(ScrollWindowProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ScrollWindowProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const ScrollWindowProto* internal_default_instance() {
    return reinterpret_cast<const ScrollWindowProto*>(
               &_ScrollWindowProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ScrollWindowProto& a, ScrollWindowProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(ScrollWindowProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ScrollWindowProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ScrollWindowProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ScrollWindowProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ScrollWindowProto& from);
  void MergeFrom(const ScrollWindowProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ScrollWindowProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.ScrollWindowProto";
  }
  protected:
  explicit ScrollWindowProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAnimationFieldNumber = 3,
    kOptionalFrameIdFieldNumber = 1,
    kScrollDistanceFieldNumber = 2,
  };
  // optional string animation = 3;
  bool has_animation() const;
  private:
  bool _internal_has_animation() const;
  public:
  void clear_animation();
  const std::string& animation() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_animation(ArgT0&& arg0, ArgT... args);
  std::string* mutable_animation();
  PROTOBUF_NODISCARD std::string* release_animation();
  void set_allocated_animation(std::string* animation);
  private:
  const std::string& _internal_animation() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_animation(const std::string& value);
  std::string* _internal_mutable_animation();
  public:

  // optional .autofill_assistant.ClientIdProto optional_frame_id = 1;
  bool has_optional_frame_id() const;
  private:
  bool _internal_has_optional_frame_id() const;
  public:
  void clear_optional_frame_id();
  const ::autofill_assistant::ClientIdProto& optional_frame_id() const;
  PROTOBUF_NODISCARD ::autofill_assistant::ClientIdProto* release_optional_frame_id();
  ::autofill_assistant::ClientIdProto* mutable_optional_frame_id();
  void set_allocated_optional_frame_id(::autofill_assistant::ClientIdProto* optional_frame_id);
  private:
  const ::autofill_assistant::ClientIdProto& _internal_optional_frame_id() const;
  ::autofill_assistant::ClientIdProto* _internal_mutable_optional_frame_id();
  public:
  void unsafe_arena_set_allocated_optional_frame_id(
      ::autofill_assistant::ClientIdProto* optional_frame_id);
  ::autofill_assistant::ClientIdProto* unsafe_arena_release_optional_frame_id();

  // optional .autofill_assistant.ScrollDistance scroll_distance = 2;
  bool has_scroll_distance() const;
  private:
  bool _internal_has_scroll_distance() const;
  public:
  void clear_scroll_distance();
  const ::autofill_assistant::ScrollDistance& scroll_distance() const;
  PROTOBUF_NODISCARD ::autofill_assistant::ScrollDistance* release_scroll_distance();
  ::autofill_assistant::ScrollDistance* mutable_scroll_distance();
  void set_allocated_scroll_distance(::autofill_assistant::ScrollDistance* scroll_distance);
  private:
  const ::autofill_assistant::ScrollDistance& _internal_scroll_distance() const;
  ::autofill_assistant::ScrollDistance* _internal_mutable_scroll_distance();
  public:
  void unsafe_arena_set_allocated_scroll_distance(
      ::autofill_assistant::ScrollDistance* scroll_distance);
  ::autofill_assistant::ScrollDistance* unsafe_arena_release_scroll_distance();

  // @@protoc_insertion_point(class_scope:autofill_assistant.ScrollWindowProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr animation_;
  ::autofill_assistant::ClientIdProto* optional_frame_id_;
  ::autofill_assistant::ScrollDistance* scroll_distance_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fdom_5faction_2eproto;
};
// -------------------------------------------------------------------

class ScrollContainerProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.ScrollContainerProto) */ {
 public:
  inline ScrollContainerProto() : ScrollContainerProto(nullptr) {}
  ~ScrollContainerProto() override;
  explicit PROTOBUF_CONSTEXPR ScrollContainerProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ScrollContainerProto(const ScrollContainerProto& from);
  ScrollContainerProto(ScrollContainerProto&& from) noexcept
    : ScrollContainerProto() {
    *this = ::std::move(from);
  }

  inline ScrollContainerProto& operator=(const ScrollContainerProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline ScrollContainerProto& operator=(ScrollContainerProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ScrollContainerProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const ScrollContainerProto* internal_default_instance() {
    return reinterpret_cast<const ScrollContainerProto*>(
               &_ScrollContainerProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ScrollContainerProto& a, ScrollContainerProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(ScrollContainerProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ScrollContainerProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ScrollContainerProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ScrollContainerProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ScrollContainerProto& from);
  void MergeFrom(const ScrollContainerProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ScrollContainerProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.ScrollContainerProto";
  }
  protected:
  explicit ScrollContainerProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAnimationFieldNumber = 3,
    kClientIdFieldNumber = 1,
    kScrollDistanceFieldNumber = 2,
  };
  // optional string animation = 3;
  bool has_animation() const;
  private:
  bool _internal_has_animation() const;
  public:
  void clear_animation();
  const std::string& animation() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_animation(ArgT0&& arg0, ArgT... args);
  std::string* mutable_animation();
  PROTOBUF_NODISCARD std::string* release_animation();
  void set_allocated_animation(std::string* animation);
  private:
  const std::string& _internal_animation() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_animation(const std::string& value);
  std::string* _internal_mutable_animation();
  public:

  // optional .autofill_assistant.ClientIdProto client_id = 1;
  bool has_client_id() const;
  private:
  bool _internal_has_client_id() const;
  public:
  void clear_client_id();
  const ::autofill_assistant::ClientIdProto& client_id() const;
  PROTOBUF_NODISCARD ::autofill_assistant::ClientIdProto* release_client_id();
  ::autofill_assistant::ClientIdProto* mutable_client_id();
  void set_allocated_client_id(::autofill_assistant::ClientIdProto* client_id);
  private:
  const ::autofill_assistant::ClientIdProto& _internal_client_id() const;
  ::autofill_assistant::ClientIdProto* _internal_mutable_client_id();
  public:
  void unsafe_arena_set_allocated_client_id(
      ::autofill_assistant::ClientIdProto* client_id);
  ::autofill_assistant::ClientIdProto* unsafe_arena_release_client_id();

  // optional .autofill_assistant.ScrollDistance scroll_distance = 2;
  bool has_scroll_distance() const;
  private:
  bool _internal_has_scroll_distance() const;
  public:
  void clear_scroll_distance();
  const ::autofill_assistant::ScrollDistance& scroll_distance() const;
  PROTOBUF_NODISCARD ::autofill_assistant::ScrollDistance* release_scroll_distance();
  ::autofill_assistant::ScrollDistance* mutable_scroll_distance();
  void set_allocated_scroll_distance(::autofill_assistant::ScrollDistance* scroll_distance);
  private:
  const ::autofill_assistant::ScrollDistance& _internal_scroll_distance() const;
  ::autofill_assistant::ScrollDistance* _internal_mutable_scroll_distance();
  public:
  void unsafe_arena_set_allocated_scroll_distance(
      ::autofill_assistant::ScrollDistance* scroll_distance);
  ::autofill_assistant::ScrollDistance* unsafe_arena_release_scroll_distance();

  // @@protoc_insertion_point(class_scope:autofill_assistant.ScrollContainerProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr animation_;
  ::autofill_assistant::ClientIdProto* client_id_;
  ::autofill_assistant::ScrollDistance* scroll_distance_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fdom_5faction_2eproto;
};
// -------------------------------------------------------------------

class WaitForDocumentToBecomeInteractiveProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.WaitForDocumentToBecomeInteractiveProto) */ {
 public:
  inline WaitForDocumentToBecomeInteractiveProto() : WaitForDocumentToBecomeInteractiveProto(nullptr) {}
  ~WaitForDocumentToBecomeInteractiveProto() override;
  explicit PROTOBUF_CONSTEXPR WaitForDocumentToBecomeInteractiveProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WaitForDocumentToBecomeInteractiveProto(const WaitForDocumentToBecomeInteractiveProto& from);
  WaitForDocumentToBecomeInteractiveProto(WaitForDocumentToBecomeInteractiveProto&& from) noexcept
    : WaitForDocumentToBecomeInteractiveProto() {
    *this = ::std::move(from);
  }

  inline WaitForDocumentToBecomeInteractiveProto& operator=(const WaitForDocumentToBecomeInteractiveProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline WaitForDocumentToBecomeInteractiveProto& operator=(WaitForDocumentToBecomeInteractiveProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const WaitForDocumentToBecomeInteractiveProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const WaitForDocumentToBecomeInteractiveProto* internal_default_instance() {
    return reinterpret_cast<const WaitForDocumentToBecomeInteractiveProto*>(
               &_WaitForDocumentToBecomeInteractiveProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(WaitForDocumentToBecomeInteractiveProto& a, WaitForDocumentToBecomeInteractiveProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(WaitForDocumentToBecomeInteractiveProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WaitForDocumentToBecomeInteractiveProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WaitForDocumentToBecomeInteractiveProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WaitForDocumentToBecomeInteractiveProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const WaitForDocumentToBecomeInteractiveProto& from);
  void MergeFrom(const WaitForDocumentToBecomeInteractiveProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(WaitForDocumentToBecomeInteractiveProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.WaitForDocumentToBecomeInteractiveProto";
  }
  protected:
  explicit WaitForDocumentToBecomeInteractiveProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientIdFieldNumber = 1,
    kTimeoutInMsFieldNumber = 2,
  };
  // optional .autofill_assistant.ClientIdProto client_id = 1;
  bool has_client_id() const;
  private:
  bool _internal_has_client_id() const;
  public:
  void clear_client_id();
  const ::autofill_assistant::ClientIdProto& client_id() const;
  PROTOBUF_NODISCARD ::autofill_assistant::ClientIdProto* release_client_id();
  ::autofill_assistant::ClientIdProto* mutable_client_id();
  void set_allocated_client_id(::autofill_assistant::ClientIdProto* client_id);
  private:
  const ::autofill_assistant::ClientIdProto& _internal_client_id() const;
  ::autofill_assistant::ClientIdProto* _internal_mutable_client_id();
  public:
  void unsafe_arena_set_allocated_client_id(
      ::autofill_assistant::ClientIdProto* client_id);
  ::autofill_assistant::ClientIdProto* unsafe_arena_release_client_id();

  // optional int32 timeout_in_ms = 2;
  bool has_timeout_in_ms() const;
  private:
  bool _internal_has_timeout_in_ms() const;
  public:
  void clear_timeout_in_ms();
  int32_t timeout_in_ms() const;
  void set_timeout_in_ms(int32_t value);
  private:
  int32_t _internal_timeout_in_ms() const;
  void _internal_set_timeout_in_ms(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:autofill_assistant.WaitForDocumentToBecomeInteractiveProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::autofill_assistant::ClientIdProto* client_id_;
  int32_t timeout_in_ms_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fdom_5faction_2eproto;
};
// -------------------------------------------------------------------

class WaitForDocumentToBecomeCompleteProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.WaitForDocumentToBecomeCompleteProto) */ {
 public:
  inline WaitForDocumentToBecomeCompleteProto() : WaitForDocumentToBecomeCompleteProto(nullptr) {}
  ~WaitForDocumentToBecomeCompleteProto() override;
  explicit PROTOBUF_CONSTEXPR WaitForDocumentToBecomeCompleteProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WaitForDocumentToBecomeCompleteProto(const WaitForDocumentToBecomeCompleteProto& from);
  WaitForDocumentToBecomeCompleteProto(WaitForDocumentToBecomeCompleteProto&& from) noexcept
    : WaitForDocumentToBecomeCompleteProto() {
    *this = ::std::move(from);
  }

  inline WaitForDocumentToBecomeCompleteProto& operator=(const WaitForDocumentToBecomeCompleteProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline WaitForDocumentToBecomeCompleteProto& operator=(WaitForDocumentToBecomeCompleteProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const WaitForDocumentToBecomeCompleteProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const WaitForDocumentToBecomeCompleteProto* internal_default_instance() {
    return reinterpret_cast<const WaitForDocumentToBecomeCompleteProto*>(
               &_WaitForDocumentToBecomeCompleteProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(WaitForDocumentToBecomeCompleteProto& a, WaitForDocumentToBecomeCompleteProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(WaitForDocumentToBecomeCompleteProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WaitForDocumentToBecomeCompleteProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WaitForDocumentToBecomeCompleteProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WaitForDocumentToBecomeCompleteProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const WaitForDocumentToBecomeCompleteProto& from);
  void MergeFrom(const WaitForDocumentToBecomeCompleteProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(WaitForDocumentToBecomeCompleteProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.WaitForDocumentToBecomeCompleteProto";
  }
  protected:
  explicit WaitForDocumentToBecomeCompleteProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientIdFieldNumber = 1,
    kTimeoutInMsFieldNumber = 2,
  };
  // optional .autofill_assistant.ClientIdProto client_id = 1;
  bool has_client_id() const;
  private:
  bool _internal_has_client_id() const;
  public:
  void clear_client_id();
  const ::autofill_assistant::ClientIdProto& client_id() const;
  PROTOBUF_NODISCARD ::autofill_assistant::ClientIdProto* release_client_id();
  ::autofill_assistant::ClientIdProto* mutable_client_id();
  void set_allocated_client_id(::autofill_assistant::ClientIdProto* client_id);
  private:
  const ::autofill_assistant::ClientIdProto& _internal_client_id() const;
  ::autofill_assistant::ClientIdProto* _internal_mutable_client_id();
  public:
  void unsafe_arena_set_allocated_client_id(
      ::autofill_assistant::ClientIdProto* client_id);
  ::autofill_assistant::ClientIdProto* unsafe_arena_release_client_id();

  // optional int32 timeout_in_ms = 2;
  bool has_timeout_in_ms() const;
  private:
  bool _internal_has_timeout_in_ms() const;
  public:
  void clear_timeout_in_ms();
  int32_t timeout_in_ms() const;
  void set_timeout_in_ms(int32_t value);
  private:
  int32_t _internal_timeout_in_ms() const;
  void _internal_set_timeout_in_ms(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:autofill_assistant.WaitForDocumentToBecomeCompleteProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::autofill_assistant::ClientIdProto* client_id_;
  int32_t timeout_in_ms_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fdom_5faction_2eproto;
};
// -------------------------------------------------------------------

class WaitForElementToBecomeStableProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.WaitForElementToBecomeStableProto) */ {
 public:
  inline WaitForElementToBecomeStableProto() : WaitForElementToBecomeStableProto(nullptr) {}
  ~WaitForElementToBecomeStableProto() override;
  explicit PROTOBUF_CONSTEXPR WaitForElementToBecomeStableProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WaitForElementToBecomeStableProto(const WaitForElementToBecomeStableProto& from);
  WaitForElementToBecomeStableProto(WaitForElementToBecomeStableProto&& from) noexcept
    : WaitForElementToBecomeStableProto() {
    *this = ::std::move(from);
  }

  inline WaitForElementToBecomeStableProto& operator=(const WaitForElementToBecomeStableProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline WaitForElementToBecomeStableProto& operator=(WaitForElementToBecomeStableProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const WaitForElementToBecomeStableProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const WaitForElementToBecomeStableProto* internal_default_instance() {
    return reinterpret_cast<const WaitForElementToBecomeStableProto*>(
               &_WaitForElementToBecomeStableProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(WaitForElementToBecomeStableProto& a, WaitForElementToBecomeStableProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(WaitForElementToBecomeStableProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WaitForElementToBecomeStableProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WaitForElementToBecomeStableProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WaitForElementToBecomeStableProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const WaitForElementToBecomeStableProto& from);
  void MergeFrom(const WaitForElementToBecomeStableProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(WaitForElementToBecomeStableProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.WaitForElementToBecomeStableProto";
  }
  protected:
  explicit WaitForElementToBecomeStableProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientIdFieldNumber = 1,
    kStableCheckMaxRoundsFieldNumber = 2,
    kStableCheckIntervalMsFieldNumber = 3,
  };
  // optional .autofill_assistant.ClientIdProto client_id = 1;
  bool has_client_id() const;
  private:
  bool _internal_has_client_id() const;
  public:
  void clear_client_id();
  const ::autofill_assistant::ClientIdProto& client_id() const;
  PROTOBUF_NODISCARD ::autofill_assistant::ClientIdProto* release_client_id();
  ::autofill_assistant::ClientIdProto* mutable_client_id();
  void set_allocated_client_id(::autofill_assistant::ClientIdProto* client_id);
  private:
  const ::autofill_assistant::ClientIdProto& _internal_client_id() const;
  ::autofill_assistant::ClientIdProto* _internal_mutable_client_id();
  public:
  void unsafe_arena_set_allocated_client_id(
      ::autofill_assistant::ClientIdProto* client_id);
  ::autofill_assistant::ClientIdProto* unsafe_arena_release_client_id();

  // optional int32 stable_check_max_rounds = 2 [default = 50];
  bool has_stable_check_max_rounds() const;
  private:
  bool _internal_has_stable_check_max_rounds() const;
  public:
  void clear_stable_check_max_rounds();
  int32_t stable_check_max_rounds() const;
  void set_stable_check_max_rounds(int32_t value);
  private:
  int32_t _internal_stable_check_max_rounds() const;
  void _internal_set_stable_check_max_rounds(int32_t value);
  public:

  // optional int32 stable_check_interval_ms = 3 [default = 200];
  bool has_stable_check_interval_ms() const;
  private:
  bool _internal_has_stable_check_interval_ms() const;
  public:
  void clear_stable_check_interval_ms();
  int32_t stable_check_interval_ms() const;
  void set_stable_check_interval_ms(int32_t value);
  private:
  int32_t _internal_stable_check_interval_ms() const;
  void _internal_set_stable_check_interval_ms(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:autofill_assistant.WaitForElementToBecomeStableProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::autofill_assistant::ClientIdProto* client_id_;
  int32_t stable_check_max_rounds_;
  int32_t stable_check_interval_ms_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fdom_5faction_2eproto;
};
// -------------------------------------------------------------------

class CheckElementIsOnTopProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.CheckElementIsOnTopProto) */ {
 public:
  inline CheckElementIsOnTopProto() : CheckElementIsOnTopProto(nullptr) {}
  ~CheckElementIsOnTopProto() override;
  explicit PROTOBUF_CONSTEXPR CheckElementIsOnTopProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CheckElementIsOnTopProto(const CheckElementIsOnTopProto& from);
  CheckElementIsOnTopProto(CheckElementIsOnTopProto&& from) noexcept
    : CheckElementIsOnTopProto() {
    *this = ::std::move(from);
  }

  inline CheckElementIsOnTopProto& operator=(const CheckElementIsOnTopProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline CheckElementIsOnTopProto& operator=(CheckElementIsOnTopProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CheckElementIsOnTopProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const CheckElementIsOnTopProto* internal_default_instance() {
    return reinterpret_cast<const CheckElementIsOnTopProto*>(
               &_CheckElementIsOnTopProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(CheckElementIsOnTopProto& a, CheckElementIsOnTopProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(CheckElementIsOnTopProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CheckElementIsOnTopProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CheckElementIsOnTopProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CheckElementIsOnTopProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const CheckElementIsOnTopProto& from);
  void MergeFrom(const CheckElementIsOnTopProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CheckElementIsOnTopProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.CheckElementIsOnTopProto";
  }
  protected:
  explicit CheckElementIsOnTopProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientIdFieldNumber = 1,
  };
  // optional .autofill_assistant.ClientIdProto client_id = 1;
  bool has_client_id() const;
  private:
  bool _internal_has_client_id() const;
  public:
  void clear_client_id();
  const ::autofill_assistant::ClientIdProto& client_id() const;
  PROTOBUF_NODISCARD ::autofill_assistant::ClientIdProto* release_client_id();
  ::autofill_assistant::ClientIdProto* mutable_client_id();
  void set_allocated_client_id(::autofill_assistant::ClientIdProto* client_id);
  private:
  const ::autofill_assistant::ClientIdProto& _internal_client_id() const;
  ::autofill_assistant::ClientIdProto* _internal_mutable_client_id();
  public:
  void unsafe_arena_set_allocated_client_id(
      ::autofill_assistant::ClientIdProto* client_id);
  ::autofill_assistant::ClientIdProto* unsafe_arena_release_client_id();

  // @@protoc_insertion_point(class_scope:autofill_assistant.CheckElementIsOnTopProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::autofill_assistant::ClientIdProto* client_id_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fdom_5faction_2eproto;
};
// -------------------------------------------------------------------

class SendClickEventProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.SendClickEventProto) */ {
 public:
  inline SendClickEventProto() : SendClickEventProto(nullptr) {}
  ~SendClickEventProto() override;
  explicit PROTOBUF_CONSTEXPR SendClickEventProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SendClickEventProto(const SendClickEventProto& from);
  SendClickEventProto(SendClickEventProto&& from) noexcept
    : SendClickEventProto() {
    *this = ::std::move(from);
  }

  inline SendClickEventProto& operator=(const SendClickEventProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline SendClickEventProto& operator=(SendClickEventProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const SendClickEventProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const SendClickEventProto* internal_default_instance() {
    return reinterpret_cast<const SendClickEventProto*>(
               &_SendClickEventProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(SendClickEventProto& a, SendClickEventProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(SendClickEventProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SendClickEventProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SendClickEventProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SendClickEventProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const SendClickEventProto& from);
  void MergeFrom(const SendClickEventProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SendClickEventProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.SendClickEventProto";
  }
  protected:
  explicit SendClickEventProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientIdFieldNumber = 1,
  };
  // optional .autofill_assistant.ClientIdProto client_id = 1;
  bool has_client_id() const;
  private:
  bool _internal_has_client_id() const;
  public:
  void clear_client_id();
  const ::autofill_assistant::ClientIdProto& client_id() const;
  PROTOBUF_NODISCARD ::autofill_assistant::ClientIdProto* release_client_id();
  ::autofill_assistant::ClientIdProto* mutable_client_id();
  void set_allocated_client_id(::autofill_assistant::ClientIdProto* client_id);
  private:
  const ::autofill_assistant::ClientIdProto& _internal_client_id() const;
  ::autofill_assistant::ClientIdProto* _internal_mutable_client_id();
  public:
  void unsafe_arena_set_allocated_client_id(
      ::autofill_assistant::ClientIdProto* client_id);
  ::autofill_assistant::ClientIdProto* unsafe_arena_release_client_id();

  // @@protoc_insertion_point(class_scope:autofill_assistant.SendClickEventProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::autofill_assistant::ClientIdProto* client_id_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fdom_5faction_2eproto;
};
// -------------------------------------------------------------------

class SendTapEventProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.SendTapEventProto) */ {
 public:
  inline SendTapEventProto() : SendTapEventProto(nullptr) {}
  ~SendTapEventProto() override;
  explicit PROTOBUF_CONSTEXPR SendTapEventProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SendTapEventProto(const SendTapEventProto& from);
  SendTapEventProto(SendTapEventProto&& from) noexcept
    : SendTapEventProto() {
    *this = ::std::move(from);
  }

  inline SendTapEventProto& operator=(const SendTapEventProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline SendTapEventProto& operator=(SendTapEventProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const SendTapEventProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const SendTapEventProto* internal_default_instance() {
    return reinterpret_cast<const SendTapEventProto*>(
               &_SendTapEventProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(SendTapEventProto& a, SendTapEventProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(SendTapEventProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SendTapEventProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SendTapEventProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SendTapEventProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const SendTapEventProto& from);
  void MergeFrom(const SendTapEventProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SendTapEventProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.SendTapEventProto";
  }
  protected:
  explicit SendTapEventProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientIdFieldNumber = 1,
  };
  // optional .autofill_assistant.ClientIdProto client_id = 1;
  bool has_client_id() const;
  private:
  bool _internal_has_client_id() const;
  public:
  void clear_client_id();
  const ::autofill_assistant::ClientIdProto& client_id() const;
  PROTOBUF_NODISCARD ::autofill_assistant::ClientIdProto* release_client_id();
  ::autofill_assistant::ClientIdProto* mutable_client_id();
  void set_allocated_client_id(::autofill_assistant::ClientIdProto* client_id);
  private:
  const ::autofill_assistant::ClientIdProto& _internal_client_id() const;
  ::autofill_assistant::ClientIdProto* _internal_mutable_client_id();
  public:
  void unsafe_arena_set_allocated_client_id(
      ::autofill_assistant::ClientIdProto* client_id);
  ::autofill_assistant::ClientIdProto* unsafe_arena_release_client_id();

  // @@protoc_insertion_point(class_scope:autofill_assistant.SendTapEventProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::autofill_assistant::ClientIdProto* client_id_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fdom_5faction_2eproto;
};
// -------------------------------------------------------------------

class JsClickProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.JsClickProto) */ {
 public:
  inline JsClickProto() : JsClickProto(nullptr) {}
  ~JsClickProto() override;
  explicit PROTOBUF_CONSTEXPR JsClickProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  JsClickProto(const JsClickProto& from);
  JsClickProto(JsClickProto&& from) noexcept
    : JsClickProto() {
    *this = ::std::move(from);
  }

  inline JsClickProto& operator=(const JsClickProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline JsClickProto& operator=(JsClickProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const JsClickProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const JsClickProto* internal_default_instance() {
    return reinterpret_cast<const JsClickProto*>(
               &_JsClickProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(JsClickProto& a, JsClickProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(JsClickProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(JsClickProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  JsClickProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<JsClickProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const JsClickProto& from);
  void MergeFrom(const JsClickProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(JsClickProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.JsClickProto";
  }
  protected:
  explicit JsClickProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientIdFieldNumber = 1,
  };
  // optional .autofill_assistant.ClientIdProto client_id = 1;
  bool has_client_id() const;
  private:
  bool _internal_has_client_id() const;
  public:
  void clear_client_id();
  const ::autofill_assistant::ClientIdProto& client_id() const;
  PROTOBUF_NODISCARD ::autofill_assistant::ClientIdProto* release_client_id();
  ::autofill_assistant::ClientIdProto* mutable_client_id();
  void set_allocated_client_id(::autofill_assistant::ClientIdProto* client_id);
  private:
  const ::autofill_assistant::ClientIdProto& _internal_client_id() const;
  ::autofill_assistant::ClientIdProto* _internal_mutable_client_id();
  public:
  void unsafe_arena_set_allocated_client_id(
      ::autofill_assistant::ClientIdProto* client_id);
  ::autofill_assistant::ClientIdProto* unsafe_arena_release_client_id();

  // @@protoc_insertion_point(class_scope:autofill_assistant.JsClickProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::autofill_assistant::ClientIdProto* client_id_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fdom_5faction_2eproto;
};
// -------------------------------------------------------------------

class SendKeystrokeEventsProto_Result final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.SendKeystrokeEventsProto.Result) */ {
 public:
  inline SendKeystrokeEventsProto_Result() : SendKeystrokeEventsProto_Result(nullptr) {}
  ~SendKeystrokeEventsProto_Result() override;
  explicit PROTOBUF_CONSTEXPR SendKeystrokeEventsProto_Result(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SendKeystrokeEventsProto_Result(const SendKeystrokeEventsProto_Result& from);
  SendKeystrokeEventsProto_Result(SendKeystrokeEventsProto_Result&& from) noexcept
    : SendKeystrokeEventsProto_Result() {
    *this = ::std::move(from);
  }

  inline SendKeystrokeEventsProto_Result& operator=(const SendKeystrokeEventsProto_Result& from) {
    CopyFrom(from);
    return *this;
  }
  inline SendKeystrokeEventsProto_Result& operator=(SendKeystrokeEventsProto_Result&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const SendKeystrokeEventsProto_Result& default_instance() {
    return *internal_default_instance();
  }
  static inline const SendKeystrokeEventsProto_Result* internal_default_instance() {
    return reinterpret_cast<const SendKeystrokeEventsProto_Result*>(
               &_SendKeystrokeEventsProto_Result_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(SendKeystrokeEventsProto_Result& a, SendKeystrokeEventsProto_Result& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(SendKeystrokeEventsProto_Result* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SendKeystrokeEventsProto_Result* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SendKeystrokeEventsProto_Result* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SendKeystrokeEventsProto_Result>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const SendKeystrokeEventsProto_Result& from);
  void MergeFrom(const SendKeystrokeEventsProto_Result& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SendKeystrokeEventsProto_Result* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.SendKeystrokeEventsProto.Result";
  }
  protected:
  explicit SendKeystrokeEventsProto_Result(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMonthsSincePasswordLastUsedFieldNumber = 1,
  };
  // optional int32 months_since_password_last_used = 1;
  bool has_months_since_password_last_used() const;
  private:
  bool _internal_has_months_since_password_last_used() const;
  public:
  void clear_months_since_password_last_used();
  int32_t months_since_password_last_used() const;
  void set_months_since_password_last_used(int32_t value);
  private:
  int32_t _internal_months_since_password_last_used() const;
  void _internal_set_months_since_password_last_used(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:autofill_assistant.SendKeystrokeEventsProto.Result)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int32_t months_since_password_last_used_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fdom_5faction_2eproto;
};
// -------------------------------------------------------------------

class SendKeystrokeEventsProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.SendKeystrokeEventsProto) */ {
 public:
  inline SendKeystrokeEventsProto() : SendKeystrokeEventsProto(nullptr) {}
  ~SendKeystrokeEventsProto() override;
  explicit PROTOBUF_CONSTEXPR SendKeystrokeEventsProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SendKeystrokeEventsProto(const SendKeystrokeEventsProto& from);
  SendKeystrokeEventsProto(SendKeystrokeEventsProto&& from) noexcept
    : SendKeystrokeEventsProto() {
    *this = ::std::move(from);
  }

  inline SendKeystrokeEventsProto& operator=(const SendKeystrokeEventsProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline SendKeystrokeEventsProto& operator=(SendKeystrokeEventsProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const SendKeystrokeEventsProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const SendKeystrokeEventsProto* internal_default_instance() {
    return reinterpret_cast<const SendKeystrokeEventsProto*>(
               &_SendKeystrokeEventsProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(SendKeystrokeEventsProto& a, SendKeystrokeEventsProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(SendKeystrokeEventsProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SendKeystrokeEventsProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SendKeystrokeEventsProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SendKeystrokeEventsProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const SendKeystrokeEventsProto& from);
  void MergeFrom(const SendKeystrokeEventsProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SendKeystrokeEventsProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.SendKeystrokeEventsProto";
  }
  protected:
  explicit SendKeystrokeEventsProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef SendKeystrokeEventsProto_Result Result;

  // accessors -------------------------------------------------------

  enum : int {
    kClientIdFieldNumber = 1,
    kValueFieldNumber = 2,
    kDelayInMsFieldNumber = 3,
  };
  // optional .autofill_assistant.ClientIdProto client_id = 1;
  bool has_client_id() const;
  private:
  bool _internal_has_client_id() const;
  public:
  void clear_client_id();
  const ::autofill_assistant::ClientIdProto& client_id() const;
  PROTOBUF_NODISCARD ::autofill_assistant::ClientIdProto* release_client_id();
  ::autofill_assistant::ClientIdProto* mutable_client_id();
  void set_allocated_client_id(::autofill_assistant::ClientIdProto* client_id);
  private:
  const ::autofill_assistant::ClientIdProto& _internal_client_id() const;
  ::autofill_assistant::ClientIdProto* _internal_mutable_client_id();
  public:
  void unsafe_arena_set_allocated_client_id(
      ::autofill_assistant::ClientIdProto* client_id);
  ::autofill_assistant::ClientIdProto* unsafe_arena_release_client_id();

  // optional .autofill_assistant.TextValue value = 2;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  const ::autofill_assistant::TextValue& value() const;
  PROTOBUF_NODISCARD ::autofill_assistant::TextValue* release_value();
  ::autofill_assistant::TextValue* mutable_value();
  void set_allocated_value(::autofill_assistant::TextValue* value);
  private:
  const ::autofill_assistant::TextValue& _internal_value() const;
  ::autofill_assistant::TextValue* _internal_mutable_value();
  public:
  void unsafe_arena_set_allocated_value(
      ::autofill_assistant::TextValue* value);
  ::autofill_assistant::TextValue* unsafe_arena_release_value();

  // optional int32 delay_in_ms = 3;
  bool has_delay_in_ms() const;
  private:
  bool _internal_has_delay_in_ms() const;
  public:
  void clear_delay_in_ms();
  int32_t delay_in_ms() const;
  void set_delay_in_ms(int32_t value);
  private:
  int32_t _internal_delay_in_ms() const;
  void _internal_set_delay_in_ms(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:autofill_assistant.SendKeystrokeEventsProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::autofill_assistant::ClientIdProto* client_id_;
  ::autofill_assistant::TextValue* value_;
  int32_t delay_in_ms_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fdom_5faction_2eproto;
};
// -------------------------------------------------------------------

class SendKeyEventProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.SendKeyEventProto) */ {
 public:
  inline SendKeyEventProto() : SendKeyEventProto(nullptr) {}
  ~SendKeyEventProto() override;
  explicit PROTOBUF_CONSTEXPR SendKeyEventProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SendKeyEventProto(const SendKeyEventProto& from);
  SendKeyEventProto(SendKeyEventProto&& from) noexcept
    : SendKeyEventProto() {
    *this = ::std::move(from);
  }

  inline SendKeyEventProto& operator=(const SendKeyEventProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline SendKeyEventProto& operator=(SendKeyEventProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const SendKeyEventProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const SendKeyEventProto* internal_default_instance() {
    return reinterpret_cast<const SendKeyEventProto*>(
               &_SendKeyEventProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(SendKeyEventProto& a, SendKeyEventProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(SendKeyEventProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SendKeyEventProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SendKeyEventProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SendKeyEventProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const SendKeyEventProto& from);
  void MergeFrom(const SendKeyEventProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SendKeyEventProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.SendKeyEventProto";
  }
  protected:
  explicit SendKeyEventProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientIdFieldNumber = 1,
    kKeyEventFieldNumber = 2,
  };
  // optional .autofill_assistant.ClientIdProto client_id = 1;
  bool has_client_id() const;
  private:
  bool _internal_has_client_id() const;
  public:
  void clear_client_id();
  const ::autofill_assistant::ClientIdProto& client_id() const;
  PROTOBUF_NODISCARD ::autofill_assistant::ClientIdProto* release_client_id();
  ::autofill_assistant::ClientIdProto* mutable_client_id();
  void set_allocated_client_id(::autofill_assistant::ClientIdProto* client_id);
  private:
  const ::autofill_assistant::ClientIdProto& _internal_client_id() const;
  ::autofill_assistant::ClientIdProto* _internal_mutable_client_id();
  public:
  void unsafe_arena_set_allocated_client_id(
      ::autofill_assistant::ClientIdProto* client_id);
  ::autofill_assistant::ClientIdProto* unsafe_arena_release_client_id();

  // optional .autofill_assistant.KeyEvent key_event = 2;
  bool has_key_event() const;
  private:
  bool _internal_has_key_event() const;
  public:
  void clear_key_event();
  const ::autofill_assistant::KeyEvent& key_event() const;
  PROTOBUF_NODISCARD ::autofill_assistant::KeyEvent* release_key_event();
  ::autofill_assistant::KeyEvent* mutable_key_event();
  void set_allocated_key_event(::autofill_assistant::KeyEvent* key_event);
  private:
  const ::autofill_assistant::KeyEvent& _internal_key_event() const;
  ::autofill_assistant::KeyEvent* _internal_mutable_key_event();
  public:
  void unsafe_arena_set_allocated_key_event(
      ::autofill_assistant::KeyEvent* key_event);
  ::autofill_assistant::KeyEvent* unsafe_arena_release_key_event();

  // @@protoc_insertion_point(class_scope:autofill_assistant.SendKeyEventProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::autofill_assistant::ClientIdProto* client_id_;
  ::autofill_assistant::KeyEvent* key_event_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fdom_5faction_2eproto;
};
// -------------------------------------------------------------------

class SendChangeEventProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.SendChangeEventProto) */ {
 public:
  inline SendChangeEventProto() : SendChangeEventProto(nullptr) {}
  ~SendChangeEventProto() override;
  explicit PROTOBUF_CONSTEXPR SendChangeEventProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SendChangeEventProto(const SendChangeEventProto& from);
  SendChangeEventProto(SendChangeEventProto&& from) noexcept
    : SendChangeEventProto() {
    *this = ::std::move(from);
  }

  inline SendChangeEventProto& operator=(const SendChangeEventProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline SendChangeEventProto& operator=(SendChangeEventProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const SendChangeEventProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const SendChangeEventProto* internal_default_instance() {
    return reinterpret_cast<const SendChangeEventProto*>(
               &_SendChangeEventProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(SendChangeEventProto& a, SendChangeEventProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(SendChangeEventProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SendChangeEventProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SendChangeEventProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SendChangeEventProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const SendChangeEventProto& from);
  void MergeFrom(const SendChangeEventProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SendChangeEventProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.SendChangeEventProto";
  }
  protected:
  explicit SendChangeEventProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientIdFieldNumber = 1,
  };
  // optional .autofill_assistant.ClientIdProto client_id = 1;
  bool has_client_id() const;
  private:
  bool _internal_has_client_id() const;
  public:
  void clear_client_id();
  const ::autofill_assistant::ClientIdProto& client_id() const;
  PROTOBUF_NODISCARD ::autofill_assistant::ClientIdProto* release_client_id();
  ::autofill_assistant::ClientIdProto* mutable_client_id();
  void set_allocated_client_id(::autofill_assistant::ClientIdProto* client_id);
  private:
  const ::autofill_assistant::ClientIdProto& _internal_client_id() const;
  ::autofill_assistant::ClientIdProto* _internal_mutable_client_id();
  public:
  void unsafe_arena_set_allocated_client_id(
      ::autofill_assistant::ClientIdProto* client_id);
  ::autofill_assistant::ClientIdProto* unsafe_arena_release_client_id();

  // @@protoc_insertion_point(class_scope:autofill_assistant.SendChangeEventProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::autofill_assistant::ClientIdProto* client_id_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fdom_5faction_2eproto;
};
// -------------------------------------------------------------------

class SetElementAttributeProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.SetElementAttributeProto) */ {
 public:
  inline SetElementAttributeProto() : SetElementAttributeProto(nullptr) {}
  ~SetElementAttributeProto() override;
  explicit PROTOBUF_CONSTEXPR SetElementAttributeProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetElementAttributeProto(const SetElementAttributeProto& from);
  SetElementAttributeProto(SetElementAttributeProto&& from) noexcept
    : SetElementAttributeProto() {
    *this = ::std::move(from);
  }

  inline SetElementAttributeProto& operator=(const SetElementAttributeProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetElementAttributeProto& operator=(SetElementAttributeProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const SetElementAttributeProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetElementAttributeProto* internal_default_instance() {
    return reinterpret_cast<const SetElementAttributeProto*>(
               &_SetElementAttributeProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(SetElementAttributeProto& a, SetElementAttributeProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(SetElementAttributeProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetElementAttributeProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetElementAttributeProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetElementAttributeProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const SetElementAttributeProto& from);
  void MergeFrom(const SetElementAttributeProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SetElementAttributeProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.SetElementAttributeProto";
  }
  protected:
  explicit SetElementAttributeProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAttributeFieldNumber = 2,
    kClientIdFieldNumber = 1,
    kValueFieldNumber = 3,
  };
  // repeated string attribute = 2;
  int attribute_size() const;
  private:
  int _internal_attribute_size() const;
  public:
  void clear_attribute();
  const std::string& attribute(int index) const;
  std::string* mutable_attribute(int index);
  void set_attribute(int index, const std::string& value);
  void set_attribute(int index, std::string&& value);
  void set_attribute(int index, const char* value);
  void set_attribute(int index, const char* value, size_t size);
  std::string* add_attribute();
  void add_attribute(const std::string& value);
  void add_attribute(std::string&& value);
  void add_attribute(const char* value);
  void add_attribute(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& attribute() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_attribute();
  private:
  const std::string& _internal_attribute(int index) const;
  std::string* _internal_add_attribute();
  public:

  // optional .autofill_assistant.ClientIdProto client_id = 1;
  bool has_client_id() const;
  private:
  bool _internal_has_client_id() const;
  public:
  void clear_client_id();
  const ::autofill_assistant::ClientIdProto& client_id() const;
  PROTOBUF_NODISCARD ::autofill_assistant::ClientIdProto* release_client_id();
  ::autofill_assistant::ClientIdProto* mutable_client_id();
  void set_allocated_client_id(::autofill_assistant::ClientIdProto* client_id);
  private:
  const ::autofill_assistant::ClientIdProto& _internal_client_id() const;
  ::autofill_assistant::ClientIdProto* _internal_mutable_client_id();
  public:
  void unsafe_arena_set_allocated_client_id(
      ::autofill_assistant::ClientIdProto* client_id);
  ::autofill_assistant::ClientIdProto* unsafe_arena_release_client_id();

  // optional .autofill_assistant.TextValue value = 3;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  const ::autofill_assistant::TextValue& value() const;
  PROTOBUF_NODISCARD ::autofill_assistant::TextValue* release_value();
  ::autofill_assistant::TextValue* mutable_value();
  void set_allocated_value(::autofill_assistant::TextValue* value);
  private:
  const ::autofill_assistant::TextValue& _internal_value() const;
  ::autofill_assistant::TextValue* _internal_mutable_value();
  public:
  void unsafe_arena_set_allocated_value(
      ::autofill_assistant::TextValue* value);
  ::autofill_assistant::TextValue* unsafe_arena_release_value();

  // @@protoc_insertion_point(class_scope:autofill_assistant.SetElementAttributeProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> attribute_;
  ::autofill_assistant::ClientIdProto* client_id_;
  ::autofill_assistant::TextValue* value_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fdom_5faction_2eproto;
};
// -------------------------------------------------------------------

class SelectFieldValueProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.SelectFieldValueProto) */ {
 public:
  inline SelectFieldValueProto() : SelectFieldValueProto(nullptr) {}
  ~SelectFieldValueProto() override;
  explicit PROTOBUF_CONSTEXPR SelectFieldValueProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SelectFieldValueProto(const SelectFieldValueProto& from);
  SelectFieldValueProto(SelectFieldValueProto&& from) noexcept
    : SelectFieldValueProto() {
    *this = ::std::move(from);
  }

  inline SelectFieldValueProto& operator=(const SelectFieldValueProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline SelectFieldValueProto& operator=(SelectFieldValueProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const SelectFieldValueProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const SelectFieldValueProto* internal_default_instance() {
    return reinterpret_cast<const SelectFieldValueProto*>(
               &_SelectFieldValueProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(SelectFieldValueProto& a, SelectFieldValueProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(SelectFieldValueProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SelectFieldValueProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SelectFieldValueProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SelectFieldValueProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const SelectFieldValueProto& from);
  void MergeFrom(const SelectFieldValueProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SelectFieldValueProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.SelectFieldValueProto";
  }
  protected:
  explicit SelectFieldValueProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientIdFieldNumber = 1,
  };
  // optional .autofill_assistant.ClientIdProto client_id = 1;
  bool has_client_id() const;
  private:
  bool _internal_has_client_id() const;
  public:
  void clear_client_id();
  const ::autofill_assistant::ClientIdProto& client_id() const;
  PROTOBUF_NODISCARD ::autofill_assistant::ClientIdProto* release_client_id();
  ::autofill_assistant::ClientIdProto* mutable_client_id();
  void set_allocated_client_id(::autofill_assistant::ClientIdProto* client_id);
  private:
  const ::autofill_assistant::ClientIdProto& _internal_client_id() const;
  ::autofill_assistant::ClientIdProto* _internal_mutable_client_id();
  public:
  void unsafe_arena_set_allocated_client_id(
      ::autofill_assistant::ClientIdProto* client_id);
  ::autofill_assistant::ClientIdProto* unsafe_arena_release_client_id();

  // @@protoc_insertion_point(class_scope:autofill_assistant.SelectFieldValueProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::autofill_assistant::ClientIdProto* client_id_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fdom_5faction_2eproto;
};
// -------------------------------------------------------------------

class FocusFieldProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.FocusFieldProto) */ {
 public:
  inline FocusFieldProto() : FocusFieldProto(nullptr) {}
  ~FocusFieldProto() override;
  explicit PROTOBUF_CONSTEXPR FocusFieldProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FocusFieldProto(const FocusFieldProto& from);
  FocusFieldProto(FocusFieldProto&& from) noexcept
    : FocusFieldProto() {
    *this = ::std::move(from);
  }

  inline FocusFieldProto& operator=(const FocusFieldProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline FocusFieldProto& operator=(FocusFieldProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const FocusFieldProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const FocusFieldProto* internal_default_instance() {
    return reinterpret_cast<const FocusFieldProto*>(
               &_FocusFieldProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(FocusFieldProto& a, FocusFieldProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(FocusFieldProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FocusFieldProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FocusFieldProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FocusFieldProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const FocusFieldProto& from);
  void MergeFrom(const FocusFieldProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(FocusFieldProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.FocusFieldProto";
  }
  protected:
  explicit FocusFieldProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientIdFieldNumber = 1,
  };
  // optional .autofill_assistant.ClientIdProto client_id = 1;
  bool has_client_id() const;
  private:
  bool _internal_has_client_id() const;
  public:
  void clear_client_id();
  const ::autofill_assistant::ClientIdProto& client_id() const;
  PROTOBUF_NODISCARD ::autofill_assistant::ClientIdProto* release_client_id();
  ::autofill_assistant::ClientIdProto* mutable_client_id();
  void set_allocated_client_id(::autofill_assistant::ClientIdProto* client_id);
  private:
  const ::autofill_assistant::ClientIdProto& _internal_client_id() const;
  ::autofill_assistant::ClientIdProto* _internal_mutable_client_id();
  public:
  void unsafe_arena_set_allocated_client_id(
      ::autofill_assistant::ClientIdProto* client_id);
  ::autofill_assistant::ClientIdProto* unsafe_arena_release_client_id();

  // @@protoc_insertion_point(class_scope:autofill_assistant.FocusFieldProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::autofill_assistant::ClientIdProto* client_id_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fdom_5faction_2eproto;
};
// -------------------------------------------------------------------

class BlurFieldProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.BlurFieldProto) */ {
 public:
  inline BlurFieldProto() : BlurFieldProto(nullptr) {}
  ~BlurFieldProto() override;
  explicit PROTOBUF_CONSTEXPR BlurFieldProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BlurFieldProto(const BlurFieldProto& from);
  BlurFieldProto(BlurFieldProto&& from) noexcept
    : BlurFieldProto() {
    *this = ::std::move(from);
  }

  inline BlurFieldProto& operator=(const BlurFieldProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline BlurFieldProto& operator=(BlurFieldProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const BlurFieldProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const BlurFieldProto* internal_default_instance() {
    return reinterpret_cast<const BlurFieldProto*>(
               &_BlurFieldProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(BlurFieldProto& a, BlurFieldProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(BlurFieldProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BlurFieldProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BlurFieldProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BlurFieldProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const BlurFieldProto& from);
  void MergeFrom(const BlurFieldProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BlurFieldProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.BlurFieldProto";
  }
  protected:
  explicit BlurFieldProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientIdFieldNumber = 1,
  };
  // optional .autofill_assistant.ClientIdProto client_id = 1;
  bool has_client_id() const;
  private:
  bool _internal_has_client_id() const;
  public:
  void clear_client_id();
  const ::autofill_assistant::ClientIdProto& client_id() const;
  PROTOBUF_NODISCARD ::autofill_assistant::ClientIdProto* release_client_id();
  ::autofill_assistant::ClientIdProto* mutable_client_id();
  void set_allocated_client_id(::autofill_assistant::ClientIdProto* client_id);
  private:
  const ::autofill_assistant::ClientIdProto& _internal_client_id() const;
  ::autofill_assistant::ClientIdProto* _internal_mutable_client_id();
  public:
  void unsafe_arena_set_allocated_client_id(
      ::autofill_assistant::ClientIdProto* client_id);
  ::autofill_assistant::ClientIdProto* unsafe_arena_release_client_id();

  // @@protoc_insertion_point(class_scope:autofill_assistant.BlurFieldProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::autofill_assistant::ClientIdProto* client_id_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fdom_5faction_2eproto;
};
// -------------------------------------------------------------------

class SelectOptionElementProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.SelectOptionElementProto) */ {
 public:
  inline SelectOptionElementProto() : SelectOptionElementProto(nullptr) {}
  ~SelectOptionElementProto() override;
  explicit PROTOBUF_CONSTEXPR SelectOptionElementProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SelectOptionElementProto(const SelectOptionElementProto& from);
  SelectOptionElementProto(SelectOptionElementProto&& from) noexcept
    : SelectOptionElementProto() {
    *this = ::std::move(from);
  }

  inline SelectOptionElementProto& operator=(const SelectOptionElementProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline SelectOptionElementProto& operator=(SelectOptionElementProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const SelectOptionElementProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const SelectOptionElementProto* internal_default_instance() {
    return reinterpret_cast<const SelectOptionElementProto*>(
               &_SelectOptionElementProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(SelectOptionElementProto& a, SelectOptionElementProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(SelectOptionElementProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SelectOptionElementProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SelectOptionElementProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SelectOptionElementProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const SelectOptionElementProto& from);
  void MergeFrom(const SelectOptionElementProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SelectOptionElementProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.SelectOptionElementProto";
  }
  protected:
  explicit SelectOptionElementProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSelectIdFieldNumber = 1,
    kOptionIdFieldNumber = 2,
  };
  // optional .autofill_assistant.ClientIdProto select_id = 1;
  bool has_select_id() const;
  private:
  bool _internal_has_select_id() const;
  public:
  void clear_select_id();
  const ::autofill_assistant::ClientIdProto& select_id() const;
  PROTOBUF_NODISCARD ::autofill_assistant::ClientIdProto* release_select_id();
  ::autofill_assistant::ClientIdProto* mutable_select_id();
  void set_allocated_select_id(::autofill_assistant::ClientIdProto* select_id);
  private:
  const ::autofill_assistant::ClientIdProto& _internal_select_id() const;
  ::autofill_assistant::ClientIdProto* _internal_mutable_select_id();
  public:
  void unsafe_arena_set_allocated_select_id(
      ::autofill_assistant::ClientIdProto* select_id);
  ::autofill_assistant::ClientIdProto* unsafe_arena_release_select_id();

  // optional .autofill_assistant.ClientIdProto option_id = 2;
  bool has_option_id() const;
  private:
  bool _internal_has_option_id() const;
  public:
  void clear_option_id();
  const ::autofill_assistant::ClientIdProto& option_id() const;
  PROTOBUF_NODISCARD ::autofill_assistant::ClientIdProto* release_option_id();
  ::autofill_assistant::ClientIdProto* mutable_option_id();
  void set_allocated_option_id(::autofill_assistant::ClientIdProto* option_id);
  private:
  const ::autofill_assistant::ClientIdProto& _internal_option_id() const;
  ::autofill_assistant::ClientIdProto* _internal_mutable_option_id();
  public:
  void unsafe_arena_set_allocated_option_id(
      ::autofill_assistant::ClientIdProto* option_id);
  ::autofill_assistant::ClientIdProto* unsafe_arena_release_option_id();

  // @@protoc_insertion_point(class_scope:autofill_assistant.SelectOptionElementProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::autofill_assistant::ClientIdProto* select_id_;
  ::autofill_assistant::ClientIdProto* option_id_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fdom_5faction_2eproto;
};
// -------------------------------------------------------------------

class CheckElementTagProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.CheckElementTagProto) */ {
 public:
  inline CheckElementTagProto() : CheckElementTagProto(nullptr) {}
  ~CheckElementTagProto() override;
  explicit PROTOBUF_CONSTEXPR CheckElementTagProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CheckElementTagProto(const CheckElementTagProto& from);
  CheckElementTagProto(CheckElementTagProto&& from) noexcept
    : CheckElementTagProto() {
    *this = ::std::move(from);
  }

  inline CheckElementTagProto& operator=(const CheckElementTagProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline CheckElementTagProto& operator=(CheckElementTagProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CheckElementTagProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const CheckElementTagProto* internal_default_instance() {
    return reinterpret_cast<const CheckElementTagProto*>(
               &_CheckElementTagProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(CheckElementTagProto& a, CheckElementTagProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(CheckElementTagProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CheckElementTagProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CheckElementTagProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CheckElementTagProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const CheckElementTagProto& from);
  void MergeFrom(const CheckElementTagProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CheckElementTagProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.CheckElementTagProto";
  }
  protected:
  explicit CheckElementTagProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAnyOfTagFieldNumber = 2,
    kClientIdFieldNumber = 1,
  };
  // repeated string any_of_tag = 2;
  int any_of_tag_size() const;
  private:
  int _internal_any_of_tag_size() const;
  public:
  void clear_any_of_tag();
  const std::string& any_of_tag(int index) const;
  std::string* mutable_any_of_tag(int index);
  void set_any_of_tag(int index, const std::string& value);
  void set_any_of_tag(int index, std::string&& value);
  void set_any_of_tag(int index, const char* value);
  void set_any_of_tag(int index, const char* value, size_t size);
  std::string* add_any_of_tag();
  void add_any_of_tag(const std::string& value);
  void add_any_of_tag(std::string&& value);
  void add_any_of_tag(const char* value);
  void add_any_of_tag(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& any_of_tag() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_any_of_tag();
  private:
  const std::string& _internal_any_of_tag(int index) const;
  std::string* _internal_add_any_of_tag();
  public:

  // optional .autofill_assistant.ClientIdProto client_id = 1;
  bool has_client_id() const;
  private:
  bool _internal_has_client_id() const;
  public:
  void clear_client_id();
  const ::autofill_assistant::ClientIdProto& client_id() const;
  PROTOBUF_NODISCARD ::autofill_assistant::ClientIdProto* release_client_id();
  ::autofill_assistant::ClientIdProto* mutable_client_id();
  void set_allocated_client_id(::autofill_assistant::ClientIdProto* client_id);
  private:
  const ::autofill_assistant::ClientIdProto& _internal_client_id() const;
  ::autofill_assistant::ClientIdProto* _internal_mutable_client_id();
  public:
  void unsafe_arena_set_allocated_client_id(
      ::autofill_assistant::ClientIdProto* client_id);
  ::autofill_assistant::ClientIdProto* unsafe_arena_release_client_id();

  // @@protoc_insertion_point(class_scope:autofill_assistant.CheckElementTagProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> any_of_tag_;
  ::autofill_assistant::ClientIdProto* client_id_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fdom_5faction_2eproto;
};
// -------------------------------------------------------------------

class CheckOptionElementProto_Result final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.CheckOptionElementProto.Result) */ {
 public:
  inline CheckOptionElementProto_Result() : CheckOptionElementProto_Result(nullptr) {}
  ~CheckOptionElementProto_Result() override;
  explicit PROTOBUF_CONSTEXPR CheckOptionElementProto_Result(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CheckOptionElementProto_Result(const CheckOptionElementProto_Result& from);
  CheckOptionElementProto_Result(CheckOptionElementProto_Result&& from) noexcept
    : CheckOptionElementProto_Result() {
    *this = ::std::move(from);
  }

  inline CheckOptionElementProto_Result& operator=(const CheckOptionElementProto_Result& from) {
    CopyFrom(from);
    return *this;
  }
  inline CheckOptionElementProto_Result& operator=(CheckOptionElementProto_Result&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CheckOptionElementProto_Result& default_instance() {
    return *internal_default_instance();
  }
  static inline const CheckOptionElementProto_Result* internal_default_instance() {
    return reinterpret_cast<const CheckOptionElementProto_Result*>(
               &_CheckOptionElementProto_Result_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(CheckOptionElementProto_Result& a, CheckOptionElementProto_Result& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(CheckOptionElementProto_Result* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CheckOptionElementProto_Result* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CheckOptionElementProto_Result* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CheckOptionElementProto_Result>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const CheckOptionElementProto_Result& from);
  void MergeFrom(const CheckOptionElementProto_Result& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CheckOptionElementProto_Result* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.CheckOptionElementProto.Result";
  }
  protected:
  explicit CheckOptionElementProto_Result(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMatchFieldNumber = 1,
  };
  // optional bool match = 1;
  bool has_match() const;
  private:
  bool _internal_has_match() const;
  public:
  void clear_match();
  bool match() const;
  void set_match(bool value);
  private:
  bool _internal_match() const;
  void _internal_set_match(bool value);
  public:

  // @@protoc_insertion_point(class_scope:autofill_assistant.CheckOptionElementProto.Result)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  bool match_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fdom_5faction_2eproto;
};
// -------------------------------------------------------------------

class CheckOptionElementProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.CheckOptionElementProto) */ {
 public:
  inline CheckOptionElementProto() : CheckOptionElementProto(nullptr) {}
  ~CheckOptionElementProto() override;
  explicit PROTOBUF_CONSTEXPR CheckOptionElementProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CheckOptionElementProto(const CheckOptionElementProto& from);
  CheckOptionElementProto(CheckOptionElementProto&& from) noexcept
    : CheckOptionElementProto() {
    *this = ::std::move(from);
  }

  inline CheckOptionElementProto& operator=(const CheckOptionElementProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline CheckOptionElementProto& operator=(CheckOptionElementProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CheckOptionElementProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const CheckOptionElementProto* internal_default_instance() {
    return reinterpret_cast<const CheckOptionElementProto*>(
               &_CheckOptionElementProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(CheckOptionElementProto& a, CheckOptionElementProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(CheckOptionElementProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CheckOptionElementProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CheckOptionElementProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CheckOptionElementProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const CheckOptionElementProto& from);
  void MergeFrom(const CheckOptionElementProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CheckOptionElementProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.CheckOptionElementProto";
  }
  protected:
  explicit CheckOptionElementProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef CheckOptionElementProto_Result Result;

  // accessors -------------------------------------------------------

  enum : int {
    kSelectIdFieldNumber = 1,
    kOptionIdFieldNumber = 2,
    kMismatchShouldFailFieldNumber = 3,
  };
  // optional .autofill_assistant.ClientIdProto select_id = 1;
  bool has_select_id() const;
  private:
  bool _internal_has_select_id() const;
  public:
  void clear_select_id();
  const ::autofill_assistant::ClientIdProto& select_id() const;
  PROTOBUF_NODISCARD ::autofill_assistant::ClientIdProto* release_select_id();
  ::autofill_assistant::ClientIdProto* mutable_select_id();
  void set_allocated_select_id(::autofill_assistant::ClientIdProto* select_id);
  private:
  const ::autofill_assistant::ClientIdProto& _internal_select_id() const;
  ::autofill_assistant::ClientIdProto* _internal_mutable_select_id();
  public:
  void unsafe_arena_set_allocated_select_id(
      ::autofill_assistant::ClientIdProto* select_id);
  ::autofill_assistant::ClientIdProto* unsafe_arena_release_select_id();

  // optional .autofill_assistant.ClientIdProto option_id = 2;
  bool has_option_id() const;
  private:
  bool _internal_has_option_id() const;
  public:
  void clear_option_id();
  const ::autofill_assistant::ClientIdProto& option_id() const;
  PROTOBUF_NODISCARD ::autofill_assistant::ClientIdProto* release_option_id();
  ::autofill_assistant::ClientIdProto* mutable_option_id();
  void set_allocated_option_id(::autofill_assistant::ClientIdProto* option_id);
  private:
  const ::autofill_assistant::ClientIdProto& _internal_option_id() const;
  ::autofill_assistant::ClientIdProto* _internal_mutable_option_id();
  public:
  void unsafe_arena_set_allocated_option_id(
      ::autofill_assistant::ClientIdProto* option_id);
  ::autofill_assistant::ClientIdProto* unsafe_arena_release_option_id();

  // optional bool mismatch_should_fail = 3;
  bool has_mismatch_should_fail() const;
  private:
  bool _internal_has_mismatch_should_fail() const;
  public:
  void clear_mismatch_should_fail();
  bool mismatch_should_fail() const;
  void set_mismatch_should_fail(bool value);
  private:
  bool _internal_mismatch_should_fail() const;
  void _internal_set_mismatch_should_fail(bool value);
  public:

  // @@protoc_insertion_point(class_scope:autofill_assistant.CheckOptionElementProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::autofill_assistant::ClientIdProto* select_id_;
  ::autofill_assistant::ClientIdProto* option_id_;
  bool mismatch_should_fail_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fdom_5faction_2eproto;
};
// -------------------------------------------------------------------

class ExecuteJsProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.ExecuteJsProto) */ {
 public:
  inline ExecuteJsProto() : ExecuteJsProto(nullptr) {}
  ~ExecuteJsProto() override;
  explicit PROTOBUF_CONSTEXPR ExecuteJsProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ExecuteJsProto(const ExecuteJsProto& from);
  ExecuteJsProto(ExecuteJsProto&& from) noexcept
    : ExecuteJsProto() {
    *this = ::std::move(from);
  }

  inline ExecuteJsProto& operator=(const ExecuteJsProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExecuteJsProto& operator=(ExecuteJsProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ExecuteJsProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExecuteJsProto* internal_default_instance() {
    return reinterpret_cast<const ExecuteJsProto*>(
               &_ExecuteJsProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(ExecuteJsProto& a, ExecuteJsProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(ExecuteJsProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExecuteJsProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExecuteJsProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ExecuteJsProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ExecuteJsProto& from);
  void MergeFrom(const ExecuteJsProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ExecuteJsProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.ExecuteJsProto";
  }
  protected:
  explicit ExecuteJsProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kJsSnippetFieldNumber = 2,
    kClientIdFieldNumber = 1,
    kTimeoutMsFieldNumber = 3,
  };
  // optional string js_snippet = 2;
  bool has_js_snippet() const;
  private:
  bool _internal_has_js_snippet() const;
  public:
  void clear_js_snippet();
  const std::string& js_snippet() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_js_snippet(ArgT0&& arg0, ArgT... args);
  std::string* mutable_js_snippet();
  PROTOBUF_NODISCARD std::string* release_js_snippet();
  void set_allocated_js_snippet(std::string* js_snippet);
  private:
  const std::string& _internal_js_snippet() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_js_snippet(const std::string& value);
  std::string* _internal_mutable_js_snippet();
  public:

  // optional .autofill_assistant.ClientIdProto client_id = 1;
  bool has_client_id() const;
  private:
  bool _internal_has_client_id() const;
  public:
  void clear_client_id();
  const ::autofill_assistant::ClientIdProto& client_id() const;
  PROTOBUF_NODISCARD ::autofill_assistant::ClientIdProto* release_client_id();
  ::autofill_assistant::ClientIdProto* mutable_client_id();
  void set_allocated_client_id(::autofill_assistant::ClientIdProto* client_id);
  private:
  const ::autofill_assistant::ClientIdProto& _internal_client_id() const;
  ::autofill_assistant::ClientIdProto* _internal_mutable_client_id();
  public:
  void unsafe_arena_set_allocated_client_id(
      ::autofill_assistant::ClientIdProto* client_id);
  ::autofill_assistant::ClientIdProto* unsafe_arena_release_client_id();

  // optional int32 timeout_ms = 3;
  bool has_timeout_ms() const;
  private:
  bool _internal_has_timeout_ms() const;
  public:
  void clear_timeout_ms();
  int32_t timeout_ms() const;
  void set_timeout_ms(int32_t value);
  private:
  int32_t _internal_timeout_ms() const;
  void _internal_set_timeout_ms(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:autofill_assistant.ExecuteJsProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr js_snippet_;
  ::autofill_assistant::ClientIdProto* client_id_;
  int32_t timeout_ms_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fdom_5faction_2eproto;
};
// -------------------------------------------------------------------

class SetNativeValueProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.SetNativeValueProto) */ {
 public:
  inline SetNativeValueProto() : SetNativeValueProto(nullptr) {}
  ~SetNativeValueProto() override;
  explicit PROTOBUF_CONSTEXPR SetNativeValueProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetNativeValueProto(const SetNativeValueProto& from);
  SetNativeValueProto(SetNativeValueProto&& from) noexcept
    : SetNativeValueProto() {
    *this = ::std::move(from);
  }

  inline SetNativeValueProto& operator=(const SetNativeValueProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetNativeValueProto& operator=(SetNativeValueProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const SetNativeValueProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetNativeValueProto* internal_default_instance() {
    return reinterpret_cast<const SetNativeValueProto*>(
               &_SetNativeValueProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(SetNativeValueProto& a, SetNativeValueProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(SetNativeValueProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetNativeValueProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetNativeValueProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetNativeValueProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const SetNativeValueProto& from);
  void MergeFrom(const SetNativeValueProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SetNativeValueProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.SetNativeValueProto";
  }
  protected:
  explicit SetNativeValueProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientIdFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // optional .autofill_assistant.ClientIdProto client_id = 1;
  bool has_client_id() const;
  private:
  bool _internal_has_client_id() const;
  public:
  void clear_client_id();
  const ::autofill_assistant::ClientIdProto& client_id() const;
  PROTOBUF_NODISCARD ::autofill_assistant::ClientIdProto* release_client_id();
  ::autofill_assistant::ClientIdProto* mutable_client_id();
  void set_allocated_client_id(::autofill_assistant::ClientIdProto* client_id);
  private:
  const ::autofill_assistant::ClientIdProto& _internal_client_id() const;
  ::autofill_assistant::ClientIdProto* _internal_mutable_client_id();
  public:
  void unsafe_arena_set_allocated_client_id(
      ::autofill_assistant::ClientIdProto* client_id);
  ::autofill_assistant::ClientIdProto* unsafe_arena_release_client_id();

  // optional .autofill_assistant.TextValue value = 2;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  const ::autofill_assistant::TextValue& value() const;
  PROTOBUF_NODISCARD ::autofill_assistant::TextValue* release_value();
  ::autofill_assistant::TextValue* mutable_value();
  void set_allocated_value(::autofill_assistant::TextValue* value);
  private:
  const ::autofill_assistant::TextValue& _internal_value() const;
  ::autofill_assistant::TextValue* _internal_mutable_value();
  public:
  void unsafe_arena_set_allocated_value(
      ::autofill_assistant::TextValue* value);
  ::autofill_assistant::TextValue* unsafe_arena_release_value();

  // @@protoc_insertion_point(class_scope:autofill_assistant.SetNativeValueProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::autofill_assistant::ClientIdProto* client_id_;
  ::autofill_assistant::TextValue* value_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fdom_5faction_2eproto;
};
// -------------------------------------------------------------------

class SetNativeCheckedProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.SetNativeCheckedProto) */ {
 public:
  inline SetNativeCheckedProto() : SetNativeCheckedProto(nullptr) {}
  ~SetNativeCheckedProto() override;
  explicit PROTOBUF_CONSTEXPR SetNativeCheckedProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetNativeCheckedProto(const SetNativeCheckedProto& from);
  SetNativeCheckedProto(SetNativeCheckedProto&& from) noexcept
    : SetNativeCheckedProto() {
    *this = ::std::move(from);
  }

  inline SetNativeCheckedProto& operator=(const SetNativeCheckedProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetNativeCheckedProto& operator=(SetNativeCheckedProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const SetNativeCheckedProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetNativeCheckedProto* internal_default_instance() {
    return reinterpret_cast<const SetNativeCheckedProto*>(
               &_SetNativeCheckedProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(SetNativeCheckedProto& a, SetNativeCheckedProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(SetNativeCheckedProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetNativeCheckedProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetNativeCheckedProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetNativeCheckedProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const SetNativeCheckedProto& from);
  void MergeFrom(const SetNativeCheckedProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SetNativeCheckedProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.SetNativeCheckedProto";
  }
  protected:
  explicit SetNativeCheckedProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientIdFieldNumber = 1,
    kCheckedFieldNumber = 2,
  };
  // optional .autofill_assistant.ClientIdProto client_id = 1;
  bool has_client_id() const;
  private:
  bool _internal_has_client_id() const;
  public:
  void clear_client_id();
  const ::autofill_assistant::ClientIdProto& client_id() const;
  PROTOBUF_NODISCARD ::autofill_assistant::ClientIdProto* release_client_id();
  ::autofill_assistant::ClientIdProto* mutable_client_id();
  void set_allocated_client_id(::autofill_assistant::ClientIdProto* client_id);
  private:
  const ::autofill_assistant::ClientIdProto& _internal_client_id() const;
  ::autofill_assistant::ClientIdProto* _internal_mutable_client_id();
  public:
  void unsafe_arena_set_allocated_client_id(
      ::autofill_assistant::ClientIdProto* client_id);
  ::autofill_assistant::ClientIdProto* unsafe_arena_release_client_id();

  // optional bool checked = 2;
  bool has_checked() const;
  private:
  bool _internal_has_checked() const;
  public:
  void clear_checked();
  bool checked() const;
  void set_checked(bool value);
  private:
  bool _internal_checked() const;
  void _internal_set_checked(bool value);
  public:

  // @@protoc_insertion_point(class_scope:autofill_assistant.SetNativeCheckedProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::autofill_assistant::ClientIdProto* client_id_;
  bool checked_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fdom_5faction_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ClientIdProto

// optional string identifier = 1;
inline bool ClientIdProto::_internal_has_identifier() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ClientIdProto::has_identifier() const {
  return _internal_has_identifier();
}
inline void ClientIdProto::clear_identifier() {
  identifier_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ClientIdProto::identifier() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ClientIdProto.identifier)
  return _internal_identifier();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ClientIdProto::set_identifier(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 identifier_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.ClientIdProto.identifier)
}
inline std::string* ClientIdProto::mutable_identifier() {
  std::string* _s = _internal_mutable_identifier();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ClientIdProto.identifier)
  return _s;
}
inline const std::string& ClientIdProto::_internal_identifier() const {
  return identifier_.Get();
}
inline void ClientIdProto::_internal_set_identifier(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  identifier_.Set(value, GetArenaForAllocation());
}
inline std::string* ClientIdProto::_internal_mutable_identifier() {
  _has_bits_[0] |= 0x00000001u;
  return identifier_.Mutable(GetArenaForAllocation());
}
inline std::string* ClientIdProto::release_identifier() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ClientIdProto.identifier)
  if (!_internal_has_identifier()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = identifier_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (identifier_.IsDefault()) {
    identifier_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ClientIdProto::set_allocated_identifier(std::string* identifier) {
  if (identifier != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  identifier_.SetAllocated(identifier, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (identifier_.IsDefault()) {
    identifier_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ClientIdProto.identifier)
}

// -------------------------------------------------------------------

// ScrollIntoViewProto

// optional .autofill_assistant.ClientIdProto client_id = 1;
inline bool ScrollIntoViewProto::_internal_has_client_id() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || client_id_ != nullptr);
  return value;
}
inline bool ScrollIntoViewProto::has_client_id() const {
  return _internal_has_client_id();
}
inline void ScrollIntoViewProto::clear_client_id() {
  if (client_id_ != nullptr) client_id_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::autofill_assistant::ClientIdProto& ScrollIntoViewProto::_internal_client_id() const {
  const ::autofill_assistant::ClientIdProto* p = client_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::ClientIdProto&>(
      ::autofill_assistant::_ClientIdProto_default_instance_);
}
inline const ::autofill_assistant::ClientIdProto& ScrollIntoViewProto::client_id() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ScrollIntoViewProto.client_id)
  return _internal_client_id();
}
inline void ScrollIntoViewProto::unsafe_arena_set_allocated_client_id(
    ::autofill_assistant::ClientIdProto* client_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(client_id_);
  }
  client_id_ = client_id;
  if (client_id) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ScrollIntoViewProto.client_id)
}
inline ::autofill_assistant::ClientIdProto* ScrollIntoViewProto::release_client_id() {
  _has_bits_[0] &= ~0x00000008u;
  ::autofill_assistant::ClientIdProto* temp = client_id_;
  client_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::ClientIdProto* ScrollIntoViewProto::unsafe_arena_release_client_id() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ScrollIntoViewProto.client_id)
  _has_bits_[0] &= ~0x00000008u;
  ::autofill_assistant::ClientIdProto* temp = client_id_;
  client_id_ = nullptr;
  return temp;
}
inline ::autofill_assistant::ClientIdProto* ScrollIntoViewProto::_internal_mutable_client_id() {
  _has_bits_[0] |= 0x00000008u;
  if (client_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::ClientIdProto>(GetArenaForAllocation());
    client_id_ = p;
  }
  return client_id_;
}
inline ::autofill_assistant::ClientIdProto* ScrollIntoViewProto::mutable_client_id() {
  ::autofill_assistant::ClientIdProto* _msg = _internal_mutable_client_id();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ScrollIntoViewProto.client_id)
  return _msg;
}
inline void ScrollIntoViewProto::set_allocated_client_id(::autofill_assistant::ClientIdProto* client_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete client_id_;
  }
  if (client_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(client_id);
    if (message_arena != submessage_arena) {
      client_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, client_id, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  client_id_ = client_id;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ScrollIntoViewProto.client_id)
}

// optional string animation = 2;
inline bool ScrollIntoViewProto::_internal_has_animation() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ScrollIntoViewProto::has_animation() const {
  return _internal_has_animation();
}
inline void ScrollIntoViewProto::clear_animation() {
  animation_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ScrollIntoViewProto::animation() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ScrollIntoViewProto.animation)
  return _internal_animation();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ScrollIntoViewProto::set_animation(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 animation_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.ScrollIntoViewProto.animation)
}
inline std::string* ScrollIntoViewProto::mutable_animation() {
  std::string* _s = _internal_mutable_animation();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ScrollIntoViewProto.animation)
  return _s;
}
inline const std::string& ScrollIntoViewProto::_internal_animation() const {
  return animation_.Get();
}
inline void ScrollIntoViewProto::_internal_set_animation(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  animation_.Set(value, GetArenaForAllocation());
}
inline std::string* ScrollIntoViewProto::_internal_mutable_animation() {
  _has_bits_[0] |= 0x00000001u;
  return animation_.Mutable(GetArenaForAllocation());
}
inline std::string* ScrollIntoViewProto::release_animation() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ScrollIntoViewProto.animation)
  if (!_internal_has_animation()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = animation_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (animation_.IsDefault()) {
    animation_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ScrollIntoViewProto::set_allocated_animation(std::string* animation) {
  if (animation != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  animation_.SetAllocated(animation, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (animation_.IsDefault()) {
    animation_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ScrollIntoViewProto.animation)
}

// optional string vertical_alignment = 3;
inline bool ScrollIntoViewProto::_internal_has_vertical_alignment() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ScrollIntoViewProto::has_vertical_alignment() const {
  return _internal_has_vertical_alignment();
}
inline void ScrollIntoViewProto::clear_vertical_alignment() {
  vertical_alignment_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ScrollIntoViewProto::vertical_alignment() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ScrollIntoViewProto.vertical_alignment)
  return _internal_vertical_alignment();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ScrollIntoViewProto::set_vertical_alignment(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 vertical_alignment_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.ScrollIntoViewProto.vertical_alignment)
}
inline std::string* ScrollIntoViewProto::mutable_vertical_alignment() {
  std::string* _s = _internal_mutable_vertical_alignment();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ScrollIntoViewProto.vertical_alignment)
  return _s;
}
inline const std::string& ScrollIntoViewProto::_internal_vertical_alignment() const {
  return vertical_alignment_.Get();
}
inline void ScrollIntoViewProto::_internal_set_vertical_alignment(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  vertical_alignment_.Set(value, GetArenaForAllocation());
}
inline std::string* ScrollIntoViewProto::_internal_mutable_vertical_alignment() {
  _has_bits_[0] |= 0x00000002u;
  return vertical_alignment_.Mutable(GetArenaForAllocation());
}
inline std::string* ScrollIntoViewProto::release_vertical_alignment() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ScrollIntoViewProto.vertical_alignment)
  if (!_internal_has_vertical_alignment()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = vertical_alignment_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (vertical_alignment_.IsDefault()) {
    vertical_alignment_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ScrollIntoViewProto::set_allocated_vertical_alignment(std::string* vertical_alignment) {
  if (vertical_alignment != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  vertical_alignment_.SetAllocated(vertical_alignment, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (vertical_alignment_.IsDefault()) {
    vertical_alignment_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ScrollIntoViewProto.vertical_alignment)
}

// optional string horizontal_alignment = 4;
inline bool ScrollIntoViewProto::_internal_has_horizontal_alignment() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ScrollIntoViewProto::has_horizontal_alignment() const {
  return _internal_has_horizontal_alignment();
}
inline void ScrollIntoViewProto::clear_horizontal_alignment() {
  horizontal_alignment_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& ScrollIntoViewProto::horizontal_alignment() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ScrollIntoViewProto.horizontal_alignment)
  return _internal_horizontal_alignment();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ScrollIntoViewProto::set_horizontal_alignment(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 horizontal_alignment_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.ScrollIntoViewProto.horizontal_alignment)
}
inline std::string* ScrollIntoViewProto::mutable_horizontal_alignment() {
  std::string* _s = _internal_mutable_horizontal_alignment();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ScrollIntoViewProto.horizontal_alignment)
  return _s;
}
inline const std::string& ScrollIntoViewProto::_internal_horizontal_alignment() const {
  return horizontal_alignment_.Get();
}
inline void ScrollIntoViewProto::_internal_set_horizontal_alignment(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  horizontal_alignment_.Set(value, GetArenaForAllocation());
}
inline std::string* ScrollIntoViewProto::_internal_mutable_horizontal_alignment() {
  _has_bits_[0] |= 0x00000004u;
  return horizontal_alignment_.Mutable(GetArenaForAllocation());
}
inline std::string* ScrollIntoViewProto::release_horizontal_alignment() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ScrollIntoViewProto.horizontal_alignment)
  if (!_internal_has_horizontal_alignment()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = horizontal_alignment_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (horizontal_alignment_.IsDefault()) {
    horizontal_alignment_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ScrollIntoViewProto::set_allocated_horizontal_alignment(std::string* horizontal_alignment) {
  if (horizontal_alignment != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  horizontal_alignment_.SetAllocated(horizontal_alignment, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (horizontal_alignment_.IsDefault()) {
    horizontal_alignment_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ScrollIntoViewProto.horizontal_alignment)
}

// -------------------------------------------------------------------

// ScrollIntoViewIfNeededProto

// optional .autofill_assistant.ClientIdProto client_id = 1;
inline bool ScrollIntoViewIfNeededProto::_internal_has_client_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || client_id_ != nullptr);
  return value;
}
inline bool ScrollIntoViewIfNeededProto::has_client_id() const {
  return _internal_has_client_id();
}
inline void ScrollIntoViewIfNeededProto::clear_client_id() {
  if (client_id_ != nullptr) client_id_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::autofill_assistant::ClientIdProto& ScrollIntoViewIfNeededProto::_internal_client_id() const {
  const ::autofill_assistant::ClientIdProto* p = client_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::ClientIdProto&>(
      ::autofill_assistant::_ClientIdProto_default_instance_);
}
inline const ::autofill_assistant::ClientIdProto& ScrollIntoViewIfNeededProto::client_id() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ScrollIntoViewIfNeededProto.client_id)
  return _internal_client_id();
}
inline void ScrollIntoViewIfNeededProto::unsafe_arena_set_allocated_client_id(
    ::autofill_assistant::ClientIdProto* client_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(client_id_);
  }
  client_id_ = client_id;
  if (client_id) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ScrollIntoViewIfNeededProto.client_id)
}
inline ::autofill_assistant::ClientIdProto* ScrollIntoViewIfNeededProto::release_client_id() {
  _has_bits_[0] &= ~0x00000001u;
  ::autofill_assistant::ClientIdProto* temp = client_id_;
  client_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::ClientIdProto* ScrollIntoViewIfNeededProto::unsafe_arena_release_client_id() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ScrollIntoViewIfNeededProto.client_id)
  _has_bits_[0] &= ~0x00000001u;
  ::autofill_assistant::ClientIdProto* temp = client_id_;
  client_id_ = nullptr;
  return temp;
}
inline ::autofill_assistant::ClientIdProto* ScrollIntoViewIfNeededProto::_internal_mutable_client_id() {
  _has_bits_[0] |= 0x00000001u;
  if (client_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::ClientIdProto>(GetArenaForAllocation());
    client_id_ = p;
  }
  return client_id_;
}
inline ::autofill_assistant::ClientIdProto* ScrollIntoViewIfNeededProto::mutable_client_id() {
  ::autofill_assistant::ClientIdProto* _msg = _internal_mutable_client_id();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ScrollIntoViewIfNeededProto.client_id)
  return _msg;
}
inline void ScrollIntoViewIfNeededProto::set_allocated_client_id(::autofill_assistant::ClientIdProto* client_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete client_id_;
  }
  if (client_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(client_id);
    if (message_arena != submessage_arena) {
      client_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, client_id, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  client_id_ = client_id;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ScrollIntoViewIfNeededProto.client_id)
}

// optional bool center = 2;
inline bool ScrollIntoViewIfNeededProto::_internal_has_center() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ScrollIntoViewIfNeededProto::has_center() const {
  return _internal_has_center();
}
inline void ScrollIntoViewIfNeededProto::clear_center() {
  center_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool ScrollIntoViewIfNeededProto::_internal_center() const {
  return center_;
}
inline bool ScrollIntoViewIfNeededProto::center() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ScrollIntoViewIfNeededProto.center)
  return _internal_center();
}
inline void ScrollIntoViewIfNeededProto::_internal_set_center(bool value) {
  _has_bits_[0] |= 0x00000002u;
  center_ = value;
}
inline void ScrollIntoViewIfNeededProto::set_center(bool value) {
  _internal_set_center(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.ScrollIntoViewIfNeededProto.center)
}

// -------------------------------------------------------------------

// ScrollDistance

// int32 pixels = 1;
inline bool ScrollDistance::_internal_has_pixels() const {
  return value_case() == kPixels;
}
inline bool ScrollDistance::has_pixels() const {
  return _internal_has_pixels();
}
inline void ScrollDistance::set_has_pixels() {
  _oneof_case_[0] = kPixels;
}
inline void ScrollDistance::clear_pixels() {
  if (_internal_has_pixels()) {
    value_.pixels_ = 0;
    clear_has_value();
  }
}
inline int32_t ScrollDistance::_internal_pixels() const {
  if (_internal_has_pixels()) {
    return value_.pixels_;
  }
  return 0;
}
inline void ScrollDistance::_internal_set_pixels(int32_t value) {
  if (!_internal_has_pixels()) {
    clear_value();
    set_has_pixels();
  }
  value_.pixels_ = value;
}
inline int32_t ScrollDistance::pixels() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ScrollDistance.pixels)
  return _internal_pixels();
}
inline void ScrollDistance::set_pixels(int32_t value) {
  _internal_set_pixels(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.ScrollDistance.pixels)
}

// float window_ratio = 2;
inline bool ScrollDistance::_internal_has_window_ratio() const {
  return value_case() == kWindowRatio;
}
inline bool ScrollDistance::has_window_ratio() const {
  return _internal_has_window_ratio();
}
inline void ScrollDistance::set_has_window_ratio() {
  _oneof_case_[0] = kWindowRatio;
}
inline void ScrollDistance::clear_window_ratio() {
  if (_internal_has_window_ratio()) {
    value_.window_ratio_ = 0;
    clear_has_value();
  }
}
inline float ScrollDistance::_internal_window_ratio() const {
  if (_internal_has_window_ratio()) {
    return value_.window_ratio_;
  }
  return 0;
}
inline void ScrollDistance::_internal_set_window_ratio(float value) {
  if (!_internal_has_window_ratio()) {
    clear_value();
    set_has_window_ratio();
  }
  value_.window_ratio_ = value;
}
inline float ScrollDistance::window_ratio() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ScrollDistance.window_ratio)
  return _internal_window_ratio();
}
inline void ScrollDistance::set_window_ratio(float value) {
  _internal_set_window_ratio(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.ScrollDistance.window_ratio)
}

inline bool ScrollDistance::has_value() const {
  return value_case() != VALUE_NOT_SET;
}
inline void ScrollDistance::clear_has_value() {
  _oneof_case_[0] = VALUE_NOT_SET;
}
inline ScrollDistance::ValueCase ScrollDistance::value_case() const {
  return ScrollDistance::ValueCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ScrollWindowProto

// optional .autofill_assistant.ClientIdProto optional_frame_id = 1;
inline bool ScrollWindowProto::_internal_has_optional_frame_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || optional_frame_id_ != nullptr);
  return value;
}
inline bool ScrollWindowProto::has_optional_frame_id() const {
  return _internal_has_optional_frame_id();
}
inline void ScrollWindowProto::clear_optional_frame_id() {
  if (optional_frame_id_ != nullptr) optional_frame_id_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::autofill_assistant::ClientIdProto& ScrollWindowProto::_internal_optional_frame_id() const {
  const ::autofill_assistant::ClientIdProto* p = optional_frame_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::ClientIdProto&>(
      ::autofill_assistant::_ClientIdProto_default_instance_);
}
inline const ::autofill_assistant::ClientIdProto& ScrollWindowProto::optional_frame_id() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ScrollWindowProto.optional_frame_id)
  return _internal_optional_frame_id();
}
inline void ScrollWindowProto::unsafe_arena_set_allocated_optional_frame_id(
    ::autofill_assistant::ClientIdProto* optional_frame_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(optional_frame_id_);
  }
  optional_frame_id_ = optional_frame_id;
  if (optional_frame_id) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ScrollWindowProto.optional_frame_id)
}
inline ::autofill_assistant::ClientIdProto* ScrollWindowProto::release_optional_frame_id() {
  _has_bits_[0] &= ~0x00000002u;
  ::autofill_assistant::ClientIdProto* temp = optional_frame_id_;
  optional_frame_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::ClientIdProto* ScrollWindowProto::unsafe_arena_release_optional_frame_id() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ScrollWindowProto.optional_frame_id)
  _has_bits_[0] &= ~0x00000002u;
  ::autofill_assistant::ClientIdProto* temp = optional_frame_id_;
  optional_frame_id_ = nullptr;
  return temp;
}
inline ::autofill_assistant::ClientIdProto* ScrollWindowProto::_internal_mutable_optional_frame_id() {
  _has_bits_[0] |= 0x00000002u;
  if (optional_frame_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::ClientIdProto>(GetArenaForAllocation());
    optional_frame_id_ = p;
  }
  return optional_frame_id_;
}
inline ::autofill_assistant::ClientIdProto* ScrollWindowProto::mutable_optional_frame_id() {
  ::autofill_assistant::ClientIdProto* _msg = _internal_mutable_optional_frame_id();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ScrollWindowProto.optional_frame_id)
  return _msg;
}
inline void ScrollWindowProto::set_allocated_optional_frame_id(::autofill_assistant::ClientIdProto* optional_frame_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete optional_frame_id_;
  }
  if (optional_frame_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(optional_frame_id);
    if (message_arena != submessage_arena) {
      optional_frame_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, optional_frame_id, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  optional_frame_id_ = optional_frame_id;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ScrollWindowProto.optional_frame_id)
}

// optional .autofill_assistant.ScrollDistance scroll_distance = 2;
inline bool ScrollWindowProto::_internal_has_scroll_distance() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || scroll_distance_ != nullptr);
  return value;
}
inline bool ScrollWindowProto::has_scroll_distance() const {
  return _internal_has_scroll_distance();
}
inline void ScrollWindowProto::clear_scroll_distance() {
  if (scroll_distance_ != nullptr) scroll_distance_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::autofill_assistant::ScrollDistance& ScrollWindowProto::_internal_scroll_distance() const {
  const ::autofill_assistant::ScrollDistance* p = scroll_distance_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::ScrollDistance&>(
      ::autofill_assistant::_ScrollDistance_default_instance_);
}
inline const ::autofill_assistant::ScrollDistance& ScrollWindowProto::scroll_distance() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ScrollWindowProto.scroll_distance)
  return _internal_scroll_distance();
}
inline void ScrollWindowProto::unsafe_arena_set_allocated_scroll_distance(
    ::autofill_assistant::ScrollDistance* scroll_distance) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(scroll_distance_);
  }
  scroll_distance_ = scroll_distance;
  if (scroll_distance) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ScrollWindowProto.scroll_distance)
}
inline ::autofill_assistant::ScrollDistance* ScrollWindowProto::release_scroll_distance() {
  _has_bits_[0] &= ~0x00000004u;
  ::autofill_assistant::ScrollDistance* temp = scroll_distance_;
  scroll_distance_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::ScrollDistance* ScrollWindowProto::unsafe_arena_release_scroll_distance() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ScrollWindowProto.scroll_distance)
  _has_bits_[0] &= ~0x00000004u;
  ::autofill_assistant::ScrollDistance* temp = scroll_distance_;
  scroll_distance_ = nullptr;
  return temp;
}
inline ::autofill_assistant::ScrollDistance* ScrollWindowProto::_internal_mutable_scroll_distance() {
  _has_bits_[0] |= 0x00000004u;
  if (scroll_distance_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::ScrollDistance>(GetArenaForAllocation());
    scroll_distance_ = p;
  }
  return scroll_distance_;
}
inline ::autofill_assistant::ScrollDistance* ScrollWindowProto::mutable_scroll_distance() {
  ::autofill_assistant::ScrollDistance* _msg = _internal_mutable_scroll_distance();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ScrollWindowProto.scroll_distance)
  return _msg;
}
inline void ScrollWindowProto::set_allocated_scroll_distance(::autofill_assistant::ScrollDistance* scroll_distance) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete scroll_distance_;
  }
  if (scroll_distance) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(scroll_distance);
    if (message_arena != submessage_arena) {
      scroll_distance = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, scroll_distance, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  scroll_distance_ = scroll_distance;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ScrollWindowProto.scroll_distance)
}

// optional string animation = 3;
inline bool ScrollWindowProto::_internal_has_animation() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ScrollWindowProto::has_animation() const {
  return _internal_has_animation();
}
inline void ScrollWindowProto::clear_animation() {
  animation_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ScrollWindowProto::animation() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ScrollWindowProto.animation)
  return _internal_animation();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ScrollWindowProto::set_animation(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 animation_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.ScrollWindowProto.animation)
}
inline std::string* ScrollWindowProto::mutable_animation() {
  std::string* _s = _internal_mutable_animation();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ScrollWindowProto.animation)
  return _s;
}
inline const std::string& ScrollWindowProto::_internal_animation() const {
  return animation_.Get();
}
inline void ScrollWindowProto::_internal_set_animation(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  animation_.Set(value, GetArenaForAllocation());
}
inline std::string* ScrollWindowProto::_internal_mutable_animation() {
  _has_bits_[0] |= 0x00000001u;
  return animation_.Mutable(GetArenaForAllocation());
}
inline std::string* ScrollWindowProto::release_animation() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ScrollWindowProto.animation)
  if (!_internal_has_animation()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = animation_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (animation_.IsDefault()) {
    animation_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ScrollWindowProto::set_allocated_animation(std::string* animation) {
  if (animation != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  animation_.SetAllocated(animation, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (animation_.IsDefault()) {
    animation_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ScrollWindowProto.animation)
}

// -------------------------------------------------------------------

// ScrollContainerProto

// optional .autofill_assistant.ClientIdProto client_id = 1;
inline bool ScrollContainerProto::_internal_has_client_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || client_id_ != nullptr);
  return value;
}
inline bool ScrollContainerProto::has_client_id() const {
  return _internal_has_client_id();
}
inline void ScrollContainerProto::clear_client_id() {
  if (client_id_ != nullptr) client_id_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::autofill_assistant::ClientIdProto& ScrollContainerProto::_internal_client_id() const {
  const ::autofill_assistant::ClientIdProto* p = client_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::ClientIdProto&>(
      ::autofill_assistant::_ClientIdProto_default_instance_);
}
inline const ::autofill_assistant::ClientIdProto& ScrollContainerProto::client_id() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ScrollContainerProto.client_id)
  return _internal_client_id();
}
inline void ScrollContainerProto::unsafe_arena_set_allocated_client_id(
    ::autofill_assistant::ClientIdProto* client_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(client_id_);
  }
  client_id_ = client_id;
  if (client_id) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ScrollContainerProto.client_id)
}
inline ::autofill_assistant::ClientIdProto* ScrollContainerProto::release_client_id() {
  _has_bits_[0] &= ~0x00000002u;
  ::autofill_assistant::ClientIdProto* temp = client_id_;
  client_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::ClientIdProto* ScrollContainerProto::unsafe_arena_release_client_id() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ScrollContainerProto.client_id)
  _has_bits_[0] &= ~0x00000002u;
  ::autofill_assistant::ClientIdProto* temp = client_id_;
  client_id_ = nullptr;
  return temp;
}
inline ::autofill_assistant::ClientIdProto* ScrollContainerProto::_internal_mutable_client_id() {
  _has_bits_[0] |= 0x00000002u;
  if (client_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::ClientIdProto>(GetArenaForAllocation());
    client_id_ = p;
  }
  return client_id_;
}
inline ::autofill_assistant::ClientIdProto* ScrollContainerProto::mutable_client_id() {
  ::autofill_assistant::ClientIdProto* _msg = _internal_mutable_client_id();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ScrollContainerProto.client_id)
  return _msg;
}
inline void ScrollContainerProto::set_allocated_client_id(::autofill_assistant::ClientIdProto* client_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete client_id_;
  }
  if (client_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(client_id);
    if (message_arena != submessage_arena) {
      client_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, client_id, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  client_id_ = client_id;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ScrollContainerProto.client_id)
}

// optional .autofill_assistant.ScrollDistance scroll_distance = 2;
inline bool ScrollContainerProto::_internal_has_scroll_distance() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || scroll_distance_ != nullptr);
  return value;
}
inline bool ScrollContainerProto::has_scroll_distance() const {
  return _internal_has_scroll_distance();
}
inline void ScrollContainerProto::clear_scroll_distance() {
  if (scroll_distance_ != nullptr) scroll_distance_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::autofill_assistant::ScrollDistance& ScrollContainerProto::_internal_scroll_distance() const {
  const ::autofill_assistant::ScrollDistance* p = scroll_distance_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::ScrollDistance&>(
      ::autofill_assistant::_ScrollDistance_default_instance_);
}
inline const ::autofill_assistant::ScrollDistance& ScrollContainerProto::scroll_distance() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ScrollContainerProto.scroll_distance)
  return _internal_scroll_distance();
}
inline void ScrollContainerProto::unsafe_arena_set_allocated_scroll_distance(
    ::autofill_assistant::ScrollDistance* scroll_distance) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(scroll_distance_);
  }
  scroll_distance_ = scroll_distance;
  if (scroll_distance) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ScrollContainerProto.scroll_distance)
}
inline ::autofill_assistant::ScrollDistance* ScrollContainerProto::release_scroll_distance() {
  _has_bits_[0] &= ~0x00000004u;
  ::autofill_assistant::ScrollDistance* temp = scroll_distance_;
  scroll_distance_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::ScrollDistance* ScrollContainerProto::unsafe_arena_release_scroll_distance() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ScrollContainerProto.scroll_distance)
  _has_bits_[0] &= ~0x00000004u;
  ::autofill_assistant::ScrollDistance* temp = scroll_distance_;
  scroll_distance_ = nullptr;
  return temp;
}
inline ::autofill_assistant::ScrollDistance* ScrollContainerProto::_internal_mutable_scroll_distance() {
  _has_bits_[0] |= 0x00000004u;
  if (scroll_distance_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::ScrollDistance>(GetArenaForAllocation());
    scroll_distance_ = p;
  }
  return scroll_distance_;
}
inline ::autofill_assistant::ScrollDistance* ScrollContainerProto::mutable_scroll_distance() {
  ::autofill_assistant::ScrollDistance* _msg = _internal_mutable_scroll_distance();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ScrollContainerProto.scroll_distance)
  return _msg;
}
inline void ScrollContainerProto::set_allocated_scroll_distance(::autofill_assistant::ScrollDistance* scroll_distance) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete scroll_distance_;
  }
  if (scroll_distance) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(scroll_distance);
    if (message_arena != submessage_arena) {
      scroll_distance = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, scroll_distance, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  scroll_distance_ = scroll_distance;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ScrollContainerProto.scroll_distance)
}

// optional string animation = 3;
inline bool ScrollContainerProto::_internal_has_animation() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ScrollContainerProto::has_animation() const {
  return _internal_has_animation();
}
inline void ScrollContainerProto::clear_animation() {
  animation_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ScrollContainerProto::animation() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ScrollContainerProto.animation)
  return _internal_animation();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ScrollContainerProto::set_animation(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 animation_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.ScrollContainerProto.animation)
}
inline std::string* ScrollContainerProto::mutable_animation() {
  std::string* _s = _internal_mutable_animation();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ScrollContainerProto.animation)
  return _s;
}
inline const std::string& ScrollContainerProto::_internal_animation() const {
  return animation_.Get();
}
inline void ScrollContainerProto::_internal_set_animation(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  animation_.Set(value, GetArenaForAllocation());
}
inline std::string* ScrollContainerProto::_internal_mutable_animation() {
  _has_bits_[0] |= 0x00000001u;
  return animation_.Mutable(GetArenaForAllocation());
}
inline std::string* ScrollContainerProto::release_animation() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ScrollContainerProto.animation)
  if (!_internal_has_animation()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = animation_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (animation_.IsDefault()) {
    animation_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ScrollContainerProto::set_allocated_animation(std::string* animation) {
  if (animation != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  animation_.SetAllocated(animation, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (animation_.IsDefault()) {
    animation_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ScrollContainerProto.animation)
}

// -------------------------------------------------------------------

// WaitForDocumentToBecomeInteractiveProto

// optional .autofill_assistant.ClientIdProto client_id = 1;
inline bool WaitForDocumentToBecomeInteractiveProto::_internal_has_client_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || client_id_ != nullptr);
  return value;
}
inline bool WaitForDocumentToBecomeInteractiveProto::has_client_id() const {
  return _internal_has_client_id();
}
inline void WaitForDocumentToBecomeInteractiveProto::clear_client_id() {
  if (client_id_ != nullptr) client_id_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::autofill_assistant::ClientIdProto& WaitForDocumentToBecomeInteractiveProto::_internal_client_id() const {
  const ::autofill_assistant::ClientIdProto* p = client_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::ClientIdProto&>(
      ::autofill_assistant::_ClientIdProto_default_instance_);
}
inline const ::autofill_assistant::ClientIdProto& WaitForDocumentToBecomeInteractiveProto::client_id() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.WaitForDocumentToBecomeInteractiveProto.client_id)
  return _internal_client_id();
}
inline void WaitForDocumentToBecomeInteractiveProto::unsafe_arena_set_allocated_client_id(
    ::autofill_assistant::ClientIdProto* client_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(client_id_);
  }
  client_id_ = client_id;
  if (client_id) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.WaitForDocumentToBecomeInteractiveProto.client_id)
}
inline ::autofill_assistant::ClientIdProto* WaitForDocumentToBecomeInteractiveProto::release_client_id() {
  _has_bits_[0] &= ~0x00000001u;
  ::autofill_assistant::ClientIdProto* temp = client_id_;
  client_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::ClientIdProto* WaitForDocumentToBecomeInteractiveProto::unsafe_arena_release_client_id() {
  // @@protoc_insertion_point(field_release:autofill_assistant.WaitForDocumentToBecomeInteractiveProto.client_id)
  _has_bits_[0] &= ~0x00000001u;
  ::autofill_assistant::ClientIdProto* temp = client_id_;
  client_id_ = nullptr;
  return temp;
}
inline ::autofill_assistant::ClientIdProto* WaitForDocumentToBecomeInteractiveProto::_internal_mutable_client_id() {
  _has_bits_[0] |= 0x00000001u;
  if (client_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::ClientIdProto>(GetArenaForAllocation());
    client_id_ = p;
  }
  return client_id_;
}
inline ::autofill_assistant::ClientIdProto* WaitForDocumentToBecomeInteractiveProto::mutable_client_id() {
  ::autofill_assistant::ClientIdProto* _msg = _internal_mutable_client_id();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.WaitForDocumentToBecomeInteractiveProto.client_id)
  return _msg;
}
inline void WaitForDocumentToBecomeInteractiveProto::set_allocated_client_id(::autofill_assistant::ClientIdProto* client_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete client_id_;
  }
  if (client_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(client_id);
    if (message_arena != submessage_arena) {
      client_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, client_id, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  client_id_ = client_id;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.WaitForDocumentToBecomeInteractiveProto.client_id)
}

// optional int32 timeout_in_ms = 2;
inline bool WaitForDocumentToBecomeInteractiveProto::_internal_has_timeout_in_ms() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool WaitForDocumentToBecomeInteractiveProto::has_timeout_in_ms() const {
  return _internal_has_timeout_in_ms();
}
inline void WaitForDocumentToBecomeInteractiveProto::clear_timeout_in_ms() {
  timeout_in_ms_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline int32_t WaitForDocumentToBecomeInteractiveProto::_internal_timeout_in_ms() const {
  return timeout_in_ms_;
}
inline int32_t WaitForDocumentToBecomeInteractiveProto::timeout_in_ms() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.WaitForDocumentToBecomeInteractiveProto.timeout_in_ms)
  return _internal_timeout_in_ms();
}
inline void WaitForDocumentToBecomeInteractiveProto::_internal_set_timeout_in_ms(int32_t value) {
  _has_bits_[0] |= 0x00000002u;
  timeout_in_ms_ = value;
}
inline void WaitForDocumentToBecomeInteractiveProto::set_timeout_in_ms(int32_t value) {
  _internal_set_timeout_in_ms(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.WaitForDocumentToBecomeInteractiveProto.timeout_in_ms)
}

// -------------------------------------------------------------------

// WaitForDocumentToBecomeCompleteProto

// optional .autofill_assistant.ClientIdProto client_id = 1;
inline bool WaitForDocumentToBecomeCompleteProto::_internal_has_client_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || client_id_ != nullptr);
  return value;
}
inline bool WaitForDocumentToBecomeCompleteProto::has_client_id() const {
  return _internal_has_client_id();
}
inline void WaitForDocumentToBecomeCompleteProto::clear_client_id() {
  if (client_id_ != nullptr) client_id_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::autofill_assistant::ClientIdProto& WaitForDocumentToBecomeCompleteProto::_internal_client_id() const {
  const ::autofill_assistant::ClientIdProto* p = client_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::ClientIdProto&>(
      ::autofill_assistant::_ClientIdProto_default_instance_);
}
inline const ::autofill_assistant::ClientIdProto& WaitForDocumentToBecomeCompleteProto::client_id() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.WaitForDocumentToBecomeCompleteProto.client_id)
  return _internal_client_id();
}
inline void WaitForDocumentToBecomeCompleteProto::unsafe_arena_set_allocated_client_id(
    ::autofill_assistant::ClientIdProto* client_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(client_id_);
  }
  client_id_ = client_id;
  if (client_id) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.WaitForDocumentToBecomeCompleteProto.client_id)
}
inline ::autofill_assistant::ClientIdProto* WaitForDocumentToBecomeCompleteProto::release_client_id() {
  _has_bits_[0] &= ~0x00000001u;
  ::autofill_assistant::ClientIdProto* temp = client_id_;
  client_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::ClientIdProto* WaitForDocumentToBecomeCompleteProto::unsafe_arena_release_client_id() {
  // @@protoc_insertion_point(field_release:autofill_assistant.WaitForDocumentToBecomeCompleteProto.client_id)
  _has_bits_[0] &= ~0x00000001u;
  ::autofill_assistant::ClientIdProto* temp = client_id_;
  client_id_ = nullptr;
  return temp;
}
inline ::autofill_assistant::ClientIdProto* WaitForDocumentToBecomeCompleteProto::_internal_mutable_client_id() {
  _has_bits_[0] |= 0x00000001u;
  if (client_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::ClientIdProto>(GetArenaForAllocation());
    client_id_ = p;
  }
  return client_id_;
}
inline ::autofill_assistant::ClientIdProto* WaitForDocumentToBecomeCompleteProto::mutable_client_id() {
  ::autofill_assistant::ClientIdProto* _msg = _internal_mutable_client_id();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.WaitForDocumentToBecomeCompleteProto.client_id)
  return _msg;
}
inline void WaitForDocumentToBecomeCompleteProto::set_allocated_client_id(::autofill_assistant::ClientIdProto* client_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete client_id_;
  }
  if (client_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(client_id);
    if (message_arena != submessage_arena) {
      client_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, client_id, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  client_id_ = client_id;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.WaitForDocumentToBecomeCompleteProto.client_id)
}

// optional int32 timeout_in_ms = 2;
inline bool WaitForDocumentToBecomeCompleteProto::_internal_has_timeout_in_ms() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool WaitForDocumentToBecomeCompleteProto::has_timeout_in_ms() const {
  return _internal_has_timeout_in_ms();
}
inline void WaitForDocumentToBecomeCompleteProto::clear_timeout_in_ms() {
  timeout_in_ms_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline int32_t WaitForDocumentToBecomeCompleteProto::_internal_timeout_in_ms() const {
  return timeout_in_ms_;
}
inline int32_t WaitForDocumentToBecomeCompleteProto::timeout_in_ms() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.WaitForDocumentToBecomeCompleteProto.timeout_in_ms)
  return _internal_timeout_in_ms();
}
inline void WaitForDocumentToBecomeCompleteProto::_internal_set_timeout_in_ms(int32_t value) {
  _has_bits_[0] |= 0x00000002u;
  timeout_in_ms_ = value;
}
inline void WaitForDocumentToBecomeCompleteProto::set_timeout_in_ms(int32_t value) {
  _internal_set_timeout_in_ms(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.WaitForDocumentToBecomeCompleteProto.timeout_in_ms)
}

// -------------------------------------------------------------------

// WaitForElementToBecomeStableProto

// optional .autofill_assistant.ClientIdProto client_id = 1;
inline bool WaitForElementToBecomeStableProto::_internal_has_client_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || client_id_ != nullptr);
  return value;
}
inline bool WaitForElementToBecomeStableProto::has_client_id() const {
  return _internal_has_client_id();
}
inline void WaitForElementToBecomeStableProto::clear_client_id() {
  if (client_id_ != nullptr) client_id_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::autofill_assistant::ClientIdProto& WaitForElementToBecomeStableProto::_internal_client_id() const {
  const ::autofill_assistant::ClientIdProto* p = client_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::ClientIdProto&>(
      ::autofill_assistant::_ClientIdProto_default_instance_);
}
inline const ::autofill_assistant::ClientIdProto& WaitForElementToBecomeStableProto::client_id() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.WaitForElementToBecomeStableProto.client_id)
  return _internal_client_id();
}
inline void WaitForElementToBecomeStableProto::unsafe_arena_set_allocated_client_id(
    ::autofill_assistant::ClientIdProto* client_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(client_id_);
  }
  client_id_ = client_id;
  if (client_id) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.WaitForElementToBecomeStableProto.client_id)
}
inline ::autofill_assistant::ClientIdProto* WaitForElementToBecomeStableProto::release_client_id() {
  _has_bits_[0] &= ~0x00000001u;
  ::autofill_assistant::ClientIdProto* temp = client_id_;
  client_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::ClientIdProto* WaitForElementToBecomeStableProto::unsafe_arena_release_client_id() {
  // @@protoc_insertion_point(field_release:autofill_assistant.WaitForElementToBecomeStableProto.client_id)
  _has_bits_[0] &= ~0x00000001u;
  ::autofill_assistant::ClientIdProto* temp = client_id_;
  client_id_ = nullptr;
  return temp;
}
inline ::autofill_assistant::ClientIdProto* WaitForElementToBecomeStableProto::_internal_mutable_client_id() {
  _has_bits_[0] |= 0x00000001u;
  if (client_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::ClientIdProto>(GetArenaForAllocation());
    client_id_ = p;
  }
  return client_id_;
}
inline ::autofill_assistant::ClientIdProto* WaitForElementToBecomeStableProto::mutable_client_id() {
  ::autofill_assistant::ClientIdProto* _msg = _internal_mutable_client_id();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.WaitForElementToBecomeStableProto.client_id)
  return _msg;
}
inline void WaitForElementToBecomeStableProto::set_allocated_client_id(::autofill_assistant::ClientIdProto* client_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete client_id_;
  }
  if (client_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(client_id);
    if (message_arena != submessage_arena) {
      client_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, client_id, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  client_id_ = client_id;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.WaitForElementToBecomeStableProto.client_id)
}

// optional int32 stable_check_max_rounds = 2 [default = 50];
inline bool WaitForElementToBecomeStableProto::_internal_has_stable_check_max_rounds() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool WaitForElementToBecomeStableProto::has_stable_check_max_rounds() const {
  return _internal_has_stable_check_max_rounds();
}
inline void WaitForElementToBecomeStableProto::clear_stable_check_max_rounds() {
  stable_check_max_rounds_ = 50;
  _has_bits_[0] &= ~0x00000002u;
}
inline int32_t WaitForElementToBecomeStableProto::_internal_stable_check_max_rounds() const {
  return stable_check_max_rounds_;
}
inline int32_t WaitForElementToBecomeStableProto::stable_check_max_rounds() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.WaitForElementToBecomeStableProto.stable_check_max_rounds)
  return _internal_stable_check_max_rounds();
}
inline void WaitForElementToBecomeStableProto::_internal_set_stable_check_max_rounds(int32_t value) {
  _has_bits_[0] |= 0x00000002u;
  stable_check_max_rounds_ = value;
}
inline void WaitForElementToBecomeStableProto::set_stable_check_max_rounds(int32_t value) {
  _internal_set_stable_check_max_rounds(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.WaitForElementToBecomeStableProto.stable_check_max_rounds)
}

// optional int32 stable_check_interval_ms = 3 [default = 200];
inline bool WaitForElementToBecomeStableProto::_internal_has_stable_check_interval_ms() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool WaitForElementToBecomeStableProto::has_stable_check_interval_ms() const {
  return _internal_has_stable_check_interval_ms();
}
inline void WaitForElementToBecomeStableProto::clear_stable_check_interval_ms() {
  stable_check_interval_ms_ = 200;
  _has_bits_[0] &= ~0x00000004u;
}
inline int32_t WaitForElementToBecomeStableProto::_internal_stable_check_interval_ms() const {
  return stable_check_interval_ms_;
}
inline int32_t WaitForElementToBecomeStableProto::stable_check_interval_ms() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.WaitForElementToBecomeStableProto.stable_check_interval_ms)
  return _internal_stable_check_interval_ms();
}
inline void WaitForElementToBecomeStableProto::_internal_set_stable_check_interval_ms(int32_t value) {
  _has_bits_[0] |= 0x00000004u;
  stable_check_interval_ms_ = value;
}
inline void WaitForElementToBecomeStableProto::set_stable_check_interval_ms(int32_t value) {
  _internal_set_stable_check_interval_ms(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.WaitForElementToBecomeStableProto.stable_check_interval_ms)
}

// -------------------------------------------------------------------

// CheckElementIsOnTopProto

// optional .autofill_assistant.ClientIdProto client_id = 1;
inline bool CheckElementIsOnTopProto::_internal_has_client_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || client_id_ != nullptr);
  return value;
}
inline bool CheckElementIsOnTopProto::has_client_id() const {
  return _internal_has_client_id();
}
inline void CheckElementIsOnTopProto::clear_client_id() {
  if (client_id_ != nullptr) client_id_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::autofill_assistant::ClientIdProto& CheckElementIsOnTopProto::_internal_client_id() const {
  const ::autofill_assistant::ClientIdProto* p = client_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::ClientIdProto&>(
      ::autofill_assistant::_ClientIdProto_default_instance_);
}
inline const ::autofill_assistant::ClientIdProto& CheckElementIsOnTopProto::client_id() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.CheckElementIsOnTopProto.client_id)
  return _internal_client_id();
}
inline void CheckElementIsOnTopProto::unsafe_arena_set_allocated_client_id(
    ::autofill_assistant::ClientIdProto* client_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(client_id_);
  }
  client_id_ = client_id;
  if (client_id) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.CheckElementIsOnTopProto.client_id)
}
inline ::autofill_assistant::ClientIdProto* CheckElementIsOnTopProto::release_client_id() {
  _has_bits_[0] &= ~0x00000001u;
  ::autofill_assistant::ClientIdProto* temp = client_id_;
  client_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::ClientIdProto* CheckElementIsOnTopProto::unsafe_arena_release_client_id() {
  // @@protoc_insertion_point(field_release:autofill_assistant.CheckElementIsOnTopProto.client_id)
  _has_bits_[0] &= ~0x00000001u;
  ::autofill_assistant::ClientIdProto* temp = client_id_;
  client_id_ = nullptr;
  return temp;
}
inline ::autofill_assistant::ClientIdProto* CheckElementIsOnTopProto::_internal_mutable_client_id() {
  _has_bits_[0] |= 0x00000001u;
  if (client_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::ClientIdProto>(GetArenaForAllocation());
    client_id_ = p;
  }
  return client_id_;
}
inline ::autofill_assistant::ClientIdProto* CheckElementIsOnTopProto::mutable_client_id() {
  ::autofill_assistant::ClientIdProto* _msg = _internal_mutable_client_id();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.CheckElementIsOnTopProto.client_id)
  return _msg;
}
inline void CheckElementIsOnTopProto::set_allocated_client_id(::autofill_assistant::ClientIdProto* client_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete client_id_;
  }
  if (client_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(client_id);
    if (message_arena != submessage_arena) {
      client_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, client_id, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  client_id_ = client_id;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.CheckElementIsOnTopProto.client_id)
}

// -------------------------------------------------------------------

// SendClickEventProto

// optional .autofill_assistant.ClientIdProto client_id = 1;
inline bool SendClickEventProto::_internal_has_client_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || client_id_ != nullptr);
  return value;
}
inline bool SendClickEventProto::has_client_id() const {
  return _internal_has_client_id();
}
inline void SendClickEventProto::clear_client_id() {
  if (client_id_ != nullptr) client_id_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::autofill_assistant::ClientIdProto& SendClickEventProto::_internal_client_id() const {
  const ::autofill_assistant::ClientIdProto* p = client_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::ClientIdProto&>(
      ::autofill_assistant::_ClientIdProto_default_instance_);
}
inline const ::autofill_assistant::ClientIdProto& SendClickEventProto::client_id() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.SendClickEventProto.client_id)
  return _internal_client_id();
}
inline void SendClickEventProto::unsafe_arena_set_allocated_client_id(
    ::autofill_assistant::ClientIdProto* client_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(client_id_);
  }
  client_id_ = client_id;
  if (client_id) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.SendClickEventProto.client_id)
}
inline ::autofill_assistant::ClientIdProto* SendClickEventProto::release_client_id() {
  _has_bits_[0] &= ~0x00000001u;
  ::autofill_assistant::ClientIdProto* temp = client_id_;
  client_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::ClientIdProto* SendClickEventProto::unsafe_arena_release_client_id() {
  // @@protoc_insertion_point(field_release:autofill_assistant.SendClickEventProto.client_id)
  _has_bits_[0] &= ~0x00000001u;
  ::autofill_assistant::ClientIdProto* temp = client_id_;
  client_id_ = nullptr;
  return temp;
}
inline ::autofill_assistant::ClientIdProto* SendClickEventProto::_internal_mutable_client_id() {
  _has_bits_[0] |= 0x00000001u;
  if (client_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::ClientIdProto>(GetArenaForAllocation());
    client_id_ = p;
  }
  return client_id_;
}
inline ::autofill_assistant::ClientIdProto* SendClickEventProto::mutable_client_id() {
  ::autofill_assistant::ClientIdProto* _msg = _internal_mutable_client_id();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.SendClickEventProto.client_id)
  return _msg;
}
inline void SendClickEventProto::set_allocated_client_id(::autofill_assistant::ClientIdProto* client_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete client_id_;
  }
  if (client_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(client_id);
    if (message_arena != submessage_arena) {
      client_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, client_id, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  client_id_ = client_id;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.SendClickEventProto.client_id)
}

// -------------------------------------------------------------------

// SendTapEventProto

// optional .autofill_assistant.ClientIdProto client_id = 1;
inline bool SendTapEventProto::_internal_has_client_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || client_id_ != nullptr);
  return value;
}
inline bool SendTapEventProto::has_client_id() const {
  return _internal_has_client_id();
}
inline void SendTapEventProto::clear_client_id() {
  if (client_id_ != nullptr) client_id_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::autofill_assistant::ClientIdProto& SendTapEventProto::_internal_client_id() const {
  const ::autofill_assistant::ClientIdProto* p = client_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::ClientIdProto&>(
      ::autofill_assistant::_ClientIdProto_default_instance_);
}
inline const ::autofill_assistant::ClientIdProto& SendTapEventProto::client_id() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.SendTapEventProto.client_id)
  return _internal_client_id();
}
inline void SendTapEventProto::unsafe_arena_set_allocated_client_id(
    ::autofill_assistant::ClientIdProto* client_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(client_id_);
  }
  client_id_ = client_id;
  if (client_id) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.SendTapEventProto.client_id)
}
inline ::autofill_assistant::ClientIdProto* SendTapEventProto::release_client_id() {
  _has_bits_[0] &= ~0x00000001u;
  ::autofill_assistant::ClientIdProto* temp = client_id_;
  client_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::ClientIdProto* SendTapEventProto::unsafe_arena_release_client_id() {
  // @@protoc_insertion_point(field_release:autofill_assistant.SendTapEventProto.client_id)
  _has_bits_[0] &= ~0x00000001u;
  ::autofill_assistant::ClientIdProto* temp = client_id_;
  client_id_ = nullptr;
  return temp;
}
inline ::autofill_assistant::ClientIdProto* SendTapEventProto::_internal_mutable_client_id() {
  _has_bits_[0] |= 0x00000001u;
  if (client_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::ClientIdProto>(GetArenaForAllocation());
    client_id_ = p;
  }
  return client_id_;
}
inline ::autofill_assistant::ClientIdProto* SendTapEventProto::mutable_client_id() {
  ::autofill_assistant::ClientIdProto* _msg = _internal_mutable_client_id();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.SendTapEventProto.client_id)
  return _msg;
}
inline void SendTapEventProto::set_allocated_client_id(::autofill_assistant::ClientIdProto* client_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete client_id_;
  }
  if (client_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(client_id);
    if (message_arena != submessage_arena) {
      client_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, client_id, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  client_id_ = client_id;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.SendTapEventProto.client_id)
}

// -------------------------------------------------------------------

// JsClickProto

// optional .autofill_assistant.ClientIdProto client_id = 1;
inline bool JsClickProto::_internal_has_client_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || client_id_ != nullptr);
  return value;
}
inline bool JsClickProto::has_client_id() const {
  return _internal_has_client_id();
}
inline void JsClickProto::clear_client_id() {
  if (client_id_ != nullptr) client_id_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::autofill_assistant::ClientIdProto& JsClickProto::_internal_client_id() const {
  const ::autofill_assistant::ClientIdProto* p = client_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::ClientIdProto&>(
      ::autofill_assistant::_ClientIdProto_default_instance_);
}
inline const ::autofill_assistant::ClientIdProto& JsClickProto::client_id() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.JsClickProto.client_id)
  return _internal_client_id();
}
inline void JsClickProto::unsafe_arena_set_allocated_client_id(
    ::autofill_assistant::ClientIdProto* client_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(client_id_);
  }
  client_id_ = client_id;
  if (client_id) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.JsClickProto.client_id)
}
inline ::autofill_assistant::ClientIdProto* JsClickProto::release_client_id() {
  _has_bits_[0] &= ~0x00000001u;
  ::autofill_assistant::ClientIdProto* temp = client_id_;
  client_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::ClientIdProto* JsClickProto::unsafe_arena_release_client_id() {
  // @@protoc_insertion_point(field_release:autofill_assistant.JsClickProto.client_id)
  _has_bits_[0] &= ~0x00000001u;
  ::autofill_assistant::ClientIdProto* temp = client_id_;
  client_id_ = nullptr;
  return temp;
}
inline ::autofill_assistant::ClientIdProto* JsClickProto::_internal_mutable_client_id() {
  _has_bits_[0] |= 0x00000001u;
  if (client_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::ClientIdProto>(GetArenaForAllocation());
    client_id_ = p;
  }
  return client_id_;
}
inline ::autofill_assistant::ClientIdProto* JsClickProto::mutable_client_id() {
  ::autofill_assistant::ClientIdProto* _msg = _internal_mutable_client_id();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.JsClickProto.client_id)
  return _msg;
}
inline void JsClickProto::set_allocated_client_id(::autofill_assistant::ClientIdProto* client_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete client_id_;
  }
  if (client_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(client_id);
    if (message_arena != submessage_arena) {
      client_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, client_id, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  client_id_ = client_id;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.JsClickProto.client_id)
}

// -------------------------------------------------------------------

// SendKeystrokeEventsProto_Result

// optional int32 months_since_password_last_used = 1;
inline bool SendKeystrokeEventsProto_Result::_internal_has_months_since_password_last_used() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SendKeystrokeEventsProto_Result::has_months_since_password_last_used() const {
  return _internal_has_months_since_password_last_used();
}
inline void SendKeystrokeEventsProto_Result::clear_months_since_password_last_used() {
  months_since_password_last_used_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline int32_t SendKeystrokeEventsProto_Result::_internal_months_since_password_last_used() const {
  return months_since_password_last_used_;
}
inline int32_t SendKeystrokeEventsProto_Result::months_since_password_last_used() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.SendKeystrokeEventsProto.Result.months_since_password_last_used)
  return _internal_months_since_password_last_used();
}
inline void SendKeystrokeEventsProto_Result::_internal_set_months_since_password_last_used(int32_t value) {
  _has_bits_[0] |= 0x00000001u;
  months_since_password_last_used_ = value;
}
inline void SendKeystrokeEventsProto_Result::set_months_since_password_last_used(int32_t value) {
  _internal_set_months_since_password_last_used(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.SendKeystrokeEventsProto.Result.months_since_password_last_used)
}

// -------------------------------------------------------------------

// SendKeystrokeEventsProto

// optional .autofill_assistant.ClientIdProto client_id = 1;
inline bool SendKeystrokeEventsProto::_internal_has_client_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || client_id_ != nullptr);
  return value;
}
inline bool SendKeystrokeEventsProto::has_client_id() const {
  return _internal_has_client_id();
}
inline void SendKeystrokeEventsProto::clear_client_id() {
  if (client_id_ != nullptr) client_id_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::autofill_assistant::ClientIdProto& SendKeystrokeEventsProto::_internal_client_id() const {
  const ::autofill_assistant::ClientIdProto* p = client_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::ClientIdProto&>(
      ::autofill_assistant::_ClientIdProto_default_instance_);
}
inline const ::autofill_assistant::ClientIdProto& SendKeystrokeEventsProto::client_id() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.SendKeystrokeEventsProto.client_id)
  return _internal_client_id();
}
inline void SendKeystrokeEventsProto::unsafe_arena_set_allocated_client_id(
    ::autofill_assistant::ClientIdProto* client_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(client_id_);
  }
  client_id_ = client_id;
  if (client_id) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.SendKeystrokeEventsProto.client_id)
}
inline ::autofill_assistant::ClientIdProto* SendKeystrokeEventsProto::release_client_id() {
  _has_bits_[0] &= ~0x00000001u;
  ::autofill_assistant::ClientIdProto* temp = client_id_;
  client_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::ClientIdProto* SendKeystrokeEventsProto::unsafe_arena_release_client_id() {
  // @@protoc_insertion_point(field_release:autofill_assistant.SendKeystrokeEventsProto.client_id)
  _has_bits_[0] &= ~0x00000001u;
  ::autofill_assistant::ClientIdProto* temp = client_id_;
  client_id_ = nullptr;
  return temp;
}
inline ::autofill_assistant::ClientIdProto* SendKeystrokeEventsProto::_internal_mutable_client_id() {
  _has_bits_[0] |= 0x00000001u;
  if (client_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::ClientIdProto>(GetArenaForAllocation());
    client_id_ = p;
  }
  return client_id_;
}
inline ::autofill_assistant::ClientIdProto* SendKeystrokeEventsProto::mutable_client_id() {
  ::autofill_assistant::ClientIdProto* _msg = _internal_mutable_client_id();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.SendKeystrokeEventsProto.client_id)
  return _msg;
}
inline void SendKeystrokeEventsProto::set_allocated_client_id(::autofill_assistant::ClientIdProto* client_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete client_id_;
  }
  if (client_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(client_id);
    if (message_arena != submessage_arena) {
      client_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, client_id, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  client_id_ = client_id;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.SendKeystrokeEventsProto.client_id)
}

// optional .autofill_assistant.TextValue value = 2;
inline bool SendKeystrokeEventsProto::_internal_has_value() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || value_ != nullptr);
  return value;
}
inline bool SendKeystrokeEventsProto::has_value() const {
  return _internal_has_value();
}
inline const ::autofill_assistant::TextValue& SendKeystrokeEventsProto::_internal_value() const {
  const ::autofill_assistant::TextValue* p = value_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::TextValue&>(
      ::autofill_assistant::_TextValue_default_instance_);
}
inline const ::autofill_assistant::TextValue& SendKeystrokeEventsProto::value() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.SendKeystrokeEventsProto.value)
  return _internal_value();
}
inline void SendKeystrokeEventsProto::unsafe_arena_set_allocated_value(
    ::autofill_assistant::TextValue* value) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(value_);
  }
  value_ = value;
  if (value) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.SendKeystrokeEventsProto.value)
}
inline ::autofill_assistant::TextValue* SendKeystrokeEventsProto::release_value() {
  _has_bits_[0] &= ~0x00000002u;
  ::autofill_assistant::TextValue* temp = value_;
  value_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::TextValue* SendKeystrokeEventsProto::unsafe_arena_release_value() {
  // @@protoc_insertion_point(field_release:autofill_assistant.SendKeystrokeEventsProto.value)
  _has_bits_[0] &= ~0x00000002u;
  ::autofill_assistant::TextValue* temp = value_;
  value_ = nullptr;
  return temp;
}
inline ::autofill_assistant::TextValue* SendKeystrokeEventsProto::_internal_mutable_value() {
  _has_bits_[0] |= 0x00000002u;
  if (value_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::TextValue>(GetArenaForAllocation());
    value_ = p;
  }
  return value_;
}
inline ::autofill_assistant::TextValue* SendKeystrokeEventsProto::mutable_value() {
  ::autofill_assistant::TextValue* _msg = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.SendKeystrokeEventsProto.value)
  return _msg;
}
inline void SendKeystrokeEventsProto::set_allocated_value(::autofill_assistant::TextValue* value) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(value_);
  }
  if (value) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(value));
    if (message_arena != submessage_arena) {
      value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  value_ = value;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.SendKeystrokeEventsProto.value)
}

// optional int32 delay_in_ms = 3;
inline bool SendKeystrokeEventsProto::_internal_has_delay_in_ms() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool SendKeystrokeEventsProto::has_delay_in_ms() const {
  return _internal_has_delay_in_ms();
}
inline void SendKeystrokeEventsProto::clear_delay_in_ms() {
  delay_in_ms_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline int32_t SendKeystrokeEventsProto::_internal_delay_in_ms() const {
  return delay_in_ms_;
}
inline int32_t SendKeystrokeEventsProto::delay_in_ms() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.SendKeystrokeEventsProto.delay_in_ms)
  return _internal_delay_in_ms();
}
inline void SendKeystrokeEventsProto::_internal_set_delay_in_ms(int32_t value) {
  _has_bits_[0] |= 0x00000004u;
  delay_in_ms_ = value;
}
inline void SendKeystrokeEventsProto::set_delay_in_ms(int32_t value) {
  _internal_set_delay_in_ms(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.SendKeystrokeEventsProto.delay_in_ms)
}

// -------------------------------------------------------------------

// SendKeyEventProto

// optional .autofill_assistant.ClientIdProto client_id = 1;
inline bool SendKeyEventProto::_internal_has_client_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || client_id_ != nullptr);
  return value;
}
inline bool SendKeyEventProto::has_client_id() const {
  return _internal_has_client_id();
}
inline void SendKeyEventProto::clear_client_id() {
  if (client_id_ != nullptr) client_id_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::autofill_assistant::ClientIdProto& SendKeyEventProto::_internal_client_id() const {
  const ::autofill_assistant::ClientIdProto* p = client_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::ClientIdProto&>(
      ::autofill_assistant::_ClientIdProto_default_instance_);
}
inline const ::autofill_assistant::ClientIdProto& SendKeyEventProto::client_id() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.SendKeyEventProto.client_id)
  return _internal_client_id();
}
inline void SendKeyEventProto::unsafe_arena_set_allocated_client_id(
    ::autofill_assistant::ClientIdProto* client_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(client_id_);
  }
  client_id_ = client_id;
  if (client_id) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.SendKeyEventProto.client_id)
}
inline ::autofill_assistant::ClientIdProto* SendKeyEventProto::release_client_id() {
  _has_bits_[0] &= ~0x00000001u;
  ::autofill_assistant::ClientIdProto* temp = client_id_;
  client_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::ClientIdProto* SendKeyEventProto::unsafe_arena_release_client_id() {
  // @@protoc_insertion_point(field_release:autofill_assistant.SendKeyEventProto.client_id)
  _has_bits_[0] &= ~0x00000001u;
  ::autofill_assistant::ClientIdProto* temp = client_id_;
  client_id_ = nullptr;
  return temp;
}
inline ::autofill_assistant::ClientIdProto* SendKeyEventProto::_internal_mutable_client_id() {
  _has_bits_[0] |= 0x00000001u;
  if (client_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::ClientIdProto>(GetArenaForAllocation());
    client_id_ = p;
  }
  return client_id_;
}
inline ::autofill_assistant::ClientIdProto* SendKeyEventProto::mutable_client_id() {
  ::autofill_assistant::ClientIdProto* _msg = _internal_mutable_client_id();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.SendKeyEventProto.client_id)
  return _msg;
}
inline void SendKeyEventProto::set_allocated_client_id(::autofill_assistant::ClientIdProto* client_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete client_id_;
  }
  if (client_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(client_id);
    if (message_arena != submessage_arena) {
      client_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, client_id, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  client_id_ = client_id;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.SendKeyEventProto.client_id)
}

// optional .autofill_assistant.KeyEvent key_event = 2;
inline bool SendKeyEventProto::_internal_has_key_event() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || key_event_ != nullptr);
  return value;
}
inline bool SendKeyEventProto::has_key_event() const {
  return _internal_has_key_event();
}
inline const ::autofill_assistant::KeyEvent& SendKeyEventProto::_internal_key_event() const {
  const ::autofill_assistant::KeyEvent* p = key_event_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::KeyEvent&>(
      ::autofill_assistant::_KeyEvent_default_instance_);
}
inline const ::autofill_assistant::KeyEvent& SendKeyEventProto::key_event() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.SendKeyEventProto.key_event)
  return _internal_key_event();
}
inline void SendKeyEventProto::unsafe_arena_set_allocated_key_event(
    ::autofill_assistant::KeyEvent* key_event) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(key_event_);
  }
  key_event_ = key_event;
  if (key_event) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.SendKeyEventProto.key_event)
}
inline ::autofill_assistant::KeyEvent* SendKeyEventProto::release_key_event() {
  _has_bits_[0] &= ~0x00000002u;
  ::autofill_assistant::KeyEvent* temp = key_event_;
  key_event_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::KeyEvent* SendKeyEventProto::unsafe_arena_release_key_event() {
  // @@protoc_insertion_point(field_release:autofill_assistant.SendKeyEventProto.key_event)
  _has_bits_[0] &= ~0x00000002u;
  ::autofill_assistant::KeyEvent* temp = key_event_;
  key_event_ = nullptr;
  return temp;
}
inline ::autofill_assistant::KeyEvent* SendKeyEventProto::_internal_mutable_key_event() {
  _has_bits_[0] |= 0x00000002u;
  if (key_event_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::KeyEvent>(GetArenaForAllocation());
    key_event_ = p;
  }
  return key_event_;
}
inline ::autofill_assistant::KeyEvent* SendKeyEventProto::mutable_key_event() {
  ::autofill_assistant::KeyEvent* _msg = _internal_mutable_key_event();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.SendKeyEventProto.key_event)
  return _msg;
}
inline void SendKeyEventProto::set_allocated_key_event(::autofill_assistant::KeyEvent* key_event) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(key_event_);
  }
  if (key_event) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(key_event));
    if (message_arena != submessage_arena) {
      key_event = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, key_event, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  key_event_ = key_event;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.SendKeyEventProto.key_event)
}

// -------------------------------------------------------------------

// SendChangeEventProto

// optional .autofill_assistant.ClientIdProto client_id = 1;
inline bool SendChangeEventProto::_internal_has_client_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || client_id_ != nullptr);
  return value;
}
inline bool SendChangeEventProto::has_client_id() const {
  return _internal_has_client_id();
}
inline void SendChangeEventProto::clear_client_id() {
  if (client_id_ != nullptr) client_id_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::autofill_assistant::ClientIdProto& SendChangeEventProto::_internal_client_id() const {
  const ::autofill_assistant::ClientIdProto* p = client_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::ClientIdProto&>(
      ::autofill_assistant::_ClientIdProto_default_instance_);
}
inline const ::autofill_assistant::ClientIdProto& SendChangeEventProto::client_id() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.SendChangeEventProto.client_id)
  return _internal_client_id();
}
inline void SendChangeEventProto::unsafe_arena_set_allocated_client_id(
    ::autofill_assistant::ClientIdProto* client_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(client_id_);
  }
  client_id_ = client_id;
  if (client_id) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.SendChangeEventProto.client_id)
}
inline ::autofill_assistant::ClientIdProto* SendChangeEventProto::release_client_id() {
  _has_bits_[0] &= ~0x00000001u;
  ::autofill_assistant::ClientIdProto* temp = client_id_;
  client_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::ClientIdProto* SendChangeEventProto::unsafe_arena_release_client_id() {
  // @@protoc_insertion_point(field_release:autofill_assistant.SendChangeEventProto.client_id)
  _has_bits_[0] &= ~0x00000001u;
  ::autofill_assistant::ClientIdProto* temp = client_id_;
  client_id_ = nullptr;
  return temp;
}
inline ::autofill_assistant::ClientIdProto* SendChangeEventProto::_internal_mutable_client_id() {
  _has_bits_[0] |= 0x00000001u;
  if (client_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::ClientIdProto>(GetArenaForAllocation());
    client_id_ = p;
  }
  return client_id_;
}
inline ::autofill_assistant::ClientIdProto* SendChangeEventProto::mutable_client_id() {
  ::autofill_assistant::ClientIdProto* _msg = _internal_mutable_client_id();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.SendChangeEventProto.client_id)
  return _msg;
}
inline void SendChangeEventProto::set_allocated_client_id(::autofill_assistant::ClientIdProto* client_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete client_id_;
  }
  if (client_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(client_id);
    if (message_arena != submessage_arena) {
      client_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, client_id, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  client_id_ = client_id;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.SendChangeEventProto.client_id)
}

// -------------------------------------------------------------------

// SetElementAttributeProto

// optional .autofill_assistant.ClientIdProto client_id = 1;
inline bool SetElementAttributeProto::_internal_has_client_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || client_id_ != nullptr);
  return value;
}
inline bool SetElementAttributeProto::has_client_id() const {
  return _internal_has_client_id();
}
inline void SetElementAttributeProto::clear_client_id() {
  if (client_id_ != nullptr) client_id_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::autofill_assistant::ClientIdProto& SetElementAttributeProto::_internal_client_id() const {
  const ::autofill_assistant::ClientIdProto* p = client_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::ClientIdProto&>(
      ::autofill_assistant::_ClientIdProto_default_instance_);
}
inline const ::autofill_assistant::ClientIdProto& SetElementAttributeProto::client_id() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.SetElementAttributeProto.client_id)
  return _internal_client_id();
}
inline void SetElementAttributeProto::unsafe_arena_set_allocated_client_id(
    ::autofill_assistant::ClientIdProto* client_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(client_id_);
  }
  client_id_ = client_id;
  if (client_id) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.SetElementAttributeProto.client_id)
}
inline ::autofill_assistant::ClientIdProto* SetElementAttributeProto::release_client_id() {
  _has_bits_[0] &= ~0x00000001u;
  ::autofill_assistant::ClientIdProto* temp = client_id_;
  client_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::ClientIdProto* SetElementAttributeProto::unsafe_arena_release_client_id() {
  // @@protoc_insertion_point(field_release:autofill_assistant.SetElementAttributeProto.client_id)
  _has_bits_[0] &= ~0x00000001u;
  ::autofill_assistant::ClientIdProto* temp = client_id_;
  client_id_ = nullptr;
  return temp;
}
inline ::autofill_assistant::ClientIdProto* SetElementAttributeProto::_internal_mutable_client_id() {
  _has_bits_[0] |= 0x00000001u;
  if (client_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::ClientIdProto>(GetArenaForAllocation());
    client_id_ = p;
  }
  return client_id_;
}
inline ::autofill_assistant::ClientIdProto* SetElementAttributeProto::mutable_client_id() {
  ::autofill_assistant::ClientIdProto* _msg = _internal_mutable_client_id();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.SetElementAttributeProto.client_id)
  return _msg;
}
inline void SetElementAttributeProto::set_allocated_client_id(::autofill_assistant::ClientIdProto* client_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete client_id_;
  }
  if (client_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(client_id);
    if (message_arena != submessage_arena) {
      client_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, client_id, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  client_id_ = client_id;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.SetElementAttributeProto.client_id)
}

// repeated string attribute = 2;
inline int SetElementAttributeProto::_internal_attribute_size() const {
  return attribute_.size();
}
inline int SetElementAttributeProto::attribute_size() const {
  return _internal_attribute_size();
}
inline void SetElementAttributeProto::clear_attribute() {
  attribute_.Clear();
}
inline std::string* SetElementAttributeProto::add_attribute() {
  std::string* _s = _internal_add_attribute();
  // @@protoc_insertion_point(field_add_mutable:autofill_assistant.SetElementAttributeProto.attribute)
  return _s;
}
inline const std::string& SetElementAttributeProto::_internal_attribute(int index) const {
  return attribute_.Get(index);
}
inline const std::string& SetElementAttributeProto::attribute(int index) const {
  // @@protoc_insertion_point(field_get:autofill_assistant.SetElementAttributeProto.attribute)
  return _internal_attribute(index);
}
inline std::string* SetElementAttributeProto::mutable_attribute(int index) {
  // @@protoc_insertion_point(field_mutable:autofill_assistant.SetElementAttributeProto.attribute)
  return attribute_.Mutable(index);
}
inline void SetElementAttributeProto::set_attribute(int index, const std::string& value) {
  attribute_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.SetElementAttributeProto.attribute)
}
inline void SetElementAttributeProto::set_attribute(int index, std::string&& value) {
  attribute_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:autofill_assistant.SetElementAttributeProto.attribute)
}
inline void SetElementAttributeProto::set_attribute(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  attribute_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:autofill_assistant.SetElementAttributeProto.attribute)
}
inline void SetElementAttributeProto::set_attribute(int index, const char* value, size_t size) {
  attribute_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:autofill_assistant.SetElementAttributeProto.attribute)
}
inline std::string* SetElementAttributeProto::_internal_add_attribute() {
  return attribute_.Add();
}
inline void SetElementAttributeProto::add_attribute(const std::string& value) {
  attribute_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:autofill_assistant.SetElementAttributeProto.attribute)
}
inline void SetElementAttributeProto::add_attribute(std::string&& value) {
  attribute_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:autofill_assistant.SetElementAttributeProto.attribute)
}
inline void SetElementAttributeProto::add_attribute(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  attribute_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:autofill_assistant.SetElementAttributeProto.attribute)
}
inline void SetElementAttributeProto::add_attribute(const char* value, size_t size) {
  attribute_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:autofill_assistant.SetElementAttributeProto.attribute)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
SetElementAttributeProto::attribute() const {
  // @@protoc_insertion_point(field_list:autofill_assistant.SetElementAttributeProto.attribute)
  return attribute_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
SetElementAttributeProto::mutable_attribute() {
  // @@protoc_insertion_point(field_mutable_list:autofill_assistant.SetElementAttributeProto.attribute)
  return &attribute_;
}

// optional .autofill_assistant.TextValue value = 3;
inline bool SetElementAttributeProto::_internal_has_value() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || value_ != nullptr);
  return value;
}
inline bool SetElementAttributeProto::has_value() const {
  return _internal_has_value();
}
inline const ::autofill_assistant::TextValue& SetElementAttributeProto::_internal_value() const {
  const ::autofill_assistant::TextValue* p = value_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::TextValue&>(
      ::autofill_assistant::_TextValue_default_instance_);
}
inline const ::autofill_assistant::TextValue& SetElementAttributeProto::value() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.SetElementAttributeProto.value)
  return _internal_value();
}
inline void SetElementAttributeProto::unsafe_arena_set_allocated_value(
    ::autofill_assistant::TextValue* value) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(value_);
  }
  value_ = value;
  if (value) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.SetElementAttributeProto.value)
}
inline ::autofill_assistant::TextValue* SetElementAttributeProto::release_value() {
  _has_bits_[0] &= ~0x00000002u;
  ::autofill_assistant::TextValue* temp = value_;
  value_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::TextValue* SetElementAttributeProto::unsafe_arena_release_value() {
  // @@protoc_insertion_point(field_release:autofill_assistant.SetElementAttributeProto.value)
  _has_bits_[0] &= ~0x00000002u;
  ::autofill_assistant::TextValue* temp = value_;
  value_ = nullptr;
  return temp;
}
inline ::autofill_assistant::TextValue* SetElementAttributeProto::_internal_mutable_value() {
  _has_bits_[0] |= 0x00000002u;
  if (value_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::TextValue>(GetArenaForAllocation());
    value_ = p;
  }
  return value_;
}
inline ::autofill_assistant::TextValue* SetElementAttributeProto::mutable_value() {
  ::autofill_assistant::TextValue* _msg = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.SetElementAttributeProto.value)
  return _msg;
}
inline void SetElementAttributeProto::set_allocated_value(::autofill_assistant::TextValue* value) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(value_);
  }
  if (value) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(value));
    if (message_arena != submessage_arena) {
      value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  value_ = value;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.SetElementAttributeProto.value)
}

// -------------------------------------------------------------------

// SelectFieldValueProto

// optional .autofill_assistant.ClientIdProto client_id = 1;
inline bool SelectFieldValueProto::_internal_has_client_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || client_id_ != nullptr);
  return value;
}
inline bool SelectFieldValueProto::has_client_id() const {
  return _internal_has_client_id();
}
inline void SelectFieldValueProto::clear_client_id() {
  if (client_id_ != nullptr) client_id_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::autofill_assistant::ClientIdProto& SelectFieldValueProto::_internal_client_id() const {
  const ::autofill_assistant::ClientIdProto* p = client_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::ClientIdProto&>(
      ::autofill_assistant::_ClientIdProto_default_instance_);
}
inline const ::autofill_assistant::ClientIdProto& SelectFieldValueProto::client_id() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.SelectFieldValueProto.client_id)
  return _internal_client_id();
}
inline void SelectFieldValueProto::unsafe_arena_set_allocated_client_id(
    ::autofill_assistant::ClientIdProto* client_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(client_id_);
  }
  client_id_ = client_id;
  if (client_id) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.SelectFieldValueProto.client_id)
}
inline ::autofill_assistant::ClientIdProto* SelectFieldValueProto::release_client_id() {
  _has_bits_[0] &= ~0x00000001u;
  ::autofill_assistant::ClientIdProto* temp = client_id_;
  client_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::ClientIdProto* SelectFieldValueProto::unsafe_arena_release_client_id() {
  // @@protoc_insertion_point(field_release:autofill_assistant.SelectFieldValueProto.client_id)
  _has_bits_[0] &= ~0x00000001u;
  ::autofill_assistant::ClientIdProto* temp = client_id_;
  client_id_ = nullptr;
  return temp;
}
inline ::autofill_assistant::ClientIdProto* SelectFieldValueProto::_internal_mutable_client_id() {
  _has_bits_[0] |= 0x00000001u;
  if (client_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::ClientIdProto>(GetArenaForAllocation());
    client_id_ = p;
  }
  return client_id_;
}
inline ::autofill_assistant::ClientIdProto* SelectFieldValueProto::mutable_client_id() {
  ::autofill_assistant::ClientIdProto* _msg = _internal_mutable_client_id();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.SelectFieldValueProto.client_id)
  return _msg;
}
inline void SelectFieldValueProto::set_allocated_client_id(::autofill_assistant::ClientIdProto* client_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete client_id_;
  }
  if (client_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(client_id);
    if (message_arena != submessage_arena) {
      client_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, client_id, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  client_id_ = client_id;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.SelectFieldValueProto.client_id)
}

// -------------------------------------------------------------------

// FocusFieldProto

// optional .autofill_assistant.ClientIdProto client_id = 1;
inline bool FocusFieldProto::_internal_has_client_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || client_id_ != nullptr);
  return value;
}
inline bool FocusFieldProto::has_client_id() const {
  return _internal_has_client_id();
}
inline void FocusFieldProto::clear_client_id() {
  if (client_id_ != nullptr) client_id_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::autofill_assistant::ClientIdProto& FocusFieldProto::_internal_client_id() const {
  const ::autofill_assistant::ClientIdProto* p = client_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::ClientIdProto&>(
      ::autofill_assistant::_ClientIdProto_default_instance_);
}
inline const ::autofill_assistant::ClientIdProto& FocusFieldProto::client_id() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.FocusFieldProto.client_id)
  return _internal_client_id();
}
inline void FocusFieldProto::unsafe_arena_set_allocated_client_id(
    ::autofill_assistant::ClientIdProto* client_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(client_id_);
  }
  client_id_ = client_id;
  if (client_id) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.FocusFieldProto.client_id)
}
inline ::autofill_assistant::ClientIdProto* FocusFieldProto::release_client_id() {
  _has_bits_[0] &= ~0x00000001u;
  ::autofill_assistant::ClientIdProto* temp = client_id_;
  client_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::ClientIdProto* FocusFieldProto::unsafe_arena_release_client_id() {
  // @@protoc_insertion_point(field_release:autofill_assistant.FocusFieldProto.client_id)
  _has_bits_[0] &= ~0x00000001u;
  ::autofill_assistant::ClientIdProto* temp = client_id_;
  client_id_ = nullptr;
  return temp;
}
inline ::autofill_assistant::ClientIdProto* FocusFieldProto::_internal_mutable_client_id() {
  _has_bits_[0] |= 0x00000001u;
  if (client_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::ClientIdProto>(GetArenaForAllocation());
    client_id_ = p;
  }
  return client_id_;
}
inline ::autofill_assistant::ClientIdProto* FocusFieldProto::mutable_client_id() {
  ::autofill_assistant::ClientIdProto* _msg = _internal_mutable_client_id();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.FocusFieldProto.client_id)
  return _msg;
}
inline void FocusFieldProto::set_allocated_client_id(::autofill_assistant::ClientIdProto* client_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete client_id_;
  }
  if (client_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(client_id);
    if (message_arena != submessage_arena) {
      client_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, client_id, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  client_id_ = client_id;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.FocusFieldProto.client_id)
}

// -------------------------------------------------------------------

// BlurFieldProto

// optional .autofill_assistant.ClientIdProto client_id = 1;
inline bool BlurFieldProto::_internal_has_client_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || client_id_ != nullptr);
  return value;
}
inline bool BlurFieldProto::has_client_id() const {
  return _internal_has_client_id();
}
inline void BlurFieldProto::clear_client_id() {
  if (client_id_ != nullptr) client_id_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::autofill_assistant::ClientIdProto& BlurFieldProto::_internal_client_id() const {
  const ::autofill_assistant::ClientIdProto* p = client_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::ClientIdProto&>(
      ::autofill_assistant::_ClientIdProto_default_instance_);
}
inline const ::autofill_assistant::ClientIdProto& BlurFieldProto::client_id() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.BlurFieldProto.client_id)
  return _internal_client_id();
}
inline void BlurFieldProto::unsafe_arena_set_allocated_client_id(
    ::autofill_assistant::ClientIdProto* client_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(client_id_);
  }
  client_id_ = client_id;
  if (client_id) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.BlurFieldProto.client_id)
}
inline ::autofill_assistant::ClientIdProto* BlurFieldProto::release_client_id() {
  _has_bits_[0] &= ~0x00000001u;
  ::autofill_assistant::ClientIdProto* temp = client_id_;
  client_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::ClientIdProto* BlurFieldProto::unsafe_arena_release_client_id() {
  // @@protoc_insertion_point(field_release:autofill_assistant.BlurFieldProto.client_id)
  _has_bits_[0] &= ~0x00000001u;
  ::autofill_assistant::ClientIdProto* temp = client_id_;
  client_id_ = nullptr;
  return temp;
}
inline ::autofill_assistant::ClientIdProto* BlurFieldProto::_internal_mutable_client_id() {
  _has_bits_[0] |= 0x00000001u;
  if (client_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::ClientIdProto>(GetArenaForAllocation());
    client_id_ = p;
  }
  return client_id_;
}
inline ::autofill_assistant::ClientIdProto* BlurFieldProto::mutable_client_id() {
  ::autofill_assistant::ClientIdProto* _msg = _internal_mutable_client_id();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.BlurFieldProto.client_id)
  return _msg;
}
inline void BlurFieldProto::set_allocated_client_id(::autofill_assistant::ClientIdProto* client_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete client_id_;
  }
  if (client_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(client_id);
    if (message_arena != submessage_arena) {
      client_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, client_id, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  client_id_ = client_id;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.BlurFieldProto.client_id)
}

// -------------------------------------------------------------------

// SelectOptionElementProto

// optional .autofill_assistant.ClientIdProto select_id = 1;
inline bool SelectOptionElementProto::_internal_has_select_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || select_id_ != nullptr);
  return value;
}
inline bool SelectOptionElementProto::has_select_id() const {
  return _internal_has_select_id();
}
inline void SelectOptionElementProto::clear_select_id() {
  if (select_id_ != nullptr) select_id_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::autofill_assistant::ClientIdProto& SelectOptionElementProto::_internal_select_id() const {
  const ::autofill_assistant::ClientIdProto* p = select_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::ClientIdProto&>(
      ::autofill_assistant::_ClientIdProto_default_instance_);
}
inline const ::autofill_assistant::ClientIdProto& SelectOptionElementProto::select_id() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.SelectOptionElementProto.select_id)
  return _internal_select_id();
}
inline void SelectOptionElementProto::unsafe_arena_set_allocated_select_id(
    ::autofill_assistant::ClientIdProto* select_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(select_id_);
  }
  select_id_ = select_id;
  if (select_id) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.SelectOptionElementProto.select_id)
}
inline ::autofill_assistant::ClientIdProto* SelectOptionElementProto::release_select_id() {
  _has_bits_[0] &= ~0x00000001u;
  ::autofill_assistant::ClientIdProto* temp = select_id_;
  select_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::ClientIdProto* SelectOptionElementProto::unsafe_arena_release_select_id() {
  // @@protoc_insertion_point(field_release:autofill_assistant.SelectOptionElementProto.select_id)
  _has_bits_[0] &= ~0x00000001u;
  ::autofill_assistant::ClientIdProto* temp = select_id_;
  select_id_ = nullptr;
  return temp;
}
inline ::autofill_assistant::ClientIdProto* SelectOptionElementProto::_internal_mutable_select_id() {
  _has_bits_[0] |= 0x00000001u;
  if (select_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::ClientIdProto>(GetArenaForAllocation());
    select_id_ = p;
  }
  return select_id_;
}
inline ::autofill_assistant::ClientIdProto* SelectOptionElementProto::mutable_select_id() {
  ::autofill_assistant::ClientIdProto* _msg = _internal_mutable_select_id();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.SelectOptionElementProto.select_id)
  return _msg;
}
inline void SelectOptionElementProto::set_allocated_select_id(::autofill_assistant::ClientIdProto* select_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete select_id_;
  }
  if (select_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(select_id);
    if (message_arena != submessage_arena) {
      select_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, select_id, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  select_id_ = select_id;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.SelectOptionElementProto.select_id)
}

// optional .autofill_assistant.ClientIdProto option_id = 2;
inline bool SelectOptionElementProto::_internal_has_option_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || option_id_ != nullptr);
  return value;
}
inline bool SelectOptionElementProto::has_option_id() const {
  return _internal_has_option_id();
}
inline void SelectOptionElementProto::clear_option_id() {
  if (option_id_ != nullptr) option_id_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::autofill_assistant::ClientIdProto& SelectOptionElementProto::_internal_option_id() const {
  const ::autofill_assistant::ClientIdProto* p = option_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::ClientIdProto&>(
      ::autofill_assistant::_ClientIdProto_default_instance_);
}
inline const ::autofill_assistant::ClientIdProto& SelectOptionElementProto::option_id() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.SelectOptionElementProto.option_id)
  return _internal_option_id();
}
inline void SelectOptionElementProto::unsafe_arena_set_allocated_option_id(
    ::autofill_assistant::ClientIdProto* option_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(option_id_);
  }
  option_id_ = option_id;
  if (option_id) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.SelectOptionElementProto.option_id)
}
inline ::autofill_assistant::ClientIdProto* SelectOptionElementProto::release_option_id() {
  _has_bits_[0] &= ~0x00000002u;
  ::autofill_assistant::ClientIdProto* temp = option_id_;
  option_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::ClientIdProto* SelectOptionElementProto::unsafe_arena_release_option_id() {
  // @@protoc_insertion_point(field_release:autofill_assistant.SelectOptionElementProto.option_id)
  _has_bits_[0] &= ~0x00000002u;
  ::autofill_assistant::ClientIdProto* temp = option_id_;
  option_id_ = nullptr;
  return temp;
}
inline ::autofill_assistant::ClientIdProto* SelectOptionElementProto::_internal_mutable_option_id() {
  _has_bits_[0] |= 0x00000002u;
  if (option_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::ClientIdProto>(GetArenaForAllocation());
    option_id_ = p;
  }
  return option_id_;
}
inline ::autofill_assistant::ClientIdProto* SelectOptionElementProto::mutable_option_id() {
  ::autofill_assistant::ClientIdProto* _msg = _internal_mutable_option_id();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.SelectOptionElementProto.option_id)
  return _msg;
}
inline void SelectOptionElementProto::set_allocated_option_id(::autofill_assistant::ClientIdProto* option_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete option_id_;
  }
  if (option_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(option_id);
    if (message_arena != submessage_arena) {
      option_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, option_id, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  option_id_ = option_id;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.SelectOptionElementProto.option_id)
}

// -------------------------------------------------------------------

// CheckElementTagProto

// optional .autofill_assistant.ClientIdProto client_id = 1;
inline bool CheckElementTagProto::_internal_has_client_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || client_id_ != nullptr);
  return value;
}
inline bool CheckElementTagProto::has_client_id() const {
  return _internal_has_client_id();
}
inline void CheckElementTagProto::clear_client_id() {
  if (client_id_ != nullptr) client_id_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::autofill_assistant::ClientIdProto& CheckElementTagProto::_internal_client_id() const {
  const ::autofill_assistant::ClientIdProto* p = client_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::ClientIdProto&>(
      ::autofill_assistant::_ClientIdProto_default_instance_);
}
inline const ::autofill_assistant::ClientIdProto& CheckElementTagProto::client_id() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.CheckElementTagProto.client_id)
  return _internal_client_id();
}
inline void CheckElementTagProto::unsafe_arena_set_allocated_client_id(
    ::autofill_assistant::ClientIdProto* client_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(client_id_);
  }
  client_id_ = client_id;
  if (client_id) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.CheckElementTagProto.client_id)
}
inline ::autofill_assistant::ClientIdProto* CheckElementTagProto::release_client_id() {
  _has_bits_[0] &= ~0x00000001u;
  ::autofill_assistant::ClientIdProto* temp = client_id_;
  client_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::ClientIdProto* CheckElementTagProto::unsafe_arena_release_client_id() {
  // @@protoc_insertion_point(field_release:autofill_assistant.CheckElementTagProto.client_id)
  _has_bits_[0] &= ~0x00000001u;
  ::autofill_assistant::ClientIdProto* temp = client_id_;
  client_id_ = nullptr;
  return temp;
}
inline ::autofill_assistant::ClientIdProto* CheckElementTagProto::_internal_mutable_client_id() {
  _has_bits_[0] |= 0x00000001u;
  if (client_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::ClientIdProto>(GetArenaForAllocation());
    client_id_ = p;
  }
  return client_id_;
}
inline ::autofill_assistant::ClientIdProto* CheckElementTagProto::mutable_client_id() {
  ::autofill_assistant::ClientIdProto* _msg = _internal_mutable_client_id();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.CheckElementTagProto.client_id)
  return _msg;
}
inline void CheckElementTagProto::set_allocated_client_id(::autofill_assistant::ClientIdProto* client_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete client_id_;
  }
  if (client_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(client_id);
    if (message_arena != submessage_arena) {
      client_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, client_id, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  client_id_ = client_id;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.CheckElementTagProto.client_id)
}

// repeated string any_of_tag = 2;
inline int CheckElementTagProto::_internal_any_of_tag_size() const {
  return any_of_tag_.size();
}
inline int CheckElementTagProto::any_of_tag_size() const {
  return _internal_any_of_tag_size();
}
inline void CheckElementTagProto::clear_any_of_tag() {
  any_of_tag_.Clear();
}
inline std::string* CheckElementTagProto::add_any_of_tag() {
  std::string* _s = _internal_add_any_of_tag();
  // @@protoc_insertion_point(field_add_mutable:autofill_assistant.CheckElementTagProto.any_of_tag)
  return _s;
}
inline const std::string& CheckElementTagProto::_internal_any_of_tag(int index) const {
  return any_of_tag_.Get(index);
}
inline const std::string& CheckElementTagProto::any_of_tag(int index) const {
  // @@protoc_insertion_point(field_get:autofill_assistant.CheckElementTagProto.any_of_tag)
  return _internal_any_of_tag(index);
}
inline std::string* CheckElementTagProto::mutable_any_of_tag(int index) {
  // @@protoc_insertion_point(field_mutable:autofill_assistant.CheckElementTagProto.any_of_tag)
  return any_of_tag_.Mutable(index);
}
inline void CheckElementTagProto::set_any_of_tag(int index, const std::string& value) {
  any_of_tag_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.CheckElementTagProto.any_of_tag)
}
inline void CheckElementTagProto::set_any_of_tag(int index, std::string&& value) {
  any_of_tag_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:autofill_assistant.CheckElementTagProto.any_of_tag)
}
inline void CheckElementTagProto::set_any_of_tag(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  any_of_tag_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:autofill_assistant.CheckElementTagProto.any_of_tag)
}
inline void CheckElementTagProto::set_any_of_tag(int index, const char* value, size_t size) {
  any_of_tag_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:autofill_assistant.CheckElementTagProto.any_of_tag)
}
inline std::string* CheckElementTagProto::_internal_add_any_of_tag() {
  return any_of_tag_.Add();
}
inline void CheckElementTagProto::add_any_of_tag(const std::string& value) {
  any_of_tag_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:autofill_assistant.CheckElementTagProto.any_of_tag)
}
inline void CheckElementTagProto::add_any_of_tag(std::string&& value) {
  any_of_tag_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:autofill_assistant.CheckElementTagProto.any_of_tag)
}
inline void CheckElementTagProto::add_any_of_tag(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  any_of_tag_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:autofill_assistant.CheckElementTagProto.any_of_tag)
}
inline void CheckElementTagProto::add_any_of_tag(const char* value, size_t size) {
  any_of_tag_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:autofill_assistant.CheckElementTagProto.any_of_tag)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
CheckElementTagProto::any_of_tag() const {
  // @@protoc_insertion_point(field_list:autofill_assistant.CheckElementTagProto.any_of_tag)
  return any_of_tag_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
CheckElementTagProto::mutable_any_of_tag() {
  // @@protoc_insertion_point(field_mutable_list:autofill_assistant.CheckElementTagProto.any_of_tag)
  return &any_of_tag_;
}

// -------------------------------------------------------------------

// CheckOptionElementProto_Result

// optional bool match = 1;
inline bool CheckOptionElementProto_Result::_internal_has_match() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CheckOptionElementProto_Result::has_match() const {
  return _internal_has_match();
}
inline void CheckOptionElementProto_Result::clear_match() {
  match_ = false;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool CheckOptionElementProto_Result::_internal_match() const {
  return match_;
}
inline bool CheckOptionElementProto_Result::match() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.CheckOptionElementProto.Result.match)
  return _internal_match();
}
inline void CheckOptionElementProto_Result::_internal_set_match(bool value) {
  _has_bits_[0] |= 0x00000001u;
  match_ = value;
}
inline void CheckOptionElementProto_Result::set_match(bool value) {
  _internal_set_match(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.CheckOptionElementProto.Result.match)
}

// -------------------------------------------------------------------

// CheckOptionElementProto

// optional .autofill_assistant.ClientIdProto select_id = 1;
inline bool CheckOptionElementProto::_internal_has_select_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || select_id_ != nullptr);
  return value;
}
inline bool CheckOptionElementProto::has_select_id() const {
  return _internal_has_select_id();
}
inline void CheckOptionElementProto::clear_select_id() {
  if (select_id_ != nullptr) select_id_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::autofill_assistant::ClientIdProto& CheckOptionElementProto::_internal_select_id() const {
  const ::autofill_assistant::ClientIdProto* p = select_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::ClientIdProto&>(
      ::autofill_assistant::_ClientIdProto_default_instance_);
}
inline const ::autofill_assistant::ClientIdProto& CheckOptionElementProto::select_id() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.CheckOptionElementProto.select_id)
  return _internal_select_id();
}
inline void CheckOptionElementProto::unsafe_arena_set_allocated_select_id(
    ::autofill_assistant::ClientIdProto* select_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(select_id_);
  }
  select_id_ = select_id;
  if (select_id) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.CheckOptionElementProto.select_id)
}
inline ::autofill_assistant::ClientIdProto* CheckOptionElementProto::release_select_id() {
  _has_bits_[0] &= ~0x00000001u;
  ::autofill_assistant::ClientIdProto* temp = select_id_;
  select_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::ClientIdProto* CheckOptionElementProto::unsafe_arena_release_select_id() {
  // @@protoc_insertion_point(field_release:autofill_assistant.CheckOptionElementProto.select_id)
  _has_bits_[0] &= ~0x00000001u;
  ::autofill_assistant::ClientIdProto* temp = select_id_;
  select_id_ = nullptr;
  return temp;
}
inline ::autofill_assistant::ClientIdProto* CheckOptionElementProto::_internal_mutable_select_id() {
  _has_bits_[0] |= 0x00000001u;
  if (select_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::ClientIdProto>(GetArenaForAllocation());
    select_id_ = p;
  }
  return select_id_;
}
inline ::autofill_assistant::ClientIdProto* CheckOptionElementProto::mutable_select_id() {
  ::autofill_assistant::ClientIdProto* _msg = _internal_mutable_select_id();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.CheckOptionElementProto.select_id)
  return _msg;
}
inline void CheckOptionElementProto::set_allocated_select_id(::autofill_assistant::ClientIdProto* select_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete select_id_;
  }
  if (select_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(select_id);
    if (message_arena != submessage_arena) {
      select_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, select_id, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  select_id_ = select_id;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.CheckOptionElementProto.select_id)
}

// optional .autofill_assistant.ClientIdProto option_id = 2;
inline bool CheckOptionElementProto::_internal_has_option_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || option_id_ != nullptr);
  return value;
}
inline bool CheckOptionElementProto::has_option_id() const {
  return _internal_has_option_id();
}
inline void CheckOptionElementProto::clear_option_id() {
  if (option_id_ != nullptr) option_id_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::autofill_assistant::ClientIdProto& CheckOptionElementProto::_internal_option_id() const {
  const ::autofill_assistant::ClientIdProto* p = option_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::ClientIdProto&>(
      ::autofill_assistant::_ClientIdProto_default_instance_);
}
inline const ::autofill_assistant::ClientIdProto& CheckOptionElementProto::option_id() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.CheckOptionElementProto.option_id)
  return _internal_option_id();
}
inline void CheckOptionElementProto::unsafe_arena_set_allocated_option_id(
    ::autofill_assistant::ClientIdProto* option_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(option_id_);
  }
  option_id_ = option_id;
  if (option_id) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.CheckOptionElementProto.option_id)
}
inline ::autofill_assistant::ClientIdProto* CheckOptionElementProto::release_option_id() {
  _has_bits_[0] &= ~0x00000002u;
  ::autofill_assistant::ClientIdProto* temp = option_id_;
  option_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::ClientIdProto* CheckOptionElementProto::unsafe_arena_release_option_id() {
  // @@protoc_insertion_point(field_release:autofill_assistant.CheckOptionElementProto.option_id)
  _has_bits_[0] &= ~0x00000002u;
  ::autofill_assistant::ClientIdProto* temp = option_id_;
  option_id_ = nullptr;
  return temp;
}
inline ::autofill_assistant::ClientIdProto* CheckOptionElementProto::_internal_mutable_option_id() {
  _has_bits_[0] |= 0x00000002u;
  if (option_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::ClientIdProto>(GetArenaForAllocation());
    option_id_ = p;
  }
  return option_id_;
}
inline ::autofill_assistant::ClientIdProto* CheckOptionElementProto::mutable_option_id() {
  ::autofill_assistant::ClientIdProto* _msg = _internal_mutable_option_id();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.CheckOptionElementProto.option_id)
  return _msg;
}
inline void CheckOptionElementProto::set_allocated_option_id(::autofill_assistant::ClientIdProto* option_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete option_id_;
  }
  if (option_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(option_id);
    if (message_arena != submessage_arena) {
      option_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, option_id, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  option_id_ = option_id;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.CheckOptionElementProto.option_id)
}

// optional bool mismatch_should_fail = 3;
inline bool CheckOptionElementProto::_internal_has_mismatch_should_fail() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CheckOptionElementProto::has_mismatch_should_fail() const {
  return _internal_has_mismatch_should_fail();
}
inline void CheckOptionElementProto::clear_mismatch_should_fail() {
  mismatch_should_fail_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool CheckOptionElementProto::_internal_mismatch_should_fail() const {
  return mismatch_should_fail_;
}
inline bool CheckOptionElementProto::mismatch_should_fail() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.CheckOptionElementProto.mismatch_should_fail)
  return _internal_mismatch_should_fail();
}
inline void CheckOptionElementProto::_internal_set_mismatch_should_fail(bool value) {
  _has_bits_[0] |= 0x00000004u;
  mismatch_should_fail_ = value;
}
inline void CheckOptionElementProto::set_mismatch_should_fail(bool value) {
  _internal_set_mismatch_should_fail(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.CheckOptionElementProto.mismatch_should_fail)
}

// -------------------------------------------------------------------

// ExecuteJsProto

// optional .autofill_assistant.ClientIdProto client_id = 1;
inline bool ExecuteJsProto::_internal_has_client_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || client_id_ != nullptr);
  return value;
}
inline bool ExecuteJsProto::has_client_id() const {
  return _internal_has_client_id();
}
inline void ExecuteJsProto::clear_client_id() {
  if (client_id_ != nullptr) client_id_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::autofill_assistant::ClientIdProto& ExecuteJsProto::_internal_client_id() const {
  const ::autofill_assistant::ClientIdProto* p = client_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::ClientIdProto&>(
      ::autofill_assistant::_ClientIdProto_default_instance_);
}
inline const ::autofill_assistant::ClientIdProto& ExecuteJsProto::client_id() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ExecuteJsProto.client_id)
  return _internal_client_id();
}
inline void ExecuteJsProto::unsafe_arena_set_allocated_client_id(
    ::autofill_assistant::ClientIdProto* client_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(client_id_);
  }
  client_id_ = client_id;
  if (client_id) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ExecuteJsProto.client_id)
}
inline ::autofill_assistant::ClientIdProto* ExecuteJsProto::release_client_id() {
  _has_bits_[0] &= ~0x00000002u;
  ::autofill_assistant::ClientIdProto* temp = client_id_;
  client_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::ClientIdProto* ExecuteJsProto::unsafe_arena_release_client_id() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ExecuteJsProto.client_id)
  _has_bits_[0] &= ~0x00000002u;
  ::autofill_assistant::ClientIdProto* temp = client_id_;
  client_id_ = nullptr;
  return temp;
}
inline ::autofill_assistant::ClientIdProto* ExecuteJsProto::_internal_mutable_client_id() {
  _has_bits_[0] |= 0x00000002u;
  if (client_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::ClientIdProto>(GetArenaForAllocation());
    client_id_ = p;
  }
  return client_id_;
}
inline ::autofill_assistant::ClientIdProto* ExecuteJsProto::mutable_client_id() {
  ::autofill_assistant::ClientIdProto* _msg = _internal_mutable_client_id();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ExecuteJsProto.client_id)
  return _msg;
}
inline void ExecuteJsProto::set_allocated_client_id(::autofill_assistant::ClientIdProto* client_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete client_id_;
  }
  if (client_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(client_id);
    if (message_arena != submessage_arena) {
      client_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, client_id, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  client_id_ = client_id;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ExecuteJsProto.client_id)
}

// optional string js_snippet = 2;
inline bool ExecuteJsProto::_internal_has_js_snippet() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ExecuteJsProto::has_js_snippet() const {
  return _internal_has_js_snippet();
}
inline void ExecuteJsProto::clear_js_snippet() {
  js_snippet_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ExecuteJsProto::js_snippet() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ExecuteJsProto.js_snippet)
  return _internal_js_snippet();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ExecuteJsProto::set_js_snippet(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 js_snippet_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.ExecuteJsProto.js_snippet)
}
inline std::string* ExecuteJsProto::mutable_js_snippet() {
  std::string* _s = _internal_mutable_js_snippet();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ExecuteJsProto.js_snippet)
  return _s;
}
inline const std::string& ExecuteJsProto::_internal_js_snippet() const {
  return js_snippet_.Get();
}
inline void ExecuteJsProto::_internal_set_js_snippet(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  js_snippet_.Set(value, GetArenaForAllocation());
}
inline std::string* ExecuteJsProto::_internal_mutable_js_snippet() {
  _has_bits_[0] |= 0x00000001u;
  return js_snippet_.Mutable(GetArenaForAllocation());
}
inline std::string* ExecuteJsProto::release_js_snippet() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ExecuteJsProto.js_snippet)
  if (!_internal_has_js_snippet()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = js_snippet_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (js_snippet_.IsDefault()) {
    js_snippet_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ExecuteJsProto::set_allocated_js_snippet(std::string* js_snippet) {
  if (js_snippet != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  js_snippet_.SetAllocated(js_snippet, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (js_snippet_.IsDefault()) {
    js_snippet_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ExecuteJsProto.js_snippet)
}

// optional int32 timeout_ms = 3;
inline bool ExecuteJsProto::_internal_has_timeout_ms() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ExecuteJsProto::has_timeout_ms() const {
  return _internal_has_timeout_ms();
}
inline void ExecuteJsProto::clear_timeout_ms() {
  timeout_ms_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline int32_t ExecuteJsProto::_internal_timeout_ms() const {
  return timeout_ms_;
}
inline int32_t ExecuteJsProto::timeout_ms() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ExecuteJsProto.timeout_ms)
  return _internal_timeout_ms();
}
inline void ExecuteJsProto::_internal_set_timeout_ms(int32_t value) {
  _has_bits_[0] |= 0x00000004u;
  timeout_ms_ = value;
}
inline void ExecuteJsProto::set_timeout_ms(int32_t value) {
  _internal_set_timeout_ms(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.ExecuteJsProto.timeout_ms)
}

// -------------------------------------------------------------------

// SetNativeValueProto

// optional .autofill_assistant.ClientIdProto client_id = 1;
inline bool SetNativeValueProto::_internal_has_client_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || client_id_ != nullptr);
  return value;
}
inline bool SetNativeValueProto::has_client_id() const {
  return _internal_has_client_id();
}
inline void SetNativeValueProto::clear_client_id() {
  if (client_id_ != nullptr) client_id_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::autofill_assistant::ClientIdProto& SetNativeValueProto::_internal_client_id() const {
  const ::autofill_assistant::ClientIdProto* p = client_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::ClientIdProto&>(
      ::autofill_assistant::_ClientIdProto_default_instance_);
}
inline const ::autofill_assistant::ClientIdProto& SetNativeValueProto::client_id() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.SetNativeValueProto.client_id)
  return _internal_client_id();
}
inline void SetNativeValueProto::unsafe_arena_set_allocated_client_id(
    ::autofill_assistant::ClientIdProto* client_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(client_id_);
  }
  client_id_ = client_id;
  if (client_id) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.SetNativeValueProto.client_id)
}
inline ::autofill_assistant::ClientIdProto* SetNativeValueProto::release_client_id() {
  _has_bits_[0] &= ~0x00000001u;
  ::autofill_assistant::ClientIdProto* temp = client_id_;
  client_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::ClientIdProto* SetNativeValueProto::unsafe_arena_release_client_id() {
  // @@protoc_insertion_point(field_release:autofill_assistant.SetNativeValueProto.client_id)
  _has_bits_[0] &= ~0x00000001u;
  ::autofill_assistant::ClientIdProto* temp = client_id_;
  client_id_ = nullptr;
  return temp;
}
inline ::autofill_assistant::ClientIdProto* SetNativeValueProto::_internal_mutable_client_id() {
  _has_bits_[0] |= 0x00000001u;
  if (client_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::ClientIdProto>(GetArenaForAllocation());
    client_id_ = p;
  }
  return client_id_;
}
inline ::autofill_assistant::ClientIdProto* SetNativeValueProto::mutable_client_id() {
  ::autofill_assistant::ClientIdProto* _msg = _internal_mutable_client_id();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.SetNativeValueProto.client_id)
  return _msg;
}
inline void SetNativeValueProto::set_allocated_client_id(::autofill_assistant::ClientIdProto* client_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete client_id_;
  }
  if (client_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(client_id);
    if (message_arena != submessage_arena) {
      client_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, client_id, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  client_id_ = client_id;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.SetNativeValueProto.client_id)
}

// optional .autofill_assistant.TextValue value = 2;
inline bool SetNativeValueProto::_internal_has_value() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || value_ != nullptr);
  return value;
}
inline bool SetNativeValueProto::has_value() const {
  return _internal_has_value();
}
inline const ::autofill_assistant::TextValue& SetNativeValueProto::_internal_value() const {
  const ::autofill_assistant::TextValue* p = value_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::TextValue&>(
      ::autofill_assistant::_TextValue_default_instance_);
}
inline const ::autofill_assistant::TextValue& SetNativeValueProto::value() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.SetNativeValueProto.value)
  return _internal_value();
}
inline void SetNativeValueProto::unsafe_arena_set_allocated_value(
    ::autofill_assistant::TextValue* value) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(value_);
  }
  value_ = value;
  if (value) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.SetNativeValueProto.value)
}
inline ::autofill_assistant::TextValue* SetNativeValueProto::release_value() {
  _has_bits_[0] &= ~0x00000002u;
  ::autofill_assistant::TextValue* temp = value_;
  value_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::TextValue* SetNativeValueProto::unsafe_arena_release_value() {
  // @@protoc_insertion_point(field_release:autofill_assistant.SetNativeValueProto.value)
  _has_bits_[0] &= ~0x00000002u;
  ::autofill_assistant::TextValue* temp = value_;
  value_ = nullptr;
  return temp;
}
inline ::autofill_assistant::TextValue* SetNativeValueProto::_internal_mutable_value() {
  _has_bits_[0] |= 0x00000002u;
  if (value_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::TextValue>(GetArenaForAllocation());
    value_ = p;
  }
  return value_;
}
inline ::autofill_assistant::TextValue* SetNativeValueProto::mutable_value() {
  ::autofill_assistant::TextValue* _msg = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.SetNativeValueProto.value)
  return _msg;
}
inline void SetNativeValueProto::set_allocated_value(::autofill_assistant::TextValue* value) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(value_);
  }
  if (value) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(value));
    if (message_arena != submessage_arena) {
      value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  value_ = value;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.SetNativeValueProto.value)
}

// -------------------------------------------------------------------

// SetNativeCheckedProto

// optional .autofill_assistant.ClientIdProto client_id = 1;
inline bool SetNativeCheckedProto::_internal_has_client_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || client_id_ != nullptr);
  return value;
}
inline bool SetNativeCheckedProto::has_client_id() const {
  return _internal_has_client_id();
}
inline void SetNativeCheckedProto::clear_client_id() {
  if (client_id_ != nullptr) client_id_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::autofill_assistant::ClientIdProto& SetNativeCheckedProto::_internal_client_id() const {
  const ::autofill_assistant::ClientIdProto* p = client_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::ClientIdProto&>(
      ::autofill_assistant::_ClientIdProto_default_instance_);
}
inline const ::autofill_assistant::ClientIdProto& SetNativeCheckedProto::client_id() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.SetNativeCheckedProto.client_id)
  return _internal_client_id();
}
inline void SetNativeCheckedProto::unsafe_arena_set_allocated_client_id(
    ::autofill_assistant::ClientIdProto* client_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(client_id_);
  }
  client_id_ = client_id;
  if (client_id) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.SetNativeCheckedProto.client_id)
}
inline ::autofill_assistant::ClientIdProto* SetNativeCheckedProto::release_client_id() {
  _has_bits_[0] &= ~0x00000001u;
  ::autofill_assistant::ClientIdProto* temp = client_id_;
  client_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::ClientIdProto* SetNativeCheckedProto::unsafe_arena_release_client_id() {
  // @@protoc_insertion_point(field_release:autofill_assistant.SetNativeCheckedProto.client_id)
  _has_bits_[0] &= ~0x00000001u;
  ::autofill_assistant::ClientIdProto* temp = client_id_;
  client_id_ = nullptr;
  return temp;
}
inline ::autofill_assistant::ClientIdProto* SetNativeCheckedProto::_internal_mutable_client_id() {
  _has_bits_[0] |= 0x00000001u;
  if (client_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::ClientIdProto>(GetArenaForAllocation());
    client_id_ = p;
  }
  return client_id_;
}
inline ::autofill_assistant::ClientIdProto* SetNativeCheckedProto::mutable_client_id() {
  ::autofill_assistant::ClientIdProto* _msg = _internal_mutable_client_id();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.SetNativeCheckedProto.client_id)
  return _msg;
}
inline void SetNativeCheckedProto::set_allocated_client_id(::autofill_assistant::ClientIdProto* client_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete client_id_;
  }
  if (client_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(client_id);
    if (message_arena != submessage_arena) {
      client_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, client_id, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  client_id_ = client_id;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.SetNativeCheckedProto.client_id)
}

// optional bool checked = 2;
inline bool SetNativeCheckedProto::_internal_has_checked() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SetNativeCheckedProto::has_checked() const {
  return _internal_has_checked();
}
inline void SetNativeCheckedProto::clear_checked() {
  checked_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool SetNativeCheckedProto::_internal_checked() const {
  return checked_;
}
inline bool SetNativeCheckedProto::checked() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.SetNativeCheckedProto.checked)
  return _internal_checked();
}
inline void SetNativeCheckedProto::_internal_set_checked(bool value) {
  _has_bits_[0] |= 0x00000002u;
  checked_ = value;
}
inline void SetNativeCheckedProto::set_checked(bool value) {
  _internal_set_checked(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.SetNativeCheckedProto.checked)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace autofill_assistant

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_components_2fautofill_5fassistant_2fbrowser_2fdom_5faction_2eproto
