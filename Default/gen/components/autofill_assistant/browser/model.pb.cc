// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: components/autofill_assistant/browser/model.proto

#include "components/autofill_assistant/browser/model.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace autofill_assistant {
PROTOBUF_CONSTEXPR ModelProto_ModelValue::ModelProto_ModelValue(
    ::_pbi::ConstantInitialized)
  : identifier_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , value_(nullptr){}
struct ModelProto_ModelValueDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ModelProto_ModelValueDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ModelProto_ModelValueDefaultTypeInternal() {}
  union {
    ModelProto_ModelValue _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ModelProto_ModelValueDefaultTypeInternal _ModelProto_ModelValue_default_instance_;
PROTOBUF_CONSTEXPR ModelProto::ModelProto(
    ::_pbi::ConstantInitialized)
  : values_(){}
struct ModelProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ModelProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ModelProtoDefaultTypeInternal() {}
  union {
    ModelProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ModelProtoDefaultTypeInternal _ModelProto_default_instance_;
PROTOBUF_CONSTEXPR ValueProto::ValueProto(
    ::_pbi::ConstantInitialized)
  : is_client_side_only_(false)
  , _oneof_case_{}{}
struct ValueProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ValueProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ValueProtoDefaultTypeInternal() {}
  union {
    ValueProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ValueProtoDefaultTypeInternal _ValueProto_default_instance_;
PROTOBUF_CONSTEXPR ValueReferenceProto::ValueReferenceProto(
    ::_pbi::ConstantInitialized)
  : _oneof_case_{}{}
struct ValueReferenceProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ValueReferenceProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ValueReferenceProtoDefaultTypeInternal() {}
  union {
    ValueReferenceProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ValueReferenceProtoDefaultTypeInternal _ValueReferenceProto_default_instance_;
PROTOBUF_CONSTEXPR StringList::StringList(
    ::_pbi::ConstantInitialized)
  : values_(){}
struct StringListDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StringListDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~StringListDefaultTypeInternal() {}
  union {
    StringList _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StringListDefaultTypeInternal _StringList_default_instance_;
PROTOBUF_CONSTEXPR BooleanList::BooleanList(
    ::_pbi::ConstantInitialized)
  : values_(){}
struct BooleanListDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BooleanListDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~BooleanListDefaultTypeInternal() {}
  union {
    BooleanList _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BooleanListDefaultTypeInternal _BooleanList_default_instance_;
PROTOBUF_CONSTEXPR IntList::IntList(
    ::_pbi::ConstantInitialized)
  : values_(){}
struct IntListDefaultTypeInternal {
  PROTOBUF_CONSTEXPR IntListDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~IntListDefaultTypeInternal() {}
  union {
    IntList _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 IntListDefaultTypeInternal _IntList_default_instance_;
PROTOBUF_CONSTEXPR UserActionList::UserActionList(
    ::_pbi::ConstantInitialized)
  : values_(){}
struct UserActionListDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UserActionListDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~UserActionListDefaultTypeInternal() {}
  union {
    UserActionList _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UserActionListDefaultTypeInternal _UserActionList_default_instance_;
PROTOBUF_CONSTEXPR DateList::DateList(
    ::_pbi::ConstantInitialized)
  : values_(){}
struct DateListDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DateListDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DateListDefaultTypeInternal() {}
  union {
    DateList _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DateListDefaultTypeInternal _DateList_default_instance_;
PROTOBUF_CONSTEXPR CreditCardList::CreditCardList(
    ::_pbi::ConstantInitialized)
  : values_(){}
struct CreditCardListDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CreditCardListDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CreditCardListDefaultTypeInternal() {}
  union {
    CreditCardList _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CreditCardListDefaultTypeInternal _CreditCardList_default_instance_;
PROTOBUF_CONSTEXPR ProfileList::ProfileList(
    ::_pbi::ConstantInitialized)
  : values_(){}
struct ProfileListDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ProfileListDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ProfileListDefaultTypeInternal() {}
  union {
    ProfileList _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ProfileListDefaultTypeInternal _ProfileList_default_instance_;
PROTOBUF_CONSTEXPR LoginOptionList::LoginOptionList(
    ::_pbi::ConstantInitialized)
  : values_(){}
struct LoginOptionListDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LoginOptionListDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LoginOptionListDefaultTypeInternal() {}
  union {
    LoginOptionList _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LoginOptionListDefaultTypeInternal _LoginOptionList_default_instance_;
PROTOBUF_CONSTEXPR Empty::Empty(
    ::_pbi::ConstantInitialized){}
struct EmptyDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EmptyDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~EmptyDefaultTypeInternal() {}
  union {
    Empty _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EmptyDefaultTypeInternal _Empty_default_instance_;
PROTOBUF_CONSTEXPR ChipProto::ChipProto(
    ::_pbi::ConstantInitialized)
  : text_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , content_description_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , type_(0)

  , icon_(0)

  , sticky_(false){}
struct ChipProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ChipProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ChipProtoDefaultTypeInternal() {}
  union {
    ChipProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ChipProtoDefaultTypeInternal _ChipProto_default_instance_;
PROTOBUF_CONSTEXPR DirectActionProto::DirectActionProto(
    ::_pbi::ConstantInitialized)
  : names_()
  , required_arguments_()
  , optional_arguments_(){}
struct DirectActionProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DirectActionProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DirectActionProtoDefaultTypeInternal() {}
  union {
    DirectActionProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DirectActionProtoDefaultTypeInternal _DirectActionProto_default_instance_;
PROTOBUF_CONSTEXPR UserActionProto::UserActionProto(
    ::_pbi::ConstantInitialized)
  : identifier_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , chip_(nullptr)
  , direct_action_(nullptr)
  , enabled_(true){}
struct UserActionProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UserActionProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~UserActionProtoDefaultTypeInternal() {}
  union {
    UserActionProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UserActionProtoDefaultTypeInternal _UserActionProto_default_instance_;
PROTOBUF_CONSTEXPR DateProto::DateProto(
    ::_pbi::ConstantInitialized)
  : year_(int64_t{0})
  , month_(0)
  , day_(0){}
struct DateProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DateProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DateProtoDefaultTypeInternal() {}
  union {
    DateProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DateProtoDefaultTypeInternal _DateProto_default_instance_;
PROTOBUF_CONSTEXPR TimeProto::TimeProto(
    ::_pbi::ConstantInitialized)
  : hour_(0)
  , minute_(0)
  , second_(0){}
struct TimeProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TimeProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TimeProtoDefaultTypeInternal() {}
  union {
    TimeProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TimeProtoDefaultTypeInternal _TimeProto_default_instance_;
PROTOBUF_CONSTEXPR DateTimeProto::DateTimeProto(
    ::_pbi::ConstantInitialized)
  : date_(nullptr)
  , time_(nullptr){}
struct DateTimeProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DateTimeProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DateTimeProtoDefaultTypeInternal() {}
  union {
    DateTimeProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DateTimeProtoDefaultTypeInternal _DateTimeProto_default_instance_;
PROTOBUF_CONSTEXPR AutofillCreditCardProto::AutofillCreditCardProto(
    ::_pbi::ConstantInitialized)
  : _oneof_case_{}{}
struct AutofillCreditCardProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AutofillCreditCardProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AutofillCreditCardProtoDefaultTypeInternal() {}
  union {
    AutofillCreditCardProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AutofillCreditCardProtoDefaultTypeInternal _AutofillCreditCardProto_default_instance_;
PROTOBUF_CONSTEXPR CreditCardResponseProto::CreditCardResponseProto(
    ::_pbi::ConstantInitialized)
  : network_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}){}
struct CreditCardResponseProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CreditCardResponseProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CreditCardResponseProtoDefaultTypeInternal() {}
  union {
    CreditCardResponseProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CreditCardResponseProtoDefaultTypeInternal _CreditCardResponseProto_default_instance_;
PROTOBUF_CONSTEXPR AutofillProfileProto::AutofillProfileProto(
    ::_pbi::ConstantInitialized)
  : _oneof_case_{}{}
struct AutofillProfileProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AutofillProfileProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AutofillProfileProtoDefaultTypeInternal() {}
  union {
    AutofillProfileProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AutofillProfileProtoDefaultTypeInternal _AutofillProfileProto_default_instance_;
PROTOBUF_CONSTEXPR LoginOptionProto::LoginOptionProto(
    ::_pbi::ConstantInitialized)
  : label_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , sublabel_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , _oneof_case_{}{}
struct LoginOptionProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LoginOptionProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LoginOptionProtoDefaultTypeInternal() {}
  union {
    LoginOptionProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LoginOptionProtoDefaultTypeInternal _LoginOptionProto_default_instance_;
}  // namespace autofill_assistant
namespace autofill_assistant {
bool ProcessedActionStatusProto_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 24:
    case 26:
    case 27:
    case 28:
    case 29:
    case 30:
    case 31:
    case 33:
    case 34:
    case 35:
    case 37:
    case 38:
    case 39:
    case 40:
    case 41:
    case 42:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ProcessedActionStatusProto_strings[38] = {};

static const char ProcessedActionStatusProto_names[] =
  "ACTION_APPLIED"
  "AUTOFILL_INCOMPLETE"
  "AUTOFILL_INFO_NOT_AVAILABLE"
  "CLIENT_ID_RESOLUTION_FAILED"
  "CLIENT_MEMORY_KEY_NOT_AVAILABLE"
  "COLLECT_USER_DATA_ERROR"
  "ELEMENT_MISMATCH"
  "ELEMENT_NOT_ON_TOP"
  "ELEMENT_POSITION_NOT_FOUND"
  "ELEMENT_RESOLUTION_FAILED"
  "ELEMENT_UNSTABLE"
  "EMPTY_VALUE_EXPRESSION_RESULT"
  "FRAME_HOST_NOT_FOUND"
  "GET_FULL_CARD_FAILED"
  "INTERRUPT_FAILED"
  "INVALID_ACTION"
  "INVALID_SELECTOR"
  "INVALID_TARGET"
  "JS_FORCED_ROUNDTRIP"
  "MANUAL_FALLBACK"
  "NAVIGATION_ERROR"
  "NO_RENDER_FRAME"
  "OPTION_VALUE_NOT_FOUND"
  "OTHER_ACTION_STATUS"
  "PASSWORD_ORIGIN_MISMATCH"
  "PRECONDITION_FAILED"
  "QR_CODE_SCAN_CAMERA_ERROR"
  "QR_CODE_SCAN_CANCELLED"
  "QR_CODE_SCAN_FAILURE"
  "TIMED_OUT"
  "TOO_MANY_ELEMENTS"
  "TOO_MANY_OPTION_VALUES_FOUND"
  "UNEXPECTED_JS_ERROR"
  "UNKNOWN_ACTION_STATUS"
  "UNSUPPORTED"
  "UNSUPPORTED_ACTION"
  "USER_ABORTED_ACTION"
  "USER_DATA_REQUEST_FAILED";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ProcessedActionStatusProto_entries[] = {
  { {ProcessedActionStatusProto_names + 0, 14}, 2 },
  { {ProcessedActionStatusProto_names + 14, 19}, 24 },
  { {ProcessedActionStatusProto_names + 33, 27}, 21 },
  { {ProcessedActionStatusProto_names + 60, 27}, 28 },
  { {ProcessedActionStatusProto_names + 87, 31}, 34 },
  { {ProcessedActionStatusProto_names + 118, 23}, 4 },
  { {ProcessedActionStatusProto_names + 141, 16}, 26 },
  { {ProcessedActionStatusProto_names + 157, 18}, 27 },
  { {ProcessedActionStatusProto_names + 175, 26}, 33 },
  { {ProcessedActionStatusProto_names + 201, 25}, 1 },
  { {ProcessedActionStatusProto_names + 226, 16}, 14 },
  { {ProcessedActionStatusProto_names + 242, 29}, 35 },
  { {ProcessedActionStatusProto_names + 271, 20}, 22 },
  { {ProcessedActionStatusProto_names + 291, 20}, 9 },
  { {ProcessedActionStatusProto_names + 311, 16}, 7 },
  { {ProcessedActionStatusProto_names + 327, 14}, 11 },
  { {ProcessedActionStatusProto_names + 341, 16}, 20 },
  { {ProcessedActionStatusProto_names + 357, 14}, 31 },
  { {ProcessedActionStatusProto_names + 371, 19}, 39 },
  { {ProcessedActionStatusProto_names + 390, 15}, 6 },
  { {ProcessedActionStatusProto_names + 405, 16}, 19 },
  { {ProcessedActionStatusProto_names + 421, 15}, 37 },
  { {ProcessedActionStatusProto_names + 436, 22}, 16 },
  { {ProcessedActionStatusProto_names + 458, 19}, 3 },
  { {ProcessedActionStatusProto_names + 477, 24}, 29 },
  { {ProcessedActionStatusProto_names + 501, 19}, 10 },
  { {ProcessedActionStatusProto_names + 520, 25}, 42 },
  { {ProcessedActionStatusProto_names + 545, 22}, 41 },
  { {ProcessedActionStatusProto_names + 567, 20}, 40 },
  { {ProcessedActionStatusProto_names + 587, 9}, 13 },
  { {ProcessedActionStatusProto_names + 596, 17}, 18 },
  { {ProcessedActionStatusProto_names + 613, 28}, 30 },
  { {ProcessedActionStatusProto_names + 641, 19}, 17 },
  { {ProcessedActionStatusProto_names + 660, 21}, 0 },
  { {ProcessedActionStatusProto_names + 681, 11}, 12 },
  { {ProcessedActionStatusProto_names + 692, 18}, 5 },
  { {ProcessedActionStatusProto_names + 710, 19}, 8 },
  { {ProcessedActionStatusProto_names + 729, 24}, 38 },
};

static const int ProcessedActionStatusProto_entries_by_number[] = {
  33, // 0 -> UNKNOWN_ACTION_STATUS
  9, // 1 -> ELEMENT_RESOLUTION_FAILED
  0, // 2 -> ACTION_APPLIED
  23, // 3 -> OTHER_ACTION_STATUS
  5, // 4 -> COLLECT_USER_DATA_ERROR
  35, // 5 -> UNSUPPORTED_ACTION
  19, // 6 -> MANUAL_FALLBACK
  14, // 7 -> INTERRUPT_FAILED
  36, // 8 -> USER_ABORTED_ACTION
  13, // 9 -> GET_FULL_CARD_FAILED
  25, // 10 -> PRECONDITION_FAILED
  15, // 11 -> INVALID_ACTION
  34, // 12 -> UNSUPPORTED
  29, // 13 -> TIMED_OUT
  10, // 14 -> ELEMENT_UNSTABLE
  22, // 16 -> OPTION_VALUE_NOT_FOUND
  32, // 17 -> UNEXPECTED_JS_ERROR
  30, // 18 -> TOO_MANY_ELEMENTS
  20, // 19 -> NAVIGATION_ERROR
  16, // 20 -> INVALID_SELECTOR
  2, // 21 -> AUTOFILL_INFO_NOT_AVAILABLE
  12, // 22 -> FRAME_HOST_NOT_FOUND
  1, // 24 -> AUTOFILL_INCOMPLETE
  6, // 26 -> ELEMENT_MISMATCH
  7, // 27 -> ELEMENT_NOT_ON_TOP
  3, // 28 -> CLIENT_ID_RESOLUTION_FAILED
  24, // 29 -> PASSWORD_ORIGIN_MISMATCH
  31, // 30 -> TOO_MANY_OPTION_VALUES_FOUND
  17, // 31 -> INVALID_TARGET
  8, // 33 -> ELEMENT_POSITION_NOT_FOUND
  4, // 34 -> CLIENT_MEMORY_KEY_NOT_AVAILABLE
  11, // 35 -> EMPTY_VALUE_EXPRESSION_RESULT
  21, // 37 -> NO_RENDER_FRAME
  37, // 38 -> USER_DATA_REQUEST_FAILED
  18, // 39 -> JS_FORCED_ROUNDTRIP
  28, // 40 -> QR_CODE_SCAN_FAILURE
  27, // 41 -> QR_CODE_SCAN_CANCELLED
  26, // 42 -> QR_CODE_SCAN_CAMERA_ERROR
};

const std::string& ProcessedActionStatusProto_Name(
    ProcessedActionStatusProto value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ProcessedActionStatusProto_entries,
          ProcessedActionStatusProto_entries_by_number,
          38, ProcessedActionStatusProto_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ProcessedActionStatusProto_entries,
      ProcessedActionStatusProto_entries_by_number,
      38, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ProcessedActionStatusProto_strings[idx].get();
}
bool ProcessedActionStatusProto_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ProcessedActionStatusProto* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ProcessedActionStatusProto_entries, 38, name, &int_value);
  if (success) {
    *value = static_cast<ProcessedActionStatusProto>(int_value);
  }
  return success;
}
bool ChipType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ChipType_strings[7] = {};

static const char ChipType_names[] =
  "CANCEL_ACTION"
  "CLOSE_ACTION"
  "DONE_ACTION"
  "FEEDBACK_ACTION"
  "HIGHLIGHTED_ACTION"
  "NORMAL_ACTION"
  "UNKNOWN_CHIP_TYPE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ChipType_entries[] = {
  { {ChipType_names + 0, 13}, 4 },
  { {ChipType_names + 13, 12}, 5 },
  { {ChipType_names + 25, 11}, 6 },
  { {ChipType_names + 36, 15}, 7 },
  { {ChipType_names + 51, 18}, 1 },
  { {ChipType_names + 69, 13}, 3 },
  { {ChipType_names + 82, 17}, 0 },
};

static const int ChipType_entries_by_number[] = {
  6, // 0 -> UNKNOWN_CHIP_TYPE
  4, // 1 -> HIGHLIGHTED_ACTION
  5, // 3 -> NORMAL_ACTION
  0, // 4 -> CANCEL_ACTION
  1, // 5 -> CLOSE_ACTION
  2, // 6 -> DONE_ACTION
  3, // 7 -> FEEDBACK_ACTION
};

const std::string& ChipType_Name(
    ChipType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ChipType_entries,
          ChipType_entries_by_number,
          7, ChipType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ChipType_entries,
      ChipType_entries_by_number,
      7, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ChipType_strings[idx].get();
}
bool ChipType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ChipType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ChipType_entries, 7, name, &int_value);
  if (success) {
    *value = static_cast<ChipType>(int_value);
  }
  return success;
}
bool ChipIcon_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ChipIcon_strings[5] = {};

static const char ChipIcon_names[] =
  "ICON_CLEAR"
  "ICON_DONE"
  "ICON_OVERFLOW"
  "ICON_REFRESH"
  "NO_ICON";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ChipIcon_entries[] = {
  { {ChipIcon_names + 0, 10}, 1 },
  { {ChipIcon_names + 10, 9}, 2 },
  { {ChipIcon_names + 19, 13}, 4 },
  { {ChipIcon_names + 32, 12}, 3 },
  { {ChipIcon_names + 44, 7}, 0 },
};

static const int ChipIcon_entries_by_number[] = {
  4, // 0 -> NO_ICON
  0, // 1 -> ICON_CLEAR
  1, // 2 -> ICON_DONE
  3, // 3 -> ICON_REFRESH
  2, // 4 -> ICON_OVERFLOW
};

const std::string& ChipIcon_Name(
    ChipIcon value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ChipIcon_entries,
          ChipIcon_entries_by_number,
          5, ChipIcon_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ChipIcon_entries,
      ChipIcon_entries_by_number,
      5, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ChipIcon_strings[idx].get();
}
bool ChipIcon_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ChipIcon* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ChipIcon_entries, 5, name, &int_value);
  if (success) {
    *value = static_cast<ChipIcon>(int_value);
  }
  return success;
}

// ===================================================================

class ModelProto_ModelValue::_Internal {
 public:
  using HasBits = decltype(std::declval<ModelProto_ModelValue>()._has_bits_);
  static void set_has_identifier(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::autofill_assistant::ValueProto& value(const ModelProto_ModelValue* msg);
  static void set_has_value(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::autofill_assistant::ValueProto&
ModelProto_ModelValue::_Internal::value(const ModelProto_ModelValue* msg) {
  return *msg->value_;
}
ModelProto_ModelValue::ModelProto_ModelValue(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.ModelProto.ModelValue)
}
ModelProto_ModelValue::ModelProto_ModelValue(const ModelProto_ModelValue& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  identifier_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    identifier_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_identifier()) {
    identifier_.Set(from._internal_identifier(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_value()) {
    value_ = new ::autofill_assistant::ValueProto(*from.value_);
  } else {
    value_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.ModelProto.ModelValue)
}

inline void ModelProto_ModelValue::SharedCtor() {
identifier_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  identifier_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
value_ = nullptr;
}

ModelProto_ModelValue::~ModelProto_ModelValue() {
  // @@protoc_insertion_point(destructor:autofill_assistant.ModelProto.ModelValue)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ModelProto_ModelValue::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  identifier_.Destroy();
  if (this != internal_default_instance()) delete value_;
}

void ModelProto_ModelValue::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ModelProto_ModelValue::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.ModelProto.ModelValue)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      identifier_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(value_ != nullptr);
      value_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ModelProto_ModelValue::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string identifier = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_identifier();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .autofill_assistant.ValueProto value = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_value(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ModelProto_ModelValue::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.ModelProto.ModelValue)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string identifier = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_identifier(), target);
  }

  // optional .autofill_assistant.ValueProto value = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::value(this),
        _Internal::value(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.ModelProto.ModelValue)
  return target;
}

size_t ModelProto_ModelValue::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.ModelProto.ModelValue)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string identifier = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_identifier());
    }

    // optional .autofill_assistant.ValueProto value = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *value_);
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ModelProto_ModelValue::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ModelProto_ModelValue*>(
      &from));
}

void ModelProto_ModelValue::MergeFrom(const ModelProto_ModelValue& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.ModelProto.ModelValue)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_identifier(from._internal_identifier());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_value()->::autofill_assistant::ValueProto::MergeFrom(from._internal_value());
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ModelProto_ModelValue::CopyFrom(const ModelProto_ModelValue& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.ModelProto.ModelValue)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ModelProto_ModelValue::IsInitialized() const {
  return true;
}

void ModelProto_ModelValue::InternalSwap(ModelProto_ModelValue* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &identifier_, lhs_arena,
      &other->identifier_, rhs_arena
  );
  swap(value_, other->value_);
}

std::string ModelProto_ModelValue::GetTypeName() const {
  return "autofill_assistant.ModelProto.ModelValue";
}


// ===================================================================

class ModelProto::_Internal {
 public:
};

ModelProto::ModelProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  values_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.ModelProto)
}
ModelProto::ModelProto(const ModelProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      values_(from.values_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.ModelProto)
}

inline void ModelProto::SharedCtor() {
}

ModelProto::~ModelProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.ModelProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ModelProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ModelProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ModelProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.ModelProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  values_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ModelProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .autofill_assistant.ModelProto.ModelValue values = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_values(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ModelProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.ModelProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .autofill_assistant.ModelProto.ModelValue values = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_values_size()); i < n; i++) {
    const auto& repfield = this->_internal_values(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.ModelProto)
  return target;
}

size_t ModelProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.ModelProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .autofill_assistant.ModelProto.ModelValue values = 1;
  total_size += 1UL * this->_internal_values_size();
  for (const auto& msg : this->values_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ModelProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ModelProto*>(
      &from));
}

void ModelProto::MergeFrom(const ModelProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.ModelProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  values_.MergeFrom(from.values_);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ModelProto::CopyFrom(const ModelProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.ModelProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ModelProto::IsInitialized() const {
  return true;
}

void ModelProto::InternalSwap(ModelProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  values_.InternalSwap(&other->values_);
}

std::string ModelProto::GetTypeName() const {
  return "autofill_assistant.ModelProto";
}


// ===================================================================

class ValueProto::_Internal {
 public:
  using HasBits = decltype(std::declval<ValueProto>()._has_bits_);
  static const ::autofill_assistant::StringList& strings(const ValueProto* msg);
  static const ::autofill_assistant::BooleanList& booleans(const ValueProto* msg);
  static const ::autofill_assistant::IntList& ints(const ValueProto* msg);
  static const ::autofill_assistant::UserActionList& user_actions(const ValueProto* msg);
  static const ::autofill_assistant::DateList& dates(const ValueProto* msg);
  static const ::autofill_assistant::CreditCardList& credit_cards(const ValueProto* msg);
  static const ::autofill_assistant::ProfileList& profiles(const ValueProto* msg);
  static const ::autofill_assistant::LoginOptionList& login_options(const ValueProto* msg);
  static const ::autofill_assistant::CreditCardResponseProto& credit_card_response(const ValueProto* msg);
  static void set_has_is_client_side_only(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::autofill_assistant::StringList&
ValueProto::_Internal::strings(const ValueProto* msg) {
  return *msg->kind_.strings_;
}
const ::autofill_assistant::BooleanList&
ValueProto::_Internal::booleans(const ValueProto* msg) {
  return *msg->kind_.booleans_;
}
const ::autofill_assistant::IntList&
ValueProto::_Internal::ints(const ValueProto* msg) {
  return *msg->kind_.ints_;
}
const ::autofill_assistant::UserActionList&
ValueProto::_Internal::user_actions(const ValueProto* msg) {
  return *msg->kind_.user_actions_;
}
const ::autofill_assistant::DateList&
ValueProto::_Internal::dates(const ValueProto* msg) {
  return *msg->kind_.dates_;
}
const ::autofill_assistant::CreditCardList&
ValueProto::_Internal::credit_cards(const ValueProto* msg) {
  return *msg->kind_.credit_cards_;
}
const ::autofill_assistant::ProfileList&
ValueProto::_Internal::profiles(const ValueProto* msg) {
  return *msg->kind_.profiles_;
}
const ::autofill_assistant::LoginOptionList&
ValueProto::_Internal::login_options(const ValueProto* msg) {
  return *msg->kind_.login_options_;
}
const ::autofill_assistant::CreditCardResponseProto&
ValueProto::_Internal::credit_card_response(const ValueProto* msg) {
  return *msg->kind_.credit_card_response_;
}
void ValueProto::set_allocated_strings(::autofill_assistant::StringList* strings) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_kind();
  if (strings) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(strings);
    if (message_arena != submessage_arena) {
      strings = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, strings, submessage_arena);
    }
    set_has_strings();
    kind_.strings_ = strings;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ValueProto.strings)
}
void ValueProto::set_allocated_booleans(::autofill_assistant::BooleanList* booleans) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_kind();
  if (booleans) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(booleans);
    if (message_arena != submessage_arena) {
      booleans = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, booleans, submessage_arena);
    }
    set_has_booleans();
    kind_.booleans_ = booleans;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ValueProto.booleans)
}
void ValueProto::set_allocated_ints(::autofill_assistant::IntList* ints) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_kind();
  if (ints) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(ints);
    if (message_arena != submessage_arena) {
      ints = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ints, submessage_arena);
    }
    set_has_ints();
    kind_.ints_ = ints;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ValueProto.ints)
}
void ValueProto::set_allocated_user_actions(::autofill_assistant::UserActionList* user_actions) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_kind();
  if (user_actions) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(user_actions);
    if (message_arena != submessage_arena) {
      user_actions = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, user_actions, submessage_arena);
    }
    set_has_user_actions();
    kind_.user_actions_ = user_actions;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ValueProto.user_actions)
}
void ValueProto::set_allocated_dates(::autofill_assistant::DateList* dates) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_kind();
  if (dates) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(dates);
    if (message_arena != submessage_arena) {
      dates = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, dates, submessage_arena);
    }
    set_has_dates();
    kind_.dates_ = dates;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ValueProto.dates)
}
void ValueProto::set_allocated_credit_cards(::autofill_assistant::CreditCardList* credit_cards) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_kind();
  if (credit_cards) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(credit_cards);
    if (message_arena != submessage_arena) {
      credit_cards = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, credit_cards, submessage_arena);
    }
    set_has_credit_cards();
    kind_.credit_cards_ = credit_cards;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ValueProto.credit_cards)
}
void ValueProto::set_allocated_profiles(::autofill_assistant::ProfileList* profiles) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_kind();
  if (profiles) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(profiles);
    if (message_arena != submessage_arena) {
      profiles = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, profiles, submessage_arena);
    }
    set_has_profiles();
    kind_.profiles_ = profiles;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ValueProto.profiles)
}
void ValueProto::set_allocated_login_options(::autofill_assistant::LoginOptionList* login_options) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_kind();
  if (login_options) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(login_options);
    if (message_arena != submessage_arena) {
      login_options = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, login_options, submessage_arena);
    }
    set_has_login_options();
    kind_.login_options_ = login_options;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ValueProto.login_options)
}
void ValueProto::set_allocated_credit_card_response(::autofill_assistant::CreditCardResponseProto* credit_card_response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_kind();
  if (credit_card_response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(credit_card_response);
    if (message_arena != submessage_arena) {
      credit_card_response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, credit_card_response, submessage_arena);
    }
    set_has_credit_card_response();
    kind_.credit_card_response_ = credit_card_response;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ValueProto.credit_card_response)
}
ValueProto::ValueProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.ValueProto)
}
ValueProto::ValueProto(const ValueProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  is_client_side_only_ = from.is_client_side_only_;
  clear_has_kind();
  switch (from.kind_case()) {
    case kStrings: {
      _internal_mutable_strings()->::autofill_assistant::StringList::MergeFrom(from._internal_strings());
      break;
    }
    case kBooleans: {
      _internal_mutable_booleans()->::autofill_assistant::BooleanList::MergeFrom(from._internal_booleans());
      break;
    }
    case kInts: {
      _internal_mutable_ints()->::autofill_assistant::IntList::MergeFrom(from._internal_ints());
      break;
    }
    case kUserActions: {
      _internal_mutable_user_actions()->::autofill_assistant::UserActionList::MergeFrom(from._internal_user_actions());
      break;
    }
    case kDates: {
      _internal_mutable_dates()->::autofill_assistant::DateList::MergeFrom(from._internal_dates());
      break;
    }
    case kCreditCards: {
      _internal_mutable_credit_cards()->::autofill_assistant::CreditCardList::MergeFrom(from._internal_credit_cards());
      break;
    }
    case kProfiles: {
      _internal_mutable_profiles()->::autofill_assistant::ProfileList::MergeFrom(from._internal_profiles());
      break;
    }
    case kLoginOptions: {
      _internal_mutable_login_options()->::autofill_assistant::LoginOptionList::MergeFrom(from._internal_login_options());
      break;
    }
    case kCreditCardResponse: {
      _internal_mutable_credit_card_response()->::autofill_assistant::CreditCardResponseProto::MergeFrom(from._internal_credit_card_response());
      break;
    }
    case kServerPayload: {
      _internal_set_server_payload(from._internal_server_payload());
      break;
    }
    case KIND_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.ValueProto)
}

inline void ValueProto::SharedCtor() {
is_client_side_only_ = false;
clear_has_kind();
}

ValueProto::~ValueProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.ValueProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ValueProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_kind()) {
    clear_kind();
  }
}

void ValueProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ValueProto::clear_kind() {
// @@protoc_insertion_point(one_of_clear_start:autofill_assistant.ValueProto)
  switch (kind_case()) {
    case kStrings: {
      if (GetArenaForAllocation() == nullptr) {
        delete kind_.strings_;
      }
      break;
    }
    case kBooleans: {
      if (GetArenaForAllocation() == nullptr) {
        delete kind_.booleans_;
      }
      break;
    }
    case kInts: {
      if (GetArenaForAllocation() == nullptr) {
        delete kind_.ints_;
      }
      break;
    }
    case kUserActions: {
      if (GetArenaForAllocation() == nullptr) {
        delete kind_.user_actions_;
      }
      break;
    }
    case kDates: {
      if (GetArenaForAllocation() == nullptr) {
        delete kind_.dates_;
      }
      break;
    }
    case kCreditCards: {
      if (GetArenaForAllocation() == nullptr) {
        delete kind_.credit_cards_;
      }
      break;
    }
    case kProfiles: {
      if (GetArenaForAllocation() == nullptr) {
        delete kind_.profiles_;
      }
      break;
    }
    case kLoginOptions: {
      if (GetArenaForAllocation() == nullptr) {
        delete kind_.login_options_;
      }
      break;
    }
    case kCreditCardResponse: {
      if (GetArenaForAllocation() == nullptr) {
        delete kind_.credit_card_response_;
      }
      break;
    }
    case kServerPayload: {
      kind_.server_payload_.Destroy();
      break;
    }
    case KIND_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = KIND_NOT_SET;
}


void ValueProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.ValueProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  is_client_side_only_ = false;
  clear_kind();
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ValueProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .autofill_assistant.StringList strings = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_strings(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.BooleanList booleans = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_booleans(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.IntList ints = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_ints(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.UserActionList user_actions = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_user_actions(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.DateList dates = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_dates(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_client_side_only = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_is_client_side_only(&has_bits);
          is_client_side_only_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.CreditCardList credit_cards = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_credit_cards(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.ProfileList profiles = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_profiles(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.LoginOptionList login_options = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_login_options(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.CreditCardResponseProto credit_card_response = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_credit_card_response(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes server_payload = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          auto str = _internal_mutable_server_payload();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ValueProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.ValueProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (kind_case()) {
    case kStrings: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, _Internal::strings(this),
          _Internal::strings(this).GetCachedSize(), target, stream);
      break;
    }
    case kBooleans: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, _Internal::booleans(this),
          _Internal::booleans(this).GetCachedSize(), target, stream);
      break;
    }
    case kInts: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, _Internal::ints(this),
          _Internal::ints(this).GetCachedSize(), target, stream);
      break;
    }
    case kUserActions: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, _Internal::user_actions(this),
          _Internal::user_actions(this).GetCachedSize(), target, stream);
      break;
    }
    case kDates: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(5, _Internal::dates(this),
          _Internal::dates(this).GetCachedSize(), target, stream);
      break;
    }
    default: ;
  }
  cached_has_bits = _has_bits_[0];
  // optional bool is_client_side_only = 6;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(6, this->_internal_is_client_side_only(), target);
  }

  switch (kind_case()) {
    case kCreditCards: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(7, _Internal::credit_cards(this),
          _Internal::credit_cards(this).GetCachedSize(), target, stream);
      break;
    }
    case kProfiles: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(8, _Internal::profiles(this),
          _Internal::profiles(this).GetCachedSize(), target, stream);
      break;
    }
    case kLoginOptions: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(9, _Internal::login_options(this),
          _Internal::login_options(this).GetCachedSize(), target, stream);
      break;
    }
    case kCreditCardResponse: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(10, _Internal::credit_card_response(this),
          _Internal::credit_card_response(this).GetCachedSize(), target, stream);
      break;
    }
    case kServerPayload: {
      target = stream->WriteBytesMaybeAliased(
          12, this->_internal_server_payload(), target);
      break;
    }
    default: ;
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.ValueProto)
  return target;
}

size_t ValueProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.ValueProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bool is_client_side_only = 6;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 1;
  }

  switch (kind_case()) {
    // .autofill_assistant.StringList strings = 1;
    case kStrings: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *kind_.strings_);
      break;
    }
    // .autofill_assistant.BooleanList booleans = 2;
    case kBooleans: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *kind_.booleans_);
      break;
    }
    // .autofill_assistant.IntList ints = 3;
    case kInts: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *kind_.ints_);
      break;
    }
    // .autofill_assistant.UserActionList user_actions = 4;
    case kUserActions: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *kind_.user_actions_);
      break;
    }
    // .autofill_assistant.DateList dates = 5;
    case kDates: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *kind_.dates_);
      break;
    }
    // .autofill_assistant.CreditCardList credit_cards = 7;
    case kCreditCards: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *kind_.credit_cards_);
      break;
    }
    // .autofill_assistant.ProfileList profiles = 8;
    case kProfiles: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *kind_.profiles_);
      break;
    }
    // .autofill_assistant.LoginOptionList login_options = 9;
    case kLoginOptions: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *kind_.login_options_);
      break;
    }
    // .autofill_assistant.CreditCardResponseProto credit_card_response = 10;
    case kCreditCardResponse: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *kind_.credit_card_response_);
      break;
    }
    // bytes server_payload = 12;
    case kServerPayload: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_server_payload());
      break;
    }
    case KIND_NOT_SET: {
      break;
    }
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ValueProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ValueProto*>(
      &from));
}

void ValueProto::MergeFrom(const ValueProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.ValueProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_is_client_side_only()) {
    _internal_set_is_client_side_only(from._internal_is_client_side_only());
  }
  switch (from.kind_case()) {
    case kStrings: {
      _internal_mutable_strings()->::autofill_assistant::StringList::MergeFrom(from._internal_strings());
      break;
    }
    case kBooleans: {
      _internal_mutable_booleans()->::autofill_assistant::BooleanList::MergeFrom(from._internal_booleans());
      break;
    }
    case kInts: {
      _internal_mutable_ints()->::autofill_assistant::IntList::MergeFrom(from._internal_ints());
      break;
    }
    case kUserActions: {
      _internal_mutable_user_actions()->::autofill_assistant::UserActionList::MergeFrom(from._internal_user_actions());
      break;
    }
    case kDates: {
      _internal_mutable_dates()->::autofill_assistant::DateList::MergeFrom(from._internal_dates());
      break;
    }
    case kCreditCards: {
      _internal_mutable_credit_cards()->::autofill_assistant::CreditCardList::MergeFrom(from._internal_credit_cards());
      break;
    }
    case kProfiles: {
      _internal_mutable_profiles()->::autofill_assistant::ProfileList::MergeFrom(from._internal_profiles());
      break;
    }
    case kLoginOptions: {
      _internal_mutable_login_options()->::autofill_assistant::LoginOptionList::MergeFrom(from._internal_login_options());
      break;
    }
    case kCreditCardResponse: {
      _internal_mutable_credit_card_response()->::autofill_assistant::CreditCardResponseProto::MergeFrom(from._internal_credit_card_response());
      break;
    }
    case kServerPayload: {
      _internal_set_server_payload(from._internal_server_payload());
      break;
    }
    case KIND_NOT_SET: {
      break;
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ValueProto::CopyFrom(const ValueProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.ValueProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ValueProto::IsInitialized() const {
  return true;
}

void ValueProto::InternalSwap(ValueProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(is_client_side_only_, other->is_client_side_only_);
  swap(kind_, other->kind_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

std::string ValueProto::GetTypeName() const {
  return "autofill_assistant.ValueProto";
}


// ===================================================================

class ValueReferenceProto::_Internal {
 public:
  static const ::autofill_assistant::ValueProto& value(const ValueReferenceProto* msg);
};

const ::autofill_assistant::ValueProto&
ValueReferenceProto::_Internal::value(const ValueReferenceProto* msg) {
  return *msg->kind_.value_;
}
void ValueReferenceProto::set_allocated_value(::autofill_assistant::ValueProto* value) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_kind();
  if (value) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(value);
    if (message_arena != submessage_arena) {
      value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    set_has_value();
    kind_.value_ = value;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ValueReferenceProto.value)
}
ValueReferenceProto::ValueReferenceProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.ValueReferenceProto)
}
ValueReferenceProto::ValueReferenceProto(const ValueReferenceProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  clear_has_kind();
  switch (from.kind_case()) {
    case kValue: {
      _internal_mutable_value()->::autofill_assistant::ValueProto::MergeFrom(from._internal_value());
      break;
    }
    case kModelIdentifier: {
      _internal_set_model_identifier(from._internal_model_identifier());
      break;
    }
    case KIND_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.ValueReferenceProto)
}

inline void ValueReferenceProto::SharedCtor() {
clear_has_kind();
}

ValueReferenceProto::~ValueReferenceProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.ValueReferenceProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ValueReferenceProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_kind()) {
    clear_kind();
  }
}

void ValueReferenceProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ValueReferenceProto::clear_kind() {
// @@protoc_insertion_point(one_of_clear_start:autofill_assistant.ValueReferenceProto)
  switch (kind_case()) {
    case kValue: {
      if (GetArenaForAllocation() == nullptr) {
        delete kind_.value_;
      }
      break;
    }
    case kModelIdentifier: {
      kind_.model_identifier_.Destroy();
      break;
    }
    case KIND_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = KIND_NOT_SET;
}


void ValueReferenceProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.ValueReferenceProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_kind();
  _internal_metadata_.Clear<std::string>();
}

const char* ValueReferenceProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .autofill_assistant.ValueProto value = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_value(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string model_identifier = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_model_identifier();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ValueReferenceProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.ValueReferenceProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (kind_case()) {
    case kValue: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, _Internal::value(this),
          _Internal::value(this).GetCachedSize(), target, stream);
      break;
    }
    case kModelIdentifier: {
      target = stream->WriteStringMaybeAliased(
          2, this->_internal_model_identifier(), target);
      break;
    }
    default: ;
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.ValueReferenceProto)
  return target;
}

size_t ValueReferenceProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.ValueReferenceProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (kind_case()) {
    // .autofill_assistant.ValueProto value = 1;
    case kValue: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *kind_.value_);
      break;
    }
    // string model_identifier = 2;
    case kModelIdentifier: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_model_identifier());
      break;
    }
    case KIND_NOT_SET: {
      break;
    }
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ValueReferenceProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ValueReferenceProto*>(
      &from));
}

void ValueReferenceProto::MergeFrom(const ValueReferenceProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.ValueReferenceProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.kind_case()) {
    case kValue: {
      _internal_mutable_value()->::autofill_assistant::ValueProto::MergeFrom(from._internal_value());
      break;
    }
    case kModelIdentifier: {
      _internal_set_model_identifier(from._internal_model_identifier());
      break;
    }
    case KIND_NOT_SET: {
      break;
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ValueReferenceProto::CopyFrom(const ValueReferenceProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.ValueReferenceProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ValueReferenceProto::IsInitialized() const {
  return true;
}

void ValueReferenceProto::InternalSwap(ValueReferenceProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(kind_, other->kind_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

std::string ValueReferenceProto::GetTypeName() const {
  return "autofill_assistant.ValueReferenceProto";
}


// ===================================================================

class StringList::_Internal {
 public:
};

StringList::StringList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  values_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.StringList)
}
StringList::StringList(const StringList& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      values_(from.values_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.StringList)
}

inline void StringList::SharedCtor() {
}

StringList::~StringList() {
  // @@protoc_insertion_point(destructor:autofill_assistant.StringList)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StringList::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void StringList::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void StringList::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.StringList)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  values_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* StringList::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated string values = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_values();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StringList::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.StringList)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated string values = 1;
  for (int i = 0, n = this->_internal_values_size(); i < n; i++) {
    const auto& s = this->_internal_values(i);
    target = stream->WriteString(1, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.StringList)
  return target;
}

size_t StringList::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.StringList)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string values = 1;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(values_.size());
  for (int i = 0, n = values_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      values_.Get(i));
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void StringList::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const StringList*>(
      &from));
}

void StringList::MergeFrom(const StringList& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.StringList)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  values_.MergeFrom(from.values_);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void StringList::CopyFrom(const StringList& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.StringList)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StringList::IsInitialized() const {
  return true;
}

void StringList::InternalSwap(StringList* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  values_.InternalSwap(&other->values_);
}

std::string StringList::GetTypeName() const {
  return "autofill_assistant.StringList";
}


// ===================================================================

class BooleanList::_Internal {
 public:
};

BooleanList::BooleanList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  values_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.BooleanList)
}
BooleanList::BooleanList(const BooleanList& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      values_(from.values_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.BooleanList)
}

inline void BooleanList::SharedCtor() {
}

BooleanList::~BooleanList() {
  // @@protoc_insertion_point(destructor:autofill_assistant.BooleanList)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void BooleanList::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void BooleanList::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void BooleanList::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.BooleanList)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  values_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* BooleanList::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated bool values = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_values(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<8>(ptr));
        } else if (static_cast<uint8_t>(tag) == 10) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedBoolParser(_internal_mutable_values(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* BooleanList::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.BooleanList)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated bool values = 1;
  for (int i = 0, n = this->_internal_values_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_values(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.BooleanList)
  return target;
}

size_t BooleanList::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.BooleanList)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated bool values = 1;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_values_size());
    size_t data_size = 1UL * count;
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_values_size());
    total_size += data_size;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void BooleanList::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const BooleanList*>(
      &from));
}

void BooleanList::MergeFrom(const BooleanList& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.BooleanList)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  values_.MergeFrom(from.values_);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void BooleanList::CopyFrom(const BooleanList& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.BooleanList)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BooleanList::IsInitialized() const {
  return true;
}

void BooleanList::InternalSwap(BooleanList* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  values_.InternalSwap(&other->values_);
}

std::string BooleanList::GetTypeName() const {
  return "autofill_assistant.BooleanList";
}


// ===================================================================

class IntList::_Internal {
 public:
};

IntList::IntList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  values_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.IntList)
}
IntList::IntList(const IntList& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      values_(from.values_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.IntList)
}

inline void IntList::SharedCtor() {
}

IntList::~IntList() {
  // @@protoc_insertion_point(destructor:autofill_assistant.IntList)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void IntList::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void IntList::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void IntList::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.IntList)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  values_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* IntList::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated int32 values = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_values(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<8>(ptr));
        } else if (static_cast<uint8_t>(tag) == 10) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_values(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* IntList::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.IntList)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated int32 values = 1;
  for (int i = 0, n = this->_internal_values_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_values(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.IntList)
  return target;
}

size_t IntList::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.IntList)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int32 values = 1;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int32Size(this->values_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_values_size());
    total_size += data_size;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void IntList::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const IntList*>(
      &from));
}

void IntList::MergeFrom(const IntList& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.IntList)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  values_.MergeFrom(from.values_);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void IntList::CopyFrom(const IntList& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.IntList)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IntList::IsInitialized() const {
  return true;
}

void IntList::InternalSwap(IntList* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  values_.InternalSwap(&other->values_);
}

std::string IntList::GetTypeName() const {
  return "autofill_assistant.IntList";
}


// ===================================================================

class UserActionList::_Internal {
 public:
};

UserActionList::UserActionList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  values_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.UserActionList)
}
UserActionList::UserActionList(const UserActionList& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      values_(from.values_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.UserActionList)
}

inline void UserActionList::SharedCtor() {
}

UserActionList::~UserActionList() {
  // @@protoc_insertion_point(destructor:autofill_assistant.UserActionList)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void UserActionList::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void UserActionList::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void UserActionList::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.UserActionList)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  values_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* UserActionList::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .autofill_assistant.UserActionProto values = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_values(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UserActionList::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.UserActionList)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .autofill_assistant.UserActionProto values = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_values_size()); i < n; i++) {
    const auto& repfield = this->_internal_values(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.UserActionList)
  return target;
}

size_t UserActionList::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.UserActionList)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .autofill_assistant.UserActionProto values = 1;
  total_size += 1UL * this->_internal_values_size();
  for (const auto& msg : this->values_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void UserActionList::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const UserActionList*>(
      &from));
}

void UserActionList::MergeFrom(const UserActionList& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.UserActionList)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  values_.MergeFrom(from.values_);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void UserActionList::CopyFrom(const UserActionList& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.UserActionList)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UserActionList::IsInitialized() const {
  return true;
}

void UserActionList::InternalSwap(UserActionList* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  values_.InternalSwap(&other->values_);
}

std::string UserActionList::GetTypeName() const {
  return "autofill_assistant.UserActionList";
}


// ===================================================================

class DateList::_Internal {
 public:
};

DateList::DateList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  values_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.DateList)
}
DateList::DateList(const DateList& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      values_(from.values_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.DateList)
}

inline void DateList::SharedCtor() {
}

DateList::~DateList() {
  // @@protoc_insertion_point(destructor:autofill_assistant.DateList)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DateList::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void DateList::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void DateList::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.DateList)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  values_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* DateList::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .autofill_assistant.DateProto values = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_values(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DateList::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.DateList)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .autofill_assistant.DateProto values = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_values_size()); i < n; i++) {
    const auto& repfield = this->_internal_values(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.DateList)
  return target;
}

size_t DateList::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.DateList)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .autofill_assistant.DateProto values = 1;
  total_size += 1UL * this->_internal_values_size();
  for (const auto& msg : this->values_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DateList::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DateList*>(
      &from));
}

void DateList::MergeFrom(const DateList& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.DateList)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  values_.MergeFrom(from.values_);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DateList::CopyFrom(const DateList& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.DateList)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DateList::IsInitialized() const {
  return true;
}

void DateList::InternalSwap(DateList* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  values_.InternalSwap(&other->values_);
}

std::string DateList::GetTypeName() const {
  return "autofill_assistant.DateList";
}


// ===================================================================

class CreditCardList::_Internal {
 public:
};

CreditCardList::CreditCardList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  values_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.CreditCardList)
}
CreditCardList::CreditCardList(const CreditCardList& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      values_(from.values_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.CreditCardList)
}

inline void CreditCardList::SharedCtor() {
}

CreditCardList::~CreditCardList() {
  // @@protoc_insertion_point(destructor:autofill_assistant.CreditCardList)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CreditCardList::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CreditCardList::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CreditCardList::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.CreditCardList)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  values_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CreditCardList::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .autofill_assistant.AutofillCreditCardProto values = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_values(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CreditCardList::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.CreditCardList)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .autofill_assistant.AutofillCreditCardProto values = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_values_size()); i < n; i++) {
    const auto& repfield = this->_internal_values(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.CreditCardList)
  return target;
}

size_t CreditCardList::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.CreditCardList)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .autofill_assistant.AutofillCreditCardProto values = 1;
  total_size += 1UL * this->_internal_values_size();
  for (const auto& msg : this->values_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CreditCardList::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CreditCardList*>(
      &from));
}

void CreditCardList::MergeFrom(const CreditCardList& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.CreditCardList)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  values_.MergeFrom(from.values_);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CreditCardList::CopyFrom(const CreditCardList& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.CreditCardList)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CreditCardList::IsInitialized() const {
  return true;
}

void CreditCardList::InternalSwap(CreditCardList* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  values_.InternalSwap(&other->values_);
}

std::string CreditCardList::GetTypeName() const {
  return "autofill_assistant.CreditCardList";
}


// ===================================================================

class ProfileList::_Internal {
 public:
};

ProfileList::ProfileList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  values_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.ProfileList)
}
ProfileList::ProfileList(const ProfileList& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      values_(from.values_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.ProfileList)
}

inline void ProfileList::SharedCtor() {
}

ProfileList::~ProfileList() {
  // @@protoc_insertion_point(destructor:autofill_assistant.ProfileList)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ProfileList::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ProfileList::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ProfileList::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.ProfileList)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  values_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ProfileList::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .autofill_assistant.AutofillProfileProto values = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_values(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ProfileList::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.ProfileList)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .autofill_assistant.AutofillProfileProto values = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_values_size()); i < n; i++) {
    const auto& repfield = this->_internal_values(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.ProfileList)
  return target;
}

size_t ProfileList::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.ProfileList)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .autofill_assistant.AutofillProfileProto values = 1;
  total_size += 1UL * this->_internal_values_size();
  for (const auto& msg : this->values_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ProfileList::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ProfileList*>(
      &from));
}

void ProfileList::MergeFrom(const ProfileList& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.ProfileList)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  values_.MergeFrom(from.values_);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ProfileList::CopyFrom(const ProfileList& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.ProfileList)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ProfileList::IsInitialized() const {
  return true;
}

void ProfileList::InternalSwap(ProfileList* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  values_.InternalSwap(&other->values_);
}

std::string ProfileList::GetTypeName() const {
  return "autofill_assistant.ProfileList";
}


// ===================================================================

class LoginOptionList::_Internal {
 public:
};

LoginOptionList::LoginOptionList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  values_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.LoginOptionList)
}
LoginOptionList::LoginOptionList(const LoginOptionList& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      values_(from.values_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.LoginOptionList)
}

inline void LoginOptionList::SharedCtor() {
}

LoginOptionList::~LoginOptionList() {
  // @@protoc_insertion_point(destructor:autofill_assistant.LoginOptionList)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LoginOptionList::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void LoginOptionList::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void LoginOptionList::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.LoginOptionList)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  values_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* LoginOptionList::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .autofill_assistant.LoginOptionProto values = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_values(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LoginOptionList::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.LoginOptionList)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .autofill_assistant.LoginOptionProto values = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_values_size()); i < n; i++) {
    const auto& repfield = this->_internal_values(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.LoginOptionList)
  return target;
}

size_t LoginOptionList::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.LoginOptionList)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .autofill_assistant.LoginOptionProto values = 1;
  total_size += 1UL * this->_internal_values_size();
  for (const auto& msg : this->values_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void LoginOptionList::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const LoginOptionList*>(
      &from));
}

void LoginOptionList::MergeFrom(const LoginOptionList& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.LoginOptionList)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  values_.MergeFrom(from.values_);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void LoginOptionList::CopyFrom(const LoginOptionList& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.LoginOptionList)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LoginOptionList::IsInitialized() const {
  return true;
}

void LoginOptionList::InternalSwap(LoginOptionList* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  values_.InternalSwap(&other->values_);
}

std::string LoginOptionList::GetTypeName() const {
  return "autofill_assistant.LoginOptionList";
}


// ===================================================================

class Empty::_Internal {
 public:
};

Empty::Empty(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.Empty)
}
Empty::Empty(const Empty& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.Empty)
}

inline void Empty::SharedCtor() {
}

Empty::~Empty() {
  // @@protoc_insertion_point(destructor:autofill_assistant.Empty)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Empty::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Empty::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Empty::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.Empty)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_metadata_.Clear<std::string>();
}

const char* Empty::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Empty::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.Empty)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.Empty)
  return target;
}

size_t Empty::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.Empty)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Empty::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Empty*>(
      &from));
}

void Empty::MergeFrom(const Empty& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.Empty)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Empty::CopyFrom(const Empty& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.Empty)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Empty::IsInitialized() const {
  return true;
}

void Empty::InternalSwap(Empty* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
}

std::string Empty::GetTypeName() const {
  return "autofill_assistant.Empty";
}


// ===================================================================

class ChipProto::_Internal {
 public:
  using HasBits = decltype(std::declval<ChipProto>()._has_bits_);
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_icon(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_text(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_sticky(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_content_description(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

ChipProto::ChipProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.ChipProto)
}
ChipProto::ChipProto(const ChipProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  text_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    text_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_text()) {
    text_.Set(from._internal_text(), 
      GetArenaForAllocation());
  }
  content_description_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    content_description_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_content_description()) {
    content_description_.Set(from._internal_content_description(), 
      GetArenaForAllocation());
  }
  ::memcpy(&type_, &from.type_,
    static_cast<size_t>(reinterpret_cast<char*>(&sticky_) -
    reinterpret_cast<char*>(&type_)) + sizeof(sticky_));
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.ChipProto)
}

inline void ChipProto::SharedCtor() {
text_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  text_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
content_description_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  content_description_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&type_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&sticky_) -
    reinterpret_cast<char*>(&type_)) + sizeof(sticky_));
}

ChipProto::~ChipProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.ChipProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ChipProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  text_.Destroy();
  content_description_.Destroy();
}

void ChipProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ChipProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.ChipProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      text_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      content_description_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000001cu) {
    ::memset(&type_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&sticky_) -
        reinterpret_cast<char*>(&type_)) + sizeof(sticky_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ChipProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .autofill_assistant.ChipType type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::autofill_assistant::ChipType_IsValid(val))) {
            _internal_set_type(static_cast<::autofill_assistant::ChipType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .autofill_assistant.ChipIcon icon = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::autofill_assistant::ChipIcon_IsValid(val))) {
            _internal_set_icon(static_cast<::autofill_assistant::ChipIcon>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional string text = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_text();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool sticky = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_sticky(&has_bits);
          sticky_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string content_description = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_content_description();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ChipProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.ChipProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .autofill_assistant.ChipType type = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_type(), target);
  }

  // optional .autofill_assistant.ChipIcon icon = 2;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_icon(), target);
  }

  // optional string text = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_text(), target);
  }

  // optional bool sticky = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_sticky(), target);
  }

  // optional string content_description = 5;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_content_description(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.ChipProto)
  return target;
}

size_t ChipProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.ChipProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional string text = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_text());
    }

    // optional string content_description = 5;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_content_description());
    }

    // optional .autofill_assistant.ChipType type = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
    }

    // optional .autofill_assistant.ChipIcon icon = 2;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_icon());
    }

    // optional bool sticky = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 1;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ChipProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ChipProto*>(
      &from));
}

void ChipProto::MergeFrom(const ChipProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.ChipProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_text(from._internal_text());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_content_description(from._internal_content_description());
    }
    if (cached_has_bits & 0x00000004u) {
      type_ = from.type_;
    }
    if (cached_has_bits & 0x00000008u) {
      icon_ = from.icon_;
    }
    if (cached_has_bits & 0x00000010u) {
      sticky_ = from.sticky_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ChipProto::CopyFrom(const ChipProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.ChipProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ChipProto::IsInitialized() const {
  return true;
}

void ChipProto::InternalSwap(ChipProto* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &text_, lhs_arena,
      &other->text_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &content_description_, lhs_arena,
      &other->content_description_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ChipProto, sticky_)
      + sizeof(ChipProto::sticky_)
      - PROTOBUF_FIELD_OFFSET(ChipProto, type_)>(
          reinterpret_cast<char*>(&type_),
          reinterpret_cast<char*>(&other->type_));
}

std::string ChipProto::GetTypeName() const {
  return "autofill_assistant.ChipProto";
}


// ===================================================================

class DirectActionProto::_Internal {
 public:
};

DirectActionProto::DirectActionProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  names_(arena),
  required_arguments_(arena),
  optional_arguments_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.DirectActionProto)
}
DirectActionProto::DirectActionProto(const DirectActionProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      names_(from.names_),
      required_arguments_(from.required_arguments_),
      optional_arguments_(from.optional_arguments_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.DirectActionProto)
}

inline void DirectActionProto::SharedCtor() {
}

DirectActionProto::~DirectActionProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.DirectActionProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DirectActionProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void DirectActionProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void DirectActionProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.DirectActionProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  names_.Clear();
  required_arguments_.Clear();
  optional_arguments_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* DirectActionProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated string names = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_names();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated string required_arguments = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_required_arguments();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated string optional_arguments = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_optional_arguments();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DirectActionProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.DirectActionProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated string names = 1;
  for (int i = 0, n = this->_internal_names_size(); i < n; i++) {
    const auto& s = this->_internal_names(i);
    target = stream->WriteString(1, s, target);
  }

  // repeated string required_arguments = 2;
  for (int i = 0, n = this->_internal_required_arguments_size(); i < n; i++) {
    const auto& s = this->_internal_required_arguments(i);
    target = stream->WriteString(2, s, target);
  }

  // repeated string optional_arguments = 3;
  for (int i = 0, n = this->_internal_optional_arguments_size(); i < n; i++) {
    const auto& s = this->_internal_optional_arguments(i);
    target = stream->WriteString(3, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.DirectActionProto)
  return target;
}

size_t DirectActionProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.DirectActionProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string names = 1;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(names_.size());
  for (int i = 0, n = names_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      names_.Get(i));
  }

  // repeated string required_arguments = 2;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(required_arguments_.size());
  for (int i = 0, n = required_arguments_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      required_arguments_.Get(i));
  }

  // repeated string optional_arguments = 3;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(optional_arguments_.size());
  for (int i = 0, n = optional_arguments_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      optional_arguments_.Get(i));
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DirectActionProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DirectActionProto*>(
      &from));
}

void DirectActionProto::MergeFrom(const DirectActionProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.DirectActionProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  names_.MergeFrom(from.names_);
  required_arguments_.MergeFrom(from.required_arguments_);
  optional_arguments_.MergeFrom(from.optional_arguments_);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DirectActionProto::CopyFrom(const DirectActionProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.DirectActionProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DirectActionProto::IsInitialized() const {
  return true;
}

void DirectActionProto::InternalSwap(DirectActionProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  names_.InternalSwap(&other->names_);
  required_arguments_.InternalSwap(&other->required_arguments_);
  optional_arguments_.InternalSwap(&other->optional_arguments_);
}

std::string DirectActionProto::GetTypeName() const {
  return "autofill_assistant.DirectActionProto";
}


// ===================================================================

class UserActionProto::_Internal {
 public:
  using HasBits = decltype(std::declval<UserActionProto>()._has_bits_);
  static const ::autofill_assistant::ChipProto& chip(const UserActionProto* msg);
  static void set_has_chip(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::autofill_assistant::DirectActionProto& direct_action(const UserActionProto* msg);
  static void set_has_direct_action(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_identifier(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::autofill_assistant::ChipProto&
UserActionProto::_Internal::chip(const UserActionProto* msg) {
  return *msg->chip_;
}
const ::autofill_assistant::DirectActionProto&
UserActionProto::_Internal::direct_action(const UserActionProto* msg) {
  return *msg->direct_action_;
}
UserActionProto::UserActionProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.UserActionProto)
}
UserActionProto::UserActionProto(const UserActionProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  identifier_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    identifier_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_identifier()) {
    identifier_.Set(from._internal_identifier(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_chip()) {
    chip_ = new ::autofill_assistant::ChipProto(*from.chip_);
  } else {
    chip_ = nullptr;
  }
  if (from._internal_has_direct_action()) {
    direct_action_ = new ::autofill_assistant::DirectActionProto(*from.direct_action_);
  } else {
    direct_action_ = nullptr;
  }
  enabled_ = from.enabled_;
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.UserActionProto)
}

inline void UserActionProto::SharedCtor() {
identifier_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  identifier_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&chip_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&direct_action_) -
    reinterpret_cast<char*>(&chip_)) + sizeof(direct_action_));
enabled_ = true;
}

UserActionProto::~UserActionProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.UserActionProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void UserActionProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  identifier_.Destroy();
  if (this != internal_default_instance()) delete chip_;
  if (this != internal_default_instance()) delete direct_action_;
}

void UserActionProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void UserActionProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.UserActionProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      identifier_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(chip_ != nullptr);
      chip_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(direct_action_ != nullptr);
      direct_action_->Clear();
    }
    enabled_ = true;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* UserActionProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .autofill_assistant.ChipProto chip = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_chip(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .autofill_assistant.DirectActionProto direct_action = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_direct_action(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string identifier = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_identifier();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool enabled = 4 [default = true];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_enabled(&has_bits);
          enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UserActionProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.UserActionProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .autofill_assistant.ChipProto chip = 1;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::chip(this),
        _Internal::chip(this).GetCachedSize(), target, stream);
  }

  // optional .autofill_assistant.DirectActionProto direct_action = 2;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::direct_action(this),
        _Internal::direct_action(this).GetCachedSize(), target, stream);
  }

  // optional string identifier = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_identifier(), target);
  }

  // optional bool enabled = 4 [default = true];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_enabled(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.UserActionProto)
  return target;
}

size_t UserActionProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.UserActionProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string identifier = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_identifier());
    }

    // optional .autofill_assistant.ChipProto chip = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *chip_);
    }

    // optional .autofill_assistant.DirectActionProto direct_action = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *direct_action_);
    }

    // optional bool enabled = 4 [default = true];
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void UserActionProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const UserActionProto*>(
      &from));
}

void UserActionProto::MergeFrom(const UserActionProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.UserActionProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_identifier(from._internal_identifier());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_chip()->::autofill_assistant::ChipProto::MergeFrom(from._internal_chip());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_direct_action()->::autofill_assistant::DirectActionProto::MergeFrom(from._internal_direct_action());
    }
    if (cached_has_bits & 0x00000008u) {
      enabled_ = from.enabled_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void UserActionProto::CopyFrom(const UserActionProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.UserActionProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UserActionProto::IsInitialized() const {
  return true;
}

void UserActionProto::InternalSwap(UserActionProto* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &identifier_, lhs_arena,
      &other->identifier_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(UserActionProto, direct_action_)
      + sizeof(UserActionProto::direct_action_)
      - PROTOBUF_FIELD_OFFSET(UserActionProto, chip_)>(
          reinterpret_cast<char*>(&chip_),
          reinterpret_cast<char*>(&other->chip_));
  swap(enabled_, other->enabled_);
}

std::string UserActionProto::GetTypeName() const {
  return "autofill_assistant.UserActionProto";
}


// ===================================================================

class DateProto::_Internal {
 public:
  using HasBits = decltype(std::declval<DateProto>()._has_bits_);
  static void set_has_year(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_month(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_day(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

DateProto::DateProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.DateProto)
}
DateProto::DateProto(const DateProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&year_, &from.year_,
    static_cast<size_t>(reinterpret_cast<char*>(&day_) -
    reinterpret_cast<char*>(&year_)) + sizeof(day_));
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.DateProto)
}

inline void DateProto::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&year_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&day_) -
    reinterpret_cast<char*>(&year_)) + sizeof(day_));
}

DateProto::~DateProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.DateProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DateProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void DateProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void DateProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.DateProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&year_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&day_) -
        reinterpret_cast<char*>(&year_)) + sizeof(day_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* DateProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 year = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_year(&has_bits);
          year_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 month = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_month(&has_bits);
          month_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 day = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_day(&has_bits);
          day_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DateProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.DateProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int64 year = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_year(), target);
  }

  // optional int32 month = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_month(), target);
  }

  // optional int32 day = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_day(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.DateProto)
  return target;
}

size_t DateProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.DateProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional int64 year = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_year());
    }

    // optional int32 month = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_month());
    }

    // optional int32 day = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_day());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DateProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DateProto*>(
      &from));
}

void DateProto::MergeFrom(const DateProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.DateProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      year_ = from.year_;
    }
    if (cached_has_bits & 0x00000002u) {
      month_ = from.month_;
    }
    if (cached_has_bits & 0x00000004u) {
      day_ = from.day_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DateProto::CopyFrom(const DateProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.DateProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DateProto::IsInitialized() const {
  return true;
}

void DateProto::InternalSwap(DateProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DateProto, day_)
      + sizeof(DateProto::day_)
      - PROTOBUF_FIELD_OFFSET(DateProto, year_)>(
          reinterpret_cast<char*>(&year_),
          reinterpret_cast<char*>(&other->year_));
}

std::string DateProto::GetTypeName() const {
  return "autofill_assistant.DateProto";
}


// ===================================================================

class TimeProto::_Internal {
 public:
  using HasBits = decltype(std::declval<TimeProto>()._has_bits_);
  static void set_has_hour(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_minute(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_second(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

TimeProto::TimeProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.TimeProto)
}
TimeProto::TimeProto(const TimeProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&hour_, &from.hour_,
    static_cast<size_t>(reinterpret_cast<char*>(&second_) -
    reinterpret_cast<char*>(&hour_)) + sizeof(second_));
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.TimeProto)
}

inline void TimeProto::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&hour_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&second_) -
    reinterpret_cast<char*>(&hour_)) + sizeof(second_));
}

TimeProto::~TimeProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.TimeProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TimeProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void TimeProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void TimeProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.TimeProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&hour_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&second_) -
        reinterpret_cast<char*>(&hour_)) + sizeof(second_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* TimeProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 hour = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_hour(&has_bits);
          hour_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 minute = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_minute(&has_bits);
          minute_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 second = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_second(&has_bits);
          second_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TimeProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.TimeProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 hour = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_hour(), target);
  }

  // optional int32 minute = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_minute(), target);
  }

  // optional int32 second = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_second(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.TimeProto)
  return target;
}

size_t TimeProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.TimeProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional int32 hour = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_hour());
    }

    // optional int32 minute = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_minute());
    }

    // optional int32 second = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_second());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TimeProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const TimeProto*>(
      &from));
}

void TimeProto::MergeFrom(const TimeProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.TimeProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      hour_ = from.hour_;
    }
    if (cached_has_bits & 0x00000002u) {
      minute_ = from.minute_;
    }
    if (cached_has_bits & 0x00000004u) {
      second_ = from.second_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TimeProto::CopyFrom(const TimeProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.TimeProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TimeProto::IsInitialized() const {
  return true;
}

void TimeProto::InternalSwap(TimeProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TimeProto, second_)
      + sizeof(TimeProto::second_)
      - PROTOBUF_FIELD_OFFSET(TimeProto, hour_)>(
          reinterpret_cast<char*>(&hour_),
          reinterpret_cast<char*>(&other->hour_));
}

std::string TimeProto::GetTypeName() const {
  return "autofill_assistant.TimeProto";
}


// ===================================================================

class DateTimeProto::_Internal {
 public:
  using HasBits = decltype(std::declval<DateTimeProto>()._has_bits_);
  static const ::autofill_assistant::DateProto& date(const DateTimeProto* msg);
  static void set_has_date(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::autofill_assistant::TimeProto& time(const DateTimeProto* msg);
  static void set_has_time(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::autofill_assistant::DateProto&
DateTimeProto::_Internal::date(const DateTimeProto* msg) {
  return *msg->date_;
}
const ::autofill_assistant::TimeProto&
DateTimeProto::_Internal::time(const DateTimeProto* msg) {
  return *msg->time_;
}
DateTimeProto::DateTimeProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.DateTimeProto)
}
DateTimeProto::DateTimeProto(const DateTimeProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_date()) {
    date_ = new ::autofill_assistant::DateProto(*from.date_);
  } else {
    date_ = nullptr;
  }
  if (from._internal_has_time()) {
    time_ = new ::autofill_assistant::TimeProto(*from.time_);
  } else {
    time_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.DateTimeProto)
}

inline void DateTimeProto::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&date_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&time_) -
    reinterpret_cast<char*>(&date_)) + sizeof(time_));
}

DateTimeProto::~DateTimeProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.DateTimeProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DateTimeProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete date_;
  if (this != internal_default_instance()) delete time_;
}

void DateTimeProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void DateTimeProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.DateTimeProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(date_ != nullptr);
      date_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(time_ != nullptr);
      time_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* DateTimeProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .autofill_assistant.DateProto date = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_date(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .autofill_assistant.TimeProto time = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_time(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DateTimeProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.DateTimeProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .autofill_assistant.DateProto date = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::date(this),
        _Internal::date(this).GetCachedSize(), target, stream);
  }

  // optional .autofill_assistant.TimeProto time = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::time(this),
        _Internal::time(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.DateTimeProto)
  return target;
}

size_t DateTimeProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.DateTimeProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .autofill_assistant.DateProto date = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *date_);
    }

    // optional .autofill_assistant.TimeProto time = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *time_);
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DateTimeProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DateTimeProto*>(
      &from));
}

void DateTimeProto::MergeFrom(const DateTimeProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.DateTimeProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_date()->::autofill_assistant::DateProto::MergeFrom(from._internal_date());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_time()->::autofill_assistant::TimeProto::MergeFrom(from._internal_time());
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DateTimeProto::CopyFrom(const DateTimeProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.DateTimeProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DateTimeProto::IsInitialized() const {
  return true;
}

void DateTimeProto::InternalSwap(DateTimeProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DateTimeProto, time_)
      + sizeof(DateTimeProto::time_)
      - PROTOBUF_FIELD_OFFSET(DateTimeProto, date_)>(
          reinterpret_cast<char*>(&date_),
          reinterpret_cast<char*>(&other->date_));
}

std::string DateTimeProto::GetTypeName() const {
  return "autofill_assistant.DateTimeProto";
}


// ===================================================================

class AutofillCreditCardProto::_Internal {
 public:
  static const ::autofill_assistant::Empty& selected_credit_card(const AutofillCreditCardProto* msg);
};

const ::autofill_assistant::Empty&
AutofillCreditCardProto::_Internal::selected_credit_card(const AutofillCreditCardProto* msg) {
  return *msg->identifier_.selected_credit_card_;
}
void AutofillCreditCardProto::set_allocated_selected_credit_card(::autofill_assistant::Empty* selected_credit_card) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_identifier();
  if (selected_credit_card) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(selected_credit_card);
    if (message_arena != submessage_arena) {
      selected_credit_card = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, selected_credit_card, submessage_arena);
    }
    set_has_selected_credit_card();
    identifier_.selected_credit_card_ = selected_credit_card;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.AutofillCreditCardProto.selected_credit_card)
}
AutofillCreditCardProto::AutofillCreditCardProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.AutofillCreditCardProto)
}
AutofillCreditCardProto::AutofillCreditCardProto(const AutofillCreditCardProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  clear_has_identifier();
  switch (from.identifier_case()) {
    case kGuid: {
      _internal_set_guid(from._internal_guid());
      break;
    }
    case kSelectedCreditCard: {
      _internal_mutable_selected_credit_card()->::autofill_assistant::Empty::MergeFrom(from._internal_selected_credit_card());
      break;
    }
    case IDENTIFIER_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.AutofillCreditCardProto)
}

inline void AutofillCreditCardProto::SharedCtor() {
clear_has_identifier();
}

AutofillCreditCardProto::~AutofillCreditCardProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.AutofillCreditCardProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AutofillCreditCardProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_identifier()) {
    clear_identifier();
  }
}

void AutofillCreditCardProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void AutofillCreditCardProto::clear_identifier() {
// @@protoc_insertion_point(one_of_clear_start:autofill_assistant.AutofillCreditCardProto)
  switch (identifier_case()) {
    case kGuid: {
      identifier_.guid_.Destroy();
      break;
    }
    case kSelectedCreditCard: {
      if (GetArenaForAllocation() == nullptr) {
        delete identifier_.selected_credit_card_;
      }
      break;
    }
    case IDENTIFIER_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = IDENTIFIER_NOT_SET;
}


void AutofillCreditCardProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.AutofillCreditCardProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_identifier();
  _internal_metadata_.Clear<std::string>();
}

const char* AutofillCreditCardProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string guid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_guid();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.Empty selected_credit_card = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_selected_credit_card(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AutofillCreditCardProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.AutofillCreditCardProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (identifier_case()) {
    case kGuid: {
      target = stream->WriteStringMaybeAliased(
          1, this->_internal_guid(), target);
      break;
    }
    case kSelectedCreditCard: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, _Internal::selected_credit_card(this),
          _Internal::selected_credit_card(this).GetCachedSize(), target, stream);
      break;
    }
    default: ;
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.AutofillCreditCardProto)
  return target;
}

size_t AutofillCreditCardProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.AutofillCreditCardProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (identifier_case()) {
    // string guid = 1;
    case kGuid: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_guid());
      break;
    }
    // .autofill_assistant.Empty selected_credit_card = 2;
    case kSelectedCreditCard: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *identifier_.selected_credit_card_);
      break;
    }
    case IDENTIFIER_NOT_SET: {
      break;
    }
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void AutofillCreditCardProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const AutofillCreditCardProto*>(
      &from));
}

void AutofillCreditCardProto::MergeFrom(const AutofillCreditCardProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.AutofillCreditCardProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.identifier_case()) {
    case kGuid: {
      _internal_set_guid(from._internal_guid());
      break;
    }
    case kSelectedCreditCard: {
      _internal_mutable_selected_credit_card()->::autofill_assistant::Empty::MergeFrom(from._internal_selected_credit_card());
      break;
    }
    case IDENTIFIER_NOT_SET: {
      break;
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void AutofillCreditCardProto::CopyFrom(const AutofillCreditCardProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.AutofillCreditCardProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AutofillCreditCardProto::IsInitialized() const {
  return true;
}

void AutofillCreditCardProto::InternalSwap(AutofillCreditCardProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(identifier_, other->identifier_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

std::string AutofillCreditCardProto::GetTypeName() const {
  return "autofill_assistant.AutofillCreditCardProto";
}


// ===================================================================

class CreditCardResponseProto::_Internal {
 public:
  using HasBits = decltype(std::declval<CreditCardResponseProto>()._has_bits_);
  static void set_has_network(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CreditCardResponseProto::CreditCardResponseProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.CreditCardResponseProto)
}
CreditCardResponseProto::CreditCardResponseProto(const CreditCardResponseProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  network_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    network_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_network()) {
    network_.Set(from._internal_network(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.CreditCardResponseProto)
}

inline void CreditCardResponseProto::SharedCtor() {
network_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  network_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CreditCardResponseProto::~CreditCardResponseProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.CreditCardResponseProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CreditCardResponseProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  network_.Destroy();
}

void CreditCardResponseProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CreditCardResponseProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.CreditCardResponseProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    network_.ClearNonDefaultToEmpty();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CreditCardResponseProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string network = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_network();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CreditCardResponseProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.CreditCardResponseProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string network = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_network(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.CreditCardResponseProto)
  return target;
}

size_t CreditCardResponseProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.CreditCardResponseProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string network = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_network());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CreditCardResponseProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CreditCardResponseProto*>(
      &from));
}

void CreditCardResponseProto::MergeFrom(const CreditCardResponseProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.CreditCardResponseProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_network()) {
    _internal_set_network(from._internal_network());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CreditCardResponseProto::CopyFrom(const CreditCardResponseProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.CreditCardResponseProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CreditCardResponseProto::IsInitialized() const {
  return true;
}

void CreditCardResponseProto::InternalSwap(CreditCardResponseProto* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &network_, lhs_arena,
      &other->network_, rhs_arena
  );
}

std::string CreditCardResponseProto::GetTypeName() const {
  return "autofill_assistant.CreditCardResponseProto";
}


// ===================================================================

class AutofillProfileProto::_Internal {
 public:
};

AutofillProfileProto::AutofillProfileProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.AutofillProfileProto)
}
AutofillProfileProto::AutofillProfileProto(const AutofillProfileProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  clear_has_identifier();
  switch (from.identifier_case()) {
    case kGuid: {
      _internal_set_guid(from._internal_guid());
      break;
    }
    case kSelectedProfileName: {
      _internal_set_selected_profile_name(from._internal_selected_profile_name());
      break;
    }
    case IDENTIFIER_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.AutofillProfileProto)
}

inline void AutofillProfileProto::SharedCtor() {
clear_has_identifier();
}

AutofillProfileProto::~AutofillProfileProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.AutofillProfileProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AutofillProfileProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_identifier()) {
    clear_identifier();
  }
}

void AutofillProfileProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void AutofillProfileProto::clear_identifier() {
// @@protoc_insertion_point(one_of_clear_start:autofill_assistant.AutofillProfileProto)
  switch (identifier_case()) {
    case kGuid: {
      identifier_.guid_.Destroy();
      break;
    }
    case kSelectedProfileName: {
      identifier_.selected_profile_name_.Destroy();
      break;
    }
    case IDENTIFIER_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = IDENTIFIER_NOT_SET;
}


void AutofillProfileProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.AutofillProfileProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_identifier();
  _internal_metadata_.Clear<std::string>();
}

const char* AutofillProfileProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string guid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_guid();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string selected_profile_name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_selected_profile_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AutofillProfileProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.AutofillProfileProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (identifier_case()) {
    case kGuid: {
      target = stream->WriteStringMaybeAliased(
          1, this->_internal_guid(), target);
      break;
    }
    case kSelectedProfileName: {
      target = stream->WriteStringMaybeAliased(
          2, this->_internal_selected_profile_name(), target);
      break;
    }
    default: ;
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.AutofillProfileProto)
  return target;
}

size_t AutofillProfileProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.AutofillProfileProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (identifier_case()) {
    // string guid = 1;
    case kGuid: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_guid());
      break;
    }
    // string selected_profile_name = 2;
    case kSelectedProfileName: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_selected_profile_name());
      break;
    }
    case IDENTIFIER_NOT_SET: {
      break;
    }
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void AutofillProfileProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const AutofillProfileProto*>(
      &from));
}

void AutofillProfileProto::MergeFrom(const AutofillProfileProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.AutofillProfileProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.identifier_case()) {
    case kGuid: {
      _internal_set_guid(from._internal_guid());
      break;
    }
    case kSelectedProfileName: {
      _internal_set_selected_profile_name(from._internal_selected_profile_name());
      break;
    }
    case IDENTIFIER_NOT_SET: {
      break;
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void AutofillProfileProto::CopyFrom(const AutofillProfileProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.AutofillProfileProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AutofillProfileProto::IsInitialized() const {
  return true;
}

void AutofillProfileProto::InternalSwap(AutofillProfileProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(identifier_, other->identifier_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

std::string AutofillProfileProto::GetTypeName() const {
  return "autofill_assistant.AutofillProfileProto";
}


// ===================================================================

class LoginOptionProto::_Internal {
 public:
  using HasBits = decltype(std::declval<LoginOptionProto>()._has_bits_);
  static void set_has_label(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_sublabel(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

LoginOptionProto::LoginOptionProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.LoginOptionProto)
}
LoginOptionProto::LoginOptionProto(const LoginOptionProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  label_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    label_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_label()) {
    label_.Set(from._internal_label(), 
      GetArenaForAllocation());
  }
  sublabel_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    sublabel_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_sublabel()) {
    sublabel_.Set(from._internal_sublabel(), 
      GetArenaForAllocation());
  }
  clear_has_payload_or_tag();
  switch (from.payload_or_tag_case()) {
    case kPayload: {
      _internal_set_payload(from._internal_payload());
      break;
    }
    case kTag: {
      _internal_set_tag(from._internal_tag());
      break;
    }
    case PAYLOAD_OR_TAG_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.LoginOptionProto)
}

inline void LoginOptionProto::SharedCtor() {
label_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  label_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
sublabel_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  sublabel_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
clear_has_payload_or_tag();
}

LoginOptionProto::~LoginOptionProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.LoginOptionProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LoginOptionProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  label_.Destroy();
  sublabel_.Destroy();
  if (has_payload_or_tag()) {
    clear_payload_or_tag();
  }
}

void LoginOptionProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void LoginOptionProto::clear_payload_or_tag() {
// @@protoc_insertion_point(one_of_clear_start:autofill_assistant.LoginOptionProto)
  switch (payload_or_tag_case()) {
    case kPayload: {
      payload_or_tag_.payload_.Destroy();
      break;
    }
    case kTag: {
      payload_or_tag_.tag_.Destroy();
      break;
    }
    case PAYLOAD_OR_TAG_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = PAYLOAD_OR_TAG_NOT_SET;
}


void LoginOptionProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.LoginOptionProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      label_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      sublabel_.ClearNonDefaultToEmpty();
    }
  }
  clear_payload_or_tag();
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* LoginOptionProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string label = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_label();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string sublabel = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_sublabel();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes payload = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_payload();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string tag = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_tag();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LoginOptionProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.LoginOptionProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string label = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_label(), target);
  }

  // optional string sublabel = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_sublabel(), target);
  }

  switch (payload_or_tag_case()) {
    case kPayload: {
      target = stream->WriteBytesMaybeAliased(
          3, this->_internal_payload(), target);
      break;
    }
    case kTag: {
      target = stream->WriteStringMaybeAliased(
          4, this->_internal_tag(), target);
      break;
    }
    default: ;
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.LoginOptionProto)
  return target;
}

size_t LoginOptionProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.LoginOptionProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string label = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_label());
    }

    // optional string sublabel = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_sublabel());
    }

  }
  switch (payload_or_tag_case()) {
    // bytes payload = 3;
    case kPayload: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_payload());
      break;
    }
    // string tag = 4;
    case kTag: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_tag());
      break;
    }
    case PAYLOAD_OR_TAG_NOT_SET: {
      break;
    }
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void LoginOptionProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const LoginOptionProto*>(
      &from));
}

void LoginOptionProto::MergeFrom(const LoginOptionProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.LoginOptionProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_label(from._internal_label());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_sublabel(from._internal_sublabel());
    }
  }
  switch (from.payload_or_tag_case()) {
    case kPayload: {
      _internal_set_payload(from._internal_payload());
      break;
    }
    case kTag: {
      _internal_set_tag(from._internal_tag());
      break;
    }
    case PAYLOAD_OR_TAG_NOT_SET: {
      break;
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void LoginOptionProto::CopyFrom(const LoginOptionProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.LoginOptionProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LoginOptionProto::IsInitialized() const {
  return true;
}

void LoginOptionProto::InternalSwap(LoginOptionProto* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &label_, lhs_arena,
      &other->label_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &sublabel_, lhs_arena,
      &other->sublabel_, rhs_arena
  );
  swap(payload_or_tag_, other->payload_or_tag_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

std::string LoginOptionProto::GetTypeName() const {
  return "autofill_assistant.LoginOptionProto";
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace autofill_assistant
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::autofill_assistant::ModelProto_ModelValue*
Arena::CreateMaybeMessage< ::autofill_assistant::ModelProto_ModelValue >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::ModelProto_ModelValue >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::ModelProto*
Arena::CreateMaybeMessage< ::autofill_assistant::ModelProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::ModelProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::ValueProto*
Arena::CreateMaybeMessage< ::autofill_assistant::ValueProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::ValueProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::ValueReferenceProto*
Arena::CreateMaybeMessage< ::autofill_assistant::ValueReferenceProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::ValueReferenceProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::StringList*
Arena::CreateMaybeMessage< ::autofill_assistant::StringList >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::StringList >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::BooleanList*
Arena::CreateMaybeMessage< ::autofill_assistant::BooleanList >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::BooleanList >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::IntList*
Arena::CreateMaybeMessage< ::autofill_assistant::IntList >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::IntList >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::UserActionList*
Arena::CreateMaybeMessage< ::autofill_assistant::UserActionList >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::UserActionList >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::DateList*
Arena::CreateMaybeMessage< ::autofill_assistant::DateList >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::DateList >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::CreditCardList*
Arena::CreateMaybeMessage< ::autofill_assistant::CreditCardList >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::CreditCardList >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::ProfileList*
Arena::CreateMaybeMessage< ::autofill_assistant::ProfileList >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::ProfileList >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::LoginOptionList*
Arena::CreateMaybeMessage< ::autofill_assistant::LoginOptionList >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::LoginOptionList >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::Empty*
Arena::CreateMaybeMessage< ::autofill_assistant::Empty >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::Empty >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::ChipProto*
Arena::CreateMaybeMessage< ::autofill_assistant::ChipProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::ChipProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::DirectActionProto*
Arena::CreateMaybeMessage< ::autofill_assistant::DirectActionProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::DirectActionProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::UserActionProto*
Arena::CreateMaybeMessage< ::autofill_assistant::UserActionProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::UserActionProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::DateProto*
Arena::CreateMaybeMessage< ::autofill_assistant::DateProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::DateProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::TimeProto*
Arena::CreateMaybeMessage< ::autofill_assistant::TimeProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::TimeProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::DateTimeProto*
Arena::CreateMaybeMessage< ::autofill_assistant::DateTimeProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::DateTimeProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::AutofillCreditCardProto*
Arena::CreateMaybeMessage< ::autofill_assistant::AutofillCreditCardProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::AutofillCreditCardProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::CreditCardResponseProto*
Arena::CreateMaybeMessage< ::autofill_assistant::CreditCardResponseProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::CreditCardResponseProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::AutofillProfileProto*
Arena::CreateMaybeMessage< ::autofill_assistant::AutofillProfileProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::AutofillProfileProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::LoginOptionProto*
Arena::CreateMaybeMessage< ::autofill_assistant::LoginOptionProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::LoginOptionProto >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
