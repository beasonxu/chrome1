// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: components/autofill_assistant/browser/public/password_change/proto/actions.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_components_2fautofill_5fassistant_2fbrowser_2fpublic_2fpassword_5fchange_2fproto_2factions_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_components_2fautofill_5fassistant_2fbrowser_2fpublic_2fpassword_5fchange_2fproto_2factions_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3020000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3020000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_components_2fautofill_5fassistant_2fbrowser_2fpublic_2fpassword_5fchange_2fproto_2factions_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_components_2fautofill_5fassistant_2fbrowser_2fpublic_2fpassword_5fchange_2fproto_2factions_2eproto {
  static const uint32_t offsets[];
};
namespace autofill_assistant {
namespace password_change {
class BasePromptSpecification;
struct BasePromptSpecificationDefaultTypeInternal;
extern BasePromptSpecificationDefaultTypeInternal _BasePromptSpecification_default_instance_;
class BasePromptSpecification_Result;
struct BasePromptSpecification_ResultDefaultTypeInternal;
extern BasePromptSpecification_ResultDefaultTypeInternal _BasePromptSpecification_Result_default_instance_;
class Choice;
struct ChoiceDefaultTypeInternal;
extern ChoiceDefaultTypeInternal _Choice_default_instance_;
class GenericPasswordChangeSpecification;
struct GenericPasswordChangeSpecificationDefaultTypeInternal;
extern GenericPasswordChangeSpecificationDefaultTypeInternal _GenericPasswordChangeSpecification_default_instance_;
class GenericPasswordChangeSpecificationResult;
struct GenericPasswordChangeSpecificationResultDefaultTypeInternal;
extern GenericPasswordChangeSpecificationResultDefaultTypeInternal _GenericPasswordChangeSpecificationResult_default_instance_;
class UpdateSidePanelSpecification;
struct UpdateSidePanelSpecificationDefaultTypeInternal;
extern UpdateSidePanelSpecificationDefaultTypeInternal _UpdateSidePanelSpecification_default_instance_;
class UseGeneratedPasswordPromptSpecification;
struct UseGeneratedPasswordPromptSpecificationDefaultTypeInternal;
extern UseGeneratedPasswordPromptSpecificationDefaultTypeInternal _UseGeneratedPasswordPromptSpecification_default_instance_;
class UseGeneratedPasswordPromptSpecification_Result;
struct UseGeneratedPasswordPromptSpecification_ResultDefaultTypeInternal;
extern UseGeneratedPasswordPromptSpecification_ResultDefaultTypeInternal _UseGeneratedPasswordPromptSpecification_Result_default_instance_;
}  // namespace password_change
}  // namespace autofill_assistant
PROTOBUF_NAMESPACE_OPEN
template<> ::autofill_assistant::password_change::BasePromptSpecification* Arena::CreateMaybeMessage<::autofill_assistant::password_change::BasePromptSpecification>(Arena*);
template<> ::autofill_assistant::password_change::BasePromptSpecification_Result* Arena::CreateMaybeMessage<::autofill_assistant::password_change::BasePromptSpecification_Result>(Arena*);
template<> ::autofill_assistant::password_change::Choice* Arena::CreateMaybeMessage<::autofill_assistant::password_change::Choice>(Arena*);
template<> ::autofill_assistant::password_change::GenericPasswordChangeSpecification* Arena::CreateMaybeMessage<::autofill_assistant::password_change::GenericPasswordChangeSpecification>(Arena*);
template<> ::autofill_assistant::password_change::GenericPasswordChangeSpecificationResult* Arena::CreateMaybeMessage<::autofill_assistant::password_change::GenericPasswordChangeSpecificationResult>(Arena*);
template<> ::autofill_assistant::password_change::UpdateSidePanelSpecification* Arena::CreateMaybeMessage<::autofill_assistant::password_change::UpdateSidePanelSpecification>(Arena*);
template<> ::autofill_assistant::password_change::UseGeneratedPasswordPromptSpecification* Arena::CreateMaybeMessage<::autofill_assistant::password_change::UseGeneratedPasswordPromptSpecification>(Arena*);
template<> ::autofill_assistant::password_change::UseGeneratedPasswordPromptSpecification_Result* Arena::CreateMaybeMessage<::autofill_assistant::password_change::UseGeneratedPasswordPromptSpecification_Result>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace autofill_assistant {
namespace password_change {

enum TopIcon : int {
  TOP_ICON_UNSPECIFIED = 0,
  TOP_ICON_OPEN_SITE_SETTINGS = 1,
  TOP_ICON_ENTER_OLD_PASSWORD = 2,
  TOP_ICON_CHOOSE_NEW_PASSWORD = 3,
  TOP_ICON_SAVE_NEW_PASSWORD = 4,
  TOP_ICON_CHANGED_PASSWORD = 5,
  TOP_ICON_BAD_NEW_PASSWORD = 6,
  TOP_ICON_ERROR_OCCURRED = 7,
  TOP_ICON_USER_ACTION_REQUIRED = 8
};
bool TopIcon_IsValid(int value);
constexpr TopIcon TopIcon_MIN = TOP_ICON_UNSPECIFIED;
constexpr TopIcon TopIcon_MAX = TOP_ICON_USER_ACTION_REQUIRED;
constexpr int TopIcon_ARRAYSIZE = TopIcon_MAX + 1;

const std::string& TopIcon_Name(TopIcon value);
template<typename T>
inline const std::string& TopIcon_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TopIcon>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TopIcon_Name.");
  return TopIcon_Name(static_cast<TopIcon>(enum_t_value));
}
bool TopIcon_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TopIcon* value);
enum ProgressStep : int {
  PROGRESS_STEP_UNSPECIFIED = 0,
  PROGRESS_STEP_START = 1,
  PROGRESS_STEP_CHANGE_PASSWORD = 2,
  PROGRESS_STEP_SAVE_PASSWORD = 3,
  PROGRESS_STEP_END = 4
};
bool ProgressStep_IsValid(int value);
constexpr ProgressStep ProgressStep_MIN = PROGRESS_STEP_UNSPECIFIED;
constexpr ProgressStep ProgressStep_MAX = PROGRESS_STEP_END;
constexpr int ProgressStep_ARRAYSIZE = ProgressStep_MAX + 1;

const std::string& ProgressStep_Name(ProgressStep value);
template<typename T>
inline const std::string& ProgressStep_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ProgressStep>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ProgressStep_Name.");
  return ProgressStep_Name(static_cast<ProgressStep>(enum_t_value));
}
bool ProgressStep_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ProgressStep* value);
// ===================================================================

class Choice final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.password_change.Choice) */ {
 public:
  inline Choice() : Choice(nullptr) {}
  ~Choice() override;
  explicit PROTOBUF_CONSTEXPR Choice(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Choice(const Choice& from);
  Choice(Choice&& from) noexcept
    : Choice() {
    *this = ::std::move(from);
  }

  inline Choice& operator=(const Choice& from) {
    CopyFrom(from);
    return *this;
  }
  inline Choice& operator=(Choice&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const Choice& default_instance() {
    return *internal_default_instance();
  }
  static inline const Choice* internal_default_instance() {
    return reinterpret_cast<const Choice*>(
               &_Choice_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Choice& a, Choice& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(Choice* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Choice* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Choice* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Choice>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Choice& from);
  void MergeFrom(const Choice& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Choice* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.password_change.Choice";
  }
  protected:
  explicit Choice(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTextFieldNumber = 1,
    kTagFieldNumber = 2,
    kHighlightedFieldNumber = 3,
  };
  // optional string text = 1;
  bool has_text() const;
  private:
  bool _internal_has_text() const;
  public:
  void clear_text();
  const std::string& text() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_text(ArgT0&& arg0, ArgT... args);
  std::string* mutable_text();
  PROTOBUF_NODISCARD std::string* release_text();
  void set_allocated_text(std::string* text);
  private:
  const std::string& _internal_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_text(const std::string& value);
  std::string* _internal_mutable_text();
  public:

  // optional string tag = 2;
  bool has_tag() const;
  private:
  bool _internal_has_tag() const;
  public:
  void clear_tag();
  const std::string& tag() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tag(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tag();
  PROTOBUF_NODISCARD std::string* release_tag();
  void set_allocated_tag(std::string* tag);
  private:
  const std::string& _internal_tag() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tag(const std::string& value);
  std::string* _internal_mutable_tag();
  public:

  // optional bool highlighted = 3;
  bool has_highlighted() const;
  private:
  bool _internal_has_highlighted() const;
  public:
  void clear_highlighted();
  bool highlighted() const;
  void set_highlighted(bool value);
  private:
  bool _internal_highlighted() const;
  void _internal_set_highlighted(bool value);
  public:

  // @@protoc_insertion_point(class_scope:autofill_assistant.password_change.Choice)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tag_;
  bool highlighted_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fpublic_2fpassword_5fchange_2fproto_2factions_2eproto;
};
// -------------------------------------------------------------------

class BasePromptSpecification_Result final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.password_change.BasePromptSpecification.Result) */ {
 public:
  inline BasePromptSpecification_Result() : BasePromptSpecification_Result(nullptr) {}
  ~BasePromptSpecification_Result() override;
  explicit PROTOBUF_CONSTEXPR BasePromptSpecification_Result(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BasePromptSpecification_Result(const BasePromptSpecification_Result& from);
  BasePromptSpecification_Result(BasePromptSpecification_Result&& from) noexcept
    : BasePromptSpecification_Result() {
    *this = ::std::move(from);
  }

  inline BasePromptSpecification_Result& operator=(const BasePromptSpecification_Result& from) {
    CopyFrom(from);
    return *this;
  }
  inline BasePromptSpecification_Result& operator=(BasePromptSpecification_Result&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const BasePromptSpecification_Result& default_instance() {
    return *internal_default_instance();
  }
  static inline const BasePromptSpecification_Result* internal_default_instance() {
    return reinterpret_cast<const BasePromptSpecification_Result*>(
               &_BasePromptSpecification_Result_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(BasePromptSpecification_Result& a, BasePromptSpecification_Result& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(BasePromptSpecification_Result* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BasePromptSpecification_Result* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BasePromptSpecification_Result* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BasePromptSpecification_Result>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const BasePromptSpecification_Result& from);
  void MergeFrom(const BasePromptSpecification_Result& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BasePromptSpecification_Result* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.password_change.BasePromptSpecification.Result";
  }
  protected:
  explicit BasePromptSpecification_Result(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSelectedTagFieldNumber = 1,
  };
  // optional string selected_tag = 1;
  bool has_selected_tag() const;
  private:
  bool _internal_has_selected_tag() const;
  public:
  void clear_selected_tag();
  const std::string& selected_tag() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_selected_tag(ArgT0&& arg0, ArgT... args);
  std::string* mutable_selected_tag();
  PROTOBUF_NODISCARD std::string* release_selected_tag();
  void set_allocated_selected_tag(std::string* selected_tag);
  private:
  const std::string& _internal_selected_tag() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_selected_tag(const std::string& value);
  std::string* _internal_mutable_selected_tag();
  public:

  // @@protoc_insertion_point(class_scope:autofill_assistant.password_change.BasePromptSpecification.Result)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr selected_tag_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fpublic_2fpassword_5fchange_2fproto_2factions_2eproto;
};
// -------------------------------------------------------------------

class BasePromptSpecification final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.password_change.BasePromptSpecification) */ {
 public:
  inline BasePromptSpecification() : BasePromptSpecification(nullptr) {}
  ~BasePromptSpecification() override;
  explicit PROTOBUF_CONSTEXPR BasePromptSpecification(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BasePromptSpecification(const BasePromptSpecification& from);
  BasePromptSpecification(BasePromptSpecification&& from) noexcept
    : BasePromptSpecification() {
    *this = ::std::move(from);
  }

  inline BasePromptSpecification& operator=(const BasePromptSpecification& from) {
    CopyFrom(from);
    return *this;
  }
  inline BasePromptSpecification& operator=(BasePromptSpecification&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const BasePromptSpecification& default_instance() {
    return *internal_default_instance();
  }
  static inline const BasePromptSpecification* internal_default_instance() {
    return reinterpret_cast<const BasePromptSpecification*>(
               &_BasePromptSpecification_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(BasePromptSpecification& a, BasePromptSpecification& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(BasePromptSpecification* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BasePromptSpecification* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BasePromptSpecification* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BasePromptSpecification>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const BasePromptSpecification& from);
  void MergeFrom(const BasePromptSpecification& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BasePromptSpecification* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.password_change.BasePromptSpecification";
  }
  protected:
  explicit BasePromptSpecification(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef BasePromptSpecification_Result Result;

  // accessors -------------------------------------------------------

  enum : int {
    kChoicesFieldNumber = 3,
    kOutputKeyFieldNumber = 1,
    kTitleFieldNumber = 2,
    kDescriptionFieldNumber = 4,
  };
  // repeated .autofill_assistant.password_change.Choice choices = 3;
  int choices_size() const;
  private:
  int _internal_choices_size() const;
  public:
  void clear_choices();
  ::autofill_assistant::password_change::Choice* mutable_choices(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::password_change::Choice >*
      mutable_choices();
  private:
  const ::autofill_assistant::password_change::Choice& _internal_choices(int index) const;
  ::autofill_assistant::password_change::Choice* _internal_add_choices();
  public:
  const ::autofill_assistant::password_change::Choice& choices(int index) const;
  ::autofill_assistant::password_change::Choice* add_choices();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::password_change::Choice >&
      choices() const;

  // optional string output_key = 1;
  bool has_output_key() const;
  private:
  bool _internal_has_output_key() const;
  public:
  void clear_output_key();
  const std::string& output_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_output_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_output_key();
  PROTOBUF_NODISCARD std::string* release_output_key();
  void set_allocated_output_key(std::string* output_key);
  private:
  const std::string& _internal_output_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_output_key(const std::string& value);
  std::string* _internal_mutable_output_key();
  public:

  // optional string title = 2;
  bool has_title() const;
  private:
  bool _internal_has_title() const;
  public:
  void clear_title();
  const std::string& title() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_title(ArgT0&& arg0, ArgT... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* title);
  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(const std::string& value);
  std::string* _internal_mutable_title();
  public:

  // optional string description = 4;
  bool has_description() const;
  private:
  bool _internal_has_description() const;
  public:
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // @@protoc_insertion_point(class_scope:autofill_assistant.password_change.BasePromptSpecification)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::password_change::Choice > choices_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr output_key_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fpublic_2fpassword_5fchange_2fproto_2factions_2eproto;
};
// -------------------------------------------------------------------

class UseGeneratedPasswordPromptSpecification_Result final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.password_change.UseGeneratedPasswordPromptSpecification.Result) */ {
 public:
  inline UseGeneratedPasswordPromptSpecification_Result() : UseGeneratedPasswordPromptSpecification_Result(nullptr) {}
  ~UseGeneratedPasswordPromptSpecification_Result() override;
  explicit PROTOBUF_CONSTEXPR UseGeneratedPasswordPromptSpecification_Result(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UseGeneratedPasswordPromptSpecification_Result(const UseGeneratedPasswordPromptSpecification_Result& from);
  UseGeneratedPasswordPromptSpecification_Result(UseGeneratedPasswordPromptSpecification_Result&& from) noexcept
    : UseGeneratedPasswordPromptSpecification_Result() {
    *this = ::std::move(from);
  }

  inline UseGeneratedPasswordPromptSpecification_Result& operator=(const UseGeneratedPasswordPromptSpecification_Result& from) {
    CopyFrom(from);
    return *this;
  }
  inline UseGeneratedPasswordPromptSpecification_Result& operator=(UseGeneratedPasswordPromptSpecification_Result&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const UseGeneratedPasswordPromptSpecification_Result& default_instance() {
    return *internal_default_instance();
  }
  static inline const UseGeneratedPasswordPromptSpecification_Result* internal_default_instance() {
    return reinterpret_cast<const UseGeneratedPasswordPromptSpecification_Result*>(
               &_UseGeneratedPasswordPromptSpecification_Result_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(UseGeneratedPasswordPromptSpecification_Result& a, UseGeneratedPasswordPromptSpecification_Result& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(UseGeneratedPasswordPromptSpecification_Result* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UseGeneratedPasswordPromptSpecification_Result* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UseGeneratedPasswordPromptSpecification_Result* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UseGeneratedPasswordPromptSpecification_Result>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const UseGeneratedPasswordPromptSpecification_Result& from);
  void MergeFrom(const UseGeneratedPasswordPromptSpecification_Result& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(UseGeneratedPasswordPromptSpecification_Result* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.password_change.UseGeneratedPasswordPromptSpecification.Result";
  }
  protected:
  explicit UseGeneratedPasswordPromptSpecification_Result(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGeneratedPasswordAcceptedFieldNumber = 1,
  };
  // optional bool generated_password_accepted = 1;
  bool has_generated_password_accepted() const;
  private:
  bool _internal_has_generated_password_accepted() const;
  public:
  void clear_generated_password_accepted();
  bool generated_password_accepted() const;
  void set_generated_password_accepted(bool value);
  private:
  bool _internal_generated_password_accepted() const;
  void _internal_set_generated_password_accepted(bool value);
  public:

  // @@protoc_insertion_point(class_scope:autofill_assistant.password_change.UseGeneratedPasswordPromptSpecification.Result)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  bool generated_password_accepted_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fpublic_2fpassword_5fchange_2fproto_2factions_2eproto;
};
// -------------------------------------------------------------------

class UseGeneratedPasswordPromptSpecification final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.password_change.UseGeneratedPasswordPromptSpecification) */ {
 public:
  inline UseGeneratedPasswordPromptSpecification() : UseGeneratedPasswordPromptSpecification(nullptr) {}
  ~UseGeneratedPasswordPromptSpecification() override;
  explicit PROTOBUF_CONSTEXPR UseGeneratedPasswordPromptSpecification(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UseGeneratedPasswordPromptSpecification(const UseGeneratedPasswordPromptSpecification& from);
  UseGeneratedPasswordPromptSpecification(UseGeneratedPasswordPromptSpecification&& from) noexcept
    : UseGeneratedPasswordPromptSpecification() {
    *this = ::std::move(from);
  }

  inline UseGeneratedPasswordPromptSpecification& operator=(const UseGeneratedPasswordPromptSpecification& from) {
    CopyFrom(from);
    return *this;
  }
  inline UseGeneratedPasswordPromptSpecification& operator=(UseGeneratedPasswordPromptSpecification&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const UseGeneratedPasswordPromptSpecification& default_instance() {
    return *internal_default_instance();
  }
  static inline const UseGeneratedPasswordPromptSpecification* internal_default_instance() {
    return reinterpret_cast<const UseGeneratedPasswordPromptSpecification*>(
               &_UseGeneratedPasswordPromptSpecification_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(UseGeneratedPasswordPromptSpecification& a, UseGeneratedPasswordPromptSpecification& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(UseGeneratedPasswordPromptSpecification* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UseGeneratedPasswordPromptSpecification* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UseGeneratedPasswordPromptSpecification* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UseGeneratedPasswordPromptSpecification>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const UseGeneratedPasswordPromptSpecification& from);
  void MergeFrom(const UseGeneratedPasswordPromptSpecification& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(UseGeneratedPasswordPromptSpecification* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.password_change.UseGeneratedPasswordPromptSpecification";
  }
  protected:
  explicit UseGeneratedPasswordPromptSpecification(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef UseGeneratedPasswordPromptSpecification_Result Result;

  // accessors -------------------------------------------------------

  enum : int {
    kTitleFieldNumber = 2,
    kDescriptionFieldNumber = 3,
    kManualPasswordChoiceFieldNumber = 4,
    kGeneratedPasswordChoiceFieldNumber = 5,
  };
  // optional string title = 2;
  bool has_title() const;
  private:
  bool _internal_has_title() const;
  public:
  void clear_title();
  const std::string& title() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_title(ArgT0&& arg0, ArgT... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* title);
  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(const std::string& value);
  std::string* _internal_mutable_title();
  public:

  // optional string description = 3;
  bool has_description() const;
  private:
  bool _internal_has_description() const;
  public:
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // optional .autofill_assistant.password_change.Choice manual_password_choice = 4;
  bool has_manual_password_choice() const;
  private:
  bool _internal_has_manual_password_choice() const;
  public:
  void clear_manual_password_choice();
  const ::autofill_assistant::password_change::Choice& manual_password_choice() const;
  PROTOBUF_NODISCARD ::autofill_assistant::password_change::Choice* release_manual_password_choice();
  ::autofill_assistant::password_change::Choice* mutable_manual_password_choice();
  void set_allocated_manual_password_choice(::autofill_assistant::password_change::Choice* manual_password_choice);
  private:
  const ::autofill_assistant::password_change::Choice& _internal_manual_password_choice() const;
  ::autofill_assistant::password_change::Choice* _internal_mutable_manual_password_choice();
  public:
  void unsafe_arena_set_allocated_manual_password_choice(
      ::autofill_assistant::password_change::Choice* manual_password_choice);
  ::autofill_assistant::password_change::Choice* unsafe_arena_release_manual_password_choice();

  // optional .autofill_assistant.password_change.Choice generated_password_choice = 5;
  bool has_generated_password_choice() const;
  private:
  bool _internal_has_generated_password_choice() const;
  public:
  void clear_generated_password_choice();
  const ::autofill_assistant::password_change::Choice& generated_password_choice() const;
  PROTOBUF_NODISCARD ::autofill_assistant::password_change::Choice* release_generated_password_choice();
  ::autofill_assistant::password_change::Choice* mutable_generated_password_choice();
  void set_allocated_generated_password_choice(::autofill_assistant::password_change::Choice* generated_password_choice);
  private:
  const ::autofill_assistant::password_change::Choice& _internal_generated_password_choice() const;
  ::autofill_assistant::password_change::Choice* _internal_mutable_generated_password_choice();
  public:
  void unsafe_arena_set_allocated_generated_password_choice(
      ::autofill_assistant::password_change::Choice* generated_password_choice);
  ::autofill_assistant::password_change::Choice* unsafe_arena_release_generated_password_choice();

  // @@protoc_insertion_point(class_scope:autofill_assistant.password_change.UseGeneratedPasswordPromptSpecification)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
  ::autofill_assistant::password_change::Choice* manual_password_choice_;
  ::autofill_assistant::password_change::Choice* generated_password_choice_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fpublic_2fpassword_5fchange_2fproto_2factions_2eproto;
};
// -------------------------------------------------------------------

class UpdateSidePanelSpecification final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.password_change.UpdateSidePanelSpecification) */ {
 public:
  inline UpdateSidePanelSpecification() : UpdateSidePanelSpecification(nullptr) {}
  ~UpdateSidePanelSpecification() override;
  explicit PROTOBUF_CONSTEXPR UpdateSidePanelSpecification(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateSidePanelSpecification(const UpdateSidePanelSpecification& from);
  UpdateSidePanelSpecification(UpdateSidePanelSpecification&& from) noexcept
    : UpdateSidePanelSpecification() {
    *this = ::std::move(from);
  }

  inline UpdateSidePanelSpecification& operator=(const UpdateSidePanelSpecification& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateSidePanelSpecification& operator=(UpdateSidePanelSpecification&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const UpdateSidePanelSpecification& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateSidePanelSpecification* internal_default_instance() {
    return reinterpret_cast<const UpdateSidePanelSpecification*>(
               &_UpdateSidePanelSpecification_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(UpdateSidePanelSpecification& a, UpdateSidePanelSpecification& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(UpdateSidePanelSpecification* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateSidePanelSpecification* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateSidePanelSpecification* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateSidePanelSpecification>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const UpdateSidePanelSpecification& from);
  void MergeFrom(const UpdateSidePanelSpecification& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(UpdateSidePanelSpecification* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.password_change.UpdateSidePanelSpecification";
  }
  protected:
  explicit UpdateSidePanelSpecification(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTitleFieldNumber = 2,
    kDescriptionFieldNumber = 3,
    kTopIconFieldNumber = 1,
    kProgressStepFieldNumber = 4,
  };
  // optional string title = 2;
  bool has_title() const;
  private:
  bool _internal_has_title() const;
  public:
  void clear_title();
  const std::string& title() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_title(ArgT0&& arg0, ArgT... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* title);
  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(const std::string& value);
  std::string* _internal_mutable_title();
  public:

  // optional string description = 3;
  bool has_description() const;
  private:
  bool _internal_has_description() const;
  public:
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // optional .autofill_assistant.password_change.TopIcon top_icon = 1;
  bool has_top_icon() const;
  private:
  bool _internal_has_top_icon() const;
  public:
  void clear_top_icon();
  ::autofill_assistant::password_change::TopIcon top_icon() const;
  void set_top_icon(::autofill_assistant::password_change::TopIcon value);
  private:
  ::autofill_assistant::password_change::TopIcon _internal_top_icon() const;
  void _internal_set_top_icon(::autofill_assistant::password_change::TopIcon value);
  public:

  // optional .autofill_assistant.password_change.ProgressStep progress_step = 4;
  bool has_progress_step() const;
  private:
  bool _internal_has_progress_step() const;
  public:
  void clear_progress_step();
  ::autofill_assistant::password_change::ProgressStep progress_step() const;
  void set_progress_step(::autofill_assistant::password_change::ProgressStep value);
  private:
  ::autofill_assistant::password_change::ProgressStep _internal_progress_step() const;
  void _internal_set_progress_step(::autofill_assistant::password_change::ProgressStep value);
  public:

  // @@protoc_insertion_point(class_scope:autofill_assistant.password_change.UpdateSidePanelSpecification)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
  int top_icon_;
  int progress_step_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fpublic_2fpassword_5fchange_2fproto_2factions_2eproto;
};
// -------------------------------------------------------------------

class GenericPasswordChangeSpecification final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.password_change.GenericPasswordChangeSpecification) */ {
 public:
  inline GenericPasswordChangeSpecification() : GenericPasswordChangeSpecification(nullptr) {}
  ~GenericPasswordChangeSpecification() override;
  explicit PROTOBUF_CONSTEXPR GenericPasswordChangeSpecification(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GenericPasswordChangeSpecification(const GenericPasswordChangeSpecification& from);
  GenericPasswordChangeSpecification(GenericPasswordChangeSpecification&& from) noexcept
    : GenericPasswordChangeSpecification() {
    *this = ::std::move(from);
  }

  inline GenericPasswordChangeSpecification& operator=(const GenericPasswordChangeSpecification& from) {
    CopyFrom(from);
    return *this;
  }
  inline GenericPasswordChangeSpecification& operator=(GenericPasswordChangeSpecification&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const GenericPasswordChangeSpecification& default_instance() {
    return *internal_default_instance();
  }
  enum SpecificationCase {
    kBasePrompt = 1,
    kUseGeneratedPasswordPrompt = 2,
    kUpdateSidePanel = 3,
    SPECIFICATION_NOT_SET = 0,
  };

  static inline const GenericPasswordChangeSpecification* internal_default_instance() {
    return reinterpret_cast<const GenericPasswordChangeSpecification*>(
               &_GenericPasswordChangeSpecification_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(GenericPasswordChangeSpecification& a, GenericPasswordChangeSpecification& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(GenericPasswordChangeSpecification* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GenericPasswordChangeSpecification* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GenericPasswordChangeSpecification* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GenericPasswordChangeSpecification>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const GenericPasswordChangeSpecification& from);
  void MergeFrom(const GenericPasswordChangeSpecification& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GenericPasswordChangeSpecification* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.password_change.GenericPasswordChangeSpecification";
  }
  protected:
  explicit GenericPasswordChangeSpecification(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBasePromptFieldNumber = 1,
    kUseGeneratedPasswordPromptFieldNumber = 2,
    kUpdateSidePanelFieldNumber = 3,
  };
  // .autofill_assistant.password_change.BasePromptSpecification base_prompt = 1;
  bool has_base_prompt() const;
  private:
  bool _internal_has_base_prompt() const;
  public:
  void clear_base_prompt();
  const ::autofill_assistant::password_change::BasePromptSpecification& base_prompt() const;
  PROTOBUF_NODISCARD ::autofill_assistant::password_change::BasePromptSpecification* release_base_prompt();
  ::autofill_assistant::password_change::BasePromptSpecification* mutable_base_prompt();
  void set_allocated_base_prompt(::autofill_assistant::password_change::BasePromptSpecification* base_prompt);
  private:
  const ::autofill_assistant::password_change::BasePromptSpecification& _internal_base_prompt() const;
  ::autofill_assistant::password_change::BasePromptSpecification* _internal_mutable_base_prompt();
  public:
  void unsafe_arena_set_allocated_base_prompt(
      ::autofill_assistant::password_change::BasePromptSpecification* base_prompt);
  ::autofill_assistant::password_change::BasePromptSpecification* unsafe_arena_release_base_prompt();

  // .autofill_assistant.password_change.UseGeneratedPasswordPromptSpecification use_generated_password_prompt = 2;
  bool has_use_generated_password_prompt() const;
  private:
  bool _internal_has_use_generated_password_prompt() const;
  public:
  void clear_use_generated_password_prompt();
  const ::autofill_assistant::password_change::UseGeneratedPasswordPromptSpecification& use_generated_password_prompt() const;
  PROTOBUF_NODISCARD ::autofill_assistant::password_change::UseGeneratedPasswordPromptSpecification* release_use_generated_password_prompt();
  ::autofill_assistant::password_change::UseGeneratedPasswordPromptSpecification* mutable_use_generated_password_prompt();
  void set_allocated_use_generated_password_prompt(::autofill_assistant::password_change::UseGeneratedPasswordPromptSpecification* use_generated_password_prompt);
  private:
  const ::autofill_assistant::password_change::UseGeneratedPasswordPromptSpecification& _internal_use_generated_password_prompt() const;
  ::autofill_assistant::password_change::UseGeneratedPasswordPromptSpecification* _internal_mutable_use_generated_password_prompt();
  public:
  void unsafe_arena_set_allocated_use_generated_password_prompt(
      ::autofill_assistant::password_change::UseGeneratedPasswordPromptSpecification* use_generated_password_prompt);
  ::autofill_assistant::password_change::UseGeneratedPasswordPromptSpecification* unsafe_arena_release_use_generated_password_prompt();

  // .autofill_assistant.password_change.UpdateSidePanelSpecification update_side_panel = 3;
  bool has_update_side_panel() const;
  private:
  bool _internal_has_update_side_panel() const;
  public:
  void clear_update_side_panel();
  const ::autofill_assistant::password_change::UpdateSidePanelSpecification& update_side_panel() const;
  PROTOBUF_NODISCARD ::autofill_assistant::password_change::UpdateSidePanelSpecification* release_update_side_panel();
  ::autofill_assistant::password_change::UpdateSidePanelSpecification* mutable_update_side_panel();
  void set_allocated_update_side_panel(::autofill_assistant::password_change::UpdateSidePanelSpecification* update_side_panel);
  private:
  const ::autofill_assistant::password_change::UpdateSidePanelSpecification& _internal_update_side_panel() const;
  ::autofill_assistant::password_change::UpdateSidePanelSpecification* _internal_mutable_update_side_panel();
  public:
  void unsafe_arena_set_allocated_update_side_panel(
      ::autofill_assistant::password_change::UpdateSidePanelSpecification* update_side_panel);
  ::autofill_assistant::password_change::UpdateSidePanelSpecification* unsafe_arena_release_update_side_panel();

  void clear_specification();
  SpecificationCase specification_case() const;
  // @@protoc_insertion_point(class_scope:autofill_assistant.password_change.GenericPasswordChangeSpecification)
 private:
  class _Internal;
  void set_has_base_prompt();
  void set_has_use_generated_password_prompt();
  void set_has_update_side_panel();

  inline bool has_specification() const;
  inline void clear_has_specification();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union SpecificationUnion {
    constexpr SpecificationUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::autofill_assistant::password_change::BasePromptSpecification* base_prompt_;
    ::autofill_assistant::password_change::UseGeneratedPasswordPromptSpecification* use_generated_password_prompt_;
    ::autofill_assistant::password_change::UpdateSidePanelSpecification* update_side_panel_;
  } specification_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fpublic_2fpassword_5fchange_2fproto_2factions_2eproto;
};
// -------------------------------------------------------------------

class GenericPasswordChangeSpecificationResult final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.password_change.GenericPasswordChangeSpecificationResult) */ {
 public:
  inline GenericPasswordChangeSpecificationResult() : GenericPasswordChangeSpecificationResult(nullptr) {}
  ~GenericPasswordChangeSpecificationResult() override;
  explicit PROTOBUF_CONSTEXPR GenericPasswordChangeSpecificationResult(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GenericPasswordChangeSpecificationResult(const GenericPasswordChangeSpecificationResult& from);
  GenericPasswordChangeSpecificationResult(GenericPasswordChangeSpecificationResult&& from) noexcept
    : GenericPasswordChangeSpecificationResult() {
    *this = ::std::move(from);
  }

  inline GenericPasswordChangeSpecificationResult& operator=(const GenericPasswordChangeSpecificationResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline GenericPasswordChangeSpecificationResult& operator=(GenericPasswordChangeSpecificationResult&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const GenericPasswordChangeSpecificationResult& default_instance() {
    return *internal_default_instance();
  }
  enum ResultCase {
    kBasePromptResult = 1,
    kUseGeneratedPasswordPromptResult = 2,
    RESULT_NOT_SET = 0,
  };

  static inline const GenericPasswordChangeSpecificationResult* internal_default_instance() {
    return reinterpret_cast<const GenericPasswordChangeSpecificationResult*>(
               &_GenericPasswordChangeSpecificationResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(GenericPasswordChangeSpecificationResult& a, GenericPasswordChangeSpecificationResult& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(GenericPasswordChangeSpecificationResult* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GenericPasswordChangeSpecificationResult* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GenericPasswordChangeSpecificationResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GenericPasswordChangeSpecificationResult>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const GenericPasswordChangeSpecificationResult& from);
  void MergeFrom(const GenericPasswordChangeSpecificationResult& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GenericPasswordChangeSpecificationResult* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.password_change.GenericPasswordChangeSpecificationResult";
  }
  protected:
  explicit GenericPasswordChangeSpecificationResult(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBasePromptResultFieldNumber = 1,
    kUseGeneratedPasswordPromptResultFieldNumber = 2,
  };
  // .autofill_assistant.password_change.BasePromptSpecification.Result base_prompt_result = 1;
  bool has_base_prompt_result() const;
  private:
  bool _internal_has_base_prompt_result() const;
  public:
  void clear_base_prompt_result();
  const ::autofill_assistant::password_change::BasePromptSpecification_Result& base_prompt_result() const;
  PROTOBUF_NODISCARD ::autofill_assistant::password_change::BasePromptSpecification_Result* release_base_prompt_result();
  ::autofill_assistant::password_change::BasePromptSpecification_Result* mutable_base_prompt_result();
  void set_allocated_base_prompt_result(::autofill_assistant::password_change::BasePromptSpecification_Result* base_prompt_result);
  private:
  const ::autofill_assistant::password_change::BasePromptSpecification_Result& _internal_base_prompt_result() const;
  ::autofill_assistant::password_change::BasePromptSpecification_Result* _internal_mutable_base_prompt_result();
  public:
  void unsafe_arena_set_allocated_base_prompt_result(
      ::autofill_assistant::password_change::BasePromptSpecification_Result* base_prompt_result);
  ::autofill_assistant::password_change::BasePromptSpecification_Result* unsafe_arena_release_base_prompt_result();

  // .autofill_assistant.password_change.UseGeneratedPasswordPromptSpecification.Result use_generated_password_prompt_result = 2;
  bool has_use_generated_password_prompt_result() const;
  private:
  bool _internal_has_use_generated_password_prompt_result() const;
  public:
  void clear_use_generated_password_prompt_result();
  const ::autofill_assistant::password_change::UseGeneratedPasswordPromptSpecification_Result& use_generated_password_prompt_result() const;
  PROTOBUF_NODISCARD ::autofill_assistant::password_change::UseGeneratedPasswordPromptSpecification_Result* release_use_generated_password_prompt_result();
  ::autofill_assistant::password_change::UseGeneratedPasswordPromptSpecification_Result* mutable_use_generated_password_prompt_result();
  void set_allocated_use_generated_password_prompt_result(::autofill_assistant::password_change::UseGeneratedPasswordPromptSpecification_Result* use_generated_password_prompt_result);
  private:
  const ::autofill_assistant::password_change::UseGeneratedPasswordPromptSpecification_Result& _internal_use_generated_password_prompt_result() const;
  ::autofill_assistant::password_change::UseGeneratedPasswordPromptSpecification_Result* _internal_mutable_use_generated_password_prompt_result();
  public:
  void unsafe_arena_set_allocated_use_generated_password_prompt_result(
      ::autofill_assistant::password_change::UseGeneratedPasswordPromptSpecification_Result* use_generated_password_prompt_result);
  ::autofill_assistant::password_change::UseGeneratedPasswordPromptSpecification_Result* unsafe_arena_release_use_generated_password_prompt_result();

  void clear_result();
  ResultCase result_case() const;
  // @@protoc_insertion_point(class_scope:autofill_assistant.password_change.GenericPasswordChangeSpecificationResult)
 private:
  class _Internal;
  void set_has_base_prompt_result();
  void set_has_use_generated_password_prompt_result();

  inline bool has_result() const;
  inline void clear_has_result();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union ResultUnion {
    constexpr ResultUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::autofill_assistant::password_change::BasePromptSpecification_Result* base_prompt_result_;
    ::autofill_assistant::password_change::UseGeneratedPasswordPromptSpecification_Result* use_generated_password_prompt_result_;
  } result_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fpublic_2fpassword_5fchange_2fproto_2factions_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Choice

// optional string text = 1;
inline bool Choice::_internal_has_text() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Choice::has_text() const {
  return _internal_has_text();
}
inline void Choice::clear_text() {
  text_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Choice::text() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.password_change.Choice.text)
  return _internal_text();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Choice::set_text(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 text_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.password_change.Choice.text)
}
inline std::string* Choice::mutable_text() {
  std::string* _s = _internal_mutable_text();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.password_change.Choice.text)
  return _s;
}
inline const std::string& Choice::_internal_text() const {
  return text_.Get();
}
inline void Choice::_internal_set_text(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  text_.Set(value, GetArenaForAllocation());
}
inline std::string* Choice::_internal_mutable_text() {
  _has_bits_[0] |= 0x00000001u;
  return text_.Mutable(GetArenaForAllocation());
}
inline std::string* Choice::release_text() {
  // @@protoc_insertion_point(field_release:autofill_assistant.password_change.Choice.text)
  if (!_internal_has_text()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = text_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (text_.IsDefault()) {
    text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Choice::set_allocated_text(std::string* text) {
  if (text != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  text_.SetAllocated(text, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (text_.IsDefault()) {
    text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.password_change.Choice.text)
}

// optional string tag = 2;
inline bool Choice::_internal_has_tag() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Choice::has_tag() const {
  return _internal_has_tag();
}
inline void Choice::clear_tag() {
  tag_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Choice::tag() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.password_change.Choice.tag)
  return _internal_tag();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Choice::set_tag(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 tag_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.password_change.Choice.tag)
}
inline std::string* Choice::mutable_tag() {
  std::string* _s = _internal_mutable_tag();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.password_change.Choice.tag)
  return _s;
}
inline const std::string& Choice::_internal_tag() const {
  return tag_.Get();
}
inline void Choice::_internal_set_tag(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  tag_.Set(value, GetArenaForAllocation());
}
inline std::string* Choice::_internal_mutable_tag() {
  _has_bits_[0] |= 0x00000002u;
  return tag_.Mutable(GetArenaForAllocation());
}
inline std::string* Choice::release_tag() {
  // @@protoc_insertion_point(field_release:autofill_assistant.password_change.Choice.tag)
  if (!_internal_has_tag()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = tag_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (tag_.IsDefault()) {
    tag_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Choice::set_allocated_tag(std::string* tag) {
  if (tag != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  tag_.SetAllocated(tag, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (tag_.IsDefault()) {
    tag_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.password_change.Choice.tag)
}

// optional bool highlighted = 3;
inline bool Choice::_internal_has_highlighted() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Choice::has_highlighted() const {
  return _internal_has_highlighted();
}
inline void Choice::clear_highlighted() {
  highlighted_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool Choice::_internal_highlighted() const {
  return highlighted_;
}
inline bool Choice::highlighted() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.password_change.Choice.highlighted)
  return _internal_highlighted();
}
inline void Choice::_internal_set_highlighted(bool value) {
  _has_bits_[0] |= 0x00000004u;
  highlighted_ = value;
}
inline void Choice::set_highlighted(bool value) {
  _internal_set_highlighted(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.password_change.Choice.highlighted)
}

// -------------------------------------------------------------------

// BasePromptSpecification_Result

// optional string selected_tag = 1;
inline bool BasePromptSpecification_Result::_internal_has_selected_tag() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool BasePromptSpecification_Result::has_selected_tag() const {
  return _internal_has_selected_tag();
}
inline void BasePromptSpecification_Result::clear_selected_tag() {
  selected_tag_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& BasePromptSpecification_Result::selected_tag() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.password_change.BasePromptSpecification.Result.selected_tag)
  return _internal_selected_tag();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BasePromptSpecification_Result::set_selected_tag(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 selected_tag_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.password_change.BasePromptSpecification.Result.selected_tag)
}
inline std::string* BasePromptSpecification_Result::mutable_selected_tag() {
  std::string* _s = _internal_mutable_selected_tag();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.password_change.BasePromptSpecification.Result.selected_tag)
  return _s;
}
inline const std::string& BasePromptSpecification_Result::_internal_selected_tag() const {
  return selected_tag_.Get();
}
inline void BasePromptSpecification_Result::_internal_set_selected_tag(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  selected_tag_.Set(value, GetArenaForAllocation());
}
inline std::string* BasePromptSpecification_Result::_internal_mutable_selected_tag() {
  _has_bits_[0] |= 0x00000001u;
  return selected_tag_.Mutable(GetArenaForAllocation());
}
inline std::string* BasePromptSpecification_Result::release_selected_tag() {
  // @@protoc_insertion_point(field_release:autofill_assistant.password_change.BasePromptSpecification.Result.selected_tag)
  if (!_internal_has_selected_tag()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = selected_tag_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (selected_tag_.IsDefault()) {
    selected_tag_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void BasePromptSpecification_Result::set_allocated_selected_tag(std::string* selected_tag) {
  if (selected_tag != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  selected_tag_.SetAllocated(selected_tag, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (selected_tag_.IsDefault()) {
    selected_tag_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.password_change.BasePromptSpecification.Result.selected_tag)
}

// -------------------------------------------------------------------

// BasePromptSpecification

// optional string output_key = 1;
inline bool BasePromptSpecification::_internal_has_output_key() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool BasePromptSpecification::has_output_key() const {
  return _internal_has_output_key();
}
inline void BasePromptSpecification::clear_output_key() {
  output_key_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& BasePromptSpecification::output_key() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.password_change.BasePromptSpecification.output_key)
  return _internal_output_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BasePromptSpecification::set_output_key(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 output_key_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.password_change.BasePromptSpecification.output_key)
}
inline std::string* BasePromptSpecification::mutable_output_key() {
  std::string* _s = _internal_mutable_output_key();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.password_change.BasePromptSpecification.output_key)
  return _s;
}
inline const std::string& BasePromptSpecification::_internal_output_key() const {
  return output_key_.Get();
}
inline void BasePromptSpecification::_internal_set_output_key(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  output_key_.Set(value, GetArenaForAllocation());
}
inline std::string* BasePromptSpecification::_internal_mutable_output_key() {
  _has_bits_[0] |= 0x00000001u;
  return output_key_.Mutable(GetArenaForAllocation());
}
inline std::string* BasePromptSpecification::release_output_key() {
  // @@protoc_insertion_point(field_release:autofill_assistant.password_change.BasePromptSpecification.output_key)
  if (!_internal_has_output_key()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = output_key_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (output_key_.IsDefault()) {
    output_key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void BasePromptSpecification::set_allocated_output_key(std::string* output_key) {
  if (output_key != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  output_key_.SetAllocated(output_key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (output_key_.IsDefault()) {
    output_key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.password_change.BasePromptSpecification.output_key)
}

// optional string title = 2;
inline bool BasePromptSpecification::_internal_has_title() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool BasePromptSpecification::has_title() const {
  return _internal_has_title();
}
inline void BasePromptSpecification::clear_title() {
  title_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& BasePromptSpecification::title() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.password_change.BasePromptSpecification.title)
  return _internal_title();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BasePromptSpecification::set_title(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 title_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.password_change.BasePromptSpecification.title)
}
inline std::string* BasePromptSpecification::mutable_title() {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.password_change.BasePromptSpecification.title)
  return _s;
}
inline const std::string& BasePromptSpecification::_internal_title() const {
  return title_.Get();
}
inline void BasePromptSpecification::_internal_set_title(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  title_.Set(value, GetArenaForAllocation());
}
inline std::string* BasePromptSpecification::_internal_mutable_title() {
  _has_bits_[0] |= 0x00000002u;
  return title_.Mutable(GetArenaForAllocation());
}
inline std::string* BasePromptSpecification::release_title() {
  // @@protoc_insertion_point(field_release:autofill_assistant.password_change.BasePromptSpecification.title)
  if (!_internal_has_title()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = title_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (title_.IsDefault()) {
    title_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void BasePromptSpecification::set_allocated_title(std::string* title) {
  if (title != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  title_.SetAllocated(title, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (title_.IsDefault()) {
    title_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.password_change.BasePromptSpecification.title)
}

// optional string description = 4;
inline bool BasePromptSpecification::_internal_has_description() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool BasePromptSpecification::has_description() const {
  return _internal_has_description();
}
inline void BasePromptSpecification::clear_description() {
  description_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& BasePromptSpecification::description() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.password_change.BasePromptSpecification.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BasePromptSpecification::set_description(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.password_change.BasePromptSpecification.description)
}
inline std::string* BasePromptSpecification::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.password_change.BasePromptSpecification.description)
  return _s;
}
inline const std::string& BasePromptSpecification::_internal_description() const {
  return description_.Get();
}
inline void BasePromptSpecification::_internal_set_description(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  description_.Set(value, GetArenaForAllocation());
}
inline std::string* BasePromptSpecification::_internal_mutable_description() {
  _has_bits_[0] |= 0x00000004u;
  return description_.Mutable(GetArenaForAllocation());
}
inline std::string* BasePromptSpecification::release_description() {
  // @@protoc_insertion_point(field_release:autofill_assistant.password_change.BasePromptSpecification.description)
  if (!_internal_has_description()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = description_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (description_.IsDefault()) {
    description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void BasePromptSpecification::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (description_.IsDefault()) {
    description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.password_change.BasePromptSpecification.description)
}

// repeated .autofill_assistant.password_change.Choice choices = 3;
inline int BasePromptSpecification::_internal_choices_size() const {
  return choices_.size();
}
inline int BasePromptSpecification::choices_size() const {
  return _internal_choices_size();
}
inline void BasePromptSpecification::clear_choices() {
  choices_.Clear();
}
inline ::autofill_assistant::password_change::Choice* BasePromptSpecification::mutable_choices(int index) {
  // @@protoc_insertion_point(field_mutable:autofill_assistant.password_change.BasePromptSpecification.choices)
  return choices_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::password_change::Choice >*
BasePromptSpecification::mutable_choices() {
  // @@protoc_insertion_point(field_mutable_list:autofill_assistant.password_change.BasePromptSpecification.choices)
  return &choices_;
}
inline const ::autofill_assistant::password_change::Choice& BasePromptSpecification::_internal_choices(int index) const {
  return choices_.Get(index);
}
inline const ::autofill_assistant::password_change::Choice& BasePromptSpecification::choices(int index) const {
  // @@protoc_insertion_point(field_get:autofill_assistant.password_change.BasePromptSpecification.choices)
  return _internal_choices(index);
}
inline ::autofill_assistant::password_change::Choice* BasePromptSpecification::_internal_add_choices() {
  return choices_.Add();
}
inline ::autofill_assistant::password_change::Choice* BasePromptSpecification::add_choices() {
  ::autofill_assistant::password_change::Choice* _add = _internal_add_choices();
  // @@protoc_insertion_point(field_add:autofill_assistant.password_change.BasePromptSpecification.choices)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::password_change::Choice >&
BasePromptSpecification::choices() const {
  // @@protoc_insertion_point(field_list:autofill_assistant.password_change.BasePromptSpecification.choices)
  return choices_;
}

// -------------------------------------------------------------------

// UseGeneratedPasswordPromptSpecification_Result

// optional bool generated_password_accepted = 1;
inline bool UseGeneratedPasswordPromptSpecification_Result::_internal_has_generated_password_accepted() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool UseGeneratedPasswordPromptSpecification_Result::has_generated_password_accepted() const {
  return _internal_has_generated_password_accepted();
}
inline void UseGeneratedPasswordPromptSpecification_Result::clear_generated_password_accepted() {
  generated_password_accepted_ = false;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool UseGeneratedPasswordPromptSpecification_Result::_internal_generated_password_accepted() const {
  return generated_password_accepted_;
}
inline bool UseGeneratedPasswordPromptSpecification_Result::generated_password_accepted() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.password_change.UseGeneratedPasswordPromptSpecification.Result.generated_password_accepted)
  return _internal_generated_password_accepted();
}
inline void UseGeneratedPasswordPromptSpecification_Result::_internal_set_generated_password_accepted(bool value) {
  _has_bits_[0] |= 0x00000001u;
  generated_password_accepted_ = value;
}
inline void UseGeneratedPasswordPromptSpecification_Result::set_generated_password_accepted(bool value) {
  _internal_set_generated_password_accepted(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.password_change.UseGeneratedPasswordPromptSpecification.Result.generated_password_accepted)
}

// -------------------------------------------------------------------

// UseGeneratedPasswordPromptSpecification

// optional string title = 2;
inline bool UseGeneratedPasswordPromptSpecification::_internal_has_title() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool UseGeneratedPasswordPromptSpecification::has_title() const {
  return _internal_has_title();
}
inline void UseGeneratedPasswordPromptSpecification::clear_title() {
  title_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& UseGeneratedPasswordPromptSpecification::title() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.password_change.UseGeneratedPasswordPromptSpecification.title)
  return _internal_title();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UseGeneratedPasswordPromptSpecification::set_title(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 title_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.password_change.UseGeneratedPasswordPromptSpecification.title)
}
inline std::string* UseGeneratedPasswordPromptSpecification::mutable_title() {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.password_change.UseGeneratedPasswordPromptSpecification.title)
  return _s;
}
inline const std::string& UseGeneratedPasswordPromptSpecification::_internal_title() const {
  return title_.Get();
}
inline void UseGeneratedPasswordPromptSpecification::_internal_set_title(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  title_.Set(value, GetArenaForAllocation());
}
inline std::string* UseGeneratedPasswordPromptSpecification::_internal_mutable_title() {
  _has_bits_[0] |= 0x00000001u;
  return title_.Mutable(GetArenaForAllocation());
}
inline std::string* UseGeneratedPasswordPromptSpecification::release_title() {
  // @@protoc_insertion_point(field_release:autofill_assistant.password_change.UseGeneratedPasswordPromptSpecification.title)
  if (!_internal_has_title()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = title_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (title_.IsDefault()) {
    title_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void UseGeneratedPasswordPromptSpecification::set_allocated_title(std::string* title) {
  if (title != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  title_.SetAllocated(title, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (title_.IsDefault()) {
    title_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.password_change.UseGeneratedPasswordPromptSpecification.title)
}

// optional string description = 3;
inline bool UseGeneratedPasswordPromptSpecification::_internal_has_description() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool UseGeneratedPasswordPromptSpecification::has_description() const {
  return _internal_has_description();
}
inline void UseGeneratedPasswordPromptSpecification::clear_description() {
  description_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& UseGeneratedPasswordPromptSpecification::description() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.password_change.UseGeneratedPasswordPromptSpecification.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UseGeneratedPasswordPromptSpecification::set_description(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.password_change.UseGeneratedPasswordPromptSpecification.description)
}
inline std::string* UseGeneratedPasswordPromptSpecification::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.password_change.UseGeneratedPasswordPromptSpecification.description)
  return _s;
}
inline const std::string& UseGeneratedPasswordPromptSpecification::_internal_description() const {
  return description_.Get();
}
inline void UseGeneratedPasswordPromptSpecification::_internal_set_description(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  description_.Set(value, GetArenaForAllocation());
}
inline std::string* UseGeneratedPasswordPromptSpecification::_internal_mutable_description() {
  _has_bits_[0] |= 0x00000002u;
  return description_.Mutable(GetArenaForAllocation());
}
inline std::string* UseGeneratedPasswordPromptSpecification::release_description() {
  // @@protoc_insertion_point(field_release:autofill_assistant.password_change.UseGeneratedPasswordPromptSpecification.description)
  if (!_internal_has_description()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = description_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (description_.IsDefault()) {
    description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void UseGeneratedPasswordPromptSpecification::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (description_.IsDefault()) {
    description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.password_change.UseGeneratedPasswordPromptSpecification.description)
}

// optional .autofill_assistant.password_change.Choice manual_password_choice = 4;
inline bool UseGeneratedPasswordPromptSpecification::_internal_has_manual_password_choice() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || manual_password_choice_ != nullptr);
  return value;
}
inline bool UseGeneratedPasswordPromptSpecification::has_manual_password_choice() const {
  return _internal_has_manual_password_choice();
}
inline void UseGeneratedPasswordPromptSpecification::clear_manual_password_choice() {
  if (manual_password_choice_ != nullptr) manual_password_choice_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::autofill_assistant::password_change::Choice& UseGeneratedPasswordPromptSpecification::_internal_manual_password_choice() const {
  const ::autofill_assistant::password_change::Choice* p = manual_password_choice_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::password_change::Choice&>(
      ::autofill_assistant::password_change::_Choice_default_instance_);
}
inline const ::autofill_assistant::password_change::Choice& UseGeneratedPasswordPromptSpecification::manual_password_choice() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.password_change.UseGeneratedPasswordPromptSpecification.manual_password_choice)
  return _internal_manual_password_choice();
}
inline void UseGeneratedPasswordPromptSpecification::unsafe_arena_set_allocated_manual_password_choice(
    ::autofill_assistant::password_change::Choice* manual_password_choice) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(manual_password_choice_);
  }
  manual_password_choice_ = manual_password_choice;
  if (manual_password_choice) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.password_change.UseGeneratedPasswordPromptSpecification.manual_password_choice)
}
inline ::autofill_assistant::password_change::Choice* UseGeneratedPasswordPromptSpecification::release_manual_password_choice() {
  _has_bits_[0] &= ~0x00000004u;
  ::autofill_assistant::password_change::Choice* temp = manual_password_choice_;
  manual_password_choice_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::password_change::Choice* UseGeneratedPasswordPromptSpecification::unsafe_arena_release_manual_password_choice() {
  // @@protoc_insertion_point(field_release:autofill_assistant.password_change.UseGeneratedPasswordPromptSpecification.manual_password_choice)
  _has_bits_[0] &= ~0x00000004u;
  ::autofill_assistant::password_change::Choice* temp = manual_password_choice_;
  manual_password_choice_ = nullptr;
  return temp;
}
inline ::autofill_assistant::password_change::Choice* UseGeneratedPasswordPromptSpecification::_internal_mutable_manual_password_choice() {
  _has_bits_[0] |= 0x00000004u;
  if (manual_password_choice_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::password_change::Choice>(GetArenaForAllocation());
    manual_password_choice_ = p;
  }
  return manual_password_choice_;
}
inline ::autofill_assistant::password_change::Choice* UseGeneratedPasswordPromptSpecification::mutable_manual_password_choice() {
  ::autofill_assistant::password_change::Choice* _msg = _internal_mutable_manual_password_choice();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.password_change.UseGeneratedPasswordPromptSpecification.manual_password_choice)
  return _msg;
}
inline void UseGeneratedPasswordPromptSpecification::set_allocated_manual_password_choice(::autofill_assistant::password_change::Choice* manual_password_choice) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete manual_password_choice_;
  }
  if (manual_password_choice) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(manual_password_choice);
    if (message_arena != submessage_arena) {
      manual_password_choice = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, manual_password_choice, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  manual_password_choice_ = manual_password_choice;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.password_change.UseGeneratedPasswordPromptSpecification.manual_password_choice)
}

// optional .autofill_assistant.password_change.Choice generated_password_choice = 5;
inline bool UseGeneratedPasswordPromptSpecification::_internal_has_generated_password_choice() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || generated_password_choice_ != nullptr);
  return value;
}
inline bool UseGeneratedPasswordPromptSpecification::has_generated_password_choice() const {
  return _internal_has_generated_password_choice();
}
inline void UseGeneratedPasswordPromptSpecification::clear_generated_password_choice() {
  if (generated_password_choice_ != nullptr) generated_password_choice_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::autofill_assistant::password_change::Choice& UseGeneratedPasswordPromptSpecification::_internal_generated_password_choice() const {
  const ::autofill_assistant::password_change::Choice* p = generated_password_choice_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::password_change::Choice&>(
      ::autofill_assistant::password_change::_Choice_default_instance_);
}
inline const ::autofill_assistant::password_change::Choice& UseGeneratedPasswordPromptSpecification::generated_password_choice() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.password_change.UseGeneratedPasswordPromptSpecification.generated_password_choice)
  return _internal_generated_password_choice();
}
inline void UseGeneratedPasswordPromptSpecification::unsafe_arena_set_allocated_generated_password_choice(
    ::autofill_assistant::password_change::Choice* generated_password_choice) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(generated_password_choice_);
  }
  generated_password_choice_ = generated_password_choice;
  if (generated_password_choice) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.password_change.UseGeneratedPasswordPromptSpecification.generated_password_choice)
}
inline ::autofill_assistant::password_change::Choice* UseGeneratedPasswordPromptSpecification::release_generated_password_choice() {
  _has_bits_[0] &= ~0x00000008u;
  ::autofill_assistant::password_change::Choice* temp = generated_password_choice_;
  generated_password_choice_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::password_change::Choice* UseGeneratedPasswordPromptSpecification::unsafe_arena_release_generated_password_choice() {
  // @@protoc_insertion_point(field_release:autofill_assistant.password_change.UseGeneratedPasswordPromptSpecification.generated_password_choice)
  _has_bits_[0] &= ~0x00000008u;
  ::autofill_assistant::password_change::Choice* temp = generated_password_choice_;
  generated_password_choice_ = nullptr;
  return temp;
}
inline ::autofill_assistant::password_change::Choice* UseGeneratedPasswordPromptSpecification::_internal_mutable_generated_password_choice() {
  _has_bits_[0] |= 0x00000008u;
  if (generated_password_choice_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::password_change::Choice>(GetArenaForAllocation());
    generated_password_choice_ = p;
  }
  return generated_password_choice_;
}
inline ::autofill_assistant::password_change::Choice* UseGeneratedPasswordPromptSpecification::mutable_generated_password_choice() {
  ::autofill_assistant::password_change::Choice* _msg = _internal_mutable_generated_password_choice();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.password_change.UseGeneratedPasswordPromptSpecification.generated_password_choice)
  return _msg;
}
inline void UseGeneratedPasswordPromptSpecification::set_allocated_generated_password_choice(::autofill_assistant::password_change::Choice* generated_password_choice) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete generated_password_choice_;
  }
  if (generated_password_choice) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(generated_password_choice);
    if (message_arena != submessage_arena) {
      generated_password_choice = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, generated_password_choice, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  generated_password_choice_ = generated_password_choice;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.password_change.UseGeneratedPasswordPromptSpecification.generated_password_choice)
}

// -------------------------------------------------------------------

// UpdateSidePanelSpecification

// optional .autofill_assistant.password_change.TopIcon top_icon = 1;
inline bool UpdateSidePanelSpecification::_internal_has_top_icon() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool UpdateSidePanelSpecification::has_top_icon() const {
  return _internal_has_top_icon();
}
inline void UpdateSidePanelSpecification::clear_top_icon() {
  top_icon_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::autofill_assistant::password_change::TopIcon UpdateSidePanelSpecification::_internal_top_icon() const {
  return static_cast< ::autofill_assistant::password_change::TopIcon >(top_icon_);
}
inline ::autofill_assistant::password_change::TopIcon UpdateSidePanelSpecification::top_icon() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.password_change.UpdateSidePanelSpecification.top_icon)
  return _internal_top_icon();
}
inline void UpdateSidePanelSpecification::_internal_set_top_icon(::autofill_assistant::password_change::TopIcon value) {
  assert(::autofill_assistant::password_change::TopIcon_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  top_icon_ = value;
}
inline void UpdateSidePanelSpecification::set_top_icon(::autofill_assistant::password_change::TopIcon value) {
  _internal_set_top_icon(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.password_change.UpdateSidePanelSpecification.top_icon)
}

// optional string title = 2;
inline bool UpdateSidePanelSpecification::_internal_has_title() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool UpdateSidePanelSpecification::has_title() const {
  return _internal_has_title();
}
inline void UpdateSidePanelSpecification::clear_title() {
  title_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& UpdateSidePanelSpecification::title() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.password_change.UpdateSidePanelSpecification.title)
  return _internal_title();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateSidePanelSpecification::set_title(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 title_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.password_change.UpdateSidePanelSpecification.title)
}
inline std::string* UpdateSidePanelSpecification::mutable_title() {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.password_change.UpdateSidePanelSpecification.title)
  return _s;
}
inline const std::string& UpdateSidePanelSpecification::_internal_title() const {
  return title_.Get();
}
inline void UpdateSidePanelSpecification::_internal_set_title(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  title_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateSidePanelSpecification::_internal_mutable_title() {
  _has_bits_[0] |= 0x00000001u;
  return title_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateSidePanelSpecification::release_title() {
  // @@protoc_insertion_point(field_release:autofill_assistant.password_change.UpdateSidePanelSpecification.title)
  if (!_internal_has_title()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = title_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (title_.IsDefault()) {
    title_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void UpdateSidePanelSpecification::set_allocated_title(std::string* title) {
  if (title != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  title_.SetAllocated(title, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (title_.IsDefault()) {
    title_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.password_change.UpdateSidePanelSpecification.title)
}

// optional string description = 3;
inline bool UpdateSidePanelSpecification::_internal_has_description() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool UpdateSidePanelSpecification::has_description() const {
  return _internal_has_description();
}
inline void UpdateSidePanelSpecification::clear_description() {
  description_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& UpdateSidePanelSpecification::description() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.password_change.UpdateSidePanelSpecification.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateSidePanelSpecification::set_description(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.password_change.UpdateSidePanelSpecification.description)
}
inline std::string* UpdateSidePanelSpecification::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.password_change.UpdateSidePanelSpecification.description)
  return _s;
}
inline const std::string& UpdateSidePanelSpecification::_internal_description() const {
  return description_.Get();
}
inline void UpdateSidePanelSpecification::_internal_set_description(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  description_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateSidePanelSpecification::_internal_mutable_description() {
  _has_bits_[0] |= 0x00000002u;
  return description_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateSidePanelSpecification::release_description() {
  // @@protoc_insertion_point(field_release:autofill_assistant.password_change.UpdateSidePanelSpecification.description)
  if (!_internal_has_description()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = description_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (description_.IsDefault()) {
    description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void UpdateSidePanelSpecification::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (description_.IsDefault()) {
    description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.password_change.UpdateSidePanelSpecification.description)
}

// optional .autofill_assistant.password_change.ProgressStep progress_step = 4;
inline bool UpdateSidePanelSpecification::_internal_has_progress_step() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool UpdateSidePanelSpecification::has_progress_step() const {
  return _internal_has_progress_step();
}
inline void UpdateSidePanelSpecification::clear_progress_step() {
  progress_step_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::autofill_assistant::password_change::ProgressStep UpdateSidePanelSpecification::_internal_progress_step() const {
  return static_cast< ::autofill_assistant::password_change::ProgressStep >(progress_step_);
}
inline ::autofill_assistant::password_change::ProgressStep UpdateSidePanelSpecification::progress_step() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.password_change.UpdateSidePanelSpecification.progress_step)
  return _internal_progress_step();
}
inline void UpdateSidePanelSpecification::_internal_set_progress_step(::autofill_assistant::password_change::ProgressStep value) {
  assert(::autofill_assistant::password_change::ProgressStep_IsValid(value));
  _has_bits_[0] |= 0x00000008u;
  progress_step_ = value;
}
inline void UpdateSidePanelSpecification::set_progress_step(::autofill_assistant::password_change::ProgressStep value) {
  _internal_set_progress_step(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.password_change.UpdateSidePanelSpecification.progress_step)
}

// -------------------------------------------------------------------

// GenericPasswordChangeSpecification

// .autofill_assistant.password_change.BasePromptSpecification base_prompt = 1;
inline bool GenericPasswordChangeSpecification::_internal_has_base_prompt() const {
  return specification_case() == kBasePrompt;
}
inline bool GenericPasswordChangeSpecification::has_base_prompt() const {
  return _internal_has_base_prompt();
}
inline void GenericPasswordChangeSpecification::set_has_base_prompt() {
  _oneof_case_[0] = kBasePrompt;
}
inline void GenericPasswordChangeSpecification::clear_base_prompt() {
  if (_internal_has_base_prompt()) {
    if (GetArenaForAllocation() == nullptr) {
      delete specification_.base_prompt_;
    }
    clear_has_specification();
  }
}
inline ::autofill_assistant::password_change::BasePromptSpecification* GenericPasswordChangeSpecification::release_base_prompt() {
  // @@protoc_insertion_point(field_release:autofill_assistant.password_change.GenericPasswordChangeSpecification.base_prompt)
  if (_internal_has_base_prompt()) {
    clear_has_specification();
    ::autofill_assistant::password_change::BasePromptSpecification* temp = specification_.base_prompt_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    specification_.base_prompt_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::password_change::BasePromptSpecification& GenericPasswordChangeSpecification::_internal_base_prompt() const {
  return _internal_has_base_prompt()
      ? *specification_.base_prompt_
      : reinterpret_cast< ::autofill_assistant::password_change::BasePromptSpecification&>(::autofill_assistant::password_change::_BasePromptSpecification_default_instance_);
}
inline const ::autofill_assistant::password_change::BasePromptSpecification& GenericPasswordChangeSpecification::base_prompt() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.password_change.GenericPasswordChangeSpecification.base_prompt)
  return _internal_base_prompt();
}
inline ::autofill_assistant::password_change::BasePromptSpecification* GenericPasswordChangeSpecification::unsafe_arena_release_base_prompt() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.password_change.GenericPasswordChangeSpecification.base_prompt)
  if (_internal_has_base_prompt()) {
    clear_has_specification();
    ::autofill_assistant::password_change::BasePromptSpecification* temp = specification_.base_prompt_;
    specification_.base_prompt_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void GenericPasswordChangeSpecification::unsafe_arena_set_allocated_base_prompt(::autofill_assistant::password_change::BasePromptSpecification* base_prompt) {
  clear_specification();
  if (base_prompt) {
    set_has_base_prompt();
    specification_.base_prompt_ = base_prompt;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.password_change.GenericPasswordChangeSpecification.base_prompt)
}
inline ::autofill_assistant::password_change::BasePromptSpecification* GenericPasswordChangeSpecification::_internal_mutable_base_prompt() {
  if (!_internal_has_base_prompt()) {
    clear_specification();
    set_has_base_prompt();
    specification_.base_prompt_ = CreateMaybeMessage< ::autofill_assistant::password_change::BasePromptSpecification >(GetArenaForAllocation());
  }
  return specification_.base_prompt_;
}
inline ::autofill_assistant::password_change::BasePromptSpecification* GenericPasswordChangeSpecification::mutable_base_prompt() {
  ::autofill_assistant::password_change::BasePromptSpecification* _msg = _internal_mutable_base_prompt();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.password_change.GenericPasswordChangeSpecification.base_prompt)
  return _msg;
}

// .autofill_assistant.password_change.UseGeneratedPasswordPromptSpecification use_generated_password_prompt = 2;
inline bool GenericPasswordChangeSpecification::_internal_has_use_generated_password_prompt() const {
  return specification_case() == kUseGeneratedPasswordPrompt;
}
inline bool GenericPasswordChangeSpecification::has_use_generated_password_prompt() const {
  return _internal_has_use_generated_password_prompt();
}
inline void GenericPasswordChangeSpecification::set_has_use_generated_password_prompt() {
  _oneof_case_[0] = kUseGeneratedPasswordPrompt;
}
inline void GenericPasswordChangeSpecification::clear_use_generated_password_prompt() {
  if (_internal_has_use_generated_password_prompt()) {
    if (GetArenaForAllocation() == nullptr) {
      delete specification_.use_generated_password_prompt_;
    }
    clear_has_specification();
  }
}
inline ::autofill_assistant::password_change::UseGeneratedPasswordPromptSpecification* GenericPasswordChangeSpecification::release_use_generated_password_prompt() {
  // @@protoc_insertion_point(field_release:autofill_assistant.password_change.GenericPasswordChangeSpecification.use_generated_password_prompt)
  if (_internal_has_use_generated_password_prompt()) {
    clear_has_specification();
    ::autofill_assistant::password_change::UseGeneratedPasswordPromptSpecification* temp = specification_.use_generated_password_prompt_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    specification_.use_generated_password_prompt_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::password_change::UseGeneratedPasswordPromptSpecification& GenericPasswordChangeSpecification::_internal_use_generated_password_prompt() const {
  return _internal_has_use_generated_password_prompt()
      ? *specification_.use_generated_password_prompt_
      : reinterpret_cast< ::autofill_assistant::password_change::UseGeneratedPasswordPromptSpecification&>(::autofill_assistant::password_change::_UseGeneratedPasswordPromptSpecification_default_instance_);
}
inline const ::autofill_assistant::password_change::UseGeneratedPasswordPromptSpecification& GenericPasswordChangeSpecification::use_generated_password_prompt() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.password_change.GenericPasswordChangeSpecification.use_generated_password_prompt)
  return _internal_use_generated_password_prompt();
}
inline ::autofill_assistant::password_change::UseGeneratedPasswordPromptSpecification* GenericPasswordChangeSpecification::unsafe_arena_release_use_generated_password_prompt() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.password_change.GenericPasswordChangeSpecification.use_generated_password_prompt)
  if (_internal_has_use_generated_password_prompt()) {
    clear_has_specification();
    ::autofill_assistant::password_change::UseGeneratedPasswordPromptSpecification* temp = specification_.use_generated_password_prompt_;
    specification_.use_generated_password_prompt_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void GenericPasswordChangeSpecification::unsafe_arena_set_allocated_use_generated_password_prompt(::autofill_assistant::password_change::UseGeneratedPasswordPromptSpecification* use_generated_password_prompt) {
  clear_specification();
  if (use_generated_password_prompt) {
    set_has_use_generated_password_prompt();
    specification_.use_generated_password_prompt_ = use_generated_password_prompt;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.password_change.GenericPasswordChangeSpecification.use_generated_password_prompt)
}
inline ::autofill_assistant::password_change::UseGeneratedPasswordPromptSpecification* GenericPasswordChangeSpecification::_internal_mutable_use_generated_password_prompt() {
  if (!_internal_has_use_generated_password_prompt()) {
    clear_specification();
    set_has_use_generated_password_prompt();
    specification_.use_generated_password_prompt_ = CreateMaybeMessage< ::autofill_assistant::password_change::UseGeneratedPasswordPromptSpecification >(GetArenaForAllocation());
  }
  return specification_.use_generated_password_prompt_;
}
inline ::autofill_assistant::password_change::UseGeneratedPasswordPromptSpecification* GenericPasswordChangeSpecification::mutable_use_generated_password_prompt() {
  ::autofill_assistant::password_change::UseGeneratedPasswordPromptSpecification* _msg = _internal_mutable_use_generated_password_prompt();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.password_change.GenericPasswordChangeSpecification.use_generated_password_prompt)
  return _msg;
}

// .autofill_assistant.password_change.UpdateSidePanelSpecification update_side_panel = 3;
inline bool GenericPasswordChangeSpecification::_internal_has_update_side_panel() const {
  return specification_case() == kUpdateSidePanel;
}
inline bool GenericPasswordChangeSpecification::has_update_side_panel() const {
  return _internal_has_update_side_panel();
}
inline void GenericPasswordChangeSpecification::set_has_update_side_panel() {
  _oneof_case_[0] = kUpdateSidePanel;
}
inline void GenericPasswordChangeSpecification::clear_update_side_panel() {
  if (_internal_has_update_side_panel()) {
    if (GetArenaForAllocation() == nullptr) {
      delete specification_.update_side_panel_;
    }
    clear_has_specification();
  }
}
inline ::autofill_assistant::password_change::UpdateSidePanelSpecification* GenericPasswordChangeSpecification::release_update_side_panel() {
  // @@protoc_insertion_point(field_release:autofill_assistant.password_change.GenericPasswordChangeSpecification.update_side_panel)
  if (_internal_has_update_side_panel()) {
    clear_has_specification();
    ::autofill_assistant::password_change::UpdateSidePanelSpecification* temp = specification_.update_side_panel_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    specification_.update_side_panel_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::password_change::UpdateSidePanelSpecification& GenericPasswordChangeSpecification::_internal_update_side_panel() const {
  return _internal_has_update_side_panel()
      ? *specification_.update_side_panel_
      : reinterpret_cast< ::autofill_assistant::password_change::UpdateSidePanelSpecification&>(::autofill_assistant::password_change::_UpdateSidePanelSpecification_default_instance_);
}
inline const ::autofill_assistant::password_change::UpdateSidePanelSpecification& GenericPasswordChangeSpecification::update_side_panel() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.password_change.GenericPasswordChangeSpecification.update_side_panel)
  return _internal_update_side_panel();
}
inline ::autofill_assistant::password_change::UpdateSidePanelSpecification* GenericPasswordChangeSpecification::unsafe_arena_release_update_side_panel() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.password_change.GenericPasswordChangeSpecification.update_side_panel)
  if (_internal_has_update_side_panel()) {
    clear_has_specification();
    ::autofill_assistant::password_change::UpdateSidePanelSpecification* temp = specification_.update_side_panel_;
    specification_.update_side_panel_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void GenericPasswordChangeSpecification::unsafe_arena_set_allocated_update_side_panel(::autofill_assistant::password_change::UpdateSidePanelSpecification* update_side_panel) {
  clear_specification();
  if (update_side_panel) {
    set_has_update_side_panel();
    specification_.update_side_panel_ = update_side_panel;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.password_change.GenericPasswordChangeSpecification.update_side_panel)
}
inline ::autofill_assistant::password_change::UpdateSidePanelSpecification* GenericPasswordChangeSpecification::_internal_mutable_update_side_panel() {
  if (!_internal_has_update_side_panel()) {
    clear_specification();
    set_has_update_side_panel();
    specification_.update_side_panel_ = CreateMaybeMessage< ::autofill_assistant::password_change::UpdateSidePanelSpecification >(GetArenaForAllocation());
  }
  return specification_.update_side_panel_;
}
inline ::autofill_assistant::password_change::UpdateSidePanelSpecification* GenericPasswordChangeSpecification::mutable_update_side_panel() {
  ::autofill_assistant::password_change::UpdateSidePanelSpecification* _msg = _internal_mutable_update_side_panel();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.password_change.GenericPasswordChangeSpecification.update_side_panel)
  return _msg;
}

inline bool GenericPasswordChangeSpecification::has_specification() const {
  return specification_case() != SPECIFICATION_NOT_SET;
}
inline void GenericPasswordChangeSpecification::clear_has_specification() {
  _oneof_case_[0] = SPECIFICATION_NOT_SET;
}
inline GenericPasswordChangeSpecification::SpecificationCase GenericPasswordChangeSpecification::specification_case() const {
  return GenericPasswordChangeSpecification::SpecificationCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// GenericPasswordChangeSpecificationResult

// .autofill_assistant.password_change.BasePromptSpecification.Result base_prompt_result = 1;
inline bool GenericPasswordChangeSpecificationResult::_internal_has_base_prompt_result() const {
  return result_case() == kBasePromptResult;
}
inline bool GenericPasswordChangeSpecificationResult::has_base_prompt_result() const {
  return _internal_has_base_prompt_result();
}
inline void GenericPasswordChangeSpecificationResult::set_has_base_prompt_result() {
  _oneof_case_[0] = kBasePromptResult;
}
inline void GenericPasswordChangeSpecificationResult::clear_base_prompt_result() {
  if (_internal_has_base_prompt_result()) {
    if (GetArenaForAllocation() == nullptr) {
      delete result_.base_prompt_result_;
    }
    clear_has_result();
  }
}
inline ::autofill_assistant::password_change::BasePromptSpecification_Result* GenericPasswordChangeSpecificationResult::release_base_prompt_result() {
  // @@protoc_insertion_point(field_release:autofill_assistant.password_change.GenericPasswordChangeSpecificationResult.base_prompt_result)
  if (_internal_has_base_prompt_result()) {
    clear_has_result();
    ::autofill_assistant::password_change::BasePromptSpecification_Result* temp = result_.base_prompt_result_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    result_.base_prompt_result_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::password_change::BasePromptSpecification_Result& GenericPasswordChangeSpecificationResult::_internal_base_prompt_result() const {
  return _internal_has_base_prompt_result()
      ? *result_.base_prompt_result_
      : reinterpret_cast< ::autofill_assistant::password_change::BasePromptSpecification_Result&>(::autofill_assistant::password_change::_BasePromptSpecification_Result_default_instance_);
}
inline const ::autofill_assistant::password_change::BasePromptSpecification_Result& GenericPasswordChangeSpecificationResult::base_prompt_result() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.password_change.GenericPasswordChangeSpecificationResult.base_prompt_result)
  return _internal_base_prompt_result();
}
inline ::autofill_assistant::password_change::BasePromptSpecification_Result* GenericPasswordChangeSpecificationResult::unsafe_arena_release_base_prompt_result() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.password_change.GenericPasswordChangeSpecificationResult.base_prompt_result)
  if (_internal_has_base_prompt_result()) {
    clear_has_result();
    ::autofill_assistant::password_change::BasePromptSpecification_Result* temp = result_.base_prompt_result_;
    result_.base_prompt_result_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void GenericPasswordChangeSpecificationResult::unsafe_arena_set_allocated_base_prompt_result(::autofill_assistant::password_change::BasePromptSpecification_Result* base_prompt_result) {
  clear_result();
  if (base_prompt_result) {
    set_has_base_prompt_result();
    result_.base_prompt_result_ = base_prompt_result;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.password_change.GenericPasswordChangeSpecificationResult.base_prompt_result)
}
inline ::autofill_assistant::password_change::BasePromptSpecification_Result* GenericPasswordChangeSpecificationResult::_internal_mutable_base_prompt_result() {
  if (!_internal_has_base_prompt_result()) {
    clear_result();
    set_has_base_prompt_result();
    result_.base_prompt_result_ = CreateMaybeMessage< ::autofill_assistant::password_change::BasePromptSpecification_Result >(GetArenaForAllocation());
  }
  return result_.base_prompt_result_;
}
inline ::autofill_assistant::password_change::BasePromptSpecification_Result* GenericPasswordChangeSpecificationResult::mutable_base_prompt_result() {
  ::autofill_assistant::password_change::BasePromptSpecification_Result* _msg = _internal_mutable_base_prompt_result();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.password_change.GenericPasswordChangeSpecificationResult.base_prompt_result)
  return _msg;
}

// .autofill_assistant.password_change.UseGeneratedPasswordPromptSpecification.Result use_generated_password_prompt_result = 2;
inline bool GenericPasswordChangeSpecificationResult::_internal_has_use_generated_password_prompt_result() const {
  return result_case() == kUseGeneratedPasswordPromptResult;
}
inline bool GenericPasswordChangeSpecificationResult::has_use_generated_password_prompt_result() const {
  return _internal_has_use_generated_password_prompt_result();
}
inline void GenericPasswordChangeSpecificationResult::set_has_use_generated_password_prompt_result() {
  _oneof_case_[0] = kUseGeneratedPasswordPromptResult;
}
inline void GenericPasswordChangeSpecificationResult::clear_use_generated_password_prompt_result() {
  if (_internal_has_use_generated_password_prompt_result()) {
    if (GetArenaForAllocation() == nullptr) {
      delete result_.use_generated_password_prompt_result_;
    }
    clear_has_result();
  }
}
inline ::autofill_assistant::password_change::UseGeneratedPasswordPromptSpecification_Result* GenericPasswordChangeSpecificationResult::release_use_generated_password_prompt_result() {
  // @@protoc_insertion_point(field_release:autofill_assistant.password_change.GenericPasswordChangeSpecificationResult.use_generated_password_prompt_result)
  if (_internal_has_use_generated_password_prompt_result()) {
    clear_has_result();
    ::autofill_assistant::password_change::UseGeneratedPasswordPromptSpecification_Result* temp = result_.use_generated_password_prompt_result_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    result_.use_generated_password_prompt_result_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::password_change::UseGeneratedPasswordPromptSpecification_Result& GenericPasswordChangeSpecificationResult::_internal_use_generated_password_prompt_result() const {
  return _internal_has_use_generated_password_prompt_result()
      ? *result_.use_generated_password_prompt_result_
      : reinterpret_cast< ::autofill_assistant::password_change::UseGeneratedPasswordPromptSpecification_Result&>(::autofill_assistant::password_change::_UseGeneratedPasswordPromptSpecification_Result_default_instance_);
}
inline const ::autofill_assistant::password_change::UseGeneratedPasswordPromptSpecification_Result& GenericPasswordChangeSpecificationResult::use_generated_password_prompt_result() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.password_change.GenericPasswordChangeSpecificationResult.use_generated_password_prompt_result)
  return _internal_use_generated_password_prompt_result();
}
inline ::autofill_assistant::password_change::UseGeneratedPasswordPromptSpecification_Result* GenericPasswordChangeSpecificationResult::unsafe_arena_release_use_generated_password_prompt_result() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.password_change.GenericPasswordChangeSpecificationResult.use_generated_password_prompt_result)
  if (_internal_has_use_generated_password_prompt_result()) {
    clear_has_result();
    ::autofill_assistant::password_change::UseGeneratedPasswordPromptSpecification_Result* temp = result_.use_generated_password_prompt_result_;
    result_.use_generated_password_prompt_result_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void GenericPasswordChangeSpecificationResult::unsafe_arena_set_allocated_use_generated_password_prompt_result(::autofill_assistant::password_change::UseGeneratedPasswordPromptSpecification_Result* use_generated_password_prompt_result) {
  clear_result();
  if (use_generated_password_prompt_result) {
    set_has_use_generated_password_prompt_result();
    result_.use_generated_password_prompt_result_ = use_generated_password_prompt_result;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.password_change.GenericPasswordChangeSpecificationResult.use_generated_password_prompt_result)
}
inline ::autofill_assistant::password_change::UseGeneratedPasswordPromptSpecification_Result* GenericPasswordChangeSpecificationResult::_internal_mutable_use_generated_password_prompt_result() {
  if (!_internal_has_use_generated_password_prompt_result()) {
    clear_result();
    set_has_use_generated_password_prompt_result();
    result_.use_generated_password_prompt_result_ = CreateMaybeMessage< ::autofill_assistant::password_change::UseGeneratedPasswordPromptSpecification_Result >(GetArenaForAllocation());
  }
  return result_.use_generated_password_prompt_result_;
}
inline ::autofill_assistant::password_change::UseGeneratedPasswordPromptSpecification_Result* GenericPasswordChangeSpecificationResult::mutable_use_generated_password_prompt_result() {
  ::autofill_assistant::password_change::UseGeneratedPasswordPromptSpecification_Result* _msg = _internal_mutable_use_generated_password_prompt_result();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.password_change.GenericPasswordChangeSpecificationResult.use_generated_password_prompt_result)
  return _msg;
}

inline bool GenericPasswordChangeSpecificationResult::has_result() const {
  return result_case() != RESULT_NOT_SET;
}
inline void GenericPasswordChangeSpecificationResult::clear_has_result() {
  _oneof_case_[0] = RESULT_NOT_SET;
}
inline GenericPasswordChangeSpecificationResult::ResultCase GenericPasswordChangeSpecificationResult::result_case() const {
  return GenericPasswordChangeSpecificationResult::ResultCase(_oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace password_change
}  // namespace autofill_assistant

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::autofill_assistant::password_change::TopIcon> : ::std::true_type {};
template <> struct is_proto_enum< ::autofill_assistant::password_change::ProgressStep> : ::std::true_type {};

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_components_2fautofill_5fassistant_2fbrowser_2fpublic_2fpassword_5fchange_2fproto_2factions_2eproto
