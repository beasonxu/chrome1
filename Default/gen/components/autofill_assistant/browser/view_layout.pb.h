// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: components/autofill_assistant/browser/view_layout.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_components_2fautofill_5fassistant_2fbrowser_2fview_5flayout_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_components_2fautofill_5fassistant_2fbrowser_2fview_5flayout_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3020000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3020000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry_lite.h>
#include <google/protobuf/map_field_lite.h>
#include <google/protobuf/generated_enum_util.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_components_2fautofill_5fassistant_2fbrowser_2fview_5flayout_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_components_2fautofill_5fassistant_2fbrowser_2fview_5flayout_2eproto {
  static const uint32_t offsets[];
};
namespace autofill_assistant {
class BitmapDrawableProto;
struct BitmapDrawableProtoDefaultTypeInternal;
extern BitmapDrawableProtoDefaultTypeInternal _BitmapDrawableProto_default_instance_;
class ClientDimensionProto;
struct ClientDimensionProtoDefaultTypeInternal;
extern ClientDimensionProtoDefaultTypeInternal _ClientDimensionProto_default_instance_;
class ColorProto;
struct ColorProtoDefaultTypeInternal;
extern ColorProtoDefaultTypeInternal _ColorProto_default_instance_;
class ConfigBasedUrlProto;
struct ConfigBasedUrlProtoDefaultTypeInternal;
extern ConfigBasedUrlProtoDefaultTypeInternal _ConfigBasedUrlProto_default_instance_;
class ConfigBasedUrlProto_UrlEntry_DoNotUse;
struct ConfigBasedUrlProto_UrlEntry_DoNotUseDefaultTypeInternal;
extern ConfigBasedUrlProto_UrlEntry_DoNotUseDefaultTypeInternal _ConfigBasedUrlProto_UrlEntry_DoNotUse_default_instance_;
class DividerViewProto;
struct DividerViewProtoDefaultTypeInternal;
extern DividerViewProtoDefaultTypeInternal _DividerViewProto_default_instance_;
class DrawableProto;
struct DrawableProtoDefaultTypeInternal;
extern DrawableProtoDefaultTypeInternal _DrawableProto_default_instance_;
class FaviconDrawableProto;
struct FaviconDrawableProtoDefaultTypeInternal;
extern FaviconDrawableProtoDefaultTypeInternal _FaviconDrawableProto_default_instance_;
class ImageViewProto;
struct ImageViewProtoDefaultTypeInternal;
extern ImageViewProtoDefaultTypeInternal _ImageViewProto_default_instance_;
class InfoPopupProto;
struct InfoPopupProtoDefaultTypeInternal;
extern InfoPopupProtoDefaultTypeInternal _InfoPopupProto_default_instance_;
class InfoPopupProto_DialogButton;
struct InfoPopupProto_DialogButtonDefaultTypeInternal;
extern InfoPopupProto_DialogButtonDefaultTypeInternal _InfoPopupProto_DialogButton_default_instance_;
class InfoPopupProto_DialogButton_CloseDialog;
struct InfoPopupProto_DialogButton_CloseDialogDefaultTypeInternal;
extern InfoPopupProto_DialogButton_CloseDialogDefaultTypeInternal _InfoPopupProto_DialogButton_CloseDialog_default_instance_;
class InfoPopupProto_DialogButton_OpenUrlInCCT;
struct InfoPopupProto_DialogButton_OpenUrlInCCTDefaultTypeInternal;
extern InfoPopupProto_DialogButton_OpenUrlInCCTDefaultTypeInternal _InfoPopupProto_DialogButton_OpenUrlInCCT_default_instance_;
class LinearLayoutProto;
struct LinearLayoutProtoDefaultTypeInternal;
extern LinearLayoutProtoDefaultTypeInternal _LinearLayoutProto_default_instance_;
class ShapeDrawableProto;
struct ShapeDrawableProtoDefaultTypeInternal;
extern ShapeDrawableProtoDefaultTypeInternal _ShapeDrawableProto_default_instance_;
class ShapeDrawableProto_Rectangle;
struct ShapeDrawableProto_RectangleDefaultTypeInternal;
extern ShapeDrawableProto_RectangleDefaultTypeInternal _ShapeDrawableProto_Rectangle_default_instance_;
class TextInputViewProto;
struct TextInputViewProtoDefaultTypeInternal;
extern TextInputViewProtoDefaultTypeInternal _TextInputViewProto_default_instance_;
class TextViewProto;
struct TextViewProtoDefaultTypeInternal;
extern TextViewProtoDefaultTypeInternal _TextViewProto_default_instance_;
class ToggleButtonViewProto;
struct ToggleButtonViewProtoDefaultTypeInternal;
extern ToggleButtonViewProtoDefaultTypeInternal _ToggleButtonViewProto_default_instance_;
class ToggleButtonViewProto_CheckBox;
struct ToggleButtonViewProto_CheckBoxDefaultTypeInternal;
extern ToggleButtonViewProto_CheckBoxDefaultTypeInternal _ToggleButtonViewProto_CheckBox_default_instance_;
class ToggleButtonViewProto_RadioButton;
struct ToggleButtonViewProto_RadioButtonDefaultTypeInternal;
extern ToggleButtonViewProto_RadioButtonDefaultTypeInternal _ToggleButtonViewProto_RadioButton_default_instance_;
class VerticalExpanderAccordionProto;
struct VerticalExpanderAccordionProtoDefaultTypeInternal;
extern VerticalExpanderAccordionProtoDefaultTypeInternal _VerticalExpanderAccordionProto_default_instance_;
class VerticalExpanderViewProto;
struct VerticalExpanderViewProtoDefaultTypeInternal;
extern VerticalExpanderViewProtoDefaultTypeInternal _VerticalExpanderViewProto_default_instance_;
class ViewAttributesProto;
struct ViewAttributesProtoDefaultTypeInternal;
extern ViewAttributesProtoDefaultTypeInternal _ViewAttributesProto_default_instance_;
class ViewContainerProto;
struct ViewContainerProtoDefaultTypeInternal;
extern ViewContainerProtoDefaultTypeInternal _ViewContainerProto_default_instance_;
class ViewLayoutParamsProto;
struct ViewLayoutParamsProtoDefaultTypeInternal;
extern ViewLayoutParamsProtoDefaultTypeInternal _ViewLayoutParamsProto_default_instance_;
class ViewProto;
struct ViewProtoDefaultTypeInternal;
extern ViewProtoDefaultTypeInternal _ViewProto_default_instance_;
}  // namespace autofill_assistant
PROTOBUF_NAMESPACE_OPEN
template<> ::autofill_assistant::BitmapDrawableProto* Arena::CreateMaybeMessage<::autofill_assistant::BitmapDrawableProto>(Arena*);
template<> ::autofill_assistant::ClientDimensionProto* Arena::CreateMaybeMessage<::autofill_assistant::ClientDimensionProto>(Arena*);
template<> ::autofill_assistant::ColorProto* Arena::CreateMaybeMessage<::autofill_assistant::ColorProto>(Arena*);
template<> ::autofill_assistant::ConfigBasedUrlProto* Arena::CreateMaybeMessage<::autofill_assistant::ConfigBasedUrlProto>(Arena*);
template<> ::autofill_assistant::ConfigBasedUrlProto_UrlEntry_DoNotUse* Arena::CreateMaybeMessage<::autofill_assistant::ConfigBasedUrlProto_UrlEntry_DoNotUse>(Arena*);
template<> ::autofill_assistant::DividerViewProto* Arena::CreateMaybeMessage<::autofill_assistant::DividerViewProto>(Arena*);
template<> ::autofill_assistant::DrawableProto* Arena::CreateMaybeMessage<::autofill_assistant::DrawableProto>(Arena*);
template<> ::autofill_assistant::FaviconDrawableProto* Arena::CreateMaybeMessage<::autofill_assistant::FaviconDrawableProto>(Arena*);
template<> ::autofill_assistant::ImageViewProto* Arena::CreateMaybeMessage<::autofill_assistant::ImageViewProto>(Arena*);
template<> ::autofill_assistant::InfoPopupProto* Arena::CreateMaybeMessage<::autofill_assistant::InfoPopupProto>(Arena*);
template<> ::autofill_assistant::InfoPopupProto_DialogButton* Arena::CreateMaybeMessage<::autofill_assistant::InfoPopupProto_DialogButton>(Arena*);
template<> ::autofill_assistant::InfoPopupProto_DialogButton_CloseDialog* Arena::CreateMaybeMessage<::autofill_assistant::InfoPopupProto_DialogButton_CloseDialog>(Arena*);
template<> ::autofill_assistant::InfoPopupProto_DialogButton_OpenUrlInCCT* Arena::CreateMaybeMessage<::autofill_assistant::InfoPopupProto_DialogButton_OpenUrlInCCT>(Arena*);
template<> ::autofill_assistant::LinearLayoutProto* Arena::CreateMaybeMessage<::autofill_assistant::LinearLayoutProto>(Arena*);
template<> ::autofill_assistant::ShapeDrawableProto* Arena::CreateMaybeMessage<::autofill_assistant::ShapeDrawableProto>(Arena*);
template<> ::autofill_assistant::ShapeDrawableProto_Rectangle* Arena::CreateMaybeMessage<::autofill_assistant::ShapeDrawableProto_Rectangle>(Arena*);
template<> ::autofill_assistant::TextInputViewProto* Arena::CreateMaybeMessage<::autofill_assistant::TextInputViewProto>(Arena*);
template<> ::autofill_assistant::TextViewProto* Arena::CreateMaybeMessage<::autofill_assistant::TextViewProto>(Arena*);
template<> ::autofill_assistant::ToggleButtonViewProto* Arena::CreateMaybeMessage<::autofill_assistant::ToggleButtonViewProto>(Arena*);
template<> ::autofill_assistant::ToggleButtonViewProto_CheckBox* Arena::CreateMaybeMessage<::autofill_assistant::ToggleButtonViewProto_CheckBox>(Arena*);
template<> ::autofill_assistant::ToggleButtonViewProto_RadioButton* Arena::CreateMaybeMessage<::autofill_assistant::ToggleButtonViewProto_RadioButton>(Arena*);
template<> ::autofill_assistant::VerticalExpanderAccordionProto* Arena::CreateMaybeMessage<::autofill_assistant::VerticalExpanderAccordionProto>(Arena*);
template<> ::autofill_assistant::VerticalExpanderViewProto* Arena::CreateMaybeMessage<::autofill_assistant::VerticalExpanderViewProto>(Arena*);
template<> ::autofill_assistant::ViewAttributesProto* Arena::CreateMaybeMessage<::autofill_assistant::ViewAttributesProto>(Arena*);
template<> ::autofill_assistant::ViewContainerProto* Arena::CreateMaybeMessage<::autofill_assistant::ViewContainerProto>(Arena*);
template<> ::autofill_assistant::ViewLayoutParamsProto* Arena::CreateMaybeMessage<::autofill_assistant::ViewLayoutParamsProto>(Arena*);
template<> ::autofill_assistant::ViewProto* Arena::CreateMaybeMessage<::autofill_assistant::ViewProto>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace autofill_assistant {

enum DrawableProto_Icon : int {
  DrawableProto_Icon_DRAWABLE_ICON_UNDEFINED = 0,
  DrawableProto_Icon_PROGRESSBAR_DEFAULT_INITIAL_STEP = 1,
  DrawableProto_Icon_PROGRESSBAR_DEFAULT_DATA_COLLECTION = 2,
  DrawableProto_Icon_PROGRESSBAR_DEFAULT_PAYMENT = 3,
  DrawableProto_Icon_PROGRESSBAR_DEFAULT_FINAL_STEP = 4,
  DrawableProto_Icon_SITTING_PERSON = 5,
  DrawableProto_Icon_TICKET_STUB = 6,
  DrawableProto_Icon_SHOPPING_BASKET = 7,
  DrawableProto_Icon_FAST_FOOD = 8,
  DrawableProto_Icon_LOCAL_DINING = 9,
  DrawableProto_Icon_COGWHEEL = 10,
  DrawableProto_Icon_KEY = 11,
  DrawableProto_Icon_CAR = 12,
  DrawableProto_Icon_GROCERY = 13,
  DrawableProto_Icon_VISIBILITY_ON = 14,
  DrawableProto_Icon_VISIBILITY_OFF = 15
};
bool DrawableProto_Icon_IsValid(int value);
constexpr DrawableProto_Icon DrawableProto_Icon_Icon_MIN = DrawableProto_Icon_DRAWABLE_ICON_UNDEFINED;
constexpr DrawableProto_Icon DrawableProto_Icon_Icon_MAX = DrawableProto_Icon_VISIBILITY_OFF;
constexpr int DrawableProto_Icon_Icon_ARRAYSIZE = DrawableProto_Icon_Icon_MAX + 1;

const std::string& DrawableProto_Icon_Name(DrawableProto_Icon value);
template<typename T>
inline const std::string& DrawableProto_Icon_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DrawableProto_Icon>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DrawableProto_Icon_Name.");
  return DrawableProto_Icon_Name(static_cast<DrawableProto_Icon>(enum_t_value));
}
bool DrawableProto_Icon_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DrawableProto_Icon* value);
enum ViewLayoutParamsProto_Gravity : int {
  ViewLayoutParamsProto_Gravity_UNDEFINED = 0,
  ViewLayoutParamsProto_Gravity_CENTER = 17,
  ViewLayoutParamsProto_Gravity_CENTER_HORIZONTAL = 1,
  ViewLayoutParamsProto_Gravity_CENTER_VERTICAL = 16,
  ViewLayoutParamsProto_Gravity_START = 8388611,
  ViewLayoutParamsProto_Gravity_TOP = 48,
  ViewLayoutParamsProto_Gravity_END = 8388613,
  ViewLayoutParamsProto_Gravity_BOTTOM = 80,
  ViewLayoutParamsProto_Gravity_FILL_HORIZONTAL = 7,
  ViewLayoutParamsProto_Gravity_FILL_VERTICAL = 112
};
bool ViewLayoutParamsProto_Gravity_IsValid(int value);
constexpr ViewLayoutParamsProto_Gravity ViewLayoutParamsProto_Gravity_Gravity_MIN = ViewLayoutParamsProto_Gravity_UNDEFINED;
constexpr ViewLayoutParamsProto_Gravity ViewLayoutParamsProto_Gravity_Gravity_MAX = ViewLayoutParamsProto_Gravity_END;
constexpr int ViewLayoutParamsProto_Gravity_Gravity_ARRAYSIZE = ViewLayoutParamsProto_Gravity_Gravity_MAX + 1;

const std::string& ViewLayoutParamsProto_Gravity_Name(ViewLayoutParamsProto_Gravity value);
template<typename T>
inline const std::string& ViewLayoutParamsProto_Gravity_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ViewLayoutParamsProto_Gravity>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ViewLayoutParamsProto_Gravity_Name.");
  return ViewLayoutParamsProto_Gravity_Name(static_cast<ViewLayoutParamsProto_Gravity>(enum_t_value));
}
bool ViewLayoutParamsProto_Gravity_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ViewLayoutParamsProto_Gravity* value);
enum ViewLayoutParamsProto_Size : int {
  ViewLayoutParamsProto_Size_WRAP_CONTENT = -2,
  ViewLayoutParamsProto_Size_MATCH_PARENT = -1
};
bool ViewLayoutParamsProto_Size_IsValid(int value);
constexpr ViewLayoutParamsProto_Size ViewLayoutParamsProto_Size_Size_MIN = ViewLayoutParamsProto_Size_WRAP_CONTENT;
constexpr ViewLayoutParamsProto_Size ViewLayoutParamsProto_Size_Size_MAX = ViewLayoutParamsProto_Size_MATCH_PARENT;
constexpr int ViewLayoutParamsProto_Size_Size_ARRAYSIZE = ViewLayoutParamsProto_Size_Size_MAX + 1;

const std::string& ViewLayoutParamsProto_Size_Name(ViewLayoutParamsProto_Size value);
template<typename T>
inline const std::string& ViewLayoutParamsProto_Size_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ViewLayoutParamsProto_Size>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ViewLayoutParamsProto_Size_Name.");
  return ViewLayoutParamsProto_Size_Name(static_cast<ViewLayoutParamsProto_Size>(enum_t_value));
}
bool ViewLayoutParamsProto_Size_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ViewLayoutParamsProto_Size* value);
enum LinearLayoutProto_Orientation : int {
  LinearLayoutProto_Orientation_HORIZONTAL = 0,
  LinearLayoutProto_Orientation_VERTICAL = 1
};
bool LinearLayoutProto_Orientation_IsValid(int value);
constexpr LinearLayoutProto_Orientation LinearLayoutProto_Orientation_Orientation_MIN = LinearLayoutProto_Orientation_HORIZONTAL;
constexpr LinearLayoutProto_Orientation LinearLayoutProto_Orientation_Orientation_MAX = LinearLayoutProto_Orientation_VERTICAL;
constexpr int LinearLayoutProto_Orientation_Orientation_ARRAYSIZE = LinearLayoutProto_Orientation_Orientation_MAX + 1;

const std::string& LinearLayoutProto_Orientation_Name(LinearLayoutProto_Orientation value);
template<typename T>
inline const std::string& LinearLayoutProto_Orientation_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LinearLayoutProto_Orientation>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LinearLayoutProto_Orientation_Name.");
  return LinearLayoutProto_Orientation_Name(static_cast<LinearLayoutProto_Orientation>(enum_t_value));
}
bool LinearLayoutProto_Orientation_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, LinearLayoutProto_Orientation* value);
enum VerticalExpanderViewProto_ChevronStyle : int {
  VerticalExpanderViewProto_ChevronStyle_NOT_SET_AUTOMATIC = 0,
  VerticalExpanderViewProto_ChevronStyle_ALWAYS = 1,
  VerticalExpanderViewProto_ChevronStyle_NEVER = 2
};
bool VerticalExpanderViewProto_ChevronStyle_IsValid(int value);
constexpr VerticalExpanderViewProto_ChevronStyle VerticalExpanderViewProto_ChevronStyle_ChevronStyle_MIN = VerticalExpanderViewProto_ChevronStyle_NOT_SET_AUTOMATIC;
constexpr VerticalExpanderViewProto_ChevronStyle VerticalExpanderViewProto_ChevronStyle_ChevronStyle_MAX = VerticalExpanderViewProto_ChevronStyle_NEVER;
constexpr int VerticalExpanderViewProto_ChevronStyle_ChevronStyle_ARRAYSIZE = VerticalExpanderViewProto_ChevronStyle_ChevronStyle_MAX + 1;

const std::string& VerticalExpanderViewProto_ChevronStyle_Name(VerticalExpanderViewProto_ChevronStyle value);
template<typename T>
inline const std::string& VerticalExpanderViewProto_ChevronStyle_Name(T enum_t_value) {
  static_assert(::std::is_same<T, VerticalExpanderViewProto_ChevronStyle>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function VerticalExpanderViewProto_ChevronStyle_Name.");
  return VerticalExpanderViewProto_ChevronStyle_Name(static_cast<VerticalExpanderViewProto_ChevronStyle>(enum_t_value));
}
bool VerticalExpanderViewProto_ChevronStyle_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, VerticalExpanderViewProto_ChevronStyle* value);
enum TextInputViewProto_InputTypeHint : int {
  TextInputViewProto_InputTypeHint_NONE = 0,
  TextInputViewProto_InputTypeHint_PHONE = 1,
  TextInputViewProto_InputTypeHint_EMAIL = 2,
  TextInputViewProto_InputTypeHint_STREET_LINES = 3,
  TextInputViewProto_InputTypeHint_PERSON_NAME = 4,
  TextInputViewProto_InputTypeHint_REGION = 5,
  TextInputViewProto_InputTypeHint_ALPHA_NUMERIC = 6,
  TextInputViewProto_InputTypeHint_CREDIT_CARD = 7,
  TextInputViewProto_InputTypeHint_NUMERIC = 8
};
bool TextInputViewProto_InputTypeHint_IsValid(int value);
constexpr TextInputViewProto_InputTypeHint TextInputViewProto_InputTypeHint_InputTypeHint_MIN = TextInputViewProto_InputTypeHint_NONE;
constexpr TextInputViewProto_InputTypeHint TextInputViewProto_InputTypeHint_InputTypeHint_MAX = TextInputViewProto_InputTypeHint_NUMERIC;
constexpr int TextInputViewProto_InputTypeHint_InputTypeHint_ARRAYSIZE = TextInputViewProto_InputTypeHint_InputTypeHint_MAX + 1;

const std::string& TextInputViewProto_InputTypeHint_Name(TextInputViewProto_InputTypeHint value);
template<typename T>
inline const std::string& TextInputViewProto_InputTypeHint_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TextInputViewProto_InputTypeHint>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TextInputViewProto_InputTypeHint_Name.");
  return TextInputViewProto_InputTypeHint_Name(static_cast<TextInputViewProto_InputTypeHint>(enum_t_value));
}
bool TextInputViewProto_InputTypeHint_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TextInputViewProto_InputTypeHint* value);
// ===================================================================

class ViewProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.ViewProto) */ {
 public:
  inline ViewProto() : ViewProto(nullptr) {}
  ~ViewProto() override;
  explicit PROTOBUF_CONSTEXPR ViewProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ViewProto(const ViewProto& from);
  ViewProto(ViewProto&& from) noexcept
    : ViewProto() {
    *this = ::std::move(from);
  }

  inline ViewProto& operator=(const ViewProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline ViewProto& operator=(ViewProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ViewProto& default_instance() {
    return *internal_default_instance();
  }
  enum ViewCase {
    kViewContainer = 4,
    kTextView = 5,
    kDividerView = 6,
    kImageView = 7,
    kTextInputView = 8,
    kVerticalExpanderView = 9,
    kToggleButtonView = 10,
    VIEW_NOT_SET = 0,
  };

  static inline const ViewProto* internal_default_instance() {
    return reinterpret_cast<const ViewProto*>(
               &_ViewProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(ViewProto& a, ViewProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(ViewProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ViewProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ViewProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ViewProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ViewProto& from);
  void MergeFrom(const ViewProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ViewProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.ViewProto";
  }
  protected:
  explicit ViewProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdentifierFieldNumber = 1,
    kAttributesFieldNumber = 2,
    kLayoutParamsFieldNumber = 3,
    kViewContainerFieldNumber = 4,
    kTextViewFieldNumber = 5,
    kDividerViewFieldNumber = 6,
    kImageViewFieldNumber = 7,
    kTextInputViewFieldNumber = 8,
    kVerticalExpanderViewFieldNumber = 9,
    kToggleButtonViewFieldNumber = 10,
  };
  // optional string identifier = 1;
  bool has_identifier() const;
  private:
  bool _internal_has_identifier() const;
  public:
  void clear_identifier();
  const std::string& identifier() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_identifier(ArgT0&& arg0, ArgT... args);
  std::string* mutable_identifier();
  PROTOBUF_NODISCARD std::string* release_identifier();
  void set_allocated_identifier(std::string* identifier);
  private:
  const std::string& _internal_identifier() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_identifier(const std::string& value);
  std::string* _internal_mutable_identifier();
  public:

  // optional .autofill_assistant.ViewAttributesProto attributes = 2;
  bool has_attributes() const;
  private:
  bool _internal_has_attributes() const;
  public:
  void clear_attributes();
  const ::autofill_assistant::ViewAttributesProto& attributes() const;
  PROTOBUF_NODISCARD ::autofill_assistant::ViewAttributesProto* release_attributes();
  ::autofill_assistant::ViewAttributesProto* mutable_attributes();
  void set_allocated_attributes(::autofill_assistant::ViewAttributesProto* attributes);
  private:
  const ::autofill_assistant::ViewAttributesProto& _internal_attributes() const;
  ::autofill_assistant::ViewAttributesProto* _internal_mutable_attributes();
  public:
  void unsafe_arena_set_allocated_attributes(
      ::autofill_assistant::ViewAttributesProto* attributes);
  ::autofill_assistant::ViewAttributesProto* unsafe_arena_release_attributes();

  // optional .autofill_assistant.ViewLayoutParamsProto layout_params = 3;
  bool has_layout_params() const;
  private:
  bool _internal_has_layout_params() const;
  public:
  void clear_layout_params();
  const ::autofill_assistant::ViewLayoutParamsProto& layout_params() const;
  PROTOBUF_NODISCARD ::autofill_assistant::ViewLayoutParamsProto* release_layout_params();
  ::autofill_assistant::ViewLayoutParamsProto* mutable_layout_params();
  void set_allocated_layout_params(::autofill_assistant::ViewLayoutParamsProto* layout_params);
  private:
  const ::autofill_assistant::ViewLayoutParamsProto& _internal_layout_params() const;
  ::autofill_assistant::ViewLayoutParamsProto* _internal_mutable_layout_params();
  public:
  void unsafe_arena_set_allocated_layout_params(
      ::autofill_assistant::ViewLayoutParamsProto* layout_params);
  ::autofill_assistant::ViewLayoutParamsProto* unsafe_arena_release_layout_params();

  // .autofill_assistant.ViewContainerProto view_container = 4;
  bool has_view_container() const;
  private:
  bool _internal_has_view_container() const;
  public:
  void clear_view_container();
  const ::autofill_assistant::ViewContainerProto& view_container() const;
  PROTOBUF_NODISCARD ::autofill_assistant::ViewContainerProto* release_view_container();
  ::autofill_assistant::ViewContainerProto* mutable_view_container();
  void set_allocated_view_container(::autofill_assistant::ViewContainerProto* view_container);
  private:
  const ::autofill_assistant::ViewContainerProto& _internal_view_container() const;
  ::autofill_assistant::ViewContainerProto* _internal_mutable_view_container();
  public:
  void unsafe_arena_set_allocated_view_container(
      ::autofill_assistant::ViewContainerProto* view_container);
  ::autofill_assistant::ViewContainerProto* unsafe_arena_release_view_container();

  // .autofill_assistant.TextViewProto text_view = 5;
  bool has_text_view() const;
  private:
  bool _internal_has_text_view() const;
  public:
  void clear_text_view();
  const ::autofill_assistant::TextViewProto& text_view() const;
  PROTOBUF_NODISCARD ::autofill_assistant::TextViewProto* release_text_view();
  ::autofill_assistant::TextViewProto* mutable_text_view();
  void set_allocated_text_view(::autofill_assistant::TextViewProto* text_view);
  private:
  const ::autofill_assistant::TextViewProto& _internal_text_view() const;
  ::autofill_assistant::TextViewProto* _internal_mutable_text_view();
  public:
  void unsafe_arena_set_allocated_text_view(
      ::autofill_assistant::TextViewProto* text_view);
  ::autofill_assistant::TextViewProto* unsafe_arena_release_text_view();

  // .autofill_assistant.DividerViewProto divider_view = 6;
  bool has_divider_view() const;
  private:
  bool _internal_has_divider_view() const;
  public:
  void clear_divider_view();
  const ::autofill_assistant::DividerViewProto& divider_view() const;
  PROTOBUF_NODISCARD ::autofill_assistant::DividerViewProto* release_divider_view();
  ::autofill_assistant::DividerViewProto* mutable_divider_view();
  void set_allocated_divider_view(::autofill_assistant::DividerViewProto* divider_view);
  private:
  const ::autofill_assistant::DividerViewProto& _internal_divider_view() const;
  ::autofill_assistant::DividerViewProto* _internal_mutable_divider_view();
  public:
  void unsafe_arena_set_allocated_divider_view(
      ::autofill_assistant::DividerViewProto* divider_view);
  ::autofill_assistant::DividerViewProto* unsafe_arena_release_divider_view();

  // .autofill_assistant.ImageViewProto image_view = 7;
  bool has_image_view() const;
  private:
  bool _internal_has_image_view() const;
  public:
  void clear_image_view();
  const ::autofill_assistant::ImageViewProto& image_view() const;
  PROTOBUF_NODISCARD ::autofill_assistant::ImageViewProto* release_image_view();
  ::autofill_assistant::ImageViewProto* mutable_image_view();
  void set_allocated_image_view(::autofill_assistant::ImageViewProto* image_view);
  private:
  const ::autofill_assistant::ImageViewProto& _internal_image_view() const;
  ::autofill_assistant::ImageViewProto* _internal_mutable_image_view();
  public:
  void unsafe_arena_set_allocated_image_view(
      ::autofill_assistant::ImageViewProto* image_view);
  ::autofill_assistant::ImageViewProto* unsafe_arena_release_image_view();

  // .autofill_assistant.TextInputViewProto text_input_view = 8;
  bool has_text_input_view() const;
  private:
  bool _internal_has_text_input_view() const;
  public:
  void clear_text_input_view();
  const ::autofill_assistant::TextInputViewProto& text_input_view() const;
  PROTOBUF_NODISCARD ::autofill_assistant::TextInputViewProto* release_text_input_view();
  ::autofill_assistant::TextInputViewProto* mutable_text_input_view();
  void set_allocated_text_input_view(::autofill_assistant::TextInputViewProto* text_input_view);
  private:
  const ::autofill_assistant::TextInputViewProto& _internal_text_input_view() const;
  ::autofill_assistant::TextInputViewProto* _internal_mutable_text_input_view();
  public:
  void unsafe_arena_set_allocated_text_input_view(
      ::autofill_assistant::TextInputViewProto* text_input_view);
  ::autofill_assistant::TextInputViewProto* unsafe_arena_release_text_input_view();

  // .autofill_assistant.VerticalExpanderViewProto vertical_expander_view = 9;
  bool has_vertical_expander_view() const;
  private:
  bool _internal_has_vertical_expander_view() const;
  public:
  void clear_vertical_expander_view();
  const ::autofill_assistant::VerticalExpanderViewProto& vertical_expander_view() const;
  PROTOBUF_NODISCARD ::autofill_assistant::VerticalExpanderViewProto* release_vertical_expander_view();
  ::autofill_assistant::VerticalExpanderViewProto* mutable_vertical_expander_view();
  void set_allocated_vertical_expander_view(::autofill_assistant::VerticalExpanderViewProto* vertical_expander_view);
  private:
  const ::autofill_assistant::VerticalExpanderViewProto& _internal_vertical_expander_view() const;
  ::autofill_assistant::VerticalExpanderViewProto* _internal_mutable_vertical_expander_view();
  public:
  void unsafe_arena_set_allocated_vertical_expander_view(
      ::autofill_assistant::VerticalExpanderViewProto* vertical_expander_view);
  ::autofill_assistant::VerticalExpanderViewProto* unsafe_arena_release_vertical_expander_view();

  // .autofill_assistant.ToggleButtonViewProto toggle_button_view = 10;
  bool has_toggle_button_view() const;
  private:
  bool _internal_has_toggle_button_view() const;
  public:
  void clear_toggle_button_view();
  const ::autofill_assistant::ToggleButtonViewProto& toggle_button_view() const;
  PROTOBUF_NODISCARD ::autofill_assistant::ToggleButtonViewProto* release_toggle_button_view();
  ::autofill_assistant::ToggleButtonViewProto* mutable_toggle_button_view();
  void set_allocated_toggle_button_view(::autofill_assistant::ToggleButtonViewProto* toggle_button_view);
  private:
  const ::autofill_assistant::ToggleButtonViewProto& _internal_toggle_button_view() const;
  ::autofill_assistant::ToggleButtonViewProto* _internal_mutable_toggle_button_view();
  public:
  void unsafe_arena_set_allocated_toggle_button_view(
      ::autofill_assistant::ToggleButtonViewProto* toggle_button_view);
  ::autofill_assistant::ToggleButtonViewProto* unsafe_arena_release_toggle_button_view();

  void clear_view();
  ViewCase view_case() const;
  // @@protoc_insertion_point(class_scope:autofill_assistant.ViewProto)
 private:
  class _Internal;
  void set_has_view_container();
  void set_has_text_view();
  void set_has_divider_view();
  void set_has_image_view();
  void set_has_text_input_view();
  void set_has_vertical_expander_view();
  void set_has_toggle_button_view();

  inline bool has_view() const;
  inline void clear_has_view();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr identifier_;
  ::autofill_assistant::ViewAttributesProto* attributes_;
  ::autofill_assistant::ViewLayoutParamsProto* layout_params_;
  union ViewUnion {
    constexpr ViewUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::autofill_assistant::ViewContainerProto* view_container_;
    ::autofill_assistant::TextViewProto* text_view_;
    ::autofill_assistant::DividerViewProto* divider_view_;
    ::autofill_assistant::ImageViewProto* image_view_;
    ::autofill_assistant::TextInputViewProto* text_input_view_;
    ::autofill_assistant::VerticalExpanderViewProto* vertical_expander_view_;
    ::autofill_assistant::ToggleButtonViewProto* toggle_button_view_;
  } view_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fview_5flayout_2eproto;
};
// -------------------------------------------------------------------

class ColorProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.ColorProto) */ {
 public:
  inline ColorProto() : ColorProto(nullptr) {}
  ~ColorProto() override;
  explicit PROTOBUF_CONSTEXPR ColorProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ColorProto(const ColorProto& from);
  ColorProto(ColorProto&& from) noexcept
    : ColorProto() {
    *this = ::std::move(from);
  }

  inline ColorProto& operator=(const ColorProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline ColorProto& operator=(ColorProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ColorProto& default_instance() {
    return *internal_default_instance();
  }
  enum ColorCase {
    kResourceIdentifier = 1,
    kParseableColor = 2,
    COLOR_NOT_SET = 0,
  };

  static inline const ColorProto* internal_default_instance() {
    return reinterpret_cast<const ColorProto*>(
               &_ColorProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ColorProto& a, ColorProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(ColorProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ColorProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ColorProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ColorProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ColorProto& from);
  void MergeFrom(const ColorProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ColorProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.ColorProto";
  }
  protected:
  explicit ColorProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResourceIdentifierFieldNumber = 1,
    kParseableColorFieldNumber = 2,
  };
  // string resource_identifier = 1;
  bool has_resource_identifier() const;
  private:
  bool _internal_has_resource_identifier() const;
  public:
  void clear_resource_identifier();
  const std::string& resource_identifier() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_resource_identifier(ArgT0&& arg0, ArgT... args);
  std::string* mutable_resource_identifier();
  PROTOBUF_NODISCARD std::string* release_resource_identifier();
  void set_allocated_resource_identifier(std::string* resource_identifier);
  private:
  const std::string& _internal_resource_identifier() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_resource_identifier(const std::string& value);
  std::string* _internal_mutable_resource_identifier();
  public:

  // string parseable_color = 2;
  bool has_parseable_color() const;
  private:
  bool _internal_has_parseable_color() const;
  public:
  void clear_parseable_color();
  const std::string& parseable_color() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_parseable_color(ArgT0&& arg0, ArgT... args);
  std::string* mutable_parseable_color();
  PROTOBUF_NODISCARD std::string* release_parseable_color();
  void set_allocated_parseable_color(std::string* parseable_color);
  private:
  const std::string& _internal_parseable_color() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_parseable_color(const std::string& value);
  std::string* _internal_mutable_parseable_color();
  public:

  void clear_color();
  ColorCase color_case() const;
  // @@protoc_insertion_point(class_scope:autofill_assistant.ColorProto)
 private:
  class _Internal;
  void set_has_resource_identifier();
  void set_has_parseable_color();

  inline bool has_color() const;
  inline void clear_has_color();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union ColorUnion {
    constexpr ColorUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr resource_identifier_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr parseable_color_;
  } color_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fview_5flayout_2eproto;
};
// -------------------------------------------------------------------

class ClientDimensionProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.ClientDimensionProto) */ {
 public:
  inline ClientDimensionProto() : ClientDimensionProto(nullptr) {}
  ~ClientDimensionProto() override;
  explicit PROTOBUF_CONSTEXPR ClientDimensionProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ClientDimensionProto(const ClientDimensionProto& from);
  ClientDimensionProto(ClientDimensionProto&& from) noexcept
    : ClientDimensionProto() {
    *this = ::std::move(from);
  }

  inline ClientDimensionProto& operator=(const ClientDimensionProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClientDimensionProto& operator=(ClientDimensionProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ClientDimensionProto& default_instance() {
    return *internal_default_instance();
  }
  enum SizeCase {
    kDp = 1,
    kWidthFactor = 2,
    kHeightFactor = 3,
    kSizeInPixel = 4,
    SIZE_NOT_SET = 0,
  };

  static inline const ClientDimensionProto* internal_default_instance() {
    return reinterpret_cast<const ClientDimensionProto*>(
               &_ClientDimensionProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ClientDimensionProto& a, ClientDimensionProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(ClientDimensionProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClientDimensionProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ClientDimensionProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ClientDimensionProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ClientDimensionProto& from);
  void MergeFrom(const ClientDimensionProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ClientDimensionProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.ClientDimensionProto";
  }
  protected:
  explicit ClientDimensionProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDpFieldNumber = 1,
    kWidthFactorFieldNumber = 2,
    kHeightFactorFieldNumber = 3,
    kSizeInPixelFieldNumber = 4,
  };
  // int32 dp = 1;
  bool has_dp() const;
  private:
  bool _internal_has_dp() const;
  public:
  void clear_dp();
  int32_t dp() const;
  void set_dp(int32_t value);
  private:
  int32_t _internal_dp() const;
  void _internal_set_dp(int32_t value);
  public:

  // float width_factor = 2;
  bool has_width_factor() const;
  private:
  bool _internal_has_width_factor() const;
  public:
  void clear_width_factor();
  float width_factor() const;
  void set_width_factor(float value);
  private:
  float _internal_width_factor() const;
  void _internal_set_width_factor(float value);
  public:

  // float height_factor = 3;
  bool has_height_factor() const;
  private:
  bool _internal_has_height_factor() const;
  public:
  void clear_height_factor();
  float height_factor() const;
  void set_height_factor(float value);
  private:
  float _internal_height_factor() const;
  void _internal_set_height_factor(float value);
  public:

  // int32 size_in_pixel = 4;
  bool has_size_in_pixel() const;
  private:
  bool _internal_has_size_in_pixel() const;
  public:
  void clear_size_in_pixel();
  int32_t size_in_pixel() const;
  void set_size_in_pixel(int32_t value);
  private:
  int32_t _internal_size_in_pixel() const;
  void _internal_set_size_in_pixel(int32_t value);
  public:

  void clear_size();
  SizeCase size_case() const;
  // @@protoc_insertion_point(class_scope:autofill_assistant.ClientDimensionProto)
 private:
  class _Internal;
  void set_has_dp();
  void set_has_width_factor();
  void set_has_height_factor();
  void set_has_size_in_pixel();

  inline bool has_size() const;
  inline void clear_has_size();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union SizeUnion {
    constexpr SizeUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    int32_t dp_;
    float width_factor_;
    float height_factor_;
    int32_t size_in_pixel_;
  } size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fview_5flayout_2eproto;
};
// -------------------------------------------------------------------

class ShapeDrawableProto_Rectangle final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.ShapeDrawableProto.Rectangle) */ {
 public:
  inline ShapeDrawableProto_Rectangle() : ShapeDrawableProto_Rectangle(nullptr) {}
  ~ShapeDrawableProto_Rectangle() override;
  explicit PROTOBUF_CONSTEXPR ShapeDrawableProto_Rectangle(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ShapeDrawableProto_Rectangle(const ShapeDrawableProto_Rectangle& from);
  ShapeDrawableProto_Rectangle(ShapeDrawableProto_Rectangle&& from) noexcept
    : ShapeDrawableProto_Rectangle() {
    *this = ::std::move(from);
  }

  inline ShapeDrawableProto_Rectangle& operator=(const ShapeDrawableProto_Rectangle& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShapeDrawableProto_Rectangle& operator=(ShapeDrawableProto_Rectangle&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ShapeDrawableProto_Rectangle& default_instance() {
    return *internal_default_instance();
  }
  static inline const ShapeDrawableProto_Rectangle* internal_default_instance() {
    return reinterpret_cast<const ShapeDrawableProto_Rectangle*>(
               &_ShapeDrawableProto_Rectangle_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ShapeDrawableProto_Rectangle& a, ShapeDrawableProto_Rectangle& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(ShapeDrawableProto_Rectangle* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShapeDrawableProto_Rectangle* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ShapeDrawableProto_Rectangle* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ShapeDrawableProto_Rectangle>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ShapeDrawableProto_Rectangle& from);
  void MergeFrom(const ShapeDrawableProto_Rectangle& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ShapeDrawableProto_Rectangle* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.ShapeDrawableProto.Rectangle";
  }
  protected:
  explicit ShapeDrawableProto_Rectangle(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCornerRadiusFieldNumber = 1,
  };
  // optional .autofill_assistant.ClientDimensionProto corner_radius = 1;
  bool has_corner_radius() const;
  private:
  bool _internal_has_corner_radius() const;
  public:
  void clear_corner_radius();
  const ::autofill_assistant::ClientDimensionProto& corner_radius() const;
  PROTOBUF_NODISCARD ::autofill_assistant::ClientDimensionProto* release_corner_radius();
  ::autofill_assistant::ClientDimensionProto* mutable_corner_radius();
  void set_allocated_corner_radius(::autofill_assistant::ClientDimensionProto* corner_radius);
  private:
  const ::autofill_assistant::ClientDimensionProto& _internal_corner_radius() const;
  ::autofill_assistant::ClientDimensionProto* _internal_mutable_corner_radius();
  public:
  void unsafe_arena_set_allocated_corner_radius(
      ::autofill_assistant::ClientDimensionProto* corner_radius);
  ::autofill_assistant::ClientDimensionProto* unsafe_arena_release_corner_radius();

  // @@protoc_insertion_point(class_scope:autofill_assistant.ShapeDrawableProto.Rectangle)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::autofill_assistant::ClientDimensionProto* corner_radius_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fview_5flayout_2eproto;
};
// -------------------------------------------------------------------

class ShapeDrawableProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.ShapeDrawableProto) */ {
 public:
  inline ShapeDrawableProto() : ShapeDrawableProto(nullptr) {}
  ~ShapeDrawableProto() override;
  explicit PROTOBUF_CONSTEXPR ShapeDrawableProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ShapeDrawableProto(const ShapeDrawableProto& from);
  ShapeDrawableProto(ShapeDrawableProto&& from) noexcept
    : ShapeDrawableProto() {
    *this = ::std::move(from);
  }

  inline ShapeDrawableProto& operator=(const ShapeDrawableProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShapeDrawableProto& operator=(ShapeDrawableProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ShapeDrawableProto& default_instance() {
    return *internal_default_instance();
  }
  enum ShapeCase {
    kRectangle = 1,
    SHAPE_NOT_SET = 0,
  };

  static inline const ShapeDrawableProto* internal_default_instance() {
    return reinterpret_cast<const ShapeDrawableProto*>(
               &_ShapeDrawableProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ShapeDrawableProto& a, ShapeDrawableProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(ShapeDrawableProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShapeDrawableProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ShapeDrawableProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ShapeDrawableProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ShapeDrawableProto& from);
  void MergeFrom(const ShapeDrawableProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ShapeDrawableProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.ShapeDrawableProto";
  }
  protected:
  explicit ShapeDrawableProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef ShapeDrawableProto_Rectangle Rectangle;

  // accessors -------------------------------------------------------

  enum : int {
    kBackgroundColorFieldNumber = 2,
    kStrokeWidthFieldNumber = 3,
    kStrokeColorFieldNumber = 4,
    kRectangleFieldNumber = 1,
  };
  // optional .autofill_assistant.ColorProto background_color = 2;
  bool has_background_color() const;
  private:
  bool _internal_has_background_color() const;
  public:
  void clear_background_color();
  const ::autofill_assistant::ColorProto& background_color() const;
  PROTOBUF_NODISCARD ::autofill_assistant::ColorProto* release_background_color();
  ::autofill_assistant::ColorProto* mutable_background_color();
  void set_allocated_background_color(::autofill_assistant::ColorProto* background_color);
  private:
  const ::autofill_assistant::ColorProto& _internal_background_color() const;
  ::autofill_assistant::ColorProto* _internal_mutable_background_color();
  public:
  void unsafe_arena_set_allocated_background_color(
      ::autofill_assistant::ColorProto* background_color);
  ::autofill_assistant::ColorProto* unsafe_arena_release_background_color();

  // optional .autofill_assistant.ClientDimensionProto stroke_width = 3;
  bool has_stroke_width() const;
  private:
  bool _internal_has_stroke_width() const;
  public:
  void clear_stroke_width();
  const ::autofill_assistant::ClientDimensionProto& stroke_width() const;
  PROTOBUF_NODISCARD ::autofill_assistant::ClientDimensionProto* release_stroke_width();
  ::autofill_assistant::ClientDimensionProto* mutable_stroke_width();
  void set_allocated_stroke_width(::autofill_assistant::ClientDimensionProto* stroke_width);
  private:
  const ::autofill_assistant::ClientDimensionProto& _internal_stroke_width() const;
  ::autofill_assistant::ClientDimensionProto* _internal_mutable_stroke_width();
  public:
  void unsafe_arena_set_allocated_stroke_width(
      ::autofill_assistant::ClientDimensionProto* stroke_width);
  ::autofill_assistant::ClientDimensionProto* unsafe_arena_release_stroke_width();

  // optional .autofill_assistant.ColorProto stroke_color = 4;
  bool has_stroke_color() const;
  private:
  bool _internal_has_stroke_color() const;
  public:
  void clear_stroke_color();
  const ::autofill_assistant::ColorProto& stroke_color() const;
  PROTOBUF_NODISCARD ::autofill_assistant::ColorProto* release_stroke_color();
  ::autofill_assistant::ColorProto* mutable_stroke_color();
  void set_allocated_stroke_color(::autofill_assistant::ColorProto* stroke_color);
  private:
  const ::autofill_assistant::ColorProto& _internal_stroke_color() const;
  ::autofill_assistant::ColorProto* _internal_mutable_stroke_color();
  public:
  void unsafe_arena_set_allocated_stroke_color(
      ::autofill_assistant::ColorProto* stroke_color);
  ::autofill_assistant::ColorProto* unsafe_arena_release_stroke_color();

  // .autofill_assistant.ShapeDrawableProto.Rectangle rectangle = 1;
  bool has_rectangle() const;
  private:
  bool _internal_has_rectangle() const;
  public:
  void clear_rectangle();
  const ::autofill_assistant::ShapeDrawableProto_Rectangle& rectangle() const;
  PROTOBUF_NODISCARD ::autofill_assistant::ShapeDrawableProto_Rectangle* release_rectangle();
  ::autofill_assistant::ShapeDrawableProto_Rectangle* mutable_rectangle();
  void set_allocated_rectangle(::autofill_assistant::ShapeDrawableProto_Rectangle* rectangle);
  private:
  const ::autofill_assistant::ShapeDrawableProto_Rectangle& _internal_rectangle() const;
  ::autofill_assistant::ShapeDrawableProto_Rectangle* _internal_mutable_rectangle();
  public:
  void unsafe_arena_set_allocated_rectangle(
      ::autofill_assistant::ShapeDrawableProto_Rectangle* rectangle);
  ::autofill_assistant::ShapeDrawableProto_Rectangle* unsafe_arena_release_rectangle();

  void clear_shape();
  ShapeCase shape_case() const;
  // @@protoc_insertion_point(class_scope:autofill_assistant.ShapeDrawableProto)
 private:
  class _Internal;
  void set_has_rectangle();

  inline bool has_shape() const;
  inline void clear_has_shape();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::autofill_assistant::ColorProto* background_color_;
  ::autofill_assistant::ClientDimensionProto* stroke_width_;
  ::autofill_assistant::ColorProto* stroke_color_;
  union ShapeUnion {
    constexpr ShapeUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::autofill_assistant::ShapeDrawableProto_Rectangle* rectangle_;
  } shape_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fview_5flayout_2eproto;
};
// -------------------------------------------------------------------

class ConfigBasedUrlProto_UrlEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntryLite<ConfigBasedUrlProto_UrlEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntryLite<ConfigBasedUrlProto_UrlEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  ConfigBasedUrlProto_UrlEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR ConfigBasedUrlProto_UrlEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit ConfigBasedUrlProto_UrlEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const ConfigBasedUrlProto_UrlEntry_DoNotUse& other);
  static const ConfigBasedUrlProto_UrlEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const ConfigBasedUrlProto_UrlEntry_DoNotUse*>(&_ConfigBasedUrlProto_UrlEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(void*) { return true; }
  static bool ValidateValue(void*) { return true; }
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fview_5flayout_2eproto;
};

// -------------------------------------------------------------------

class ConfigBasedUrlProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.ConfigBasedUrlProto) */ {
 public:
  inline ConfigBasedUrlProto() : ConfigBasedUrlProto(nullptr) {}
  ~ConfigBasedUrlProto() override;
  explicit PROTOBUF_CONSTEXPR ConfigBasedUrlProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConfigBasedUrlProto(const ConfigBasedUrlProto& from);
  ConfigBasedUrlProto(ConfigBasedUrlProto&& from) noexcept
    : ConfigBasedUrlProto() {
    *this = ::std::move(from);
  }

  inline ConfigBasedUrlProto& operator=(const ConfigBasedUrlProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConfigBasedUrlProto& operator=(ConfigBasedUrlProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ConfigBasedUrlProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConfigBasedUrlProto* internal_default_instance() {
    return reinterpret_cast<const ConfigBasedUrlProto*>(
               &_ConfigBasedUrlProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(ConfigBasedUrlProto& a, ConfigBasedUrlProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(ConfigBasedUrlProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConfigBasedUrlProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConfigBasedUrlProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConfigBasedUrlProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ConfigBasedUrlProto& from);
  void MergeFrom(const ConfigBasedUrlProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ConfigBasedUrlProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.ConfigBasedUrlProto";
  }
  protected:
  explicit ConfigBasedUrlProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kUrlFieldNumber = 1,
  };
  // map<string, string> url = 1;
  int url_size() const;
  private:
  int _internal_url_size() const;
  public:
  void clear_url();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_url() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_url();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      url() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_url();

  // @@protoc_insertion_point(class_scope:autofill_assistant.ConfigBasedUrlProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapFieldLite<
      ConfigBasedUrlProto_UrlEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> url_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fview_5flayout_2eproto;
};
// -------------------------------------------------------------------

class BitmapDrawableProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.BitmapDrawableProto) */ {
 public:
  inline BitmapDrawableProto() : BitmapDrawableProto(nullptr) {}
  ~BitmapDrawableProto() override;
  explicit PROTOBUF_CONSTEXPR BitmapDrawableProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BitmapDrawableProto(const BitmapDrawableProto& from);
  BitmapDrawableProto(BitmapDrawableProto&& from) noexcept
    : BitmapDrawableProto() {
    *this = ::std::move(from);
  }

  inline BitmapDrawableProto& operator=(const BitmapDrawableProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline BitmapDrawableProto& operator=(BitmapDrawableProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const BitmapDrawableProto& default_instance() {
    return *internal_default_instance();
  }
  enum ImageUrlCase {
    kUrl = 1,
    kConfigBasedUrl = 4,
    IMAGE_URL_NOT_SET = 0,
  };

  static inline const BitmapDrawableProto* internal_default_instance() {
    return reinterpret_cast<const BitmapDrawableProto*>(
               &_BitmapDrawableProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(BitmapDrawableProto& a, BitmapDrawableProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(BitmapDrawableProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BitmapDrawableProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BitmapDrawableProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BitmapDrawableProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const BitmapDrawableProto& from);
  void MergeFrom(const BitmapDrawableProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BitmapDrawableProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.BitmapDrawableProto";
  }
  protected:
  explicit BitmapDrawableProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWidthFieldNumber = 2,
    kHeightFieldNumber = 3,
    kUseInstrinsicDimensionsFieldNumber = 5,
    kUrlFieldNumber = 1,
    kConfigBasedUrlFieldNumber = 4,
  };
  // optional .autofill_assistant.ClientDimensionProto width = 2;
  bool has_width() const;
  private:
  bool _internal_has_width() const;
  public:
  void clear_width();
  const ::autofill_assistant::ClientDimensionProto& width() const;
  PROTOBUF_NODISCARD ::autofill_assistant::ClientDimensionProto* release_width();
  ::autofill_assistant::ClientDimensionProto* mutable_width();
  void set_allocated_width(::autofill_assistant::ClientDimensionProto* width);
  private:
  const ::autofill_assistant::ClientDimensionProto& _internal_width() const;
  ::autofill_assistant::ClientDimensionProto* _internal_mutable_width();
  public:
  void unsafe_arena_set_allocated_width(
      ::autofill_assistant::ClientDimensionProto* width);
  ::autofill_assistant::ClientDimensionProto* unsafe_arena_release_width();

  // optional .autofill_assistant.ClientDimensionProto height = 3;
  bool has_height() const;
  private:
  bool _internal_has_height() const;
  public:
  void clear_height();
  const ::autofill_assistant::ClientDimensionProto& height() const;
  PROTOBUF_NODISCARD ::autofill_assistant::ClientDimensionProto* release_height();
  ::autofill_assistant::ClientDimensionProto* mutable_height();
  void set_allocated_height(::autofill_assistant::ClientDimensionProto* height);
  private:
  const ::autofill_assistant::ClientDimensionProto& _internal_height() const;
  ::autofill_assistant::ClientDimensionProto* _internal_mutable_height();
  public:
  void unsafe_arena_set_allocated_height(
      ::autofill_assistant::ClientDimensionProto* height);
  ::autofill_assistant::ClientDimensionProto* unsafe_arena_release_height();

  // optional bool use_instrinsic_dimensions = 5;
  bool has_use_instrinsic_dimensions() const;
  private:
  bool _internal_has_use_instrinsic_dimensions() const;
  public:
  void clear_use_instrinsic_dimensions();
  bool use_instrinsic_dimensions() const;
  void set_use_instrinsic_dimensions(bool value);
  private:
  bool _internal_use_instrinsic_dimensions() const;
  void _internal_set_use_instrinsic_dimensions(bool value);
  public:

  // string url = 1;
  bool has_url() const;
  private:
  bool _internal_has_url() const;
  public:
  void clear_url();
  const std::string& url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_url();
  PROTOBUF_NODISCARD std::string* release_url();
  void set_allocated_url(std::string* url);
  private:
  const std::string& _internal_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_url(const std::string& value);
  std::string* _internal_mutable_url();
  public:

  // .autofill_assistant.ConfigBasedUrlProto config_based_url = 4;
  bool has_config_based_url() const;
  private:
  bool _internal_has_config_based_url() const;
  public:
  void clear_config_based_url();
  const ::autofill_assistant::ConfigBasedUrlProto& config_based_url() const;
  PROTOBUF_NODISCARD ::autofill_assistant::ConfigBasedUrlProto* release_config_based_url();
  ::autofill_assistant::ConfigBasedUrlProto* mutable_config_based_url();
  void set_allocated_config_based_url(::autofill_assistant::ConfigBasedUrlProto* config_based_url);
  private:
  const ::autofill_assistant::ConfigBasedUrlProto& _internal_config_based_url() const;
  ::autofill_assistant::ConfigBasedUrlProto* _internal_mutable_config_based_url();
  public:
  void unsafe_arena_set_allocated_config_based_url(
      ::autofill_assistant::ConfigBasedUrlProto* config_based_url);
  ::autofill_assistant::ConfigBasedUrlProto* unsafe_arena_release_config_based_url();

  void clear_image_url();
  ImageUrlCase image_url_case() const;
  // @@protoc_insertion_point(class_scope:autofill_assistant.BitmapDrawableProto)
 private:
  class _Internal;
  void set_has_url();
  void set_has_config_based_url();

  inline bool has_image_url() const;
  inline void clear_has_image_url();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::autofill_assistant::ClientDimensionProto* width_;
  ::autofill_assistant::ClientDimensionProto* height_;
  bool use_instrinsic_dimensions_;
  union ImageUrlUnion {
    constexpr ImageUrlUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr url_;
    ::autofill_assistant::ConfigBasedUrlProto* config_based_url_;
  } image_url_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fview_5flayout_2eproto;
};
// -------------------------------------------------------------------

class FaviconDrawableProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.FaviconDrawableProto) */ {
 public:
  inline FaviconDrawableProto() : FaviconDrawableProto(nullptr) {}
  ~FaviconDrawableProto() override;
  explicit PROTOBUF_CONSTEXPR FaviconDrawableProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FaviconDrawableProto(const FaviconDrawableProto& from);
  FaviconDrawableProto(FaviconDrawableProto&& from) noexcept
    : FaviconDrawableProto() {
    *this = ::std::move(from);
  }

  inline FaviconDrawableProto& operator=(const FaviconDrawableProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline FaviconDrawableProto& operator=(FaviconDrawableProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const FaviconDrawableProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const FaviconDrawableProto* internal_default_instance() {
    return reinterpret_cast<const FaviconDrawableProto*>(
               &_FaviconDrawableProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(FaviconDrawableProto& a, FaviconDrawableProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(FaviconDrawableProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FaviconDrawableProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FaviconDrawableProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FaviconDrawableProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const FaviconDrawableProto& from);
  void MergeFrom(const FaviconDrawableProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(FaviconDrawableProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.FaviconDrawableProto";
  }
  protected:
  explicit FaviconDrawableProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWebsiteUrlFieldNumber = 3,
    kDiameterSizeFieldNumber = 1,
    kForceMonogramFieldNumber = 2,
  };
  // optional string website_url = 3;
  bool has_website_url() const;
  private:
  bool _internal_has_website_url() const;
  public:
  void clear_website_url();
  const std::string& website_url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_website_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_website_url();
  PROTOBUF_NODISCARD std::string* release_website_url();
  void set_allocated_website_url(std::string* website_url);
  private:
  const std::string& _internal_website_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_website_url(const std::string& value);
  std::string* _internal_mutable_website_url();
  public:

  // optional .autofill_assistant.ClientDimensionProto diameter_size = 1;
  bool has_diameter_size() const;
  private:
  bool _internal_has_diameter_size() const;
  public:
  void clear_diameter_size();
  const ::autofill_assistant::ClientDimensionProto& diameter_size() const;
  PROTOBUF_NODISCARD ::autofill_assistant::ClientDimensionProto* release_diameter_size();
  ::autofill_assistant::ClientDimensionProto* mutable_diameter_size();
  void set_allocated_diameter_size(::autofill_assistant::ClientDimensionProto* diameter_size);
  private:
  const ::autofill_assistant::ClientDimensionProto& _internal_diameter_size() const;
  ::autofill_assistant::ClientDimensionProto* _internal_mutable_diameter_size();
  public:
  void unsafe_arena_set_allocated_diameter_size(
      ::autofill_assistant::ClientDimensionProto* diameter_size);
  ::autofill_assistant::ClientDimensionProto* unsafe_arena_release_diameter_size();

  // optional bool force_monogram = 2;
  bool has_force_monogram() const;
  private:
  bool _internal_has_force_monogram() const;
  public:
  void clear_force_monogram();
  bool force_monogram() const;
  void set_force_monogram(bool value);
  private:
  bool _internal_force_monogram() const;
  void _internal_set_force_monogram(bool value);
  public:

  // @@protoc_insertion_point(class_scope:autofill_assistant.FaviconDrawableProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr website_url_;
  ::autofill_assistant::ClientDimensionProto* diameter_size_;
  bool force_monogram_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fview_5flayout_2eproto;
};
// -------------------------------------------------------------------

class DrawableProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.DrawableProto) */ {
 public:
  inline DrawableProto() : DrawableProto(nullptr) {}
  ~DrawableProto() override;
  explicit PROTOBUF_CONSTEXPR DrawableProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DrawableProto(const DrawableProto& from);
  DrawableProto(DrawableProto&& from) noexcept
    : DrawableProto() {
    *this = ::std::move(from);
  }

  inline DrawableProto& operator=(const DrawableProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline DrawableProto& operator=(DrawableProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DrawableProto& default_instance() {
    return *internal_default_instance();
  }
  enum DrawableCase {
    kResourceIdentifier = 1,
    kBitmap = 2,
    kShape = 3,
    kIcon = 4,
    kImageData = 5,
    kImageDataBase64 = 7,
    kFavicon = 6,
    DRAWABLE_NOT_SET = 0,
  };

  static inline const DrawableProto* internal_default_instance() {
    return reinterpret_cast<const DrawableProto*>(
               &_DrawableProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(DrawableProto& a, DrawableProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(DrawableProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DrawableProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DrawableProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DrawableProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DrawableProto& from);
  void MergeFrom(const DrawableProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DrawableProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.DrawableProto";
  }
  protected:
  explicit DrawableProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef DrawableProto_Icon Icon;
  static constexpr Icon DRAWABLE_ICON_UNDEFINED =
    DrawableProto_Icon_DRAWABLE_ICON_UNDEFINED;
  static constexpr Icon PROGRESSBAR_DEFAULT_INITIAL_STEP =
    DrawableProto_Icon_PROGRESSBAR_DEFAULT_INITIAL_STEP;
  static constexpr Icon PROGRESSBAR_DEFAULT_DATA_COLLECTION =
    DrawableProto_Icon_PROGRESSBAR_DEFAULT_DATA_COLLECTION;
  static constexpr Icon PROGRESSBAR_DEFAULT_PAYMENT =
    DrawableProto_Icon_PROGRESSBAR_DEFAULT_PAYMENT;
  static constexpr Icon PROGRESSBAR_DEFAULT_FINAL_STEP =
    DrawableProto_Icon_PROGRESSBAR_DEFAULT_FINAL_STEP;
  static constexpr Icon SITTING_PERSON =
    DrawableProto_Icon_SITTING_PERSON;
  static constexpr Icon TICKET_STUB =
    DrawableProto_Icon_TICKET_STUB;
  static constexpr Icon SHOPPING_BASKET =
    DrawableProto_Icon_SHOPPING_BASKET;
  static constexpr Icon FAST_FOOD =
    DrawableProto_Icon_FAST_FOOD;
  static constexpr Icon LOCAL_DINING =
    DrawableProto_Icon_LOCAL_DINING;
  static constexpr Icon COGWHEEL =
    DrawableProto_Icon_COGWHEEL;
  static constexpr Icon KEY =
    DrawableProto_Icon_KEY;
  static constexpr Icon CAR =
    DrawableProto_Icon_CAR;
  static constexpr Icon GROCERY =
    DrawableProto_Icon_GROCERY;
  static constexpr Icon VISIBILITY_ON =
    DrawableProto_Icon_VISIBILITY_ON;
  static constexpr Icon VISIBILITY_OFF =
    DrawableProto_Icon_VISIBILITY_OFF;
  static inline bool Icon_IsValid(int value) {
    return DrawableProto_Icon_IsValid(value);
  }
  static constexpr Icon Icon_MIN =
    DrawableProto_Icon_Icon_MIN;
  static constexpr Icon Icon_MAX =
    DrawableProto_Icon_Icon_MAX;
  static constexpr int Icon_ARRAYSIZE =
    DrawableProto_Icon_Icon_ARRAYSIZE;
  template<typename T>
  static inline const std::string& Icon_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Icon>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Icon_Name.");
    return DrawableProto_Icon_Name(enum_t_value);
  }
  static inline bool Icon_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Icon* value) {
    return DrawableProto_Icon_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kResourceIdentifierFieldNumber = 1,
    kBitmapFieldNumber = 2,
    kShapeFieldNumber = 3,
    kIconFieldNumber = 4,
    kImageDataFieldNumber = 5,
    kImageDataBase64FieldNumber = 7,
    kFaviconFieldNumber = 6,
  };
  // string resource_identifier = 1;
  bool has_resource_identifier() const;
  private:
  bool _internal_has_resource_identifier() const;
  public:
  void clear_resource_identifier();
  const std::string& resource_identifier() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_resource_identifier(ArgT0&& arg0, ArgT... args);
  std::string* mutable_resource_identifier();
  PROTOBUF_NODISCARD std::string* release_resource_identifier();
  void set_allocated_resource_identifier(std::string* resource_identifier);
  private:
  const std::string& _internal_resource_identifier() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_resource_identifier(const std::string& value);
  std::string* _internal_mutable_resource_identifier();
  public:

  // .autofill_assistant.BitmapDrawableProto bitmap = 2;
  bool has_bitmap() const;
  private:
  bool _internal_has_bitmap() const;
  public:
  void clear_bitmap();
  const ::autofill_assistant::BitmapDrawableProto& bitmap() const;
  PROTOBUF_NODISCARD ::autofill_assistant::BitmapDrawableProto* release_bitmap();
  ::autofill_assistant::BitmapDrawableProto* mutable_bitmap();
  void set_allocated_bitmap(::autofill_assistant::BitmapDrawableProto* bitmap);
  private:
  const ::autofill_assistant::BitmapDrawableProto& _internal_bitmap() const;
  ::autofill_assistant::BitmapDrawableProto* _internal_mutable_bitmap();
  public:
  void unsafe_arena_set_allocated_bitmap(
      ::autofill_assistant::BitmapDrawableProto* bitmap);
  ::autofill_assistant::BitmapDrawableProto* unsafe_arena_release_bitmap();

  // .autofill_assistant.ShapeDrawableProto shape = 3;
  bool has_shape() const;
  private:
  bool _internal_has_shape() const;
  public:
  void clear_shape();
  const ::autofill_assistant::ShapeDrawableProto& shape() const;
  PROTOBUF_NODISCARD ::autofill_assistant::ShapeDrawableProto* release_shape();
  ::autofill_assistant::ShapeDrawableProto* mutable_shape();
  void set_allocated_shape(::autofill_assistant::ShapeDrawableProto* shape);
  private:
  const ::autofill_assistant::ShapeDrawableProto& _internal_shape() const;
  ::autofill_assistant::ShapeDrawableProto* _internal_mutable_shape();
  public:
  void unsafe_arena_set_allocated_shape(
      ::autofill_assistant::ShapeDrawableProto* shape);
  ::autofill_assistant::ShapeDrawableProto* unsafe_arena_release_shape();

  // .autofill_assistant.DrawableProto.Icon icon = 4;
  bool has_icon() const;
  private:
  bool _internal_has_icon() const;
  public:
  void clear_icon();
  ::autofill_assistant::DrawableProto_Icon icon() const;
  void set_icon(::autofill_assistant::DrawableProto_Icon value);
  private:
  ::autofill_assistant::DrawableProto_Icon _internal_icon() const;
  void _internal_set_icon(::autofill_assistant::DrawableProto_Icon value);
  public:

  // bytes image_data = 5;
  bool has_image_data() const;
  private:
  bool _internal_has_image_data() const;
  public:
  void clear_image_data();
  const std::string& image_data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_image_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_image_data();
  PROTOBUF_NODISCARD std::string* release_image_data();
  void set_allocated_image_data(std::string* image_data);
  private:
  const std::string& _internal_image_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_image_data(const std::string& value);
  std::string* _internal_mutable_image_data();
  public:

  // string image_data_base64 = 7;
  bool has_image_data_base64() const;
  private:
  bool _internal_has_image_data_base64() const;
  public:
  void clear_image_data_base64();
  const std::string& image_data_base64() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_image_data_base64(ArgT0&& arg0, ArgT... args);
  std::string* mutable_image_data_base64();
  PROTOBUF_NODISCARD std::string* release_image_data_base64();
  void set_allocated_image_data_base64(std::string* image_data_base64);
  private:
  const std::string& _internal_image_data_base64() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_image_data_base64(const std::string& value);
  std::string* _internal_mutable_image_data_base64();
  public:

  // .autofill_assistant.FaviconDrawableProto favicon = 6;
  bool has_favicon() const;
  private:
  bool _internal_has_favicon() const;
  public:
  void clear_favicon();
  const ::autofill_assistant::FaviconDrawableProto& favicon() const;
  PROTOBUF_NODISCARD ::autofill_assistant::FaviconDrawableProto* release_favicon();
  ::autofill_assistant::FaviconDrawableProto* mutable_favicon();
  void set_allocated_favicon(::autofill_assistant::FaviconDrawableProto* favicon);
  private:
  const ::autofill_assistant::FaviconDrawableProto& _internal_favicon() const;
  ::autofill_assistant::FaviconDrawableProto* _internal_mutable_favicon();
  public:
  void unsafe_arena_set_allocated_favicon(
      ::autofill_assistant::FaviconDrawableProto* favicon);
  ::autofill_assistant::FaviconDrawableProto* unsafe_arena_release_favicon();

  void clear_drawable();
  DrawableCase drawable_case() const;
  // @@protoc_insertion_point(class_scope:autofill_assistant.DrawableProto)
 private:
  class _Internal;
  void set_has_resource_identifier();
  void set_has_bitmap();
  void set_has_shape();
  void set_has_icon();
  void set_has_image_data();
  void set_has_image_data_base64();
  void set_has_favicon();

  inline bool has_drawable() const;
  inline void clear_has_drawable();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union DrawableUnion {
    constexpr DrawableUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr resource_identifier_;
    ::autofill_assistant::BitmapDrawableProto* bitmap_;
    ::autofill_assistant::ShapeDrawableProto* shape_;
    int icon_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr image_data_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr image_data_base64_;
    ::autofill_assistant::FaviconDrawableProto* favicon_;
  } drawable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fview_5flayout_2eproto;
};
// -------------------------------------------------------------------

class ViewAttributesProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.ViewAttributesProto) */ {
 public:
  inline ViewAttributesProto() : ViewAttributesProto(nullptr) {}
  ~ViewAttributesProto() override;
  explicit PROTOBUF_CONSTEXPR ViewAttributesProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ViewAttributesProto(const ViewAttributesProto& from);
  ViewAttributesProto(ViewAttributesProto&& from) noexcept
    : ViewAttributesProto() {
    *this = ::std::move(from);
  }

  inline ViewAttributesProto& operator=(const ViewAttributesProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline ViewAttributesProto& operator=(ViewAttributesProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ViewAttributesProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const ViewAttributesProto* internal_default_instance() {
    return reinterpret_cast<const ViewAttributesProto*>(
               &_ViewAttributesProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(ViewAttributesProto& a, ViewAttributesProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(ViewAttributesProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ViewAttributesProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ViewAttributesProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ViewAttributesProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ViewAttributesProto& from);
  void MergeFrom(const ViewAttributesProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ViewAttributesProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.ViewAttributesProto";
  }
  protected:
  explicit ViewAttributesProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContentDescriptionFieldNumber = 6,
    kBackgroundFieldNumber = 5,
    kPaddingStartFieldNumber = 1,
    kPaddingTopFieldNumber = 2,
    kPaddingEndFieldNumber = 3,
    kPaddingBottomFieldNumber = 4,
    kVisibleFieldNumber = 7,
    kEnabledFieldNumber = 8,
  };
  // optional string content_description = 6;
  bool has_content_description() const;
  private:
  bool _internal_has_content_description() const;
  public:
  void clear_content_description();
  const std::string& content_description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_content_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_content_description();
  PROTOBUF_NODISCARD std::string* release_content_description();
  void set_allocated_content_description(std::string* content_description);
  private:
  const std::string& _internal_content_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_content_description(const std::string& value);
  std::string* _internal_mutable_content_description();
  public:

  // optional .autofill_assistant.DrawableProto background = 5;
  bool has_background() const;
  private:
  bool _internal_has_background() const;
  public:
  void clear_background();
  const ::autofill_assistant::DrawableProto& background() const;
  PROTOBUF_NODISCARD ::autofill_assistant::DrawableProto* release_background();
  ::autofill_assistant::DrawableProto* mutable_background();
  void set_allocated_background(::autofill_assistant::DrawableProto* background);
  private:
  const ::autofill_assistant::DrawableProto& _internal_background() const;
  ::autofill_assistant::DrawableProto* _internal_mutable_background();
  public:
  void unsafe_arena_set_allocated_background(
      ::autofill_assistant::DrawableProto* background);
  ::autofill_assistant::DrawableProto* unsafe_arena_release_background();

  // optional int32 padding_start = 1;
  bool has_padding_start() const;
  private:
  bool _internal_has_padding_start() const;
  public:
  void clear_padding_start();
  int32_t padding_start() const;
  void set_padding_start(int32_t value);
  private:
  int32_t _internal_padding_start() const;
  void _internal_set_padding_start(int32_t value);
  public:

  // optional int32 padding_top = 2;
  bool has_padding_top() const;
  private:
  bool _internal_has_padding_top() const;
  public:
  void clear_padding_top();
  int32_t padding_top() const;
  void set_padding_top(int32_t value);
  private:
  int32_t _internal_padding_top() const;
  void _internal_set_padding_top(int32_t value);
  public:

  // optional int32 padding_end = 3;
  bool has_padding_end() const;
  private:
  bool _internal_has_padding_end() const;
  public:
  void clear_padding_end();
  int32_t padding_end() const;
  void set_padding_end(int32_t value);
  private:
  int32_t _internal_padding_end() const;
  void _internal_set_padding_end(int32_t value);
  public:

  // optional int32 padding_bottom = 4;
  bool has_padding_bottom() const;
  private:
  bool _internal_has_padding_bottom() const;
  public:
  void clear_padding_bottom();
  int32_t padding_bottom() const;
  void set_padding_bottom(int32_t value);
  private:
  int32_t _internal_padding_bottom() const;
  void _internal_set_padding_bottom(int32_t value);
  public:

  // optional bool visible = 7 [default = true];
  bool has_visible() const;
  private:
  bool _internal_has_visible() const;
  public:
  void clear_visible();
  bool visible() const;
  void set_visible(bool value);
  private:
  bool _internal_visible() const;
  void _internal_set_visible(bool value);
  public:

  // optional bool enabled = 8 [default = true];
  bool has_enabled() const;
  private:
  bool _internal_has_enabled() const;
  public:
  void clear_enabled();
  bool enabled() const;
  void set_enabled(bool value);
  private:
  bool _internal_enabled() const;
  void _internal_set_enabled(bool value);
  public:

  // @@protoc_insertion_point(class_scope:autofill_assistant.ViewAttributesProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr content_description_;
  ::autofill_assistant::DrawableProto* background_;
  int32_t padding_start_;
  int32_t padding_top_;
  int32_t padding_end_;
  int32_t padding_bottom_;
  bool visible_;
  bool enabled_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fview_5flayout_2eproto;
};
// -------------------------------------------------------------------

class ViewLayoutParamsProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.ViewLayoutParamsProto) */ {
 public:
  inline ViewLayoutParamsProto() : ViewLayoutParamsProto(nullptr) {}
  ~ViewLayoutParamsProto() override;
  explicit PROTOBUF_CONSTEXPR ViewLayoutParamsProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ViewLayoutParamsProto(const ViewLayoutParamsProto& from);
  ViewLayoutParamsProto(ViewLayoutParamsProto&& from) noexcept
    : ViewLayoutParamsProto() {
    *this = ::std::move(from);
  }

  inline ViewLayoutParamsProto& operator=(const ViewLayoutParamsProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline ViewLayoutParamsProto& operator=(ViewLayoutParamsProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ViewLayoutParamsProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const ViewLayoutParamsProto* internal_default_instance() {
    return reinterpret_cast<const ViewLayoutParamsProto*>(
               &_ViewLayoutParamsProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(ViewLayoutParamsProto& a, ViewLayoutParamsProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(ViewLayoutParamsProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ViewLayoutParamsProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ViewLayoutParamsProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ViewLayoutParamsProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ViewLayoutParamsProto& from);
  void MergeFrom(const ViewLayoutParamsProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ViewLayoutParamsProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.ViewLayoutParamsProto";
  }
  protected:
  explicit ViewLayoutParamsProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef ViewLayoutParamsProto_Gravity Gravity;
  static constexpr Gravity UNDEFINED =
    ViewLayoutParamsProto_Gravity_UNDEFINED;
  static constexpr Gravity CENTER =
    ViewLayoutParamsProto_Gravity_CENTER;
  static constexpr Gravity CENTER_HORIZONTAL =
    ViewLayoutParamsProto_Gravity_CENTER_HORIZONTAL;
  static constexpr Gravity CENTER_VERTICAL =
    ViewLayoutParamsProto_Gravity_CENTER_VERTICAL;
  static constexpr Gravity START =
    ViewLayoutParamsProto_Gravity_START;
  static constexpr Gravity TOP =
    ViewLayoutParamsProto_Gravity_TOP;
  static constexpr Gravity END =
    ViewLayoutParamsProto_Gravity_END;
  static constexpr Gravity BOTTOM =
    ViewLayoutParamsProto_Gravity_BOTTOM;
  static constexpr Gravity FILL_HORIZONTAL =
    ViewLayoutParamsProto_Gravity_FILL_HORIZONTAL;
  static constexpr Gravity FILL_VERTICAL =
    ViewLayoutParamsProto_Gravity_FILL_VERTICAL;
  static inline bool Gravity_IsValid(int value) {
    return ViewLayoutParamsProto_Gravity_IsValid(value);
  }
  static constexpr Gravity Gravity_MIN =
    ViewLayoutParamsProto_Gravity_Gravity_MIN;
  static constexpr Gravity Gravity_MAX =
    ViewLayoutParamsProto_Gravity_Gravity_MAX;
  static constexpr int Gravity_ARRAYSIZE =
    ViewLayoutParamsProto_Gravity_Gravity_ARRAYSIZE;
  template<typename T>
  static inline const std::string& Gravity_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Gravity>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Gravity_Name.");
    return ViewLayoutParamsProto_Gravity_Name(enum_t_value);
  }
  static inline bool Gravity_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Gravity* value) {
    return ViewLayoutParamsProto_Gravity_Parse(name, value);
  }

  typedef ViewLayoutParamsProto_Size Size;
  static constexpr Size WRAP_CONTENT =
    ViewLayoutParamsProto_Size_WRAP_CONTENT;
  static constexpr Size MATCH_PARENT =
    ViewLayoutParamsProto_Size_MATCH_PARENT;
  static inline bool Size_IsValid(int value) {
    return ViewLayoutParamsProto_Size_IsValid(value);
  }
  static constexpr Size Size_MIN =
    ViewLayoutParamsProto_Size_Size_MIN;
  static constexpr Size Size_MAX =
    ViewLayoutParamsProto_Size_Size_MAX;
  static constexpr int Size_ARRAYSIZE =
    ViewLayoutParamsProto_Size_Size_ARRAYSIZE;
  template<typename T>
  static inline const std::string& Size_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Size>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Size_Name.");
    return ViewLayoutParamsProto_Size_Name(enum_t_value);
  }
  static inline bool Size_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Size* value) {
    return ViewLayoutParamsProto_Size_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kMarginStartFieldNumber = 3,
    kMarginTopFieldNumber = 4,
    kMarginEndFieldNumber = 5,
    kMarginBottomFieldNumber = 6,
    kLayoutGravityFieldNumber = 7,
    kLayoutWeightFieldNumber = 8,
    kMinimumWidthFieldNumber = 9,
    kMinimumHeightFieldNumber = 10,
    kLayoutWidthFieldNumber = 1,
    kLayoutHeightFieldNumber = 2,
  };
  // optional int32 margin_start = 3;
  bool has_margin_start() const;
  private:
  bool _internal_has_margin_start() const;
  public:
  void clear_margin_start();
  int32_t margin_start() const;
  void set_margin_start(int32_t value);
  private:
  int32_t _internal_margin_start() const;
  void _internal_set_margin_start(int32_t value);
  public:

  // optional int32 margin_top = 4;
  bool has_margin_top() const;
  private:
  bool _internal_has_margin_top() const;
  public:
  void clear_margin_top();
  int32_t margin_top() const;
  void set_margin_top(int32_t value);
  private:
  int32_t _internal_margin_top() const;
  void _internal_set_margin_top(int32_t value);
  public:

  // optional int32 margin_end = 5;
  bool has_margin_end() const;
  private:
  bool _internal_has_margin_end() const;
  public:
  void clear_margin_end();
  int32_t margin_end() const;
  void set_margin_end(int32_t value);
  private:
  int32_t _internal_margin_end() const;
  void _internal_set_margin_end(int32_t value);
  public:

  // optional int32 margin_bottom = 6;
  bool has_margin_bottom() const;
  private:
  bool _internal_has_margin_bottom() const;
  public:
  void clear_margin_bottom();
  int32_t margin_bottom() const;
  void set_margin_bottom(int32_t value);
  private:
  int32_t _internal_margin_bottom() const;
  void _internal_set_margin_bottom(int32_t value);
  public:

  // optional int32 layout_gravity = 7;
  bool has_layout_gravity() const;
  private:
  bool _internal_has_layout_gravity() const;
  public:
  void clear_layout_gravity();
  int32_t layout_gravity() const;
  void set_layout_gravity(int32_t value);
  private:
  int32_t _internal_layout_gravity() const;
  void _internal_set_layout_gravity(int32_t value);
  public:

  // optional float layout_weight = 8;
  bool has_layout_weight() const;
  private:
  bool _internal_has_layout_weight() const;
  public:
  void clear_layout_weight();
  float layout_weight() const;
  void set_layout_weight(float value);
  private:
  float _internal_layout_weight() const;
  void _internal_set_layout_weight(float value);
  public:

  // optional int32 minimum_width = 9;
  bool has_minimum_width() const;
  private:
  bool _internal_has_minimum_width() const;
  public:
  void clear_minimum_width();
  int32_t minimum_width() const;
  void set_minimum_width(int32_t value);
  private:
  int32_t _internal_minimum_width() const;
  void _internal_set_minimum_width(int32_t value);
  public:

  // optional int32 minimum_height = 10;
  bool has_minimum_height() const;
  private:
  bool _internal_has_minimum_height() const;
  public:
  void clear_minimum_height();
  int32_t minimum_height() const;
  void set_minimum_height(int32_t value);
  private:
  int32_t _internal_minimum_height() const;
  void _internal_set_minimum_height(int32_t value);
  public:

  // optional int32 layout_width = 1 [default = -2];
  bool has_layout_width() const;
  private:
  bool _internal_has_layout_width() const;
  public:
  void clear_layout_width();
  int32_t layout_width() const;
  void set_layout_width(int32_t value);
  private:
  int32_t _internal_layout_width() const;
  void _internal_set_layout_width(int32_t value);
  public:

  // optional int32 layout_height = 2 [default = -2];
  bool has_layout_height() const;
  private:
  bool _internal_has_layout_height() const;
  public:
  void clear_layout_height();
  int32_t layout_height() const;
  void set_layout_height(int32_t value);
  private:
  int32_t _internal_layout_height() const;
  void _internal_set_layout_height(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:autofill_assistant.ViewLayoutParamsProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int32_t margin_start_;
  int32_t margin_top_;
  int32_t margin_end_;
  int32_t margin_bottom_;
  int32_t layout_gravity_;
  float layout_weight_;
  int32_t minimum_width_;
  int32_t minimum_height_;
  int32_t layout_width_;
  int32_t layout_height_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fview_5flayout_2eproto;
};
// -------------------------------------------------------------------

class ViewContainerProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.ViewContainerProto) */ {
 public:
  inline ViewContainerProto() : ViewContainerProto(nullptr) {}
  ~ViewContainerProto() override;
  explicit PROTOBUF_CONSTEXPR ViewContainerProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ViewContainerProto(const ViewContainerProto& from);
  ViewContainerProto(ViewContainerProto&& from) noexcept
    : ViewContainerProto() {
    *this = ::std::move(from);
  }

  inline ViewContainerProto& operator=(const ViewContainerProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline ViewContainerProto& operator=(ViewContainerProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ViewContainerProto& default_instance() {
    return *internal_default_instance();
  }
  enum ContainerCase {
    kLinearLayout = 2,
    kExpanderAccordion = 3,
    CONTAINER_NOT_SET = 0,
  };

  static inline const ViewContainerProto* internal_default_instance() {
    return reinterpret_cast<const ViewContainerProto*>(
               &_ViewContainerProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(ViewContainerProto& a, ViewContainerProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(ViewContainerProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ViewContainerProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ViewContainerProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ViewContainerProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ViewContainerProto& from);
  void MergeFrom(const ViewContainerProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ViewContainerProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.ViewContainerProto";
  }
  protected:
  explicit ViewContainerProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kViewsFieldNumber = 1,
    kLinearLayoutFieldNumber = 2,
    kExpanderAccordionFieldNumber = 3,
  };
  // repeated .autofill_assistant.ViewProto views = 1;
  int views_size() const;
  private:
  int _internal_views_size() const;
  public:
  void clear_views();
  ::autofill_assistant::ViewProto* mutable_views(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::ViewProto >*
      mutable_views();
  private:
  const ::autofill_assistant::ViewProto& _internal_views(int index) const;
  ::autofill_assistant::ViewProto* _internal_add_views();
  public:
  const ::autofill_assistant::ViewProto& views(int index) const;
  ::autofill_assistant::ViewProto* add_views();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::ViewProto >&
      views() const;

  // .autofill_assistant.LinearLayoutProto linear_layout = 2;
  bool has_linear_layout() const;
  private:
  bool _internal_has_linear_layout() const;
  public:
  void clear_linear_layout();
  const ::autofill_assistant::LinearLayoutProto& linear_layout() const;
  PROTOBUF_NODISCARD ::autofill_assistant::LinearLayoutProto* release_linear_layout();
  ::autofill_assistant::LinearLayoutProto* mutable_linear_layout();
  void set_allocated_linear_layout(::autofill_assistant::LinearLayoutProto* linear_layout);
  private:
  const ::autofill_assistant::LinearLayoutProto& _internal_linear_layout() const;
  ::autofill_assistant::LinearLayoutProto* _internal_mutable_linear_layout();
  public:
  void unsafe_arena_set_allocated_linear_layout(
      ::autofill_assistant::LinearLayoutProto* linear_layout);
  ::autofill_assistant::LinearLayoutProto* unsafe_arena_release_linear_layout();

  // .autofill_assistant.VerticalExpanderAccordionProto expander_accordion = 3;
  bool has_expander_accordion() const;
  private:
  bool _internal_has_expander_accordion() const;
  public:
  void clear_expander_accordion();
  const ::autofill_assistant::VerticalExpanderAccordionProto& expander_accordion() const;
  PROTOBUF_NODISCARD ::autofill_assistant::VerticalExpanderAccordionProto* release_expander_accordion();
  ::autofill_assistant::VerticalExpanderAccordionProto* mutable_expander_accordion();
  void set_allocated_expander_accordion(::autofill_assistant::VerticalExpanderAccordionProto* expander_accordion);
  private:
  const ::autofill_assistant::VerticalExpanderAccordionProto& _internal_expander_accordion() const;
  ::autofill_assistant::VerticalExpanderAccordionProto* _internal_mutable_expander_accordion();
  public:
  void unsafe_arena_set_allocated_expander_accordion(
      ::autofill_assistant::VerticalExpanderAccordionProto* expander_accordion);
  ::autofill_assistant::VerticalExpanderAccordionProto* unsafe_arena_release_expander_accordion();

  void clear_container();
  ContainerCase container_case() const;
  // @@protoc_insertion_point(class_scope:autofill_assistant.ViewContainerProto)
 private:
  class _Internal;
  void set_has_linear_layout();
  void set_has_expander_accordion();

  inline bool has_container() const;
  inline void clear_has_container();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::ViewProto > views_;
  union ContainerUnion {
    constexpr ContainerUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::autofill_assistant::LinearLayoutProto* linear_layout_;
    ::autofill_assistant::VerticalExpanderAccordionProto* expander_accordion_;
  } container_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fview_5flayout_2eproto;
};
// -------------------------------------------------------------------

class LinearLayoutProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.LinearLayoutProto) */ {
 public:
  inline LinearLayoutProto() : LinearLayoutProto(nullptr) {}
  ~LinearLayoutProto() override;
  explicit PROTOBUF_CONSTEXPR LinearLayoutProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LinearLayoutProto(const LinearLayoutProto& from);
  LinearLayoutProto(LinearLayoutProto&& from) noexcept
    : LinearLayoutProto() {
    *this = ::std::move(from);
  }

  inline LinearLayoutProto& operator=(const LinearLayoutProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline LinearLayoutProto& operator=(LinearLayoutProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const LinearLayoutProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const LinearLayoutProto* internal_default_instance() {
    return reinterpret_cast<const LinearLayoutProto*>(
               &_LinearLayoutProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(LinearLayoutProto& a, LinearLayoutProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(LinearLayoutProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LinearLayoutProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LinearLayoutProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LinearLayoutProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const LinearLayoutProto& from);
  void MergeFrom(const LinearLayoutProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LinearLayoutProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.LinearLayoutProto";
  }
  protected:
  explicit LinearLayoutProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef LinearLayoutProto_Orientation Orientation;
  static constexpr Orientation HORIZONTAL =
    LinearLayoutProto_Orientation_HORIZONTAL;
  static constexpr Orientation VERTICAL =
    LinearLayoutProto_Orientation_VERTICAL;
  static inline bool Orientation_IsValid(int value) {
    return LinearLayoutProto_Orientation_IsValid(value);
  }
  static constexpr Orientation Orientation_MIN =
    LinearLayoutProto_Orientation_Orientation_MIN;
  static constexpr Orientation Orientation_MAX =
    LinearLayoutProto_Orientation_Orientation_MAX;
  static constexpr int Orientation_ARRAYSIZE =
    LinearLayoutProto_Orientation_Orientation_ARRAYSIZE;
  template<typename T>
  static inline const std::string& Orientation_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Orientation>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Orientation_Name.");
    return LinearLayoutProto_Orientation_Name(enum_t_value);
  }
  static inline bool Orientation_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Orientation* value) {
    return LinearLayoutProto_Orientation_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kOrientationFieldNumber = 1,
  };
  // optional .autofill_assistant.LinearLayoutProto.Orientation orientation = 1;
  bool has_orientation() const;
  private:
  bool _internal_has_orientation() const;
  public:
  void clear_orientation();
  ::autofill_assistant::LinearLayoutProto_Orientation orientation() const;
  void set_orientation(::autofill_assistant::LinearLayoutProto_Orientation value);
  private:
  ::autofill_assistant::LinearLayoutProto_Orientation _internal_orientation() const;
  void _internal_set_orientation(::autofill_assistant::LinearLayoutProto_Orientation value);
  public:

  // @@protoc_insertion_point(class_scope:autofill_assistant.LinearLayoutProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int orientation_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fview_5flayout_2eproto;
};
// -------------------------------------------------------------------

class VerticalExpanderViewProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.VerticalExpanderViewProto) */ {
 public:
  inline VerticalExpanderViewProto() : VerticalExpanderViewProto(nullptr) {}
  ~VerticalExpanderViewProto() override;
  explicit PROTOBUF_CONSTEXPR VerticalExpanderViewProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VerticalExpanderViewProto(const VerticalExpanderViewProto& from);
  VerticalExpanderViewProto(VerticalExpanderViewProto&& from) noexcept
    : VerticalExpanderViewProto() {
    *this = ::std::move(from);
  }

  inline VerticalExpanderViewProto& operator=(const VerticalExpanderViewProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline VerticalExpanderViewProto& operator=(VerticalExpanderViewProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const VerticalExpanderViewProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const VerticalExpanderViewProto* internal_default_instance() {
    return reinterpret_cast<const VerticalExpanderViewProto*>(
               &_VerticalExpanderViewProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(VerticalExpanderViewProto& a, VerticalExpanderViewProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(VerticalExpanderViewProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VerticalExpanderViewProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VerticalExpanderViewProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VerticalExpanderViewProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const VerticalExpanderViewProto& from);
  void MergeFrom(const VerticalExpanderViewProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(VerticalExpanderViewProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.VerticalExpanderViewProto";
  }
  protected:
  explicit VerticalExpanderViewProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef VerticalExpanderViewProto_ChevronStyle ChevronStyle;
  static constexpr ChevronStyle NOT_SET_AUTOMATIC =
    VerticalExpanderViewProto_ChevronStyle_NOT_SET_AUTOMATIC;
  static constexpr ChevronStyle ALWAYS =
    VerticalExpanderViewProto_ChevronStyle_ALWAYS;
  static constexpr ChevronStyle NEVER =
    VerticalExpanderViewProto_ChevronStyle_NEVER;
  static inline bool ChevronStyle_IsValid(int value) {
    return VerticalExpanderViewProto_ChevronStyle_IsValid(value);
  }
  static constexpr ChevronStyle ChevronStyle_MIN =
    VerticalExpanderViewProto_ChevronStyle_ChevronStyle_MIN;
  static constexpr ChevronStyle ChevronStyle_MAX =
    VerticalExpanderViewProto_ChevronStyle_ChevronStyle_MAX;
  static constexpr int ChevronStyle_ARRAYSIZE =
    VerticalExpanderViewProto_ChevronStyle_ChevronStyle_ARRAYSIZE;
  template<typename T>
  static inline const std::string& ChevronStyle_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ChevronStyle>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ChevronStyle_Name.");
    return VerticalExpanderViewProto_ChevronStyle_Name(enum_t_value);
  }
  static inline bool ChevronStyle_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ChevronStyle* value) {
    return VerticalExpanderViewProto_ChevronStyle_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTitleViewFieldNumber = 1,
    kCollapsedViewFieldNumber = 2,
    kExpandedViewFieldNumber = 3,
    kChevronStyleFieldNumber = 4,
  };
  // optional .autofill_assistant.ViewProto title_view = 1;
  bool has_title_view() const;
  private:
  bool _internal_has_title_view() const;
  public:
  void clear_title_view();
  const ::autofill_assistant::ViewProto& title_view() const;
  PROTOBUF_NODISCARD ::autofill_assistant::ViewProto* release_title_view();
  ::autofill_assistant::ViewProto* mutable_title_view();
  void set_allocated_title_view(::autofill_assistant::ViewProto* title_view);
  private:
  const ::autofill_assistant::ViewProto& _internal_title_view() const;
  ::autofill_assistant::ViewProto* _internal_mutable_title_view();
  public:
  void unsafe_arena_set_allocated_title_view(
      ::autofill_assistant::ViewProto* title_view);
  ::autofill_assistant::ViewProto* unsafe_arena_release_title_view();

  // optional .autofill_assistant.ViewProto collapsed_view = 2;
  bool has_collapsed_view() const;
  private:
  bool _internal_has_collapsed_view() const;
  public:
  void clear_collapsed_view();
  const ::autofill_assistant::ViewProto& collapsed_view() const;
  PROTOBUF_NODISCARD ::autofill_assistant::ViewProto* release_collapsed_view();
  ::autofill_assistant::ViewProto* mutable_collapsed_view();
  void set_allocated_collapsed_view(::autofill_assistant::ViewProto* collapsed_view);
  private:
  const ::autofill_assistant::ViewProto& _internal_collapsed_view() const;
  ::autofill_assistant::ViewProto* _internal_mutable_collapsed_view();
  public:
  void unsafe_arena_set_allocated_collapsed_view(
      ::autofill_assistant::ViewProto* collapsed_view);
  ::autofill_assistant::ViewProto* unsafe_arena_release_collapsed_view();

  // optional .autofill_assistant.ViewProto expanded_view = 3;
  bool has_expanded_view() const;
  private:
  bool _internal_has_expanded_view() const;
  public:
  void clear_expanded_view();
  const ::autofill_assistant::ViewProto& expanded_view() const;
  PROTOBUF_NODISCARD ::autofill_assistant::ViewProto* release_expanded_view();
  ::autofill_assistant::ViewProto* mutable_expanded_view();
  void set_allocated_expanded_view(::autofill_assistant::ViewProto* expanded_view);
  private:
  const ::autofill_assistant::ViewProto& _internal_expanded_view() const;
  ::autofill_assistant::ViewProto* _internal_mutable_expanded_view();
  public:
  void unsafe_arena_set_allocated_expanded_view(
      ::autofill_assistant::ViewProto* expanded_view);
  ::autofill_assistant::ViewProto* unsafe_arena_release_expanded_view();

  // optional .autofill_assistant.VerticalExpanderViewProto.ChevronStyle chevron_style = 4;
  bool has_chevron_style() const;
  private:
  bool _internal_has_chevron_style() const;
  public:
  void clear_chevron_style();
  ::autofill_assistant::VerticalExpanderViewProto_ChevronStyle chevron_style() const;
  void set_chevron_style(::autofill_assistant::VerticalExpanderViewProto_ChevronStyle value);
  private:
  ::autofill_assistant::VerticalExpanderViewProto_ChevronStyle _internal_chevron_style() const;
  void _internal_set_chevron_style(::autofill_assistant::VerticalExpanderViewProto_ChevronStyle value);
  public:

  // @@protoc_insertion_point(class_scope:autofill_assistant.VerticalExpanderViewProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::autofill_assistant::ViewProto* title_view_;
  ::autofill_assistant::ViewProto* collapsed_view_;
  ::autofill_assistant::ViewProto* expanded_view_;
  int chevron_style_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fview_5flayout_2eproto;
};
// -------------------------------------------------------------------

class VerticalExpanderAccordionProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.VerticalExpanderAccordionProto) */ {
 public:
  inline VerticalExpanderAccordionProto() : VerticalExpanderAccordionProto(nullptr) {}
  ~VerticalExpanderAccordionProto() override;
  explicit PROTOBUF_CONSTEXPR VerticalExpanderAccordionProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VerticalExpanderAccordionProto(const VerticalExpanderAccordionProto& from);
  VerticalExpanderAccordionProto(VerticalExpanderAccordionProto&& from) noexcept
    : VerticalExpanderAccordionProto() {
    *this = ::std::move(from);
  }

  inline VerticalExpanderAccordionProto& operator=(const VerticalExpanderAccordionProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline VerticalExpanderAccordionProto& operator=(VerticalExpanderAccordionProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const VerticalExpanderAccordionProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const VerticalExpanderAccordionProto* internal_default_instance() {
    return reinterpret_cast<const VerticalExpanderAccordionProto*>(
               &_VerticalExpanderAccordionProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(VerticalExpanderAccordionProto& a, VerticalExpanderAccordionProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(VerticalExpanderAccordionProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VerticalExpanderAccordionProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VerticalExpanderAccordionProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VerticalExpanderAccordionProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const VerticalExpanderAccordionProto& from);
  void MergeFrom(const VerticalExpanderAccordionProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(VerticalExpanderAccordionProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.VerticalExpanderAccordionProto";
  }
  protected:
  explicit VerticalExpanderAccordionProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrientationFieldNumber = 2,
  };
  // optional .autofill_assistant.LinearLayoutProto.Orientation orientation = 2;
  bool has_orientation() const;
  private:
  bool _internal_has_orientation() const;
  public:
  void clear_orientation();
  ::autofill_assistant::LinearLayoutProto_Orientation orientation() const;
  void set_orientation(::autofill_assistant::LinearLayoutProto_Orientation value);
  private:
  ::autofill_assistant::LinearLayoutProto_Orientation _internal_orientation() const;
  void _internal_set_orientation(::autofill_assistant::LinearLayoutProto_Orientation value);
  public:

  // @@protoc_insertion_point(class_scope:autofill_assistant.VerticalExpanderAccordionProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int orientation_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fview_5flayout_2eproto;
};
// -------------------------------------------------------------------

class TextViewProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.TextViewProto) */ {
 public:
  inline TextViewProto() : TextViewProto(nullptr) {}
  ~TextViewProto() override;
  explicit PROTOBUF_CONSTEXPR TextViewProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TextViewProto(const TextViewProto& from);
  TextViewProto(TextViewProto&& from) noexcept
    : TextViewProto() {
    *this = ::std::move(from);
  }

  inline TextViewProto& operator=(const TextViewProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline TextViewProto& operator=(TextViewProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const TextViewProto& default_instance() {
    return *internal_default_instance();
  }
  enum KindCase {
    kText = 1,
    kModelIdentifier = 3,
    KIND_NOT_SET = 0,
  };

  static inline const TextViewProto* internal_default_instance() {
    return reinterpret_cast<const TextViewProto*>(
               &_TextViewProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(TextViewProto& a, TextViewProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(TextViewProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TextViewProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TextViewProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TextViewProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const TextViewProto& from);
  void MergeFrom(const TextViewProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TextViewProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.TextViewProto";
  }
  protected:
  explicit TextViewProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTextAppearanceFieldNumber = 2,
    kTextAlignmentFieldNumber = 4,
    kTextFieldNumber = 1,
    kModelIdentifierFieldNumber = 3,
  };
  // optional string text_appearance = 2;
  bool has_text_appearance() const;
  private:
  bool _internal_has_text_appearance() const;
  public:
  void clear_text_appearance();
  const std::string& text_appearance() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_text_appearance(ArgT0&& arg0, ArgT... args);
  std::string* mutable_text_appearance();
  PROTOBUF_NODISCARD std::string* release_text_appearance();
  void set_allocated_text_appearance(std::string* text_appearance);
  private:
  const std::string& _internal_text_appearance() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_text_appearance(const std::string& value);
  std::string* _internal_mutable_text_appearance();
  public:

  // optional int32 text_alignment = 4 [default = 8388659];
  bool has_text_alignment() const;
  private:
  bool _internal_has_text_alignment() const;
  public:
  void clear_text_alignment();
  int32_t text_alignment() const;
  void set_text_alignment(int32_t value);
  private:
  int32_t _internal_text_alignment() const;
  void _internal_set_text_alignment(int32_t value);
  public:

  // string text = 1;
  bool has_text() const;
  private:
  bool _internal_has_text() const;
  public:
  void clear_text();
  const std::string& text() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_text(ArgT0&& arg0, ArgT... args);
  std::string* mutable_text();
  PROTOBUF_NODISCARD std::string* release_text();
  void set_allocated_text(std::string* text);
  private:
  const std::string& _internal_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_text(const std::string& value);
  std::string* _internal_mutable_text();
  public:

  // string model_identifier = 3;
  bool has_model_identifier() const;
  private:
  bool _internal_has_model_identifier() const;
  public:
  void clear_model_identifier();
  const std::string& model_identifier() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_model_identifier(ArgT0&& arg0, ArgT... args);
  std::string* mutable_model_identifier();
  PROTOBUF_NODISCARD std::string* release_model_identifier();
  void set_allocated_model_identifier(std::string* model_identifier);
  private:
  const std::string& _internal_model_identifier() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_model_identifier(const std::string& value);
  std::string* _internal_mutable_model_identifier();
  public:

  void clear_kind();
  KindCase kind_case() const;
  // @@protoc_insertion_point(class_scope:autofill_assistant.TextViewProto)
 private:
  class _Internal;
  void set_has_text();
  void set_has_model_identifier();

  inline bool has_kind() const;
  inline void clear_has_kind();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_appearance_;
  int32_t text_alignment_;
  union KindUnion {
    constexpr KindUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr model_identifier_;
  } kind_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fview_5flayout_2eproto;
};
// -------------------------------------------------------------------

class DividerViewProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.DividerViewProto) */ {
 public:
  inline DividerViewProto() : DividerViewProto(nullptr) {}
  ~DividerViewProto() override;
  explicit PROTOBUF_CONSTEXPR DividerViewProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DividerViewProto(const DividerViewProto& from);
  DividerViewProto(DividerViewProto&& from) noexcept
    : DividerViewProto() {
    *this = ::std::move(from);
  }

  inline DividerViewProto& operator=(const DividerViewProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline DividerViewProto& operator=(DividerViewProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DividerViewProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const DividerViewProto* internal_default_instance() {
    return reinterpret_cast<const DividerViewProto*>(
               &_DividerViewProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(DividerViewProto& a, DividerViewProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(DividerViewProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DividerViewProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DividerViewProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DividerViewProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DividerViewProto& from);
  void MergeFrom(const DividerViewProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DividerViewProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.DividerViewProto";
  }
  protected:
  explicit DividerViewProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:autofill_assistant.DividerViewProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fview_5flayout_2eproto;
};
// -------------------------------------------------------------------

class ImageViewProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.ImageViewProto) */ {
 public:
  inline ImageViewProto() : ImageViewProto(nullptr) {}
  ~ImageViewProto() override;
  explicit PROTOBUF_CONSTEXPR ImageViewProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ImageViewProto(const ImageViewProto& from);
  ImageViewProto(ImageViewProto&& from) noexcept
    : ImageViewProto() {
    *this = ::std::move(from);
  }

  inline ImageViewProto& operator=(const ImageViewProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline ImageViewProto& operator=(ImageViewProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ImageViewProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const ImageViewProto* internal_default_instance() {
    return reinterpret_cast<const ImageViewProto*>(
               &_ImageViewProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(ImageViewProto& a, ImageViewProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(ImageViewProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ImageViewProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ImageViewProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ImageViewProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ImageViewProto& from);
  void MergeFrom(const ImageViewProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ImageViewProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.ImageViewProto";
  }
  protected:
  explicit ImageViewProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kImageFieldNumber = 1,
  };
  // optional .autofill_assistant.DrawableProto image = 1;
  bool has_image() const;
  private:
  bool _internal_has_image() const;
  public:
  void clear_image();
  const ::autofill_assistant::DrawableProto& image() const;
  PROTOBUF_NODISCARD ::autofill_assistant::DrawableProto* release_image();
  ::autofill_assistant::DrawableProto* mutable_image();
  void set_allocated_image(::autofill_assistant::DrawableProto* image);
  private:
  const ::autofill_assistant::DrawableProto& _internal_image() const;
  ::autofill_assistant::DrawableProto* _internal_mutable_image();
  public:
  void unsafe_arena_set_allocated_image(
      ::autofill_assistant::DrawableProto* image);
  ::autofill_assistant::DrawableProto* unsafe_arena_release_image();

  // @@protoc_insertion_point(class_scope:autofill_assistant.ImageViewProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::autofill_assistant::DrawableProto* image_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fview_5flayout_2eproto;
};
// -------------------------------------------------------------------

class TextInputViewProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.TextInputViewProto) */ {
 public:
  inline TextInputViewProto() : TextInputViewProto(nullptr) {}
  ~TextInputViewProto() override;
  explicit PROTOBUF_CONSTEXPR TextInputViewProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TextInputViewProto(const TextInputViewProto& from);
  TextInputViewProto(TextInputViewProto&& from) noexcept
    : TextInputViewProto() {
    *this = ::std::move(from);
  }

  inline TextInputViewProto& operator=(const TextInputViewProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline TextInputViewProto& operator=(TextInputViewProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const TextInputViewProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const TextInputViewProto* internal_default_instance() {
    return reinterpret_cast<const TextInputViewProto*>(
               &_TextInputViewProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(TextInputViewProto& a, TextInputViewProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(TextInputViewProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TextInputViewProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TextInputViewProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TextInputViewProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const TextInputViewProto& from);
  void MergeFrom(const TextInputViewProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TextInputViewProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.TextInputViewProto";
  }
  protected:
  explicit TextInputViewProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef TextInputViewProto_InputTypeHint InputTypeHint;
  static constexpr InputTypeHint NONE =
    TextInputViewProto_InputTypeHint_NONE;
  static constexpr InputTypeHint PHONE =
    TextInputViewProto_InputTypeHint_PHONE;
  static constexpr InputTypeHint EMAIL =
    TextInputViewProto_InputTypeHint_EMAIL;
  static constexpr InputTypeHint STREET_LINES =
    TextInputViewProto_InputTypeHint_STREET_LINES;
  static constexpr InputTypeHint PERSON_NAME =
    TextInputViewProto_InputTypeHint_PERSON_NAME;
  static constexpr InputTypeHint REGION =
    TextInputViewProto_InputTypeHint_REGION;
  static constexpr InputTypeHint ALPHA_NUMERIC =
    TextInputViewProto_InputTypeHint_ALPHA_NUMERIC;
  static constexpr InputTypeHint CREDIT_CARD =
    TextInputViewProto_InputTypeHint_CREDIT_CARD;
  static constexpr InputTypeHint NUMERIC =
    TextInputViewProto_InputTypeHint_NUMERIC;
  static inline bool InputTypeHint_IsValid(int value) {
    return TextInputViewProto_InputTypeHint_IsValid(value);
  }
  static constexpr InputTypeHint InputTypeHint_MIN =
    TextInputViewProto_InputTypeHint_InputTypeHint_MIN;
  static constexpr InputTypeHint InputTypeHint_MAX =
    TextInputViewProto_InputTypeHint_InputTypeHint_MAX;
  static constexpr int InputTypeHint_ARRAYSIZE =
    TextInputViewProto_InputTypeHint_InputTypeHint_ARRAYSIZE;
  template<typename T>
  static inline const std::string& InputTypeHint_Name(T enum_t_value) {
    static_assert(::std::is_same<T, InputTypeHint>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function InputTypeHint_Name.");
    return TextInputViewProto_InputTypeHint_Name(enum_t_value);
  }
  static inline bool InputTypeHint_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      InputTypeHint* value) {
    return TextInputViewProto_InputTypeHint_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kHintFieldNumber = 1,
    kModelIdentifierFieldNumber = 3,
    kTypeFieldNumber = 2,
    kFocusAndShowKeyboardFieldNumber = 4,
  };
  // optional string hint = 1;
  bool has_hint() const;
  private:
  bool _internal_has_hint() const;
  public:
  void clear_hint();
  const std::string& hint() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_hint(ArgT0&& arg0, ArgT... args);
  std::string* mutable_hint();
  PROTOBUF_NODISCARD std::string* release_hint();
  void set_allocated_hint(std::string* hint);
  private:
  const std::string& _internal_hint() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hint(const std::string& value);
  std::string* _internal_mutable_hint();
  public:

  // optional string model_identifier = 3;
  bool has_model_identifier() const;
  private:
  bool _internal_has_model_identifier() const;
  public:
  void clear_model_identifier();
  const std::string& model_identifier() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_model_identifier(ArgT0&& arg0, ArgT... args);
  std::string* mutable_model_identifier();
  PROTOBUF_NODISCARD std::string* release_model_identifier();
  void set_allocated_model_identifier(std::string* model_identifier);
  private:
  const std::string& _internal_model_identifier() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_model_identifier(const std::string& value);
  std::string* _internal_mutable_model_identifier();
  public:

  // optional .autofill_assistant.TextInputViewProto.InputTypeHint type = 2;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::autofill_assistant::TextInputViewProto_InputTypeHint type() const;
  void set_type(::autofill_assistant::TextInputViewProto_InputTypeHint value);
  private:
  ::autofill_assistant::TextInputViewProto_InputTypeHint _internal_type() const;
  void _internal_set_type(::autofill_assistant::TextInputViewProto_InputTypeHint value);
  public:

  // optional bool focus_and_show_keyboard = 4;
  bool has_focus_and_show_keyboard() const;
  private:
  bool _internal_has_focus_and_show_keyboard() const;
  public:
  void clear_focus_and_show_keyboard();
  bool focus_and_show_keyboard() const;
  void set_focus_and_show_keyboard(bool value);
  private:
  bool _internal_focus_and_show_keyboard() const;
  void _internal_set_focus_and_show_keyboard(bool value);
  public:

  // @@protoc_insertion_point(class_scope:autofill_assistant.TextInputViewProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hint_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr model_identifier_;
  int type_;
  bool focus_and_show_keyboard_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fview_5flayout_2eproto;
};
// -------------------------------------------------------------------

class InfoPopupProto_DialogButton_CloseDialog final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.InfoPopupProto.DialogButton.CloseDialog) */ {
 public:
  inline InfoPopupProto_DialogButton_CloseDialog() : InfoPopupProto_DialogButton_CloseDialog(nullptr) {}
  ~InfoPopupProto_DialogButton_CloseDialog() override;
  explicit PROTOBUF_CONSTEXPR InfoPopupProto_DialogButton_CloseDialog(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InfoPopupProto_DialogButton_CloseDialog(const InfoPopupProto_DialogButton_CloseDialog& from);
  InfoPopupProto_DialogButton_CloseDialog(InfoPopupProto_DialogButton_CloseDialog&& from) noexcept
    : InfoPopupProto_DialogButton_CloseDialog() {
    *this = ::std::move(from);
  }

  inline InfoPopupProto_DialogButton_CloseDialog& operator=(const InfoPopupProto_DialogButton_CloseDialog& from) {
    CopyFrom(from);
    return *this;
  }
  inline InfoPopupProto_DialogButton_CloseDialog& operator=(InfoPopupProto_DialogButton_CloseDialog&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const InfoPopupProto_DialogButton_CloseDialog& default_instance() {
    return *internal_default_instance();
  }
  static inline const InfoPopupProto_DialogButton_CloseDialog* internal_default_instance() {
    return reinterpret_cast<const InfoPopupProto_DialogButton_CloseDialog*>(
               &_InfoPopupProto_DialogButton_CloseDialog_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(InfoPopupProto_DialogButton_CloseDialog& a, InfoPopupProto_DialogButton_CloseDialog& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(InfoPopupProto_DialogButton_CloseDialog* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InfoPopupProto_DialogButton_CloseDialog* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InfoPopupProto_DialogButton_CloseDialog* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InfoPopupProto_DialogButton_CloseDialog>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const InfoPopupProto_DialogButton_CloseDialog& from);
  void MergeFrom(const InfoPopupProto_DialogButton_CloseDialog& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(InfoPopupProto_DialogButton_CloseDialog* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.InfoPopupProto.DialogButton.CloseDialog";
  }
  protected:
  explicit InfoPopupProto_DialogButton_CloseDialog(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:autofill_assistant.InfoPopupProto.DialogButton.CloseDialog)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fview_5flayout_2eproto;
};
// -------------------------------------------------------------------

class InfoPopupProto_DialogButton_OpenUrlInCCT final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.InfoPopupProto.DialogButton.OpenUrlInCCT) */ {
 public:
  inline InfoPopupProto_DialogButton_OpenUrlInCCT() : InfoPopupProto_DialogButton_OpenUrlInCCT(nullptr) {}
  ~InfoPopupProto_DialogButton_OpenUrlInCCT() override;
  explicit PROTOBUF_CONSTEXPR InfoPopupProto_DialogButton_OpenUrlInCCT(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InfoPopupProto_DialogButton_OpenUrlInCCT(const InfoPopupProto_DialogButton_OpenUrlInCCT& from);
  InfoPopupProto_DialogButton_OpenUrlInCCT(InfoPopupProto_DialogButton_OpenUrlInCCT&& from) noexcept
    : InfoPopupProto_DialogButton_OpenUrlInCCT() {
    *this = ::std::move(from);
  }

  inline InfoPopupProto_DialogButton_OpenUrlInCCT& operator=(const InfoPopupProto_DialogButton_OpenUrlInCCT& from) {
    CopyFrom(from);
    return *this;
  }
  inline InfoPopupProto_DialogButton_OpenUrlInCCT& operator=(InfoPopupProto_DialogButton_OpenUrlInCCT&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const InfoPopupProto_DialogButton_OpenUrlInCCT& default_instance() {
    return *internal_default_instance();
  }
  static inline const InfoPopupProto_DialogButton_OpenUrlInCCT* internal_default_instance() {
    return reinterpret_cast<const InfoPopupProto_DialogButton_OpenUrlInCCT*>(
               &_InfoPopupProto_DialogButton_OpenUrlInCCT_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(InfoPopupProto_DialogButton_OpenUrlInCCT& a, InfoPopupProto_DialogButton_OpenUrlInCCT& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(InfoPopupProto_DialogButton_OpenUrlInCCT* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InfoPopupProto_DialogButton_OpenUrlInCCT* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InfoPopupProto_DialogButton_OpenUrlInCCT* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InfoPopupProto_DialogButton_OpenUrlInCCT>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const InfoPopupProto_DialogButton_OpenUrlInCCT& from);
  void MergeFrom(const InfoPopupProto_DialogButton_OpenUrlInCCT& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(InfoPopupProto_DialogButton_OpenUrlInCCT* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.InfoPopupProto.DialogButton.OpenUrlInCCT";
  }
  protected:
  explicit InfoPopupProto_DialogButton_OpenUrlInCCT(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUrlFieldNumber = 1,
  };
  // optional string url = 1;
  bool has_url() const;
  private:
  bool _internal_has_url() const;
  public:
  void clear_url();
  const std::string& url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_url();
  PROTOBUF_NODISCARD std::string* release_url();
  void set_allocated_url(std::string* url);
  private:
  const std::string& _internal_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_url(const std::string& value);
  std::string* _internal_mutable_url();
  public:

  // @@protoc_insertion_point(class_scope:autofill_assistant.InfoPopupProto.DialogButton.OpenUrlInCCT)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr url_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fview_5flayout_2eproto;
};
// -------------------------------------------------------------------

class InfoPopupProto_DialogButton final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.InfoPopupProto.DialogButton) */ {
 public:
  inline InfoPopupProto_DialogButton() : InfoPopupProto_DialogButton(nullptr) {}
  ~InfoPopupProto_DialogButton() override;
  explicit PROTOBUF_CONSTEXPR InfoPopupProto_DialogButton(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InfoPopupProto_DialogButton(const InfoPopupProto_DialogButton& from);
  InfoPopupProto_DialogButton(InfoPopupProto_DialogButton&& from) noexcept
    : InfoPopupProto_DialogButton() {
    *this = ::std::move(from);
  }

  inline InfoPopupProto_DialogButton& operator=(const InfoPopupProto_DialogButton& from) {
    CopyFrom(from);
    return *this;
  }
  inline InfoPopupProto_DialogButton& operator=(InfoPopupProto_DialogButton&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const InfoPopupProto_DialogButton& default_instance() {
    return *internal_default_instance();
  }
  enum ClickActionCase {
    kCloseDialog = 4,
    kOpenUrlInCct = 5,
    CLICK_ACTION_NOT_SET = 0,
  };

  static inline const InfoPopupProto_DialogButton* internal_default_instance() {
    return reinterpret_cast<const InfoPopupProto_DialogButton*>(
               &_InfoPopupProto_DialogButton_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(InfoPopupProto_DialogButton& a, InfoPopupProto_DialogButton& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(InfoPopupProto_DialogButton* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InfoPopupProto_DialogButton* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InfoPopupProto_DialogButton* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InfoPopupProto_DialogButton>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const InfoPopupProto_DialogButton& from);
  void MergeFrom(const InfoPopupProto_DialogButton& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(InfoPopupProto_DialogButton* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.InfoPopupProto.DialogButton";
  }
  protected:
  explicit InfoPopupProto_DialogButton(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef InfoPopupProto_DialogButton_CloseDialog CloseDialog;
  typedef InfoPopupProto_DialogButton_OpenUrlInCCT OpenUrlInCCT;

  // accessors -------------------------------------------------------

  enum : int {
    kLabelFieldNumber = 1,
    kCloseDialogFieldNumber = 4,
    kOpenUrlInCctFieldNumber = 5,
  };
  // optional string label = 1;
  bool has_label() const;
  private:
  bool _internal_has_label() const;
  public:
  void clear_label();
  const std::string& label() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_label(ArgT0&& arg0, ArgT... args);
  std::string* mutable_label();
  PROTOBUF_NODISCARD std::string* release_label();
  void set_allocated_label(std::string* label);
  private:
  const std::string& _internal_label() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_label(const std::string& value);
  std::string* _internal_mutable_label();
  public:

  // .autofill_assistant.InfoPopupProto.DialogButton.CloseDialog close_dialog = 4;
  bool has_close_dialog() const;
  private:
  bool _internal_has_close_dialog() const;
  public:
  void clear_close_dialog();
  const ::autofill_assistant::InfoPopupProto_DialogButton_CloseDialog& close_dialog() const;
  PROTOBUF_NODISCARD ::autofill_assistant::InfoPopupProto_DialogButton_CloseDialog* release_close_dialog();
  ::autofill_assistant::InfoPopupProto_DialogButton_CloseDialog* mutable_close_dialog();
  void set_allocated_close_dialog(::autofill_assistant::InfoPopupProto_DialogButton_CloseDialog* close_dialog);
  private:
  const ::autofill_assistant::InfoPopupProto_DialogButton_CloseDialog& _internal_close_dialog() const;
  ::autofill_assistant::InfoPopupProto_DialogButton_CloseDialog* _internal_mutable_close_dialog();
  public:
  void unsafe_arena_set_allocated_close_dialog(
      ::autofill_assistant::InfoPopupProto_DialogButton_CloseDialog* close_dialog);
  ::autofill_assistant::InfoPopupProto_DialogButton_CloseDialog* unsafe_arena_release_close_dialog();

  // .autofill_assistant.InfoPopupProto.DialogButton.OpenUrlInCCT open_url_in_cct = 5;
  bool has_open_url_in_cct() const;
  private:
  bool _internal_has_open_url_in_cct() const;
  public:
  void clear_open_url_in_cct();
  const ::autofill_assistant::InfoPopupProto_DialogButton_OpenUrlInCCT& open_url_in_cct() const;
  PROTOBUF_NODISCARD ::autofill_assistant::InfoPopupProto_DialogButton_OpenUrlInCCT* release_open_url_in_cct();
  ::autofill_assistant::InfoPopupProto_DialogButton_OpenUrlInCCT* mutable_open_url_in_cct();
  void set_allocated_open_url_in_cct(::autofill_assistant::InfoPopupProto_DialogButton_OpenUrlInCCT* open_url_in_cct);
  private:
  const ::autofill_assistant::InfoPopupProto_DialogButton_OpenUrlInCCT& _internal_open_url_in_cct() const;
  ::autofill_assistant::InfoPopupProto_DialogButton_OpenUrlInCCT* _internal_mutable_open_url_in_cct();
  public:
  void unsafe_arena_set_allocated_open_url_in_cct(
      ::autofill_assistant::InfoPopupProto_DialogButton_OpenUrlInCCT* open_url_in_cct);
  ::autofill_assistant::InfoPopupProto_DialogButton_OpenUrlInCCT* unsafe_arena_release_open_url_in_cct();

  void clear_click_action();
  ClickActionCase click_action_case() const;
  // @@protoc_insertion_point(class_scope:autofill_assistant.InfoPopupProto.DialogButton)
 private:
  class _Internal;
  void set_has_close_dialog();
  void set_has_open_url_in_cct();

  inline bool has_click_action() const;
  inline void clear_has_click_action();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr label_;
  union ClickActionUnion {
    constexpr ClickActionUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::autofill_assistant::InfoPopupProto_DialogButton_CloseDialog* close_dialog_;
    ::autofill_assistant::InfoPopupProto_DialogButton_OpenUrlInCCT* open_url_in_cct_;
  } click_action_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fview_5flayout_2eproto;
};
// -------------------------------------------------------------------

class InfoPopupProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.InfoPopupProto) */ {
 public:
  inline InfoPopupProto() : InfoPopupProto(nullptr) {}
  ~InfoPopupProto() override;
  explicit PROTOBUF_CONSTEXPR InfoPopupProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InfoPopupProto(const InfoPopupProto& from);
  InfoPopupProto(InfoPopupProto&& from) noexcept
    : InfoPopupProto() {
    *this = ::std::move(from);
  }

  inline InfoPopupProto& operator=(const InfoPopupProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline InfoPopupProto& operator=(InfoPopupProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const InfoPopupProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const InfoPopupProto* internal_default_instance() {
    return reinterpret_cast<const InfoPopupProto*>(
               &_InfoPopupProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(InfoPopupProto& a, InfoPopupProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(InfoPopupProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InfoPopupProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InfoPopupProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InfoPopupProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const InfoPopupProto& from);
  void MergeFrom(const InfoPopupProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(InfoPopupProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.InfoPopupProto";
  }
  protected:
  explicit InfoPopupProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef InfoPopupProto_DialogButton DialogButton;

  // accessors -------------------------------------------------------

  enum : int {
    kTitleFieldNumber = 1,
    kTextFieldNumber = 2,
    kPositiveButtonFieldNumber = 3,
    kNegativeButtonFieldNumber = 4,
    kNeutralButtonFieldNumber = 5,
  };
  // optional string title = 1;
  bool has_title() const;
  private:
  bool _internal_has_title() const;
  public:
  void clear_title();
  const std::string& title() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_title(ArgT0&& arg0, ArgT... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* title);
  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(const std::string& value);
  std::string* _internal_mutable_title();
  public:

  // optional string text = 2;
  bool has_text() const;
  private:
  bool _internal_has_text() const;
  public:
  void clear_text();
  const std::string& text() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_text(ArgT0&& arg0, ArgT... args);
  std::string* mutable_text();
  PROTOBUF_NODISCARD std::string* release_text();
  void set_allocated_text(std::string* text);
  private:
  const std::string& _internal_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_text(const std::string& value);
  std::string* _internal_mutable_text();
  public:

  // optional .autofill_assistant.InfoPopupProto.DialogButton positive_button = 3;
  bool has_positive_button() const;
  private:
  bool _internal_has_positive_button() const;
  public:
  void clear_positive_button();
  const ::autofill_assistant::InfoPopupProto_DialogButton& positive_button() const;
  PROTOBUF_NODISCARD ::autofill_assistant::InfoPopupProto_DialogButton* release_positive_button();
  ::autofill_assistant::InfoPopupProto_DialogButton* mutable_positive_button();
  void set_allocated_positive_button(::autofill_assistant::InfoPopupProto_DialogButton* positive_button);
  private:
  const ::autofill_assistant::InfoPopupProto_DialogButton& _internal_positive_button() const;
  ::autofill_assistant::InfoPopupProto_DialogButton* _internal_mutable_positive_button();
  public:
  void unsafe_arena_set_allocated_positive_button(
      ::autofill_assistant::InfoPopupProto_DialogButton* positive_button);
  ::autofill_assistant::InfoPopupProto_DialogButton* unsafe_arena_release_positive_button();

  // optional .autofill_assistant.InfoPopupProto.DialogButton negative_button = 4;
  bool has_negative_button() const;
  private:
  bool _internal_has_negative_button() const;
  public:
  void clear_negative_button();
  const ::autofill_assistant::InfoPopupProto_DialogButton& negative_button() const;
  PROTOBUF_NODISCARD ::autofill_assistant::InfoPopupProto_DialogButton* release_negative_button();
  ::autofill_assistant::InfoPopupProto_DialogButton* mutable_negative_button();
  void set_allocated_negative_button(::autofill_assistant::InfoPopupProto_DialogButton* negative_button);
  private:
  const ::autofill_assistant::InfoPopupProto_DialogButton& _internal_negative_button() const;
  ::autofill_assistant::InfoPopupProto_DialogButton* _internal_mutable_negative_button();
  public:
  void unsafe_arena_set_allocated_negative_button(
      ::autofill_assistant::InfoPopupProto_DialogButton* negative_button);
  ::autofill_assistant::InfoPopupProto_DialogButton* unsafe_arena_release_negative_button();

  // optional .autofill_assistant.InfoPopupProto.DialogButton neutral_button = 5;
  bool has_neutral_button() const;
  private:
  bool _internal_has_neutral_button() const;
  public:
  void clear_neutral_button();
  const ::autofill_assistant::InfoPopupProto_DialogButton& neutral_button() const;
  PROTOBUF_NODISCARD ::autofill_assistant::InfoPopupProto_DialogButton* release_neutral_button();
  ::autofill_assistant::InfoPopupProto_DialogButton* mutable_neutral_button();
  void set_allocated_neutral_button(::autofill_assistant::InfoPopupProto_DialogButton* neutral_button);
  private:
  const ::autofill_assistant::InfoPopupProto_DialogButton& _internal_neutral_button() const;
  ::autofill_assistant::InfoPopupProto_DialogButton* _internal_mutable_neutral_button();
  public:
  void unsafe_arena_set_allocated_neutral_button(
      ::autofill_assistant::InfoPopupProto_DialogButton* neutral_button);
  ::autofill_assistant::InfoPopupProto_DialogButton* unsafe_arena_release_neutral_button();

  // @@protoc_insertion_point(class_scope:autofill_assistant.InfoPopupProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_;
  ::autofill_assistant::InfoPopupProto_DialogButton* positive_button_;
  ::autofill_assistant::InfoPopupProto_DialogButton* negative_button_;
  ::autofill_assistant::InfoPopupProto_DialogButton* neutral_button_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fview_5flayout_2eproto;
};
// -------------------------------------------------------------------

class ToggleButtonViewProto_CheckBox final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.ToggleButtonViewProto.CheckBox) */ {
 public:
  inline ToggleButtonViewProto_CheckBox() : ToggleButtonViewProto_CheckBox(nullptr) {}
  ~ToggleButtonViewProto_CheckBox() override;
  explicit PROTOBUF_CONSTEXPR ToggleButtonViewProto_CheckBox(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ToggleButtonViewProto_CheckBox(const ToggleButtonViewProto_CheckBox& from);
  ToggleButtonViewProto_CheckBox(ToggleButtonViewProto_CheckBox&& from) noexcept
    : ToggleButtonViewProto_CheckBox() {
    *this = ::std::move(from);
  }

  inline ToggleButtonViewProto_CheckBox& operator=(const ToggleButtonViewProto_CheckBox& from) {
    CopyFrom(from);
    return *this;
  }
  inline ToggleButtonViewProto_CheckBox& operator=(ToggleButtonViewProto_CheckBox&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ToggleButtonViewProto_CheckBox& default_instance() {
    return *internal_default_instance();
  }
  static inline const ToggleButtonViewProto_CheckBox* internal_default_instance() {
    return reinterpret_cast<const ToggleButtonViewProto_CheckBox*>(
               &_ToggleButtonViewProto_CheckBox_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(ToggleButtonViewProto_CheckBox& a, ToggleButtonViewProto_CheckBox& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(ToggleButtonViewProto_CheckBox* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ToggleButtonViewProto_CheckBox* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ToggleButtonViewProto_CheckBox* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ToggleButtonViewProto_CheckBox>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ToggleButtonViewProto_CheckBox& from);
  void MergeFrom(const ToggleButtonViewProto_CheckBox& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ToggleButtonViewProto_CheckBox* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.ToggleButtonViewProto.CheckBox";
  }
  protected:
  explicit ToggleButtonViewProto_CheckBox(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:autofill_assistant.ToggleButtonViewProto.CheckBox)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fview_5flayout_2eproto;
};
// -------------------------------------------------------------------

class ToggleButtonViewProto_RadioButton final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.ToggleButtonViewProto.RadioButton) */ {
 public:
  inline ToggleButtonViewProto_RadioButton() : ToggleButtonViewProto_RadioButton(nullptr) {}
  ~ToggleButtonViewProto_RadioButton() override;
  explicit PROTOBUF_CONSTEXPR ToggleButtonViewProto_RadioButton(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ToggleButtonViewProto_RadioButton(const ToggleButtonViewProto_RadioButton& from);
  ToggleButtonViewProto_RadioButton(ToggleButtonViewProto_RadioButton&& from) noexcept
    : ToggleButtonViewProto_RadioButton() {
    *this = ::std::move(from);
  }

  inline ToggleButtonViewProto_RadioButton& operator=(const ToggleButtonViewProto_RadioButton& from) {
    CopyFrom(from);
    return *this;
  }
  inline ToggleButtonViewProto_RadioButton& operator=(ToggleButtonViewProto_RadioButton&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ToggleButtonViewProto_RadioButton& default_instance() {
    return *internal_default_instance();
  }
  static inline const ToggleButtonViewProto_RadioButton* internal_default_instance() {
    return reinterpret_cast<const ToggleButtonViewProto_RadioButton*>(
               &_ToggleButtonViewProto_RadioButton_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(ToggleButtonViewProto_RadioButton& a, ToggleButtonViewProto_RadioButton& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(ToggleButtonViewProto_RadioButton* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ToggleButtonViewProto_RadioButton* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ToggleButtonViewProto_RadioButton* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ToggleButtonViewProto_RadioButton>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ToggleButtonViewProto_RadioButton& from);
  void MergeFrom(const ToggleButtonViewProto_RadioButton& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ToggleButtonViewProto_RadioButton* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.ToggleButtonViewProto.RadioButton";
  }
  protected:
  explicit ToggleButtonViewProto_RadioButton(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRadioGroupIdentifierFieldNumber = 1,
  };
  // optional string radio_group_identifier = 1;
  bool has_radio_group_identifier() const;
  private:
  bool _internal_has_radio_group_identifier() const;
  public:
  void clear_radio_group_identifier();
  const std::string& radio_group_identifier() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_radio_group_identifier(ArgT0&& arg0, ArgT... args);
  std::string* mutable_radio_group_identifier();
  PROTOBUF_NODISCARD std::string* release_radio_group_identifier();
  void set_allocated_radio_group_identifier(std::string* radio_group_identifier);
  private:
  const std::string& _internal_radio_group_identifier() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_radio_group_identifier(const std::string& value);
  std::string* _internal_mutable_radio_group_identifier();
  public:

  // @@protoc_insertion_point(class_scope:autofill_assistant.ToggleButtonViewProto.RadioButton)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr radio_group_identifier_;
  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fview_5flayout_2eproto;
};
// -------------------------------------------------------------------

class ToggleButtonViewProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill_assistant.ToggleButtonViewProto) */ {
 public:
  inline ToggleButtonViewProto() : ToggleButtonViewProto(nullptr) {}
  ~ToggleButtonViewProto() override;
  explicit PROTOBUF_CONSTEXPR ToggleButtonViewProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ToggleButtonViewProto(const ToggleButtonViewProto& from);
  ToggleButtonViewProto(ToggleButtonViewProto&& from) noexcept
    : ToggleButtonViewProto() {
    *this = ::std::move(from);
  }

  inline ToggleButtonViewProto& operator=(const ToggleButtonViewProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline ToggleButtonViewProto& operator=(ToggleButtonViewProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ToggleButtonViewProto& default_instance() {
    return *internal_default_instance();
  }
  enum KindCase {
    kCheckBox = 1,
    kRadioButton = 2,
    KIND_NOT_SET = 0,
  };

  static inline const ToggleButtonViewProto* internal_default_instance() {
    return reinterpret_cast<const ToggleButtonViewProto*>(
               &_ToggleButtonViewProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(ToggleButtonViewProto& a, ToggleButtonViewProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(ToggleButtonViewProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ToggleButtonViewProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ToggleButtonViewProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ToggleButtonViewProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ToggleButtonViewProto& from);
  void MergeFrom(const ToggleButtonViewProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ToggleButtonViewProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill_assistant.ToggleButtonViewProto";
  }
  protected:
  explicit ToggleButtonViewProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef ToggleButtonViewProto_CheckBox CheckBox;
  typedef ToggleButtonViewProto_RadioButton RadioButton;

  // accessors -------------------------------------------------------

  enum : int {
    kModelIdentifierFieldNumber = 5,
    kLeftContentViewFieldNumber = 3,
    kRightContentViewFieldNumber = 4,
    kCheckBoxFieldNumber = 1,
    kRadioButtonFieldNumber = 2,
  };
  // optional string model_identifier = 5;
  bool has_model_identifier() const;
  private:
  bool _internal_has_model_identifier() const;
  public:
  void clear_model_identifier();
  const std::string& model_identifier() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_model_identifier(ArgT0&& arg0, ArgT... args);
  std::string* mutable_model_identifier();
  PROTOBUF_NODISCARD std::string* release_model_identifier();
  void set_allocated_model_identifier(std::string* model_identifier);
  private:
  const std::string& _internal_model_identifier() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_model_identifier(const std::string& value);
  std::string* _internal_mutable_model_identifier();
  public:

  // optional .autofill_assistant.ViewProto left_content_view = 3;
  bool has_left_content_view() const;
  private:
  bool _internal_has_left_content_view() const;
  public:
  void clear_left_content_view();
  const ::autofill_assistant::ViewProto& left_content_view() const;
  PROTOBUF_NODISCARD ::autofill_assistant::ViewProto* release_left_content_view();
  ::autofill_assistant::ViewProto* mutable_left_content_view();
  void set_allocated_left_content_view(::autofill_assistant::ViewProto* left_content_view);
  private:
  const ::autofill_assistant::ViewProto& _internal_left_content_view() const;
  ::autofill_assistant::ViewProto* _internal_mutable_left_content_view();
  public:
  void unsafe_arena_set_allocated_left_content_view(
      ::autofill_assistant::ViewProto* left_content_view);
  ::autofill_assistant::ViewProto* unsafe_arena_release_left_content_view();

  // optional .autofill_assistant.ViewProto right_content_view = 4;
  bool has_right_content_view() const;
  private:
  bool _internal_has_right_content_view() const;
  public:
  void clear_right_content_view();
  const ::autofill_assistant::ViewProto& right_content_view() const;
  PROTOBUF_NODISCARD ::autofill_assistant::ViewProto* release_right_content_view();
  ::autofill_assistant::ViewProto* mutable_right_content_view();
  void set_allocated_right_content_view(::autofill_assistant::ViewProto* right_content_view);
  private:
  const ::autofill_assistant::ViewProto& _internal_right_content_view() const;
  ::autofill_assistant::ViewProto* _internal_mutable_right_content_view();
  public:
  void unsafe_arena_set_allocated_right_content_view(
      ::autofill_assistant::ViewProto* right_content_view);
  ::autofill_assistant::ViewProto* unsafe_arena_release_right_content_view();

  // .autofill_assistant.ToggleButtonViewProto.CheckBox check_box = 1;
  bool has_check_box() const;
  private:
  bool _internal_has_check_box() const;
  public:
  void clear_check_box();
  const ::autofill_assistant::ToggleButtonViewProto_CheckBox& check_box() const;
  PROTOBUF_NODISCARD ::autofill_assistant::ToggleButtonViewProto_CheckBox* release_check_box();
  ::autofill_assistant::ToggleButtonViewProto_CheckBox* mutable_check_box();
  void set_allocated_check_box(::autofill_assistant::ToggleButtonViewProto_CheckBox* check_box);
  private:
  const ::autofill_assistant::ToggleButtonViewProto_CheckBox& _internal_check_box() const;
  ::autofill_assistant::ToggleButtonViewProto_CheckBox* _internal_mutable_check_box();
  public:
  void unsafe_arena_set_allocated_check_box(
      ::autofill_assistant::ToggleButtonViewProto_CheckBox* check_box);
  ::autofill_assistant::ToggleButtonViewProto_CheckBox* unsafe_arena_release_check_box();

  // .autofill_assistant.ToggleButtonViewProto.RadioButton radio_button = 2;
  bool has_radio_button() const;
  private:
  bool _internal_has_radio_button() const;
  public:
  void clear_radio_button();
  const ::autofill_assistant::ToggleButtonViewProto_RadioButton& radio_button() const;
  PROTOBUF_NODISCARD ::autofill_assistant::ToggleButtonViewProto_RadioButton* release_radio_button();
  ::autofill_assistant::ToggleButtonViewProto_RadioButton* mutable_radio_button();
  void set_allocated_radio_button(::autofill_assistant::ToggleButtonViewProto_RadioButton* radio_button);
  private:
  const ::autofill_assistant::ToggleButtonViewProto_RadioButton& _internal_radio_button() const;
  ::autofill_assistant::ToggleButtonViewProto_RadioButton* _internal_mutable_radio_button();
  public:
  void unsafe_arena_set_allocated_radio_button(
      ::autofill_assistant::ToggleButtonViewProto_RadioButton* radio_button);
  ::autofill_assistant::ToggleButtonViewProto_RadioButton* unsafe_arena_release_radio_button();

  void clear_kind();
  KindCase kind_case() const;
  // @@protoc_insertion_point(class_scope:autofill_assistant.ToggleButtonViewProto)
 private:
  class _Internal;
  void set_has_check_box();
  void set_has_radio_button();

  inline bool has_kind() const;
  inline void clear_has_kind();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr model_identifier_;
  ::autofill_assistant::ViewProto* left_content_view_;
  ::autofill_assistant::ViewProto* right_content_view_;
  union KindUnion {
    constexpr KindUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::autofill_assistant::ToggleButtonViewProto_CheckBox* check_box_;
    ::autofill_assistant::ToggleButtonViewProto_RadioButton* radio_button_;
  } kind_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_components_2fautofill_5fassistant_2fbrowser_2fview_5flayout_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ViewProto

// optional string identifier = 1;
inline bool ViewProto::_internal_has_identifier() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ViewProto::has_identifier() const {
  return _internal_has_identifier();
}
inline void ViewProto::clear_identifier() {
  identifier_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ViewProto::identifier() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ViewProto.identifier)
  return _internal_identifier();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ViewProto::set_identifier(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 identifier_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.ViewProto.identifier)
}
inline std::string* ViewProto::mutable_identifier() {
  std::string* _s = _internal_mutable_identifier();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ViewProto.identifier)
  return _s;
}
inline const std::string& ViewProto::_internal_identifier() const {
  return identifier_.Get();
}
inline void ViewProto::_internal_set_identifier(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  identifier_.Set(value, GetArenaForAllocation());
}
inline std::string* ViewProto::_internal_mutable_identifier() {
  _has_bits_[0] |= 0x00000001u;
  return identifier_.Mutable(GetArenaForAllocation());
}
inline std::string* ViewProto::release_identifier() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ViewProto.identifier)
  if (!_internal_has_identifier()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = identifier_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (identifier_.IsDefault()) {
    identifier_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ViewProto::set_allocated_identifier(std::string* identifier) {
  if (identifier != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  identifier_.SetAllocated(identifier, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (identifier_.IsDefault()) {
    identifier_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ViewProto.identifier)
}

// optional .autofill_assistant.ViewAttributesProto attributes = 2;
inline bool ViewProto::_internal_has_attributes() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || attributes_ != nullptr);
  return value;
}
inline bool ViewProto::has_attributes() const {
  return _internal_has_attributes();
}
inline void ViewProto::clear_attributes() {
  if (attributes_ != nullptr) attributes_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::autofill_assistant::ViewAttributesProto& ViewProto::_internal_attributes() const {
  const ::autofill_assistant::ViewAttributesProto* p = attributes_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::ViewAttributesProto&>(
      ::autofill_assistant::_ViewAttributesProto_default_instance_);
}
inline const ::autofill_assistant::ViewAttributesProto& ViewProto::attributes() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ViewProto.attributes)
  return _internal_attributes();
}
inline void ViewProto::unsafe_arena_set_allocated_attributes(
    ::autofill_assistant::ViewAttributesProto* attributes) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(attributes_);
  }
  attributes_ = attributes;
  if (attributes) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ViewProto.attributes)
}
inline ::autofill_assistant::ViewAttributesProto* ViewProto::release_attributes() {
  _has_bits_[0] &= ~0x00000002u;
  ::autofill_assistant::ViewAttributesProto* temp = attributes_;
  attributes_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::ViewAttributesProto* ViewProto::unsafe_arena_release_attributes() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ViewProto.attributes)
  _has_bits_[0] &= ~0x00000002u;
  ::autofill_assistant::ViewAttributesProto* temp = attributes_;
  attributes_ = nullptr;
  return temp;
}
inline ::autofill_assistant::ViewAttributesProto* ViewProto::_internal_mutable_attributes() {
  _has_bits_[0] |= 0x00000002u;
  if (attributes_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::ViewAttributesProto>(GetArenaForAllocation());
    attributes_ = p;
  }
  return attributes_;
}
inline ::autofill_assistant::ViewAttributesProto* ViewProto::mutable_attributes() {
  ::autofill_assistant::ViewAttributesProto* _msg = _internal_mutable_attributes();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ViewProto.attributes)
  return _msg;
}
inline void ViewProto::set_allocated_attributes(::autofill_assistant::ViewAttributesProto* attributes) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete attributes_;
  }
  if (attributes) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(attributes);
    if (message_arena != submessage_arena) {
      attributes = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, attributes, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  attributes_ = attributes;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ViewProto.attributes)
}

// optional .autofill_assistant.ViewLayoutParamsProto layout_params = 3;
inline bool ViewProto::_internal_has_layout_params() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || layout_params_ != nullptr);
  return value;
}
inline bool ViewProto::has_layout_params() const {
  return _internal_has_layout_params();
}
inline void ViewProto::clear_layout_params() {
  if (layout_params_ != nullptr) layout_params_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::autofill_assistant::ViewLayoutParamsProto& ViewProto::_internal_layout_params() const {
  const ::autofill_assistant::ViewLayoutParamsProto* p = layout_params_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::ViewLayoutParamsProto&>(
      ::autofill_assistant::_ViewLayoutParamsProto_default_instance_);
}
inline const ::autofill_assistant::ViewLayoutParamsProto& ViewProto::layout_params() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ViewProto.layout_params)
  return _internal_layout_params();
}
inline void ViewProto::unsafe_arena_set_allocated_layout_params(
    ::autofill_assistant::ViewLayoutParamsProto* layout_params) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(layout_params_);
  }
  layout_params_ = layout_params;
  if (layout_params) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ViewProto.layout_params)
}
inline ::autofill_assistant::ViewLayoutParamsProto* ViewProto::release_layout_params() {
  _has_bits_[0] &= ~0x00000004u;
  ::autofill_assistant::ViewLayoutParamsProto* temp = layout_params_;
  layout_params_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::ViewLayoutParamsProto* ViewProto::unsafe_arena_release_layout_params() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ViewProto.layout_params)
  _has_bits_[0] &= ~0x00000004u;
  ::autofill_assistant::ViewLayoutParamsProto* temp = layout_params_;
  layout_params_ = nullptr;
  return temp;
}
inline ::autofill_assistant::ViewLayoutParamsProto* ViewProto::_internal_mutable_layout_params() {
  _has_bits_[0] |= 0x00000004u;
  if (layout_params_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::ViewLayoutParamsProto>(GetArenaForAllocation());
    layout_params_ = p;
  }
  return layout_params_;
}
inline ::autofill_assistant::ViewLayoutParamsProto* ViewProto::mutable_layout_params() {
  ::autofill_assistant::ViewLayoutParamsProto* _msg = _internal_mutable_layout_params();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ViewProto.layout_params)
  return _msg;
}
inline void ViewProto::set_allocated_layout_params(::autofill_assistant::ViewLayoutParamsProto* layout_params) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete layout_params_;
  }
  if (layout_params) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(layout_params);
    if (message_arena != submessage_arena) {
      layout_params = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, layout_params, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  layout_params_ = layout_params;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ViewProto.layout_params)
}

// .autofill_assistant.ViewContainerProto view_container = 4;
inline bool ViewProto::_internal_has_view_container() const {
  return view_case() == kViewContainer;
}
inline bool ViewProto::has_view_container() const {
  return _internal_has_view_container();
}
inline void ViewProto::set_has_view_container() {
  _oneof_case_[0] = kViewContainer;
}
inline void ViewProto::clear_view_container() {
  if (_internal_has_view_container()) {
    if (GetArenaForAllocation() == nullptr) {
      delete view_.view_container_;
    }
    clear_has_view();
  }
}
inline ::autofill_assistant::ViewContainerProto* ViewProto::release_view_container() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ViewProto.view_container)
  if (_internal_has_view_container()) {
    clear_has_view();
    ::autofill_assistant::ViewContainerProto* temp = view_.view_container_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    view_.view_container_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::ViewContainerProto& ViewProto::_internal_view_container() const {
  return _internal_has_view_container()
      ? *view_.view_container_
      : reinterpret_cast< ::autofill_assistant::ViewContainerProto&>(::autofill_assistant::_ViewContainerProto_default_instance_);
}
inline const ::autofill_assistant::ViewContainerProto& ViewProto::view_container() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ViewProto.view_container)
  return _internal_view_container();
}
inline ::autofill_assistant::ViewContainerProto* ViewProto::unsafe_arena_release_view_container() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.ViewProto.view_container)
  if (_internal_has_view_container()) {
    clear_has_view();
    ::autofill_assistant::ViewContainerProto* temp = view_.view_container_;
    view_.view_container_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ViewProto::unsafe_arena_set_allocated_view_container(::autofill_assistant::ViewContainerProto* view_container) {
  clear_view();
  if (view_container) {
    set_has_view_container();
    view_.view_container_ = view_container;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ViewProto.view_container)
}
inline ::autofill_assistant::ViewContainerProto* ViewProto::_internal_mutable_view_container() {
  if (!_internal_has_view_container()) {
    clear_view();
    set_has_view_container();
    view_.view_container_ = CreateMaybeMessage< ::autofill_assistant::ViewContainerProto >(GetArenaForAllocation());
  }
  return view_.view_container_;
}
inline ::autofill_assistant::ViewContainerProto* ViewProto::mutable_view_container() {
  ::autofill_assistant::ViewContainerProto* _msg = _internal_mutable_view_container();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ViewProto.view_container)
  return _msg;
}

// .autofill_assistant.TextViewProto text_view = 5;
inline bool ViewProto::_internal_has_text_view() const {
  return view_case() == kTextView;
}
inline bool ViewProto::has_text_view() const {
  return _internal_has_text_view();
}
inline void ViewProto::set_has_text_view() {
  _oneof_case_[0] = kTextView;
}
inline void ViewProto::clear_text_view() {
  if (_internal_has_text_view()) {
    if (GetArenaForAllocation() == nullptr) {
      delete view_.text_view_;
    }
    clear_has_view();
  }
}
inline ::autofill_assistant::TextViewProto* ViewProto::release_text_view() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ViewProto.text_view)
  if (_internal_has_text_view()) {
    clear_has_view();
    ::autofill_assistant::TextViewProto* temp = view_.text_view_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    view_.text_view_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::TextViewProto& ViewProto::_internal_text_view() const {
  return _internal_has_text_view()
      ? *view_.text_view_
      : reinterpret_cast< ::autofill_assistant::TextViewProto&>(::autofill_assistant::_TextViewProto_default_instance_);
}
inline const ::autofill_assistant::TextViewProto& ViewProto::text_view() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ViewProto.text_view)
  return _internal_text_view();
}
inline ::autofill_assistant::TextViewProto* ViewProto::unsafe_arena_release_text_view() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.ViewProto.text_view)
  if (_internal_has_text_view()) {
    clear_has_view();
    ::autofill_assistant::TextViewProto* temp = view_.text_view_;
    view_.text_view_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ViewProto::unsafe_arena_set_allocated_text_view(::autofill_assistant::TextViewProto* text_view) {
  clear_view();
  if (text_view) {
    set_has_text_view();
    view_.text_view_ = text_view;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ViewProto.text_view)
}
inline ::autofill_assistant::TextViewProto* ViewProto::_internal_mutable_text_view() {
  if (!_internal_has_text_view()) {
    clear_view();
    set_has_text_view();
    view_.text_view_ = CreateMaybeMessage< ::autofill_assistant::TextViewProto >(GetArenaForAllocation());
  }
  return view_.text_view_;
}
inline ::autofill_assistant::TextViewProto* ViewProto::mutable_text_view() {
  ::autofill_assistant::TextViewProto* _msg = _internal_mutable_text_view();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ViewProto.text_view)
  return _msg;
}

// .autofill_assistant.DividerViewProto divider_view = 6;
inline bool ViewProto::_internal_has_divider_view() const {
  return view_case() == kDividerView;
}
inline bool ViewProto::has_divider_view() const {
  return _internal_has_divider_view();
}
inline void ViewProto::set_has_divider_view() {
  _oneof_case_[0] = kDividerView;
}
inline void ViewProto::clear_divider_view() {
  if (_internal_has_divider_view()) {
    if (GetArenaForAllocation() == nullptr) {
      delete view_.divider_view_;
    }
    clear_has_view();
  }
}
inline ::autofill_assistant::DividerViewProto* ViewProto::release_divider_view() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ViewProto.divider_view)
  if (_internal_has_divider_view()) {
    clear_has_view();
    ::autofill_assistant::DividerViewProto* temp = view_.divider_view_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    view_.divider_view_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::DividerViewProto& ViewProto::_internal_divider_view() const {
  return _internal_has_divider_view()
      ? *view_.divider_view_
      : reinterpret_cast< ::autofill_assistant::DividerViewProto&>(::autofill_assistant::_DividerViewProto_default_instance_);
}
inline const ::autofill_assistant::DividerViewProto& ViewProto::divider_view() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ViewProto.divider_view)
  return _internal_divider_view();
}
inline ::autofill_assistant::DividerViewProto* ViewProto::unsafe_arena_release_divider_view() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.ViewProto.divider_view)
  if (_internal_has_divider_view()) {
    clear_has_view();
    ::autofill_assistant::DividerViewProto* temp = view_.divider_view_;
    view_.divider_view_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ViewProto::unsafe_arena_set_allocated_divider_view(::autofill_assistant::DividerViewProto* divider_view) {
  clear_view();
  if (divider_view) {
    set_has_divider_view();
    view_.divider_view_ = divider_view;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ViewProto.divider_view)
}
inline ::autofill_assistant::DividerViewProto* ViewProto::_internal_mutable_divider_view() {
  if (!_internal_has_divider_view()) {
    clear_view();
    set_has_divider_view();
    view_.divider_view_ = CreateMaybeMessage< ::autofill_assistant::DividerViewProto >(GetArenaForAllocation());
  }
  return view_.divider_view_;
}
inline ::autofill_assistant::DividerViewProto* ViewProto::mutable_divider_view() {
  ::autofill_assistant::DividerViewProto* _msg = _internal_mutable_divider_view();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ViewProto.divider_view)
  return _msg;
}

// .autofill_assistant.ImageViewProto image_view = 7;
inline bool ViewProto::_internal_has_image_view() const {
  return view_case() == kImageView;
}
inline bool ViewProto::has_image_view() const {
  return _internal_has_image_view();
}
inline void ViewProto::set_has_image_view() {
  _oneof_case_[0] = kImageView;
}
inline void ViewProto::clear_image_view() {
  if (_internal_has_image_view()) {
    if (GetArenaForAllocation() == nullptr) {
      delete view_.image_view_;
    }
    clear_has_view();
  }
}
inline ::autofill_assistant::ImageViewProto* ViewProto::release_image_view() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ViewProto.image_view)
  if (_internal_has_image_view()) {
    clear_has_view();
    ::autofill_assistant::ImageViewProto* temp = view_.image_view_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    view_.image_view_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::ImageViewProto& ViewProto::_internal_image_view() const {
  return _internal_has_image_view()
      ? *view_.image_view_
      : reinterpret_cast< ::autofill_assistant::ImageViewProto&>(::autofill_assistant::_ImageViewProto_default_instance_);
}
inline const ::autofill_assistant::ImageViewProto& ViewProto::image_view() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ViewProto.image_view)
  return _internal_image_view();
}
inline ::autofill_assistant::ImageViewProto* ViewProto::unsafe_arena_release_image_view() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.ViewProto.image_view)
  if (_internal_has_image_view()) {
    clear_has_view();
    ::autofill_assistant::ImageViewProto* temp = view_.image_view_;
    view_.image_view_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ViewProto::unsafe_arena_set_allocated_image_view(::autofill_assistant::ImageViewProto* image_view) {
  clear_view();
  if (image_view) {
    set_has_image_view();
    view_.image_view_ = image_view;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ViewProto.image_view)
}
inline ::autofill_assistant::ImageViewProto* ViewProto::_internal_mutable_image_view() {
  if (!_internal_has_image_view()) {
    clear_view();
    set_has_image_view();
    view_.image_view_ = CreateMaybeMessage< ::autofill_assistant::ImageViewProto >(GetArenaForAllocation());
  }
  return view_.image_view_;
}
inline ::autofill_assistant::ImageViewProto* ViewProto::mutable_image_view() {
  ::autofill_assistant::ImageViewProto* _msg = _internal_mutable_image_view();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ViewProto.image_view)
  return _msg;
}

// .autofill_assistant.TextInputViewProto text_input_view = 8;
inline bool ViewProto::_internal_has_text_input_view() const {
  return view_case() == kTextInputView;
}
inline bool ViewProto::has_text_input_view() const {
  return _internal_has_text_input_view();
}
inline void ViewProto::set_has_text_input_view() {
  _oneof_case_[0] = kTextInputView;
}
inline void ViewProto::clear_text_input_view() {
  if (_internal_has_text_input_view()) {
    if (GetArenaForAllocation() == nullptr) {
      delete view_.text_input_view_;
    }
    clear_has_view();
  }
}
inline ::autofill_assistant::TextInputViewProto* ViewProto::release_text_input_view() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ViewProto.text_input_view)
  if (_internal_has_text_input_view()) {
    clear_has_view();
    ::autofill_assistant::TextInputViewProto* temp = view_.text_input_view_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    view_.text_input_view_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::TextInputViewProto& ViewProto::_internal_text_input_view() const {
  return _internal_has_text_input_view()
      ? *view_.text_input_view_
      : reinterpret_cast< ::autofill_assistant::TextInputViewProto&>(::autofill_assistant::_TextInputViewProto_default_instance_);
}
inline const ::autofill_assistant::TextInputViewProto& ViewProto::text_input_view() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ViewProto.text_input_view)
  return _internal_text_input_view();
}
inline ::autofill_assistant::TextInputViewProto* ViewProto::unsafe_arena_release_text_input_view() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.ViewProto.text_input_view)
  if (_internal_has_text_input_view()) {
    clear_has_view();
    ::autofill_assistant::TextInputViewProto* temp = view_.text_input_view_;
    view_.text_input_view_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ViewProto::unsafe_arena_set_allocated_text_input_view(::autofill_assistant::TextInputViewProto* text_input_view) {
  clear_view();
  if (text_input_view) {
    set_has_text_input_view();
    view_.text_input_view_ = text_input_view;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ViewProto.text_input_view)
}
inline ::autofill_assistant::TextInputViewProto* ViewProto::_internal_mutable_text_input_view() {
  if (!_internal_has_text_input_view()) {
    clear_view();
    set_has_text_input_view();
    view_.text_input_view_ = CreateMaybeMessage< ::autofill_assistant::TextInputViewProto >(GetArenaForAllocation());
  }
  return view_.text_input_view_;
}
inline ::autofill_assistant::TextInputViewProto* ViewProto::mutable_text_input_view() {
  ::autofill_assistant::TextInputViewProto* _msg = _internal_mutable_text_input_view();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ViewProto.text_input_view)
  return _msg;
}

// .autofill_assistant.VerticalExpanderViewProto vertical_expander_view = 9;
inline bool ViewProto::_internal_has_vertical_expander_view() const {
  return view_case() == kVerticalExpanderView;
}
inline bool ViewProto::has_vertical_expander_view() const {
  return _internal_has_vertical_expander_view();
}
inline void ViewProto::set_has_vertical_expander_view() {
  _oneof_case_[0] = kVerticalExpanderView;
}
inline void ViewProto::clear_vertical_expander_view() {
  if (_internal_has_vertical_expander_view()) {
    if (GetArenaForAllocation() == nullptr) {
      delete view_.vertical_expander_view_;
    }
    clear_has_view();
  }
}
inline ::autofill_assistant::VerticalExpanderViewProto* ViewProto::release_vertical_expander_view() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ViewProto.vertical_expander_view)
  if (_internal_has_vertical_expander_view()) {
    clear_has_view();
    ::autofill_assistant::VerticalExpanderViewProto* temp = view_.vertical_expander_view_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    view_.vertical_expander_view_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::VerticalExpanderViewProto& ViewProto::_internal_vertical_expander_view() const {
  return _internal_has_vertical_expander_view()
      ? *view_.vertical_expander_view_
      : reinterpret_cast< ::autofill_assistant::VerticalExpanderViewProto&>(::autofill_assistant::_VerticalExpanderViewProto_default_instance_);
}
inline const ::autofill_assistant::VerticalExpanderViewProto& ViewProto::vertical_expander_view() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ViewProto.vertical_expander_view)
  return _internal_vertical_expander_view();
}
inline ::autofill_assistant::VerticalExpanderViewProto* ViewProto::unsafe_arena_release_vertical_expander_view() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.ViewProto.vertical_expander_view)
  if (_internal_has_vertical_expander_view()) {
    clear_has_view();
    ::autofill_assistant::VerticalExpanderViewProto* temp = view_.vertical_expander_view_;
    view_.vertical_expander_view_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ViewProto::unsafe_arena_set_allocated_vertical_expander_view(::autofill_assistant::VerticalExpanderViewProto* vertical_expander_view) {
  clear_view();
  if (vertical_expander_view) {
    set_has_vertical_expander_view();
    view_.vertical_expander_view_ = vertical_expander_view;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ViewProto.vertical_expander_view)
}
inline ::autofill_assistant::VerticalExpanderViewProto* ViewProto::_internal_mutable_vertical_expander_view() {
  if (!_internal_has_vertical_expander_view()) {
    clear_view();
    set_has_vertical_expander_view();
    view_.vertical_expander_view_ = CreateMaybeMessage< ::autofill_assistant::VerticalExpanderViewProto >(GetArenaForAllocation());
  }
  return view_.vertical_expander_view_;
}
inline ::autofill_assistant::VerticalExpanderViewProto* ViewProto::mutable_vertical_expander_view() {
  ::autofill_assistant::VerticalExpanderViewProto* _msg = _internal_mutable_vertical_expander_view();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ViewProto.vertical_expander_view)
  return _msg;
}

// .autofill_assistant.ToggleButtonViewProto toggle_button_view = 10;
inline bool ViewProto::_internal_has_toggle_button_view() const {
  return view_case() == kToggleButtonView;
}
inline bool ViewProto::has_toggle_button_view() const {
  return _internal_has_toggle_button_view();
}
inline void ViewProto::set_has_toggle_button_view() {
  _oneof_case_[0] = kToggleButtonView;
}
inline void ViewProto::clear_toggle_button_view() {
  if (_internal_has_toggle_button_view()) {
    if (GetArenaForAllocation() == nullptr) {
      delete view_.toggle_button_view_;
    }
    clear_has_view();
  }
}
inline ::autofill_assistant::ToggleButtonViewProto* ViewProto::release_toggle_button_view() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ViewProto.toggle_button_view)
  if (_internal_has_toggle_button_view()) {
    clear_has_view();
    ::autofill_assistant::ToggleButtonViewProto* temp = view_.toggle_button_view_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    view_.toggle_button_view_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::ToggleButtonViewProto& ViewProto::_internal_toggle_button_view() const {
  return _internal_has_toggle_button_view()
      ? *view_.toggle_button_view_
      : reinterpret_cast< ::autofill_assistant::ToggleButtonViewProto&>(::autofill_assistant::_ToggleButtonViewProto_default_instance_);
}
inline const ::autofill_assistant::ToggleButtonViewProto& ViewProto::toggle_button_view() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ViewProto.toggle_button_view)
  return _internal_toggle_button_view();
}
inline ::autofill_assistant::ToggleButtonViewProto* ViewProto::unsafe_arena_release_toggle_button_view() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.ViewProto.toggle_button_view)
  if (_internal_has_toggle_button_view()) {
    clear_has_view();
    ::autofill_assistant::ToggleButtonViewProto* temp = view_.toggle_button_view_;
    view_.toggle_button_view_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ViewProto::unsafe_arena_set_allocated_toggle_button_view(::autofill_assistant::ToggleButtonViewProto* toggle_button_view) {
  clear_view();
  if (toggle_button_view) {
    set_has_toggle_button_view();
    view_.toggle_button_view_ = toggle_button_view;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ViewProto.toggle_button_view)
}
inline ::autofill_assistant::ToggleButtonViewProto* ViewProto::_internal_mutable_toggle_button_view() {
  if (!_internal_has_toggle_button_view()) {
    clear_view();
    set_has_toggle_button_view();
    view_.toggle_button_view_ = CreateMaybeMessage< ::autofill_assistant::ToggleButtonViewProto >(GetArenaForAllocation());
  }
  return view_.toggle_button_view_;
}
inline ::autofill_assistant::ToggleButtonViewProto* ViewProto::mutable_toggle_button_view() {
  ::autofill_assistant::ToggleButtonViewProto* _msg = _internal_mutable_toggle_button_view();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ViewProto.toggle_button_view)
  return _msg;
}

inline bool ViewProto::has_view() const {
  return view_case() != VIEW_NOT_SET;
}
inline void ViewProto::clear_has_view() {
  _oneof_case_[0] = VIEW_NOT_SET;
}
inline ViewProto::ViewCase ViewProto::view_case() const {
  return ViewProto::ViewCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ColorProto

// string resource_identifier = 1;
inline bool ColorProto::_internal_has_resource_identifier() const {
  return color_case() == kResourceIdentifier;
}
inline bool ColorProto::has_resource_identifier() const {
  return _internal_has_resource_identifier();
}
inline void ColorProto::set_has_resource_identifier() {
  _oneof_case_[0] = kResourceIdentifier;
}
inline void ColorProto::clear_resource_identifier() {
  if (_internal_has_resource_identifier()) {
    color_.resource_identifier_.Destroy();
    clear_has_color();
  }
}
inline const std::string& ColorProto::resource_identifier() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ColorProto.resource_identifier)
  return _internal_resource_identifier();
}
template <typename ArgT0, typename... ArgT>
inline void ColorProto::set_resource_identifier(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_resource_identifier()) {
    clear_color();
    set_has_resource_identifier();
    color_.resource_identifier_.InitDefault();
  }
  color_.resource_identifier_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.ColorProto.resource_identifier)
}
inline std::string* ColorProto::mutable_resource_identifier() {
  std::string* _s = _internal_mutable_resource_identifier();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ColorProto.resource_identifier)
  return _s;
}
inline const std::string& ColorProto::_internal_resource_identifier() const {
  if (_internal_has_resource_identifier()) {
    return color_.resource_identifier_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void ColorProto::_internal_set_resource_identifier(const std::string& value) {
  if (!_internal_has_resource_identifier()) {
    clear_color();
    set_has_resource_identifier();
    color_.resource_identifier_.InitDefault();
  }
  color_.resource_identifier_.Set(value, GetArenaForAllocation());
}
inline std::string* ColorProto::_internal_mutable_resource_identifier() {
  if (!_internal_has_resource_identifier()) {
    clear_color();
    set_has_resource_identifier();
    color_.resource_identifier_.InitDefault();
  }
  return color_.resource_identifier_.Mutable(      GetArenaForAllocation());
}
inline std::string* ColorProto::release_resource_identifier() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ColorProto.resource_identifier)
  if (_internal_has_resource_identifier()) {
    clear_has_color();
    return color_.resource_identifier_.Release();
  } else {
    return nullptr;
  }
}
inline void ColorProto::set_allocated_resource_identifier(std::string* resource_identifier) {
  if (has_color()) {
    clear_color();
  }
  if (resource_identifier != nullptr) {
    set_has_resource_identifier();
    color_.resource_identifier_.InitAllocated(resource_identifier, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ColorProto.resource_identifier)
}

// string parseable_color = 2;
inline bool ColorProto::_internal_has_parseable_color() const {
  return color_case() == kParseableColor;
}
inline bool ColorProto::has_parseable_color() const {
  return _internal_has_parseable_color();
}
inline void ColorProto::set_has_parseable_color() {
  _oneof_case_[0] = kParseableColor;
}
inline void ColorProto::clear_parseable_color() {
  if (_internal_has_parseable_color()) {
    color_.parseable_color_.Destroy();
    clear_has_color();
  }
}
inline const std::string& ColorProto::parseable_color() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ColorProto.parseable_color)
  return _internal_parseable_color();
}
template <typename ArgT0, typename... ArgT>
inline void ColorProto::set_parseable_color(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_parseable_color()) {
    clear_color();
    set_has_parseable_color();
    color_.parseable_color_.InitDefault();
  }
  color_.parseable_color_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.ColorProto.parseable_color)
}
inline std::string* ColorProto::mutable_parseable_color() {
  std::string* _s = _internal_mutable_parseable_color();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ColorProto.parseable_color)
  return _s;
}
inline const std::string& ColorProto::_internal_parseable_color() const {
  if (_internal_has_parseable_color()) {
    return color_.parseable_color_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void ColorProto::_internal_set_parseable_color(const std::string& value) {
  if (!_internal_has_parseable_color()) {
    clear_color();
    set_has_parseable_color();
    color_.parseable_color_.InitDefault();
  }
  color_.parseable_color_.Set(value, GetArenaForAllocation());
}
inline std::string* ColorProto::_internal_mutable_parseable_color() {
  if (!_internal_has_parseable_color()) {
    clear_color();
    set_has_parseable_color();
    color_.parseable_color_.InitDefault();
  }
  return color_.parseable_color_.Mutable(      GetArenaForAllocation());
}
inline std::string* ColorProto::release_parseable_color() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ColorProto.parseable_color)
  if (_internal_has_parseable_color()) {
    clear_has_color();
    return color_.parseable_color_.Release();
  } else {
    return nullptr;
  }
}
inline void ColorProto::set_allocated_parseable_color(std::string* parseable_color) {
  if (has_color()) {
    clear_color();
  }
  if (parseable_color != nullptr) {
    set_has_parseable_color();
    color_.parseable_color_.InitAllocated(parseable_color, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ColorProto.parseable_color)
}

inline bool ColorProto::has_color() const {
  return color_case() != COLOR_NOT_SET;
}
inline void ColorProto::clear_has_color() {
  _oneof_case_[0] = COLOR_NOT_SET;
}
inline ColorProto::ColorCase ColorProto::color_case() const {
  return ColorProto::ColorCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ClientDimensionProto

// int32 dp = 1;
inline bool ClientDimensionProto::_internal_has_dp() const {
  return size_case() == kDp;
}
inline bool ClientDimensionProto::has_dp() const {
  return _internal_has_dp();
}
inline void ClientDimensionProto::set_has_dp() {
  _oneof_case_[0] = kDp;
}
inline void ClientDimensionProto::clear_dp() {
  if (_internal_has_dp()) {
    size_.dp_ = 0;
    clear_has_size();
  }
}
inline int32_t ClientDimensionProto::_internal_dp() const {
  if (_internal_has_dp()) {
    return size_.dp_;
  }
  return 0;
}
inline void ClientDimensionProto::_internal_set_dp(int32_t value) {
  if (!_internal_has_dp()) {
    clear_size();
    set_has_dp();
  }
  size_.dp_ = value;
}
inline int32_t ClientDimensionProto::dp() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ClientDimensionProto.dp)
  return _internal_dp();
}
inline void ClientDimensionProto::set_dp(int32_t value) {
  _internal_set_dp(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.ClientDimensionProto.dp)
}

// float width_factor = 2;
inline bool ClientDimensionProto::_internal_has_width_factor() const {
  return size_case() == kWidthFactor;
}
inline bool ClientDimensionProto::has_width_factor() const {
  return _internal_has_width_factor();
}
inline void ClientDimensionProto::set_has_width_factor() {
  _oneof_case_[0] = kWidthFactor;
}
inline void ClientDimensionProto::clear_width_factor() {
  if (_internal_has_width_factor()) {
    size_.width_factor_ = 0;
    clear_has_size();
  }
}
inline float ClientDimensionProto::_internal_width_factor() const {
  if (_internal_has_width_factor()) {
    return size_.width_factor_;
  }
  return 0;
}
inline void ClientDimensionProto::_internal_set_width_factor(float value) {
  if (!_internal_has_width_factor()) {
    clear_size();
    set_has_width_factor();
  }
  size_.width_factor_ = value;
}
inline float ClientDimensionProto::width_factor() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ClientDimensionProto.width_factor)
  return _internal_width_factor();
}
inline void ClientDimensionProto::set_width_factor(float value) {
  _internal_set_width_factor(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.ClientDimensionProto.width_factor)
}

// float height_factor = 3;
inline bool ClientDimensionProto::_internal_has_height_factor() const {
  return size_case() == kHeightFactor;
}
inline bool ClientDimensionProto::has_height_factor() const {
  return _internal_has_height_factor();
}
inline void ClientDimensionProto::set_has_height_factor() {
  _oneof_case_[0] = kHeightFactor;
}
inline void ClientDimensionProto::clear_height_factor() {
  if (_internal_has_height_factor()) {
    size_.height_factor_ = 0;
    clear_has_size();
  }
}
inline float ClientDimensionProto::_internal_height_factor() const {
  if (_internal_has_height_factor()) {
    return size_.height_factor_;
  }
  return 0;
}
inline void ClientDimensionProto::_internal_set_height_factor(float value) {
  if (!_internal_has_height_factor()) {
    clear_size();
    set_has_height_factor();
  }
  size_.height_factor_ = value;
}
inline float ClientDimensionProto::height_factor() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ClientDimensionProto.height_factor)
  return _internal_height_factor();
}
inline void ClientDimensionProto::set_height_factor(float value) {
  _internal_set_height_factor(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.ClientDimensionProto.height_factor)
}

// int32 size_in_pixel = 4;
inline bool ClientDimensionProto::_internal_has_size_in_pixel() const {
  return size_case() == kSizeInPixel;
}
inline bool ClientDimensionProto::has_size_in_pixel() const {
  return _internal_has_size_in_pixel();
}
inline void ClientDimensionProto::set_has_size_in_pixel() {
  _oneof_case_[0] = kSizeInPixel;
}
inline void ClientDimensionProto::clear_size_in_pixel() {
  if (_internal_has_size_in_pixel()) {
    size_.size_in_pixel_ = 0;
    clear_has_size();
  }
}
inline int32_t ClientDimensionProto::_internal_size_in_pixel() const {
  if (_internal_has_size_in_pixel()) {
    return size_.size_in_pixel_;
  }
  return 0;
}
inline void ClientDimensionProto::_internal_set_size_in_pixel(int32_t value) {
  if (!_internal_has_size_in_pixel()) {
    clear_size();
    set_has_size_in_pixel();
  }
  size_.size_in_pixel_ = value;
}
inline int32_t ClientDimensionProto::size_in_pixel() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ClientDimensionProto.size_in_pixel)
  return _internal_size_in_pixel();
}
inline void ClientDimensionProto::set_size_in_pixel(int32_t value) {
  _internal_set_size_in_pixel(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.ClientDimensionProto.size_in_pixel)
}

inline bool ClientDimensionProto::has_size() const {
  return size_case() != SIZE_NOT_SET;
}
inline void ClientDimensionProto::clear_has_size() {
  _oneof_case_[0] = SIZE_NOT_SET;
}
inline ClientDimensionProto::SizeCase ClientDimensionProto::size_case() const {
  return ClientDimensionProto::SizeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ShapeDrawableProto_Rectangle

// optional .autofill_assistant.ClientDimensionProto corner_radius = 1;
inline bool ShapeDrawableProto_Rectangle::_internal_has_corner_radius() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || corner_radius_ != nullptr);
  return value;
}
inline bool ShapeDrawableProto_Rectangle::has_corner_radius() const {
  return _internal_has_corner_radius();
}
inline void ShapeDrawableProto_Rectangle::clear_corner_radius() {
  if (corner_radius_ != nullptr) corner_radius_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::autofill_assistant::ClientDimensionProto& ShapeDrawableProto_Rectangle::_internal_corner_radius() const {
  const ::autofill_assistant::ClientDimensionProto* p = corner_radius_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::ClientDimensionProto&>(
      ::autofill_assistant::_ClientDimensionProto_default_instance_);
}
inline const ::autofill_assistant::ClientDimensionProto& ShapeDrawableProto_Rectangle::corner_radius() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ShapeDrawableProto.Rectangle.corner_radius)
  return _internal_corner_radius();
}
inline void ShapeDrawableProto_Rectangle::unsafe_arena_set_allocated_corner_radius(
    ::autofill_assistant::ClientDimensionProto* corner_radius) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(corner_radius_);
  }
  corner_radius_ = corner_radius;
  if (corner_radius) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ShapeDrawableProto.Rectangle.corner_radius)
}
inline ::autofill_assistant::ClientDimensionProto* ShapeDrawableProto_Rectangle::release_corner_radius() {
  _has_bits_[0] &= ~0x00000001u;
  ::autofill_assistant::ClientDimensionProto* temp = corner_radius_;
  corner_radius_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::ClientDimensionProto* ShapeDrawableProto_Rectangle::unsafe_arena_release_corner_radius() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ShapeDrawableProto.Rectangle.corner_radius)
  _has_bits_[0] &= ~0x00000001u;
  ::autofill_assistant::ClientDimensionProto* temp = corner_radius_;
  corner_radius_ = nullptr;
  return temp;
}
inline ::autofill_assistant::ClientDimensionProto* ShapeDrawableProto_Rectangle::_internal_mutable_corner_radius() {
  _has_bits_[0] |= 0x00000001u;
  if (corner_radius_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::ClientDimensionProto>(GetArenaForAllocation());
    corner_radius_ = p;
  }
  return corner_radius_;
}
inline ::autofill_assistant::ClientDimensionProto* ShapeDrawableProto_Rectangle::mutable_corner_radius() {
  ::autofill_assistant::ClientDimensionProto* _msg = _internal_mutable_corner_radius();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ShapeDrawableProto.Rectangle.corner_radius)
  return _msg;
}
inline void ShapeDrawableProto_Rectangle::set_allocated_corner_radius(::autofill_assistant::ClientDimensionProto* corner_radius) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete corner_radius_;
  }
  if (corner_radius) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(corner_radius);
    if (message_arena != submessage_arena) {
      corner_radius = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, corner_radius, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  corner_radius_ = corner_radius;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ShapeDrawableProto.Rectangle.corner_radius)
}

// -------------------------------------------------------------------

// ShapeDrawableProto

// .autofill_assistant.ShapeDrawableProto.Rectangle rectangle = 1;
inline bool ShapeDrawableProto::_internal_has_rectangle() const {
  return shape_case() == kRectangle;
}
inline bool ShapeDrawableProto::has_rectangle() const {
  return _internal_has_rectangle();
}
inline void ShapeDrawableProto::set_has_rectangle() {
  _oneof_case_[0] = kRectangle;
}
inline void ShapeDrawableProto::clear_rectangle() {
  if (_internal_has_rectangle()) {
    if (GetArenaForAllocation() == nullptr) {
      delete shape_.rectangle_;
    }
    clear_has_shape();
  }
}
inline ::autofill_assistant::ShapeDrawableProto_Rectangle* ShapeDrawableProto::release_rectangle() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ShapeDrawableProto.rectangle)
  if (_internal_has_rectangle()) {
    clear_has_shape();
    ::autofill_assistant::ShapeDrawableProto_Rectangle* temp = shape_.rectangle_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    shape_.rectangle_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::ShapeDrawableProto_Rectangle& ShapeDrawableProto::_internal_rectangle() const {
  return _internal_has_rectangle()
      ? *shape_.rectangle_
      : reinterpret_cast< ::autofill_assistant::ShapeDrawableProto_Rectangle&>(::autofill_assistant::_ShapeDrawableProto_Rectangle_default_instance_);
}
inline const ::autofill_assistant::ShapeDrawableProto_Rectangle& ShapeDrawableProto::rectangle() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ShapeDrawableProto.rectangle)
  return _internal_rectangle();
}
inline ::autofill_assistant::ShapeDrawableProto_Rectangle* ShapeDrawableProto::unsafe_arena_release_rectangle() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.ShapeDrawableProto.rectangle)
  if (_internal_has_rectangle()) {
    clear_has_shape();
    ::autofill_assistant::ShapeDrawableProto_Rectangle* temp = shape_.rectangle_;
    shape_.rectangle_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ShapeDrawableProto::unsafe_arena_set_allocated_rectangle(::autofill_assistant::ShapeDrawableProto_Rectangle* rectangle) {
  clear_shape();
  if (rectangle) {
    set_has_rectangle();
    shape_.rectangle_ = rectangle;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ShapeDrawableProto.rectangle)
}
inline ::autofill_assistant::ShapeDrawableProto_Rectangle* ShapeDrawableProto::_internal_mutable_rectangle() {
  if (!_internal_has_rectangle()) {
    clear_shape();
    set_has_rectangle();
    shape_.rectangle_ = CreateMaybeMessage< ::autofill_assistant::ShapeDrawableProto_Rectangle >(GetArenaForAllocation());
  }
  return shape_.rectangle_;
}
inline ::autofill_assistant::ShapeDrawableProto_Rectangle* ShapeDrawableProto::mutable_rectangle() {
  ::autofill_assistant::ShapeDrawableProto_Rectangle* _msg = _internal_mutable_rectangle();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ShapeDrawableProto.rectangle)
  return _msg;
}

// optional .autofill_assistant.ColorProto background_color = 2;
inline bool ShapeDrawableProto::_internal_has_background_color() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || background_color_ != nullptr);
  return value;
}
inline bool ShapeDrawableProto::has_background_color() const {
  return _internal_has_background_color();
}
inline void ShapeDrawableProto::clear_background_color() {
  if (background_color_ != nullptr) background_color_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::autofill_assistant::ColorProto& ShapeDrawableProto::_internal_background_color() const {
  const ::autofill_assistant::ColorProto* p = background_color_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::ColorProto&>(
      ::autofill_assistant::_ColorProto_default_instance_);
}
inline const ::autofill_assistant::ColorProto& ShapeDrawableProto::background_color() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ShapeDrawableProto.background_color)
  return _internal_background_color();
}
inline void ShapeDrawableProto::unsafe_arena_set_allocated_background_color(
    ::autofill_assistant::ColorProto* background_color) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(background_color_);
  }
  background_color_ = background_color;
  if (background_color) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ShapeDrawableProto.background_color)
}
inline ::autofill_assistant::ColorProto* ShapeDrawableProto::release_background_color() {
  _has_bits_[0] &= ~0x00000001u;
  ::autofill_assistant::ColorProto* temp = background_color_;
  background_color_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::ColorProto* ShapeDrawableProto::unsafe_arena_release_background_color() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ShapeDrawableProto.background_color)
  _has_bits_[0] &= ~0x00000001u;
  ::autofill_assistant::ColorProto* temp = background_color_;
  background_color_ = nullptr;
  return temp;
}
inline ::autofill_assistant::ColorProto* ShapeDrawableProto::_internal_mutable_background_color() {
  _has_bits_[0] |= 0x00000001u;
  if (background_color_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::ColorProto>(GetArenaForAllocation());
    background_color_ = p;
  }
  return background_color_;
}
inline ::autofill_assistant::ColorProto* ShapeDrawableProto::mutable_background_color() {
  ::autofill_assistant::ColorProto* _msg = _internal_mutable_background_color();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ShapeDrawableProto.background_color)
  return _msg;
}
inline void ShapeDrawableProto::set_allocated_background_color(::autofill_assistant::ColorProto* background_color) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete background_color_;
  }
  if (background_color) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(background_color);
    if (message_arena != submessage_arena) {
      background_color = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, background_color, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  background_color_ = background_color;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ShapeDrawableProto.background_color)
}

// optional .autofill_assistant.ClientDimensionProto stroke_width = 3;
inline bool ShapeDrawableProto::_internal_has_stroke_width() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || stroke_width_ != nullptr);
  return value;
}
inline bool ShapeDrawableProto::has_stroke_width() const {
  return _internal_has_stroke_width();
}
inline void ShapeDrawableProto::clear_stroke_width() {
  if (stroke_width_ != nullptr) stroke_width_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::autofill_assistant::ClientDimensionProto& ShapeDrawableProto::_internal_stroke_width() const {
  const ::autofill_assistant::ClientDimensionProto* p = stroke_width_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::ClientDimensionProto&>(
      ::autofill_assistant::_ClientDimensionProto_default_instance_);
}
inline const ::autofill_assistant::ClientDimensionProto& ShapeDrawableProto::stroke_width() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ShapeDrawableProto.stroke_width)
  return _internal_stroke_width();
}
inline void ShapeDrawableProto::unsafe_arena_set_allocated_stroke_width(
    ::autofill_assistant::ClientDimensionProto* stroke_width) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(stroke_width_);
  }
  stroke_width_ = stroke_width;
  if (stroke_width) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ShapeDrawableProto.stroke_width)
}
inline ::autofill_assistant::ClientDimensionProto* ShapeDrawableProto::release_stroke_width() {
  _has_bits_[0] &= ~0x00000002u;
  ::autofill_assistant::ClientDimensionProto* temp = stroke_width_;
  stroke_width_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::ClientDimensionProto* ShapeDrawableProto::unsafe_arena_release_stroke_width() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ShapeDrawableProto.stroke_width)
  _has_bits_[0] &= ~0x00000002u;
  ::autofill_assistant::ClientDimensionProto* temp = stroke_width_;
  stroke_width_ = nullptr;
  return temp;
}
inline ::autofill_assistant::ClientDimensionProto* ShapeDrawableProto::_internal_mutable_stroke_width() {
  _has_bits_[0] |= 0x00000002u;
  if (stroke_width_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::ClientDimensionProto>(GetArenaForAllocation());
    stroke_width_ = p;
  }
  return stroke_width_;
}
inline ::autofill_assistant::ClientDimensionProto* ShapeDrawableProto::mutable_stroke_width() {
  ::autofill_assistant::ClientDimensionProto* _msg = _internal_mutable_stroke_width();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ShapeDrawableProto.stroke_width)
  return _msg;
}
inline void ShapeDrawableProto::set_allocated_stroke_width(::autofill_assistant::ClientDimensionProto* stroke_width) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete stroke_width_;
  }
  if (stroke_width) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(stroke_width);
    if (message_arena != submessage_arena) {
      stroke_width = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stroke_width, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  stroke_width_ = stroke_width;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ShapeDrawableProto.stroke_width)
}

// optional .autofill_assistant.ColorProto stroke_color = 4;
inline bool ShapeDrawableProto::_internal_has_stroke_color() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || stroke_color_ != nullptr);
  return value;
}
inline bool ShapeDrawableProto::has_stroke_color() const {
  return _internal_has_stroke_color();
}
inline void ShapeDrawableProto::clear_stroke_color() {
  if (stroke_color_ != nullptr) stroke_color_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::autofill_assistant::ColorProto& ShapeDrawableProto::_internal_stroke_color() const {
  const ::autofill_assistant::ColorProto* p = stroke_color_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::ColorProto&>(
      ::autofill_assistant::_ColorProto_default_instance_);
}
inline const ::autofill_assistant::ColorProto& ShapeDrawableProto::stroke_color() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ShapeDrawableProto.stroke_color)
  return _internal_stroke_color();
}
inline void ShapeDrawableProto::unsafe_arena_set_allocated_stroke_color(
    ::autofill_assistant::ColorProto* stroke_color) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(stroke_color_);
  }
  stroke_color_ = stroke_color;
  if (stroke_color) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ShapeDrawableProto.stroke_color)
}
inline ::autofill_assistant::ColorProto* ShapeDrawableProto::release_stroke_color() {
  _has_bits_[0] &= ~0x00000004u;
  ::autofill_assistant::ColorProto* temp = stroke_color_;
  stroke_color_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::ColorProto* ShapeDrawableProto::unsafe_arena_release_stroke_color() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ShapeDrawableProto.stroke_color)
  _has_bits_[0] &= ~0x00000004u;
  ::autofill_assistant::ColorProto* temp = stroke_color_;
  stroke_color_ = nullptr;
  return temp;
}
inline ::autofill_assistant::ColorProto* ShapeDrawableProto::_internal_mutable_stroke_color() {
  _has_bits_[0] |= 0x00000004u;
  if (stroke_color_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::ColorProto>(GetArenaForAllocation());
    stroke_color_ = p;
  }
  return stroke_color_;
}
inline ::autofill_assistant::ColorProto* ShapeDrawableProto::mutable_stroke_color() {
  ::autofill_assistant::ColorProto* _msg = _internal_mutable_stroke_color();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ShapeDrawableProto.stroke_color)
  return _msg;
}
inline void ShapeDrawableProto::set_allocated_stroke_color(::autofill_assistant::ColorProto* stroke_color) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete stroke_color_;
  }
  if (stroke_color) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(stroke_color);
    if (message_arena != submessage_arena) {
      stroke_color = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stroke_color, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  stroke_color_ = stroke_color;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ShapeDrawableProto.stroke_color)
}

inline bool ShapeDrawableProto::has_shape() const {
  return shape_case() != SHAPE_NOT_SET;
}
inline void ShapeDrawableProto::clear_has_shape() {
  _oneof_case_[0] = SHAPE_NOT_SET;
}
inline ShapeDrawableProto::ShapeCase ShapeDrawableProto::shape_case() const {
  return ShapeDrawableProto::ShapeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ConfigBasedUrlProto

// map<string, string> url = 1;
inline int ConfigBasedUrlProto::_internal_url_size() const {
  return url_.size();
}
inline int ConfigBasedUrlProto::url_size() const {
  return _internal_url_size();
}
inline void ConfigBasedUrlProto::clear_url() {
  url_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
ConfigBasedUrlProto::_internal_url() const {
  return url_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
ConfigBasedUrlProto::url() const {
  // @@protoc_insertion_point(field_map:autofill_assistant.ConfigBasedUrlProto.url)
  return _internal_url();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
ConfigBasedUrlProto::_internal_mutable_url() {
  return url_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
ConfigBasedUrlProto::mutable_url() {
  // @@protoc_insertion_point(field_mutable_map:autofill_assistant.ConfigBasedUrlProto.url)
  return _internal_mutable_url();
}

// -------------------------------------------------------------------

// BitmapDrawableProto

// string url = 1;
inline bool BitmapDrawableProto::_internal_has_url() const {
  return image_url_case() == kUrl;
}
inline bool BitmapDrawableProto::has_url() const {
  return _internal_has_url();
}
inline void BitmapDrawableProto::set_has_url() {
  _oneof_case_[0] = kUrl;
}
inline void BitmapDrawableProto::clear_url() {
  if (_internal_has_url()) {
    image_url_.url_.Destroy();
    clear_has_image_url();
  }
}
inline const std::string& BitmapDrawableProto::url() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.BitmapDrawableProto.url)
  return _internal_url();
}
template <typename ArgT0, typename... ArgT>
inline void BitmapDrawableProto::set_url(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_url()) {
    clear_image_url();
    set_has_url();
    image_url_.url_.InitDefault();
  }
  image_url_.url_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.BitmapDrawableProto.url)
}
inline std::string* BitmapDrawableProto::mutable_url() {
  std::string* _s = _internal_mutable_url();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.BitmapDrawableProto.url)
  return _s;
}
inline const std::string& BitmapDrawableProto::_internal_url() const {
  if (_internal_has_url()) {
    return image_url_.url_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void BitmapDrawableProto::_internal_set_url(const std::string& value) {
  if (!_internal_has_url()) {
    clear_image_url();
    set_has_url();
    image_url_.url_.InitDefault();
  }
  image_url_.url_.Set(value, GetArenaForAllocation());
}
inline std::string* BitmapDrawableProto::_internal_mutable_url() {
  if (!_internal_has_url()) {
    clear_image_url();
    set_has_url();
    image_url_.url_.InitDefault();
  }
  return image_url_.url_.Mutable(      GetArenaForAllocation());
}
inline std::string* BitmapDrawableProto::release_url() {
  // @@protoc_insertion_point(field_release:autofill_assistant.BitmapDrawableProto.url)
  if (_internal_has_url()) {
    clear_has_image_url();
    return image_url_.url_.Release();
  } else {
    return nullptr;
  }
}
inline void BitmapDrawableProto::set_allocated_url(std::string* url) {
  if (has_image_url()) {
    clear_image_url();
  }
  if (url != nullptr) {
    set_has_url();
    image_url_.url_.InitAllocated(url, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.BitmapDrawableProto.url)
}

// .autofill_assistant.ConfigBasedUrlProto config_based_url = 4;
inline bool BitmapDrawableProto::_internal_has_config_based_url() const {
  return image_url_case() == kConfigBasedUrl;
}
inline bool BitmapDrawableProto::has_config_based_url() const {
  return _internal_has_config_based_url();
}
inline void BitmapDrawableProto::set_has_config_based_url() {
  _oneof_case_[0] = kConfigBasedUrl;
}
inline void BitmapDrawableProto::clear_config_based_url() {
  if (_internal_has_config_based_url()) {
    if (GetArenaForAllocation() == nullptr) {
      delete image_url_.config_based_url_;
    }
    clear_has_image_url();
  }
}
inline ::autofill_assistant::ConfigBasedUrlProto* BitmapDrawableProto::release_config_based_url() {
  // @@protoc_insertion_point(field_release:autofill_assistant.BitmapDrawableProto.config_based_url)
  if (_internal_has_config_based_url()) {
    clear_has_image_url();
    ::autofill_assistant::ConfigBasedUrlProto* temp = image_url_.config_based_url_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    image_url_.config_based_url_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::ConfigBasedUrlProto& BitmapDrawableProto::_internal_config_based_url() const {
  return _internal_has_config_based_url()
      ? *image_url_.config_based_url_
      : reinterpret_cast< ::autofill_assistant::ConfigBasedUrlProto&>(::autofill_assistant::_ConfigBasedUrlProto_default_instance_);
}
inline const ::autofill_assistant::ConfigBasedUrlProto& BitmapDrawableProto::config_based_url() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.BitmapDrawableProto.config_based_url)
  return _internal_config_based_url();
}
inline ::autofill_assistant::ConfigBasedUrlProto* BitmapDrawableProto::unsafe_arena_release_config_based_url() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.BitmapDrawableProto.config_based_url)
  if (_internal_has_config_based_url()) {
    clear_has_image_url();
    ::autofill_assistant::ConfigBasedUrlProto* temp = image_url_.config_based_url_;
    image_url_.config_based_url_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BitmapDrawableProto::unsafe_arena_set_allocated_config_based_url(::autofill_assistant::ConfigBasedUrlProto* config_based_url) {
  clear_image_url();
  if (config_based_url) {
    set_has_config_based_url();
    image_url_.config_based_url_ = config_based_url;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.BitmapDrawableProto.config_based_url)
}
inline ::autofill_assistant::ConfigBasedUrlProto* BitmapDrawableProto::_internal_mutable_config_based_url() {
  if (!_internal_has_config_based_url()) {
    clear_image_url();
    set_has_config_based_url();
    image_url_.config_based_url_ = CreateMaybeMessage< ::autofill_assistant::ConfigBasedUrlProto >(GetArenaForAllocation());
  }
  return image_url_.config_based_url_;
}
inline ::autofill_assistant::ConfigBasedUrlProto* BitmapDrawableProto::mutable_config_based_url() {
  ::autofill_assistant::ConfigBasedUrlProto* _msg = _internal_mutable_config_based_url();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.BitmapDrawableProto.config_based_url)
  return _msg;
}

// optional .autofill_assistant.ClientDimensionProto width = 2;
inline bool BitmapDrawableProto::_internal_has_width() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || width_ != nullptr);
  return value;
}
inline bool BitmapDrawableProto::has_width() const {
  return _internal_has_width();
}
inline void BitmapDrawableProto::clear_width() {
  if (width_ != nullptr) width_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::autofill_assistant::ClientDimensionProto& BitmapDrawableProto::_internal_width() const {
  const ::autofill_assistant::ClientDimensionProto* p = width_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::ClientDimensionProto&>(
      ::autofill_assistant::_ClientDimensionProto_default_instance_);
}
inline const ::autofill_assistant::ClientDimensionProto& BitmapDrawableProto::width() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.BitmapDrawableProto.width)
  return _internal_width();
}
inline void BitmapDrawableProto::unsafe_arena_set_allocated_width(
    ::autofill_assistant::ClientDimensionProto* width) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(width_);
  }
  width_ = width;
  if (width) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.BitmapDrawableProto.width)
}
inline ::autofill_assistant::ClientDimensionProto* BitmapDrawableProto::release_width() {
  _has_bits_[0] &= ~0x00000001u;
  ::autofill_assistant::ClientDimensionProto* temp = width_;
  width_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::ClientDimensionProto* BitmapDrawableProto::unsafe_arena_release_width() {
  // @@protoc_insertion_point(field_release:autofill_assistant.BitmapDrawableProto.width)
  _has_bits_[0] &= ~0x00000001u;
  ::autofill_assistant::ClientDimensionProto* temp = width_;
  width_ = nullptr;
  return temp;
}
inline ::autofill_assistant::ClientDimensionProto* BitmapDrawableProto::_internal_mutable_width() {
  _has_bits_[0] |= 0x00000001u;
  if (width_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::ClientDimensionProto>(GetArenaForAllocation());
    width_ = p;
  }
  return width_;
}
inline ::autofill_assistant::ClientDimensionProto* BitmapDrawableProto::mutable_width() {
  ::autofill_assistant::ClientDimensionProto* _msg = _internal_mutable_width();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.BitmapDrawableProto.width)
  return _msg;
}
inline void BitmapDrawableProto::set_allocated_width(::autofill_assistant::ClientDimensionProto* width) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete width_;
  }
  if (width) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(width);
    if (message_arena != submessage_arena) {
      width = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, width, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  width_ = width;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.BitmapDrawableProto.width)
}

// optional .autofill_assistant.ClientDimensionProto height = 3;
inline bool BitmapDrawableProto::_internal_has_height() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || height_ != nullptr);
  return value;
}
inline bool BitmapDrawableProto::has_height() const {
  return _internal_has_height();
}
inline void BitmapDrawableProto::clear_height() {
  if (height_ != nullptr) height_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::autofill_assistant::ClientDimensionProto& BitmapDrawableProto::_internal_height() const {
  const ::autofill_assistant::ClientDimensionProto* p = height_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::ClientDimensionProto&>(
      ::autofill_assistant::_ClientDimensionProto_default_instance_);
}
inline const ::autofill_assistant::ClientDimensionProto& BitmapDrawableProto::height() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.BitmapDrawableProto.height)
  return _internal_height();
}
inline void BitmapDrawableProto::unsafe_arena_set_allocated_height(
    ::autofill_assistant::ClientDimensionProto* height) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(height_);
  }
  height_ = height;
  if (height) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.BitmapDrawableProto.height)
}
inline ::autofill_assistant::ClientDimensionProto* BitmapDrawableProto::release_height() {
  _has_bits_[0] &= ~0x00000002u;
  ::autofill_assistant::ClientDimensionProto* temp = height_;
  height_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::ClientDimensionProto* BitmapDrawableProto::unsafe_arena_release_height() {
  // @@protoc_insertion_point(field_release:autofill_assistant.BitmapDrawableProto.height)
  _has_bits_[0] &= ~0x00000002u;
  ::autofill_assistant::ClientDimensionProto* temp = height_;
  height_ = nullptr;
  return temp;
}
inline ::autofill_assistant::ClientDimensionProto* BitmapDrawableProto::_internal_mutable_height() {
  _has_bits_[0] |= 0x00000002u;
  if (height_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::ClientDimensionProto>(GetArenaForAllocation());
    height_ = p;
  }
  return height_;
}
inline ::autofill_assistant::ClientDimensionProto* BitmapDrawableProto::mutable_height() {
  ::autofill_assistant::ClientDimensionProto* _msg = _internal_mutable_height();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.BitmapDrawableProto.height)
  return _msg;
}
inline void BitmapDrawableProto::set_allocated_height(::autofill_assistant::ClientDimensionProto* height) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete height_;
  }
  if (height) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(height);
    if (message_arena != submessage_arena) {
      height = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, height, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  height_ = height;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.BitmapDrawableProto.height)
}

// optional bool use_instrinsic_dimensions = 5;
inline bool BitmapDrawableProto::_internal_has_use_instrinsic_dimensions() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool BitmapDrawableProto::has_use_instrinsic_dimensions() const {
  return _internal_has_use_instrinsic_dimensions();
}
inline void BitmapDrawableProto::clear_use_instrinsic_dimensions() {
  use_instrinsic_dimensions_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool BitmapDrawableProto::_internal_use_instrinsic_dimensions() const {
  return use_instrinsic_dimensions_;
}
inline bool BitmapDrawableProto::use_instrinsic_dimensions() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.BitmapDrawableProto.use_instrinsic_dimensions)
  return _internal_use_instrinsic_dimensions();
}
inline void BitmapDrawableProto::_internal_set_use_instrinsic_dimensions(bool value) {
  _has_bits_[0] |= 0x00000004u;
  use_instrinsic_dimensions_ = value;
}
inline void BitmapDrawableProto::set_use_instrinsic_dimensions(bool value) {
  _internal_set_use_instrinsic_dimensions(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.BitmapDrawableProto.use_instrinsic_dimensions)
}

inline bool BitmapDrawableProto::has_image_url() const {
  return image_url_case() != IMAGE_URL_NOT_SET;
}
inline void BitmapDrawableProto::clear_has_image_url() {
  _oneof_case_[0] = IMAGE_URL_NOT_SET;
}
inline BitmapDrawableProto::ImageUrlCase BitmapDrawableProto::image_url_case() const {
  return BitmapDrawableProto::ImageUrlCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// FaviconDrawableProto

// optional .autofill_assistant.ClientDimensionProto diameter_size = 1;
inline bool FaviconDrawableProto::_internal_has_diameter_size() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || diameter_size_ != nullptr);
  return value;
}
inline bool FaviconDrawableProto::has_diameter_size() const {
  return _internal_has_diameter_size();
}
inline void FaviconDrawableProto::clear_diameter_size() {
  if (diameter_size_ != nullptr) diameter_size_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::autofill_assistant::ClientDimensionProto& FaviconDrawableProto::_internal_diameter_size() const {
  const ::autofill_assistant::ClientDimensionProto* p = diameter_size_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::ClientDimensionProto&>(
      ::autofill_assistant::_ClientDimensionProto_default_instance_);
}
inline const ::autofill_assistant::ClientDimensionProto& FaviconDrawableProto::diameter_size() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.FaviconDrawableProto.diameter_size)
  return _internal_diameter_size();
}
inline void FaviconDrawableProto::unsafe_arena_set_allocated_diameter_size(
    ::autofill_assistant::ClientDimensionProto* diameter_size) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(diameter_size_);
  }
  diameter_size_ = diameter_size;
  if (diameter_size) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.FaviconDrawableProto.diameter_size)
}
inline ::autofill_assistant::ClientDimensionProto* FaviconDrawableProto::release_diameter_size() {
  _has_bits_[0] &= ~0x00000002u;
  ::autofill_assistant::ClientDimensionProto* temp = diameter_size_;
  diameter_size_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::ClientDimensionProto* FaviconDrawableProto::unsafe_arena_release_diameter_size() {
  // @@protoc_insertion_point(field_release:autofill_assistant.FaviconDrawableProto.diameter_size)
  _has_bits_[0] &= ~0x00000002u;
  ::autofill_assistant::ClientDimensionProto* temp = diameter_size_;
  diameter_size_ = nullptr;
  return temp;
}
inline ::autofill_assistant::ClientDimensionProto* FaviconDrawableProto::_internal_mutable_diameter_size() {
  _has_bits_[0] |= 0x00000002u;
  if (diameter_size_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::ClientDimensionProto>(GetArenaForAllocation());
    diameter_size_ = p;
  }
  return diameter_size_;
}
inline ::autofill_assistant::ClientDimensionProto* FaviconDrawableProto::mutable_diameter_size() {
  ::autofill_assistant::ClientDimensionProto* _msg = _internal_mutable_diameter_size();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.FaviconDrawableProto.diameter_size)
  return _msg;
}
inline void FaviconDrawableProto::set_allocated_diameter_size(::autofill_assistant::ClientDimensionProto* diameter_size) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete diameter_size_;
  }
  if (diameter_size) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(diameter_size);
    if (message_arena != submessage_arena) {
      diameter_size = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, diameter_size, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  diameter_size_ = diameter_size;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.FaviconDrawableProto.diameter_size)
}

// optional bool force_monogram = 2;
inline bool FaviconDrawableProto::_internal_has_force_monogram() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool FaviconDrawableProto::has_force_monogram() const {
  return _internal_has_force_monogram();
}
inline void FaviconDrawableProto::clear_force_monogram() {
  force_monogram_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool FaviconDrawableProto::_internal_force_monogram() const {
  return force_monogram_;
}
inline bool FaviconDrawableProto::force_monogram() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.FaviconDrawableProto.force_monogram)
  return _internal_force_monogram();
}
inline void FaviconDrawableProto::_internal_set_force_monogram(bool value) {
  _has_bits_[0] |= 0x00000004u;
  force_monogram_ = value;
}
inline void FaviconDrawableProto::set_force_monogram(bool value) {
  _internal_set_force_monogram(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.FaviconDrawableProto.force_monogram)
}

// optional string website_url = 3;
inline bool FaviconDrawableProto::_internal_has_website_url() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool FaviconDrawableProto::has_website_url() const {
  return _internal_has_website_url();
}
inline void FaviconDrawableProto::clear_website_url() {
  website_url_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& FaviconDrawableProto::website_url() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.FaviconDrawableProto.website_url)
  return _internal_website_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FaviconDrawableProto::set_website_url(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 website_url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.FaviconDrawableProto.website_url)
}
inline std::string* FaviconDrawableProto::mutable_website_url() {
  std::string* _s = _internal_mutable_website_url();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.FaviconDrawableProto.website_url)
  return _s;
}
inline const std::string& FaviconDrawableProto::_internal_website_url() const {
  return website_url_.Get();
}
inline void FaviconDrawableProto::_internal_set_website_url(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  website_url_.Set(value, GetArenaForAllocation());
}
inline std::string* FaviconDrawableProto::_internal_mutable_website_url() {
  _has_bits_[0] |= 0x00000001u;
  return website_url_.Mutable(GetArenaForAllocation());
}
inline std::string* FaviconDrawableProto::release_website_url() {
  // @@protoc_insertion_point(field_release:autofill_assistant.FaviconDrawableProto.website_url)
  if (!_internal_has_website_url()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = website_url_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (website_url_.IsDefault()) {
    website_url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void FaviconDrawableProto::set_allocated_website_url(std::string* website_url) {
  if (website_url != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  website_url_.SetAllocated(website_url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (website_url_.IsDefault()) {
    website_url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.FaviconDrawableProto.website_url)
}

// -------------------------------------------------------------------

// DrawableProto

// string resource_identifier = 1;
inline bool DrawableProto::_internal_has_resource_identifier() const {
  return drawable_case() == kResourceIdentifier;
}
inline bool DrawableProto::has_resource_identifier() const {
  return _internal_has_resource_identifier();
}
inline void DrawableProto::set_has_resource_identifier() {
  _oneof_case_[0] = kResourceIdentifier;
}
inline void DrawableProto::clear_resource_identifier() {
  if (_internal_has_resource_identifier()) {
    drawable_.resource_identifier_.Destroy();
    clear_has_drawable();
  }
}
inline const std::string& DrawableProto::resource_identifier() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.DrawableProto.resource_identifier)
  return _internal_resource_identifier();
}
template <typename ArgT0, typename... ArgT>
inline void DrawableProto::set_resource_identifier(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_resource_identifier()) {
    clear_drawable();
    set_has_resource_identifier();
    drawable_.resource_identifier_.InitDefault();
  }
  drawable_.resource_identifier_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.DrawableProto.resource_identifier)
}
inline std::string* DrawableProto::mutable_resource_identifier() {
  std::string* _s = _internal_mutable_resource_identifier();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.DrawableProto.resource_identifier)
  return _s;
}
inline const std::string& DrawableProto::_internal_resource_identifier() const {
  if (_internal_has_resource_identifier()) {
    return drawable_.resource_identifier_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void DrawableProto::_internal_set_resource_identifier(const std::string& value) {
  if (!_internal_has_resource_identifier()) {
    clear_drawable();
    set_has_resource_identifier();
    drawable_.resource_identifier_.InitDefault();
  }
  drawable_.resource_identifier_.Set(value, GetArenaForAllocation());
}
inline std::string* DrawableProto::_internal_mutable_resource_identifier() {
  if (!_internal_has_resource_identifier()) {
    clear_drawable();
    set_has_resource_identifier();
    drawable_.resource_identifier_.InitDefault();
  }
  return drawable_.resource_identifier_.Mutable(      GetArenaForAllocation());
}
inline std::string* DrawableProto::release_resource_identifier() {
  // @@protoc_insertion_point(field_release:autofill_assistant.DrawableProto.resource_identifier)
  if (_internal_has_resource_identifier()) {
    clear_has_drawable();
    return drawable_.resource_identifier_.Release();
  } else {
    return nullptr;
  }
}
inline void DrawableProto::set_allocated_resource_identifier(std::string* resource_identifier) {
  if (has_drawable()) {
    clear_drawable();
  }
  if (resource_identifier != nullptr) {
    set_has_resource_identifier();
    drawable_.resource_identifier_.InitAllocated(resource_identifier, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.DrawableProto.resource_identifier)
}

// .autofill_assistant.BitmapDrawableProto bitmap = 2;
inline bool DrawableProto::_internal_has_bitmap() const {
  return drawable_case() == kBitmap;
}
inline bool DrawableProto::has_bitmap() const {
  return _internal_has_bitmap();
}
inline void DrawableProto::set_has_bitmap() {
  _oneof_case_[0] = kBitmap;
}
inline void DrawableProto::clear_bitmap() {
  if (_internal_has_bitmap()) {
    if (GetArenaForAllocation() == nullptr) {
      delete drawable_.bitmap_;
    }
    clear_has_drawable();
  }
}
inline ::autofill_assistant::BitmapDrawableProto* DrawableProto::release_bitmap() {
  // @@protoc_insertion_point(field_release:autofill_assistant.DrawableProto.bitmap)
  if (_internal_has_bitmap()) {
    clear_has_drawable();
    ::autofill_assistant::BitmapDrawableProto* temp = drawable_.bitmap_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    drawable_.bitmap_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::BitmapDrawableProto& DrawableProto::_internal_bitmap() const {
  return _internal_has_bitmap()
      ? *drawable_.bitmap_
      : reinterpret_cast< ::autofill_assistant::BitmapDrawableProto&>(::autofill_assistant::_BitmapDrawableProto_default_instance_);
}
inline const ::autofill_assistant::BitmapDrawableProto& DrawableProto::bitmap() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.DrawableProto.bitmap)
  return _internal_bitmap();
}
inline ::autofill_assistant::BitmapDrawableProto* DrawableProto::unsafe_arena_release_bitmap() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.DrawableProto.bitmap)
  if (_internal_has_bitmap()) {
    clear_has_drawable();
    ::autofill_assistant::BitmapDrawableProto* temp = drawable_.bitmap_;
    drawable_.bitmap_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DrawableProto::unsafe_arena_set_allocated_bitmap(::autofill_assistant::BitmapDrawableProto* bitmap) {
  clear_drawable();
  if (bitmap) {
    set_has_bitmap();
    drawable_.bitmap_ = bitmap;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.DrawableProto.bitmap)
}
inline ::autofill_assistant::BitmapDrawableProto* DrawableProto::_internal_mutable_bitmap() {
  if (!_internal_has_bitmap()) {
    clear_drawable();
    set_has_bitmap();
    drawable_.bitmap_ = CreateMaybeMessage< ::autofill_assistant::BitmapDrawableProto >(GetArenaForAllocation());
  }
  return drawable_.bitmap_;
}
inline ::autofill_assistant::BitmapDrawableProto* DrawableProto::mutable_bitmap() {
  ::autofill_assistant::BitmapDrawableProto* _msg = _internal_mutable_bitmap();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.DrawableProto.bitmap)
  return _msg;
}

// .autofill_assistant.ShapeDrawableProto shape = 3;
inline bool DrawableProto::_internal_has_shape() const {
  return drawable_case() == kShape;
}
inline bool DrawableProto::has_shape() const {
  return _internal_has_shape();
}
inline void DrawableProto::set_has_shape() {
  _oneof_case_[0] = kShape;
}
inline void DrawableProto::clear_shape() {
  if (_internal_has_shape()) {
    if (GetArenaForAllocation() == nullptr) {
      delete drawable_.shape_;
    }
    clear_has_drawable();
  }
}
inline ::autofill_assistant::ShapeDrawableProto* DrawableProto::release_shape() {
  // @@protoc_insertion_point(field_release:autofill_assistant.DrawableProto.shape)
  if (_internal_has_shape()) {
    clear_has_drawable();
    ::autofill_assistant::ShapeDrawableProto* temp = drawable_.shape_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    drawable_.shape_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::ShapeDrawableProto& DrawableProto::_internal_shape() const {
  return _internal_has_shape()
      ? *drawable_.shape_
      : reinterpret_cast< ::autofill_assistant::ShapeDrawableProto&>(::autofill_assistant::_ShapeDrawableProto_default_instance_);
}
inline const ::autofill_assistant::ShapeDrawableProto& DrawableProto::shape() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.DrawableProto.shape)
  return _internal_shape();
}
inline ::autofill_assistant::ShapeDrawableProto* DrawableProto::unsafe_arena_release_shape() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.DrawableProto.shape)
  if (_internal_has_shape()) {
    clear_has_drawable();
    ::autofill_assistant::ShapeDrawableProto* temp = drawable_.shape_;
    drawable_.shape_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DrawableProto::unsafe_arena_set_allocated_shape(::autofill_assistant::ShapeDrawableProto* shape) {
  clear_drawable();
  if (shape) {
    set_has_shape();
    drawable_.shape_ = shape;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.DrawableProto.shape)
}
inline ::autofill_assistant::ShapeDrawableProto* DrawableProto::_internal_mutable_shape() {
  if (!_internal_has_shape()) {
    clear_drawable();
    set_has_shape();
    drawable_.shape_ = CreateMaybeMessage< ::autofill_assistant::ShapeDrawableProto >(GetArenaForAllocation());
  }
  return drawable_.shape_;
}
inline ::autofill_assistant::ShapeDrawableProto* DrawableProto::mutable_shape() {
  ::autofill_assistant::ShapeDrawableProto* _msg = _internal_mutable_shape();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.DrawableProto.shape)
  return _msg;
}

// .autofill_assistant.DrawableProto.Icon icon = 4;
inline bool DrawableProto::_internal_has_icon() const {
  return drawable_case() == kIcon;
}
inline bool DrawableProto::has_icon() const {
  return _internal_has_icon();
}
inline void DrawableProto::set_has_icon() {
  _oneof_case_[0] = kIcon;
}
inline void DrawableProto::clear_icon() {
  if (_internal_has_icon()) {
    drawable_.icon_ = 0;
    clear_has_drawable();
  }
}
inline ::autofill_assistant::DrawableProto_Icon DrawableProto::_internal_icon() const {
  if (_internal_has_icon()) {
    return static_cast< ::autofill_assistant::DrawableProto_Icon >(drawable_.icon_);
  }
  return static_cast< ::autofill_assistant::DrawableProto_Icon >(0);
}
inline ::autofill_assistant::DrawableProto_Icon DrawableProto::icon() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.DrawableProto.icon)
  return _internal_icon();
}
inline void DrawableProto::_internal_set_icon(::autofill_assistant::DrawableProto_Icon value) {
  assert(::autofill_assistant::DrawableProto_Icon_IsValid(value));
  if (!_internal_has_icon()) {
    clear_drawable();
    set_has_icon();
  }
  drawable_.icon_ = value;
}
inline void DrawableProto::set_icon(::autofill_assistant::DrawableProto_Icon value) {
  _internal_set_icon(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.DrawableProto.icon)
}

// bytes image_data = 5;
inline bool DrawableProto::_internal_has_image_data() const {
  return drawable_case() == kImageData;
}
inline bool DrawableProto::has_image_data() const {
  return _internal_has_image_data();
}
inline void DrawableProto::set_has_image_data() {
  _oneof_case_[0] = kImageData;
}
inline void DrawableProto::clear_image_data() {
  if (_internal_has_image_data()) {
    drawable_.image_data_.Destroy();
    clear_has_drawable();
  }
}
inline const std::string& DrawableProto::image_data() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.DrawableProto.image_data)
  return _internal_image_data();
}
template <typename ArgT0, typename... ArgT>
inline void DrawableProto::set_image_data(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_image_data()) {
    clear_drawable();
    set_has_image_data();
    drawable_.image_data_.InitDefault();
  }
  drawable_.image_data_.SetBytes( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.DrawableProto.image_data)
}
inline std::string* DrawableProto::mutable_image_data() {
  std::string* _s = _internal_mutable_image_data();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.DrawableProto.image_data)
  return _s;
}
inline const std::string& DrawableProto::_internal_image_data() const {
  if (_internal_has_image_data()) {
    return drawable_.image_data_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void DrawableProto::_internal_set_image_data(const std::string& value) {
  if (!_internal_has_image_data()) {
    clear_drawable();
    set_has_image_data();
    drawable_.image_data_.InitDefault();
  }
  drawable_.image_data_.Set(value, GetArenaForAllocation());
}
inline std::string* DrawableProto::_internal_mutable_image_data() {
  if (!_internal_has_image_data()) {
    clear_drawable();
    set_has_image_data();
    drawable_.image_data_.InitDefault();
  }
  return drawable_.image_data_.Mutable(      GetArenaForAllocation());
}
inline std::string* DrawableProto::release_image_data() {
  // @@protoc_insertion_point(field_release:autofill_assistant.DrawableProto.image_data)
  if (_internal_has_image_data()) {
    clear_has_drawable();
    return drawable_.image_data_.Release();
  } else {
    return nullptr;
  }
}
inline void DrawableProto::set_allocated_image_data(std::string* image_data) {
  if (has_drawable()) {
    clear_drawable();
  }
  if (image_data != nullptr) {
    set_has_image_data();
    drawable_.image_data_.InitAllocated(image_data, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.DrawableProto.image_data)
}

// string image_data_base64 = 7;
inline bool DrawableProto::_internal_has_image_data_base64() const {
  return drawable_case() == kImageDataBase64;
}
inline bool DrawableProto::has_image_data_base64() const {
  return _internal_has_image_data_base64();
}
inline void DrawableProto::set_has_image_data_base64() {
  _oneof_case_[0] = kImageDataBase64;
}
inline void DrawableProto::clear_image_data_base64() {
  if (_internal_has_image_data_base64()) {
    drawable_.image_data_base64_.Destroy();
    clear_has_drawable();
  }
}
inline const std::string& DrawableProto::image_data_base64() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.DrawableProto.image_data_base64)
  return _internal_image_data_base64();
}
template <typename ArgT0, typename... ArgT>
inline void DrawableProto::set_image_data_base64(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_image_data_base64()) {
    clear_drawable();
    set_has_image_data_base64();
    drawable_.image_data_base64_.InitDefault();
  }
  drawable_.image_data_base64_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.DrawableProto.image_data_base64)
}
inline std::string* DrawableProto::mutable_image_data_base64() {
  std::string* _s = _internal_mutable_image_data_base64();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.DrawableProto.image_data_base64)
  return _s;
}
inline const std::string& DrawableProto::_internal_image_data_base64() const {
  if (_internal_has_image_data_base64()) {
    return drawable_.image_data_base64_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void DrawableProto::_internal_set_image_data_base64(const std::string& value) {
  if (!_internal_has_image_data_base64()) {
    clear_drawable();
    set_has_image_data_base64();
    drawable_.image_data_base64_.InitDefault();
  }
  drawable_.image_data_base64_.Set(value, GetArenaForAllocation());
}
inline std::string* DrawableProto::_internal_mutable_image_data_base64() {
  if (!_internal_has_image_data_base64()) {
    clear_drawable();
    set_has_image_data_base64();
    drawable_.image_data_base64_.InitDefault();
  }
  return drawable_.image_data_base64_.Mutable(      GetArenaForAllocation());
}
inline std::string* DrawableProto::release_image_data_base64() {
  // @@protoc_insertion_point(field_release:autofill_assistant.DrawableProto.image_data_base64)
  if (_internal_has_image_data_base64()) {
    clear_has_drawable();
    return drawable_.image_data_base64_.Release();
  } else {
    return nullptr;
  }
}
inline void DrawableProto::set_allocated_image_data_base64(std::string* image_data_base64) {
  if (has_drawable()) {
    clear_drawable();
  }
  if (image_data_base64 != nullptr) {
    set_has_image_data_base64();
    drawable_.image_data_base64_.InitAllocated(image_data_base64, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.DrawableProto.image_data_base64)
}

// .autofill_assistant.FaviconDrawableProto favicon = 6;
inline bool DrawableProto::_internal_has_favicon() const {
  return drawable_case() == kFavicon;
}
inline bool DrawableProto::has_favicon() const {
  return _internal_has_favicon();
}
inline void DrawableProto::set_has_favicon() {
  _oneof_case_[0] = kFavicon;
}
inline void DrawableProto::clear_favicon() {
  if (_internal_has_favicon()) {
    if (GetArenaForAllocation() == nullptr) {
      delete drawable_.favicon_;
    }
    clear_has_drawable();
  }
}
inline ::autofill_assistant::FaviconDrawableProto* DrawableProto::release_favicon() {
  // @@protoc_insertion_point(field_release:autofill_assistant.DrawableProto.favicon)
  if (_internal_has_favicon()) {
    clear_has_drawable();
    ::autofill_assistant::FaviconDrawableProto* temp = drawable_.favicon_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    drawable_.favicon_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::FaviconDrawableProto& DrawableProto::_internal_favicon() const {
  return _internal_has_favicon()
      ? *drawable_.favicon_
      : reinterpret_cast< ::autofill_assistant::FaviconDrawableProto&>(::autofill_assistant::_FaviconDrawableProto_default_instance_);
}
inline const ::autofill_assistant::FaviconDrawableProto& DrawableProto::favicon() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.DrawableProto.favicon)
  return _internal_favicon();
}
inline ::autofill_assistant::FaviconDrawableProto* DrawableProto::unsafe_arena_release_favicon() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.DrawableProto.favicon)
  if (_internal_has_favicon()) {
    clear_has_drawable();
    ::autofill_assistant::FaviconDrawableProto* temp = drawable_.favicon_;
    drawable_.favicon_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DrawableProto::unsafe_arena_set_allocated_favicon(::autofill_assistant::FaviconDrawableProto* favicon) {
  clear_drawable();
  if (favicon) {
    set_has_favicon();
    drawable_.favicon_ = favicon;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.DrawableProto.favicon)
}
inline ::autofill_assistant::FaviconDrawableProto* DrawableProto::_internal_mutable_favicon() {
  if (!_internal_has_favicon()) {
    clear_drawable();
    set_has_favicon();
    drawable_.favicon_ = CreateMaybeMessage< ::autofill_assistant::FaviconDrawableProto >(GetArenaForAllocation());
  }
  return drawable_.favicon_;
}
inline ::autofill_assistant::FaviconDrawableProto* DrawableProto::mutable_favicon() {
  ::autofill_assistant::FaviconDrawableProto* _msg = _internal_mutable_favicon();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.DrawableProto.favicon)
  return _msg;
}

inline bool DrawableProto::has_drawable() const {
  return drawable_case() != DRAWABLE_NOT_SET;
}
inline void DrawableProto::clear_has_drawable() {
  _oneof_case_[0] = DRAWABLE_NOT_SET;
}
inline DrawableProto::DrawableCase DrawableProto::drawable_case() const {
  return DrawableProto::DrawableCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ViewAttributesProto

// optional int32 padding_start = 1;
inline bool ViewAttributesProto::_internal_has_padding_start() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ViewAttributesProto::has_padding_start() const {
  return _internal_has_padding_start();
}
inline void ViewAttributesProto::clear_padding_start() {
  padding_start_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline int32_t ViewAttributesProto::_internal_padding_start() const {
  return padding_start_;
}
inline int32_t ViewAttributesProto::padding_start() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ViewAttributesProto.padding_start)
  return _internal_padding_start();
}
inline void ViewAttributesProto::_internal_set_padding_start(int32_t value) {
  _has_bits_[0] |= 0x00000004u;
  padding_start_ = value;
}
inline void ViewAttributesProto::set_padding_start(int32_t value) {
  _internal_set_padding_start(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.ViewAttributesProto.padding_start)
}

// optional int32 padding_top = 2;
inline bool ViewAttributesProto::_internal_has_padding_top() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ViewAttributesProto::has_padding_top() const {
  return _internal_has_padding_top();
}
inline void ViewAttributesProto::clear_padding_top() {
  padding_top_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline int32_t ViewAttributesProto::_internal_padding_top() const {
  return padding_top_;
}
inline int32_t ViewAttributesProto::padding_top() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ViewAttributesProto.padding_top)
  return _internal_padding_top();
}
inline void ViewAttributesProto::_internal_set_padding_top(int32_t value) {
  _has_bits_[0] |= 0x00000008u;
  padding_top_ = value;
}
inline void ViewAttributesProto::set_padding_top(int32_t value) {
  _internal_set_padding_top(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.ViewAttributesProto.padding_top)
}

// optional int32 padding_end = 3;
inline bool ViewAttributesProto::_internal_has_padding_end() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ViewAttributesProto::has_padding_end() const {
  return _internal_has_padding_end();
}
inline void ViewAttributesProto::clear_padding_end() {
  padding_end_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline int32_t ViewAttributesProto::_internal_padding_end() const {
  return padding_end_;
}
inline int32_t ViewAttributesProto::padding_end() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ViewAttributesProto.padding_end)
  return _internal_padding_end();
}
inline void ViewAttributesProto::_internal_set_padding_end(int32_t value) {
  _has_bits_[0] |= 0x00000010u;
  padding_end_ = value;
}
inline void ViewAttributesProto::set_padding_end(int32_t value) {
  _internal_set_padding_end(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.ViewAttributesProto.padding_end)
}

// optional int32 padding_bottom = 4;
inline bool ViewAttributesProto::_internal_has_padding_bottom() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool ViewAttributesProto::has_padding_bottom() const {
  return _internal_has_padding_bottom();
}
inline void ViewAttributesProto::clear_padding_bottom() {
  padding_bottom_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline int32_t ViewAttributesProto::_internal_padding_bottom() const {
  return padding_bottom_;
}
inline int32_t ViewAttributesProto::padding_bottom() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ViewAttributesProto.padding_bottom)
  return _internal_padding_bottom();
}
inline void ViewAttributesProto::_internal_set_padding_bottom(int32_t value) {
  _has_bits_[0] |= 0x00000020u;
  padding_bottom_ = value;
}
inline void ViewAttributesProto::set_padding_bottom(int32_t value) {
  _internal_set_padding_bottom(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.ViewAttributesProto.padding_bottom)
}

// optional .autofill_assistant.DrawableProto background = 5;
inline bool ViewAttributesProto::_internal_has_background() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || background_ != nullptr);
  return value;
}
inline bool ViewAttributesProto::has_background() const {
  return _internal_has_background();
}
inline void ViewAttributesProto::clear_background() {
  if (background_ != nullptr) background_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::autofill_assistant::DrawableProto& ViewAttributesProto::_internal_background() const {
  const ::autofill_assistant::DrawableProto* p = background_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::DrawableProto&>(
      ::autofill_assistant::_DrawableProto_default_instance_);
}
inline const ::autofill_assistant::DrawableProto& ViewAttributesProto::background() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ViewAttributesProto.background)
  return _internal_background();
}
inline void ViewAttributesProto::unsafe_arena_set_allocated_background(
    ::autofill_assistant::DrawableProto* background) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(background_);
  }
  background_ = background;
  if (background) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ViewAttributesProto.background)
}
inline ::autofill_assistant::DrawableProto* ViewAttributesProto::release_background() {
  _has_bits_[0] &= ~0x00000002u;
  ::autofill_assistant::DrawableProto* temp = background_;
  background_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::DrawableProto* ViewAttributesProto::unsafe_arena_release_background() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ViewAttributesProto.background)
  _has_bits_[0] &= ~0x00000002u;
  ::autofill_assistant::DrawableProto* temp = background_;
  background_ = nullptr;
  return temp;
}
inline ::autofill_assistant::DrawableProto* ViewAttributesProto::_internal_mutable_background() {
  _has_bits_[0] |= 0x00000002u;
  if (background_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::DrawableProto>(GetArenaForAllocation());
    background_ = p;
  }
  return background_;
}
inline ::autofill_assistant::DrawableProto* ViewAttributesProto::mutable_background() {
  ::autofill_assistant::DrawableProto* _msg = _internal_mutable_background();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ViewAttributesProto.background)
  return _msg;
}
inline void ViewAttributesProto::set_allocated_background(::autofill_assistant::DrawableProto* background) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete background_;
  }
  if (background) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(background);
    if (message_arena != submessage_arena) {
      background = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, background, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  background_ = background;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ViewAttributesProto.background)
}

// optional string content_description = 6;
inline bool ViewAttributesProto::_internal_has_content_description() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ViewAttributesProto::has_content_description() const {
  return _internal_has_content_description();
}
inline void ViewAttributesProto::clear_content_description() {
  content_description_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ViewAttributesProto::content_description() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ViewAttributesProto.content_description)
  return _internal_content_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ViewAttributesProto::set_content_description(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 content_description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.ViewAttributesProto.content_description)
}
inline std::string* ViewAttributesProto::mutable_content_description() {
  std::string* _s = _internal_mutable_content_description();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ViewAttributesProto.content_description)
  return _s;
}
inline const std::string& ViewAttributesProto::_internal_content_description() const {
  return content_description_.Get();
}
inline void ViewAttributesProto::_internal_set_content_description(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  content_description_.Set(value, GetArenaForAllocation());
}
inline std::string* ViewAttributesProto::_internal_mutable_content_description() {
  _has_bits_[0] |= 0x00000001u;
  return content_description_.Mutable(GetArenaForAllocation());
}
inline std::string* ViewAttributesProto::release_content_description() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ViewAttributesProto.content_description)
  if (!_internal_has_content_description()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = content_description_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (content_description_.IsDefault()) {
    content_description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ViewAttributesProto::set_allocated_content_description(std::string* content_description) {
  if (content_description != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  content_description_.SetAllocated(content_description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (content_description_.IsDefault()) {
    content_description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ViewAttributesProto.content_description)
}

// optional bool visible = 7 [default = true];
inline bool ViewAttributesProto::_internal_has_visible() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool ViewAttributesProto::has_visible() const {
  return _internal_has_visible();
}
inline void ViewAttributesProto::clear_visible() {
  visible_ = true;
  _has_bits_[0] &= ~0x00000040u;
}
inline bool ViewAttributesProto::_internal_visible() const {
  return visible_;
}
inline bool ViewAttributesProto::visible() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ViewAttributesProto.visible)
  return _internal_visible();
}
inline void ViewAttributesProto::_internal_set_visible(bool value) {
  _has_bits_[0] |= 0x00000040u;
  visible_ = value;
}
inline void ViewAttributesProto::set_visible(bool value) {
  _internal_set_visible(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.ViewAttributesProto.visible)
}

// optional bool enabled = 8 [default = true];
inline bool ViewAttributesProto::_internal_has_enabled() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool ViewAttributesProto::has_enabled() const {
  return _internal_has_enabled();
}
inline void ViewAttributesProto::clear_enabled() {
  enabled_ = true;
  _has_bits_[0] &= ~0x00000080u;
}
inline bool ViewAttributesProto::_internal_enabled() const {
  return enabled_;
}
inline bool ViewAttributesProto::enabled() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ViewAttributesProto.enabled)
  return _internal_enabled();
}
inline void ViewAttributesProto::_internal_set_enabled(bool value) {
  _has_bits_[0] |= 0x00000080u;
  enabled_ = value;
}
inline void ViewAttributesProto::set_enabled(bool value) {
  _internal_set_enabled(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.ViewAttributesProto.enabled)
}

// -------------------------------------------------------------------

// ViewLayoutParamsProto

// optional int32 layout_width = 1 [default = -2];
inline bool ViewLayoutParamsProto::_internal_has_layout_width() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool ViewLayoutParamsProto::has_layout_width() const {
  return _internal_has_layout_width();
}
inline void ViewLayoutParamsProto::clear_layout_width() {
  layout_width_ = -2;
  _has_bits_[0] &= ~0x00000100u;
}
inline int32_t ViewLayoutParamsProto::_internal_layout_width() const {
  return layout_width_;
}
inline int32_t ViewLayoutParamsProto::layout_width() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ViewLayoutParamsProto.layout_width)
  return _internal_layout_width();
}
inline void ViewLayoutParamsProto::_internal_set_layout_width(int32_t value) {
  _has_bits_[0] |= 0x00000100u;
  layout_width_ = value;
}
inline void ViewLayoutParamsProto::set_layout_width(int32_t value) {
  _internal_set_layout_width(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.ViewLayoutParamsProto.layout_width)
}

// optional int32 layout_height = 2 [default = -2];
inline bool ViewLayoutParamsProto::_internal_has_layout_height() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool ViewLayoutParamsProto::has_layout_height() const {
  return _internal_has_layout_height();
}
inline void ViewLayoutParamsProto::clear_layout_height() {
  layout_height_ = -2;
  _has_bits_[0] &= ~0x00000200u;
}
inline int32_t ViewLayoutParamsProto::_internal_layout_height() const {
  return layout_height_;
}
inline int32_t ViewLayoutParamsProto::layout_height() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ViewLayoutParamsProto.layout_height)
  return _internal_layout_height();
}
inline void ViewLayoutParamsProto::_internal_set_layout_height(int32_t value) {
  _has_bits_[0] |= 0x00000200u;
  layout_height_ = value;
}
inline void ViewLayoutParamsProto::set_layout_height(int32_t value) {
  _internal_set_layout_height(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.ViewLayoutParamsProto.layout_height)
}

// optional float layout_weight = 8;
inline bool ViewLayoutParamsProto::_internal_has_layout_weight() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool ViewLayoutParamsProto::has_layout_weight() const {
  return _internal_has_layout_weight();
}
inline void ViewLayoutParamsProto::clear_layout_weight() {
  layout_weight_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline float ViewLayoutParamsProto::_internal_layout_weight() const {
  return layout_weight_;
}
inline float ViewLayoutParamsProto::layout_weight() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ViewLayoutParamsProto.layout_weight)
  return _internal_layout_weight();
}
inline void ViewLayoutParamsProto::_internal_set_layout_weight(float value) {
  _has_bits_[0] |= 0x00000020u;
  layout_weight_ = value;
}
inline void ViewLayoutParamsProto::set_layout_weight(float value) {
  _internal_set_layout_weight(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.ViewLayoutParamsProto.layout_weight)
}

// optional int32 margin_start = 3;
inline bool ViewLayoutParamsProto::_internal_has_margin_start() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ViewLayoutParamsProto::has_margin_start() const {
  return _internal_has_margin_start();
}
inline void ViewLayoutParamsProto::clear_margin_start() {
  margin_start_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline int32_t ViewLayoutParamsProto::_internal_margin_start() const {
  return margin_start_;
}
inline int32_t ViewLayoutParamsProto::margin_start() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ViewLayoutParamsProto.margin_start)
  return _internal_margin_start();
}
inline void ViewLayoutParamsProto::_internal_set_margin_start(int32_t value) {
  _has_bits_[0] |= 0x00000001u;
  margin_start_ = value;
}
inline void ViewLayoutParamsProto::set_margin_start(int32_t value) {
  _internal_set_margin_start(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.ViewLayoutParamsProto.margin_start)
}

// optional int32 margin_top = 4;
inline bool ViewLayoutParamsProto::_internal_has_margin_top() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ViewLayoutParamsProto::has_margin_top() const {
  return _internal_has_margin_top();
}
inline void ViewLayoutParamsProto::clear_margin_top() {
  margin_top_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline int32_t ViewLayoutParamsProto::_internal_margin_top() const {
  return margin_top_;
}
inline int32_t ViewLayoutParamsProto::margin_top() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ViewLayoutParamsProto.margin_top)
  return _internal_margin_top();
}
inline void ViewLayoutParamsProto::_internal_set_margin_top(int32_t value) {
  _has_bits_[0] |= 0x00000002u;
  margin_top_ = value;
}
inline void ViewLayoutParamsProto::set_margin_top(int32_t value) {
  _internal_set_margin_top(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.ViewLayoutParamsProto.margin_top)
}

// optional int32 margin_end = 5;
inline bool ViewLayoutParamsProto::_internal_has_margin_end() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ViewLayoutParamsProto::has_margin_end() const {
  return _internal_has_margin_end();
}
inline void ViewLayoutParamsProto::clear_margin_end() {
  margin_end_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline int32_t ViewLayoutParamsProto::_internal_margin_end() const {
  return margin_end_;
}
inline int32_t ViewLayoutParamsProto::margin_end() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ViewLayoutParamsProto.margin_end)
  return _internal_margin_end();
}
inline void ViewLayoutParamsProto::_internal_set_margin_end(int32_t value) {
  _has_bits_[0] |= 0x00000004u;
  margin_end_ = value;
}
inline void ViewLayoutParamsProto::set_margin_end(int32_t value) {
  _internal_set_margin_end(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.ViewLayoutParamsProto.margin_end)
}

// optional int32 margin_bottom = 6;
inline bool ViewLayoutParamsProto::_internal_has_margin_bottom() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ViewLayoutParamsProto::has_margin_bottom() const {
  return _internal_has_margin_bottom();
}
inline void ViewLayoutParamsProto::clear_margin_bottom() {
  margin_bottom_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline int32_t ViewLayoutParamsProto::_internal_margin_bottom() const {
  return margin_bottom_;
}
inline int32_t ViewLayoutParamsProto::margin_bottom() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ViewLayoutParamsProto.margin_bottom)
  return _internal_margin_bottom();
}
inline void ViewLayoutParamsProto::_internal_set_margin_bottom(int32_t value) {
  _has_bits_[0] |= 0x00000008u;
  margin_bottom_ = value;
}
inline void ViewLayoutParamsProto::set_margin_bottom(int32_t value) {
  _internal_set_margin_bottom(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.ViewLayoutParamsProto.margin_bottom)
}

// optional int32 layout_gravity = 7;
inline bool ViewLayoutParamsProto::_internal_has_layout_gravity() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ViewLayoutParamsProto::has_layout_gravity() const {
  return _internal_has_layout_gravity();
}
inline void ViewLayoutParamsProto::clear_layout_gravity() {
  layout_gravity_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline int32_t ViewLayoutParamsProto::_internal_layout_gravity() const {
  return layout_gravity_;
}
inline int32_t ViewLayoutParamsProto::layout_gravity() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ViewLayoutParamsProto.layout_gravity)
  return _internal_layout_gravity();
}
inline void ViewLayoutParamsProto::_internal_set_layout_gravity(int32_t value) {
  _has_bits_[0] |= 0x00000010u;
  layout_gravity_ = value;
}
inline void ViewLayoutParamsProto::set_layout_gravity(int32_t value) {
  _internal_set_layout_gravity(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.ViewLayoutParamsProto.layout_gravity)
}

// optional int32 minimum_width = 9;
inline bool ViewLayoutParamsProto::_internal_has_minimum_width() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool ViewLayoutParamsProto::has_minimum_width() const {
  return _internal_has_minimum_width();
}
inline void ViewLayoutParamsProto::clear_minimum_width() {
  minimum_width_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline int32_t ViewLayoutParamsProto::_internal_minimum_width() const {
  return minimum_width_;
}
inline int32_t ViewLayoutParamsProto::minimum_width() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ViewLayoutParamsProto.minimum_width)
  return _internal_minimum_width();
}
inline void ViewLayoutParamsProto::_internal_set_minimum_width(int32_t value) {
  _has_bits_[0] |= 0x00000040u;
  minimum_width_ = value;
}
inline void ViewLayoutParamsProto::set_minimum_width(int32_t value) {
  _internal_set_minimum_width(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.ViewLayoutParamsProto.minimum_width)
}

// optional int32 minimum_height = 10;
inline bool ViewLayoutParamsProto::_internal_has_minimum_height() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool ViewLayoutParamsProto::has_minimum_height() const {
  return _internal_has_minimum_height();
}
inline void ViewLayoutParamsProto::clear_minimum_height() {
  minimum_height_ = 0;
  _has_bits_[0] &= ~0x00000080u;
}
inline int32_t ViewLayoutParamsProto::_internal_minimum_height() const {
  return minimum_height_;
}
inline int32_t ViewLayoutParamsProto::minimum_height() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ViewLayoutParamsProto.minimum_height)
  return _internal_minimum_height();
}
inline void ViewLayoutParamsProto::_internal_set_minimum_height(int32_t value) {
  _has_bits_[0] |= 0x00000080u;
  minimum_height_ = value;
}
inline void ViewLayoutParamsProto::set_minimum_height(int32_t value) {
  _internal_set_minimum_height(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.ViewLayoutParamsProto.minimum_height)
}

// -------------------------------------------------------------------

// ViewContainerProto

// repeated .autofill_assistant.ViewProto views = 1;
inline int ViewContainerProto::_internal_views_size() const {
  return views_.size();
}
inline int ViewContainerProto::views_size() const {
  return _internal_views_size();
}
inline void ViewContainerProto::clear_views() {
  views_.Clear();
}
inline ::autofill_assistant::ViewProto* ViewContainerProto::mutable_views(int index) {
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ViewContainerProto.views)
  return views_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::ViewProto >*
ViewContainerProto::mutable_views() {
  // @@protoc_insertion_point(field_mutable_list:autofill_assistant.ViewContainerProto.views)
  return &views_;
}
inline const ::autofill_assistant::ViewProto& ViewContainerProto::_internal_views(int index) const {
  return views_.Get(index);
}
inline const ::autofill_assistant::ViewProto& ViewContainerProto::views(int index) const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ViewContainerProto.views)
  return _internal_views(index);
}
inline ::autofill_assistant::ViewProto* ViewContainerProto::_internal_add_views() {
  return views_.Add();
}
inline ::autofill_assistant::ViewProto* ViewContainerProto::add_views() {
  ::autofill_assistant::ViewProto* _add = _internal_add_views();
  // @@protoc_insertion_point(field_add:autofill_assistant.ViewContainerProto.views)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill_assistant::ViewProto >&
ViewContainerProto::views() const {
  // @@protoc_insertion_point(field_list:autofill_assistant.ViewContainerProto.views)
  return views_;
}

// .autofill_assistant.LinearLayoutProto linear_layout = 2;
inline bool ViewContainerProto::_internal_has_linear_layout() const {
  return container_case() == kLinearLayout;
}
inline bool ViewContainerProto::has_linear_layout() const {
  return _internal_has_linear_layout();
}
inline void ViewContainerProto::set_has_linear_layout() {
  _oneof_case_[0] = kLinearLayout;
}
inline void ViewContainerProto::clear_linear_layout() {
  if (_internal_has_linear_layout()) {
    if (GetArenaForAllocation() == nullptr) {
      delete container_.linear_layout_;
    }
    clear_has_container();
  }
}
inline ::autofill_assistant::LinearLayoutProto* ViewContainerProto::release_linear_layout() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ViewContainerProto.linear_layout)
  if (_internal_has_linear_layout()) {
    clear_has_container();
    ::autofill_assistant::LinearLayoutProto* temp = container_.linear_layout_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    container_.linear_layout_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::LinearLayoutProto& ViewContainerProto::_internal_linear_layout() const {
  return _internal_has_linear_layout()
      ? *container_.linear_layout_
      : reinterpret_cast< ::autofill_assistant::LinearLayoutProto&>(::autofill_assistant::_LinearLayoutProto_default_instance_);
}
inline const ::autofill_assistant::LinearLayoutProto& ViewContainerProto::linear_layout() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ViewContainerProto.linear_layout)
  return _internal_linear_layout();
}
inline ::autofill_assistant::LinearLayoutProto* ViewContainerProto::unsafe_arena_release_linear_layout() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.ViewContainerProto.linear_layout)
  if (_internal_has_linear_layout()) {
    clear_has_container();
    ::autofill_assistant::LinearLayoutProto* temp = container_.linear_layout_;
    container_.linear_layout_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ViewContainerProto::unsafe_arena_set_allocated_linear_layout(::autofill_assistant::LinearLayoutProto* linear_layout) {
  clear_container();
  if (linear_layout) {
    set_has_linear_layout();
    container_.linear_layout_ = linear_layout;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ViewContainerProto.linear_layout)
}
inline ::autofill_assistant::LinearLayoutProto* ViewContainerProto::_internal_mutable_linear_layout() {
  if (!_internal_has_linear_layout()) {
    clear_container();
    set_has_linear_layout();
    container_.linear_layout_ = CreateMaybeMessage< ::autofill_assistant::LinearLayoutProto >(GetArenaForAllocation());
  }
  return container_.linear_layout_;
}
inline ::autofill_assistant::LinearLayoutProto* ViewContainerProto::mutable_linear_layout() {
  ::autofill_assistant::LinearLayoutProto* _msg = _internal_mutable_linear_layout();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ViewContainerProto.linear_layout)
  return _msg;
}

// .autofill_assistant.VerticalExpanderAccordionProto expander_accordion = 3;
inline bool ViewContainerProto::_internal_has_expander_accordion() const {
  return container_case() == kExpanderAccordion;
}
inline bool ViewContainerProto::has_expander_accordion() const {
  return _internal_has_expander_accordion();
}
inline void ViewContainerProto::set_has_expander_accordion() {
  _oneof_case_[0] = kExpanderAccordion;
}
inline void ViewContainerProto::clear_expander_accordion() {
  if (_internal_has_expander_accordion()) {
    if (GetArenaForAllocation() == nullptr) {
      delete container_.expander_accordion_;
    }
    clear_has_container();
  }
}
inline ::autofill_assistant::VerticalExpanderAccordionProto* ViewContainerProto::release_expander_accordion() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ViewContainerProto.expander_accordion)
  if (_internal_has_expander_accordion()) {
    clear_has_container();
    ::autofill_assistant::VerticalExpanderAccordionProto* temp = container_.expander_accordion_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    container_.expander_accordion_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::VerticalExpanderAccordionProto& ViewContainerProto::_internal_expander_accordion() const {
  return _internal_has_expander_accordion()
      ? *container_.expander_accordion_
      : reinterpret_cast< ::autofill_assistant::VerticalExpanderAccordionProto&>(::autofill_assistant::_VerticalExpanderAccordionProto_default_instance_);
}
inline const ::autofill_assistant::VerticalExpanderAccordionProto& ViewContainerProto::expander_accordion() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ViewContainerProto.expander_accordion)
  return _internal_expander_accordion();
}
inline ::autofill_assistant::VerticalExpanderAccordionProto* ViewContainerProto::unsafe_arena_release_expander_accordion() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.ViewContainerProto.expander_accordion)
  if (_internal_has_expander_accordion()) {
    clear_has_container();
    ::autofill_assistant::VerticalExpanderAccordionProto* temp = container_.expander_accordion_;
    container_.expander_accordion_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ViewContainerProto::unsafe_arena_set_allocated_expander_accordion(::autofill_assistant::VerticalExpanderAccordionProto* expander_accordion) {
  clear_container();
  if (expander_accordion) {
    set_has_expander_accordion();
    container_.expander_accordion_ = expander_accordion;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ViewContainerProto.expander_accordion)
}
inline ::autofill_assistant::VerticalExpanderAccordionProto* ViewContainerProto::_internal_mutable_expander_accordion() {
  if (!_internal_has_expander_accordion()) {
    clear_container();
    set_has_expander_accordion();
    container_.expander_accordion_ = CreateMaybeMessage< ::autofill_assistant::VerticalExpanderAccordionProto >(GetArenaForAllocation());
  }
  return container_.expander_accordion_;
}
inline ::autofill_assistant::VerticalExpanderAccordionProto* ViewContainerProto::mutable_expander_accordion() {
  ::autofill_assistant::VerticalExpanderAccordionProto* _msg = _internal_mutable_expander_accordion();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ViewContainerProto.expander_accordion)
  return _msg;
}

inline bool ViewContainerProto::has_container() const {
  return container_case() != CONTAINER_NOT_SET;
}
inline void ViewContainerProto::clear_has_container() {
  _oneof_case_[0] = CONTAINER_NOT_SET;
}
inline ViewContainerProto::ContainerCase ViewContainerProto::container_case() const {
  return ViewContainerProto::ContainerCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// LinearLayoutProto

// optional .autofill_assistant.LinearLayoutProto.Orientation orientation = 1;
inline bool LinearLayoutProto::_internal_has_orientation() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LinearLayoutProto::has_orientation() const {
  return _internal_has_orientation();
}
inline void LinearLayoutProto::clear_orientation() {
  orientation_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::autofill_assistant::LinearLayoutProto_Orientation LinearLayoutProto::_internal_orientation() const {
  return static_cast< ::autofill_assistant::LinearLayoutProto_Orientation >(orientation_);
}
inline ::autofill_assistant::LinearLayoutProto_Orientation LinearLayoutProto::orientation() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.LinearLayoutProto.orientation)
  return _internal_orientation();
}
inline void LinearLayoutProto::_internal_set_orientation(::autofill_assistant::LinearLayoutProto_Orientation value) {
  assert(::autofill_assistant::LinearLayoutProto_Orientation_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  orientation_ = value;
}
inline void LinearLayoutProto::set_orientation(::autofill_assistant::LinearLayoutProto_Orientation value) {
  _internal_set_orientation(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.LinearLayoutProto.orientation)
}

// -------------------------------------------------------------------

// VerticalExpanderViewProto

// optional .autofill_assistant.ViewProto title_view = 1;
inline bool VerticalExpanderViewProto::_internal_has_title_view() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || title_view_ != nullptr);
  return value;
}
inline bool VerticalExpanderViewProto::has_title_view() const {
  return _internal_has_title_view();
}
inline void VerticalExpanderViewProto::clear_title_view() {
  if (title_view_ != nullptr) title_view_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::autofill_assistant::ViewProto& VerticalExpanderViewProto::_internal_title_view() const {
  const ::autofill_assistant::ViewProto* p = title_view_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::ViewProto&>(
      ::autofill_assistant::_ViewProto_default_instance_);
}
inline const ::autofill_assistant::ViewProto& VerticalExpanderViewProto::title_view() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.VerticalExpanderViewProto.title_view)
  return _internal_title_view();
}
inline void VerticalExpanderViewProto::unsafe_arena_set_allocated_title_view(
    ::autofill_assistant::ViewProto* title_view) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(title_view_);
  }
  title_view_ = title_view;
  if (title_view) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.VerticalExpanderViewProto.title_view)
}
inline ::autofill_assistant::ViewProto* VerticalExpanderViewProto::release_title_view() {
  _has_bits_[0] &= ~0x00000001u;
  ::autofill_assistant::ViewProto* temp = title_view_;
  title_view_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::ViewProto* VerticalExpanderViewProto::unsafe_arena_release_title_view() {
  // @@protoc_insertion_point(field_release:autofill_assistant.VerticalExpanderViewProto.title_view)
  _has_bits_[0] &= ~0x00000001u;
  ::autofill_assistant::ViewProto* temp = title_view_;
  title_view_ = nullptr;
  return temp;
}
inline ::autofill_assistant::ViewProto* VerticalExpanderViewProto::_internal_mutable_title_view() {
  _has_bits_[0] |= 0x00000001u;
  if (title_view_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::ViewProto>(GetArenaForAllocation());
    title_view_ = p;
  }
  return title_view_;
}
inline ::autofill_assistant::ViewProto* VerticalExpanderViewProto::mutable_title_view() {
  ::autofill_assistant::ViewProto* _msg = _internal_mutable_title_view();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.VerticalExpanderViewProto.title_view)
  return _msg;
}
inline void VerticalExpanderViewProto::set_allocated_title_view(::autofill_assistant::ViewProto* title_view) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete title_view_;
  }
  if (title_view) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(title_view);
    if (message_arena != submessage_arena) {
      title_view = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, title_view, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  title_view_ = title_view;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.VerticalExpanderViewProto.title_view)
}

// optional .autofill_assistant.ViewProto collapsed_view = 2;
inline bool VerticalExpanderViewProto::_internal_has_collapsed_view() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || collapsed_view_ != nullptr);
  return value;
}
inline bool VerticalExpanderViewProto::has_collapsed_view() const {
  return _internal_has_collapsed_view();
}
inline void VerticalExpanderViewProto::clear_collapsed_view() {
  if (collapsed_view_ != nullptr) collapsed_view_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::autofill_assistant::ViewProto& VerticalExpanderViewProto::_internal_collapsed_view() const {
  const ::autofill_assistant::ViewProto* p = collapsed_view_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::ViewProto&>(
      ::autofill_assistant::_ViewProto_default_instance_);
}
inline const ::autofill_assistant::ViewProto& VerticalExpanderViewProto::collapsed_view() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.VerticalExpanderViewProto.collapsed_view)
  return _internal_collapsed_view();
}
inline void VerticalExpanderViewProto::unsafe_arena_set_allocated_collapsed_view(
    ::autofill_assistant::ViewProto* collapsed_view) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(collapsed_view_);
  }
  collapsed_view_ = collapsed_view;
  if (collapsed_view) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.VerticalExpanderViewProto.collapsed_view)
}
inline ::autofill_assistant::ViewProto* VerticalExpanderViewProto::release_collapsed_view() {
  _has_bits_[0] &= ~0x00000002u;
  ::autofill_assistant::ViewProto* temp = collapsed_view_;
  collapsed_view_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::ViewProto* VerticalExpanderViewProto::unsafe_arena_release_collapsed_view() {
  // @@protoc_insertion_point(field_release:autofill_assistant.VerticalExpanderViewProto.collapsed_view)
  _has_bits_[0] &= ~0x00000002u;
  ::autofill_assistant::ViewProto* temp = collapsed_view_;
  collapsed_view_ = nullptr;
  return temp;
}
inline ::autofill_assistant::ViewProto* VerticalExpanderViewProto::_internal_mutable_collapsed_view() {
  _has_bits_[0] |= 0x00000002u;
  if (collapsed_view_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::ViewProto>(GetArenaForAllocation());
    collapsed_view_ = p;
  }
  return collapsed_view_;
}
inline ::autofill_assistant::ViewProto* VerticalExpanderViewProto::mutable_collapsed_view() {
  ::autofill_assistant::ViewProto* _msg = _internal_mutable_collapsed_view();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.VerticalExpanderViewProto.collapsed_view)
  return _msg;
}
inline void VerticalExpanderViewProto::set_allocated_collapsed_view(::autofill_assistant::ViewProto* collapsed_view) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete collapsed_view_;
  }
  if (collapsed_view) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(collapsed_view);
    if (message_arena != submessage_arena) {
      collapsed_view = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, collapsed_view, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  collapsed_view_ = collapsed_view;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.VerticalExpanderViewProto.collapsed_view)
}

// optional .autofill_assistant.ViewProto expanded_view = 3;
inline bool VerticalExpanderViewProto::_internal_has_expanded_view() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || expanded_view_ != nullptr);
  return value;
}
inline bool VerticalExpanderViewProto::has_expanded_view() const {
  return _internal_has_expanded_view();
}
inline void VerticalExpanderViewProto::clear_expanded_view() {
  if (expanded_view_ != nullptr) expanded_view_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::autofill_assistant::ViewProto& VerticalExpanderViewProto::_internal_expanded_view() const {
  const ::autofill_assistant::ViewProto* p = expanded_view_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::ViewProto&>(
      ::autofill_assistant::_ViewProto_default_instance_);
}
inline const ::autofill_assistant::ViewProto& VerticalExpanderViewProto::expanded_view() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.VerticalExpanderViewProto.expanded_view)
  return _internal_expanded_view();
}
inline void VerticalExpanderViewProto::unsafe_arena_set_allocated_expanded_view(
    ::autofill_assistant::ViewProto* expanded_view) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(expanded_view_);
  }
  expanded_view_ = expanded_view;
  if (expanded_view) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.VerticalExpanderViewProto.expanded_view)
}
inline ::autofill_assistant::ViewProto* VerticalExpanderViewProto::release_expanded_view() {
  _has_bits_[0] &= ~0x00000004u;
  ::autofill_assistant::ViewProto* temp = expanded_view_;
  expanded_view_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::ViewProto* VerticalExpanderViewProto::unsafe_arena_release_expanded_view() {
  // @@protoc_insertion_point(field_release:autofill_assistant.VerticalExpanderViewProto.expanded_view)
  _has_bits_[0] &= ~0x00000004u;
  ::autofill_assistant::ViewProto* temp = expanded_view_;
  expanded_view_ = nullptr;
  return temp;
}
inline ::autofill_assistant::ViewProto* VerticalExpanderViewProto::_internal_mutable_expanded_view() {
  _has_bits_[0] |= 0x00000004u;
  if (expanded_view_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::ViewProto>(GetArenaForAllocation());
    expanded_view_ = p;
  }
  return expanded_view_;
}
inline ::autofill_assistant::ViewProto* VerticalExpanderViewProto::mutable_expanded_view() {
  ::autofill_assistant::ViewProto* _msg = _internal_mutable_expanded_view();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.VerticalExpanderViewProto.expanded_view)
  return _msg;
}
inline void VerticalExpanderViewProto::set_allocated_expanded_view(::autofill_assistant::ViewProto* expanded_view) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete expanded_view_;
  }
  if (expanded_view) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(expanded_view);
    if (message_arena != submessage_arena) {
      expanded_view = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, expanded_view, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  expanded_view_ = expanded_view;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.VerticalExpanderViewProto.expanded_view)
}

// optional .autofill_assistant.VerticalExpanderViewProto.ChevronStyle chevron_style = 4;
inline bool VerticalExpanderViewProto::_internal_has_chevron_style() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool VerticalExpanderViewProto::has_chevron_style() const {
  return _internal_has_chevron_style();
}
inline void VerticalExpanderViewProto::clear_chevron_style() {
  chevron_style_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::autofill_assistant::VerticalExpanderViewProto_ChevronStyle VerticalExpanderViewProto::_internal_chevron_style() const {
  return static_cast< ::autofill_assistant::VerticalExpanderViewProto_ChevronStyle >(chevron_style_);
}
inline ::autofill_assistant::VerticalExpanderViewProto_ChevronStyle VerticalExpanderViewProto::chevron_style() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.VerticalExpanderViewProto.chevron_style)
  return _internal_chevron_style();
}
inline void VerticalExpanderViewProto::_internal_set_chevron_style(::autofill_assistant::VerticalExpanderViewProto_ChevronStyle value) {
  assert(::autofill_assistant::VerticalExpanderViewProto_ChevronStyle_IsValid(value));
  _has_bits_[0] |= 0x00000008u;
  chevron_style_ = value;
}
inline void VerticalExpanderViewProto::set_chevron_style(::autofill_assistant::VerticalExpanderViewProto_ChevronStyle value) {
  _internal_set_chevron_style(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.VerticalExpanderViewProto.chevron_style)
}

// -------------------------------------------------------------------

// VerticalExpanderAccordionProto

// optional .autofill_assistant.LinearLayoutProto.Orientation orientation = 2;
inline bool VerticalExpanderAccordionProto::_internal_has_orientation() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool VerticalExpanderAccordionProto::has_orientation() const {
  return _internal_has_orientation();
}
inline void VerticalExpanderAccordionProto::clear_orientation() {
  orientation_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::autofill_assistant::LinearLayoutProto_Orientation VerticalExpanderAccordionProto::_internal_orientation() const {
  return static_cast< ::autofill_assistant::LinearLayoutProto_Orientation >(orientation_);
}
inline ::autofill_assistant::LinearLayoutProto_Orientation VerticalExpanderAccordionProto::orientation() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.VerticalExpanderAccordionProto.orientation)
  return _internal_orientation();
}
inline void VerticalExpanderAccordionProto::_internal_set_orientation(::autofill_assistant::LinearLayoutProto_Orientation value) {
  assert(::autofill_assistant::LinearLayoutProto_Orientation_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  orientation_ = value;
}
inline void VerticalExpanderAccordionProto::set_orientation(::autofill_assistant::LinearLayoutProto_Orientation value) {
  _internal_set_orientation(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.VerticalExpanderAccordionProto.orientation)
}

// -------------------------------------------------------------------

// TextViewProto

// string text = 1;
inline bool TextViewProto::_internal_has_text() const {
  return kind_case() == kText;
}
inline bool TextViewProto::has_text() const {
  return _internal_has_text();
}
inline void TextViewProto::set_has_text() {
  _oneof_case_[0] = kText;
}
inline void TextViewProto::clear_text() {
  if (_internal_has_text()) {
    kind_.text_.Destroy();
    clear_has_kind();
  }
}
inline const std::string& TextViewProto::text() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.TextViewProto.text)
  return _internal_text();
}
template <typename ArgT0, typename... ArgT>
inline void TextViewProto::set_text(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_text()) {
    clear_kind();
    set_has_text();
    kind_.text_.InitDefault();
  }
  kind_.text_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.TextViewProto.text)
}
inline std::string* TextViewProto::mutable_text() {
  std::string* _s = _internal_mutable_text();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.TextViewProto.text)
  return _s;
}
inline const std::string& TextViewProto::_internal_text() const {
  if (_internal_has_text()) {
    return kind_.text_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void TextViewProto::_internal_set_text(const std::string& value) {
  if (!_internal_has_text()) {
    clear_kind();
    set_has_text();
    kind_.text_.InitDefault();
  }
  kind_.text_.Set(value, GetArenaForAllocation());
}
inline std::string* TextViewProto::_internal_mutable_text() {
  if (!_internal_has_text()) {
    clear_kind();
    set_has_text();
    kind_.text_.InitDefault();
  }
  return kind_.text_.Mutable(      GetArenaForAllocation());
}
inline std::string* TextViewProto::release_text() {
  // @@protoc_insertion_point(field_release:autofill_assistant.TextViewProto.text)
  if (_internal_has_text()) {
    clear_has_kind();
    return kind_.text_.Release();
  } else {
    return nullptr;
  }
}
inline void TextViewProto::set_allocated_text(std::string* text) {
  if (has_kind()) {
    clear_kind();
  }
  if (text != nullptr) {
    set_has_text();
    kind_.text_.InitAllocated(text, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.TextViewProto.text)
}

// string model_identifier = 3;
inline bool TextViewProto::_internal_has_model_identifier() const {
  return kind_case() == kModelIdentifier;
}
inline bool TextViewProto::has_model_identifier() const {
  return _internal_has_model_identifier();
}
inline void TextViewProto::set_has_model_identifier() {
  _oneof_case_[0] = kModelIdentifier;
}
inline void TextViewProto::clear_model_identifier() {
  if (_internal_has_model_identifier()) {
    kind_.model_identifier_.Destroy();
    clear_has_kind();
  }
}
inline const std::string& TextViewProto::model_identifier() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.TextViewProto.model_identifier)
  return _internal_model_identifier();
}
template <typename ArgT0, typename... ArgT>
inline void TextViewProto::set_model_identifier(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_model_identifier()) {
    clear_kind();
    set_has_model_identifier();
    kind_.model_identifier_.InitDefault();
  }
  kind_.model_identifier_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.TextViewProto.model_identifier)
}
inline std::string* TextViewProto::mutable_model_identifier() {
  std::string* _s = _internal_mutable_model_identifier();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.TextViewProto.model_identifier)
  return _s;
}
inline const std::string& TextViewProto::_internal_model_identifier() const {
  if (_internal_has_model_identifier()) {
    return kind_.model_identifier_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void TextViewProto::_internal_set_model_identifier(const std::string& value) {
  if (!_internal_has_model_identifier()) {
    clear_kind();
    set_has_model_identifier();
    kind_.model_identifier_.InitDefault();
  }
  kind_.model_identifier_.Set(value, GetArenaForAllocation());
}
inline std::string* TextViewProto::_internal_mutable_model_identifier() {
  if (!_internal_has_model_identifier()) {
    clear_kind();
    set_has_model_identifier();
    kind_.model_identifier_.InitDefault();
  }
  return kind_.model_identifier_.Mutable(      GetArenaForAllocation());
}
inline std::string* TextViewProto::release_model_identifier() {
  // @@protoc_insertion_point(field_release:autofill_assistant.TextViewProto.model_identifier)
  if (_internal_has_model_identifier()) {
    clear_has_kind();
    return kind_.model_identifier_.Release();
  } else {
    return nullptr;
  }
}
inline void TextViewProto::set_allocated_model_identifier(std::string* model_identifier) {
  if (has_kind()) {
    clear_kind();
  }
  if (model_identifier != nullptr) {
    set_has_model_identifier();
    kind_.model_identifier_.InitAllocated(model_identifier, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.TextViewProto.model_identifier)
}

// optional string text_appearance = 2;
inline bool TextViewProto::_internal_has_text_appearance() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TextViewProto::has_text_appearance() const {
  return _internal_has_text_appearance();
}
inline void TextViewProto::clear_text_appearance() {
  text_appearance_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TextViewProto::text_appearance() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.TextViewProto.text_appearance)
  return _internal_text_appearance();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TextViewProto::set_text_appearance(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 text_appearance_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.TextViewProto.text_appearance)
}
inline std::string* TextViewProto::mutable_text_appearance() {
  std::string* _s = _internal_mutable_text_appearance();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.TextViewProto.text_appearance)
  return _s;
}
inline const std::string& TextViewProto::_internal_text_appearance() const {
  return text_appearance_.Get();
}
inline void TextViewProto::_internal_set_text_appearance(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  text_appearance_.Set(value, GetArenaForAllocation());
}
inline std::string* TextViewProto::_internal_mutable_text_appearance() {
  _has_bits_[0] |= 0x00000001u;
  return text_appearance_.Mutable(GetArenaForAllocation());
}
inline std::string* TextViewProto::release_text_appearance() {
  // @@protoc_insertion_point(field_release:autofill_assistant.TextViewProto.text_appearance)
  if (!_internal_has_text_appearance()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = text_appearance_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (text_appearance_.IsDefault()) {
    text_appearance_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TextViewProto::set_allocated_text_appearance(std::string* text_appearance) {
  if (text_appearance != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  text_appearance_.SetAllocated(text_appearance, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (text_appearance_.IsDefault()) {
    text_appearance_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.TextViewProto.text_appearance)
}

// optional int32 text_alignment = 4 [default = 8388659];
inline bool TextViewProto::_internal_has_text_alignment() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TextViewProto::has_text_alignment() const {
  return _internal_has_text_alignment();
}
inline void TextViewProto::clear_text_alignment() {
  text_alignment_ = 8388659;
  _has_bits_[0] &= ~0x00000002u;
}
inline int32_t TextViewProto::_internal_text_alignment() const {
  return text_alignment_;
}
inline int32_t TextViewProto::text_alignment() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.TextViewProto.text_alignment)
  return _internal_text_alignment();
}
inline void TextViewProto::_internal_set_text_alignment(int32_t value) {
  _has_bits_[0] |= 0x00000002u;
  text_alignment_ = value;
}
inline void TextViewProto::set_text_alignment(int32_t value) {
  _internal_set_text_alignment(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.TextViewProto.text_alignment)
}

inline bool TextViewProto::has_kind() const {
  return kind_case() != KIND_NOT_SET;
}
inline void TextViewProto::clear_has_kind() {
  _oneof_case_[0] = KIND_NOT_SET;
}
inline TextViewProto::KindCase TextViewProto::kind_case() const {
  return TextViewProto::KindCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// DividerViewProto

// -------------------------------------------------------------------

// ImageViewProto

// optional .autofill_assistant.DrawableProto image = 1;
inline bool ImageViewProto::_internal_has_image() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || image_ != nullptr);
  return value;
}
inline bool ImageViewProto::has_image() const {
  return _internal_has_image();
}
inline void ImageViewProto::clear_image() {
  if (image_ != nullptr) image_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::autofill_assistant::DrawableProto& ImageViewProto::_internal_image() const {
  const ::autofill_assistant::DrawableProto* p = image_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::DrawableProto&>(
      ::autofill_assistant::_DrawableProto_default_instance_);
}
inline const ::autofill_assistant::DrawableProto& ImageViewProto::image() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ImageViewProto.image)
  return _internal_image();
}
inline void ImageViewProto::unsafe_arena_set_allocated_image(
    ::autofill_assistant::DrawableProto* image) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(image_);
  }
  image_ = image;
  if (image) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ImageViewProto.image)
}
inline ::autofill_assistant::DrawableProto* ImageViewProto::release_image() {
  _has_bits_[0] &= ~0x00000001u;
  ::autofill_assistant::DrawableProto* temp = image_;
  image_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::DrawableProto* ImageViewProto::unsafe_arena_release_image() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ImageViewProto.image)
  _has_bits_[0] &= ~0x00000001u;
  ::autofill_assistant::DrawableProto* temp = image_;
  image_ = nullptr;
  return temp;
}
inline ::autofill_assistant::DrawableProto* ImageViewProto::_internal_mutable_image() {
  _has_bits_[0] |= 0x00000001u;
  if (image_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::DrawableProto>(GetArenaForAllocation());
    image_ = p;
  }
  return image_;
}
inline ::autofill_assistant::DrawableProto* ImageViewProto::mutable_image() {
  ::autofill_assistant::DrawableProto* _msg = _internal_mutable_image();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ImageViewProto.image)
  return _msg;
}
inline void ImageViewProto::set_allocated_image(::autofill_assistant::DrawableProto* image) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete image_;
  }
  if (image) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(image);
    if (message_arena != submessage_arena) {
      image = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, image, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  image_ = image;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ImageViewProto.image)
}

// -------------------------------------------------------------------

// TextInputViewProto

// optional string hint = 1;
inline bool TextInputViewProto::_internal_has_hint() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TextInputViewProto::has_hint() const {
  return _internal_has_hint();
}
inline void TextInputViewProto::clear_hint() {
  hint_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TextInputViewProto::hint() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.TextInputViewProto.hint)
  return _internal_hint();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TextInputViewProto::set_hint(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 hint_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.TextInputViewProto.hint)
}
inline std::string* TextInputViewProto::mutable_hint() {
  std::string* _s = _internal_mutable_hint();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.TextInputViewProto.hint)
  return _s;
}
inline const std::string& TextInputViewProto::_internal_hint() const {
  return hint_.Get();
}
inline void TextInputViewProto::_internal_set_hint(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  hint_.Set(value, GetArenaForAllocation());
}
inline std::string* TextInputViewProto::_internal_mutable_hint() {
  _has_bits_[0] |= 0x00000001u;
  return hint_.Mutable(GetArenaForAllocation());
}
inline std::string* TextInputViewProto::release_hint() {
  // @@protoc_insertion_point(field_release:autofill_assistant.TextInputViewProto.hint)
  if (!_internal_has_hint()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = hint_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (hint_.IsDefault()) {
    hint_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TextInputViewProto::set_allocated_hint(std::string* hint) {
  if (hint != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  hint_.SetAllocated(hint, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (hint_.IsDefault()) {
    hint_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.TextInputViewProto.hint)
}

// optional .autofill_assistant.TextInputViewProto.InputTypeHint type = 2;
inline bool TextInputViewProto::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool TextInputViewProto::has_type() const {
  return _internal_has_type();
}
inline void TextInputViewProto::clear_type() {
  type_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::autofill_assistant::TextInputViewProto_InputTypeHint TextInputViewProto::_internal_type() const {
  return static_cast< ::autofill_assistant::TextInputViewProto_InputTypeHint >(type_);
}
inline ::autofill_assistant::TextInputViewProto_InputTypeHint TextInputViewProto::type() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.TextInputViewProto.type)
  return _internal_type();
}
inline void TextInputViewProto::_internal_set_type(::autofill_assistant::TextInputViewProto_InputTypeHint value) {
  assert(::autofill_assistant::TextInputViewProto_InputTypeHint_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  type_ = value;
}
inline void TextInputViewProto::set_type(::autofill_assistant::TextInputViewProto_InputTypeHint value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.TextInputViewProto.type)
}

// optional string model_identifier = 3;
inline bool TextInputViewProto::_internal_has_model_identifier() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TextInputViewProto::has_model_identifier() const {
  return _internal_has_model_identifier();
}
inline void TextInputViewProto::clear_model_identifier() {
  model_identifier_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& TextInputViewProto::model_identifier() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.TextInputViewProto.model_identifier)
  return _internal_model_identifier();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TextInputViewProto::set_model_identifier(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 model_identifier_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.TextInputViewProto.model_identifier)
}
inline std::string* TextInputViewProto::mutable_model_identifier() {
  std::string* _s = _internal_mutable_model_identifier();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.TextInputViewProto.model_identifier)
  return _s;
}
inline const std::string& TextInputViewProto::_internal_model_identifier() const {
  return model_identifier_.Get();
}
inline void TextInputViewProto::_internal_set_model_identifier(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  model_identifier_.Set(value, GetArenaForAllocation());
}
inline std::string* TextInputViewProto::_internal_mutable_model_identifier() {
  _has_bits_[0] |= 0x00000002u;
  return model_identifier_.Mutable(GetArenaForAllocation());
}
inline std::string* TextInputViewProto::release_model_identifier() {
  // @@protoc_insertion_point(field_release:autofill_assistant.TextInputViewProto.model_identifier)
  if (!_internal_has_model_identifier()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = model_identifier_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (model_identifier_.IsDefault()) {
    model_identifier_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TextInputViewProto::set_allocated_model_identifier(std::string* model_identifier) {
  if (model_identifier != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  model_identifier_.SetAllocated(model_identifier, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (model_identifier_.IsDefault()) {
    model_identifier_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.TextInputViewProto.model_identifier)
}

// optional bool focus_and_show_keyboard = 4;
inline bool TextInputViewProto::_internal_has_focus_and_show_keyboard() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool TextInputViewProto::has_focus_and_show_keyboard() const {
  return _internal_has_focus_and_show_keyboard();
}
inline void TextInputViewProto::clear_focus_and_show_keyboard() {
  focus_and_show_keyboard_ = false;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool TextInputViewProto::_internal_focus_and_show_keyboard() const {
  return focus_and_show_keyboard_;
}
inline bool TextInputViewProto::focus_and_show_keyboard() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.TextInputViewProto.focus_and_show_keyboard)
  return _internal_focus_and_show_keyboard();
}
inline void TextInputViewProto::_internal_set_focus_and_show_keyboard(bool value) {
  _has_bits_[0] |= 0x00000008u;
  focus_and_show_keyboard_ = value;
}
inline void TextInputViewProto::set_focus_and_show_keyboard(bool value) {
  _internal_set_focus_and_show_keyboard(value);
  // @@protoc_insertion_point(field_set:autofill_assistant.TextInputViewProto.focus_and_show_keyboard)
}

// -------------------------------------------------------------------

// InfoPopupProto_DialogButton_CloseDialog

// -------------------------------------------------------------------

// InfoPopupProto_DialogButton_OpenUrlInCCT

// optional string url = 1;
inline bool InfoPopupProto_DialogButton_OpenUrlInCCT::_internal_has_url() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool InfoPopupProto_DialogButton_OpenUrlInCCT::has_url() const {
  return _internal_has_url();
}
inline void InfoPopupProto_DialogButton_OpenUrlInCCT::clear_url() {
  url_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& InfoPopupProto_DialogButton_OpenUrlInCCT::url() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.InfoPopupProto.DialogButton.OpenUrlInCCT.url)
  return _internal_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InfoPopupProto_DialogButton_OpenUrlInCCT::set_url(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.InfoPopupProto.DialogButton.OpenUrlInCCT.url)
}
inline std::string* InfoPopupProto_DialogButton_OpenUrlInCCT::mutable_url() {
  std::string* _s = _internal_mutable_url();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.InfoPopupProto.DialogButton.OpenUrlInCCT.url)
  return _s;
}
inline const std::string& InfoPopupProto_DialogButton_OpenUrlInCCT::_internal_url() const {
  return url_.Get();
}
inline void InfoPopupProto_DialogButton_OpenUrlInCCT::_internal_set_url(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  url_.Set(value, GetArenaForAllocation());
}
inline std::string* InfoPopupProto_DialogButton_OpenUrlInCCT::_internal_mutable_url() {
  _has_bits_[0] |= 0x00000001u;
  return url_.Mutable(GetArenaForAllocation());
}
inline std::string* InfoPopupProto_DialogButton_OpenUrlInCCT::release_url() {
  // @@protoc_insertion_point(field_release:autofill_assistant.InfoPopupProto.DialogButton.OpenUrlInCCT.url)
  if (!_internal_has_url()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = url_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (url_.IsDefault()) {
    url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void InfoPopupProto_DialogButton_OpenUrlInCCT::set_allocated_url(std::string* url) {
  if (url != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  url_.SetAllocated(url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (url_.IsDefault()) {
    url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.InfoPopupProto.DialogButton.OpenUrlInCCT.url)
}

// -------------------------------------------------------------------

// InfoPopupProto_DialogButton

// .autofill_assistant.InfoPopupProto.DialogButton.CloseDialog close_dialog = 4;
inline bool InfoPopupProto_DialogButton::_internal_has_close_dialog() const {
  return click_action_case() == kCloseDialog;
}
inline bool InfoPopupProto_DialogButton::has_close_dialog() const {
  return _internal_has_close_dialog();
}
inline void InfoPopupProto_DialogButton::set_has_close_dialog() {
  _oneof_case_[0] = kCloseDialog;
}
inline void InfoPopupProto_DialogButton::clear_close_dialog() {
  if (_internal_has_close_dialog()) {
    if (GetArenaForAllocation() == nullptr) {
      delete click_action_.close_dialog_;
    }
    clear_has_click_action();
  }
}
inline ::autofill_assistant::InfoPopupProto_DialogButton_CloseDialog* InfoPopupProto_DialogButton::release_close_dialog() {
  // @@protoc_insertion_point(field_release:autofill_assistant.InfoPopupProto.DialogButton.close_dialog)
  if (_internal_has_close_dialog()) {
    clear_has_click_action();
    ::autofill_assistant::InfoPopupProto_DialogButton_CloseDialog* temp = click_action_.close_dialog_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    click_action_.close_dialog_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::InfoPopupProto_DialogButton_CloseDialog& InfoPopupProto_DialogButton::_internal_close_dialog() const {
  return _internal_has_close_dialog()
      ? *click_action_.close_dialog_
      : reinterpret_cast< ::autofill_assistant::InfoPopupProto_DialogButton_CloseDialog&>(::autofill_assistant::_InfoPopupProto_DialogButton_CloseDialog_default_instance_);
}
inline const ::autofill_assistant::InfoPopupProto_DialogButton_CloseDialog& InfoPopupProto_DialogButton::close_dialog() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.InfoPopupProto.DialogButton.close_dialog)
  return _internal_close_dialog();
}
inline ::autofill_assistant::InfoPopupProto_DialogButton_CloseDialog* InfoPopupProto_DialogButton::unsafe_arena_release_close_dialog() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.InfoPopupProto.DialogButton.close_dialog)
  if (_internal_has_close_dialog()) {
    clear_has_click_action();
    ::autofill_assistant::InfoPopupProto_DialogButton_CloseDialog* temp = click_action_.close_dialog_;
    click_action_.close_dialog_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void InfoPopupProto_DialogButton::unsafe_arena_set_allocated_close_dialog(::autofill_assistant::InfoPopupProto_DialogButton_CloseDialog* close_dialog) {
  clear_click_action();
  if (close_dialog) {
    set_has_close_dialog();
    click_action_.close_dialog_ = close_dialog;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.InfoPopupProto.DialogButton.close_dialog)
}
inline ::autofill_assistant::InfoPopupProto_DialogButton_CloseDialog* InfoPopupProto_DialogButton::_internal_mutable_close_dialog() {
  if (!_internal_has_close_dialog()) {
    clear_click_action();
    set_has_close_dialog();
    click_action_.close_dialog_ = CreateMaybeMessage< ::autofill_assistant::InfoPopupProto_DialogButton_CloseDialog >(GetArenaForAllocation());
  }
  return click_action_.close_dialog_;
}
inline ::autofill_assistant::InfoPopupProto_DialogButton_CloseDialog* InfoPopupProto_DialogButton::mutable_close_dialog() {
  ::autofill_assistant::InfoPopupProto_DialogButton_CloseDialog* _msg = _internal_mutable_close_dialog();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.InfoPopupProto.DialogButton.close_dialog)
  return _msg;
}

// .autofill_assistant.InfoPopupProto.DialogButton.OpenUrlInCCT open_url_in_cct = 5;
inline bool InfoPopupProto_DialogButton::_internal_has_open_url_in_cct() const {
  return click_action_case() == kOpenUrlInCct;
}
inline bool InfoPopupProto_DialogButton::has_open_url_in_cct() const {
  return _internal_has_open_url_in_cct();
}
inline void InfoPopupProto_DialogButton::set_has_open_url_in_cct() {
  _oneof_case_[0] = kOpenUrlInCct;
}
inline void InfoPopupProto_DialogButton::clear_open_url_in_cct() {
  if (_internal_has_open_url_in_cct()) {
    if (GetArenaForAllocation() == nullptr) {
      delete click_action_.open_url_in_cct_;
    }
    clear_has_click_action();
  }
}
inline ::autofill_assistant::InfoPopupProto_DialogButton_OpenUrlInCCT* InfoPopupProto_DialogButton::release_open_url_in_cct() {
  // @@protoc_insertion_point(field_release:autofill_assistant.InfoPopupProto.DialogButton.open_url_in_cct)
  if (_internal_has_open_url_in_cct()) {
    clear_has_click_action();
    ::autofill_assistant::InfoPopupProto_DialogButton_OpenUrlInCCT* temp = click_action_.open_url_in_cct_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    click_action_.open_url_in_cct_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::InfoPopupProto_DialogButton_OpenUrlInCCT& InfoPopupProto_DialogButton::_internal_open_url_in_cct() const {
  return _internal_has_open_url_in_cct()
      ? *click_action_.open_url_in_cct_
      : reinterpret_cast< ::autofill_assistant::InfoPopupProto_DialogButton_OpenUrlInCCT&>(::autofill_assistant::_InfoPopupProto_DialogButton_OpenUrlInCCT_default_instance_);
}
inline const ::autofill_assistant::InfoPopupProto_DialogButton_OpenUrlInCCT& InfoPopupProto_DialogButton::open_url_in_cct() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.InfoPopupProto.DialogButton.open_url_in_cct)
  return _internal_open_url_in_cct();
}
inline ::autofill_assistant::InfoPopupProto_DialogButton_OpenUrlInCCT* InfoPopupProto_DialogButton::unsafe_arena_release_open_url_in_cct() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.InfoPopupProto.DialogButton.open_url_in_cct)
  if (_internal_has_open_url_in_cct()) {
    clear_has_click_action();
    ::autofill_assistant::InfoPopupProto_DialogButton_OpenUrlInCCT* temp = click_action_.open_url_in_cct_;
    click_action_.open_url_in_cct_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void InfoPopupProto_DialogButton::unsafe_arena_set_allocated_open_url_in_cct(::autofill_assistant::InfoPopupProto_DialogButton_OpenUrlInCCT* open_url_in_cct) {
  clear_click_action();
  if (open_url_in_cct) {
    set_has_open_url_in_cct();
    click_action_.open_url_in_cct_ = open_url_in_cct;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.InfoPopupProto.DialogButton.open_url_in_cct)
}
inline ::autofill_assistant::InfoPopupProto_DialogButton_OpenUrlInCCT* InfoPopupProto_DialogButton::_internal_mutable_open_url_in_cct() {
  if (!_internal_has_open_url_in_cct()) {
    clear_click_action();
    set_has_open_url_in_cct();
    click_action_.open_url_in_cct_ = CreateMaybeMessage< ::autofill_assistant::InfoPopupProto_DialogButton_OpenUrlInCCT >(GetArenaForAllocation());
  }
  return click_action_.open_url_in_cct_;
}
inline ::autofill_assistant::InfoPopupProto_DialogButton_OpenUrlInCCT* InfoPopupProto_DialogButton::mutable_open_url_in_cct() {
  ::autofill_assistant::InfoPopupProto_DialogButton_OpenUrlInCCT* _msg = _internal_mutable_open_url_in_cct();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.InfoPopupProto.DialogButton.open_url_in_cct)
  return _msg;
}

// optional string label = 1;
inline bool InfoPopupProto_DialogButton::_internal_has_label() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool InfoPopupProto_DialogButton::has_label() const {
  return _internal_has_label();
}
inline void InfoPopupProto_DialogButton::clear_label() {
  label_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& InfoPopupProto_DialogButton::label() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.InfoPopupProto.DialogButton.label)
  return _internal_label();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InfoPopupProto_DialogButton::set_label(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 label_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.InfoPopupProto.DialogButton.label)
}
inline std::string* InfoPopupProto_DialogButton::mutable_label() {
  std::string* _s = _internal_mutable_label();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.InfoPopupProto.DialogButton.label)
  return _s;
}
inline const std::string& InfoPopupProto_DialogButton::_internal_label() const {
  return label_.Get();
}
inline void InfoPopupProto_DialogButton::_internal_set_label(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  label_.Set(value, GetArenaForAllocation());
}
inline std::string* InfoPopupProto_DialogButton::_internal_mutable_label() {
  _has_bits_[0] |= 0x00000001u;
  return label_.Mutable(GetArenaForAllocation());
}
inline std::string* InfoPopupProto_DialogButton::release_label() {
  // @@protoc_insertion_point(field_release:autofill_assistant.InfoPopupProto.DialogButton.label)
  if (!_internal_has_label()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = label_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (label_.IsDefault()) {
    label_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void InfoPopupProto_DialogButton::set_allocated_label(std::string* label) {
  if (label != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  label_.SetAllocated(label, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (label_.IsDefault()) {
    label_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.InfoPopupProto.DialogButton.label)
}

inline bool InfoPopupProto_DialogButton::has_click_action() const {
  return click_action_case() != CLICK_ACTION_NOT_SET;
}
inline void InfoPopupProto_DialogButton::clear_has_click_action() {
  _oneof_case_[0] = CLICK_ACTION_NOT_SET;
}
inline InfoPopupProto_DialogButton::ClickActionCase InfoPopupProto_DialogButton::click_action_case() const {
  return InfoPopupProto_DialogButton::ClickActionCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// InfoPopupProto

// optional string title = 1;
inline bool InfoPopupProto::_internal_has_title() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool InfoPopupProto::has_title() const {
  return _internal_has_title();
}
inline void InfoPopupProto::clear_title() {
  title_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& InfoPopupProto::title() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.InfoPopupProto.title)
  return _internal_title();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InfoPopupProto::set_title(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 title_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.InfoPopupProto.title)
}
inline std::string* InfoPopupProto::mutable_title() {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.InfoPopupProto.title)
  return _s;
}
inline const std::string& InfoPopupProto::_internal_title() const {
  return title_.Get();
}
inline void InfoPopupProto::_internal_set_title(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  title_.Set(value, GetArenaForAllocation());
}
inline std::string* InfoPopupProto::_internal_mutable_title() {
  _has_bits_[0] |= 0x00000001u;
  return title_.Mutable(GetArenaForAllocation());
}
inline std::string* InfoPopupProto::release_title() {
  // @@protoc_insertion_point(field_release:autofill_assistant.InfoPopupProto.title)
  if (!_internal_has_title()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = title_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (title_.IsDefault()) {
    title_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void InfoPopupProto::set_allocated_title(std::string* title) {
  if (title != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  title_.SetAllocated(title, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (title_.IsDefault()) {
    title_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.InfoPopupProto.title)
}

// optional string text = 2;
inline bool InfoPopupProto::_internal_has_text() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool InfoPopupProto::has_text() const {
  return _internal_has_text();
}
inline void InfoPopupProto::clear_text() {
  text_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& InfoPopupProto::text() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.InfoPopupProto.text)
  return _internal_text();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InfoPopupProto::set_text(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 text_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.InfoPopupProto.text)
}
inline std::string* InfoPopupProto::mutable_text() {
  std::string* _s = _internal_mutable_text();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.InfoPopupProto.text)
  return _s;
}
inline const std::string& InfoPopupProto::_internal_text() const {
  return text_.Get();
}
inline void InfoPopupProto::_internal_set_text(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  text_.Set(value, GetArenaForAllocation());
}
inline std::string* InfoPopupProto::_internal_mutable_text() {
  _has_bits_[0] |= 0x00000002u;
  return text_.Mutable(GetArenaForAllocation());
}
inline std::string* InfoPopupProto::release_text() {
  // @@protoc_insertion_point(field_release:autofill_assistant.InfoPopupProto.text)
  if (!_internal_has_text()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = text_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (text_.IsDefault()) {
    text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void InfoPopupProto::set_allocated_text(std::string* text) {
  if (text != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  text_.SetAllocated(text, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (text_.IsDefault()) {
    text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.InfoPopupProto.text)
}

// optional .autofill_assistant.InfoPopupProto.DialogButton positive_button = 3;
inline bool InfoPopupProto::_internal_has_positive_button() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || positive_button_ != nullptr);
  return value;
}
inline bool InfoPopupProto::has_positive_button() const {
  return _internal_has_positive_button();
}
inline void InfoPopupProto::clear_positive_button() {
  if (positive_button_ != nullptr) positive_button_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::autofill_assistant::InfoPopupProto_DialogButton& InfoPopupProto::_internal_positive_button() const {
  const ::autofill_assistant::InfoPopupProto_DialogButton* p = positive_button_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::InfoPopupProto_DialogButton&>(
      ::autofill_assistant::_InfoPopupProto_DialogButton_default_instance_);
}
inline const ::autofill_assistant::InfoPopupProto_DialogButton& InfoPopupProto::positive_button() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.InfoPopupProto.positive_button)
  return _internal_positive_button();
}
inline void InfoPopupProto::unsafe_arena_set_allocated_positive_button(
    ::autofill_assistant::InfoPopupProto_DialogButton* positive_button) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(positive_button_);
  }
  positive_button_ = positive_button;
  if (positive_button) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.InfoPopupProto.positive_button)
}
inline ::autofill_assistant::InfoPopupProto_DialogButton* InfoPopupProto::release_positive_button() {
  _has_bits_[0] &= ~0x00000004u;
  ::autofill_assistant::InfoPopupProto_DialogButton* temp = positive_button_;
  positive_button_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::InfoPopupProto_DialogButton* InfoPopupProto::unsafe_arena_release_positive_button() {
  // @@protoc_insertion_point(field_release:autofill_assistant.InfoPopupProto.positive_button)
  _has_bits_[0] &= ~0x00000004u;
  ::autofill_assistant::InfoPopupProto_DialogButton* temp = positive_button_;
  positive_button_ = nullptr;
  return temp;
}
inline ::autofill_assistant::InfoPopupProto_DialogButton* InfoPopupProto::_internal_mutable_positive_button() {
  _has_bits_[0] |= 0x00000004u;
  if (positive_button_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::InfoPopupProto_DialogButton>(GetArenaForAllocation());
    positive_button_ = p;
  }
  return positive_button_;
}
inline ::autofill_assistant::InfoPopupProto_DialogButton* InfoPopupProto::mutable_positive_button() {
  ::autofill_assistant::InfoPopupProto_DialogButton* _msg = _internal_mutable_positive_button();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.InfoPopupProto.positive_button)
  return _msg;
}
inline void InfoPopupProto::set_allocated_positive_button(::autofill_assistant::InfoPopupProto_DialogButton* positive_button) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete positive_button_;
  }
  if (positive_button) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(positive_button);
    if (message_arena != submessage_arena) {
      positive_button = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, positive_button, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  positive_button_ = positive_button;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.InfoPopupProto.positive_button)
}

// optional .autofill_assistant.InfoPopupProto.DialogButton negative_button = 4;
inline bool InfoPopupProto::_internal_has_negative_button() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || negative_button_ != nullptr);
  return value;
}
inline bool InfoPopupProto::has_negative_button() const {
  return _internal_has_negative_button();
}
inline void InfoPopupProto::clear_negative_button() {
  if (negative_button_ != nullptr) negative_button_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::autofill_assistant::InfoPopupProto_DialogButton& InfoPopupProto::_internal_negative_button() const {
  const ::autofill_assistant::InfoPopupProto_DialogButton* p = negative_button_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::InfoPopupProto_DialogButton&>(
      ::autofill_assistant::_InfoPopupProto_DialogButton_default_instance_);
}
inline const ::autofill_assistant::InfoPopupProto_DialogButton& InfoPopupProto::negative_button() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.InfoPopupProto.negative_button)
  return _internal_negative_button();
}
inline void InfoPopupProto::unsafe_arena_set_allocated_negative_button(
    ::autofill_assistant::InfoPopupProto_DialogButton* negative_button) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(negative_button_);
  }
  negative_button_ = negative_button;
  if (negative_button) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.InfoPopupProto.negative_button)
}
inline ::autofill_assistant::InfoPopupProto_DialogButton* InfoPopupProto::release_negative_button() {
  _has_bits_[0] &= ~0x00000008u;
  ::autofill_assistant::InfoPopupProto_DialogButton* temp = negative_button_;
  negative_button_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::InfoPopupProto_DialogButton* InfoPopupProto::unsafe_arena_release_negative_button() {
  // @@protoc_insertion_point(field_release:autofill_assistant.InfoPopupProto.negative_button)
  _has_bits_[0] &= ~0x00000008u;
  ::autofill_assistant::InfoPopupProto_DialogButton* temp = negative_button_;
  negative_button_ = nullptr;
  return temp;
}
inline ::autofill_assistant::InfoPopupProto_DialogButton* InfoPopupProto::_internal_mutable_negative_button() {
  _has_bits_[0] |= 0x00000008u;
  if (negative_button_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::InfoPopupProto_DialogButton>(GetArenaForAllocation());
    negative_button_ = p;
  }
  return negative_button_;
}
inline ::autofill_assistant::InfoPopupProto_DialogButton* InfoPopupProto::mutable_negative_button() {
  ::autofill_assistant::InfoPopupProto_DialogButton* _msg = _internal_mutable_negative_button();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.InfoPopupProto.negative_button)
  return _msg;
}
inline void InfoPopupProto::set_allocated_negative_button(::autofill_assistant::InfoPopupProto_DialogButton* negative_button) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete negative_button_;
  }
  if (negative_button) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(negative_button);
    if (message_arena != submessage_arena) {
      negative_button = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, negative_button, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  negative_button_ = negative_button;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.InfoPopupProto.negative_button)
}

// optional .autofill_assistant.InfoPopupProto.DialogButton neutral_button = 5;
inline bool InfoPopupProto::_internal_has_neutral_button() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || neutral_button_ != nullptr);
  return value;
}
inline bool InfoPopupProto::has_neutral_button() const {
  return _internal_has_neutral_button();
}
inline void InfoPopupProto::clear_neutral_button() {
  if (neutral_button_ != nullptr) neutral_button_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::autofill_assistant::InfoPopupProto_DialogButton& InfoPopupProto::_internal_neutral_button() const {
  const ::autofill_assistant::InfoPopupProto_DialogButton* p = neutral_button_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::InfoPopupProto_DialogButton&>(
      ::autofill_assistant::_InfoPopupProto_DialogButton_default_instance_);
}
inline const ::autofill_assistant::InfoPopupProto_DialogButton& InfoPopupProto::neutral_button() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.InfoPopupProto.neutral_button)
  return _internal_neutral_button();
}
inline void InfoPopupProto::unsafe_arena_set_allocated_neutral_button(
    ::autofill_assistant::InfoPopupProto_DialogButton* neutral_button) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(neutral_button_);
  }
  neutral_button_ = neutral_button;
  if (neutral_button) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.InfoPopupProto.neutral_button)
}
inline ::autofill_assistant::InfoPopupProto_DialogButton* InfoPopupProto::release_neutral_button() {
  _has_bits_[0] &= ~0x00000010u;
  ::autofill_assistant::InfoPopupProto_DialogButton* temp = neutral_button_;
  neutral_button_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::InfoPopupProto_DialogButton* InfoPopupProto::unsafe_arena_release_neutral_button() {
  // @@protoc_insertion_point(field_release:autofill_assistant.InfoPopupProto.neutral_button)
  _has_bits_[0] &= ~0x00000010u;
  ::autofill_assistant::InfoPopupProto_DialogButton* temp = neutral_button_;
  neutral_button_ = nullptr;
  return temp;
}
inline ::autofill_assistant::InfoPopupProto_DialogButton* InfoPopupProto::_internal_mutable_neutral_button() {
  _has_bits_[0] |= 0x00000010u;
  if (neutral_button_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::InfoPopupProto_DialogButton>(GetArenaForAllocation());
    neutral_button_ = p;
  }
  return neutral_button_;
}
inline ::autofill_assistant::InfoPopupProto_DialogButton* InfoPopupProto::mutable_neutral_button() {
  ::autofill_assistant::InfoPopupProto_DialogButton* _msg = _internal_mutable_neutral_button();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.InfoPopupProto.neutral_button)
  return _msg;
}
inline void InfoPopupProto::set_allocated_neutral_button(::autofill_assistant::InfoPopupProto_DialogButton* neutral_button) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete neutral_button_;
  }
  if (neutral_button) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(neutral_button);
    if (message_arena != submessage_arena) {
      neutral_button = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, neutral_button, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  neutral_button_ = neutral_button;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.InfoPopupProto.neutral_button)
}

// -------------------------------------------------------------------

// ToggleButtonViewProto_CheckBox

// -------------------------------------------------------------------

// ToggleButtonViewProto_RadioButton

// optional string radio_group_identifier = 1;
inline bool ToggleButtonViewProto_RadioButton::_internal_has_radio_group_identifier() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ToggleButtonViewProto_RadioButton::has_radio_group_identifier() const {
  return _internal_has_radio_group_identifier();
}
inline void ToggleButtonViewProto_RadioButton::clear_radio_group_identifier() {
  radio_group_identifier_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ToggleButtonViewProto_RadioButton::radio_group_identifier() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ToggleButtonViewProto.RadioButton.radio_group_identifier)
  return _internal_radio_group_identifier();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ToggleButtonViewProto_RadioButton::set_radio_group_identifier(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 radio_group_identifier_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.ToggleButtonViewProto.RadioButton.radio_group_identifier)
}
inline std::string* ToggleButtonViewProto_RadioButton::mutable_radio_group_identifier() {
  std::string* _s = _internal_mutable_radio_group_identifier();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ToggleButtonViewProto.RadioButton.radio_group_identifier)
  return _s;
}
inline const std::string& ToggleButtonViewProto_RadioButton::_internal_radio_group_identifier() const {
  return radio_group_identifier_.Get();
}
inline void ToggleButtonViewProto_RadioButton::_internal_set_radio_group_identifier(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  radio_group_identifier_.Set(value, GetArenaForAllocation());
}
inline std::string* ToggleButtonViewProto_RadioButton::_internal_mutable_radio_group_identifier() {
  _has_bits_[0] |= 0x00000001u;
  return radio_group_identifier_.Mutable(GetArenaForAllocation());
}
inline std::string* ToggleButtonViewProto_RadioButton::release_radio_group_identifier() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ToggleButtonViewProto.RadioButton.radio_group_identifier)
  if (!_internal_has_radio_group_identifier()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = radio_group_identifier_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (radio_group_identifier_.IsDefault()) {
    radio_group_identifier_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ToggleButtonViewProto_RadioButton::set_allocated_radio_group_identifier(std::string* radio_group_identifier) {
  if (radio_group_identifier != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  radio_group_identifier_.SetAllocated(radio_group_identifier, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (radio_group_identifier_.IsDefault()) {
    radio_group_identifier_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ToggleButtonViewProto.RadioButton.radio_group_identifier)
}

// -------------------------------------------------------------------

// ToggleButtonViewProto

// .autofill_assistant.ToggleButtonViewProto.CheckBox check_box = 1;
inline bool ToggleButtonViewProto::_internal_has_check_box() const {
  return kind_case() == kCheckBox;
}
inline bool ToggleButtonViewProto::has_check_box() const {
  return _internal_has_check_box();
}
inline void ToggleButtonViewProto::set_has_check_box() {
  _oneof_case_[0] = kCheckBox;
}
inline void ToggleButtonViewProto::clear_check_box() {
  if (_internal_has_check_box()) {
    if (GetArenaForAllocation() == nullptr) {
      delete kind_.check_box_;
    }
    clear_has_kind();
  }
}
inline ::autofill_assistant::ToggleButtonViewProto_CheckBox* ToggleButtonViewProto::release_check_box() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ToggleButtonViewProto.check_box)
  if (_internal_has_check_box()) {
    clear_has_kind();
    ::autofill_assistant::ToggleButtonViewProto_CheckBox* temp = kind_.check_box_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    kind_.check_box_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::ToggleButtonViewProto_CheckBox& ToggleButtonViewProto::_internal_check_box() const {
  return _internal_has_check_box()
      ? *kind_.check_box_
      : reinterpret_cast< ::autofill_assistant::ToggleButtonViewProto_CheckBox&>(::autofill_assistant::_ToggleButtonViewProto_CheckBox_default_instance_);
}
inline const ::autofill_assistant::ToggleButtonViewProto_CheckBox& ToggleButtonViewProto::check_box() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ToggleButtonViewProto.check_box)
  return _internal_check_box();
}
inline ::autofill_assistant::ToggleButtonViewProto_CheckBox* ToggleButtonViewProto::unsafe_arena_release_check_box() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.ToggleButtonViewProto.check_box)
  if (_internal_has_check_box()) {
    clear_has_kind();
    ::autofill_assistant::ToggleButtonViewProto_CheckBox* temp = kind_.check_box_;
    kind_.check_box_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ToggleButtonViewProto::unsafe_arena_set_allocated_check_box(::autofill_assistant::ToggleButtonViewProto_CheckBox* check_box) {
  clear_kind();
  if (check_box) {
    set_has_check_box();
    kind_.check_box_ = check_box;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ToggleButtonViewProto.check_box)
}
inline ::autofill_assistant::ToggleButtonViewProto_CheckBox* ToggleButtonViewProto::_internal_mutable_check_box() {
  if (!_internal_has_check_box()) {
    clear_kind();
    set_has_check_box();
    kind_.check_box_ = CreateMaybeMessage< ::autofill_assistant::ToggleButtonViewProto_CheckBox >(GetArenaForAllocation());
  }
  return kind_.check_box_;
}
inline ::autofill_assistant::ToggleButtonViewProto_CheckBox* ToggleButtonViewProto::mutable_check_box() {
  ::autofill_assistant::ToggleButtonViewProto_CheckBox* _msg = _internal_mutable_check_box();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ToggleButtonViewProto.check_box)
  return _msg;
}

// .autofill_assistant.ToggleButtonViewProto.RadioButton radio_button = 2;
inline bool ToggleButtonViewProto::_internal_has_radio_button() const {
  return kind_case() == kRadioButton;
}
inline bool ToggleButtonViewProto::has_radio_button() const {
  return _internal_has_radio_button();
}
inline void ToggleButtonViewProto::set_has_radio_button() {
  _oneof_case_[0] = kRadioButton;
}
inline void ToggleButtonViewProto::clear_radio_button() {
  if (_internal_has_radio_button()) {
    if (GetArenaForAllocation() == nullptr) {
      delete kind_.radio_button_;
    }
    clear_has_kind();
  }
}
inline ::autofill_assistant::ToggleButtonViewProto_RadioButton* ToggleButtonViewProto::release_radio_button() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ToggleButtonViewProto.radio_button)
  if (_internal_has_radio_button()) {
    clear_has_kind();
    ::autofill_assistant::ToggleButtonViewProto_RadioButton* temp = kind_.radio_button_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    kind_.radio_button_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::autofill_assistant::ToggleButtonViewProto_RadioButton& ToggleButtonViewProto::_internal_radio_button() const {
  return _internal_has_radio_button()
      ? *kind_.radio_button_
      : reinterpret_cast< ::autofill_assistant::ToggleButtonViewProto_RadioButton&>(::autofill_assistant::_ToggleButtonViewProto_RadioButton_default_instance_);
}
inline const ::autofill_assistant::ToggleButtonViewProto_RadioButton& ToggleButtonViewProto::radio_button() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ToggleButtonViewProto.radio_button)
  return _internal_radio_button();
}
inline ::autofill_assistant::ToggleButtonViewProto_RadioButton* ToggleButtonViewProto::unsafe_arena_release_radio_button() {
  // @@protoc_insertion_point(field_unsafe_arena_release:autofill_assistant.ToggleButtonViewProto.radio_button)
  if (_internal_has_radio_button()) {
    clear_has_kind();
    ::autofill_assistant::ToggleButtonViewProto_RadioButton* temp = kind_.radio_button_;
    kind_.radio_button_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ToggleButtonViewProto::unsafe_arena_set_allocated_radio_button(::autofill_assistant::ToggleButtonViewProto_RadioButton* radio_button) {
  clear_kind();
  if (radio_button) {
    set_has_radio_button();
    kind_.radio_button_ = radio_button;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ToggleButtonViewProto.radio_button)
}
inline ::autofill_assistant::ToggleButtonViewProto_RadioButton* ToggleButtonViewProto::_internal_mutable_radio_button() {
  if (!_internal_has_radio_button()) {
    clear_kind();
    set_has_radio_button();
    kind_.radio_button_ = CreateMaybeMessage< ::autofill_assistant::ToggleButtonViewProto_RadioButton >(GetArenaForAllocation());
  }
  return kind_.radio_button_;
}
inline ::autofill_assistant::ToggleButtonViewProto_RadioButton* ToggleButtonViewProto::mutable_radio_button() {
  ::autofill_assistant::ToggleButtonViewProto_RadioButton* _msg = _internal_mutable_radio_button();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ToggleButtonViewProto.radio_button)
  return _msg;
}

// optional .autofill_assistant.ViewProto left_content_view = 3;
inline bool ToggleButtonViewProto::_internal_has_left_content_view() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || left_content_view_ != nullptr);
  return value;
}
inline bool ToggleButtonViewProto::has_left_content_view() const {
  return _internal_has_left_content_view();
}
inline void ToggleButtonViewProto::clear_left_content_view() {
  if (left_content_view_ != nullptr) left_content_view_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::autofill_assistant::ViewProto& ToggleButtonViewProto::_internal_left_content_view() const {
  const ::autofill_assistant::ViewProto* p = left_content_view_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::ViewProto&>(
      ::autofill_assistant::_ViewProto_default_instance_);
}
inline const ::autofill_assistant::ViewProto& ToggleButtonViewProto::left_content_view() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ToggleButtonViewProto.left_content_view)
  return _internal_left_content_view();
}
inline void ToggleButtonViewProto::unsafe_arena_set_allocated_left_content_view(
    ::autofill_assistant::ViewProto* left_content_view) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(left_content_view_);
  }
  left_content_view_ = left_content_view;
  if (left_content_view) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ToggleButtonViewProto.left_content_view)
}
inline ::autofill_assistant::ViewProto* ToggleButtonViewProto::release_left_content_view() {
  _has_bits_[0] &= ~0x00000002u;
  ::autofill_assistant::ViewProto* temp = left_content_view_;
  left_content_view_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::ViewProto* ToggleButtonViewProto::unsafe_arena_release_left_content_view() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ToggleButtonViewProto.left_content_view)
  _has_bits_[0] &= ~0x00000002u;
  ::autofill_assistant::ViewProto* temp = left_content_view_;
  left_content_view_ = nullptr;
  return temp;
}
inline ::autofill_assistant::ViewProto* ToggleButtonViewProto::_internal_mutable_left_content_view() {
  _has_bits_[0] |= 0x00000002u;
  if (left_content_view_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::ViewProto>(GetArenaForAllocation());
    left_content_view_ = p;
  }
  return left_content_view_;
}
inline ::autofill_assistant::ViewProto* ToggleButtonViewProto::mutable_left_content_view() {
  ::autofill_assistant::ViewProto* _msg = _internal_mutable_left_content_view();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ToggleButtonViewProto.left_content_view)
  return _msg;
}
inline void ToggleButtonViewProto::set_allocated_left_content_view(::autofill_assistant::ViewProto* left_content_view) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete left_content_view_;
  }
  if (left_content_view) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(left_content_view);
    if (message_arena != submessage_arena) {
      left_content_view = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, left_content_view, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  left_content_view_ = left_content_view;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ToggleButtonViewProto.left_content_view)
}

// optional .autofill_assistant.ViewProto right_content_view = 4;
inline bool ToggleButtonViewProto::_internal_has_right_content_view() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || right_content_view_ != nullptr);
  return value;
}
inline bool ToggleButtonViewProto::has_right_content_view() const {
  return _internal_has_right_content_view();
}
inline void ToggleButtonViewProto::clear_right_content_view() {
  if (right_content_view_ != nullptr) right_content_view_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::autofill_assistant::ViewProto& ToggleButtonViewProto::_internal_right_content_view() const {
  const ::autofill_assistant::ViewProto* p = right_content_view_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill_assistant::ViewProto&>(
      ::autofill_assistant::_ViewProto_default_instance_);
}
inline const ::autofill_assistant::ViewProto& ToggleButtonViewProto::right_content_view() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ToggleButtonViewProto.right_content_view)
  return _internal_right_content_view();
}
inline void ToggleButtonViewProto::unsafe_arena_set_allocated_right_content_view(
    ::autofill_assistant::ViewProto* right_content_view) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(right_content_view_);
  }
  right_content_view_ = right_content_view;
  if (right_content_view) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill_assistant.ToggleButtonViewProto.right_content_view)
}
inline ::autofill_assistant::ViewProto* ToggleButtonViewProto::release_right_content_view() {
  _has_bits_[0] &= ~0x00000004u;
  ::autofill_assistant::ViewProto* temp = right_content_view_;
  right_content_view_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill_assistant::ViewProto* ToggleButtonViewProto::unsafe_arena_release_right_content_view() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ToggleButtonViewProto.right_content_view)
  _has_bits_[0] &= ~0x00000004u;
  ::autofill_assistant::ViewProto* temp = right_content_view_;
  right_content_view_ = nullptr;
  return temp;
}
inline ::autofill_assistant::ViewProto* ToggleButtonViewProto::_internal_mutable_right_content_view() {
  _has_bits_[0] |= 0x00000004u;
  if (right_content_view_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill_assistant::ViewProto>(GetArenaForAllocation());
    right_content_view_ = p;
  }
  return right_content_view_;
}
inline ::autofill_assistant::ViewProto* ToggleButtonViewProto::mutable_right_content_view() {
  ::autofill_assistant::ViewProto* _msg = _internal_mutable_right_content_view();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ToggleButtonViewProto.right_content_view)
  return _msg;
}
inline void ToggleButtonViewProto::set_allocated_right_content_view(::autofill_assistant::ViewProto* right_content_view) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete right_content_view_;
  }
  if (right_content_view) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(right_content_view);
    if (message_arena != submessage_arena) {
      right_content_view = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, right_content_view, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  right_content_view_ = right_content_view;
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ToggleButtonViewProto.right_content_view)
}

// optional string model_identifier = 5;
inline bool ToggleButtonViewProto::_internal_has_model_identifier() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ToggleButtonViewProto::has_model_identifier() const {
  return _internal_has_model_identifier();
}
inline void ToggleButtonViewProto::clear_model_identifier() {
  model_identifier_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ToggleButtonViewProto::model_identifier() const {
  // @@protoc_insertion_point(field_get:autofill_assistant.ToggleButtonViewProto.model_identifier)
  return _internal_model_identifier();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ToggleButtonViewProto::set_model_identifier(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 model_identifier_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill_assistant.ToggleButtonViewProto.model_identifier)
}
inline std::string* ToggleButtonViewProto::mutable_model_identifier() {
  std::string* _s = _internal_mutable_model_identifier();
  // @@protoc_insertion_point(field_mutable:autofill_assistant.ToggleButtonViewProto.model_identifier)
  return _s;
}
inline const std::string& ToggleButtonViewProto::_internal_model_identifier() const {
  return model_identifier_.Get();
}
inline void ToggleButtonViewProto::_internal_set_model_identifier(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  model_identifier_.Set(value, GetArenaForAllocation());
}
inline std::string* ToggleButtonViewProto::_internal_mutable_model_identifier() {
  _has_bits_[0] |= 0x00000001u;
  return model_identifier_.Mutable(GetArenaForAllocation());
}
inline std::string* ToggleButtonViewProto::release_model_identifier() {
  // @@protoc_insertion_point(field_release:autofill_assistant.ToggleButtonViewProto.model_identifier)
  if (!_internal_has_model_identifier()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = model_identifier_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (model_identifier_.IsDefault()) {
    model_identifier_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ToggleButtonViewProto::set_allocated_model_identifier(std::string* model_identifier) {
  if (model_identifier != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  model_identifier_.SetAllocated(model_identifier, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (model_identifier_.IsDefault()) {
    model_identifier_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ToggleButtonViewProto.model_identifier)
}

inline bool ToggleButtonViewProto::has_kind() const {
  return kind_case() != KIND_NOT_SET;
}
inline void ToggleButtonViewProto::clear_has_kind() {
  _oneof_case_[0] = KIND_NOT_SET;
}
inline ToggleButtonViewProto::KindCase ToggleButtonViewProto::kind_case() const {
  return ToggleButtonViewProto::KindCase(_oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace autofill_assistant

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::autofill_assistant::DrawableProto_Icon> : ::std::true_type {};
template <> struct is_proto_enum< ::autofill_assistant::ViewLayoutParamsProto_Gravity> : ::std::true_type {};
template <> struct is_proto_enum< ::autofill_assistant::ViewLayoutParamsProto_Size> : ::std::true_type {};
template <> struct is_proto_enum< ::autofill_assistant::LinearLayoutProto_Orientation> : ::std::true_type {};
template <> struct is_proto_enum< ::autofill_assistant::VerticalExpanderViewProto_ChevronStyle> : ::std::true_type {};
template <> struct is_proto_enum< ::autofill_assistant::TextInputViewProto_InputTypeHint> : ::std::true_type {};

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_components_2fautofill_5fassistant_2fbrowser_2fview_5flayout_2eproto
