// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: components/autofill_assistant/browser/view_layout.proto

#include "components/autofill_assistant/browser/view_layout.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace autofill_assistant {
PROTOBUF_CONSTEXPR ViewProto::ViewProto(
    ::_pbi::ConstantInitialized)
  : identifier_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , attributes_(nullptr)
  , layout_params_(nullptr)
  , _oneof_case_{}{}
struct ViewProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ViewProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ViewProtoDefaultTypeInternal() {}
  union {
    ViewProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ViewProtoDefaultTypeInternal _ViewProto_default_instance_;
PROTOBUF_CONSTEXPR ColorProto::ColorProto(
    ::_pbi::ConstantInitialized)
  : _oneof_case_{}{}
struct ColorProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ColorProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ColorProtoDefaultTypeInternal() {}
  union {
    ColorProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ColorProtoDefaultTypeInternal _ColorProto_default_instance_;
PROTOBUF_CONSTEXPR ClientDimensionProto::ClientDimensionProto(
    ::_pbi::ConstantInitialized)
  : _oneof_case_{}{}
struct ClientDimensionProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ClientDimensionProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ClientDimensionProtoDefaultTypeInternal() {}
  union {
    ClientDimensionProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClientDimensionProtoDefaultTypeInternal _ClientDimensionProto_default_instance_;
PROTOBUF_CONSTEXPR ShapeDrawableProto_Rectangle::ShapeDrawableProto_Rectangle(
    ::_pbi::ConstantInitialized)
  : corner_radius_(nullptr){}
struct ShapeDrawableProto_RectangleDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ShapeDrawableProto_RectangleDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ShapeDrawableProto_RectangleDefaultTypeInternal() {}
  union {
    ShapeDrawableProto_Rectangle _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ShapeDrawableProto_RectangleDefaultTypeInternal _ShapeDrawableProto_Rectangle_default_instance_;
PROTOBUF_CONSTEXPR ShapeDrawableProto::ShapeDrawableProto(
    ::_pbi::ConstantInitialized)
  : background_color_(nullptr)
  , stroke_width_(nullptr)
  , stroke_color_(nullptr)
  , _oneof_case_{}{}
struct ShapeDrawableProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ShapeDrawableProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ShapeDrawableProtoDefaultTypeInternal() {}
  union {
    ShapeDrawableProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ShapeDrawableProtoDefaultTypeInternal _ShapeDrawableProto_default_instance_;
PROTOBUF_CONSTEXPR ConfigBasedUrlProto_UrlEntry_DoNotUse::ConfigBasedUrlProto_UrlEntry_DoNotUse(
    ::_pbi::ConstantInitialized){}
struct ConfigBasedUrlProto_UrlEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ConfigBasedUrlProto_UrlEntry_DoNotUseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ConfigBasedUrlProto_UrlEntry_DoNotUseDefaultTypeInternal() {}
  union {
    ConfigBasedUrlProto_UrlEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ConfigBasedUrlProto_UrlEntry_DoNotUseDefaultTypeInternal _ConfigBasedUrlProto_UrlEntry_DoNotUse_default_instance_;
PROTOBUF_CONSTEXPR ConfigBasedUrlProto::ConfigBasedUrlProto(
    ::_pbi::ConstantInitialized)
  : url_(){}
struct ConfigBasedUrlProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ConfigBasedUrlProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ConfigBasedUrlProtoDefaultTypeInternal() {}
  union {
    ConfigBasedUrlProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ConfigBasedUrlProtoDefaultTypeInternal _ConfigBasedUrlProto_default_instance_;
PROTOBUF_CONSTEXPR BitmapDrawableProto::BitmapDrawableProto(
    ::_pbi::ConstantInitialized)
  : width_(nullptr)
  , height_(nullptr)
  , use_instrinsic_dimensions_(false)
  , _oneof_case_{}{}
struct BitmapDrawableProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BitmapDrawableProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~BitmapDrawableProtoDefaultTypeInternal() {}
  union {
    BitmapDrawableProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BitmapDrawableProtoDefaultTypeInternal _BitmapDrawableProto_default_instance_;
PROTOBUF_CONSTEXPR FaviconDrawableProto::FaviconDrawableProto(
    ::_pbi::ConstantInitialized)
  : website_url_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , diameter_size_(nullptr)
  , force_monogram_(false){}
struct FaviconDrawableProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FaviconDrawableProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FaviconDrawableProtoDefaultTypeInternal() {}
  union {
    FaviconDrawableProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FaviconDrawableProtoDefaultTypeInternal _FaviconDrawableProto_default_instance_;
PROTOBUF_CONSTEXPR DrawableProto::DrawableProto(
    ::_pbi::ConstantInitialized)
  : _oneof_case_{}{}
struct DrawableProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DrawableProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DrawableProtoDefaultTypeInternal() {}
  union {
    DrawableProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DrawableProtoDefaultTypeInternal _DrawableProto_default_instance_;
PROTOBUF_CONSTEXPR ViewAttributesProto::ViewAttributesProto(
    ::_pbi::ConstantInitialized)
  : content_description_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , background_(nullptr)
  , padding_start_(0)
  , padding_top_(0)
  , padding_end_(0)
  , padding_bottom_(0)
  , visible_(true)
  , enabled_(true){}
struct ViewAttributesProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ViewAttributesProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ViewAttributesProtoDefaultTypeInternal() {}
  union {
    ViewAttributesProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ViewAttributesProtoDefaultTypeInternal _ViewAttributesProto_default_instance_;
PROTOBUF_CONSTEXPR ViewLayoutParamsProto::ViewLayoutParamsProto(
    ::_pbi::ConstantInitialized)
  : margin_start_(0)
  , margin_top_(0)
  , margin_end_(0)
  , margin_bottom_(0)
  , layout_gravity_(0)
  , layout_weight_(0)
  , minimum_width_(0)
  , minimum_height_(0)
  , layout_width_(-2)
  , layout_height_(-2){}
struct ViewLayoutParamsProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ViewLayoutParamsProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ViewLayoutParamsProtoDefaultTypeInternal() {}
  union {
    ViewLayoutParamsProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ViewLayoutParamsProtoDefaultTypeInternal _ViewLayoutParamsProto_default_instance_;
PROTOBUF_CONSTEXPR ViewContainerProto::ViewContainerProto(
    ::_pbi::ConstantInitialized)
  : views_()
  , _oneof_case_{}{}
struct ViewContainerProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ViewContainerProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ViewContainerProtoDefaultTypeInternal() {}
  union {
    ViewContainerProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ViewContainerProtoDefaultTypeInternal _ViewContainerProto_default_instance_;
PROTOBUF_CONSTEXPR LinearLayoutProto::LinearLayoutProto(
    ::_pbi::ConstantInitialized)
  : orientation_(0)
{}
struct LinearLayoutProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LinearLayoutProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LinearLayoutProtoDefaultTypeInternal() {}
  union {
    LinearLayoutProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LinearLayoutProtoDefaultTypeInternal _LinearLayoutProto_default_instance_;
PROTOBUF_CONSTEXPR VerticalExpanderViewProto::VerticalExpanderViewProto(
    ::_pbi::ConstantInitialized)
  : title_view_(nullptr)
  , collapsed_view_(nullptr)
  , expanded_view_(nullptr)
  , chevron_style_(0)
{}
struct VerticalExpanderViewProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR VerticalExpanderViewProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~VerticalExpanderViewProtoDefaultTypeInternal() {}
  union {
    VerticalExpanderViewProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VerticalExpanderViewProtoDefaultTypeInternal _VerticalExpanderViewProto_default_instance_;
PROTOBUF_CONSTEXPR VerticalExpanderAccordionProto::VerticalExpanderAccordionProto(
    ::_pbi::ConstantInitialized)
  : orientation_(0)
{}
struct VerticalExpanderAccordionProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR VerticalExpanderAccordionProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~VerticalExpanderAccordionProtoDefaultTypeInternal() {}
  union {
    VerticalExpanderAccordionProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VerticalExpanderAccordionProtoDefaultTypeInternal _VerticalExpanderAccordionProto_default_instance_;
PROTOBUF_CONSTEXPR TextViewProto::TextViewProto(
    ::_pbi::ConstantInitialized)
  : text_appearance_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , text_alignment_(8388659)
  , _oneof_case_{}{}
struct TextViewProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TextViewProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TextViewProtoDefaultTypeInternal() {}
  union {
    TextViewProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TextViewProtoDefaultTypeInternal _TextViewProto_default_instance_;
PROTOBUF_CONSTEXPR DividerViewProto::DividerViewProto(
    ::_pbi::ConstantInitialized){}
struct DividerViewProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DividerViewProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DividerViewProtoDefaultTypeInternal() {}
  union {
    DividerViewProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DividerViewProtoDefaultTypeInternal _DividerViewProto_default_instance_;
PROTOBUF_CONSTEXPR ImageViewProto::ImageViewProto(
    ::_pbi::ConstantInitialized)
  : image_(nullptr){}
struct ImageViewProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ImageViewProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ImageViewProtoDefaultTypeInternal() {}
  union {
    ImageViewProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ImageViewProtoDefaultTypeInternal _ImageViewProto_default_instance_;
PROTOBUF_CONSTEXPR TextInputViewProto::TextInputViewProto(
    ::_pbi::ConstantInitialized)
  : hint_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , model_identifier_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , type_(0)

  , focus_and_show_keyboard_(false){}
struct TextInputViewProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TextInputViewProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TextInputViewProtoDefaultTypeInternal() {}
  union {
    TextInputViewProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TextInputViewProtoDefaultTypeInternal _TextInputViewProto_default_instance_;
PROTOBUF_CONSTEXPR InfoPopupProto_DialogButton_CloseDialog::InfoPopupProto_DialogButton_CloseDialog(
    ::_pbi::ConstantInitialized){}
struct InfoPopupProto_DialogButton_CloseDialogDefaultTypeInternal {
  PROTOBUF_CONSTEXPR InfoPopupProto_DialogButton_CloseDialogDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~InfoPopupProto_DialogButton_CloseDialogDefaultTypeInternal() {}
  union {
    InfoPopupProto_DialogButton_CloseDialog _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 InfoPopupProto_DialogButton_CloseDialogDefaultTypeInternal _InfoPopupProto_DialogButton_CloseDialog_default_instance_;
PROTOBUF_CONSTEXPR InfoPopupProto_DialogButton_OpenUrlInCCT::InfoPopupProto_DialogButton_OpenUrlInCCT(
    ::_pbi::ConstantInitialized)
  : url_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}){}
struct InfoPopupProto_DialogButton_OpenUrlInCCTDefaultTypeInternal {
  PROTOBUF_CONSTEXPR InfoPopupProto_DialogButton_OpenUrlInCCTDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~InfoPopupProto_DialogButton_OpenUrlInCCTDefaultTypeInternal() {}
  union {
    InfoPopupProto_DialogButton_OpenUrlInCCT _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 InfoPopupProto_DialogButton_OpenUrlInCCTDefaultTypeInternal _InfoPopupProto_DialogButton_OpenUrlInCCT_default_instance_;
PROTOBUF_CONSTEXPR InfoPopupProto_DialogButton::InfoPopupProto_DialogButton(
    ::_pbi::ConstantInitialized)
  : label_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , _oneof_case_{}{}
struct InfoPopupProto_DialogButtonDefaultTypeInternal {
  PROTOBUF_CONSTEXPR InfoPopupProto_DialogButtonDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~InfoPopupProto_DialogButtonDefaultTypeInternal() {}
  union {
    InfoPopupProto_DialogButton _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 InfoPopupProto_DialogButtonDefaultTypeInternal _InfoPopupProto_DialogButton_default_instance_;
PROTOBUF_CONSTEXPR InfoPopupProto::InfoPopupProto(
    ::_pbi::ConstantInitialized)
  : title_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , text_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , positive_button_(nullptr)
  , negative_button_(nullptr)
  , neutral_button_(nullptr){}
struct InfoPopupProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR InfoPopupProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~InfoPopupProtoDefaultTypeInternal() {}
  union {
    InfoPopupProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 InfoPopupProtoDefaultTypeInternal _InfoPopupProto_default_instance_;
PROTOBUF_CONSTEXPR ToggleButtonViewProto_CheckBox::ToggleButtonViewProto_CheckBox(
    ::_pbi::ConstantInitialized){}
struct ToggleButtonViewProto_CheckBoxDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ToggleButtonViewProto_CheckBoxDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ToggleButtonViewProto_CheckBoxDefaultTypeInternal() {}
  union {
    ToggleButtonViewProto_CheckBox _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ToggleButtonViewProto_CheckBoxDefaultTypeInternal _ToggleButtonViewProto_CheckBox_default_instance_;
PROTOBUF_CONSTEXPR ToggleButtonViewProto_RadioButton::ToggleButtonViewProto_RadioButton(
    ::_pbi::ConstantInitialized)
  : radio_group_identifier_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}){}
struct ToggleButtonViewProto_RadioButtonDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ToggleButtonViewProto_RadioButtonDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ToggleButtonViewProto_RadioButtonDefaultTypeInternal() {}
  union {
    ToggleButtonViewProto_RadioButton _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ToggleButtonViewProto_RadioButtonDefaultTypeInternal _ToggleButtonViewProto_RadioButton_default_instance_;
PROTOBUF_CONSTEXPR ToggleButtonViewProto::ToggleButtonViewProto(
    ::_pbi::ConstantInitialized)
  : model_identifier_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , left_content_view_(nullptr)
  , right_content_view_(nullptr)
  , _oneof_case_{}{}
struct ToggleButtonViewProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ToggleButtonViewProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ToggleButtonViewProtoDefaultTypeInternal() {}
  union {
    ToggleButtonViewProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ToggleButtonViewProtoDefaultTypeInternal _ToggleButtonViewProto_default_instance_;
}  // namespace autofill_assistant
namespace autofill_assistant {
bool DrawableProto_Icon_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> DrawableProto_Icon_strings[16] = {};

static const char DrawableProto_Icon_names[] =
  "CAR"
  "COGWHEEL"
  "DRAWABLE_ICON_UNDEFINED"
  "FAST_FOOD"
  "GROCERY"
  "KEY"
  "LOCAL_DINING"
  "PROGRESSBAR_DEFAULT_DATA_COLLECTION"
  "PROGRESSBAR_DEFAULT_FINAL_STEP"
  "PROGRESSBAR_DEFAULT_INITIAL_STEP"
  "PROGRESSBAR_DEFAULT_PAYMENT"
  "SHOPPING_BASKET"
  "SITTING_PERSON"
  "TICKET_STUB"
  "VISIBILITY_OFF"
  "VISIBILITY_ON";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry DrawableProto_Icon_entries[] = {
  { {DrawableProto_Icon_names + 0, 3}, 12 },
  { {DrawableProto_Icon_names + 3, 8}, 10 },
  { {DrawableProto_Icon_names + 11, 23}, 0 },
  { {DrawableProto_Icon_names + 34, 9}, 8 },
  { {DrawableProto_Icon_names + 43, 7}, 13 },
  { {DrawableProto_Icon_names + 50, 3}, 11 },
  { {DrawableProto_Icon_names + 53, 12}, 9 },
  { {DrawableProto_Icon_names + 65, 35}, 2 },
  { {DrawableProto_Icon_names + 100, 30}, 4 },
  { {DrawableProto_Icon_names + 130, 32}, 1 },
  { {DrawableProto_Icon_names + 162, 27}, 3 },
  { {DrawableProto_Icon_names + 189, 15}, 7 },
  { {DrawableProto_Icon_names + 204, 14}, 5 },
  { {DrawableProto_Icon_names + 218, 11}, 6 },
  { {DrawableProto_Icon_names + 229, 14}, 15 },
  { {DrawableProto_Icon_names + 243, 13}, 14 },
};

static const int DrawableProto_Icon_entries_by_number[] = {
  2, // 0 -> DRAWABLE_ICON_UNDEFINED
  9, // 1 -> PROGRESSBAR_DEFAULT_INITIAL_STEP
  7, // 2 -> PROGRESSBAR_DEFAULT_DATA_COLLECTION
  10, // 3 -> PROGRESSBAR_DEFAULT_PAYMENT
  8, // 4 -> PROGRESSBAR_DEFAULT_FINAL_STEP
  12, // 5 -> SITTING_PERSON
  13, // 6 -> TICKET_STUB
  11, // 7 -> SHOPPING_BASKET
  3, // 8 -> FAST_FOOD
  6, // 9 -> LOCAL_DINING
  1, // 10 -> COGWHEEL
  5, // 11 -> KEY
  0, // 12 -> CAR
  4, // 13 -> GROCERY
  15, // 14 -> VISIBILITY_ON
  14, // 15 -> VISIBILITY_OFF
};

const std::string& DrawableProto_Icon_Name(
    DrawableProto_Icon value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          DrawableProto_Icon_entries,
          DrawableProto_Icon_entries_by_number,
          16, DrawableProto_Icon_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      DrawableProto_Icon_entries,
      DrawableProto_Icon_entries_by_number,
      16, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     DrawableProto_Icon_strings[idx].get();
}
bool DrawableProto_Icon_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DrawableProto_Icon* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      DrawableProto_Icon_entries, 16, name, &int_value);
  if (success) {
    *value = static_cast<DrawableProto_Icon>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr DrawableProto_Icon DrawableProto::DRAWABLE_ICON_UNDEFINED;
constexpr DrawableProto_Icon DrawableProto::PROGRESSBAR_DEFAULT_INITIAL_STEP;
constexpr DrawableProto_Icon DrawableProto::PROGRESSBAR_DEFAULT_DATA_COLLECTION;
constexpr DrawableProto_Icon DrawableProto::PROGRESSBAR_DEFAULT_PAYMENT;
constexpr DrawableProto_Icon DrawableProto::PROGRESSBAR_DEFAULT_FINAL_STEP;
constexpr DrawableProto_Icon DrawableProto::SITTING_PERSON;
constexpr DrawableProto_Icon DrawableProto::TICKET_STUB;
constexpr DrawableProto_Icon DrawableProto::SHOPPING_BASKET;
constexpr DrawableProto_Icon DrawableProto::FAST_FOOD;
constexpr DrawableProto_Icon DrawableProto::LOCAL_DINING;
constexpr DrawableProto_Icon DrawableProto::COGWHEEL;
constexpr DrawableProto_Icon DrawableProto::KEY;
constexpr DrawableProto_Icon DrawableProto::CAR;
constexpr DrawableProto_Icon DrawableProto::GROCERY;
constexpr DrawableProto_Icon DrawableProto::VISIBILITY_ON;
constexpr DrawableProto_Icon DrawableProto::VISIBILITY_OFF;
constexpr DrawableProto_Icon DrawableProto::Icon_MIN;
constexpr DrawableProto_Icon DrawableProto::Icon_MAX;
constexpr int DrawableProto::Icon_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool ViewLayoutParamsProto_Gravity_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 7:
    case 16:
    case 17:
    case 48:
    case 80:
    case 112:
    case 8388611:
    case 8388613:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ViewLayoutParamsProto_Gravity_strings[10] = {};

static const char ViewLayoutParamsProto_Gravity_names[] =
  "BOTTOM"
  "CENTER"
  "CENTER_HORIZONTAL"
  "CENTER_VERTICAL"
  "END"
  "FILL_HORIZONTAL"
  "FILL_VERTICAL"
  "START"
  "TOP"
  "UNDEFINED";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ViewLayoutParamsProto_Gravity_entries[] = {
  { {ViewLayoutParamsProto_Gravity_names + 0, 6}, 80 },
  { {ViewLayoutParamsProto_Gravity_names + 6, 6}, 17 },
  { {ViewLayoutParamsProto_Gravity_names + 12, 17}, 1 },
  { {ViewLayoutParamsProto_Gravity_names + 29, 15}, 16 },
  { {ViewLayoutParamsProto_Gravity_names + 44, 3}, 8388613 },
  { {ViewLayoutParamsProto_Gravity_names + 47, 15}, 7 },
  { {ViewLayoutParamsProto_Gravity_names + 62, 13}, 112 },
  { {ViewLayoutParamsProto_Gravity_names + 75, 5}, 8388611 },
  { {ViewLayoutParamsProto_Gravity_names + 80, 3}, 48 },
  { {ViewLayoutParamsProto_Gravity_names + 83, 9}, 0 },
};

static const int ViewLayoutParamsProto_Gravity_entries_by_number[] = {
  9, // 0 -> UNDEFINED
  2, // 1 -> CENTER_HORIZONTAL
  5, // 7 -> FILL_HORIZONTAL
  3, // 16 -> CENTER_VERTICAL
  1, // 17 -> CENTER
  8, // 48 -> TOP
  0, // 80 -> BOTTOM
  6, // 112 -> FILL_VERTICAL
  7, // 8388611 -> START
  4, // 8388613 -> END
};

const std::string& ViewLayoutParamsProto_Gravity_Name(
    ViewLayoutParamsProto_Gravity value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ViewLayoutParamsProto_Gravity_entries,
          ViewLayoutParamsProto_Gravity_entries_by_number,
          10, ViewLayoutParamsProto_Gravity_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ViewLayoutParamsProto_Gravity_entries,
      ViewLayoutParamsProto_Gravity_entries_by_number,
      10, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ViewLayoutParamsProto_Gravity_strings[idx].get();
}
bool ViewLayoutParamsProto_Gravity_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ViewLayoutParamsProto_Gravity* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ViewLayoutParamsProto_Gravity_entries, 10, name, &int_value);
  if (success) {
    *value = static_cast<ViewLayoutParamsProto_Gravity>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ViewLayoutParamsProto_Gravity ViewLayoutParamsProto::UNDEFINED;
constexpr ViewLayoutParamsProto_Gravity ViewLayoutParamsProto::CENTER;
constexpr ViewLayoutParamsProto_Gravity ViewLayoutParamsProto::CENTER_HORIZONTAL;
constexpr ViewLayoutParamsProto_Gravity ViewLayoutParamsProto::CENTER_VERTICAL;
constexpr ViewLayoutParamsProto_Gravity ViewLayoutParamsProto::START;
constexpr ViewLayoutParamsProto_Gravity ViewLayoutParamsProto::TOP;
constexpr ViewLayoutParamsProto_Gravity ViewLayoutParamsProto::END;
constexpr ViewLayoutParamsProto_Gravity ViewLayoutParamsProto::BOTTOM;
constexpr ViewLayoutParamsProto_Gravity ViewLayoutParamsProto::FILL_HORIZONTAL;
constexpr ViewLayoutParamsProto_Gravity ViewLayoutParamsProto::FILL_VERTICAL;
constexpr ViewLayoutParamsProto_Gravity ViewLayoutParamsProto::Gravity_MIN;
constexpr ViewLayoutParamsProto_Gravity ViewLayoutParamsProto::Gravity_MAX;
constexpr int ViewLayoutParamsProto::Gravity_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool ViewLayoutParamsProto_Size_IsValid(int value) {
  switch (value) {
    case -2:
    case -1:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ViewLayoutParamsProto_Size_strings[2] = {};

static const char ViewLayoutParamsProto_Size_names[] =
  "MATCH_PARENT"
  "WRAP_CONTENT";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ViewLayoutParamsProto_Size_entries[] = {
  { {ViewLayoutParamsProto_Size_names + 0, 12}, -1 },
  { {ViewLayoutParamsProto_Size_names + 12, 12}, -2 },
};

static const int ViewLayoutParamsProto_Size_entries_by_number[] = {
  1, // -2 -> WRAP_CONTENT
  0, // -1 -> MATCH_PARENT
};

const std::string& ViewLayoutParamsProto_Size_Name(
    ViewLayoutParamsProto_Size value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ViewLayoutParamsProto_Size_entries,
          ViewLayoutParamsProto_Size_entries_by_number,
          2, ViewLayoutParamsProto_Size_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ViewLayoutParamsProto_Size_entries,
      ViewLayoutParamsProto_Size_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ViewLayoutParamsProto_Size_strings[idx].get();
}
bool ViewLayoutParamsProto_Size_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ViewLayoutParamsProto_Size* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ViewLayoutParamsProto_Size_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<ViewLayoutParamsProto_Size>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ViewLayoutParamsProto_Size ViewLayoutParamsProto::WRAP_CONTENT;
constexpr ViewLayoutParamsProto_Size ViewLayoutParamsProto::MATCH_PARENT;
constexpr ViewLayoutParamsProto_Size ViewLayoutParamsProto::Size_MIN;
constexpr ViewLayoutParamsProto_Size ViewLayoutParamsProto::Size_MAX;
constexpr int ViewLayoutParamsProto::Size_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool LinearLayoutProto_Orientation_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> LinearLayoutProto_Orientation_strings[2] = {};

static const char LinearLayoutProto_Orientation_names[] =
  "HORIZONTAL"
  "VERTICAL";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry LinearLayoutProto_Orientation_entries[] = {
  { {LinearLayoutProto_Orientation_names + 0, 10}, 0 },
  { {LinearLayoutProto_Orientation_names + 10, 8}, 1 },
};

static const int LinearLayoutProto_Orientation_entries_by_number[] = {
  0, // 0 -> HORIZONTAL
  1, // 1 -> VERTICAL
};

const std::string& LinearLayoutProto_Orientation_Name(
    LinearLayoutProto_Orientation value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          LinearLayoutProto_Orientation_entries,
          LinearLayoutProto_Orientation_entries_by_number,
          2, LinearLayoutProto_Orientation_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      LinearLayoutProto_Orientation_entries,
      LinearLayoutProto_Orientation_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     LinearLayoutProto_Orientation_strings[idx].get();
}
bool LinearLayoutProto_Orientation_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, LinearLayoutProto_Orientation* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      LinearLayoutProto_Orientation_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<LinearLayoutProto_Orientation>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr LinearLayoutProto_Orientation LinearLayoutProto::HORIZONTAL;
constexpr LinearLayoutProto_Orientation LinearLayoutProto::VERTICAL;
constexpr LinearLayoutProto_Orientation LinearLayoutProto::Orientation_MIN;
constexpr LinearLayoutProto_Orientation LinearLayoutProto::Orientation_MAX;
constexpr int LinearLayoutProto::Orientation_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool VerticalExpanderViewProto_ChevronStyle_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> VerticalExpanderViewProto_ChevronStyle_strings[3] = {};

static const char VerticalExpanderViewProto_ChevronStyle_names[] =
  "ALWAYS"
  "NEVER"
  "NOT_SET_AUTOMATIC";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry VerticalExpanderViewProto_ChevronStyle_entries[] = {
  { {VerticalExpanderViewProto_ChevronStyle_names + 0, 6}, 1 },
  { {VerticalExpanderViewProto_ChevronStyle_names + 6, 5}, 2 },
  { {VerticalExpanderViewProto_ChevronStyle_names + 11, 17}, 0 },
};

static const int VerticalExpanderViewProto_ChevronStyle_entries_by_number[] = {
  2, // 0 -> NOT_SET_AUTOMATIC
  0, // 1 -> ALWAYS
  1, // 2 -> NEVER
};

const std::string& VerticalExpanderViewProto_ChevronStyle_Name(
    VerticalExpanderViewProto_ChevronStyle value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          VerticalExpanderViewProto_ChevronStyle_entries,
          VerticalExpanderViewProto_ChevronStyle_entries_by_number,
          3, VerticalExpanderViewProto_ChevronStyle_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      VerticalExpanderViewProto_ChevronStyle_entries,
      VerticalExpanderViewProto_ChevronStyle_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     VerticalExpanderViewProto_ChevronStyle_strings[idx].get();
}
bool VerticalExpanderViewProto_ChevronStyle_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, VerticalExpanderViewProto_ChevronStyle* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      VerticalExpanderViewProto_ChevronStyle_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<VerticalExpanderViewProto_ChevronStyle>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr VerticalExpanderViewProto_ChevronStyle VerticalExpanderViewProto::NOT_SET_AUTOMATIC;
constexpr VerticalExpanderViewProto_ChevronStyle VerticalExpanderViewProto::ALWAYS;
constexpr VerticalExpanderViewProto_ChevronStyle VerticalExpanderViewProto::NEVER;
constexpr VerticalExpanderViewProto_ChevronStyle VerticalExpanderViewProto::ChevronStyle_MIN;
constexpr VerticalExpanderViewProto_ChevronStyle VerticalExpanderViewProto::ChevronStyle_MAX;
constexpr int VerticalExpanderViewProto::ChevronStyle_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool TextInputViewProto_InputTypeHint_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> TextInputViewProto_InputTypeHint_strings[9] = {};

static const char TextInputViewProto_InputTypeHint_names[] =
  "ALPHA_NUMERIC"
  "CREDIT_CARD"
  "EMAIL"
  "NONE"
  "NUMERIC"
  "PERSON_NAME"
  "PHONE"
  "REGION"
  "STREET_LINES";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry TextInputViewProto_InputTypeHint_entries[] = {
  { {TextInputViewProto_InputTypeHint_names + 0, 13}, 6 },
  { {TextInputViewProto_InputTypeHint_names + 13, 11}, 7 },
  { {TextInputViewProto_InputTypeHint_names + 24, 5}, 2 },
  { {TextInputViewProto_InputTypeHint_names + 29, 4}, 0 },
  { {TextInputViewProto_InputTypeHint_names + 33, 7}, 8 },
  { {TextInputViewProto_InputTypeHint_names + 40, 11}, 4 },
  { {TextInputViewProto_InputTypeHint_names + 51, 5}, 1 },
  { {TextInputViewProto_InputTypeHint_names + 56, 6}, 5 },
  { {TextInputViewProto_InputTypeHint_names + 62, 12}, 3 },
};

static const int TextInputViewProto_InputTypeHint_entries_by_number[] = {
  3, // 0 -> NONE
  6, // 1 -> PHONE
  2, // 2 -> EMAIL
  8, // 3 -> STREET_LINES
  5, // 4 -> PERSON_NAME
  7, // 5 -> REGION
  0, // 6 -> ALPHA_NUMERIC
  1, // 7 -> CREDIT_CARD
  4, // 8 -> NUMERIC
};

const std::string& TextInputViewProto_InputTypeHint_Name(
    TextInputViewProto_InputTypeHint value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          TextInputViewProto_InputTypeHint_entries,
          TextInputViewProto_InputTypeHint_entries_by_number,
          9, TextInputViewProto_InputTypeHint_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      TextInputViewProto_InputTypeHint_entries,
      TextInputViewProto_InputTypeHint_entries_by_number,
      9, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     TextInputViewProto_InputTypeHint_strings[idx].get();
}
bool TextInputViewProto_InputTypeHint_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TextInputViewProto_InputTypeHint* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      TextInputViewProto_InputTypeHint_entries, 9, name, &int_value);
  if (success) {
    *value = static_cast<TextInputViewProto_InputTypeHint>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr TextInputViewProto_InputTypeHint TextInputViewProto::NONE;
constexpr TextInputViewProto_InputTypeHint TextInputViewProto::PHONE;
constexpr TextInputViewProto_InputTypeHint TextInputViewProto::EMAIL;
constexpr TextInputViewProto_InputTypeHint TextInputViewProto::STREET_LINES;
constexpr TextInputViewProto_InputTypeHint TextInputViewProto::PERSON_NAME;
constexpr TextInputViewProto_InputTypeHint TextInputViewProto::REGION;
constexpr TextInputViewProto_InputTypeHint TextInputViewProto::ALPHA_NUMERIC;
constexpr TextInputViewProto_InputTypeHint TextInputViewProto::CREDIT_CARD;
constexpr TextInputViewProto_InputTypeHint TextInputViewProto::NUMERIC;
constexpr TextInputViewProto_InputTypeHint TextInputViewProto::InputTypeHint_MIN;
constexpr TextInputViewProto_InputTypeHint TextInputViewProto::InputTypeHint_MAX;
constexpr int TextInputViewProto::InputTypeHint_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

// ===================================================================

class ViewProto::_Internal {
 public:
  using HasBits = decltype(std::declval<ViewProto>()._has_bits_);
  static void set_has_identifier(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::autofill_assistant::ViewAttributesProto& attributes(const ViewProto* msg);
  static void set_has_attributes(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::autofill_assistant::ViewLayoutParamsProto& layout_params(const ViewProto* msg);
  static void set_has_layout_params(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::autofill_assistant::ViewContainerProto& view_container(const ViewProto* msg);
  static const ::autofill_assistant::TextViewProto& text_view(const ViewProto* msg);
  static const ::autofill_assistant::DividerViewProto& divider_view(const ViewProto* msg);
  static const ::autofill_assistant::ImageViewProto& image_view(const ViewProto* msg);
  static const ::autofill_assistant::TextInputViewProto& text_input_view(const ViewProto* msg);
  static const ::autofill_assistant::VerticalExpanderViewProto& vertical_expander_view(const ViewProto* msg);
  static const ::autofill_assistant::ToggleButtonViewProto& toggle_button_view(const ViewProto* msg);
};

const ::autofill_assistant::ViewAttributesProto&
ViewProto::_Internal::attributes(const ViewProto* msg) {
  return *msg->attributes_;
}
const ::autofill_assistant::ViewLayoutParamsProto&
ViewProto::_Internal::layout_params(const ViewProto* msg) {
  return *msg->layout_params_;
}
const ::autofill_assistant::ViewContainerProto&
ViewProto::_Internal::view_container(const ViewProto* msg) {
  return *msg->view_.view_container_;
}
const ::autofill_assistant::TextViewProto&
ViewProto::_Internal::text_view(const ViewProto* msg) {
  return *msg->view_.text_view_;
}
const ::autofill_assistant::DividerViewProto&
ViewProto::_Internal::divider_view(const ViewProto* msg) {
  return *msg->view_.divider_view_;
}
const ::autofill_assistant::ImageViewProto&
ViewProto::_Internal::image_view(const ViewProto* msg) {
  return *msg->view_.image_view_;
}
const ::autofill_assistant::TextInputViewProto&
ViewProto::_Internal::text_input_view(const ViewProto* msg) {
  return *msg->view_.text_input_view_;
}
const ::autofill_assistant::VerticalExpanderViewProto&
ViewProto::_Internal::vertical_expander_view(const ViewProto* msg) {
  return *msg->view_.vertical_expander_view_;
}
const ::autofill_assistant::ToggleButtonViewProto&
ViewProto::_Internal::toggle_button_view(const ViewProto* msg) {
  return *msg->view_.toggle_button_view_;
}
void ViewProto::set_allocated_view_container(::autofill_assistant::ViewContainerProto* view_container) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_view();
  if (view_container) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(view_container);
    if (message_arena != submessage_arena) {
      view_container = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, view_container, submessage_arena);
    }
    set_has_view_container();
    view_.view_container_ = view_container;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ViewProto.view_container)
}
void ViewProto::set_allocated_text_view(::autofill_assistant::TextViewProto* text_view) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_view();
  if (text_view) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(text_view);
    if (message_arena != submessage_arena) {
      text_view = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, text_view, submessage_arena);
    }
    set_has_text_view();
    view_.text_view_ = text_view;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ViewProto.text_view)
}
void ViewProto::set_allocated_divider_view(::autofill_assistant::DividerViewProto* divider_view) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_view();
  if (divider_view) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(divider_view);
    if (message_arena != submessage_arena) {
      divider_view = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, divider_view, submessage_arena);
    }
    set_has_divider_view();
    view_.divider_view_ = divider_view;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ViewProto.divider_view)
}
void ViewProto::set_allocated_image_view(::autofill_assistant::ImageViewProto* image_view) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_view();
  if (image_view) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(image_view);
    if (message_arena != submessage_arena) {
      image_view = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, image_view, submessage_arena);
    }
    set_has_image_view();
    view_.image_view_ = image_view;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ViewProto.image_view)
}
void ViewProto::set_allocated_text_input_view(::autofill_assistant::TextInputViewProto* text_input_view) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_view();
  if (text_input_view) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(text_input_view);
    if (message_arena != submessage_arena) {
      text_input_view = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, text_input_view, submessage_arena);
    }
    set_has_text_input_view();
    view_.text_input_view_ = text_input_view;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ViewProto.text_input_view)
}
void ViewProto::set_allocated_vertical_expander_view(::autofill_assistant::VerticalExpanderViewProto* vertical_expander_view) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_view();
  if (vertical_expander_view) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(vertical_expander_view);
    if (message_arena != submessage_arena) {
      vertical_expander_view = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, vertical_expander_view, submessage_arena);
    }
    set_has_vertical_expander_view();
    view_.vertical_expander_view_ = vertical_expander_view;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ViewProto.vertical_expander_view)
}
void ViewProto::set_allocated_toggle_button_view(::autofill_assistant::ToggleButtonViewProto* toggle_button_view) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_view();
  if (toggle_button_view) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(toggle_button_view);
    if (message_arena != submessage_arena) {
      toggle_button_view = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, toggle_button_view, submessage_arena);
    }
    set_has_toggle_button_view();
    view_.toggle_button_view_ = toggle_button_view;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ViewProto.toggle_button_view)
}
ViewProto::ViewProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.ViewProto)
}
ViewProto::ViewProto(const ViewProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  identifier_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    identifier_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_identifier()) {
    identifier_.Set(from._internal_identifier(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_attributes()) {
    attributes_ = new ::autofill_assistant::ViewAttributesProto(*from.attributes_);
  } else {
    attributes_ = nullptr;
  }
  if (from._internal_has_layout_params()) {
    layout_params_ = new ::autofill_assistant::ViewLayoutParamsProto(*from.layout_params_);
  } else {
    layout_params_ = nullptr;
  }
  clear_has_view();
  switch (from.view_case()) {
    case kViewContainer: {
      _internal_mutable_view_container()->::autofill_assistant::ViewContainerProto::MergeFrom(from._internal_view_container());
      break;
    }
    case kTextView: {
      _internal_mutable_text_view()->::autofill_assistant::TextViewProto::MergeFrom(from._internal_text_view());
      break;
    }
    case kDividerView: {
      _internal_mutable_divider_view()->::autofill_assistant::DividerViewProto::MergeFrom(from._internal_divider_view());
      break;
    }
    case kImageView: {
      _internal_mutable_image_view()->::autofill_assistant::ImageViewProto::MergeFrom(from._internal_image_view());
      break;
    }
    case kTextInputView: {
      _internal_mutable_text_input_view()->::autofill_assistant::TextInputViewProto::MergeFrom(from._internal_text_input_view());
      break;
    }
    case kVerticalExpanderView: {
      _internal_mutable_vertical_expander_view()->::autofill_assistant::VerticalExpanderViewProto::MergeFrom(from._internal_vertical_expander_view());
      break;
    }
    case kToggleButtonView: {
      _internal_mutable_toggle_button_view()->::autofill_assistant::ToggleButtonViewProto::MergeFrom(from._internal_toggle_button_view());
      break;
    }
    case VIEW_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.ViewProto)
}

inline void ViewProto::SharedCtor() {
identifier_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  identifier_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&attributes_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&layout_params_) -
    reinterpret_cast<char*>(&attributes_)) + sizeof(layout_params_));
clear_has_view();
}

ViewProto::~ViewProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.ViewProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ViewProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  identifier_.Destroy();
  if (this != internal_default_instance()) delete attributes_;
  if (this != internal_default_instance()) delete layout_params_;
  if (has_view()) {
    clear_view();
  }
}

void ViewProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ViewProto::clear_view() {
// @@protoc_insertion_point(one_of_clear_start:autofill_assistant.ViewProto)
  switch (view_case()) {
    case kViewContainer: {
      if (GetArenaForAllocation() == nullptr) {
        delete view_.view_container_;
      }
      break;
    }
    case kTextView: {
      if (GetArenaForAllocation() == nullptr) {
        delete view_.text_view_;
      }
      break;
    }
    case kDividerView: {
      if (GetArenaForAllocation() == nullptr) {
        delete view_.divider_view_;
      }
      break;
    }
    case kImageView: {
      if (GetArenaForAllocation() == nullptr) {
        delete view_.image_view_;
      }
      break;
    }
    case kTextInputView: {
      if (GetArenaForAllocation() == nullptr) {
        delete view_.text_input_view_;
      }
      break;
    }
    case kVerticalExpanderView: {
      if (GetArenaForAllocation() == nullptr) {
        delete view_.vertical_expander_view_;
      }
      break;
    }
    case kToggleButtonView: {
      if (GetArenaForAllocation() == nullptr) {
        delete view_.toggle_button_view_;
      }
      break;
    }
    case VIEW_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = VIEW_NOT_SET;
}


void ViewProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.ViewProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      identifier_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(attributes_ != nullptr);
      attributes_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(layout_params_ != nullptr);
      layout_params_->Clear();
    }
  }
  clear_view();
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ViewProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string identifier = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_identifier();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .autofill_assistant.ViewAttributesProto attributes = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_attributes(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .autofill_assistant.ViewLayoutParamsProto layout_params = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_layout_params(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.ViewContainerProto view_container = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_view_container(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.TextViewProto text_view = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_text_view(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.DividerViewProto divider_view = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_divider_view(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.ImageViewProto image_view = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_image_view(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.TextInputViewProto text_input_view = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_text_input_view(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.VerticalExpanderViewProto vertical_expander_view = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_vertical_expander_view(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.ToggleButtonViewProto toggle_button_view = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_toggle_button_view(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ViewProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.ViewProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string identifier = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_identifier(), target);
  }

  // optional .autofill_assistant.ViewAttributesProto attributes = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::attributes(this),
        _Internal::attributes(this).GetCachedSize(), target, stream);
  }

  // optional .autofill_assistant.ViewLayoutParamsProto layout_params = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::layout_params(this),
        _Internal::layout_params(this).GetCachedSize(), target, stream);
  }

  switch (view_case()) {
    case kViewContainer: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, _Internal::view_container(this),
          _Internal::view_container(this).GetCachedSize(), target, stream);
      break;
    }
    case kTextView: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(5, _Internal::text_view(this),
          _Internal::text_view(this).GetCachedSize(), target, stream);
      break;
    }
    case kDividerView: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(6, _Internal::divider_view(this),
          _Internal::divider_view(this).GetCachedSize(), target, stream);
      break;
    }
    case kImageView: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(7, _Internal::image_view(this),
          _Internal::image_view(this).GetCachedSize(), target, stream);
      break;
    }
    case kTextInputView: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(8, _Internal::text_input_view(this),
          _Internal::text_input_view(this).GetCachedSize(), target, stream);
      break;
    }
    case kVerticalExpanderView: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(9, _Internal::vertical_expander_view(this),
          _Internal::vertical_expander_view(this).GetCachedSize(), target, stream);
      break;
    }
    case kToggleButtonView: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(10, _Internal::toggle_button_view(this),
          _Internal::toggle_button_view(this).GetCachedSize(), target, stream);
      break;
    }
    default: ;
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.ViewProto)
  return target;
}

size_t ViewProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.ViewProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string identifier = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_identifier());
    }

    // optional .autofill_assistant.ViewAttributesProto attributes = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *attributes_);
    }

    // optional .autofill_assistant.ViewLayoutParamsProto layout_params = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *layout_params_);
    }

  }
  switch (view_case()) {
    // .autofill_assistant.ViewContainerProto view_container = 4;
    case kViewContainer: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *view_.view_container_);
      break;
    }
    // .autofill_assistant.TextViewProto text_view = 5;
    case kTextView: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *view_.text_view_);
      break;
    }
    // .autofill_assistant.DividerViewProto divider_view = 6;
    case kDividerView: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *view_.divider_view_);
      break;
    }
    // .autofill_assistant.ImageViewProto image_view = 7;
    case kImageView: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *view_.image_view_);
      break;
    }
    // .autofill_assistant.TextInputViewProto text_input_view = 8;
    case kTextInputView: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *view_.text_input_view_);
      break;
    }
    // .autofill_assistant.VerticalExpanderViewProto vertical_expander_view = 9;
    case kVerticalExpanderView: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *view_.vertical_expander_view_);
      break;
    }
    // .autofill_assistant.ToggleButtonViewProto toggle_button_view = 10;
    case kToggleButtonView: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *view_.toggle_button_view_);
      break;
    }
    case VIEW_NOT_SET: {
      break;
    }
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ViewProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ViewProto*>(
      &from));
}

void ViewProto::MergeFrom(const ViewProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.ViewProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_identifier(from._internal_identifier());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_attributes()->::autofill_assistant::ViewAttributesProto::MergeFrom(from._internal_attributes());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_layout_params()->::autofill_assistant::ViewLayoutParamsProto::MergeFrom(from._internal_layout_params());
    }
  }
  switch (from.view_case()) {
    case kViewContainer: {
      _internal_mutable_view_container()->::autofill_assistant::ViewContainerProto::MergeFrom(from._internal_view_container());
      break;
    }
    case kTextView: {
      _internal_mutable_text_view()->::autofill_assistant::TextViewProto::MergeFrom(from._internal_text_view());
      break;
    }
    case kDividerView: {
      _internal_mutable_divider_view()->::autofill_assistant::DividerViewProto::MergeFrom(from._internal_divider_view());
      break;
    }
    case kImageView: {
      _internal_mutable_image_view()->::autofill_assistant::ImageViewProto::MergeFrom(from._internal_image_view());
      break;
    }
    case kTextInputView: {
      _internal_mutable_text_input_view()->::autofill_assistant::TextInputViewProto::MergeFrom(from._internal_text_input_view());
      break;
    }
    case kVerticalExpanderView: {
      _internal_mutable_vertical_expander_view()->::autofill_assistant::VerticalExpanderViewProto::MergeFrom(from._internal_vertical_expander_view());
      break;
    }
    case kToggleButtonView: {
      _internal_mutable_toggle_button_view()->::autofill_assistant::ToggleButtonViewProto::MergeFrom(from._internal_toggle_button_view());
      break;
    }
    case VIEW_NOT_SET: {
      break;
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ViewProto::CopyFrom(const ViewProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.ViewProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ViewProto::IsInitialized() const {
  return true;
}

void ViewProto::InternalSwap(ViewProto* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &identifier_, lhs_arena,
      &other->identifier_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ViewProto, layout_params_)
      + sizeof(ViewProto::layout_params_)
      - PROTOBUF_FIELD_OFFSET(ViewProto, attributes_)>(
          reinterpret_cast<char*>(&attributes_),
          reinterpret_cast<char*>(&other->attributes_));
  swap(view_, other->view_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

std::string ViewProto::GetTypeName() const {
  return "autofill_assistant.ViewProto";
}


// ===================================================================

class ColorProto::_Internal {
 public:
};

ColorProto::ColorProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.ColorProto)
}
ColorProto::ColorProto(const ColorProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  clear_has_color();
  switch (from.color_case()) {
    case kResourceIdentifier: {
      _internal_set_resource_identifier(from._internal_resource_identifier());
      break;
    }
    case kParseableColor: {
      _internal_set_parseable_color(from._internal_parseable_color());
      break;
    }
    case COLOR_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.ColorProto)
}

inline void ColorProto::SharedCtor() {
clear_has_color();
}

ColorProto::~ColorProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.ColorProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ColorProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_color()) {
    clear_color();
  }
}

void ColorProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ColorProto::clear_color() {
// @@protoc_insertion_point(one_of_clear_start:autofill_assistant.ColorProto)
  switch (color_case()) {
    case kResourceIdentifier: {
      color_.resource_identifier_.Destroy();
      break;
    }
    case kParseableColor: {
      color_.parseable_color_.Destroy();
      break;
    }
    case COLOR_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = COLOR_NOT_SET;
}


void ColorProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.ColorProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_color();
  _internal_metadata_.Clear<std::string>();
}

const char* ColorProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string resource_identifier = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_resource_identifier();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string parseable_color = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_parseable_color();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ColorProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.ColorProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (color_case()) {
    case kResourceIdentifier: {
      target = stream->WriteStringMaybeAliased(
          1, this->_internal_resource_identifier(), target);
      break;
    }
    case kParseableColor: {
      target = stream->WriteStringMaybeAliased(
          2, this->_internal_parseable_color(), target);
      break;
    }
    default: ;
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.ColorProto)
  return target;
}

size_t ColorProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.ColorProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (color_case()) {
    // string resource_identifier = 1;
    case kResourceIdentifier: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_resource_identifier());
      break;
    }
    // string parseable_color = 2;
    case kParseableColor: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_parseable_color());
      break;
    }
    case COLOR_NOT_SET: {
      break;
    }
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ColorProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ColorProto*>(
      &from));
}

void ColorProto::MergeFrom(const ColorProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.ColorProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.color_case()) {
    case kResourceIdentifier: {
      _internal_set_resource_identifier(from._internal_resource_identifier());
      break;
    }
    case kParseableColor: {
      _internal_set_parseable_color(from._internal_parseable_color());
      break;
    }
    case COLOR_NOT_SET: {
      break;
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ColorProto::CopyFrom(const ColorProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.ColorProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ColorProto::IsInitialized() const {
  return true;
}

void ColorProto::InternalSwap(ColorProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(color_, other->color_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

std::string ColorProto::GetTypeName() const {
  return "autofill_assistant.ColorProto";
}


// ===================================================================

class ClientDimensionProto::_Internal {
 public:
};

ClientDimensionProto::ClientDimensionProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.ClientDimensionProto)
}
ClientDimensionProto::ClientDimensionProto(const ClientDimensionProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  clear_has_size();
  switch (from.size_case()) {
    case kDp: {
      _internal_set_dp(from._internal_dp());
      break;
    }
    case kWidthFactor: {
      _internal_set_width_factor(from._internal_width_factor());
      break;
    }
    case kHeightFactor: {
      _internal_set_height_factor(from._internal_height_factor());
      break;
    }
    case kSizeInPixel: {
      _internal_set_size_in_pixel(from._internal_size_in_pixel());
      break;
    }
    case SIZE_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.ClientDimensionProto)
}

inline void ClientDimensionProto::SharedCtor() {
clear_has_size();
}

ClientDimensionProto::~ClientDimensionProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.ClientDimensionProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ClientDimensionProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_size()) {
    clear_size();
  }
}

void ClientDimensionProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ClientDimensionProto::clear_size() {
// @@protoc_insertion_point(one_of_clear_start:autofill_assistant.ClientDimensionProto)
  switch (size_case()) {
    case kDp: {
      // No need to clear
      break;
    }
    case kWidthFactor: {
      // No need to clear
      break;
    }
    case kHeightFactor: {
      // No need to clear
      break;
    }
    case kSizeInPixel: {
      // No need to clear
      break;
    }
    case SIZE_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = SIZE_NOT_SET;
}


void ClientDimensionProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.ClientDimensionProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_size();
  _internal_metadata_.Clear<std::string>();
}

const char* ClientDimensionProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 dp = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _internal_set_dp(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // float width_factor = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _internal_set_width_factor(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float height_factor = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _internal_set_height_factor(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // int32 size_in_pixel = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _internal_set_size_in_pixel(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ClientDimensionProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.ClientDimensionProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (size_case()) {
    case kDp: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_dp(), target);
      break;
    }
    case kWidthFactor: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_width_factor(), target);
      break;
    }
    case kHeightFactor: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteFloatToArray(3, this->_internal_height_factor(), target);
      break;
    }
    case kSizeInPixel: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_size_in_pixel(), target);
      break;
    }
    default: ;
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.ClientDimensionProto)
  return target;
}

size_t ClientDimensionProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.ClientDimensionProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (size_case()) {
    // int32 dp = 1;
    case kDp: {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_dp());
      break;
    }
    // float width_factor = 2;
    case kWidthFactor: {
      total_size += 1 + 4;
      break;
    }
    // float height_factor = 3;
    case kHeightFactor: {
      total_size += 1 + 4;
      break;
    }
    // int32 size_in_pixel = 4;
    case kSizeInPixel: {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_size_in_pixel());
      break;
    }
    case SIZE_NOT_SET: {
      break;
    }
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ClientDimensionProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ClientDimensionProto*>(
      &from));
}

void ClientDimensionProto::MergeFrom(const ClientDimensionProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.ClientDimensionProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.size_case()) {
    case kDp: {
      _internal_set_dp(from._internal_dp());
      break;
    }
    case kWidthFactor: {
      _internal_set_width_factor(from._internal_width_factor());
      break;
    }
    case kHeightFactor: {
      _internal_set_height_factor(from._internal_height_factor());
      break;
    }
    case kSizeInPixel: {
      _internal_set_size_in_pixel(from._internal_size_in_pixel());
      break;
    }
    case SIZE_NOT_SET: {
      break;
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClientDimensionProto::CopyFrom(const ClientDimensionProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.ClientDimensionProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClientDimensionProto::IsInitialized() const {
  return true;
}

void ClientDimensionProto::InternalSwap(ClientDimensionProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(size_, other->size_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

std::string ClientDimensionProto::GetTypeName() const {
  return "autofill_assistant.ClientDimensionProto";
}


// ===================================================================

class ShapeDrawableProto_Rectangle::_Internal {
 public:
  using HasBits = decltype(std::declval<ShapeDrawableProto_Rectangle>()._has_bits_);
  static const ::autofill_assistant::ClientDimensionProto& corner_radius(const ShapeDrawableProto_Rectangle* msg);
  static void set_has_corner_radius(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::autofill_assistant::ClientDimensionProto&
ShapeDrawableProto_Rectangle::_Internal::corner_radius(const ShapeDrawableProto_Rectangle* msg) {
  return *msg->corner_radius_;
}
ShapeDrawableProto_Rectangle::ShapeDrawableProto_Rectangle(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.ShapeDrawableProto.Rectangle)
}
ShapeDrawableProto_Rectangle::ShapeDrawableProto_Rectangle(const ShapeDrawableProto_Rectangle& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_corner_radius()) {
    corner_radius_ = new ::autofill_assistant::ClientDimensionProto(*from.corner_radius_);
  } else {
    corner_radius_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.ShapeDrawableProto.Rectangle)
}

inline void ShapeDrawableProto_Rectangle::SharedCtor() {
corner_radius_ = nullptr;
}

ShapeDrawableProto_Rectangle::~ShapeDrawableProto_Rectangle() {
  // @@protoc_insertion_point(destructor:autofill_assistant.ShapeDrawableProto.Rectangle)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ShapeDrawableProto_Rectangle::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete corner_radius_;
}

void ShapeDrawableProto_Rectangle::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ShapeDrawableProto_Rectangle::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.ShapeDrawableProto.Rectangle)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(corner_radius_ != nullptr);
    corner_radius_->Clear();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ShapeDrawableProto_Rectangle::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .autofill_assistant.ClientDimensionProto corner_radius = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_corner_radius(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ShapeDrawableProto_Rectangle::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.ShapeDrawableProto.Rectangle)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .autofill_assistant.ClientDimensionProto corner_radius = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::corner_radius(this),
        _Internal::corner_radius(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.ShapeDrawableProto.Rectangle)
  return target;
}

size_t ShapeDrawableProto_Rectangle::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.ShapeDrawableProto.Rectangle)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .autofill_assistant.ClientDimensionProto corner_radius = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *corner_radius_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ShapeDrawableProto_Rectangle::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ShapeDrawableProto_Rectangle*>(
      &from));
}

void ShapeDrawableProto_Rectangle::MergeFrom(const ShapeDrawableProto_Rectangle& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.ShapeDrawableProto.Rectangle)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_corner_radius()) {
    _internal_mutable_corner_radius()->::autofill_assistant::ClientDimensionProto::MergeFrom(from._internal_corner_radius());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ShapeDrawableProto_Rectangle::CopyFrom(const ShapeDrawableProto_Rectangle& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.ShapeDrawableProto.Rectangle)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ShapeDrawableProto_Rectangle::IsInitialized() const {
  return true;
}

void ShapeDrawableProto_Rectangle::InternalSwap(ShapeDrawableProto_Rectangle* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(corner_radius_, other->corner_radius_);
}

std::string ShapeDrawableProto_Rectangle::GetTypeName() const {
  return "autofill_assistant.ShapeDrawableProto.Rectangle";
}


// ===================================================================

class ShapeDrawableProto::_Internal {
 public:
  using HasBits = decltype(std::declval<ShapeDrawableProto>()._has_bits_);
  static const ::autofill_assistant::ShapeDrawableProto_Rectangle& rectangle(const ShapeDrawableProto* msg);
  static const ::autofill_assistant::ColorProto& background_color(const ShapeDrawableProto* msg);
  static void set_has_background_color(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::autofill_assistant::ClientDimensionProto& stroke_width(const ShapeDrawableProto* msg);
  static void set_has_stroke_width(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::autofill_assistant::ColorProto& stroke_color(const ShapeDrawableProto* msg);
  static void set_has_stroke_color(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::autofill_assistant::ShapeDrawableProto_Rectangle&
ShapeDrawableProto::_Internal::rectangle(const ShapeDrawableProto* msg) {
  return *msg->shape_.rectangle_;
}
const ::autofill_assistant::ColorProto&
ShapeDrawableProto::_Internal::background_color(const ShapeDrawableProto* msg) {
  return *msg->background_color_;
}
const ::autofill_assistant::ClientDimensionProto&
ShapeDrawableProto::_Internal::stroke_width(const ShapeDrawableProto* msg) {
  return *msg->stroke_width_;
}
const ::autofill_assistant::ColorProto&
ShapeDrawableProto::_Internal::stroke_color(const ShapeDrawableProto* msg) {
  return *msg->stroke_color_;
}
void ShapeDrawableProto::set_allocated_rectangle(::autofill_assistant::ShapeDrawableProto_Rectangle* rectangle) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_shape();
  if (rectangle) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(rectangle);
    if (message_arena != submessage_arena) {
      rectangle = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rectangle, submessage_arena);
    }
    set_has_rectangle();
    shape_.rectangle_ = rectangle;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ShapeDrawableProto.rectangle)
}
ShapeDrawableProto::ShapeDrawableProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.ShapeDrawableProto)
}
ShapeDrawableProto::ShapeDrawableProto(const ShapeDrawableProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_background_color()) {
    background_color_ = new ::autofill_assistant::ColorProto(*from.background_color_);
  } else {
    background_color_ = nullptr;
  }
  if (from._internal_has_stroke_width()) {
    stroke_width_ = new ::autofill_assistant::ClientDimensionProto(*from.stroke_width_);
  } else {
    stroke_width_ = nullptr;
  }
  if (from._internal_has_stroke_color()) {
    stroke_color_ = new ::autofill_assistant::ColorProto(*from.stroke_color_);
  } else {
    stroke_color_ = nullptr;
  }
  clear_has_shape();
  switch (from.shape_case()) {
    case kRectangle: {
      _internal_mutable_rectangle()->::autofill_assistant::ShapeDrawableProto_Rectangle::MergeFrom(from._internal_rectangle());
      break;
    }
    case SHAPE_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.ShapeDrawableProto)
}

inline void ShapeDrawableProto::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&background_color_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&stroke_color_) -
    reinterpret_cast<char*>(&background_color_)) + sizeof(stroke_color_));
clear_has_shape();
}

ShapeDrawableProto::~ShapeDrawableProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.ShapeDrawableProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ShapeDrawableProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete background_color_;
  if (this != internal_default_instance()) delete stroke_width_;
  if (this != internal_default_instance()) delete stroke_color_;
  if (has_shape()) {
    clear_shape();
  }
}

void ShapeDrawableProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ShapeDrawableProto::clear_shape() {
// @@protoc_insertion_point(one_of_clear_start:autofill_assistant.ShapeDrawableProto)
  switch (shape_case()) {
    case kRectangle: {
      if (GetArenaForAllocation() == nullptr) {
        delete shape_.rectangle_;
      }
      break;
    }
    case SHAPE_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = SHAPE_NOT_SET;
}


void ShapeDrawableProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.ShapeDrawableProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(background_color_ != nullptr);
      background_color_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(stroke_width_ != nullptr);
      stroke_width_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(stroke_color_ != nullptr);
      stroke_color_->Clear();
    }
  }
  clear_shape();
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ShapeDrawableProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .autofill_assistant.ShapeDrawableProto.Rectangle rectangle = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_rectangle(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .autofill_assistant.ColorProto background_color = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_background_color(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .autofill_assistant.ClientDimensionProto stroke_width = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_stroke_width(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .autofill_assistant.ColorProto stroke_color = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_stroke_color(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ShapeDrawableProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.ShapeDrawableProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .autofill_assistant.ShapeDrawableProto.Rectangle rectangle = 1;
  if (_internal_has_rectangle()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::rectangle(this),
        _Internal::rectangle(this).GetCachedSize(), target, stream);
  }

  cached_has_bits = _has_bits_[0];
  // optional .autofill_assistant.ColorProto background_color = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::background_color(this),
        _Internal::background_color(this).GetCachedSize(), target, stream);
  }

  // optional .autofill_assistant.ClientDimensionProto stroke_width = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::stroke_width(this),
        _Internal::stroke_width(this).GetCachedSize(), target, stream);
  }

  // optional .autofill_assistant.ColorProto stroke_color = 4;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::stroke_color(this),
        _Internal::stroke_color(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.ShapeDrawableProto)
  return target;
}

size_t ShapeDrawableProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.ShapeDrawableProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .autofill_assistant.ColorProto background_color = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *background_color_);
    }

    // optional .autofill_assistant.ClientDimensionProto stroke_width = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *stroke_width_);
    }

    // optional .autofill_assistant.ColorProto stroke_color = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *stroke_color_);
    }

  }
  switch (shape_case()) {
    // .autofill_assistant.ShapeDrawableProto.Rectangle rectangle = 1;
    case kRectangle: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *shape_.rectangle_);
      break;
    }
    case SHAPE_NOT_SET: {
      break;
    }
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ShapeDrawableProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ShapeDrawableProto*>(
      &from));
}

void ShapeDrawableProto::MergeFrom(const ShapeDrawableProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.ShapeDrawableProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_background_color()->::autofill_assistant::ColorProto::MergeFrom(from._internal_background_color());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_stroke_width()->::autofill_assistant::ClientDimensionProto::MergeFrom(from._internal_stroke_width());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_stroke_color()->::autofill_assistant::ColorProto::MergeFrom(from._internal_stroke_color());
    }
  }
  switch (from.shape_case()) {
    case kRectangle: {
      _internal_mutable_rectangle()->::autofill_assistant::ShapeDrawableProto_Rectangle::MergeFrom(from._internal_rectangle());
      break;
    }
    case SHAPE_NOT_SET: {
      break;
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ShapeDrawableProto::CopyFrom(const ShapeDrawableProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.ShapeDrawableProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ShapeDrawableProto::IsInitialized() const {
  return true;
}

void ShapeDrawableProto::InternalSwap(ShapeDrawableProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ShapeDrawableProto, stroke_color_)
      + sizeof(ShapeDrawableProto::stroke_color_)
      - PROTOBUF_FIELD_OFFSET(ShapeDrawableProto, background_color_)>(
          reinterpret_cast<char*>(&background_color_),
          reinterpret_cast<char*>(&other->background_color_));
  swap(shape_, other->shape_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

std::string ShapeDrawableProto::GetTypeName() const {
  return "autofill_assistant.ShapeDrawableProto";
}


// ===================================================================

ConfigBasedUrlProto_UrlEntry_DoNotUse::ConfigBasedUrlProto_UrlEntry_DoNotUse() {}
ConfigBasedUrlProto_UrlEntry_DoNotUse::ConfigBasedUrlProto_UrlEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void ConfigBasedUrlProto_UrlEntry_DoNotUse::MergeFrom(const ConfigBasedUrlProto_UrlEntry_DoNotUse& other) {
  MergeFromInternal(other);
}

// ===================================================================

class ConfigBasedUrlProto::_Internal {
 public:
};

ConfigBasedUrlProto::ConfigBasedUrlProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  url_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.ConfigBasedUrlProto)
}
ConfigBasedUrlProto::ConfigBasedUrlProto(const ConfigBasedUrlProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  url_.MergeFrom(from.url_);
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.ConfigBasedUrlProto)
}

inline void ConfigBasedUrlProto::SharedCtor() {
}

ConfigBasedUrlProto::~ConfigBasedUrlProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.ConfigBasedUrlProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ConfigBasedUrlProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  url_.Destruct();
}

void ConfigBasedUrlProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ConfigBasedUrlProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.ConfigBasedUrlProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  url_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ConfigBasedUrlProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // map<string, string> url = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&url_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ConfigBasedUrlProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.ConfigBasedUrlProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // map<string, string> url = 1;
  if (!this->_internal_url().empty()) {
    using MapType = ::_pb::Map<std::string, std::string>;
    using WireHelper = ConfigBasedUrlProto_UrlEntry_DoNotUse::Funcs;
    const auto& map_field = this->_internal_url();
    auto check_utf8 = [](const MapType::value_type& entry) {
      (void)entry;
    };

    if (stream->IsSerializationDeterministic() && map_field.size() > 1) {
      for (const auto& entry : ::_pbi::MapSorterPtr<MapType>(map_field)) {
        target = WireHelper::InternalSerialize(1, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    } else {
      for (const auto& entry : map_field) {
        target = WireHelper::InternalSerialize(1, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.ConfigBasedUrlProto)
  return target;
}

size_t ConfigBasedUrlProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.ConfigBasedUrlProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // map<string, string> url = 1;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_url_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >::const_iterator
      it = this->_internal_url().begin();
      it != this->_internal_url().end(); ++it) {
    total_size += ConfigBasedUrlProto_UrlEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ConfigBasedUrlProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ConfigBasedUrlProto*>(
      &from));
}

void ConfigBasedUrlProto::MergeFrom(const ConfigBasedUrlProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.ConfigBasedUrlProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  url_.MergeFrom(from.url_);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ConfigBasedUrlProto::CopyFrom(const ConfigBasedUrlProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.ConfigBasedUrlProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ConfigBasedUrlProto::IsInitialized() const {
  return true;
}

void ConfigBasedUrlProto::InternalSwap(ConfigBasedUrlProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  url_.InternalSwap(&other->url_);
}

std::string ConfigBasedUrlProto::GetTypeName() const {
  return "autofill_assistant.ConfigBasedUrlProto";
}


// ===================================================================

class BitmapDrawableProto::_Internal {
 public:
  using HasBits = decltype(std::declval<BitmapDrawableProto>()._has_bits_);
  static const ::autofill_assistant::ConfigBasedUrlProto& config_based_url(const BitmapDrawableProto* msg);
  static const ::autofill_assistant::ClientDimensionProto& width(const BitmapDrawableProto* msg);
  static void set_has_width(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::autofill_assistant::ClientDimensionProto& height(const BitmapDrawableProto* msg);
  static void set_has_height(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_use_instrinsic_dimensions(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::autofill_assistant::ConfigBasedUrlProto&
BitmapDrawableProto::_Internal::config_based_url(const BitmapDrawableProto* msg) {
  return *msg->image_url_.config_based_url_;
}
const ::autofill_assistant::ClientDimensionProto&
BitmapDrawableProto::_Internal::width(const BitmapDrawableProto* msg) {
  return *msg->width_;
}
const ::autofill_assistant::ClientDimensionProto&
BitmapDrawableProto::_Internal::height(const BitmapDrawableProto* msg) {
  return *msg->height_;
}
void BitmapDrawableProto::set_allocated_config_based_url(::autofill_assistant::ConfigBasedUrlProto* config_based_url) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_image_url();
  if (config_based_url) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(config_based_url);
    if (message_arena != submessage_arena) {
      config_based_url = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, config_based_url, submessage_arena);
    }
    set_has_config_based_url();
    image_url_.config_based_url_ = config_based_url;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.BitmapDrawableProto.config_based_url)
}
BitmapDrawableProto::BitmapDrawableProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.BitmapDrawableProto)
}
BitmapDrawableProto::BitmapDrawableProto(const BitmapDrawableProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_width()) {
    width_ = new ::autofill_assistant::ClientDimensionProto(*from.width_);
  } else {
    width_ = nullptr;
  }
  if (from._internal_has_height()) {
    height_ = new ::autofill_assistant::ClientDimensionProto(*from.height_);
  } else {
    height_ = nullptr;
  }
  use_instrinsic_dimensions_ = from.use_instrinsic_dimensions_;
  clear_has_image_url();
  switch (from.image_url_case()) {
    case kUrl: {
      _internal_set_url(from._internal_url());
      break;
    }
    case kConfigBasedUrl: {
      _internal_mutable_config_based_url()->::autofill_assistant::ConfigBasedUrlProto::MergeFrom(from._internal_config_based_url());
      break;
    }
    case IMAGE_URL_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.BitmapDrawableProto)
}

inline void BitmapDrawableProto::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&width_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&use_instrinsic_dimensions_) -
    reinterpret_cast<char*>(&width_)) + sizeof(use_instrinsic_dimensions_));
clear_has_image_url();
}

BitmapDrawableProto::~BitmapDrawableProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.BitmapDrawableProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void BitmapDrawableProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete width_;
  if (this != internal_default_instance()) delete height_;
  if (has_image_url()) {
    clear_image_url();
  }
}

void BitmapDrawableProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void BitmapDrawableProto::clear_image_url() {
// @@protoc_insertion_point(one_of_clear_start:autofill_assistant.BitmapDrawableProto)
  switch (image_url_case()) {
    case kUrl: {
      image_url_.url_.Destroy();
      break;
    }
    case kConfigBasedUrl: {
      if (GetArenaForAllocation() == nullptr) {
        delete image_url_.config_based_url_;
      }
      break;
    }
    case IMAGE_URL_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = IMAGE_URL_NOT_SET;
}


void BitmapDrawableProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.BitmapDrawableProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(width_ != nullptr);
      width_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(height_ != nullptr);
      height_->Clear();
    }
  }
  use_instrinsic_dimensions_ = false;
  clear_image_url();
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* BitmapDrawableProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string url = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_url();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .autofill_assistant.ClientDimensionProto width = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_width(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .autofill_assistant.ClientDimensionProto height = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_height(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.ConfigBasedUrlProto config_based_url = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_config_based_url(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool use_instrinsic_dimensions = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_use_instrinsic_dimensions(&has_bits);
          use_instrinsic_dimensions_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* BitmapDrawableProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.BitmapDrawableProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string url = 1;
  if (_internal_has_url()) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_url(), target);
  }

  cached_has_bits = _has_bits_[0];
  // optional .autofill_assistant.ClientDimensionProto width = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::width(this),
        _Internal::width(this).GetCachedSize(), target, stream);
  }

  // optional .autofill_assistant.ClientDimensionProto height = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::height(this),
        _Internal::height(this).GetCachedSize(), target, stream);
  }

  // .autofill_assistant.ConfigBasedUrlProto config_based_url = 4;
  if (_internal_has_config_based_url()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::config_based_url(this),
        _Internal::config_based_url(this).GetCachedSize(), target, stream);
  }

  // optional bool use_instrinsic_dimensions = 5;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_use_instrinsic_dimensions(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.BitmapDrawableProto)
  return target;
}

size_t BitmapDrawableProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.BitmapDrawableProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .autofill_assistant.ClientDimensionProto width = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *width_);
    }

    // optional .autofill_assistant.ClientDimensionProto height = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *height_);
    }

    // optional bool use_instrinsic_dimensions = 5;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

  }
  switch (image_url_case()) {
    // string url = 1;
    case kUrl: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_url());
      break;
    }
    // .autofill_assistant.ConfigBasedUrlProto config_based_url = 4;
    case kConfigBasedUrl: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *image_url_.config_based_url_);
      break;
    }
    case IMAGE_URL_NOT_SET: {
      break;
    }
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void BitmapDrawableProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const BitmapDrawableProto*>(
      &from));
}

void BitmapDrawableProto::MergeFrom(const BitmapDrawableProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.BitmapDrawableProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_width()->::autofill_assistant::ClientDimensionProto::MergeFrom(from._internal_width());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_height()->::autofill_assistant::ClientDimensionProto::MergeFrom(from._internal_height());
    }
    if (cached_has_bits & 0x00000004u) {
      use_instrinsic_dimensions_ = from.use_instrinsic_dimensions_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  switch (from.image_url_case()) {
    case kUrl: {
      _internal_set_url(from._internal_url());
      break;
    }
    case kConfigBasedUrl: {
      _internal_mutable_config_based_url()->::autofill_assistant::ConfigBasedUrlProto::MergeFrom(from._internal_config_based_url());
      break;
    }
    case IMAGE_URL_NOT_SET: {
      break;
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void BitmapDrawableProto::CopyFrom(const BitmapDrawableProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.BitmapDrawableProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BitmapDrawableProto::IsInitialized() const {
  return true;
}

void BitmapDrawableProto::InternalSwap(BitmapDrawableProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(BitmapDrawableProto, use_instrinsic_dimensions_)
      + sizeof(BitmapDrawableProto::use_instrinsic_dimensions_)
      - PROTOBUF_FIELD_OFFSET(BitmapDrawableProto, width_)>(
          reinterpret_cast<char*>(&width_),
          reinterpret_cast<char*>(&other->width_));
  swap(image_url_, other->image_url_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

std::string BitmapDrawableProto::GetTypeName() const {
  return "autofill_assistant.BitmapDrawableProto";
}


// ===================================================================

class FaviconDrawableProto::_Internal {
 public:
  using HasBits = decltype(std::declval<FaviconDrawableProto>()._has_bits_);
  static const ::autofill_assistant::ClientDimensionProto& diameter_size(const FaviconDrawableProto* msg);
  static void set_has_diameter_size(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_force_monogram(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_website_url(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::autofill_assistant::ClientDimensionProto&
FaviconDrawableProto::_Internal::diameter_size(const FaviconDrawableProto* msg) {
  return *msg->diameter_size_;
}
FaviconDrawableProto::FaviconDrawableProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.FaviconDrawableProto)
}
FaviconDrawableProto::FaviconDrawableProto(const FaviconDrawableProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  website_url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    website_url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_website_url()) {
    website_url_.Set(from._internal_website_url(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_diameter_size()) {
    diameter_size_ = new ::autofill_assistant::ClientDimensionProto(*from.diameter_size_);
  } else {
    diameter_size_ = nullptr;
  }
  force_monogram_ = from.force_monogram_;
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.FaviconDrawableProto)
}

inline void FaviconDrawableProto::SharedCtor() {
website_url_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  website_url_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&diameter_size_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&force_monogram_) -
    reinterpret_cast<char*>(&diameter_size_)) + sizeof(force_monogram_));
}

FaviconDrawableProto::~FaviconDrawableProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.FaviconDrawableProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void FaviconDrawableProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  website_url_.Destroy();
  if (this != internal_default_instance()) delete diameter_size_;
}

void FaviconDrawableProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void FaviconDrawableProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.FaviconDrawableProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      website_url_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(diameter_size_ != nullptr);
      diameter_size_->Clear();
    }
  }
  force_monogram_ = false;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* FaviconDrawableProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .autofill_assistant.ClientDimensionProto diameter_size = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_diameter_size(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool force_monogram = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_force_monogram(&has_bits);
          force_monogram_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string website_url = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_website_url();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FaviconDrawableProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.FaviconDrawableProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .autofill_assistant.ClientDimensionProto diameter_size = 1;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::diameter_size(this),
        _Internal::diameter_size(this).GetCachedSize(), target, stream);
  }

  // optional bool force_monogram = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_force_monogram(), target);
  }

  // optional string website_url = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_website_url(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.FaviconDrawableProto)
  return target;
}

size_t FaviconDrawableProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.FaviconDrawableProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string website_url = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_website_url());
    }

    // optional .autofill_assistant.ClientDimensionProto diameter_size = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *diameter_size_);
    }

    // optional bool force_monogram = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void FaviconDrawableProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const FaviconDrawableProto*>(
      &from));
}

void FaviconDrawableProto::MergeFrom(const FaviconDrawableProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.FaviconDrawableProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_website_url(from._internal_website_url());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_diameter_size()->::autofill_assistant::ClientDimensionProto::MergeFrom(from._internal_diameter_size());
    }
    if (cached_has_bits & 0x00000004u) {
      force_monogram_ = from.force_monogram_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void FaviconDrawableProto::CopyFrom(const FaviconDrawableProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.FaviconDrawableProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FaviconDrawableProto::IsInitialized() const {
  return true;
}

void FaviconDrawableProto::InternalSwap(FaviconDrawableProto* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &website_url_, lhs_arena,
      &other->website_url_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(FaviconDrawableProto, force_monogram_)
      + sizeof(FaviconDrawableProto::force_monogram_)
      - PROTOBUF_FIELD_OFFSET(FaviconDrawableProto, diameter_size_)>(
          reinterpret_cast<char*>(&diameter_size_),
          reinterpret_cast<char*>(&other->diameter_size_));
}

std::string FaviconDrawableProto::GetTypeName() const {
  return "autofill_assistant.FaviconDrawableProto";
}


// ===================================================================

class DrawableProto::_Internal {
 public:
  static const ::autofill_assistant::BitmapDrawableProto& bitmap(const DrawableProto* msg);
  static const ::autofill_assistant::ShapeDrawableProto& shape(const DrawableProto* msg);
  static const ::autofill_assistant::FaviconDrawableProto& favicon(const DrawableProto* msg);
};

const ::autofill_assistant::BitmapDrawableProto&
DrawableProto::_Internal::bitmap(const DrawableProto* msg) {
  return *msg->drawable_.bitmap_;
}
const ::autofill_assistant::ShapeDrawableProto&
DrawableProto::_Internal::shape(const DrawableProto* msg) {
  return *msg->drawable_.shape_;
}
const ::autofill_assistant::FaviconDrawableProto&
DrawableProto::_Internal::favicon(const DrawableProto* msg) {
  return *msg->drawable_.favicon_;
}
void DrawableProto::set_allocated_bitmap(::autofill_assistant::BitmapDrawableProto* bitmap) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_drawable();
  if (bitmap) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(bitmap);
    if (message_arena != submessage_arena) {
      bitmap = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, bitmap, submessage_arena);
    }
    set_has_bitmap();
    drawable_.bitmap_ = bitmap;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.DrawableProto.bitmap)
}
void DrawableProto::set_allocated_shape(::autofill_assistant::ShapeDrawableProto* shape) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_drawable();
  if (shape) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(shape);
    if (message_arena != submessage_arena) {
      shape = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, shape, submessage_arena);
    }
    set_has_shape();
    drawable_.shape_ = shape;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.DrawableProto.shape)
}
void DrawableProto::set_allocated_favicon(::autofill_assistant::FaviconDrawableProto* favicon) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_drawable();
  if (favicon) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(favicon);
    if (message_arena != submessage_arena) {
      favicon = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, favicon, submessage_arena);
    }
    set_has_favicon();
    drawable_.favicon_ = favicon;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.DrawableProto.favicon)
}
DrawableProto::DrawableProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.DrawableProto)
}
DrawableProto::DrawableProto(const DrawableProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  clear_has_drawable();
  switch (from.drawable_case()) {
    case kResourceIdentifier: {
      _internal_set_resource_identifier(from._internal_resource_identifier());
      break;
    }
    case kBitmap: {
      _internal_mutable_bitmap()->::autofill_assistant::BitmapDrawableProto::MergeFrom(from._internal_bitmap());
      break;
    }
    case kShape: {
      _internal_mutable_shape()->::autofill_assistant::ShapeDrawableProto::MergeFrom(from._internal_shape());
      break;
    }
    case kIcon: {
      _internal_set_icon(from._internal_icon());
      break;
    }
    case kImageData: {
      _internal_set_image_data(from._internal_image_data());
      break;
    }
    case kImageDataBase64: {
      _internal_set_image_data_base64(from._internal_image_data_base64());
      break;
    }
    case kFavicon: {
      _internal_mutable_favicon()->::autofill_assistant::FaviconDrawableProto::MergeFrom(from._internal_favicon());
      break;
    }
    case DRAWABLE_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.DrawableProto)
}

inline void DrawableProto::SharedCtor() {
clear_has_drawable();
}

DrawableProto::~DrawableProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.DrawableProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DrawableProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_drawable()) {
    clear_drawable();
  }
}

void DrawableProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void DrawableProto::clear_drawable() {
// @@protoc_insertion_point(one_of_clear_start:autofill_assistant.DrawableProto)
  switch (drawable_case()) {
    case kResourceIdentifier: {
      drawable_.resource_identifier_.Destroy();
      break;
    }
    case kBitmap: {
      if (GetArenaForAllocation() == nullptr) {
        delete drawable_.bitmap_;
      }
      break;
    }
    case kShape: {
      if (GetArenaForAllocation() == nullptr) {
        delete drawable_.shape_;
      }
      break;
    }
    case kIcon: {
      // No need to clear
      break;
    }
    case kImageData: {
      drawable_.image_data_.Destroy();
      break;
    }
    case kImageDataBase64: {
      drawable_.image_data_base64_.Destroy();
      break;
    }
    case kFavicon: {
      if (GetArenaForAllocation() == nullptr) {
        delete drawable_.favicon_;
      }
      break;
    }
    case DRAWABLE_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = DRAWABLE_NOT_SET;
}


void DrawableProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.DrawableProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_drawable();
  _internal_metadata_.Clear<std::string>();
}

const char* DrawableProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string resource_identifier = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_resource_identifier();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.BitmapDrawableProto bitmap = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_bitmap(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.ShapeDrawableProto shape = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_shape(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.DrawableProto.Icon icon = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::autofill_assistant::DrawableProto_Icon_IsValid(val))) {
            _internal_set_icon(static_cast<::autofill_assistant::DrawableProto_Icon>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // bytes image_data = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_image_data();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.FaviconDrawableProto favicon = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_favicon(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string image_data_base64 = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_image_data_base64();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DrawableProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.DrawableProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (drawable_case()) {
    case kResourceIdentifier: {
      target = stream->WriteStringMaybeAliased(
          1, this->_internal_resource_identifier(), target);
      break;
    }
    case kBitmap: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, _Internal::bitmap(this),
          _Internal::bitmap(this).GetCachedSize(), target, stream);
      break;
    }
    case kShape: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, _Internal::shape(this),
          _Internal::shape(this).GetCachedSize(), target, stream);
      break;
    }
    case kIcon: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteEnumToArray(
        4, this->_internal_icon(), target);
      break;
    }
    case kImageData: {
      target = stream->WriteBytesMaybeAliased(
          5, this->_internal_image_data(), target);
      break;
    }
    case kFavicon: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(6, _Internal::favicon(this),
          _Internal::favicon(this).GetCachedSize(), target, stream);
      break;
    }
    case kImageDataBase64: {
      target = stream->WriteStringMaybeAliased(
          7, this->_internal_image_data_base64(), target);
      break;
    }
    default: ;
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.DrawableProto)
  return target;
}

size_t DrawableProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.DrawableProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (drawable_case()) {
    // string resource_identifier = 1;
    case kResourceIdentifier: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_resource_identifier());
      break;
    }
    // .autofill_assistant.BitmapDrawableProto bitmap = 2;
    case kBitmap: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *drawable_.bitmap_);
      break;
    }
    // .autofill_assistant.ShapeDrawableProto shape = 3;
    case kShape: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *drawable_.shape_);
      break;
    }
    // .autofill_assistant.DrawableProto.Icon icon = 4;
    case kIcon: {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_icon());
      break;
    }
    // bytes image_data = 5;
    case kImageData: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_image_data());
      break;
    }
    // string image_data_base64 = 7;
    case kImageDataBase64: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_image_data_base64());
      break;
    }
    // .autofill_assistant.FaviconDrawableProto favicon = 6;
    case kFavicon: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *drawable_.favicon_);
      break;
    }
    case DRAWABLE_NOT_SET: {
      break;
    }
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DrawableProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DrawableProto*>(
      &from));
}

void DrawableProto::MergeFrom(const DrawableProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.DrawableProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.drawable_case()) {
    case kResourceIdentifier: {
      _internal_set_resource_identifier(from._internal_resource_identifier());
      break;
    }
    case kBitmap: {
      _internal_mutable_bitmap()->::autofill_assistant::BitmapDrawableProto::MergeFrom(from._internal_bitmap());
      break;
    }
    case kShape: {
      _internal_mutable_shape()->::autofill_assistant::ShapeDrawableProto::MergeFrom(from._internal_shape());
      break;
    }
    case kIcon: {
      _internal_set_icon(from._internal_icon());
      break;
    }
    case kImageData: {
      _internal_set_image_data(from._internal_image_data());
      break;
    }
    case kImageDataBase64: {
      _internal_set_image_data_base64(from._internal_image_data_base64());
      break;
    }
    case kFavicon: {
      _internal_mutable_favicon()->::autofill_assistant::FaviconDrawableProto::MergeFrom(from._internal_favicon());
      break;
    }
    case DRAWABLE_NOT_SET: {
      break;
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DrawableProto::CopyFrom(const DrawableProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.DrawableProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DrawableProto::IsInitialized() const {
  return true;
}

void DrawableProto::InternalSwap(DrawableProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(drawable_, other->drawable_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

std::string DrawableProto::GetTypeName() const {
  return "autofill_assistant.DrawableProto";
}


// ===================================================================

class ViewAttributesProto::_Internal {
 public:
  using HasBits = decltype(std::declval<ViewAttributesProto>()._has_bits_);
  static void set_has_padding_start(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_padding_top(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_padding_end(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_padding_bottom(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static const ::autofill_assistant::DrawableProto& background(const ViewAttributesProto* msg);
  static void set_has_background(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_content_description(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_visible(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
};

const ::autofill_assistant::DrawableProto&
ViewAttributesProto::_Internal::background(const ViewAttributesProto* msg) {
  return *msg->background_;
}
ViewAttributesProto::ViewAttributesProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.ViewAttributesProto)
}
ViewAttributesProto::ViewAttributesProto(const ViewAttributesProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  content_description_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    content_description_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_content_description()) {
    content_description_.Set(from._internal_content_description(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_background()) {
    background_ = new ::autofill_assistant::DrawableProto(*from.background_);
  } else {
    background_ = nullptr;
  }
  ::memcpy(&padding_start_, &from.padding_start_,
    static_cast<size_t>(reinterpret_cast<char*>(&enabled_) -
    reinterpret_cast<char*>(&padding_start_)) + sizeof(enabled_));
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.ViewAttributesProto)
}

inline void ViewAttributesProto::SharedCtor() {
content_description_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  content_description_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&background_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&padding_bottom_) -
    reinterpret_cast<char*>(&background_)) + sizeof(padding_bottom_));
visible_ = true;
enabled_ = true;
}

ViewAttributesProto::~ViewAttributesProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.ViewAttributesProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ViewAttributesProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  content_description_.Destroy();
  if (this != internal_default_instance()) delete background_;
}

void ViewAttributesProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ViewAttributesProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.ViewAttributesProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      content_description_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(background_ != nullptr);
      background_->Clear();
    }
  }
  if (cached_has_bits & 0x000000fcu) {
    ::memset(&padding_start_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&padding_bottom_) -
        reinterpret_cast<char*>(&padding_start_)) + sizeof(padding_bottom_));
    visible_ = true;
    enabled_ = true;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ViewAttributesProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 padding_start = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_padding_start(&has_bits);
          padding_start_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 padding_top = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_padding_top(&has_bits);
          padding_top_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 padding_end = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_padding_end(&has_bits);
          padding_end_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 padding_bottom = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_padding_bottom(&has_bits);
          padding_bottom_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .autofill_assistant.DrawableProto background = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_background(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string content_description = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_content_description();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool visible = 7 [default = true];
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_visible(&has_bits);
          visible_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool enabled = 8 [default = true];
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_enabled(&has_bits);
          enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ViewAttributesProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.ViewAttributesProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 padding_start = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_padding_start(), target);
  }

  // optional int32 padding_top = 2;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_padding_top(), target);
  }

  // optional int32 padding_end = 3;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_padding_end(), target);
  }

  // optional int32 padding_bottom = 4;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_padding_bottom(), target);
  }

  // optional .autofill_assistant.DrawableProto background = 5;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::background(this),
        _Internal::background(this).GetCachedSize(), target, stream);
  }

  // optional string content_description = 6;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_content_description(), target);
  }

  // optional bool visible = 7 [default = true];
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(7, this->_internal_visible(), target);
  }

  // optional bool enabled = 8 [default = true];
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(8, this->_internal_enabled(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.ViewAttributesProto)
  return target;
}

size_t ViewAttributesProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.ViewAttributesProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string content_description = 6;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_content_description());
    }

    // optional .autofill_assistant.DrawableProto background = 5;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *background_);
    }

    // optional int32 padding_start = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_padding_start());
    }

    // optional int32 padding_top = 2;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_padding_top());
    }

    // optional int32 padding_end = 3;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_padding_end());
    }

    // optional int32 padding_bottom = 4;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_padding_bottom());
    }

    // optional bool visible = 7 [default = true];
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 1;
    }

    // optional bool enabled = 8 [default = true];
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 1;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ViewAttributesProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ViewAttributesProto*>(
      &from));
}

void ViewAttributesProto::MergeFrom(const ViewAttributesProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.ViewAttributesProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_content_description(from._internal_content_description());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_background()->::autofill_assistant::DrawableProto::MergeFrom(from._internal_background());
    }
    if (cached_has_bits & 0x00000004u) {
      padding_start_ = from.padding_start_;
    }
    if (cached_has_bits & 0x00000008u) {
      padding_top_ = from.padding_top_;
    }
    if (cached_has_bits & 0x00000010u) {
      padding_end_ = from.padding_end_;
    }
    if (cached_has_bits & 0x00000020u) {
      padding_bottom_ = from.padding_bottom_;
    }
    if (cached_has_bits & 0x00000040u) {
      visible_ = from.visible_;
    }
    if (cached_has_bits & 0x00000080u) {
      enabled_ = from.enabled_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ViewAttributesProto::CopyFrom(const ViewAttributesProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.ViewAttributesProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ViewAttributesProto::IsInitialized() const {
  return true;
}

void ViewAttributesProto::InternalSwap(ViewAttributesProto* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &content_description_, lhs_arena,
      &other->content_description_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ViewAttributesProto, padding_bottom_)
      + sizeof(ViewAttributesProto::padding_bottom_)
      - PROTOBUF_FIELD_OFFSET(ViewAttributesProto, background_)>(
          reinterpret_cast<char*>(&background_),
          reinterpret_cast<char*>(&other->background_));
  swap(visible_, other->visible_);
  swap(enabled_, other->enabled_);
}

std::string ViewAttributesProto::GetTypeName() const {
  return "autofill_assistant.ViewAttributesProto";
}


// ===================================================================

class ViewLayoutParamsProto::_Internal {
 public:
  using HasBits = decltype(std::declval<ViewLayoutParamsProto>()._has_bits_);
  static void set_has_layout_width(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_layout_height(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_layout_weight(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_margin_start(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_margin_top(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_margin_end(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_margin_bottom(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_layout_gravity(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_minimum_width(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_minimum_height(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
};

ViewLayoutParamsProto::ViewLayoutParamsProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.ViewLayoutParamsProto)
}
ViewLayoutParamsProto::ViewLayoutParamsProto(const ViewLayoutParamsProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&margin_start_, &from.margin_start_,
    static_cast<size_t>(reinterpret_cast<char*>(&layout_height_) -
    reinterpret_cast<char*>(&margin_start_)) + sizeof(layout_height_));
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.ViewLayoutParamsProto)
}

inline void ViewLayoutParamsProto::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&margin_start_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&minimum_height_) -
    reinterpret_cast<char*>(&margin_start_)) + sizeof(minimum_height_));
layout_width_ = -2;
layout_height_ = -2;
}

ViewLayoutParamsProto::~ViewLayoutParamsProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.ViewLayoutParamsProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ViewLayoutParamsProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ViewLayoutParamsProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ViewLayoutParamsProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.ViewLayoutParamsProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&margin_start_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&minimum_height_) -
        reinterpret_cast<char*>(&margin_start_)) + sizeof(minimum_height_));
  }
  if (cached_has_bits & 0x00000300u) {
    layout_width_ = -2;
    layout_height_ = -2;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ViewLayoutParamsProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 layout_width = 1 [default = -2];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_layout_width(&has_bits);
          layout_width_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 layout_height = 2 [default = -2];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_layout_height(&has_bits);
          layout_height_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 margin_start = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_margin_start(&has_bits);
          margin_start_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 margin_top = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_margin_top(&has_bits);
          margin_top_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 margin_end = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_margin_end(&has_bits);
          margin_end_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 margin_bottom = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_margin_bottom(&has_bits);
          margin_bottom_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 layout_gravity = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_layout_gravity(&has_bits);
          layout_gravity_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float layout_weight = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 69)) {
          _Internal::set_has_layout_weight(&has_bits);
          layout_weight_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional int32 minimum_width = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_minimum_width(&has_bits);
          minimum_width_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 minimum_height = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_minimum_height(&has_bits);
          minimum_height_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ViewLayoutParamsProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.ViewLayoutParamsProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 layout_width = 1 [default = -2];
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_layout_width(), target);
  }

  // optional int32 layout_height = 2 [default = -2];
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_layout_height(), target);
  }

  // optional int32 margin_start = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_margin_start(), target);
  }

  // optional int32 margin_top = 4;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_margin_top(), target);
  }

  // optional int32 margin_end = 5;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_margin_end(), target);
  }

  // optional int32 margin_bottom = 6;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(6, this->_internal_margin_bottom(), target);
  }

  // optional int32 layout_gravity = 7;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(7, this->_internal_layout_gravity(), target);
  }

  // optional float layout_weight = 8;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(8, this->_internal_layout_weight(), target);
  }

  // optional int32 minimum_width = 9;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(9, this->_internal_minimum_width(), target);
  }

  // optional int32 minimum_height = 10;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(10, this->_internal_minimum_height(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.ViewLayoutParamsProto)
  return target;
}

size_t ViewLayoutParamsProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.ViewLayoutParamsProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional int32 margin_start = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_margin_start());
    }

    // optional int32 margin_top = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_margin_top());
    }

    // optional int32 margin_end = 5;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_margin_end());
    }

    // optional int32 margin_bottom = 6;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_margin_bottom());
    }

    // optional int32 layout_gravity = 7;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_layout_gravity());
    }

    // optional float layout_weight = 8;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 4;
    }

    // optional int32 minimum_width = 9;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_minimum_width());
    }

    // optional int32 minimum_height = 10;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_minimum_height());
    }

  }
  if (cached_has_bits & 0x00000300u) {
    // optional int32 layout_width = 1 [default = -2];
    if (cached_has_bits & 0x00000100u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_layout_width());
    }

    // optional int32 layout_height = 2 [default = -2];
    if (cached_has_bits & 0x00000200u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_layout_height());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ViewLayoutParamsProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ViewLayoutParamsProto*>(
      &from));
}

void ViewLayoutParamsProto::MergeFrom(const ViewLayoutParamsProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.ViewLayoutParamsProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      margin_start_ = from.margin_start_;
    }
    if (cached_has_bits & 0x00000002u) {
      margin_top_ = from.margin_top_;
    }
    if (cached_has_bits & 0x00000004u) {
      margin_end_ = from.margin_end_;
    }
    if (cached_has_bits & 0x00000008u) {
      margin_bottom_ = from.margin_bottom_;
    }
    if (cached_has_bits & 0x00000010u) {
      layout_gravity_ = from.layout_gravity_;
    }
    if (cached_has_bits & 0x00000020u) {
      layout_weight_ = from.layout_weight_;
    }
    if (cached_has_bits & 0x00000040u) {
      minimum_width_ = from.minimum_width_;
    }
    if (cached_has_bits & 0x00000080u) {
      minimum_height_ = from.minimum_height_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000300u) {
    if (cached_has_bits & 0x00000100u) {
      layout_width_ = from.layout_width_;
    }
    if (cached_has_bits & 0x00000200u) {
      layout_height_ = from.layout_height_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ViewLayoutParamsProto::CopyFrom(const ViewLayoutParamsProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.ViewLayoutParamsProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ViewLayoutParamsProto::IsInitialized() const {
  return true;
}

void ViewLayoutParamsProto::InternalSwap(ViewLayoutParamsProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ViewLayoutParamsProto, minimum_height_)
      + sizeof(ViewLayoutParamsProto::minimum_height_)
      - PROTOBUF_FIELD_OFFSET(ViewLayoutParamsProto, margin_start_)>(
          reinterpret_cast<char*>(&margin_start_),
          reinterpret_cast<char*>(&other->margin_start_));
  swap(layout_width_, other->layout_width_);
  swap(layout_height_, other->layout_height_);
}

std::string ViewLayoutParamsProto::GetTypeName() const {
  return "autofill_assistant.ViewLayoutParamsProto";
}


// ===================================================================

class ViewContainerProto::_Internal {
 public:
  static const ::autofill_assistant::LinearLayoutProto& linear_layout(const ViewContainerProto* msg);
  static const ::autofill_assistant::VerticalExpanderAccordionProto& expander_accordion(const ViewContainerProto* msg);
};

const ::autofill_assistant::LinearLayoutProto&
ViewContainerProto::_Internal::linear_layout(const ViewContainerProto* msg) {
  return *msg->container_.linear_layout_;
}
const ::autofill_assistant::VerticalExpanderAccordionProto&
ViewContainerProto::_Internal::expander_accordion(const ViewContainerProto* msg) {
  return *msg->container_.expander_accordion_;
}
void ViewContainerProto::set_allocated_linear_layout(::autofill_assistant::LinearLayoutProto* linear_layout) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_container();
  if (linear_layout) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(linear_layout);
    if (message_arena != submessage_arena) {
      linear_layout = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, linear_layout, submessage_arena);
    }
    set_has_linear_layout();
    container_.linear_layout_ = linear_layout;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ViewContainerProto.linear_layout)
}
void ViewContainerProto::set_allocated_expander_accordion(::autofill_assistant::VerticalExpanderAccordionProto* expander_accordion) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_container();
  if (expander_accordion) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(expander_accordion);
    if (message_arena != submessage_arena) {
      expander_accordion = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, expander_accordion, submessage_arena);
    }
    set_has_expander_accordion();
    container_.expander_accordion_ = expander_accordion;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ViewContainerProto.expander_accordion)
}
ViewContainerProto::ViewContainerProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  views_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.ViewContainerProto)
}
ViewContainerProto::ViewContainerProto(const ViewContainerProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      views_(from.views_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  clear_has_container();
  switch (from.container_case()) {
    case kLinearLayout: {
      _internal_mutable_linear_layout()->::autofill_assistant::LinearLayoutProto::MergeFrom(from._internal_linear_layout());
      break;
    }
    case kExpanderAccordion: {
      _internal_mutable_expander_accordion()->::autofill_assistant::VerticalExpanderAccordionProto::MergeFrom(from._internal_expander_accordion());
      break;
    }
    case CONTAINER_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.ViewContainerProto)
}

inline void ViewContainerProto::SharedCtor() {
clear_has_container();
}

ViewContainerProto::~ViewContainerProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.ViewContainerProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ViewContainerProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_container()) {
    clear_container();
  }
}

void ViewContainerProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ViewContainerProto::clear_container() {
// @@protoc_insertion_point(one_of_clear_start:autofill_assistant.ViewContainerProto)
  switch (container_case()) {
    case kLinearLayout: {
      if (GetArenaForAllocation() == nullptr) {
        delete container_.linear_layout_;
      }
      break;
    }
    case kExpanderAccordion: {
      if (GetArenaForAllocation() == nullptr) {
        delete container_.expander_accordion_;
      }
      break;
    }
    case CONTAINER_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = CONTAINER_NOT_SET;
}


void ViewContainerProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.ViewContainerProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  views_.Clear();
  clear_container();
  _internal_metadata_.Clear<std::string>();
}

const char* ViewContainerProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .autofill_assistant.ViewProto views = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_views(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.LinearLayoutProto linear_layout = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_linear_layout(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.VerticalExpanderAccordionProto expander_accordion = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_expander_accordion(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ViewContainerProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.ViewContainerProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .autofill_assistant.ViewProto views = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_views_size()); i < n; i++) {
    const auto& repfield = this->_internal_views(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  switch (container_case()) {
    case kLinearLayout: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, _Internal::linear_layout(this),
          _Internal::linear_layout(this).GetCachedSize(), target, stream);
      break;
    }
    case kExpanderAccordion: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, _Internal::expander_accordion(this),
          _Internal::expander_accordion(this).GetCachedSize(), target, stream);
      break;
    }
    default: ;
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.ViewContainerProto)
  return target;
}

size_t ViewContainerProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.ViewContainerProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .autofill_assistant.ViewProto views = 1;
  total_size += 1UL * this->_internal_views_size();
  for (const auto& msg : this->views_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  switch (container_case()) {
    // .autofill_assistant.LinearLayoutProto linear_layout = 2;
    case kLinearLayout: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *container_.linear_layout_);
      break;
    }
    // .autofill_assistant.VerticalExpanderAccordionProto expander_accordion = 3;
    case kExpanderAccordion: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *container_.expander_accordion_);
      break;
    }
    case CONTAINER_NOT_SET: {
      break;
    }
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ViewContainerProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ViewContainerProto*>(
      &from));
}

void ViewContainerProto::MergeFrom(const ViewContainerProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.ViewContainerProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  views_.MergeFrom(from.views_);
  switch (from.container_case()) {
    case kLinearLayout: {
      _internal_mutable_linear_layout()->::autofill_assistant::LinearLayoutProto::MergeFrom(from._internal_linear_layout());
      break;
    }
    case kExpanderAccordion: {
      _internal_mutable_expander_accordion()->::autofill_assistant::VerticalExpanderAccordionProto::MergeFrom(from._internal_expander_accordion());
      break;
    }
    case CONTAINER_NOT_SET: {
      break;
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ViewContainerProto::CopyFrom(const ViewContainerProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.ViewContainerProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ViewContainerProto::IsInitialized() const {
  return true;
}

void ViewContainerProto::InternalSwap(ViewContainerProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  views_.InternalSwap(&other->views_);
  swap(container_, other->container_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

std::string ViewContainerProto::GetTypeName() const {
  return "autofill_assistant.ViewContainerProto";
}


// ===================================================================

class LinearLayoutProto::_Internal {
 public:
  using HasBits = decltype(std::declval<LinearLayoutProto>()._has_bits_);
  static void set_has_orientation(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

LinearLayoutProto::LinearLayoutProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.LinearLayoutProto)
}
LinearLayoutProto::LinearLayoutProto(const LinearLayoutProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  orientation_ = from.orientation_;
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.LinearLayoutProto)
}

inline void LinearLayoutProto::SharedCtor() {
orientation_ = 0;
}

LinearLayoutProto::~LinearLayoutProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.LinearLayoutProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LinearLayoutProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void LinearLayoutProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void LinearLayoutProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.LinearLayoutProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  orientation_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* LinearLayoutProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .autofill_assistant.LinearLayoutProto.Orientation orientation = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::autofill_assistant::LinearLayoutProto_Orientation_IsValid(val))) {
            _internal_set_orientation(static_cast<::autofill_assistant::LinearLayoutProto_Orientation>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LinearLayoutProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.LinearLayoutProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .autofill_assistant.LinearLayoutProto.Orientation orientation = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_orientation(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.LinearLayoutProto)
  return target;
}

size_t LinearLayoutProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.LinearLayoutProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .autofill_assistant.LinearLayoutProto.Orientation orientation = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_orientation());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void LinearLayoutProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const LinearLayoutProto*>(
      &from));
}

void LinearLayoutProto::MergeFrom(const LinearLayoutProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.LinearLayoutProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_orientation()) {
    _internal_set_orientation(from._internal_orientation());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void LinearLayoutProto::CopyFrom(const LinearLayoutProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.LinearLayoutProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LinearLayoutProto::IsInitialized() const {
  return true;
}

void LinearLayoutProto::InternalSwap(LinearLayoutProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(orientation_, other->orientation_);
}

std::string LinearLayoutProto::GetTypeName() const {
  return "autofill_assistant.LinearLayoutProto";
}


// ===================================================================

class VerticalExpanderViewProto::_Internal {
 public:
  using HasBits = decltype(std::declval<VerticalExpanderViewProto>()._has_bits_);
  static const ::autofill_assistant::ViewProto& title_view(const VerticalExpanderViewProto* msg);
  static void set_has_title_view(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::autofill_assistant::ViewProto& collapsed_view(const VerticalExpanderViewProto* msg);
  static void set_has_collapsed_view(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::autofill_assistant::ViewProto& expanded_view(const VerticalExpanderViewProto* msg);
  static void set_has_expanded_view(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_chevron_style(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::autofill_assistant::ViewProto&
VerticalExpanderViewProto::_Internal::title_view(const VerticalExpanderViewProto* msg) {
  return *msg->title_view_;
}
const ::autofill_assistant::ViewProto&
VerticalExpanderViewProto::_Internal::collapsed_view(const VerticalExpanderViewProto* msg) {
  return *msg->collapsed_view_;
}
const ::autofill_assistant::ViewProto&
VerticalExpanderViewProto::_Internal::expanded_view(const VerticalExpanderViewProto* msg) {
  return *msg->expanded_view_;
}
VerticalExpanderViewProto::VerticalExpanderViewProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.VerticalExpanderViewProto)
}
VerticalExpanderViewProto::VerticalExpanderViewProto(const VerticalExpanderViewProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_title_view()) {
    title_view_ = new ::autofill_assistant::ViewProto(*from.title_view_);
  } else {
    title_view_ = nullptr;
  }
  if (from._internal_has_collapsed_view()) {
    collapsed_view_ = new ::autofill_assistant::ViewProto(*from.collapsed_view_);
  } else {
    collapsed_view_ = nullptr;
  }
  if (from._internal_has_expanded_view()) {
    expanded_view_ = new ::autofill_assistant::ViewProto(*from.expanded_view_);
  } else {
    expanded_view_ = nullptr;
  }
  chevron_style_ = from.chevron_style_;
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.VerticalExpanderViewProto)
}

inline void VerticalExpanderViewProto::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&title_view_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&chevron_style_) -
    reinterpret_cast<char*>(&title_view_)) + sizeof(chevron_style_));
}

VerticalExpanderViewProto::~VerticalExpanderViewProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.VerticalExpanderViewProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void VerticalExpanderViewProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete title_view_;
  if (this != internal_default_instance()) delete collapsed_view_;
  if (this != internal_default_instance()) delete expanded_view_;
}

void VerticalExpanderViewProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void VerticalExpanderViewProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.VerticalExpanderViewProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(title_view_ != nullptr);
      title_view_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(collapsed_view_ != nullptr);
      collapsed_view_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(expanded_view_ != nullptr);
      expanded_view_->Clear();
    }
  }
  chevron_style_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* VerticalExpanderViewProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .autofill_assistant.ViewProto title_view = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_title_view(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .autofill_assistant.ViewProto collapsed_view = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_collapsed_view(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .autofill_assistant.ViewProto expanded_view = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_expanded_view(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .autofill_assistant.VerticalExpanderViewProto.ChevronStyle chevron_style = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::autofill_assistant::VerticalExpanderViewProto_ChevronStyle_IsValid(val))) {
            _internal_set_chevron_style(static_cast<::autofill_assistant::VerticalExpanderViewProto_ChevronStyle>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* VerticalExpanderViewProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.VerticalExpanderViewProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .autofill_assistant.ViewProto title_view = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::title_view(this),
        _Internal::title_view(this).GetCachedSize(), target, stream);
  }

  // optional .autofill_assistant.ViewProto collapsed_view = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::collapsed_view(this),
        _Internal::collapsed_view(this).GetCachedSize(), target, stream);
  }

  // optional .autofill_assistant.ViewProto expanded_view = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::expanded_view(this),
        _Internal::expanded_view(this).GetCachedSize(), target, stream);
  }

  // optional .autofill_assistant.VerticalExpanderViewProto.ChevronStyle chevron_style = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      4, this->_internal_chevron_style(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.VerticalExpanderViewProto)
  return target;
}

size_t VerticalExpanderViewProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.VerticalExpanderViewProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional .autofill_assistant.ViewProto title_view = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *title_view_);
    }

    // optional .autofill_assistant.ViewProto collapsed_view = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *collapsed_view_);
    }

    // optional .autofill_assistant.ViewProto expanded_view = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *expanded_view_);
    }

    // optional .autofill_assistant.VerticalExpanderViewProto.ChevronStyle chevron_style = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_chevron_style());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void VerticalExpanderViewProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const VerticalExpanderViewProto*>(
      &from));
}

void VerticalExpanderViewProto::MergeFrom(const VerticalExpanderViewProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.VerticalExpanderViewProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_title_view()->::autofill_assistant::ViewProto::MergeFrom(from._internal_title_view());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_collapsed_view()->::autofill_assistant::ViewProto::MergeFrom(from._internal_collapsed_view());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_expanded_view()->::autofill_assistant::ViewProto::MergeFrom(from._internal_expanded_view());
    }
    if (cached_has_bits & 0x00000008u) {
      chevron_style_ = from.chevron_style_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void VerticalExpanderViewProto::CopyFrom(const VerticalExpanderViewProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.VerticalExpanderViewProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VerticalExpanderViewProto::IsInitialized() const {
  return true;
}

void VerticalExpanderViewProto::InternalSwap(VerticalExpanderViewProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(VerticalExpanderViewProto, chevron_style_)
      + sizeof(VerticalExpanderViewProto::chevron_style_)
      - PROTOBUF_FIELD_OFFSET(VerticalExpanderViewProto, title_view_)>(
          reinterpret_cast<char*>(&title_view_),
          reinterpret_cast<char*>(&other->title_view_));
}

std::string VerticalExpanderViewProto::GetTypeName() const {
  return "autofill_assistant.VerticalExpanderViewProto";
}


// ===================================================================

class VerticalExpanderAccordionProto::_Internal {
 public:
  using HasBits = decltype(std::declval<VerticalExpanderAccordionProto>()._has_bits_);
  static void set_has_orientation(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

VerticalExpanderAccordionProto::VerticalExpanderAccordionProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.VerticalExpanderAccordionProto)
}
VerticalExpanderAccordionProto::VerticalExpanderAccordionProto(const VerticalExpanderAccordionProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  orientation_ = from.orientation_;
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.VerticalExpanderAccordionProto)
}

inline void VerticalExpanderAccordionProto::SharedCtor() {
orientation_ = 0;
}

VerticalExpanderAccordionProto::~VerticalExpanderAccordionProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.VerticalExpanderAccordionProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void VerticalExpanderAccordionProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void VerticalExpanderAccordionProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void VerticalExpanderAccordionProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.VerticalExpanderAccordionProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  orientation_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* VerticalExpanderAccordionProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .autofill_assistant.LinearLayoutProto.Orientation orientation = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::autofill_assistant::LinearLayoutProto_Orientation_IsValid(val))) {
            _internal_set_orientation(static_cast<::autofill_assistant::LinearLayoutProto_Orientation>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* VerticalExpanderAccordionProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.VerticalExpanderAccordionProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .autofill_assistant.LinearLayoutProto.Orientation orientation = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_orientation(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.VerticalExpanderAccordionProto)
  return target;
}

size_t VerticalExpanderAccordionProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.VerticalExpanderAccordionProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .autofill_assistant.LinearLayoutProto.Orientation orientation = 2;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_orientation());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void VerticalExpanderAccordionProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const VerticalExpanderAccordionProto*>(
      &from));
}

void VerticalExpanderAccordionProto::MergeFrom(const VerticalExpanderAccordionProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.VerticalExpanderAccordionProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_orientation()) {
    _internal_set_orientation(from._internal_orientation());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void VerticalExpanderAccordionProto::CopyFrom(const VerticalExpanderAccordionProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.VerticalExpanderAccordionProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VerticalExpanderAccordionProto::IsInitialized() const {
  return true;
}

void VerticalExpanderAccordionProto::InternalSwap(VerticalExpanderAccordionProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(orientation_, other->orientation_);
}

std::string VerticalExpanderAccordionProto::GetTypeName() const {
  return "autofill_assistant.VerticalExpanderAccordionProto";
}


// ===================================================================

class TextViewProto::_Internal {
 public:
  using HasBits = decltype(std::declval<TextViewProto>()._has_bits_);
  static void set_has_text_appearance(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_text_alignment(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

TextViewProto::TextViewProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.TextViewProto)
}
TextViewProto::TextViewProto(const TextViewProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  text_appearance_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    text_appearance_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_text_appearance()) {
    text_appearance_.Set(from._internal_text_appearance(), 
      GetArenaForAllocation());
  }
  text_alignment_ = from.text_alignment_;
  clear_has_kind();
  switch (from.kind_case()) {
    case kText: {
      _internal_set_text(from._internal_text());
      break;
    }
    case kModelIdentifier: {
      _internal_set_model_identifier(from._internal_model_identifier());
      break;
    }
    case KIND_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.TextViewProto)
}

inline void TextViewProto::SharedCtor() {
text_appearance_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  text_appearance_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
text_alignment_ = 8388659;
clear_has_kind();
}

TextViewProto::~TextViewProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.TextViewProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TextViewProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  text_appearance_.Destroy();
  if (has_kind()) {
    clear_kind();
  }
}

void TextViewProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void TextViewProto::clear_kind() {
// @@protoc_insertion_point(one_of_clear_start:autofill_assistant.TextViewProto)
  switch (kind_case()) {
    case kText: {
      kind_.text_.Destroy();
      break;
    }
    case kModelIdentifier: {
      kind_.model_identifier_.Destroy();
      break;
    }
    case KIND_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = KIND_NOT_SET;
}


void TextViewProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.TextViewProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      text_appearance_.ClearNonDefaultToEmpty();
    }
    text_alignment_ = 8388659;
  }
  clear_kind();
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* TextViewProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string text = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_text();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string text_appearance = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_text_appearance();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string model_identifier = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_model_identifier();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 text_alignment = 4 [default = 8388659];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_text_alignment(&has_bits);
          text_alignment_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TextViewProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.TextViewProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string text = 1;
  if (_internal_has_text()) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_text(), target);
  }

  cached_has_bits = _has_bits_[0];
  // optional string text_appearance = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_text_appearance(), target);
  }

  // string model_identifier = 3;
  if (_internal_has_model_identifier()) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_model_identifier(), target);
  }

  // optional int32 text_alignment = 4 [default = 8388659];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_text_alignment(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.TextViewProto)
  return target;
}

size_t TextViewProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.TextViewProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string text_appearance = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_text_appearance());
    }

    // optional int32 text_alignment = 4 [default = 8388659];
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_text_alignment());
    }

  }
  switch (kind_case()) {
    // string text = 1;
    case kText: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_text());
      break;
    }
    // string model_identifier = 3;
    case kModelIdentifier: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_model_identifier());
      break;
    }
    case KIND_NOT_SET: {
      break;
    }
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TextViewProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const TextViewProto*>(
      &from));
}

void TextViewProto::MergeFrom(const TextViewProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.TextViewProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_text_appearance(from._internal_text_appearance());
    }
    if (cached_has_bits & 0x00000002u) {
      text_alignment_ = from.text_alignment_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  switch (from.kind_case()) {
    case kText: {
      _internal_set_text(from._internal_text());
      break;
    }
    case kModelIdentifier: {
      _internal_set_model_identifier(from._internal_model_identifier());
      break;
    }
    case KIND_NOT_SET: {
      break;
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TextViewProto::CopyFrom(const TextViewProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.TextViewProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TextViewProto::IsInitialized() const {
  return true;
}

void TextViewProto::InternalSwap(TextViewProto* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &text_appearance_, lhs_arena,
      &other->text_appearance_, rhs_arena
  );
  swap(text_alignment_, other->text_alignment_);
  swap(kind_, other->kind_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

std::string TextViewProto::GetTypeName() const {
  return "autofill_assistant.TextViewProto";
}


// ===================================================================

class DividerViewProto::_Internal {
 public:
};

DividerViewProto::DividerViewProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.DividerViewProto)
}
DividerViewProto::DividerViewProto(const DividerViewProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.DividerViewProto)
}

inline void DividerViewProto::SharedCtor() {
}

DividerViewProto::~DividerViewProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.DividerViewProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DividerViewProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void DividerViewProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void DividerViewProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.DividerViewProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_metadata_.Clear<std::string>();
}

const char* DividerViewProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DividerViewProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.DividerViewProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.DividerViewProto)
  return target;
}

size_t DividerViewProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.DividerViewProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DividerViewProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DividerViewProto*>(
      &from));
}

void DividerViewProto::MergeFrom(const DividerViewProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.DividerViewProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DividerViewProto::CopyFrom(const DividerViewProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.DividerViewProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DividerViewProto::IsInitialized() const {
  return true;
}

void DividerViewProto::InternalSwap(DividerViewProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
}

std::string DividerViewProto::GetTypeName() const {
  return "autofill_assistant.DividerViewProto";
}


// ===================================================================

class ImageViewProto::_Internal {
 public:
  using HasBits = decltype(std::declval<ImageViewProto>()._has_bits_);
  static const ::autofill_assistant::DrawableProto& image(const ImageViewProto* msg);
  static void set_has_image(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::autofill_assistant::DrawableProto&
ImageViewProto::_Internal::image(const ImageViewProto* msg) {
  return *msg->image_;
}
ImageViewProto::ImageViewProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.ImageViewProto)
}
ImageViewProto::ImageViewProto(const ImageViewProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_image()) {
    image_ = new ::autofill_assistant::DrawableProto(*from.image_);
  } else {
    image_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.ImageViewProto)
}

inline void ImageViewProto::SharedCtor() {
image_ = nullptr;
}

ImageViewProto::~ImageViewProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.ImageViewProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ImageViewProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete image_;
}

void ImageViewProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ImageViewProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.ImageViewProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(image_ != nullptr);
    image_->Clear();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ImageViewProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .autofill_assistant.DrawableProto image = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_image(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ImageViewProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.ImageViewProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .autofill_assistant.DrawableProto image = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::image(this),
        _Internal::image(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.ImageViewProto)
  return target;
}

size_t ImageViewProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.ImageViewProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .autofill_assistant.DrawableProto image = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *image_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ImageViewProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ImageViewProto*>(
      &from));
}

void ImageViewProto::MergeFrom(const ImageViewProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.ImageViewProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_image()) {
    _internal_mutable_image()->::autofill_assistant::DrawableProto::MergeFrom(from._internal_image());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ImageViewProto::CopyFrom(const ImageViewProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.ImageViewProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ImageViewProto::IsInitialized() const {
  return true;
}

void ImageViewProto::InternalSwap(ImageViewProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(image_, other->image_);
}

std::string ImageViewProto::GetTypeName() const {
  return "autofill_assistant.ImageViewProto";
}


// ===================================================================

class TextInputViewProto::_Internal {
 public:
  using HasBits = decltype(std::declval<TextInputViewProto>()._has_bits_);
  static void set_has_hint(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_model_identifier(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_focus_and_show_keyboard(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

TextInputViewProto::TextInputViewProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.TextInputViewProto)
}
TextInputViewProto::TextInputViewProto(const TextInputViewProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  hint_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    hint_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_hint()) {
    hint_.Set(from._internal_hint(), 
      GetArenaForAllocation());
  }
  model_identifier_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    model_identifier_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_model_identifier()) {
    model_identifier_.Set(from._internal_model_identifier(), 
      GetArenaForAllocation());
  }
  ::memcpy(&type_, &from.type_,
    static_cast<size_t>(reinterpret_cast<char*>(&focus_and_show_keyboard_) -
    reinterpret_cast<char*>(&type_)) + sizeof(focus_and_show_keyboard_));
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.TextInputViewProto)
}

inline void TextInputViewProto::SharedCtor() {
hint_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  hint_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
model_identifier_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  model_identifier_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&type_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&focus_and_show_keyboard_) -
    reinterpret_cast<char*>(&type_)) + sizeof(focus_and_show_keyboard_));
}

TextInputViewProto::~TextInputViewProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.TextInputViewProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TextInputViewProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  hint_.Destroy();
  model_identifier_.Destroy();
}

void TextInputViewProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void TextInputViewProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.TextInputViewProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      hint_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      model_identifier_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000000cu) {
    ::memset(&type_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&focus_and_show_keyboard_) -
        reinterpret_cast<char*>(&type_)) + sizeof(focus_and_show_keyboard_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* TextInputViewProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string hint = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_hint();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .autofill_assistant.TextInputViewProto.InputTypeHint type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::autofill_assistant::TextInputViewProto_InputTypeHint_IsValid(val))) {
            _internal_set_type(static_cast<::autofill_assistant::TextInputViewProto_InputTypeHint>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional string model_identifier = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_model_identifier();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool focus_and_show_keyboard = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_focus_and_show_keyboard(&has_bits);
          focus_and_show_keyboard_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TextInputViewProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.TextInputViewProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string hint = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_hint(), target);
  }

  // optional .autofill_assistant.TextInputViewProto.InputTypeHint type = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_type(), target);
  }

  // optional string model_identifier = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_model_identifier(), target);
  }

  // optional bool focus_and_show_keyboard = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_focus_and_show_keyboard(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.TextInputViewProto)
  return target;
}

size_t TextInputViewProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.TextInputViewProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string hint = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_hint());
    }

    // optional string model_identifier = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_model_identifier());
    }

    // optional .autofill_assistant.TextInputViewProto.InputTypeHint type = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
    }

    // optional bool focus_and_show_keyboard = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TextInputViewProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const TextInputViewProto*>(
      &from));
}

void TextInputViewProto::MergeFrom(const TextInputViewProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.TextInputViewProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_hint(from._internal_hint());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_model_identifier(from._internal_model_identifier());
    }
    if (cached_has_bits & 0x00000004u) {
      type_ = from.type_;
    }
    if (cached_has_bits & 0x00000008u) {
      focus_and_show_keyboard_ = from.focus_and_show_keyboard_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TextInputViewProto::CopyFrom(const TextInputViewProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.TextInputViewProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TextInputViewProto::IsInitialized() const {
  return true;
}

void TextInputViewProto::InternalSwap(TextInputViewProto* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &hint_, lhs_arena,
      &other->hint_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &model_identifier_, lhs_arena,
      &other->model_identifier_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TextInputViewProto, focus_and_show_keyboard_)
      + sizeof(TextInputViewProto::focus_and_show_keyboard_)
      - PROTOBUF_FIELD_OFFSET(TextInputViewProto, type_)>(
          reinterpret_cast<char*>(&type_),
          reinterpret_cast<char*>(&other->type_));
}

std::string TextInputViewProto::GetTypeName() const {
  return "autofill_assistant.TextInputViewProto";
}


// ===================================================================

class InfoPopupProto_DialogButton_CloseDialog::_Internal {
 public:
};

InfoPopupProto_DialogButton_CloseDialog::InfoPopupProto_DialogButton_CloseDialog(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.InfoPopupProto.DialogButton.CloseDialog)
}
InfoPopupProto_DialogButton_CloseDialog::InfoPopupProto_DialogButton_CloseDialog(const InfoPopupProto_DialogButton_CloseDialog& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.InfoPopupProto.DialogButton.CloseDialog)
}

inline void InfoPopupProto_DialogButton_CloseDialog::SharedCtor() {
}

InfoPopupProto_DialogButton_CloseDialog::~InfoPopupProto_DialogButton_CloseDialog() {
  // @@protoc_insertion_point(destructor:autofill_assistant.InfoPopupProto.DialogButton.CloseDialog)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void InfoPopupProto_DialogButton_CloseDialog::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void InfoPopupProto_DialogButton_CloseDialog::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void InfoPopupProto_DialogButton_CloseDialog::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.InfoPopupProto.DialogButton.CloseDialog)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_metadata_.Clear<std::string>();
}

const char* InfoPopupProto_DialogButton_CloseDialog::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* InfoPopupProto_DialogButton_CloseDialog::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.InfoPopupProto.DialogButton.CloseDialog)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.InfoPopupProto.DialogButton.CloseDialog)
  return target;
}

size_t InfoPopupProto_DialogButton_CloseDialog::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.InfoPopupProto.DialogButton.CloseDialog)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void InfoPopupProto_DialogButton_CloseDialog::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const InfoPopupProto_DialogButton_CloseDialog*>(
      &from));
}

void InfoPopupProto_DialogButton_CloseDialog::MergeFrom(const InfoPopupProto_DialogButton_CloseDialog& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.InfoPopupProto.DialogButton.CloseDialog)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void InfoPopupProto_DialogButton_CloseDialog::CopyFrom(const InfoPopupProto_DialogButton_CloseDialog& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.InfoPopupProto.DialogButton.CloseDialog)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool InfoPopupProto_DialogButton_CloseDialog::IsInitialized() const {
  return true;
}

void InfoPopupProto_DialogButton_CloseDialog::InternalSwap(InfoPopupProto_DialogButton_CloseDialog* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
}

std::string InfoPopupProto_DialogButton_CloseDialog::GetTypeName() const {
  return "autofill_assistant.InfoPopupProto.DialogButton.CloseDialog";
}


// ===================================================================

class InfoPopupProto_DialogButton_OpenUrlInCCT::_Internal {
 public:
  using HasBits = decltype(std::declval<InfoPopupProto_DialogButton_OpenUrlInCCT>()._has_bits_);
  static void set_has_url(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

InfoPopupProto_DialogButton_OpenUrlInCCT::InfoPopupProto_DialogButton_OpenUrlInCCT(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.InfoPopupProto.DialogButton.OpenUrlInCCT)
}
InfoPopupProto_DialogButton_OpenUrlInCCT::InfoPopupProto_DialogButton_OpenUrlInCCT(const InfoPopupProto_DialogButton_OpenUrlInCCT& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_url()) {
    url_.Set(from._internal_url(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.InfoPopupProto.DialogButton.OpenUrlInCCT)
}

inline void InfoPopupProto_DialogButton_OpenUrlInCCT::SharedCtor() {
url_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  url_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

InfoPopupProto_DialogButton_OpenUrlInCCT::~InfoPopupProto_DialogButton_OpenUrlInCCT() {
  // @@protoc_insertion_point(destructor:autofill_assistant.InfoPopupProto.DialogButton.OpenUrlInCCT)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void InfoPopupProto_DialogButton_OpenUrlInCCT::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  url_.Destroy();
}

void InfoPopupProto_DialogButton_OpenUrlInCCT::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void InfoPopupProto_DialogButton_OpenUrlInCCT::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.InfoPopupProto.DialogButton.OpenUrlInCCT)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    url_.ClearNonDefaultToEmpty();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* InfoPopupProto_DialogButton_OpenUrlInCCT::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string url = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_url();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* InfoPopupProto_DialogButton_OpenUrlInCCT::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.InfoPopupProto.DialogButton.OpenUrlInCCT)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string url = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_url(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.InfoPopupProto.DialogButton.OpenUrlInCCT)
  return target;
}

size_t InfoPopupProto_DialogButton_OpenUrlInCCT::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.InfoPopupProto.DialogButton.OpenUrlInCCT)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string url = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_url());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void InfoPopupProto_DialogButton_OpenUrlInCCT::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const InfoPopupProto_DialogButton_OpenUrlInCCT*>(
      &from));
}

void InfoPopupProto_DialogButton_OpenUrlInCCT::MergeFrom(const InfoPopupProto_DialogButton_OpenUrlInCCT& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.InfoPopupProto.DialogButton.OpenUrlInCCT)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_url()) {
    _internal_set_url(from._internal_url());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void InfoPopupProto_DialogButton_OpenUrlInCCT::CopyFrom(const InfoPopupProto_DialogButton_OpenUrlInCCT& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.InfoPopupProto.DialogButton.OpenUrlInCCT)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool InfoPopupProto_DialogButton_OpenUrlInCCT::IsInitialized() const {
  return true;
}

void InfoPopupProto_DialogButton_OpenUrlInCCT::InternalSwap(InfoPopupProto_DialogButton_OpenUrlInCCT* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &url_, lhs_arena,
      &other->url_, rhs_arena
  );
}

std::string InfoPopupProto_DialogButton_OpenUrlInCCT::GetTypeName() const {
  return "autofill_assistant.InfoPopupProto.DialogButton.OpenUrlInCCT";
}


// ===================================================================

class InfoPopupProto_DialogButton::_Internal {
 public:
  using HasBits = decltype(std::declval<InfoPopupProto_DialogButton>()._has_bits_);
  static const ::autofill_assistant::InfoPopupProto_DialogButton_CloseDialog& close_dialog(const InfoPopupProto_DialogButton* msg);
  static const ::autofill_assistant::InfoPopupProto_DialogButton_OpenUrlInCCT& open_url_in_cct(const InfoPopupProto_DialogButton* msg);
  static void set_has_label(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::autofill_assistant::InfoPopupProto_DialogButton_CloseDialog&
InfoPopupProto_DialogButton::_Internal::close_dialog(const InfoPopupProto_DialogButton* msg) {
  return *msg->click_action_.close_dialog_;
}
const ::autofill_assistant::InfoPopupProto_DialogButton_OpenUrlInCCT&
InfoPopupProto_DialogButton::_Internal::open_url_in_cct(const InfoPopupProto_DialogButton* msg) {
  return *msg->click_action_.open_url_in_cct_;
}
void InfoPopupProto_DialogButton::set_allocated_close_dialog(::autofill_assistant::InfoPopupProto_DialogButton_CloseDialog* close_dialog) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_click_action();
  if (close_dialog) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(close_dialog);
    if (message_arena != submessage_arena) {
      close_dialog = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, close_dialog, submessage_arena);
    }
    set_has_close_dialog();
    click_action_.close_dialog_ = close_dialog;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.InfoPopupProto.DialogButton.close_dialog)
}
void InfoPopupProto_DialogButton::set_allocated_open_url_in_cct(::autofill_assistant::InfoPopupProto_DialogButton_OpenUrlInCCT* open_url_in_cct) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_click_action();
  if (open_url_in_cct) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(open_url_in_cct);
    if (message_arena != submessage_arena) {
      open_url_in_cct = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, open_url_in_cct, submessage_arena);
    }
    set_has_open_url_in_cct();
    click_action_.open_url_in_cct_ = open_url_in_cct;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.InfoPopupProto.DialogButton.open_url_in_cct)
}
InfoPopupProto_DialogButton::InfoPopupProto_DialogButton(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.InfoPopupProto.DialogButton)
}
InfoPopupProto_DialogButton::InfoPopupProto_DialogButton(const InfoPopupProto_DialogButton& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  label_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    label_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_label()) {
    label_.Set(from._internal_label(), 
      GetArenaForAllocation());
  }
  clear_has_click_action();
  switch (from.click_action_case()) {
    case kCloseDialog: {
      _internal_mutable_close_dialog()->::autofill_assistant::InfoPopupProto_DialogButton_CloseDialog::MergeFrom(from._internal_close_dialog());
      break;
    }
    case kOpenUrlInCct: {
      _internal_mutable_open_url_in_cct()->::autofill_assistant::InfoPopupProto_DialogButton_OpenUrlInCCT::MergeFrom(from._internal_open_url_in_cct());
      break;
    }
    case CLICK_ACTION_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.InfoPopupProto.DialogButton)
}

inline void InfoPopupProto_DialogButton::SharedCtor() {
label_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  label_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
clear_has_click_action();
}

InfoPopupProto_DialogButton::~InfoPopupProto_DialogButton() {
  // @@protoc_insertion_point(destructor:autofill_assistant.InfoPopupProto.DialogButton)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void InfoPopupProto_DialogButton::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  label_.Destroy();
  if (has_click_action()) {
    clear_click_action();
  }
}

void InfoPopupProto_DialogButton::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void InfoPopupProto_DialogButton::clear_click_action() {
// @@protoc_insertion_point(one_of_clear_start:autofill_assistant.InfoPopupProto.DialogButton)
  switch (click_action_case()) {
    case kCloseDialog: {
      if (GetArenaForAllocation() == nullptr) {
        delete click_action_.close_dialog_;
      }
      break;
    }
    case kOpenUrlInCct: {
      if (GetArenaForAllocation() == nullptr) {
        delete click_action_.open_url_in_cct_;
      }
      break;
    }
    case CLICK_ACTION_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = CLICK_ACTION_NOT_SET;
}


void InfoPopupProto_DialogButton::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.InfoPopupProto.DialogButton)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    label_.ClearNonDefaultToEmpty();
  }
  clear_click_action();
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* InfoPopupProto_DialogButton::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string label = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_label();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.InfoPopupProto.DialogButton.CloseDialog close_dialog = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_close_dialog(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.InfoPopupProto.DialogButton.OpenUrlInCCT open_url_in_cct = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_open_url_in_cct(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* InfoPopupProto_DialogButton::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.InfoPopupProto.DialogButton)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string label = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_label(), target);
  }

  switch (click_action_case()) {
    case kCloseDialog: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, _Internal::close_dialog(this),
          _Internal::close_dialog(this).GetCachedSize(), target, stream);
      break;
    }
    case kOpenUrlInCct: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(5, _Internal::open_url_in_cct(this),
          _Internal::open_url_in_cct(this).GetCachedSize(), target, stream);
      break;
    }
    default: ;
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.InfoPopupProto.DialogButton)
  return target;
}

size_t InfoPopupProto_DialogButton::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.InfoPopupProto.DialogButton)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string label = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_label());
  }

  switch (click_action_case()) {
    // .autofill_assistant.InfoPopupProto.DialogButton.CloseDialog close_dialog = 4;
    case kCloseDialog: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *click_action_.close_dialog_);
      break;
    }
    // .autofill_assistant.InfoPopupProto.DialogButton.OpenUrlInCCT open_url_in_cct = 5;
    case kOpenUrlInCct: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *click_action_.open_url_in_cct_);
      break;
    }
    case CLICK_ACTION_NOT_SET: {
      break;
    }
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void InfoPopupProto_DialogButton::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const InfoPopupProto_DialogButton*>(
      &from));
}

void InfoPopupProto_DialogButton::MergeFrom(const InfoPopupProto_DialogButton& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.InfoPopupProto.DialogButton)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_label()) {
    _internal_set_label(from._internal_label());
  }
  switch (from.click_action_case()) {
    case kCloseDialog: {
      _internal_mutable_close_dialog()->::autofill_assistant::InfoPopupProto_DialogButton_CloseDialog::MergeFrom(from._internal_close_dialog());
      break;
    }
    case kOpenUrlInCct: {
      _internal_mutable_open_url_in_cct()->::autofill_assistant::InfoPopupProto_DialogButton_OpenUrlInCCT::MergeFrom(from._internal_open_url_in_cct());
      break;
    }
    case CLICK_ACTION_NOT_SET: {
      break;
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void InfoPopupProto_DialogButton::CopyFrom(const InfoPopupProto_DialogButton& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.InfoPopupProto.DialogButton)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool InfoPopupProto_DialogButton::IsInitialized() const {
  return true;
}

void InfoPopupProto_DialogButton::InternalSwap(InfoPopupProto_DialogButton* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &label_, lhs_arena,
      &other->label_, rhs_arena
  );
  swap(click_action_, other->click_action_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

std::string InfoPopupProto_DialogButton::GetTypeName() const {
  return "autofill_assistant.InfoPopupProto.DialogButton";
}


// ===================================================================

class InfoPopupProto::_Internal {
 public:
  using HasBits = decltype(std::declval<InfoPopupProto>()._has_bits_);
  static void set_has_title(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_text(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::autofill_assistant::InfoPopupProto_DialogButton& positive_button(const InfoPopupProto* msg);
  static void set_has_positive_button(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::autofill_assistant::InfoPopupProto_DialogButton& negative_button(const InfoPopupProto* msg);
  static void set_has_negative_button(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::autofill_assistant::InfoPopupProto_DialogButton& neutral_button(const InfoPopupProto* msg);
  static void set_has_neutral_button(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

const ::autofill_assistant::InfoPopupProto_DialogButton&
InfoPopupProto::_Internal::positive_button(const InfoPopupProto* msg) {
  return *msg->positive_button_;
}
const ::autofill_assistant::InfoPopupProto_DialogButton&
InfoPopupProto::_Internal::negative_button(const InfoPopupProto* msg) {
  return *msg->negative_button_;
}
const ::autofill_assistant::InfoPopupProto_DialogButton&
InfoPopupProto::_Internal::neutral_button(const InfoPopupProto* msg) {
  return *msg->neutral_button_;
}
InfoPopupProto::InfoPopupProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.InfoPopupProto)
}
InfoPopupProto::InfoPopupProto(const InfoPopupProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  title_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    title_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_title()) {
    title_.Set(from._internal_title(), 
      GetArenaForAllocation());
  }
  text_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    text_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_text()) {
    text_.Set(from._internal_text(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_positive_button()) {
    positive_button_ = new ::autofill_assistant::InfoPopupProto_DialogButton(*from.positive_button_);
  } else {
    positive_button_ = nullptr;
  }
  if (from._internal_has_negative_button()) {
    negative_button_ = new ::autofill_assistant::InfoPopupProto_DialogButton(*from.negative_button_);
  } else {
    negative_button_ = nullptr;
  }
  if (from._internal_has_neutral_button()) {
    neutral_button_ = new ::autofill_assistant::InfoPopupProto_DialogButton(*from.neutral_button_);
  } else {
    neutral_button_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.InfoPopupProto)
}

inline void InfoPopupProto::SharedCtor() {
title_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  title_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
text_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  text_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&positive_button_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&neutral_button_) -
    reinterpret_cast<char*>(&positive_button_)) + sizeof(neutral_button_));
}

InfoPopupProto::~InfoPopupProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.InfoPopupProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void InfoPopupProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  title_.Destroy();
  text_.Destroy();
  if (this != internal_default_instance()) delete positive_button_;
  if (this != internal_default_instance()) delete negative_button_;
  if (this != internal_default_instance()) delete neutral_button_;
}

void InfoPopupProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void InfoPopupProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.InfoPopupProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      title_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      text_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(positive_button_ != nullptr);
      positive_button_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(negative_button_ != nullptr);
      negative_button_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(neutral_button_ != nullptr);
      neutral_button_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* InfoPopupProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string title = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_title();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string text = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_text();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .autofill_assistant.InfoPopupProto.DialogButton positive_button = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_positive_button(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .autofill_assistant.InfoPopupProto.DialogButton negative_button = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_negative_button(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .autofill_assistant.InfoPopupProto.DialogButton neutral_button = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_neutral_button(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* InfoPopupProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.InfoPopupProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string title = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_title(), target);
  }

  // optional string text = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_text(), target);
  }

  // optional .autofill_assistant.InfoPopupProto.DialogButton positive_button = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::positive_button(this),
        _Internal::positive_button(this).GetCachedSize(), target, stream);
  }

  // optional .autofill_assistant.InfoPopupProto.DialogButton negative_button = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::negative_button(this),
        _Internal::negative_button(this).GetCachedSize(), target, stream);
  }

  // optional .autofill_assistant.InfoPopupProto.DialogButton neutral_button = 5;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::neutral_button(this),
        _Internal::neutral_button(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.InfoPopupProto)
  return target;
}

size_t InfoPopupProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.InfoPopupProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional string title = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_title());
    }

    // optional string text = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_text());
    }

    // optional .autofill_assistant.InfoPopupProto.DialogButton positive_button = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *positive_button_);
    }

    // optional .autofill_assistant.InfoPopupProto.DialogButton negative_button = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *negative_button_);
    }

    // optional .autofill_assistant.InfoPopupProto.DialogButton neutral_button = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *neutral_button_);
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void InfoPopupProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const InfoPopupProto*>(
      &from));
}

void InfoPopupProto::MergeFrom(const InfoPopupProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.InfoPopupProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_title(from._internal_title());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_text(from._internal_text());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_positive_button()->::autofill_assistant::InfoPopupProto_DialogButton::MergeFrom(from._internal_positive_button());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_mutable_negative_button()->::autofill_assistant::InfoPopupProto_DialogButton::MergeFrom(from._internal_negative_button());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_mutable_neutral_button()->::autofill_assistant::InfoPopupProto_DialogButton::MergeFrom(from._internal_neutral_button());
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void InfoPopupProto::CopyFrom(const InfoPopupProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.InfoPopupProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool InfoPopupProto::IsInitialized() const {
  return true;
}

void InfoPopupProto::InternalSwap(InfoPopupProto* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &title_, lhs_arena,
      &other->title_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &text_, lhs_arena,
      &other->text_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(InfoPopupProto, neutral_button_)
      + sizeof(InfoPopupProto::neutral_button_)
      - PROTOBUF_FIELD_OFFSET(InfoPopupProto, positive_button_)>(
          reinterpret_cast<char*>(&positive_button_),
          reinterpret_cast<char*>(&other->positive_button_));
}

std::string InfoPopupProto::GetTypeName() const {
  return "autofill_assistant.InfoPopupProto";
}


// ===================================================================

class ToggleButtonViewProto_CheckBox::_Internal {
 public:
};

ToggleButtonViewProto_CheckBox::ToggleButtonViewProto_CheckBox(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.ToggleButtonViewProto.CheckBox)
}
ToggleButtonViewProto_CheckBox::ToggleButtonViewProto_CheckBox(const ToggleButtonViewProto_CheckBox& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.ToggleButtonViewProto.CheckBox)
}

inline void ToggleButtonViewProto_CheckBox::SharedCtor() {
}

ToggleButtonViewProto_CheckBox::~ToggleButtonViewProto_CheckBox() {
  // @@protoc_insertion_point(destructor:autofill_assistant.ToggleButtonViewProto.CheckBox)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ToggleButtonViewProto_CheckBox::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ToggleButtonViewProto_CheckBox::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ToggleButtonViewProto_CheckBox::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.ToggleButtonViewProto.CheckBox)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_metadata_.Clear<std::string>();
}

const char* ToggleButtonViewProto_CheckBox::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ToggleButtonViewProto_CheckBox::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.ToggleButtonViewProto.CheckBox)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.ToggleButtonViewProto.CheckBox)
  return target;
}

size_t ToggleButtonViewProto_CheckBox::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.ToggleButtonViewProto.CheckBox)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ToggleButtonViewProto_CheckBox::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ToggleButtonViewProto_CheckBox*>(
      &from));
}

void ToggleButtonViewProto_CheckBox::MergeFrom(const ToggleButtonViewProto_CheckBox& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.ToggleButtonViewProto.CheckBox)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ToggleButtonViewProto_CheckBox::CopyFrom(const ToggleButtonViewProto_CheckBox& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.ToggleButtonViewProto.CheckBox)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ToggleButtonViewProto_CheckBox::IsInitialized() const {
  return true;
}

void ToggleButtonViewProto_CheckBox::InternalSwap(ToggleButtonViewProto_CheckBox* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
}

std::string ToggleButtonViewProto_CheckBox::GetTypeName() const {
  return "autofill_assistant.ToggleButtonViewProto.CheckBox";
}


// ===================================================================

class ToggleButtonViewProto_RadioButton::_Internal {
 public:
  using HasBits = decltype(std::declval<ToggleButtonViewProto_RadioButton>()._has_bits_);
  static void set_has_radio_group_identifier(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

ToggleButtonViewProto_RadioButton::ToggleButtonViewProto_RadioButton(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.ToggleButtonViewProto.RadioButton)
}
ToggleButtonViewProto_RadioButton::ToggleButtonViewProto_RadioButton(const ToggleButtonViewProto_RadioButton& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  radio_group_identifier_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    radio_group_identifier_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_radio_group_identifier()) {
    radio_group_identifier_.Set(from._internal_radio_group_identifier(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.ToggleButtonViewProto.RadioButton)
}

inline void ToggleButtonViewProto_RadioButton::SharedCtor() {
radio_group_identifier_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  radio_group_identifier_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ToggleButtonViewProto_RadioButton::~ToggleButtonViewProto_RadioButton() {
  // @@protoc_insertion_point(destructor:autofill_assistant.ToggleButtonViewProto.RadioButton)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ToggleButtonViewProto_RadioButton::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  radio_group_identifier_.Destroy();
}

void ToggleButtonViewProto_RadioButton::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ToggleButtonViewProto_RadioButton::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.ToggleButtonViewProto.RadioButton)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    radio_group_identifier_.ClearNonDefaultToEmpty();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ToggleButtonViewProto_RadioButton::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string radio_group_identifier = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_radio_group_identifier();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ToggleButtonViewProto_RadioButton::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.ToggleButtonViewProto.RadioButton)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string radio_group_identifier = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_radio_group_identifier(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.ToggleButtonViewProto.RadioButton)
  return target;
}

size_t ToggleButtonViewProto_RadioButton::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.ToggleButtonViewProto.RadioButton)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string radio_group_identifier = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_radio_group_identifier());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ToggleButtonViewProto_RadioButton::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ToggleButtonViewProto_RadioButton*>(
      &from));
}

void ToggleButtonViewProto_RadioButton::MergeFrom(const ToggleButtonViewProto_RadioButton& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.ToggleButtonViewProto.RadioButton)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_radio_group_identifier()) {
    _internal_set_radio_group_identifier(from._internal_radio_group_identifier());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ToggleButtonViewProto_RadioButton::CopyFrom(const ToggleButtonViewProto_RadioButton& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.ToggleButtonViewProto.RadioButton)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ToggleButtonViewProto_RadioButton::IsInitialized() const {
  return true;
}

void ToggleButtonViewProto_RadioButton::InternalSwap(ToggleButtonViewProto_RadioButton* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &radio_group_identifier_, lhs_arena,
      &other->radio_group_identifier_, rhs_arena
  );
}

std::string ToggleButtonViewProto_RadioButton::GetTypeName() const {
  return "autofill_assistant.ToggleButtonViewProto.RadioButton";
}


// ===================================================================

class ToggleButtonViewProto::_Internal {
 public:
  using HasBits = decltype(std::declval<ToggleButtonViewProto>()._has_bits_);
  static const ::autofill_assistant::ToggleButtonViewProto_CheckBox& check_box(const ToggleButtonViewProto* msg);
  static const ::autofill_assistant::ToggleButtonViewProto_RadioButton& radio_button(const ToggleButtonViewProto* msg);
  static const ::autofill_assistant::ViewProto& left_content_view(const ToggleButtonViewProto* msg);
  static void set_has_left_content_view(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::autofill_assistant::ViewProto& right_content_view(const ToggleButtonViewProto* msg);
  static void set_has_right_content_view(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_model_identifier(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::autofill_assistant::ToggleButtonViewProto_CheckBox&
ToggleButtonViewProto::_Internal::check_box(const ToggleButtonViewProto* msg) {
  return *msg->kind_.check_box_;
}
const ::autofill_assistant::ToggleButtonViewProto_RadioButton&
ToggleButtonViewProto::_Internal::radio_button(const ToggleButtonViewProto* msg) {
  return *msg->kind_.radio_button_;
}
const ::autofill_assistant::ViewProto&
ToggleButtonViewProto::_Internal::left_content_view(const ToggleButtonViewProto* msg) {
  return *msg->left_content_view_;
}
const ::autofill_assistant::ViewProto&
ToggleButtonViewProto::_Internal::right_content_view(const ToggleButtonViewProto* msg) {
  return *msg->right_content_view_;
}
void ToggleButtonViewProto::set_allocated_check_box(::autofill_assistant::ToggleButtonViewProto_CheckBox* check_box) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_kind();
  if (check_box) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(check_box);
    if (message_arena != submessage_arena) {
      check_box = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, check_box, submessage_arena);
    }
    set_has_check_box();
    kind_.check_box_ = check_box;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ToggleButtonViewProto.check_box)
}
void ToggleButtonViewProto::set_allocated_radio_button(::autofill_assistant::ToggleButtonViewProto_RadioButton* radio_button) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_kind();
  if (radio_button) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(radio_button);
    if (message_arena != submessage_arena) {
      radio_button = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, radio_button, submessage_arena);
    }
    set_has_radio_button();
    kind_.radio_button_ = radio_button;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ToggleButtonViewProto.radio_button)
}
ToggleButtonViewProto::ToggleButtonViewProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.ToggleButtonViewProto)
}
ToggleButtonViewProto::ToggleButtonViewProto(const ToggleButtonViewProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  model_identifier_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    model_identifier_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_model_identifier()) {
    model_identifier_.Set(from._internal_model_identifier(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_left_content_view()) {
    left_content_view_ = new ::autofill_assistant::ViewProto(*from.left_content_view_);
  } else {
    left_content_view_ = nullptr;
  }
  if (from._internal_has_right_content_view()) {
    right_content_view_ = new ::autofill_assistant::ViewProto(*from.right_content_view_);
  } else {
    right_content_view_ = nullptr;
  }
  clear_has_kind();
  switch (from.kind_case()) {
    case kCheckBox: {
      _internal_mutable_check_box()->::autofill_assistant::ToggleButtonViewProto_CheckBox::MergeFrom(from._internal_check_box());
      break;
    }
    case kRadioButton: {
      _internal_mutable_radio_button()->::autofill_assistant::ToggleButtonViewProto_RadioButton::MergeFrom(from._internal_radio_button());
      break;
    }
    case KIND_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.ToggleButtonViewProto)
}

inline void ToggleButtonViewProto::SharedCtor() {
model_identifier_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  model_identifier_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&left_content_view_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&right_content_view_) -
    reinterpret_cast<char*>(&left_content_view_)) + sizeof(right_content_view_));
clear_has_kind();
}

ToggleButtonViewProto::~ToggleButtonViewProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.ToggleButtonViewProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ToggleButtonViewProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  model_identifier_.Destroy();
  if (this != internal_default_instance()) delete left_content_view_;
  if (this != internal_default_instance()) delete right_content_view_;
  if (has_kind()) {
    clear_kind();
  }
}

void ToggleButtonViewProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ToggleButtonViewProto::clear_kind() {
// @@protoc_insertion_point(one_of_clear_start:autofill_assistant.ToggleButtonViewProto)
  switch (kind_case()) {
    case kCheckBox: {
      if (GetArenaForAllocation() == nullptr) {
        delete kind_.check_box_;
      }
      break;
    }
    case kRadioButton: {
      if (GetArenaForAllocation() == nullptr) {
        delete kind_.radio_button_;
      }
      break;
    }
    case KIND_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = KIND_NOT_SET;
}


void ToggleButtonViewProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.ToggleButtonViewProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      model_identifier_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(left_content_view_ != nullptr);
      left_content_view_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(right_content_view_ != nullptr);
      right_content_view_->Clear();
    }
  }
  clear_kind();
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ToggleButtonViewProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .autofill_assistant.ToggleButtonViewProto.CheckBox check_box = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_check_box(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.ToggleButtonViewProto.RadioButton radio_button = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_radio_button(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .autofill_assistant.ViewProto left_content_view = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_left_content_view(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .autofill_assistant.ViewProto right_content_view = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_right_content_view(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string model_identifier = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_model_identifier();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ToggleButtonViewProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.ToggleButtonViewProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (kind_case()) {
    case kCheckBox: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, _Internal::check_box(this),
          _Internal::check_box(this).GetCachedSize(), target, stream);
      break;
    }
    case kRadioButton: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, _Internal::radio_button(this),
          _Internal::radio_button(this).GetCachedSize(), target, stream);
      break;
    }
    default: ;
  }
  cached_has_bits = _has_bits_[0];
  // optional .autofill_assistant.ViewProto left_content_view = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::left_content_view(this),
        _Internal::left_content_view(this).GetCachedSize(), target, stream);
  }

  // optional .autofill_assistant.ViewProto right_content_view = 4;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::right_content_view(this),
        _Internal::right_content_view(this).GetCachedSize(), target, stream);
  }

  // optional string model_identifier = 5;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_model_identifier(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.ToggleButtonViewProto)
  return target;
}

size_t ToggleButtonViewProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.ToggleButtonViewProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string model_identifier = 5;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_model_identifier());
    }

    // optional .autofill_assistant.ViewProto left_content_view = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *left_content_view_);
    }

    // optional .autofill_assistant.ViewProto right_content_view = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *right_content_view_);
    }

  }
  switch (kind_case()) {
    // .autofill_assistant.ToggleButtonViewProto.CheckBox check_box = 1;
    case kCheckBox: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *kind_.check_box_);
      break;
    }
    // .autofill_assistant.ToggleButtonViewProto.RadioButton radio_button = 2;
    case kRadioButton: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *kind_.radio_button_);
      break;
    }
    case KIND_NOT_SET: {
      break;
    }
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ToggleButtonViewProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ToggleButtonViewProto*>(
      &from));
}

void ToggleButtonViewProto::MergeFrom(const ToggleButtonViewProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.ToggleButtonViewProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_model_identifier(from._internal_model_identifier());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_left_content_view()->::autofill_assistant::ViewProto::MergeFrom(from._internal_left_content_view());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_right_content_view()->::autofill_assistant::ViewProto::MergeFrom(from._internal_right_content_view());
    }
  }
  switch (from.kind_case()) {
    case kCheckBox: {
      _internal_mutable_check_box()->::autofill_assistant::ToggleButtonViewProto_CheckBox::MergeFrom(from._internal_check_box());
      break;
    }
    case kRadioButton: {
      _internal_mutable_radio_button()->::autofill_assistant::ToggleButtonViewProto_RadioButton::MergeFrom(from._internal_radio_button());
      break;
    }
    case KIND_NOT_SET: {
      break;
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ToggleButtonViewProto::CopyFrom(const ToggleButtonViewProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.ToggleButtonViewProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ToggleButtonViewProto::IsInitialized() const {
  return true;
}

void ToggleButtonViewProto::InternalSwap(ToggleButtonViewProto* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &model_identifier_, lhs_arena,
      &other->model_identifier_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ToggleButtonViewProto, right_content_view_)
      + sizeof(ToggleButtonViewProto::right_content_view_)
      - PROTOBUF_FIELD_OFFSET(ToggleButtonViewProto, left_content_view_)>(
          reinterpret_cast<char*>(&left_content_view_),
          reinterpret_cast<char*>(&other->left_content_view_));
  swap(kind_, other->kind_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

std::string ToggleButtonViewProto::GetTypeName() const {
  return "autofill_assistant.ToggleButtonViewProto";
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace autofill_assistant
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::autofill_assistant::ViewProto*
Arena::CreateMaybeMessage< ::autofill_assistant::ViewProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::ViewProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::ColorProto*
Arena::CreateMaybeMessage< ::autofill_assistant::ColorProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::ColorProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::ClientDimensionProto*
Arena::CreateMaybeMessage< ::autofill_assistant::ClientDimensionProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::ClientDimensionProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::ShapeDrawableProto_Rectangle*
Arena::CreateMaybeMessage< ::autofill_assistant::ShapeDrawableProto_Rectangle >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::ShapeDrawableProto_Rectangle >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::ShapeDrawableProto*
Arena::CreateMaybeMessage< ::autofill_assistant::ShapeDrawableProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::ShapeDrawableProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::ConfigBasedUrlProto_UrlEntry_DoNotUse*
Arena::CreateMaybeMessage< ::autofill_assistant::ConfigBasedUrlProto_UrlEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::ConfigBasedUrlProto_UrlEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::ConfigBasedUrlProto*
Arena::CreateMaybeMessage< ::autofill_assistant::ConfigBasedUrlProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::ConfigBasedUrlProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::BitmapDrawableProto*
Arena::CreateMaybeMessage< ::autofill_assistant::BitmapDrawableProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::BitmapDrawableProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::FaviconDrawableProto*
Arena::CreateMaybeMessage< ::autofill_assistant::FaviconDrawableProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::FaviconDrawableProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::DrawableProto*
Arena::CreateMaybeMessage< ::autofill_assistant::DrawableProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::DrawableProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::ViewAttributesProto*
Arena::CreateMaybeMessage< ::autofill_assistant::ViewAttributesProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::ViewAttributesProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::ViewLayoutParamsProto*
Arena::CreateMaybeMessage< ::autofill_assistant::ViewLayoutParamsProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::ViewLayoutParamsProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::ViewContainerProto*
Arena::CreateMaybeMessage< ::autofill_assistant::ViewContainerProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::ViewContainerProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::LinearLayoutProto*
Arena::CreateMaybeMessage< ::autofill_assistant::LinearLayoutProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::LinearLayoutProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::VerticalExpanderViewProto*
Arena::CreateMaybeMessage< ::autofill_assistant::VerticalExpanderViewProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::VerticalExpanderViewProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::VerticalExpanderAccordionProto*
Arena::CreateMaybeMessage< ::autofill_assistant::VerticalExpanderAccordionProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::VerticalExpanderAccordionProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::TextViewProto*
Arena::CreateMaybeMessage< ::autofill_assistant::TextViewProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::TextViewProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::DividerViewProto*
Arena::CreateMaybeMessage< ::autofill_assistant::DividerViewProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::DividerViewProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::ImageViewProto*
Arena::CreateMaybeMessage< ::autofill_assistant::ImageViewProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::ImageViewProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::TextInputViewProto*
Arena::CreateMaybeMessage< ::autofill_assistant::TextInputViewProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::TextInputViewProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::InfoPopupProto_DialogButton_CloseDialog*
Arena::CreateMaybeMessage< ::autofill_assistant::InfoPopupProto_DialogButton_CloseDialog >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::InfoPopupProto_DialogButton_CloseDialog >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::InfoPopupProto_DialogButton_OpenUrlInCCT*
Arena::CreateMaybeMessage< ::autofill_assistant::InfoPopupProto_DialogButton_OpenUrlInCCT >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::InfoPopupProto_DialogButton_OpenUrlInCCT >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::InfoPopupProto_DialogButton*
Arena::CreateMaybeMessage< ::autofill_assistant::InfoPopupProto_DialogButton >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::InfoPopupProto_DialogButton >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::InfoPopupProto*
Arena::CreateMaybeMessage< ::autofill_assistant::InfoPopupProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::InfoPopupProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::ToggleButtonViewProto_CheckBox*
Arena::CreateMaybeMessage< ::autofill_assistant::ToggleButtonViewProto_CheckBox >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::ToggleButtonViewProto_CheckBox >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::ToggleButtonViewProto_RadioButton*
Arena::CreateMaybeMessage< ::autofill_assistant::ToggleButtonViewProto_RadioButton >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::ToggleButtonViewProto_RadioButton >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::ToggleButtonViewProto*
Arena::CreateMaybeMessage< ::autofill_assistant::ToggleButtonViewProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::ToggleButtonViewProto >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
