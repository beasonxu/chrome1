// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: components/autofill_assistant/browser/generic_ui.proto

#include "components/autofill_assistant/browser/generic_ui.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace autofill_assistant {
PROTOBUF_CONSTEXPR GenericUserInterfaceProto::GenericUserInterfaceProto(
    ::_pbi::ConstantInitialized)
  : root_view_(nullptr)
  , interactions_(nullptr)
  , model_(nullptr){}
struct GenericUserInterfaceProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GenericUserInterfaceProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GenericUserInterfaceProtoDefaultTypeInternal() {}
  union {
    GenericUserInterfaceProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GenericUserInterfaceProtoDefaultTypeInternal _GenericUserInterfaceProto_default_instance_;
PROTOBUF_CONSTEXPR InteractionsProto::InteractionsProto(
    ::_pbi::ConstantInitialized)
  : interactions_(){}
struct InteractionsProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR InteractionsProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~InteractionsProtoDefaultTypeInternal() {}
  union {
    InteractionsProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 InteractionsProtoDefaultTypeInternal _InteractionsProto_default_instance_;
PROTOBUF_CONSTEXPR InteractionProto::InteractionProto(
    ::_pbi::ConstantInitialized)
  : callbacks_()
  , trigger_event_(){}
struct InteractionProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR InteractionProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~InteractionProtoDefaultTypeInternal() {}
  union {
    InteractionProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 InteractionProtoDefaultTypeInternal _InteractionProto_default_instance_;
PROTOBUF_CONSTEXPR CallbackProto::CallbackProto(
    ::_pbi::ConstantInitialized)
  : condition_model_identifier_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , _oneof_case_{}{}
struct CallbackProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CallbackProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CallbackProtoDefaultTypeInternal() {}
  union {
    CallbackProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CallbackProtoDefaultTypeInternal _CallbackProto_default_instance_;
PROTOBUF_CONSTEXPR EventProto::EventProto(
    ::_pbi::ConstantInitialized)
  : _oneof_case_{}{}
struct EventProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EventProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~EventProtoDefaultTypeInternal() {}
  union {
    EventProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EventProtoDefaultTypeInternal _EventProto_default_instance_;
PROTOBUF_CONSTEXPR OnModelValueChangedEventProto::OnModelValueChangedEventProto(
    ::_pbi::ConstantInitialized)
  : model_identifier_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}){}
struct OnModelValueChangedEventProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR OnModelValueChangedEventProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~OnModelValueChangedEventProtoDefaultTypeInternal() {}
  union {
    OnModelValueChangedEventProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 OnModelValueChangedEventProtoDefaultTypeInternal _OnModelValueChangedEventProto_default_instance_;
PROTOBUF_CONSTEXPR OnViewClickedEventProto::OnViewClickedEventProto(
    ::_pbi::ConstantInitialized)
  : view_identifier_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}){}
struct OnViewClickedEventProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR OnViewClickedEventProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~OnViewClickedEventProtoDefaultTypeInternal() {}
  union {
    OnViewClickedEventProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 OnViewClickedEventProtoDefaultTypeInternal _OnViewClickedEventProto_default_instance_;
PROTOBUF_CONSTEXPR OnUserActionCalled::OnUserActionCalled(
    ::_pbi::ConstantInitialized)
  : user_action_identifier_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}){}
struct OnUserActionCalledDefaultTypeInternal {
  PROTOBUF_CONSTEXPR OnUserActionCalledDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~OnUserActionCalledDefaultTypeInternal() {}
  union {
    OnUserActionCalled _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 OnUserActionCalledDefaultTypeInternal _OnUserActionCalled_default_instance_;
PROTOBUF_CONSTEXPR OnTextLinkClickedProto::OnTextLinkClickedProto(
    ::_pbi::ConstantInitialized)
  : text_link_(0){}
struct OnTextLinkClickedProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR OnTextLinkClickedProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~OnTextLinkClickedProtoDefaultTypeInternal() {}
  union {
    OnTextLinkClickedProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 OnTextLinkClickedProtoDefaultTypeInternal _OnTextLinkClickedProto_default_instance_;
PROTOBUF_CONSTEXPR OnPopupDismissedProto::OnPopupDismissedProto(
    ::_pbi::ConstantInitialized)
  : popup_identifier_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}){}
struct OnPopupDismissedProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR OnPopupDismissedProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~OnPopupDismissedProtoDefaultTypeInternal() {}
  union {
    OnPopupDismissedProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 OnPopupDismissedProtoDefaultTypeInternal _OnPopupDismissedProto_default_instance_;
PROTOBUF_CONSTEXPR OnViewContainerClearedProto::OnViewContainerClearedProto(
    ::_pbi::ConstantInitialized)
  : view_identifier_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}){}
struct OnViewContainerClearedProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR OnViewContainerClearedProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~OnViewContainerClearedProtoDefaultTypeInternal() {}
  union {
    OnViewContainerClearedProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 OnViewContainerClearedProtoDefaultTypeInternal _OnViewContainerClearedProto_default_instance_;
PROTOBUF_CONSTEXPR SetModelValueProto::SetModelValueProto(
    ::_pbi::ConstantInitialized)
  : model_identifier_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , value_(nullptr){}
struct SetModelValueProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SetModelValueProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SetModelValueProtoDefaultTypeInternal() {}
  union {
    SetModelValueProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SetModelValueProtoDefaultTypeInternal _SetModelValueProto_default_instance_;
PROTOBUF_CONSTEXPR ComputeValueProto::ComputeValueProto(
    ::_pbi::ConstantInitialized)
  : result_model_identifier_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , _oneof_case_{}{}
struct ComputeValueProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ComputeValueProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ComputeValueProtoDefaultTypeInternal() {}
  union {
    ComputeValueProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ComputeValueProtoDefaultTypeInternal _ComputeValueProto_default_instance_;
PROTOBUF_CONSTEXPR BooleanAndProto::BooleanAndProto(
    ::_pbi::ConstantInitialized)
  : values_(){}
struct BooleanAndProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BooleanAndProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~BooleanAndProtoDefaultTypeInternal() {}
  union {
    BooleanAndProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BooleanAndProtoDefaultTypeInternal _BooleanAndProto_default_instance_;
PROTOBUF_CONSTEXPR BooleanOrProto::BooleanOrProto(
    ::_pbi::ConstantInitialized)
  : values_(){}
struct BooleanOrProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BooleanOrProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~BooleanOrProtoDefaultTypeInternal() {}
  union {
    BooleanOrProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BooleanOrProtoDefaultTypeInternal _BooleanOrProto_default_instance_;
PROTOBUF_CONSTEXPR BooleanNotProto::BooleanNotProto(
    ::_pbi::ConstantInitialized)
  : value_(nullptr){}
struct BooleanNotProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BooleanNotProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~BooleanNotProtoDefaultTypeInternal() {}
  union {
    BooleanNotProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BooleanNotProtoDefaultTypeInternal _BooleanNotProto_default_instance_;
PROTOBUF_CONSTEXPR ToStringProto::ToStringProto(
    ::_pbi::ConstantInitialized)
  : value_(nullptr)
  , _oneof_case_{}{}
struct ToStringProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ToStringProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ToStringProtoDefaultTypeInternal() {}
  union {
    ToStringProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ToStringProtoDefaultTypeInternal _ToStringProto_default_instance_;
PROTOBUF_CONSTEXPR DateFormatProto::DateFormatProto(
    ::_pbi::ConstantInitialized)
  : date_format_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}){}
struct DateFormatProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DateFormatProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DateFormatProtoDefaultTypeInternal() {}
  union {
    DateFormatProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DateFormatProtoDefaultTypeInternal _DateFormatProto_default_instance_;
PROTOBUF_CONSTEXPR AutofillFormatProto::AutofillFormatProto(
    ::_pbi::ConstantInitialized)
  : locale_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , value_expression_(nullptr){}
struct AutofillFormatProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AutofillFormatProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AutofillFormatProtoDefaultTypeInternal() {}
  union {
    AutofillFormatProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AutofillFormatProtoDefaultTypeInternal _AutofillFormatProto_default_instance_;
PROTOBUF_CONSTEXPR ValueComparisonProto::ValueComparisonProto(
    ::_pbi::ConstantInitialized)
  : value_a_(nullptr)
  , value_b_(nullptr)
  , mode_(0)
{}
struct ValueComparisonProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ValueComparisonProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ValueComparisonProtoDefaultTypeInternal() {}
  union {
    ValueComparisonProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ValueComparisonProtoDefaultTypeInternal _ValueComparisonProto_default_instance_;
PROTOBUF_CONSTEXPR IntegerSumProto::IntegerSumProto(
    ::_pbi::ConstantInitialized)
  : values_(){}
struct IntegerSumProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR IntegerSumProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~IntegerSumProtoDefaultTypeInternal() {}
  union {
    IntegerSumProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 IntegerSumProtoDefaultTypeInternal _IntegerSumProto_default_instance_;
PROTOBUF_CONSTEXPR CreateCreditCardResponseProto::CreateCreditCardResponseProto(
    ::_pbi::ConstantInitialized)
  : value_(nullptr){}
struct CreateCreditCardResponseProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CreateCreditCardResponseProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CreateCreditCardResponseProtoDefaultTypeInternal() {}
  union {
    CreateCreditCardResponseProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CreateCreditCardResponseProtoDefaultTypeInternal _CreateCreditCardResponseProto_default_instance_;
PROTOBUF_CONSTEXPR CreateLoginOptionResponseProto::CreateLoginOptionResponseProto(
    ::_pbi::ConstantInitialized)
  : value_(nullptr){}
struct CreateLoginOptionResponseProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CreateLoginOptionResponseProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CreateLoginOptionResponseProtoDefaultTypeInternal() {}
  union {
    CreateLoginOptionResponseProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CreateLoginOptionResponseProtoDefaultTypeInternal _CreateLoginOptionResponseProto_default_instance_;
PROTOBUF_CONSTEXPR StringEmptyProto::StringEmptyProto(
    ::_pbi::ConstantInitialized)
  : value_(nullptr){}
struct StringEmptyProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StringEmptyProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~StringEmptyProtoDefaultTypeInternal() {}
  union {
    StringEmptyProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StringEmptyProtoDefaultTypeInternal _StringEmptyProto_default_instance_;
PROTOBUF_CONSTEXPR ShowInfoPopupProto::ShowInfoPopupProto(
    ::_pbi::ConstantInitialized)
  : info_popup_(nullptr){}
struct ShowInfoPopupProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ShowInfoPopupProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ShowInfoPopupProtoDefaultTypeInternal() {}
  union {
    ShowInfoPopupProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ShowInfoPopupProtoDefaultTypeInternal _ShowInfoPopupProto_default_instance_;
PROTOBUF_CONSTEXPR ShowListPopupProto::ShowListPopupProto(
    ::_pbi::ConstantInitialized)
  : selected_item_indices_model_identifier_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , selected_item_names_model_identifier_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , item_names_(nullptr)
  , item_types_(nullptr)
  , allow_multiselect_(false){}
struct ShowListPopupProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ShowListPopupProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ShowListPopupProtoDefaultTypeInternal() {}
  union {
    ShowListPopupProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ShowListPopupProtoDefaultTypeInternal _ShowListPopupProto_default_instance_;
PROTOBUF_CONSTEXPR SetUserActionsProto::SetUserActionsProto(
    ::_pbi::ConstantInitialized)
  : user_actions_(nullptr){}
struct SetUserActionsProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SetUserActionsProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SetUserActionsProtoDefaultTypeInternal() {}
  union {
    SetUserActionsProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SetUserActionsProtoDefaultTypeInternal _SetUserActionsProto_default_instance_;
PROTOBUF_CONSTEXPR ToggleUserActionProto::ToggleUserActionProto(
    ::_pbi::ConstantInitialized)
  : user_actions_model_identifier_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , user_action_identifier_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , enabled_(nullptr){}
struct ToggleUserActionProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ToggleUserActionProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ToggleUserActionProtoDefaultTypeInternal() {}
  union {
    ToggleUserActionProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ToggleUserActionProtoDefaultTypeInternal _ToggleUserActionProto_default_instance_;
PROTOBUF_CONSTEXPR EndActionProto::EndActionProto(
    ::_pbi::ConstantInitialized)
  : status_(0)
{}
struct EndActionProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EndActionProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~EndActionProtoDefaultTypeInternal() {}
  union {
    EndActionProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EndActionProtoDefaultTypeInternal _EndActionProto_default_instance_;
PROTOBUF_CONSTEXPR ShowCalendarPopupProto::ShowCalendarPopupProto(
    ::_pbi::ConstantInitialized)
  : date_model_identifier_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , min_date_(nullptr)
  , max_date_(nullptr){}
struct ShowCalendarPopupProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ShowCalendarPopupProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ShowCalendarPopupProtoDefaultTypeInternal() {}
  union {
    ShowCalendarPopupProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ShowCalendarPopupProtoDefaultTypeInternal _ShowCalendarPopupProto_default_instance_;
PROTOBUF_CONSTEXPR SetTextProto::SetTextProto(
    ::_pbi::ConstantInitialized)
  : view_identifier_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , text_(nullptr){}
struct SetTextProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SetTextProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SetTextProtoDefaultTypeInternal() {}
  union {
    SetTextProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SetTextProtoDefaultTypeInternal _SetTextProto_default_instance_;
PROTOBUF_CONSTEXPR SetViewVisibilityProto::SetViewVisibilityProto(
    ::_pbi::ConstantInitialized)
  : view_identifier_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , visible_(nullptr){}
struct SetViewVisibilityProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SetViewVisibilityProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SetViewVisibilityProtoDefaultTypeInternal() {}
  union {
    SetViewVisibilityProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SetViewVisibilityProtoDefaultTypeInternal _SetViewVisibilityProto_default_instance_;
PROTOBUF_CONSTEXPR ShowGenericUiPopupProto::ShowGenericUiPopupProto(
    ::_pbi::ConstantInitialized)
  : popup_identifier_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , generic_ui_(nullptr){}
struct ShowGenericUiPopupProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ShowGenericUiPopupProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ShowGenericUiPopupProtoDefaultTypeInternal() {}
  union {
    ShowGenericUiPopupProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ShowGenericUiPopupProtoDefaultTypeInternal _ShowGenericUiPopupProto_default_instance_;
PROTOBUF_CONSTEXPR SetViewEnabledProto::SetViewEnabledProto(
    ::_pbi::ConstantInitialized)
  : view_identifier_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , enabled_(nullptr){}
struct SetViewEnabledProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SetViewEnabledProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SetViewEnabledProtoDefaultTypeInternal() {}
  union {
    SetViewEnabledProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SetViewEnabledProtoDefaultTypeInternal _SetViewEnabledProto_default_instance_;
PROTOBUF_CONSTEXPR CreateNestedGenericUiProto::CreateNestedGenericUiProto(
    ::_pbi::ConstantInitialized)
  : generic_ui_identifier_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , parent_view_identifier_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , generic_ui_(nullptr){}
struct CreateNestedGenericUiProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CreateNestedGenericUiProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CreateNestedGenericUiProtoDefaultTypeInternal() {}
  union {
    CreateNestedGenericUiProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CreateNestedGenericUiProtoDefaultTypeInternal _CreateNestedGenericUiProto_default_instance_;
PROTOBUF_CONSTEXPR ClearViewContainerProto::ClearViewContainerProto(
    ::_pbi::ConstantInitialized)
  : view_identifier_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}){}
struct ClearViewContainerProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ClearViewContainerProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ClearViewContainerProtoDefaultTypeInternal() {}
  union {
    ClearViewContainerProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClearViewContainerProtoDefaultTypeInternal _ClearViewContainerProto_default_instance_;
PROTOBUF_CONSTEXPR ForEachProto::ForEachProto(
    ::_pbi::ConstantInitialized)
  : callbacks_()
  , loop_counter_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , loop_value_model_identifier_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}){}
struct ForEachProtoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ForEachProtoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ForEachProtoDefaultTypeInternal() {}
  union {
    ForEachProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ForEachProtoDefaultTypeInternal _ForEachProto_default_instance_;
}  // namespace autofill_assistant
namespace autofill_assistant {
bool AutofillFormatProto_AutofillAssistantCustomField_IsValid(int value) {
  switch (value) {
    case -8:
    case -7:
    case -6:
    case -5:
    case -4:
    case -3:
    case -2:
    case -1:
    case 0:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> AutofillFormatProto_AutofillAssistantCustomField_strings[9] = {};

static const char AutofillFormatProto_AutofillAssistantCustomField_names[] =
  "ADDRESS_HOME_COUNTRY_CODE"
  "ADDRESS_HOME_STATE_NAME"
  "CREDIT_CARD_NETWORK"
  "CREDIT_CARD_NETWORK_FOR_DISPLAY"
  "CREDIT_CARD_NON_PADDED_EXP_MONTH"
  "CREDIT_CARD_NUMBER_LAST_FOUR_DIGITS"
  "CREDIT_CARD_RAW_NUMBER"
  "CREDIT_CARD_VERIFICATION_CODE"
  "UNDEFINED";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry AutofillFormatProto_AutofillAssistantCustomField_entries[] = {
  { {AutofillFormatProto_AutofillAssistantCustomField_names + 0, 25}, -8 },
  { {AutofillFormatProto_AutofillAssistantCustomField_names + 25, 23}, -6 },
  { {AutofillFormatProto_AutofillAssistantCustomField_names + 48, 19}, -2 },
  { {AutofillFormatProto_AutofillAssistantCustomField_names + 67, 31}, -5 },
  { {AutofillFormatProto_AutofillAssistantCustomField_names + 98, 32}, -7 },
  { {AutofillFormatProto_AutofillAssistantCustomField_names + 130, 35}, -4 },
  { {AutofillFormatProto_AutofillAssistantCustomField_names + 165, 22}, -3 },
  { {AutofillFormatProto_AutofillAssistantCustomField_names + 187, 29}, -1 },
  { {AutofillFormatProto_AutofillAssistantCustomField_names + 216, 9}, 0 },
};

static const int AutofillFormatProto_AutofillAssistantCustomField_entries_by_number[] = {
  0, // -8 -> ADDRESS_HOME_COUNTRY_CODE
  4, // -7 -> CREDIT_CARD_NON_PADDED_EXP_MONTH
  1, // -6 -> ADDRESS_HOME_STATE_NAME
  3, // -5 -> CREDIT_CARD_NETWORK_FOR_DISPLAY
  5, // -4 -> CREDIT_CARD_NUMBER_LAST_FOUR_DIGITS
  6, // -3 -> CREDIT_CARD_RAW_NUMBER
  2, // -2 -> CREDIT_CARD_NETWORK
  7, // -1 -> CREDIT_CARD_VERIFICATION_CODE
  8, // 0 -> UNDEFINED
};

const std::string& AutofillFormatProto_AutofillAssistantCustomField_Name(
    AutofillFormatProto_AutofillAssistantCustomField value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          AutofillFormatProto_AutofillAssistantCustomField_entries,
          AutofillFormatProto_AutofillAssistantCustomField_entries_by_number,
          9, AutofillFormatProto_AutofillAssistantCustomField_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      AutofillFormatProto_AutofillAssistantCustomField_entries,
      AutofillFormatProto_AutofillAssistantCustomField_entries_by_number,
      9, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     AutofillFormatProto_AutofillAssistantCustomField_strings[idx].get();
}
bool AutofillFormatProto_AutofillAssistantCustomField_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AutofillFormatProto_AutofillAssistantCustomField* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      AutofillFormatProto_AutofillAssistantCustomField_entries, 9, name, &int_value);
  if (success) {
    *value = static_cast<AutofillFormatProto_AutofillAssistantCustomField>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr AutofillFormatProto_AutofillAssistantCustomField AutofillFormatProto::UNDEFINED;
constexpr AutofillFormatProto_AutofillAssistantCustomField AutofillFormatProto::CREDIT_CARD_VERIFICATION_CODE;
constexpr AutofillFormatProto_AutofillAssistantCustomField AutofillFormatProto::CREDIT_CARD_NETWORK;
constexpr AutofillFormatProto_AutofillAssistantCustomField AutofillFormatProto::CREDIT_CARD_RAW_NUMBER;
constexpr AutofillFormatProto_AutofillAssistantCustomField AutofillFormatProto::CREDIT_CARD_NUMBER_LAST_FOUR_DIGITS;
constexpr AutofillFormatProto_AutofillAssistantCustomField AutofillFormatProto::CREDIT_CARD_NETWORK_FOR_DISPLAY;
constexpr AutofillFormatProto_AutofillAssistantCustomField AutofillFormatProto::ADDRESS_HOME_STATE_NAME;
constexpr AutofillFormatProto_AutofillAssistantCustomField AutofillFormatProto::CREDIT_CARD_NON_PADDED_EXP_MONTH;
constexpr AutofillFormatProto_AutofillAssistantCustomField AutofillFormatProto::ADDRESS_HOME_COUNTRY_CODE;
constexpr AutofillFormatProto_AutofillAssistantCustomField AutofillFormatProto::AutofillAssistantCustomField_MIN;
constexpr AutofillFormatProto_AutofillAssistantCustomField AutofillFormatProto::AutofillAssistantCustomField_MAX;
constexpr int AutofillFormatProto::AutofillAssistantCustomField_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool ValueComparisonProto_Mode_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ValueComparisonProto_Mode_strings[7] = {};

static const char ValueComparisonProto_Mode_names[] =
  "EQUAL"
  "GREATER"
  "GREATER_OR_EQUAL"
  "LESS"
  "LESS_OR_EQUAL"
  "NOT_EQUAL"
  "UNDEFINED";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ValueComparisonProto_Mode_entries[] = {
  { {ValueComparisonProto_Mode_names + 0, 5}, 3 },
  { {ValueComparisonProto_Mode_names + 5, 7}, 5 },
  { {ValueComparisonProto_Mode_names + 12, 16}, 4 },
  { {ValueComparisonProto_Mode_names + 28, 4}, 1 },
  { {ValueComparisonProto_Mode_names + 32, 13}, 2 },
  { {ValueComparisonProto_Mode_names + 45, 9}, 6 },
  { {ValueComparisonProto_Mode_names + 54, 9}, 0 },
};

static const int ValueComparisonProto_Mode_entries_by_number[] = {
  6, // 0 -> UNDEFINED
  3, // 1 -> LESS
  4, // 2 -> LESS_OR_EQUAL
  0, // 3 -> EQUAL
  2, // 4 -> GREATER_OR_EQUAL
  1, // 5 -> GREATER
  5, // 6 -> NOT_EQUAL
};

const std::string& ValueComparisonProto_Mode_Name(
    ValueComparisonProto_Mode value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ValueComparisonProto_Mode_entries,
          ValueComparisonProto_Mode_entries_by_number,
          7, ValueComparisonProto_Mode_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ValueComparisonProto_Mode_entries,
      ValueComparisonProto_Mode_entries_by_number,
      7, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ValueComparisonProto_Mode_strings[idx].get();
}
bool ValueComparisonProto_Mode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ValueComparisonProto_Mode* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ValueComparisonProto_Mode_entries, 7, name, &int_value);
  if (success) {
    *value = static_cast<ValueComparisonProto_Mode>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ValueComparisonProto_Mode ValueComparisonProto::UNDEFINED;
constexpr ValueComparisonProto_Mode ValueComparisonProto::LESS;
constexpr ValueComparisonProto_Mode ValueComparisonProto::LESS_OR_EQUAL;
constexpr ValueComparisonProto_Mode ValueComparisonProto::EQUAL;
constexpr ValueComparisonProto_Mode ValueComparisonProto::GREATER_OR_EQUAL;
constexpr ValueComparisonProto_Mode ValueComparisonProto::GREATER;
constexpr ValueComparisonProto_Mode ValueComparisonProto::NOT_EQUAL;
constexpr ValueComparisonProto_Mode ValueComparisonProto::Mode_MIN;
constexpr ValueComparisonProto_Mode ValueComparisonProto::Mode_MAX;
constexpr int ValueComparisonProto::Mode_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool ShowListPopupProto_ItemType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ShowListPopupProto_ItemType_strings[3] = {};

static const char ShowListPopupProto_ItemType_names[] =
  "DISABLED"
  "ENABLED"
  "GROUP";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ShowListPopupProto_ItemType_entries[] = {
  { {ShowListPopupProto_ItemType_names + 0, 8}, 1 },
  { {ShowListPopupProto_ItemType_names + 8, 7}, 2 },
  { {ShowListPopupProto_ItemType_names + 15, 5}, 0 },
};

static const int ShowListPopupProto_ItemType_entries_by_number[] = {
  2, // 0 -> GROUP
  0, // 1 -> DISABLED
  1, // 2 -> ENABLED
};

const std::string& ShowListPopupProto_ItemType_Name(
    ShowListPopupProto_ItemType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ShowListPopupProto_ItemType_entries,
          ShowListPopupProto_ItemType_entries_by_number,
          3, ShowListPopupProto_ItemType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ShowListPopupProto_ItemType_entries,
      ShowListPopupProto_ItemType_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ShowListPopupProto_ItemType_strings[idx].get();
}
bool ShowListPopupProto_ItemType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ShowListPopupProto_ItemType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ShowListPopupProto_ItemType_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<ShowListPopupProto_ItemType>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ShowListPopupProto_ItemType ShowListPopupProto::GROUP;
constexpr ShowListPopupProto_ItemType ShowListPopupProto::DISABLED;
constexpr ShowListPopupProto_ItemType ShowListPopupProto::ENABLED;
constexpr ShowListPopupProto_ItemType ShowListPopupProto::ItemType_MIN;
constexpr ShowListPopupProto_ItemType ShowListPopupProto::ItemType_MAX;
constexpr int ShowListPopupProto::ItemType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

// ===================================================================

class GenericUserInterfaceProto::_Internal {
 public:
  using HasBits = decltype(std::declval<GenericUserInterfaceProto>()._has_bits_);
  static const ::autofill_assistant::ViewProto& root_view(const GenericUserInterfaceProto* msg);
  static void set_has_root_view(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::autofill_assistant::InteractionsProto& interactions(const GenericUserInterfaceProto* msg);
  static void set_has_interactions(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::autofill_assistant::ModelProto& model(const GenericUserInterfaceProto* msg);
  static void set_has_model(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::autofill_assistant::ViewProto&
GenericUserInterfaceProto::_Internal::root_view(const GenericUserInterfaceProto* msg) {
  return *msg->root_view_;
}
const ::autofill_assistant::InteractionsProto&
GenericUserInterfaceProto::_Internal::interactions(const GenericUserInterfaceProto* msg) {
  return *msg->interactions_;
}
const ::autofill_assistant::ModelProto&
GenericUserInterfaceProto::_Internal::model(const GenericUserInterfaceProto* msg) {
  return *msg->model_;
}
void GenericUserInterfaceProto::clear_root_view() {
  if (root_view_ != nullptr) root_view_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
void GenericUserInterfaceProto::clear_model() {
  if (model_ != nullptr) model_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
GenericUserInterfaceProto::GenericUserInterfaceProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.GenericUserInterfaceProto)
}
GenericUserInterfaceProto::GenericUserInterfaceProto(const GenericUserInterfaceProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_root_view()) {
    root_view_ = new ::autofill_assistant::ViewProto(*from.root_view_);
  } else {
    root_view_ = nullptr;
  }
  if (from._internal_has_interactions()) {
    interactions_ = new ::autofill_assistant::InteractionsProto(*from.interactions_);
  } else {
    interactions_ = nullptr;
  }
  if (from._internal_has_model()) {
    model_ = new ::autofill_assistant::ModelProto(*from.model_);
  } else {
    model_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.GenericUserInterfaceProto)
}

inline void GenericUserInterfaceProto::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&root_view_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&model_) -
    reinterpret_cast<char*>(&root_view_)) + sizeof(model_));
}

GenericUserInterfaceProto::~GenericUserInterfaceProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.GenericUserInterfaceProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GenericUserInterfaceProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete root_view_;
  if (this != internal_default_instance()) delete interactions_;
  if (this != internal_default_instance()) delete model_;
}

void GenericUserInterfaceProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void GenericUserInterfaceProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.GenericUserInterfaceProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(root_view_ != nullptr);
      root_view_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(interactions_ != nullptr);
      interactions_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(model_ != nullptr);
      model_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* GenericUserInterfaceProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .autofill_assistant.ViewProto root_view = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_root_view(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .autofill_assistant.InteractionsProto interactions = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_interactions(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .autofill_assistant.ModelProto model = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_model(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GenericUserInterfaceProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.GenericUserInterfaceProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .autofill_assistant.ViewProto root_view = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::root_view(this),
        _Internal::root_view(this).GetCachedSize(), target, stream);
  }

  // optional .autofill_assistant.InteractionsProto interactions = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::interactions(this),
        _Internal::interactions(this).GetCachedSize(), target, stream);
  }

  // optional .autofill_assistant.ModelProto model = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::model(this),
        _Internal::model(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.GenericUserInterfaceProto)
  return target;
}

size_t GenericUserInterfaceProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.GenericUserInterfaceProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .autofill_assistant.ViewProto root_view = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *root_view_);
    }

    // optional .autofill_assistant.InteractionsProto interactions = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *interactions_);
    }

    // optional .autofill_assistant.ModelProto model = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *model_);
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void GenericUserInterfaceProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const GenericUserInterfaceProto*>(
      &from));
}

void GenericUserInterfaceProto::MergeFrom(const GenericUserInterfaceProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.GenericUserInterfaceProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_root_view()->::autofill_assistant::ViewProto::MergeFrom(from._internal_root_view());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_interactions()->::autofill_assistant::InteractionsProto::MergeFrom(from._internal_interactions());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_model()->::autofill_assistant::ModelProto::MergeFrom(from._internal_model());
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void GenericUserInterfaceProto::CopyFrom(const GenericUserInterfaceProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.GenericUserInterfaceProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GenericUserInterfaceProto::IsInitialized() const {
  return true;
}

void GenericUserInterfaceProto::InternalSwap(GenericUserInterfaceProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(GenericUserInterfaceProto, model_)
      + sizeof(GenericUserInterfaceProto::model_)
      - PROTOBUF_FIELD_OFFSET(GenericUserInterfaceProto, root_view_)>(
          reinterpret_cast<char*>(&root_view_),
          reinterpret_cast<char*>(&other->root_view_));
}

std::string GenericUserInterfaceProto::GetTypeName() const {
  return "autofill_assistant.GenericUserInterfaceProto";
}


// ===================================================================

class InteractionsProto::_Internal {
 public:
};

InteractionsProto::InteractionsProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  interactions_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.InteractionsProto)
}
InteractionsProto::InteractionsProto(const InteractionsProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      interactions_(from.interactions_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.InteractionsProto)
}

inline void InteractionsProto::SharedCtor() {
}

InteractionsProto::~InteractionsProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.InteractionsProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void InteractionsProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void InteractionsProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void InteractionsProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.InteractionsProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  interactions_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* InteractionsProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .autofill_assistant.InteractionProto interactions = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_interactions(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* InteractionsProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.InteractionsProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .autofill_assistant.InteractionProto interactions = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_interactions_size()); i < n; i++) {
    const auto& repfield = this->_internal_interactions(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.InteractionsProto)
  return target;
}

size_t InteractionsProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.InteractionsProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .autofill_assistant.InteractionProto interactions = 1;
  total_size += 1UL * this->_internal_interactions_size();
  for (const auto& msg : this->interactions_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void InteractionsProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const InteractionsProto*>(
      &from));
}

void InteractionsProto::MergeFrom(const InteractionsProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.InteractionsProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  interactions_.MergeFrom(from.interactions_);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void InteractionsProto::CopyFrom(const InteractionsProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.InteractionsProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool InteractionsProto::IsInitialized() const {
  return true;
}

void InteractionsProto::InternalSwap(InteractionsProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  interactions_.InternalSwap(&other->interactions_);
}

std::string InteractionsProto::GetTypeName() const {
  return "autofill_assistant.InteractionsProto";
}


// ===================================================================

class InteractionProto::_Internal {
 public:
};

InteractionProto::InteractionProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  callbacks_(arena),
  trigger_event_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.InteractionProto)
}
InteractionProto::InteractionProto(const InteractionProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      callbacks_(from.callbacks_),
      trigger_event_(from.trigger_event_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.InteractionProto)
}

inline void InteractionProto::SharedCtor() {
}

InteractionProto::~InteractionProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.InteractionProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void InteractionProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void InteractionProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void InteractionProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.InteractionProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  callbacks_.Clear();
  trigger_event_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* InteractionProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .autofill_assistant.CallbackProto callbacks = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_callbacks(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .autofill_assistant.EventProto trigger_event = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_trigger_event(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* InteractionProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.InteractionProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .autofill_assistant.CallbackProto callbacks = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_callbacks_size()); i < n; i++) {
    const auto& repfield = this->_internal_callbacks(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .autofill_assistant.EventProto trigger_event = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_trigger_event_size()); i < n; i++) {
    const auto& repfield = this->_internal_trigger_event(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.InteractionProto)
  return target;
}

size_t InteractionProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.InteractionProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .autofill_assistant.CallbackProto callbacks = 1;
  total_size += 1UL * this->_internal_callbacks_size();
  for (const auto& msg : this->callbacks_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .autofill_assistant.EventProto trigger_event = 2;
  total_size += 1UL * this->_internal_trigger_event_size();
  for (const auto& msg : this->trigger_event_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void InteractionProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const InteractionProto*>(
      &from));
}

void InteractionProto::MergeFrom(const InteractionProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.InteractionProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  callbacks_.MergeFrom(from.callbacks_);
  trigger_event_.MergeFrom(from.trigger_event_);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void InteractionProto::CopyFrom(const InteractionProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.InteractionProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool InteractionProto::IsInitialized() const {
  return true;
}

void InteractionProto::InternalSwap(InteractionProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  callbacks_.InternalSwap(&other->callbacks_);
  trigger_event_.InternalSwap(&other->trigger_event_);
}

std::string InteractionProto::GetTypeName() const {
  return "autofill_assistant.InteractionProto";
}


// ===================================================================

class CallbackProto::_Internal {
 public:
  using HasBits = decltype(std::declval<CallbackProto>()._has_bits_);
  static const ::autofill_assistant::SetModelValueProto& set_value(const CallbackProto* msg);
  static const ::autofill_assistant::ShowInfoPopupProto& show_info_popup(const CallbackProto* msg);
  static const ::autofill_assistant::ShowListPopupProto& show_list_popup(const CallbackProto* msg);
  static const ::autofill_assistant::ComputeValueProto& compute_value(const CallbackProto* msg);
  static const ::autofill_assistant::SetUserActionsProto& set_user_actions(const CallbackProto* msg);
  static const ::autofill_assistant::EndActionProto& end_action(const CallbackProto* msg);
  static const ::autofill_assistant::ShowCalendarPopupProto& show_calendar_popup(const CallbackProto* msg);
  static const ::autofill_assistant::SetTextProto& set_text(const CallbackProto* msg);
  static const ::autofill_assistant::ToggleUserActionProto& toggle_user_action(const CallbackProto* msg);
  static const ::autofill_assistant::SetViewVisibilityProto& set_view_visibility(const CallbackProto* msg);
  static const ::autofill_assistant::SetViewEnabledProto& set_view_enabled(const CallbackProto* msg);
  static const ::autofill_assistant::ShowGenericUiPopupProto& show_generic_popup(const CallbackProto* msg);
  static const ::autofill_assistant::CreateNestedGenericUiProto& create_nested_ui(const CallbackProto* msg);
  static const ::autofill_assistant::ClearViewContainerProto& clear_view_container(const CallbackProto* msg);
  static const ::autofill_assistant::ForEachProto& for_each(const CallbackProto* msg);
  static void set_has_condition_model_identifier(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::autofill_assistant::SetModelValueProto&
CallbackProto::_Internal::set_value(const CallbackProto* msg) {
  return *msg->kind_.set_value_;
}
const ::autofill_assistant::ShowInfoPopupProto&
CallbackProto::_Internal::show_info_popup(const CallbackProto* msg) {
  return *msg->kind_.show_info_popup_;
}
const ::autofill_assistant::ShowListPopupProto&
CallbackProto::_Internal::show_list_popup(const CallbackProto* msg) {
  return *msg->kind_.show_list_popup_;
}
const ::autofill_assistant::ComputeValueProto&
CallbackProto::_Internal::compute_value(const CallbackProto* msg) {
  return *msg->kind_.compute_value_;
}
const ::autofill_assistant::SetUserActionsProto&
CallbackProto::_Internal::set_user_actions(const CallbackProto* msg) {
  return *msg->kind_.set_user_actions_;
}
const ::autofill_assistant::EndActionProto&
CallbackProto::_Internal::end_action(const CallbackProto* msg) {
  return *msg->kind_.end_action_;
}
const ::autofill_assistant::ShowCalendarPopupProto&
CallbackProto::_Internal::show_calendar_popup(const CallbackProto* msg) {
  return *msg->kind_.show_calendar_popup_;
}
const ::autofill_assistant::SetTextProto&
CallbackProto::_Internal::set_text(const CallbackProto* msg) {
  return *msg->kind_.set_text_;
}
const ::autofill_assistant::ToggleUserActionProto&
CallbackProto::_Internal::toggle_user_action(const CallbackProto* msg) {
  return *msg->kind_.toggle_user_action_;
}
const ::autofill_assistant::SetViewVisibilityProto&
CallbackProto::_Internal::set_view_visibility(const CallbackProto* msg) {
  return *msg->kind_.set_view_visibility_;
}
const ::autofill_assistant::SetViewEnabledProto&
CallbackProto::_Internal::set_view_enabled(const CallbackProto* msg) {
  return *msg->kind_.set_view_enabled_;
}
const ::autofill_assistant::ShowGenericUiPopupProto&
CallbackProto::_Internal::show_generic_popup(const CallbackProto* msg) {
  return *msg->kind_.show_generic_popup_;
}
const ::autofill_assistant::CreateNestedGenericUiProto&
CallbackProto::_Internal::create_nested_ui(const CallbackProto* msg) {
  return *msg->kind_.create_nested_ui_;
}
const ::autofill_assistant::ClearViewContainerProto&
CallbackProto::_Internal::clear_view_container(const CallbackProto* msg) {
  return *msg->kind_.clear_view_container_;
}
const ::autofill_assistant::ForEachProto&
CallbackProto::_Internal::for_each(const CallbackProto* msg) {
  return *msg->kind_.for_each_;
}
void CallbackProto::set_allocated_set_value(::autofill_assistant::SetModelValueProto* set_value) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_kind();
  if (set_value) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(set_value);
    if (message_arena != submessage_arena) {
      set_value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, set_value, submessage_arena);
    }
    set_has_set_value();
    kind_.set_value_ = set_value;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.CallbackProto.set_value)
}
void CallbackProto::set_allocated_show_info_popup(::autofill_assistant::ShowInfoPopupProto* show_info_popup) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_kind();
  if (show_info_popup) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(show_info_popup);
    if (message_arena != submessage_arena) {
      show_info_popup = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, show_info_popup, submessage_arena);
    }
    set_has_show_info_popup();
    kind_.show_info_popup_ = show_info_popup;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.CallbackProto.show_info_popup)
}
void CallbackProto::set_allocated_show_list_popup(::autofill_assistant::ShowListPopupProto* show_list_popup) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_kind();
  if (show_list_popup) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(show_list_popup);
    if (message_arena != submessage_arena) {
      show_list_popup = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, show_list_popup, submessage_arena);
    }
    set_has_show_list_popup();
    kind_.show_list_popup_ = show_list_popup;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.CallbackProto.show_list_popup)
}
void CallbackProto::set_allocated_compute_value(::autofill_assistant::ComputeValueProto* compute_value) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_kind();
  if (compute_value) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(compute_value);
    if (message_arena != submessage_arena) {
      compute_value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, compute_value, submessage_arena);
    }
    set_has_compute_value();
    kind_.compute_value_ = compute_value;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.CallbackProto.compute_value)
}
void CallbackProto::set_allocated_set_user_actions(::autofill_assistant::SetUserActionsProto* set_user_actions) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_kind();
  if (set_user_actions) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(set_user_actions);
    if (message_arena != submessage_arena) {
      set_user_actions = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, set_user_actions, submessage_arena);
    }
    set_has_set_user_actions();
    kind_.set_user_actions_ = set_user_actions;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.CallbackProto.set_user_actions)
}
void CallbackProto::set_allocated_end_action(::autofill_assistant::EndActionProto* end_action) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_kind();
  if (end_action) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(end_action);
    if (message_arena != submessage_arena) {
      end_action = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, end_action, submessage_arena);
    }
    set_has_end_action();
    kind_.end_action_ = end_action;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.CallbackProto.end_action)
}
void CallbackProto::set_allocated_show_calendar_popup(::autofill_assistant::ShowCalendarPopupProto* show_calendar_popup) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_kind();
  if (show_calendar_popup) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(show_calendar_popup);
    if (message_arena != submessage_arena) {
      show_calendar_popup = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, show_calendar_popup, submessage_arena);
    }
    set_has_show_calendar_popup();
    kind_.show_calendar_popup_ = show_calendar_popup;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.CallbackProto.show_calendar_popup)
}
void CallbackProto::set_allocated_set_text(::autofill_assistant::SetTextProto* set_text) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_kind();
  if (set_text) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(set_text);
    if (message_arena != submessage_arena) {
      set_text = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, set_text, submessage_arena);
    }
    set_has_set_text();
    kind_.set_text_ = set_text;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.CallbackProto.set_text)
}
void CallbackProto::set_allocated_toggle_user_action(::autofill_assistant::ToggleUserActionProto* toggle_user_action) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_kind();
  if (toggle_user_action) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(toggle_user_action);
    if (message_arena != submessage_arena) {
      toggle_user_action = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, toggle_user_action, submessage_arena);
    }
    set_has_toggle_user_action();
    kind_.toggle_user_action_ = toggle_user_action;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.CallbackProto.toggle_user_action)
}
void CallbackProto::set_allocated_set_view_visibility(::autofill_assistant::SetViewVisibilityProto* set_view_visibility) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_kind();
  if (set_view_visibility) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(set_view_visibility);
    if (message_arena != submessage_arena) {
      set_view_visibility = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, set_view_visibility, submessage_arena);
    }
    set_has_set_view_visibility();
    kind_.set_view_visibility_ = set_view_visibility;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.CallbackProto.set_view_visibility)
}
void CallbackProto::set_allocated_set_view_enabled(::autofill_assistant::SetViewEnabledProto* set_view_enabled) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_kind();
  if (set_view_enabled) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(set_view_enabled);
    if (message_arena != submessage_arena) {
      set_view_enabled = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, set_view_enabled, submessage_arena);
    }
    set_has_set_view_enabled();
    kind_.set_view_enabled_ = set_view_enabled;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.CallbackProto.set_view_enabled)
}
void CallbackProto::set_allocated_show_generic_popup(::autofill_assistant::ShowGenericUiPopupProto* show_generic_popup) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_kind();
  if (show_generic_popup) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(show_generic_popup);
    if (message_arena != submessage_arena) {
      show_generic_popup = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, show_generic_popup, submessage_arena);
    }
    set_has_show_generic_popup();
    kind_.show_generic_popup_ = show_generic_popup;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.CallbackProto.show_generic_popup)
}
void CallbackProto::set_allocated_create_nested_ui(::autofill_assistant::CreateNestedGenericUiProto* create_nested_ui) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_kind();
  if (create_nested_ui) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(create_nested_ui);
    if (message_arena != submessage_arena) {
      create_nested_ui = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, create_nested_ui, submessage_arena);
    }
    set_has_create_nested_ui();
    kind_.create_nested_ui_ = create_nested_ui;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.CallbackProto.create_nested_ui)
}
void CallbackProto::set_allocated_clear_view_container(::autofill_assistant::ClearViewContainerProto* clear_view_container) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_kind();
  if (clear_view_container) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(clear_view_container);
    if (message_arena != submessage_arena) {
      clear_view_container = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, clear_view_container, submessage_arena);
    }
    set_has_clear_view_container();
    kind_.clear_view_container_ = clear_view_container;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.CallbackProto.clear_view_container)
}
void CallbackProto::set_allocated_for_each(::autofill_assistant::ForEachProto* for_each) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_kind();
  if (for_each) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(for_each);
    if (message_arena != submessage_arena) {
      for_each = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, for_each, submessage_arena);
    }
    set_has_for_each();
    kind_.for_each_ = for_each;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.CallbackProto.for_each)
}
CallbackProto::CallbackProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.CallbackProto)
}
CallbackProto::CallbackProto(const CallbackProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  condition_model_identifier_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    condition_model_identifier_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_condition_model_identifier()) {
    condition_model_identifier_.Set(from._internal_condition_model_identifier(), 
      GetArenaForAllocation());
  }
  clear_has_kind();
  switch (from.kind_case()) {
    case kSetValue: {
      _internal_mutable_set_value()->::autofill_assistant::SetModelValueProto::MergeFrom(from._internal_set_value());
      break;
    }
    case kShowInfoPopup: {
      _internal_mutable_show_info_popup()->::autofill_assistant::ShowInfoPopupProto::MergeFrom(from._internal_show_info_popup());
      break;
    }
    case kShowListPopup: {
      _internal_mutable_show_list_popup()->::autofill_assistant::ShowListPopupProto::MergeFrom(from._internal_show_list_popup());
      break;
    }
    case kComputeValue: {
      _internal_mutable_compute_value()->::autofill_assistant::ComputeValueProto::MergeFrom(from._internal_compute_value());
      break;
    }
    case kSetUserActions: {
      _internal_mutable_set_user_actions()->::autofill_assistant::SetUserActionsProto::MergeFrom(from._internal_set_user_actions());
      break;
    }
    case kEndAction: {
      _internal_mutable_end_action()->::autofill_assistant::EndActionProto::MergeFrom(from._internal_end_action());
      break;
    }
    case kShowCalendarPopup: {
      _internal_mutable_show_calendar_popup()->::autofill_assistant::ShowCalendarPopupProto::MergeFrom(from._internal_show_calendar_popup());
      break;
    }
    case kSetText: {
      _internal_mutable_set_text()->::autofill_assistant::SetTextProto::MergeFrom(from._internal_set_text());
      break;
    }
    case kToggleUserAction: {
      _internal_mutable_toggle_user_action()->::autofill_assistant::ToggleUserActionProto::MergeFrom(from._internal_toggle_user_action());
      break;
    }
    case kSetViewVisibility: {
      _internal_mutable_set_view_visibility()->::autofill_assistant::SetViewVisibilityProto::MergeFrom(from._internal_set_view_visibility());
      break;
    }
    case kSetViewEnabled: {
      _internal_mutable_set_view_enabled()->::autofill_assistant::SetViewEnabledProto::MergeFrom(from._internal_set_view_enabled());
      break;
    }
    case kShowGenericPopup: {
      _internal_mutable_show_generic_popup()->::autofill_assistant::ShowGenericUiPopupProto::MergeFrom(from._internal_show_generic_popup());
      break;
    }
    case kCreateNestedUi: {
      _internal_mutable_create_nested_ui()->::autofill_assistant::CreateNestedGenericUiProto::MergeFrom(from._internal_create_nested_ui());
      break;
    }
    case kClearViewContainer: {
      _internal_mutable_clear_view_container()->::autofill_assistant::ClearViewContainerProto::MergeFrom(from._internal_clear_view_container());
      break;
    }
    case kForEach: {
      _internal_mutable_for_each()->::autofill_assistant::ForEachProto::MergeFrom(from._internal_for_each());
      break;
    }
    case KIND_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.CallbackProto)
}

inline void CallbackProto::SharedCtor() {
condition_model_identifier_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  condition_model_identifier_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
clear_has_kind();
}

CallbackProto::~CallbackProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.CallbackProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CallbackProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  condition_model_identifier_.Destroy();
  if (has_kind()) {
    clear_kind();
  }
}

void CallbackProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CallbackProto::clear_kind() {
// @@protoc_insertion_point(one_of_clear_start:autofill_assistant.CallbackProto)
  switch (kind_case()) {
    case kSetValue: {
      if (GetArenaForAllocation() == nullptr) {
        delete kind_.set_value_;
      }
      break;
    }
    case kShowInfoPopup: {
      if (GetArenaForAllocation() == nullptr) {
        delete kind_.show_info_popup_;
      }
      break;
    }
    case kShowListPopup: {
      if (GetArenaForAllocation() == nullptr) {
        delete kind_.show_list_popup_;
      }
      break;
    }
    case kComputeValue: {
      if (GetArenaForAllocation() == nullptr) {
        delete kind_.compute_value_;
      }
      break;
    }
    case kSetUserActions: {
      if (GetArenaForAllocation() == nullptr) {
        delete kind_.set_user_actions_;
      }
      break;
    }
    case kEndAction: {
      if (GetArenaForAllocation() == nullptr) {
        delete kind_.end_action_;
      }
      break;
    }
    case kShowCalendarPopup: {
      if (GetArenaForAllocation() == nullptr) {
        delete kind_.show_calendar_popup_;
      }
      break;
    }
    case kSetText: {
      if (GetArenaForAllocation() == nullptr) {
        delete kind_.set_text_;
      }
      break;
    }
    case kToggleUserAction: {
      if (GetArenaForAllocation() == nullptr) {
        delete kind_.toggle_user_action_;
      }
      break;
    }
    case kSetViewVisibility: {
      if (GetArenaForAllocation() == nullptr) {
        delete kind_.set_view_visibility_;
      }
      break;
    }
    case kSetViewEnabled: {
      if (GetArenaForAllocation() == nullptr) {
        delete kind_.set_view_enabled_;
      }
      break;
    }
    case kShowGenericPopup: {
      if (GetArenaForAllocation() == nullptr) {
        delete kind_.show_generic_popup_;
      }
      break;
    }
    case kCreateNestedUi: {
      if (GetArenaForAllocation() == nullptr) {
        delete kind_.create_nested_ui_;
      }
      break;
    }
    case kClearViewContainer: {
      if (GetArenaForAllocation() == nullptr) {
        delete kind_.clear_view_container_;
      }
      break;
    }
    case kForEach: {
      if (GetArenaForAllocation() == nullptr) {
        delete kind_.for_each_;
      }
      break;
    }
    case KIND_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = KIND_NOT_SET;
}


void CallbackProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.CallbackProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    condition_model_identifier_.ClearNonDefaultToEmpty();
  }
  clear_kind();
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CallbackProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .autofill_assistant.SetModelValueProto set_value = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_set_value(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.ShowInfoPopupProto show_info_popup = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_show_info_popup(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.ShowListPopupProto show_list_popup = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_show_list_popup(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.ComputeValueProto compute_value = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_compute_value(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.SetUserActionsProto set_user_actions = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_set_user_actions(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.EndActionProto end_action = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_end_action(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.ShowCalendarPopupProto show_calendar_popup = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_show_calendar_popup(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.SetTextProto set_text = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_set_text(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.ToggleUserActionProto toggle_user_action = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_toggle_user_action(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string condition_model_identifier = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          auto str = _internal_mutable_condition_model_identifier();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.SetViewVisibilityProto set_view_visibility = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_set_view_visibility(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.SetViewEnabledProto set_view_enabled = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          ptr = ctx->ParseMessage(_internal_mutable_set_view_enabled(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.ShowGenericUiPopupProto show_generic_popup = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          ptr = ctx->ParseMessage(_internal_mutable_show_generic_popup(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.CreateNestedGenericUiProto create_nested_ui = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 114)) {
          ptr = ctx->ParseMessage(_internal_mutable_create_nested_ui(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.ClearViewContainerProto clear_view_container = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 122)) {
          ptr = ctx->ParseMessage(_internal_mutable_clear_view_container(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.ForEachProto for_each = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 130)) {
          ptr = ctx->ParseMessage(_internal_mutable_for_each(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CallbackProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.CallbackProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (kind_case()) {
    case kSetValue: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, _Internal::set_value(this),
          _Internal::set_value(this).GetCachedSize(), target, stream);
      break;
    }
    case kShowInfoPopup: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, _Internal::show_info_popup(this),
          _Internal::show_info_popup(this).GetCachedSize(), target, stream);
      break;
    }
    case kShowListPopup: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, _Internal::show_list_popup(this),
          _Internal::show_list_popup(this).GetCachedSize(), target, stream);
      break;
    }
    case kComputeValue: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, _Internal::compute_value(this),
          _Internal::compute_value(this).GetCachedSize(), target, stream);
      break;
    }
    case kSetUserActions: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(5, _Internal::set_user_actions(this),
          _Internal::set_user_actions(this).GetCachedSize(), target, stream);
      break;
    }
    case kEndAction: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(6, _Internal::end_action(this),
          _Internal::end_action(this).GetCachedSize(), target, stream);
      break;
    }
    case kShowCalendarPopup: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(7, _Internal::show_calendar_popup(this),
          _Internal::show_calendar_popup(this).GetCachedSize(), target, stream);
      break;
    }
    case kSetText: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(8, _Internal::set_text(this),
          _Internal::set_text(this).GetCachedSize(), target, stream);
      break;
    }
    case kToggleUserAction: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(9, _Internal::toggle_user_action(this),
          _Internal::toggle_user_action(this).GetCachedSize(), target, stream);
      break;
    }
    default: ;
  }
  cached_has_bits = _has_bits_[0];
  // optional string condition_model_identifier = 10;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        10, this->_internal_condition_model_identifier(), target);
  }

  switch (kind_case()) {
    case kSetViewVisibility: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(11, _Internal::set_view_visibility(this),
          _Internal::set_view_visibility(this).GetCachedSize(), target, stream);
      break;
    }
    case kSetViewEnabled: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(12, _Internal::set_view_enabled(this),
          _Internal::set_view_enabled(this).GetCachedSize(), target, stream);
      break;
    }
    case kShowGenericPopup: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(13, _Internal::show_generic_popup(this),
          _Internal::show_generic_popup(this).GetCachedSize(), target, stream);
      break;
    }
    case kCreateNestedUi: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(14, _Internal::create_nested_ui(this),
          _Internal::create_nested_ui(this).GetCachedSize(), target, stream);
      break;
    }
    case kClearViewContainer: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(15, _Internal::clear_view_container(this),
          _Internal::clear_view_container(this).GetCachedSize(), target, stream);
      break;
    }
    case kForEach: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(16, _Internal::for_each(this),
          _Internal::for_each(this).GetCachedSize(), target, stream);
      break;
    }
    default: ;
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.CallbackProto)
  return target;
}

size_t CallbackProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.CallbackProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string condition_model_identifier = 10;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_condition_model_identifier());
  }

  switch (kind_case()) {
    // .autofill_assistant.SetModelValueProto set_value = 1;
    case kSetValue: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *kind_.set_value_);
      break;
    }
    // .autofill_assistant.ShowInfoPopupProto show_info_popup = 2;
    case kShowInfoPopup: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *kind_.show_info_popup_);
      break;
    }
    // .autofill_assistant.ShowListPopupProto show_list_popup = 3;
    case kShowListPopup: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *kind_.show_list_popup_);
      break;
    }
    // .autofill_assistant.ComputeValueProto compute_value = 4;
    case kComputeValue: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *kind_.compute_value_);
      break;
    }
    // .autofill_assistant.SetUserActionsProto set_user_actions = 5;
    case kSetUserActions: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *kind_.set_user_actions_);
      break;
    }
    // .autofill_assistant.EndActionProto end_action = 6;
    case kEndAction: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *kind_.end_action_);
      break;
    }
    // .autofill_assistant.ShowCalendarPopupProto show_calendar_popup = 7;
    case kShowCalendarPopup: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *kind_.show_calendar_popup_);
      break;
    }
    // .autofill_assistant.SetTextProto set_text = 8;
    case kSetText: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *kind_.set_text_);
      break;
    }
    // .autofill_assistant.ToggleUserActionProto toggle_user_action = 9;
    case kToggleUserAction: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *kind_.toggle_user_action_);
      break;
    }
    // .autofill_assistant.SetViewVisibilityProto set_view_visibility = 11;
    case kSetViewVisibility: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *kind_.set_view_visibility_);
      break;
    }
    // .autofill_assistant.SetViewEnabledProto set_view_enabled = 12;
    case kSetViewEnabled: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *kind_.set_view_enabled_);
      break;
    }
    // .autofill_assistant.ShowGenericUiPopupProto show_generic_popup = 13;
    case kShowGenericPopup: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *kind_.show_generic_popup_);
      break;
    }
    // .autofill_assistant.CreateNestedGenericUiProto create_nested_ui = 14;
    case kCreateNestedUi: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *kind_.create_nested_ui_);
      break;
    }
    // .autofill_assistant.ClearViewContainerProto clear_view_container = 15;
    case kClearViewContainer: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *kind_.clear_view_container_);
      break;
    }
    // .autofill_assistant.ForEachProto for_each = 16;
    case kForEach: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *kind_.for_each_);
      break;
    }
    case KIND_NOT_SET: {
      break;
    }
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CallbackProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CallbackProto*>(
      &from));
}

void CallbackProto::MergeFrom(const CallbackProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.CallbackProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_condition_model_identifier()) {
    _internal_set_condition_model_identifier(from._internal_condition_model_identifier());
  }
  switch (from.kind_case()) {
    case kSetValue: {
      _internal_mutable_set_value()->::autofill_assistant::SetModelValueProto::MergeFrom(from._internal_set_value());
      break;
    }
    case kShowInfoPopup: {
      _internal_mutable_show_info_popup()->::autofill_assistant::ShowInfoPopupProto::MergeFrom(from._internal_show_info_popup());
      break;
    }
    case kShowListPopup: {
      _internal_mutable_show_list_popup()->::autofill_assistant::ShowListPopupProto::MergeFrom(from._internal_show_list_popup());
      break;
    }
    case kComputeValue: {
      _internal_mutable_compute_value()->::autofill_assistant::ComputeValueProto::MergeFrom(from._internal_compute_value());
      break;
    }
    case kSetUserActions: {
      _internal_mutable_set_user_actions()->::autofill_assistant::SetUserActionsProto::MergeFrom(from._internal_set_user_actions());
      break;
    }
    case kEndAction: {
      _internal_mutable_end_action()->::autofill_assistant::EndActionProto::MergeFrom(from._internal_end_action());
      break;
    }
    case kShowCalendarPopup: {
      _internal_mutable_show_calendar_popup()->::autofill_assistant::ShowCalendarPopupProto::MergeFrom(from._internal_show_calendar_popup());
      break;
    }
    case kSetText: {
      _internal_mutable_set_text()->::autofill_assistant::SetTextProto::MergeFrom(from._internal_set_text());
      break;
    }
    case kToggleUserAction: {
      _internal_mutable_toggle_user_action()->::autofill_assistant::ToggleUserActionProto::MergeFrom(from._internal_toggle_user_action());
      break;
    }
    case kSetViewVisibility: {
      _internal_mutable_set_view_visibility()->::autofill_assistant::SetViewVisibilityProto::MergeFrom(from._internal_set_view_visibility());
      break;
    }
    case kSetViewEnabled: {
      _internal_mutable_set_view_enabled()->::autofill_assistant::SetViewEnabledProto::MergeFrom(from._internal_set_view_enabled());
      break;
    }
    case kShowGenericPopup: {
      _internal_mutable_show_generic_popup()->::autofill_assistant::ShowGenericUiPopupProto::MergeFrom(from._internal_show_generic_popup());
      break;
    }
    case kCreateNestedUi: {
      _internal_mutable_create_nested_ui()->::autofill_assistant::CreateNestedGenericUiProto::MergeFrom(from._internal_create_nested_ui());
      break;
    }
    case kClearViewContainer: {
      _internal_mutable_clear_view_container()->::autofill_assistant::ClearViewContainerProto::MergeFrom(from._internal_clear_view_container());
      break;
    }
    case kForEach: {
      _internal_mutable_for_each()->::autofill_assistant::ForEachProto::MergeFrom(from._internal_for_each());
      break;
    }
    case KIND_NOT_SET: {
      break;
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CallbackProto::CopyFrom(const CallbackProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.CallbackProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CallbackProto::IsInitialized() const {
  return true;
}

void CallbackProto::InternalSwap(CallbackProto* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &condition_model_identifier_, lhs_arena,
      &other->condition_model_identifier_, rhs_arena
  );
  swap(kind_, other->kind_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

std::string CallbackProto::GetTypeName() const {
  return "autofill_assistant.CallbackProto";
}


// ===================================================================

class EventProto::_Internal {
 public:
  static const ::autofill_assistant::OnModelValueChangedEventProto& on_value_changed(const EventProto* msg);
  static const ::autofill_assistant::OnViewClickedEventProto& on_view_clicked(const EventProto* msg);
  static const ::autofill_assistant::OnUserActionCalled& on_user_action_called(const EventProto* msg);
  static const ::autofill_assistant::OnTextLinkClickedProto& on_text_link_clicked(const EventProto* msg);
  static const ::autofill_assistant::OnPopupDismissedProto& on_popup_dismissed(const EventProto* msg);
  static const ::autofill_assistant::OnViewContainerClearedProto& on_view_container_cleared(const EventProto* msg);
};

const ::autofill_assistant::OnModelValueChangedEventProto&
EventProto::_Internal::on_value_changed(const EventProto* msg) {
  return *msg->kind_.on_value_changed_;
}
const ::autofill_assistant::OnViewClickedEventProto&
EventProto::_Internal::on_view_clicked(const EventProto* msg) {
  return *msg->kind_.on_view_clicked_;
}
const ::autofill_assistant::OnUserActionCalled&
EventProto::_Internal::on_user_action_called(const EventProto* msg) {
  return *msg->kind_.on_user_action_called_;
}
const ::autofill_assistant::OnTextLinkClickedProto&
EventProto::_Internal::on_text_link_clicked(const EventProto* msg) {
  return *msg->kind_.on_text_link_clicked_;
}
const ::autofill_assistant::OnPopupDismissedProto&
EventProto::_Internal::on_popup_dismissed(const EventProto* msg) {
  return *msg->kind_.on_popup_dismissed_;
}
const ::autofill_assistant::OnViewContainerClearedProto&
EventProto::_Internal::on_view_container_cleared(const EventProto* msg) {
  return *msg->kind_.on_view_container_cleared_;
}
void EventProto::set_allocated_on_value_changed(::autofill_assistant::OnModelValueChangedEventProto* on_value_changed) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_kind();
  if (on_value_changed) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(on_value_changed);
    if (message_arena != submessage_arena) {
      on_value_changed = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, on_value_changed, submessage_arena);
    }
    set_has_on_value_changed();
    kind_.on_value_changed_ = on_value_changed;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.EventProto.on_value_changed)
}
void EventProto::set_allocated_on_view_clicked(::autofill_assistant::OnViewClickedEventProto* on_view_clicked) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_kind();
  if (on_view_clicked) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(on_view_clicked);
    if (message_arena != submessage_arena) {
      on_view_clicked = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, on_view_clicked, submessage_arena);
    }
    set_has_on_view_clicked();
    kind_.on_view_clicked_ = on_view_clicked;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.EventProto.on_view_clicked)
}
void EventProto::set_allocated_on_user_action_called(::autofill_assistant::OnUserActionCalled* on_user_action_called) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_kind();
  if (on_user_action_called) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(on_user_action_called);
    if (message_arena != submessage_arena) {
      on_user_action_called = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, on_user_action_called, submessage_arena);
    }
    set_has_on_user_action_called();
    kind_.on_user_action_called_ = on_user_action_called;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.EventProto.on_user_action_called)
}
void EventProto::set_allocated_on_text_link_clicked(::autofill_assistant::OnTextLinkClickedProto* on_text_link_clicked) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_kind();
  if (on_text_link_clicked) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(on_text_link_clicked);
    if (message_arena != submessage_arena) {
      on_text_link_clicked = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, on_text_link_clicked, submessage_arena);
    }
    set_has_on_text_link_clicked();
    kind_.on_text_link_clicked_ = on_text_link_clicked;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.EventProto.on_text_link_clicked)
}
void EventProto::set_allocated_on_popup_dismissed(::autofill_assistant::OnPopupDismissedProto* on_popup_dismissed) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_kind();
  if (on_popup_dismissed) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(on_popup_dismissed);
    if (message_arena != submessage_arena) {
      on_popup_dismissed = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, on_popup_dismissed, submessage_arena);
    }
    set_has_on_popup_dismissed();
    kind_.on_popup_dismissed_ = on_popup_dismissed;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.EventProto.on_popup_dismissed)
}
void EventProto::set_allocated_on_view_container_cleared(::autofill_assistant::OnViewContainerClearedProto* on_view_container_cleared) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_kind();
  if (on_view_container_cleared) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(on_view_container_cleared);
    if (message_arena != submessage_arena) {
      on_view_container_cleared = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, on_view_container_cleared, submessage_arena);
    }
    set_has_on_view_container_cleared();
    kind_.on_view_container_cleared_ = on_view_container_cleared;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.EventProto.on_view_container_cleared)
}
EventProto::EventProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.EventProto)
}
EventProto::EventProto(const EventProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  clear_has_kind();
  switch (from.kind_case()) {
    case kOnValueChanged: {
      _internal_mutable_on_value_changed()->::autofill_assistant::OnModelValueChangedEventProto::MergeFrom(from._internal_on_value_changed());
      break;
    }
    case kOnViewClicked: {
      _internal_mutable_on_view_clicked()->::autofill_assistant::OnViewClickedEventProto::MergeFrom(from._internal_on_view_clicked());
      break;
    }
    case kOnUserActionCalled: {
      _internal_mutable_on_user_action_called()->::autofill_assistant::OnUserActionCalled::MergeFrom(from._internal_on_user_action_called());
      break;
    }
    case kOnTextLinkClicked: {
      _internal_mutable_on_text_link_clicked()->::autofill_assistant::OnTextLinkClickedProto::MergeFrom(from._internal_on_text_link_clicked());
      break;
    }
    case kOnPopupDismissed: {
      _internal_mutable_on_popup_dismissed()->::autofill_assistant::OnPopupDismissedProto::MergeFrom(from._internal_on_popup_dismissed());
      break;
    }
    case kOnViewContainerCleared: {
      _internal_mutable_on_view_container_cleared()->::autofill_assistant::OnViewContainerClearedProto::MergeFrom(from._internal_on_view_container_cleared());
      break;
    }
    case KIND_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.EventProto)
}

inline void EventProto::SharedCtor() {
clear_has_kind();
}

EventProto::~EventProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.EventProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void EventProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_kind()) {
    clear_kind();
  }
}

void EventProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void EventProto::clear_kind() {
// @@protoc_insertion_point(one_of_clear_start:autofill_assistant.EventProto)
  switch (kind_case()) {
    case kOnValueChanged: {
      if (GetArenaForAllocation() == nullptr) {
        delete kind_.on_value_changed_;
      }
      break;
    }
    case kOnViewClicked: {
      if (GetArenaForAllocation() == nullptr) {
        delete kind_.on_view_clicked_;
      }
      break;
    }
    case kOnUserActionCalled: {
      if (GetArenaForAllocation() == nullptr) {
        delete kind_.on_user_action_called_;
      }
      break;
    }
    case kOnTextLinkClicked: {
      if (GetArenaForAllocation() == nullptr) {
        delete kind_.on_text_link_clicked_;
      }
      break;
    }
    case kOnPopupDismissed: {
      if (GetArenaForAllocation() == nullptr) {
        delete kind_.on_popup_dismissed_;
      }
      break;
    }
    case kOnViewContainerCleared: {
      if (GetArenaForAllocation() == nullptr) {
        delete kind_.on_view_container_cleared_;
      }
      break;
    }
    case KIND_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = KIND_NOT_SET;
}


void EventProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.EventProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_kind();
  _internal_metadata_.Clear<std::string>();
}

const char* EventProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .autofill_assistant.OnModelValueChangedEventProto on_value_changed = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_on_value_changed(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.OnViewClickedEventProto on_view_clicked = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_on_view_clicked(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.OnUserActionCalled on_user_action_called = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_on_user_action_called(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.OnTextLinkClickedProto on_text_link_clicked = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_on_text_link_clicked(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.OnPopupDismissedProto on_popup_dismissed = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_on_popup_dismissed(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.OnViewContainerClearedProto on_view_container_cleared = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_on_view_container_cleared(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* EventProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.EventProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (kind_case()) {
    case kOnValueChanged: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, _Internal::on_value_changed(this),
          _Internal::on_value_changed(this).GetCachedSize(), target, stream);
      break;
    }
    case kOnViewClicked: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, _Internal::on_view_clicked(this),
          _Internal::on_view_clicked(this).GetCachedSize(), target, stream);
      break;
    }
    case kOnUserActionCalled: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, _Internal::on_user_action_called(this),
          _Internal::on_user_action_called(this).GetCachedSize(), target, stream);
      break;
    }
    case kOnTextLinkClicked: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, _Internal::on_text_link_clicked(this),
          _Internal::on_text_link_clicked(this).GetCachedSize(), target, stream);
      break;
    }
    case kOnPopupDismissed: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(5, _Internal::on_popup_dismissed(this),
          _Internal::on_popup_dismissed(this).GetCachedSize(), target, stream);
      break;
    }
    case kOnViewContainerCleared: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(6, _Internal::on_view_container_cleared(this),
          _Internal::on_view_container_cleared(this).GetCachedSize(), target, stream);
      break;
    }
    default: ;
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.EventProto)
  return target;
}

size_t EventProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.EventProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (kind_case()) {
    // .autofill_assistant.OnModelValueChangedEventProto on_value_changed = 1;
    case kOnValueChanged: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *kind_.on_value_changed_);
      break;
    }
    // .autofill_assistant.OnViewClickedEventProto on_view_clicked = 2;
    case kOnViewClicked: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *kind_.on_view_clicked_);
      break;
    }
    // .autofill_assistant.OnUserActionCalled on_user_action_called = 3;
    case kOnUserActionCalled: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *kind_.on_user_action_called_);
      break;
    }
    // .autofill_assistant.OnTextLinkClickedProto on_text_link_clicked = 4;
    case kOnTextLinkClicked: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *kind_.on_text_link_clicked_);
      break;
    }
    // .autofill_assistant.OnPopupDismissedProto on_popup_dismissed = 5;
    case kOnPopupDismissed: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *kind_.on_popup_dismissed_);
      break;
    }
    // .autofill_assistant.OnViewContainerClearedProto on_view_container_cleared = 6;
    case kOnViewContainerCleared: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *kind_.on_view_container_cleared_);
      break;
    }
    case KIND_NOT_SET: {
      break;
    }
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void EventProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const EventProto*>(
      &from));
}

void EventProto::MergeFrom(const EventProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.EventProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.kind_case()) {
    case kOnValueChanged: {
      _internal_mutable_on_value_changed()->::autofill_assistant::OnModelValueChangedEventProto::MergeFrom(from._internal_on_value_changed());
      break;
    }
    case kOnViewClicked: {
      _internal_mutable_on_view_clicked()->::autofill_assistant::OnViewClickedEventProto::MergeFrom(from._internal_on_view_clicked());
      break;
    }
    case kOnUserActionCalled: {
      _internal_mutable_on_user_action_called()->::autofill_assistant::OnUserActionCalled::MergeFrom(from._internal_on_user_action_called());
      break;
    }
    case kOnTextLinkClicked: {
      _internal_mutable_on_text_link_clicked()->::autofill_assistant::OnTextLinkClickedProto::MergeFrom(from._internal_on_text_link_clicked());
      break;
    }
    case kOnPopupDismissed: {
      _internal_mutable_on_popup_dismissed()->::autofill_assistant::OnPopupDismissedProto::MergeFrom(from._internal_on_popup_dismissed());
      break;
    }
    case kOnViewContainerCleared: {
      _internal_mutable_on_view_container_cleared()->::autofill_assistant::OnViewContainerClearedProto::MergeFrom(from._internal_on_view_container_cleared());
      break;
    }
    case KIND_NOT_SET: {
      break;
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void EventProto::CopyFrom(const EventProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.EventProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EventProto::IsInitialized() const {
  return true;
}

void EventProto::InternalSwap(EventProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(kind_, other->kind_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

std::string EventProto::GetTypeName() const {
  return "autofill_assistant.EventProto";
}


// ===================================================================

class OnModelValueChangedEventProto::_Internal {
 public:
  using HasBits = decltype(std::declval<OnModelValueChangedEventProto>()._has_bits_);
  static void set_has_model_identifier(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

OnModelValueChangedEventProto::OnModelValueChangedEventProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.OnModelValueChangedEventProto)
}
OnModelValueChangedEventProto::OnModelValueChangedEventProto(const OnModelValueChangedEventProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  model_identifier_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    model_identifier_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_model_identifier()) {
    model_identifier_.Set(from._internal_model_identifier(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.OnModelValueChangedEventProto)
}

inline void OnModelValueChangedEventProto::SharedCtor() {
model_identifier_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  model_identifier_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

OnModelValueChangedEventProto::~OnModelValueChangedEventProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.OnModelValueChangedEventProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void OnModelValueChangedEventProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  model_identifier_.Destroy();
}

void OnModelValueChangedEventProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void OnModelValueChangedEventProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.OnModelValueChangedEventProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    model_identifier_.ClearNonDefaultToEmpty();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* OnModelValueChangedEventProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string model_identifier = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_model_identifier();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* OnModelValueChangedEventProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.OnModelValueChangedEventProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string model_identifier = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_model_identifier(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.OnModelValueChangedEventProto)
  return target;
}

size_t OnModelValueChangedEventProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.OnModelValueChangedEventProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string model_identifier = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_model_identifier());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void OnModelValueChangedEventProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const OnModelValueChangedEventProto*>(
      &from));
}

void OnModelValueChangedEventProto::MergeFrom(const OnModelValueChangedEventProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.OnModelValueChangedEventProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_model_identifier()) {
    _internal_set_model_identifier(from._internal_model_identifier());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void OnModelValueChangedEventProto::CopyFrom(const OnModelValueChangedEventProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.OnModelValueChangedEventProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OnModelValueChangedEventProto::IsInitialized() const {
  return true;
}

void OnModelValueChangedEventProto::InternalSwap(OnModelValueChangedEventProto* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &model_identifier_, lhs_arena,
      &other->model_identifier_, rhs_arena
  );
}

std::string OnModelValueChangedEventProto::GetTypeName() const {
  return "autofill_assistant.OnModelValueChangedEventProto";
}


// ===================================================================

class OnViewClickedEventProto::_Internal {
 public:
  using HasBits = decltype(std::declval<OnViewClickedEventProto>()._has_bits_);
  static void set_has_view_identifier(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

OnViewClickedEventProto::OnViewClickedEventProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.OnViewClickedEventProto)
}
OnViewClickedEventProto::OnViewClickedEventProto(const OnViewClickedEventProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  view_identifier_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    view_identifier_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_view_identifier()) {
    view_identifier_.Set(from._internal_view_identifier(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.OnViewClickedEventProto)
}

inline void OnViewClickedEventProto::SharedCtor() {
view_identifier_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  view_identifier_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

OnViewClickedEventProto::~OnViewClickedEventProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.OnViewClickedEventProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void OnViewClickedEventProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  view_identifier_.Destroy();
}

void OnViewClickedEventProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void OnViewClickedEventProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.OnViewClickedEventProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    view_identifier_.ClearNonDefaultToEmpty();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* OnViewClickedEventProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string view_identifier = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_view_identifier();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* OnViewClickedEventProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.OnViewClickedEventProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string view_identifier = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_view_identifier(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.OnViewClickedEventProto)
  return target;
}

size_t OnViewClickedEventProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.OnViewClickedEventProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string view_identifier = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_view_identifier());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void OnViewClickedEventProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const OnViewClickedEventProto*>(
      &from));
}

void OnViewClickedEventProto::MergeFrom(const OnViewClickedEventProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.OnViewClickedEventProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_view_identifier()) {
    _internal_set_view_identifier(from._internal_view_identifier());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void OnViewClickedEventProto::CopyFrom(const OnViewClickedEventProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.OnViewClickedEventProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OnViewClickedEventProto::IsInitialized() const {
  return true;
}

void OnViewClickedEventProto::InternalSwap(OnViewClickedEventProto* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &view_identifier_, lhs_arena,
      &other->view_identifier_, rhs_arena
  );
}

std::string OnViewClickedEventProto::GetTypeName() const {
  return "autofill_assistant.OnViewClickedEventProto";
}


// ===================================================================

class OnUserActionCalled::_Internal {
 public:
  using HasBits = decltype(std::declval<OnUserActionCalled>()._has_bits_);
  static void set_has_user_action_identifier(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

OnUserActionCalled::OnUserActionCalled(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.OnUserActionCalled)
}
OnUserActionCalled::OnUserActionCalled(const OnUserActionCalled& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  user_action_identifier_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    user_action_identifier_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_user_action_identifier()) {
    user_action_identifier_.Set(from._internal_user_action_identifier(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.OnUserActionCalled)
}

inline void OnUserActionCalled::SharedCtor() {
user_action_identifier_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  user_action_identifier_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

OnUserActionCalled::~OnUserActionCalled() {
  // @@protoc_insertion_point(destructor:autofill_assistant.OnUserActionCalled)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void OnUserActionCalled::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  user_action_identifier_.Destroy();
}

void OnUserActionCalled::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void OnUserActionCalled::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.OnUserActionCalled)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    user_action_identifier_.ClearNonDefaultToEmpty();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* OnUserActionCalled::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string user_action_identifier = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_user_action_identifier();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* OnUserActionCalled::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.OnUserActionCalled)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string user_action_identifier = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_user_action_identifier(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.OnUserActionCalled)
  return target;
}

size_t OnUserActionCalled::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.OnUserActionCalled)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string user_action_identifier = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_user_action_identifier());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void OnUserActionCalled::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const OnUserActionCalled*>(
      &from));
}

void OnUserActionCalled::MergeFrom(const OnUserActionCalled& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.OnUserActionCalled)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_user_action_identifier()) {
    _internal_set_user_action_identifier(from._internal_user_action_identifier());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void OnUserActionCalled::CopyFrom(const OnUserActionCalled& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.OnUserActionCalled)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OnUserActionCalled::IsInitialized() const {
  return true;
}

void OnUserActionCalled::InternalSwap(OnUserActionCalled* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &user_action_identifier_, lhs_arena,
      &other->user_action_identifier_, rhs_arena
  );
}

std::string OnUserActionCalled::GetTypeName() const {
  return "autofill_assistant.OnUserActionCalled";
}


// ===================================================================

class OnTextLinkClickedProto::_Internal {
 public:
  using HasBits = decltype(std::declval<OnTextLinkClickedProto>()._has_bits_);
  static void set_has_text_link(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

OnTextLinkClickedProto::OnTextLinkClickedProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.OnTextLinkClickedProto)
}
OnTextLinkClickedProto::OnTextLinkClickedProto(const OnTextLinkClickedProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  text_link_ = from.text_link_;
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.OnTextLinkClickedProto)
}

inline void OnTextLinkClickedProto::SharedCtor() {
text_link_ = 0;
}

OnTextLinkClickedProto::~OnTextLinkClickedProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.OnTextLinkClickedProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void OnTextLinkClickedProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void OnTextLinkClickedProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void OnTextLinkClickedProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.OnTextLinkClickedProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  text_link_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* OnTextLinkClickedProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 text_link = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_text_link(&has_bits);
          text_link_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* OnTextLinkClickedProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.OnTextLinkClickedProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 text_link = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_text_link(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.OnTextLinkClickedProto)
  return target;
}

size_t OnTextLinkClickedProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.OnTextLinkClickedProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional int32 text_link = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_text_link());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void OnTextLinkClickedProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const OnTextLinkClickedProto*>(
      &from));
}

void OnTextLinkClickedProto::MergeFrom(const OnTextLinkClickedProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.OnTextLinkClickedProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_text_link()) {
    _internal_set_text_link(from._internal_text_link());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void OnTextLinkClickedProto::CopyFrom(const OnTextLinkClickedProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.OnTextLinkClickedProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OnTextLinkClickedProto::IsInitialized() const {
  return true;
}

void OnTextLinkClickedProto::InternalSwap(OnTextLinkClickedProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(text_link_, other->text_link_);
}

std::string OnTextLinkClickedProto::GetTypeName() const {
  return "autofill_assistant.OnTextLinkClickedProto";
}


// ===================================================================

class OnPopupDismissedProto::_Internal {
 public:
  using HasBits = decltype(std::declval<OnPopupDismissedProto>()._has_bits_);
  static void set_has_popup_identifier(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

OnPopupDismissedProto::OnPopupDismissedProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.OnPopupDismissedProto)
}
OnPopupDismissedProto::OnPopupDismissedProto(const OnPopupDismissedProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  popup_identifier_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    popup_identifier_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_popup_identifier()) {
    popup_identifier_.Set(from._internal_popup_identifier(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.OnPopupDismissedProto)
}

inline void OnPopupDismissedProto::SharedCtor() {
popup_identifier_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  popup_identifier_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

OnPopupDismissedProto::~OnPopupDismissedProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.OnPopupDismissedProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void OnPopupDismissedProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  popup_identifier_.Destroy();
}

void OnPopupDismissedProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void OnPopupDismissedProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.OnPopupDismissedProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    popup_identifier_.ClearNonDefaultToEmpty();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* OnPopupDismissedProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string popup_identifier = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_popup_identifier();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* OnPopupDismissedProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.OnPopupDismissedProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string popup_identifier = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_popup_identifier(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.OnPopupDismissedProto)
  return target;
}

size_t OnPopupDismissedProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.OnPopupDismissedProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string popup_identifier = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_popup_identifier());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void OnPopupDismissedProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const OnPopupDismissedProto*>(
      &from));
}

void OnPopupDismissedProto::MergeFrom(const OnPopupDismissedProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.OnPopupDismissedProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_popup_identifier()) {
    _internal_set_popup_identifier(from._internal_popup_identifier());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void OnPopupDismissedProto::CopyFrom(const OnPopupDismissedProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.OnPopupDismissedProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OnPopupDismissedProto::IsInitialized() const {
  return true;
}

void OnPopupDismissedProto::InternalSwap(OnPopupDismissedProto* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &popup_identifier_, lhs_arena,
      &other->popup_identifier_, rhs_arena
  );
}

std::string OnPopupDismissedProto::GetTypeName() const {
  return "autofill_assistant.OnPopupDismissedProto";
}


// ===================================================================

class OnViewContainerClearedProto::_Internal {
 public:
  using HasBits = decltype(std::declval<OnViewContainerClearedProto>()._has_bits_);
  static void set_has_view_identifier(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

OnViewContainerClearedProto::OnViewContainerClearedProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.OnViewContainerClearedProto)
}
OnViewContainerClearedProto::OnViewContainerClearedProto(const OnViewContainerClearedProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  view_identifier_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    view_identifier_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_view_identifier()) {
    view_identifier_.Set(from._internal_view_identifier(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.OnViewContainerClearedProto)
}

inline void OnViewContainerClearedProto::SharedCtor() {
view_identifier_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  view_identifier_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

OnViewContainerClearedProto::~OnViewContainerClearedProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.OnViewContainerClearedProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void OnViewContainerClearedProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  view_identifier_.Destroy();
}

void OnViewContainerClearedProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void OnViewContainerClearedProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.OnViewContainerClearedProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    view_identifier_.ClearNonDefaultToEmpty();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* OnViewContainerClearedProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string view_identifier = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_view_identifier();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* OnViewContainerClearedProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.OnViewContainerClearedProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string view_identifier = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_view_identifier(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.OnViewContainerClearedProto)
  return target;
}

size_t OnViewContainerClearedProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.OnViewContainerClearedProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string view_identifier = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_view_identifier());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void OnViewContainerClearedProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const OnViewContainerClearedProto*>(
      &from));
}

void OnViewContainerClearedProto::MergeFrom(const OnViewContainerClearedProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.OnViewContainerClearedProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_view_identifier()) {
    _internal_set_view_identifier(from._internal_view_identifier());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void OnViewContainerClearedProto::CopyFrom(const OnViewContainerClearedProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.OnViewContainerClearedProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OnViewContainerClearedProto::IsInitialized() const {
  return true;
}

void OnViewContainerClearedProto::InternalSwap(OnViewContainerClearedProto* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &view_identifier_, lhs_arena,
      &other->view_identifier_, rhs_arena
  );
}

std::string OnViewContainerClearedProto::GetTypeName() const {
  return "autofill_assistant.OnViewContainerClearedProto";
}


// ===================================================================

class SetModelValueProto::_Internal {
 public:
  using HasBits = decltype(std::declval<SetModelValueProto>()._has_bits_);
  static void set_has_model_identifier(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::autofill_assistant::ValueReferenceProto& value(const SetModelValueProto* msg);
  static void set_has_value(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::autofill_assistant::ValueReferenceProto&
SetModelValueProto::_Internal::value(const SetModelValueProto* msg) {
  return *msg->value_;
}
void SetModelValueProto::clear_value() {
  if (value_ != nullptr) value_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
SetModelValueProto::SetModelValueProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.SetModelValueProto)
}
SetModelValueProto::SetModelValueProto(const SetModelValueProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  model_identifier_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    model_identifier_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_model_identifier()) {
    model_identifier_.Set(from._internal_model_identifier(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_value()) {
    value_ = new ::autofill_assistant::ValueReferenceProto(*from.value_);
  } else {
    value_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.SetModelValueProto)
}

inline void SetModelValueProto::SharedCtor() {
model_identifier_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  model_identifier_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
value_ = nullptr;
}

SetModelValueProto::~SetModelValueProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.SetModelValueProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SetModelValueProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  model_identifier_.Destroy();
  if (this != internal_default_instance()) delete value_;
}

void SetModelValueProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SetModelValueProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.SetModelValueProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      model_identifier_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(value_ != nullptr);
      value_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* SetModelValueProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string model_identifier = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_model_identifier();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .autofill_assistant.ValueReferenceProto value = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_value(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SetModelValueProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.SetModelValueProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string model_identifier = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_model_identifier(), target);
  }

  // optional .autofill_assistant.ValueReferenceProto value = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::value(this),
        _Internal::value(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.SetModelValueProto)
  return target;
}

size_t SetModelValueProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.SetModelValueProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string model_identifier = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_model_identifier());
    }

    // optional .autofill_assistant.ValueReferenceProto value = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *value_);
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SetModelValueProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const SetModelValueProto*>(
      &from));
}

void SetModelValueProto::MergeFrom(const SetModelValueProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.SetModelValueProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_model_identifier(from._internal_model_identifier());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_value()->::autofill_assistant::ValueReferenceProto::MergeFrom(from._internal_value());
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SetModelValueProto::CopyFrom(const SetModelValueProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.SetModelValueProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SetModelValueProto::IsInitialized() const {
  return true;
}

void SetModelValueProto::InternalSwap(SetModelValueProto* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &model_identifier_, lhs_arena,
      &other->model_identifier_, rhs_arena
  );
  swap(value_, other->value_);
}

std::string SetModelValueProto::GetTypeName() const {
  return "autofill_assistant.SetModelValueProto";
}


// ===================================================================

class ComputeValueProto::_Internal {
 public:
  using HasBits = decltype(std::declval<ComputeValueProto>()._has_bits_);
  static const ::autofill_assistant::BooleanAndProto& boolean_and(const ComputeValueProto* msg);
  static const ::autofill_assistant::BooleanOrProto& boolean_or(const ComputeValueProto* msg);
  static const ::autofill_assistant::BooleanNotProto& boolean_not(const ComputeValueProto* msg);
  static const ::autofill_assistant::ToStringProto& to_string(const ComputeValueProto* msg);
  static const ::autofill_assistant::ValueComparisonProto& comparison(const ComputeValueProto* msg);
  static const ::autofill_assistant::IntegerSumProto& integer_sum(const ComputeValueProto* msg);
  static const ::autofill_assistant::CreateCreditCardResponseProto& create_credit_card_response(const ComputeValueProto* msg);
  static const ::autofill_assistant::CreateLoginOptionResponseProto& create_login_option_response(const ComputeValueProto* msg);
  static const ::autofill_assistant::StringEmptyProto& string_empty(const ComputeValueProto* msg);
  static void set_has_result_model_identifier(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::autofill_assistant::BooleanAndProto&
ComputeValueProto::_Internal::boolean_and(const ComputeValueProto* msg) {
  return *msg->kind_.boolean_and_;
}
const ::autofill_assistant::BooleanOrProto&
ComputeValueProto::_Internal::boolean_or(const ComputeValueProto* msg) {
  return *msg->kind_.boolean_or_;
}
const ::autofill_assistant::BooleanNotProto&
ComputeValueProto::_Internal::boolean_not(const ComputeValueProto* msg) {
  return *msg->kind_.boolean_not_;
}
const ::autofill_assistant::ToStringProto&
ComputeValueProto::_Internal::to_string(const ComputeValueProto* msg) {
  return *msg->kind_.to_string_;
}
const ::autofill_assistant::ValueComparisonProto&
ComputeValueProto::_Internal::comparison(const ComputeValueProto* msg) {
  return *msg->kind_.comparison_;
}
const ::autofill_assistant::IntegerSumProto&
ComputeValueProto::_Internal::integer_sum(const ComputeValueProto* msg) {
  return *msg->kind_.integer_sum_;
}
const ::autofill_assistant::CreateCreditCardResponseProto&
ComputeValueProto::_Internal::create_credit_card_response(const ComputeValueProto* msg) {
  return *msg->kind_.create_credit_card_response_;
}
const ::autofill_assistant::CreateLoginOptionResponseProto&
ComputeValueProto::_Internal::create_login_option_response(const ComputeValueProto* msg) {
  return *msg->kind_.create_login_option_response_;
}
const ::autofill_assistant::StringEmptyProto&
ComputeValueProto::_Internal::string_empty(const ComputeValueProto* msg) {
  return *msg->kind_.string_empty_;
}
void ComputeValueProto::set_allocated_boolean_and(::autofill_assistant::BooleanAndProto* boolean_and) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_kind();
  if (boolean_and) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(boolean_and);
    if (message_arena != submessage_arena) {
      boolean_and = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, boolean_and, submessage_arena);
    }
    set_has_boolean_and();
    kind_.boolean_and_ = boolean_and;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ComputeValueProto.boolean_and)
}
void ComputeValueProto::set_allocated_boolean_or(::autofill_assistant::BooleanOrProto* boolean_or) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_kind();
  if (boolean_or) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(boolean_or);
    if (message_arena != submessage_arena) {
      boolean_or = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, boolean_or, submessage_arena);
    }
    set_has_boolean_or();
    kind_.boolean_or_ = boolean_or;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ComputeValueProto.boolean_or)
}
void ComputeValueProto::set_allocated_boolean_not(::autofill_assistant::BooleanNotProto* boolean_not) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_kind();
  if (boolean_not) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(boolean_not);
    if (message_arena != submessage_arena) {
      boolean_not = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, boolean_not, submessage_arena);
    }
    set_has_boolean_not();
    kind_.boolean_not_ = boolean_not;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ComputeValueProto.boolean_not)
}
void ComputeValueProto::set_allocated_to_string(::autofill_assistant::ToStringProto* to_string) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_kind();
  if (to_string) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(to_string);
    if (message_arena != submessage_arena) {
      to_string = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, to_string, submessage_arena);
    }
    set_has_to_string();
    kind_.to_string_ = to_string;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ComputeValueProto.to_string)
}
void ComputeValueProto::set_allocated_comparison(::autofill_assistant::ValueComparisonProto* comparison) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_kind();
  if (comparison) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(comparison);
    if (message_arena != submessage_arena) {
      comparison = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, comparison, submessage_arena);
    }
    set_has_comparison();
    kind_.comparison_ = comparison;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ComputeValueProto.comparison)
}
void ComputeValueProto::set_allocated_integer_sum(::autofill_assistant::IntegerSumProto* integer_sum) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_kind();
  if (integer_sum) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(integer_sum);
    if (message_arena != submessage_arena) {
      integer_sum = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, integer_sum, submessage_arena);
    }
    set_has_integer_sum();
    kind_.integer_sum_ = integer_sum;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ComputeValueProto.integer_sum)
}
void ComputeValueProto::set_allocated_create_credit_card_response(::autofill_assistant::CreateCreditCardResponseProto* create_credit_card_response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_kind();
  if (create_credit_card_response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(create_credit_card_response);
    if (message_arena != submessage_arena) {
      create_credit_card_response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, create_credit_card_response, submessage_arena);
    }
    set_has_create_credit_card_response();
    kind_.create_credit_card_response_ = create_credit_card_response;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ComputeValueProto.create_credit_card_response)
}
void ComputeValueProto::set_allocated_create_login_option_response(::autofill_assistant::CreateLoginOptionResponseProto* create_login_option_response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_kind();
  if (create_login_option_response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(create_login_option_response);
    if (message_arena != submessage_arena) {
      create_login_option_response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, create_login_option_response, submessage_arena);
    }
    set_has_create_login_option_response();
    kind_.create_login_option_response_ = create_login_option_response;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ComputeValueProto.create_login_option_response)
}
void ComputeValueProto::set_allocated_string_empty(::autofill_assistant::StringEmptyProto* string_empty) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_kind();
  if (string_empty) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(string_empty);
    if (message_arena != submessage_arena) {
      string_empty = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, string_empty, submessage_arena);
    }
    set_has_string_empty();
    kind_.string_empty_ = string_empty;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ComputeValueProto.string_empty)
}
ComputeValueProto::ComputeValueProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.ComputeValueProto)
}
ComputeValueProto::ComputeValueProto(const ComputeValueProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  result_model_identifier_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    result_model_identifier_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_result_model_identifier()) {
    result_model_identifier_.Set(from._internal_result_model_identifier(), 
      GetArenaForAllocation());
  }
  clear_has_kind();
  switch (from.kind_case()) {
    case kBooleanAnd: {
      _internal_mutable_boolean_and()->::autofill_assistant::BooleanAndProto::MergeFrom(from._internal_boolean_and());
      break;
    }
    case kBooleanOr: {
      _internal_mutable_boolean_or()->::autofill_assistant::BooleanOrProto::MergeFrom(from._internal_boolean_or());
      break;
    }
    case kBooleanNot: {
      _internal_mutable_boolean_not()->::autofill_assistant::BooleanNotProto::MergeFrom(from._internal_boolean_not());
      break;
    }
    case kToString: {
      _internal_mutable_to_string()->::autofill_assistant::ToStringProto::MergeFrom(from._internal_to_string());
      break;
    }
    case kComparison: {
      _internal_mutable_comparison()->::autofill_assistant::ValueComparisonProto::MergeFrom(from._internal_comparison());
      break;
    }
    case kIntegerSum: {
      _internal_mutable_integer_sum()->::autofill_assistant::IntegerSumProto::MergeFrom(from._internal_integer_sum());
      break;
    }
    case kCreateCreditCardResponse: {
      _internal_mutable_create_credit_card_response()->::autofill_assistant::CreateCreditCardResponseProto::MergeFrom(from._internal_create_credit_card_response());
      break;
    }
    case kCreateLoginOptionResponse: {
      _internal_mutable_create_login_option_response()->::autofill_assistant::CreateLoginOptionResponseProto::MergeFrom(from._internal_create_login_option_response());
      break;
    }
    case kStringEmpty: {
      _internal_mutable_string_empty()->::autofill_assistant::StringEmptyProto::MergeFrom(from._internal_string_empty());
      break;
    }
    case KIND_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.ComputeValueProto)
}

inline void ComputeValueProto::SharedCtor() {
result_model_identifier_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  result_model_identifier_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
clear_has_kind();
}

ComputeValueProto::~ComputeValueProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.ComputeValueProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ComputeValueProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  result_model_identifier_.Destroy();
  if (has_kind()) {
    clear_kind();
  }
}

void ComputeValueProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ComputeValueProto::clear_kind() {
// @@protoc_insertion_point(one_of_clear_start:autofill_assistant.ComputeValueProto)
  switch (kind_case()) {
    case kBooleanAnd: {
      if (GetArenaForAllocation() == nullptr) {
        delete kind_.boolean_and_;
      }
      break;
    }
    case kBooleanOr: {
      if (GetArenaForAllocation() == nullptr) {
        delete kind_.boolean_or_;
      }
      break;
    }
    case kBooleanNot: {
      if (GetArenaForAllocation() == nullptr) {
        delete kind_.boolean_not_;
      }
      break;
    }
    case kToString: {
      if (GetArenaForAllocation() == nullptr) {
        delete kind_.to_string_;
      }
      break;
    }
    case kComparison: {
      if (GetArenaForAllocation() == nullptr) {
        delete kind_.comparison_;
      }
      break;
    }
    case kIntegerSum: {
      if (GetArenaForAllocation() == nullptr) {
        delete kind_.integer_sum_;
      }
      break;
    }
    case kCreateCreditCardResponse: {
      if (GetArenaForAllocation() == nullptr) {
        delete kind_.create_credit_card_response_;
      }
      break;
    }
    case kCreateLoginOptionResponse: {
      if (GetArenaForAllocation() == nullptr) {
        delete kind_.create_login_option_response_;
      }
      break;
    }
    case kStringEmpty: {
      if (GetArenaForAllocation() == nullptr) {
        delete kind_.string_empty_;
      }
      break;
    }
    case KIND_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = KIND_NOT_SET;
}


void ComputeValueProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.ComputeValueProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    result_model_identifier_.ClearNonDefaultToEmpty();
  }
  clear_kind();
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ComputeValueProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string result_model_identifier = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_result_model_identifier();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.BooleanAndProto boolean_and = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_boolean_and(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.BooleanOrProto boolean_or = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_boolean_or(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.BooleanNotProto boolean_not = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_boolean_not(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.ToStringProto to_string = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_to_string(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.ValueComparisonProto comparison = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_comparison(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.IntegerSumProto integer_sum = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_integer_sum(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.CreateCreditCardResponseProto create_credit_card_response = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_create_credit_card_response(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.CreateLoginOptionResponseProto create_login_option_response = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_create_login_option_response(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.StringEmptyProto string_empty = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_string_empty(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ComputeValueProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.ComputeValueProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string result_model_identifier = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_result_model_identifier(), target);
  }

  switch (kind_case()) {
    case kBooleanAnd: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, _Internal::boolean_and(this),
          _Internal::boolean_and(this).GetCachedSize(), target, stream);
      break;
    }
    case kBooleanOr: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, _Internal::boolean_or(this),
          _Internal::boolean_or(this).GetCachedSize(), target, stream);
      break;
    }
    case kBooleanNot: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, _Internal::boolean_not(this),
          _Internal::boolean_not(this).GetCachedSize(), target, stream);
      break;
    }
    case kToString: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(5, _Internal::to_string(this),
          _Internal::to_string(this).GetCachedSize(), target, stream);
      break;
    }
    case kComparison: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(6, _Internal::comparison(this),
          _Internal::comparison(this).GetCachedSize(), target, stream);
      break;
    }
    case kIntegerSum: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(7, _Internal::integer_sum(this),
          _Internal::integer_sum(this).GetCachedSize(), target, stream);
      break;
    }
    case kCreateCreditCardResponse: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(8, _Internal::create_credit_card_response(this),
          _Internal::create_credit_card_response(this).GetCachedSize(), target, stream);
      break;
    }
    case kCreateLoginOptionResponse: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(9, _Internal::create_login_option_response(this),
          _Internal::create_login_option_response(this).GetCachedSize(), target, stream);
      break;
    }
    case kStringEmpty: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(10, _Internal::string_empty(this),
          _Internal::string_empty(this).GetCachedSize(), target, stream);
      break;
    }
    default: ;
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.ComputeValueProto)
  return target;
}

size_t ComputeValueProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.ComputeValueProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string result_model_identifier = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_result_model_identifier());
  }

  switch (kind_case()) {
    // .autofill_assistant.BooleanAndProto boolean_and = 2;
    case kBooleanAnd: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *kind_.boolean_and_);
      break;
    }
    // .autofill_assistant.BooleanOrProto boolean_or = 3;
    case kBooleanOr: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *kind_.boolean_or_);
      break;
    }
    // .autofill_assistant.BooleanNotProto boolean_not = 4;
    case kBooleanNot: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *kind_.boolean_not_);
      break;
    }
    // .autofill_assistant.ToStringProto to_string = 5;
    case kToString: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *kind_.to_string_);
      break;
    }
    // .autofill_assistant.ValueComparisonProto comparison = 6;
    case kComparison: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *kind_.comparison_);
      break;
    }
    // .autofill_assistant.IntegerSumProto integer_sum = 7;
    case kIntegerSum: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *kind_.integer_sum_);
      break;
    }
    // .autofill_assistant.CreateCreditCardResponseProto create_credit_card_response = 8;
    case kCreateCreditCardResponse: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *kind_.create_credit_card_response_);
      break;
    }
    // .autofill_assistant.CreateLoginOptionResponseProto create_login_option_response = 9;
    case kCreateLoginOptionResponse: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *kind_.create_login_option_response_);
      break;
    }
    // .autofill_assistant.StringEmptyProto string_empty = 10;
    case kStringEmpty: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *kind_.string_empty_);
      break;
    }
    case KIND_NOT_SET: {
      break;
    }
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ComputeValueProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ComputeValueProto*>(
      &from));
}

void ComputeValueProto::MergeFrom(const ComputeValueProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.ComputeValueProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_result_model_identifier()) {
    _internal_set_result_model_identifier(from._internal_result_model_identifier());
  }
  switch (from.kind_case()) {
    case kBooleanAnd: {
      _internal_mutable_boolean_and()->::autofill_assistant::BooleanAndProto::MergeFrom(from._internal_boolean_and());
      break;
    }
    case kBooleanOr: {
      _internal_mutable_boolean_or()->::autofill_assistant::BooleanOrProto::MergeFrom(from._internal_boolean_or());
      break;
    }
    case kBooleanNot: {
      _internal_mutable_boolean_not()->::autofill_assistant::BooleanNotProto::MergeFrom(from._internal_boolean_not());
      break;
    }
    case kToString: {
      _internal_mutable_to_string()->::autofill_assistant::ToStringProto::MergeFrom(from._internal_to_string());
      break;
    }
    case kComparison: {
      _internal_mutable_comparison()->::autofill_assistant::ValueComparisonProto::MergeFrom(from._internal_comparison());
      break;
    }
    case kIntegerSum: {
      _internal_mutable_integer_sum()->::autofill_assistant::IntegerSumProto::MergeFrom(from._internal_integer_sum());
      break;
    }
    case kCreateCreditCardResponse: {
      _internal_mutable_create_credit_card_response()->::autofill_assistant::CreateCreditCardResponseProto::MergeFrom(from._internal_create_credit_card_response());
      break;
    }
    case kCreateLoginOptionResponse: {
      _internal_mutable_create_login_option_response()->::autofill_assistant::CreateLoginOptionResponseProto::MergeFrom(from._internal_create_login_option_response());
      break;
    }
    case kStringEmpty: {
      _internal_mutable_string_empty()->::autofill_assistant::StringEmptyProto::MergeFrom(from._internal_string_empty());
      break;
    }
    case KIND_NOT_SET: {
      break;
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ComputeValueProto::CopyFrom(const ComputeValueProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.ComputeValueProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ComputeValueProto::IsInitialized() const {
  return true;
}

void ComputeValueProto::InternalSwap(ComputeValueProto* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &result_model_identifier_, lhs_arena,
      &other->result_model_identifier_, rhs_arena
  );
  swap(kind_, other->kind_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

std::string ComputeValueProto::GetTypeName() const {
  return "autofill_assistant.ComputeValueProto";
}


// ===================================================================

class BooleanAndProto::_Internal {
 public:
};

void BooleanAndProto::clear_values() {
  values_.Clear();
}
BooleanAndProto::BooleanAndProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  values_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.BooleanAndProto)
}
BooleanAndProto::BooleanAndProto(const BooleanAndProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      values_(from.values_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.BooleanAndProto)
}

inline void BooleanAndProto::SharedCtor() {
}

BooleanAndProto::~BooleanAndProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.BooleanAndProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void BooleanAndProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void BooleanAndProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void BooleanAndProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.BooleanAndProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  values_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* BooleanAndProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .autofill_assistant.ValueReferenceProto values = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_values(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* BooleanAndProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.BooleanAndProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .autofill_assistant.ValueReferenceProto values = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_values_size()); i < n; i++) {
    const auto& repfield = this->_internal_values(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.BooleanAndProto)
  return target;
}

size_t BooleanAndProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.BooleanAndProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .autofill_assistant.ValueReferenceProto values = 2;
  total_size += 1UL * this->_internal_values_size();
  for (const auto& msg : this->values_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void BooleanAndProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const BooleanAndProto*>(
      &from));
}

void BooleanAndProto::MergeFrom(const BooleanAndProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.BooleanAndProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  values_.MergeFrom(from.values_);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void BooleanAndProto::CopyFrom(const BooleanAndProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.BooleanAndProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BooleanAndProto::IsInitialized() const {
  return true;
}

void BooleanAndProto::InternalSwap(BooleanAndProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  values_.InternalSwap(&other->values_);
}

std::string BooleanAndProto::GetTypeName() const {
  return "autofill_assistant.BooleanAndProto";
}


// ===================================================================

class BooleanOrProto::_Internal {
 public:
};

void BooleanOrProto::clear_values() {
  values_.Clear();
}
BooleanOrProto::BooleanOrProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  values_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.BooleanOrProto)
}
BooleanOrProto::BooleanOrProto(const BooleanOrProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      values_(from.values_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.BooleanOrProto)
}

inline void BooleanOrProto::SharedCtor() {
}

BooleanOrProto::~BooleanOrProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.BooleanOrProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void BooleanOrProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void BooleanOrProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void BooleanOrProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.BooleanOrProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  values_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* BooleanOrProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .autofill_assistant.ValueReferenceProto values = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_values(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* BooleanOrProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.BooleanOrProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .autofill_assistant.ValueReferenceProto values = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_values_size()); i < n; i++) {
    const auto& repfield = this->_internal_values(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.BooleanOrProto)
  return target;
}

size_t BooleanOrProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.BooleanOrProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .autofill_assistant.ValueReferenceProto values = 2;
  total_size += 1UL * this->_internal_values_size();
  for (const auto& msg : this->values_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void BooleanOrProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const BooleanOrProto*>(
      &from));
}

void BooleanOrProto::MergeFrom(const BooleanOrProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.BooleanOrProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  values_.MergeFrom(from.values_);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void BooleanOrProto::CopyFrom(const BooleanOrProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.BooleanOrProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BooleanOrProto::IsInitialized() const {
  return true;
}

void BooleanOrProto::InternalSwap(BooleanOrProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  values_.InternalSwap(&other->values_);
}

std::string BooleanOrProto::GetTypeName() const {
  return "autofill_assistant.BooleanOrProto";
}


// ===================================================================

class BooleanNotProto::_Internal {
 public:
  using HasBits = decltype(std::declval<BooleanNotProto>()._has_bits_);
  static const ::autofill_assistant::ValueReferenceProto& value(const BooleanNotProto* msg);
  static void set_has_value(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::autofill_assistant::ValueReferenceProto&
BooleanNotProto::_Internal::value(const BooleanNotProto* msg) {
  return *msg->value_;
}
void BooleanNotProto::clear_value() {
  if (value_ != nullptr) value_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
BooleanNotProto::BooleanNotProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.BooleanNotProto)
}
BooleanNotProto::BooleanNotProto(const BooleanNotProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_value()) {
    value_ = new ::autofill_assistant::ValueReferenceProto(*from.value_);
  } else {
    value_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.BooleanNotProto)
}

inline void BooleanNotProto::SharedCtor() {
value_ = nullptr;
}

BooleanNotProto::~BooleanNotProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.BooleanNotProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void BooleanNotProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete value_;
}

void BooleanNotProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void BooleanNotProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.BooleanNotProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(value_ != nullptr);
    value_->Clear();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* BooleanNotProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .autofill_assistant.ValueReferenceProto value = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_value(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* BooleanNotProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.BooleanNotProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .autofill_assistant.ValueReferenceProto value = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::value(this),
        _Internal::value(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.BooleanNotProto)
  return target;
}

size_t BooleanNotProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.BooleanNotProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .autofill_assistant.ValueReferenceProto value = 2;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *value_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void BooleanNotProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const BooleanNotProto*>(
      &from));
}

void BooleanNotProto::MergeFrom(const BooleanNotProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.BooleanNotProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_value()) {
    _internal_mutable_value()->::autofill_assistant::ValueReferenceProto::MergeFrom(from._internal_value());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void BooleanNotProto::CopyFrom(const BooleanNotProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.BooleanNotProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BooleanNotProto::IsInitialized() const {
  return true;
}

void BooleanNotProto::InternalSwap(BooleanNotProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(value_, other->value_);
}

std::string BooleanNotProto::GetTypeName() const {
  return "autofill_assistant.BooleanNotProto";
}


// ===================================================================

class ToStringProto::_Internal {
 public:
  using HasBits = decltype(std::declval<ToStringProto>()._has_bits_);
  static const ::autofill_assistant::ValueReferenceProto& value(const ToStringProto* msg);
  static void set_has_value(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::autofill_assistant::DateFormatProto& date_format(const ToStringProto* msg);
  static const ::autofill_assistant::AutofillFormatProto& autofill_format(const ToStringProto* msg);
};

const ::autofill_assistant::ValueReferenceProto&
ToStringProto::_Internal::value(const ToStringProto* msg) {
  return *msg->value_;
}
const ::autofill_assistant::DateFormatProto&
ToStringProto::_Internal::date_format(const ToStringProto* msg) {
  return *msg->format_options_.date_format_;
}
const ::autofill_assistant::AutofillFormatProto&
ToStringProto::_Internal::autofill_format(const ToStringProto* msg) {
  return *msg->format_options_.autofill_format_;
}
void ToStringProto::clear_value() {
  if (value_ != nullptr) value_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
void ToStringProto::set_allocated_date_format(::autofill_assistant::DateFormatProto* date_format) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_format_options();
  if (date_format) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(date_format);
    if (message_arena != submessage_arena) {
      date_format = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, date_format, submessage_arena);
    }
    set_has_date_format();
    format_options_.date_format_ = date_format;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ToStringProto.date_format)
}
void ToStringProto::set_allocated_autofill_format(::autofill_assistant::AutofillFormatProto* autofill_format) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_format_options();
  if (autofill_format) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(autofill_format);
    if (message_arena != submessage_arena) {
      autofill_format = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, autofill_format, submessage_arena);
    }
    set_has_autofill_format();
    format_options_.autofill_format_ = autofill_format;
  }
  // @@protoc_insertion_point(field_set_allocated:autofill_assistant.ToStringProto.autofill_format)
}
ToStringProto::ToStringProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.ToStringProto)
}
ToStringProto::ToStringProto(const ToStringProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_value()) {
    value_ = new ::autofill_assistant::ValueReferenceProto(*from.value_);
  } else {
    value_ = nullptr;
  }
  clear_has_format_options();
  switch (from.format_options_case()) {
    case kDateFormat: {
      _internal_mutable_date_format()->::autofill_assistant::DateFormatProto::MergeFrom(from._internal_date_format());
      break;
    }
    case kAutofillFormat: {
      _internal_mutable_autofill_format()->::autofill_assistant::AutofillFormatProto::MergeFrom(from._internal_autofill_format());
      break;
    }
    case FORMAT_OPTIONS_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.ToStringProto)
}

inline void ToStringProto::SharedCtor() {
value_ = nullptr;
clear_has_format_options();
}

ToStringProto::~ToStringProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.ToStringProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ToStringProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete value_;
  if (has_format_options()) {
    clear_format_options();
  }
}

void ToStringProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ToStringProto::clear_format_options() {
// @@protoc_insertion_point(one_of_clear_start:autofill_assistant.ToStringProto)
  switch (format_options_case()) {
    case kDateFormat: {
      if (GetArenaForAllocation() == nullptr) {
        delete format_options_.date_format_;
      }
      break;
    }
    case kAutofillFormat: {
      if (GetArenaForAllocation() == nullptr) {
        delete format_options_.autofill_format_;
      }
      break;
    }
    case FORMAT_OPTIONS_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = FORMAT_OPTIONS_NOT_SET;
}


void ToStringProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.ToStringProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(value_ != nullptr);
    value_->Clear();
  }
  clear_format_options();
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ToStringProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .autofill_assistant.DateFormatProto date_format = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_date_format(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .autofill_assistant.ValueReferenceProto value = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_value(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .autofill_assistant.AutofillFormatProto autofill_format = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_autofill_format(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ToStringProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.ToStringProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .autofill_assistant.DateFormatProto date_format = 2;
  if (_internal_has_date_format()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::date_format(this),
        _Internal::date_format(this).GetCachedSize(), target, stream);
  }

  cached_has_bits = _has_bits_[0];
  // optional .autofill_assistant.ValueReferenceProto value = 3;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::value(this),
        _Internal::value(this).GetCachedSize(), target, stream);
  }

  // .autofill_assistant.AutofillFormatProto autofill_format = 4;
  if (_internal_has_autofill_format()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::autofill_format(this),
        _Internal::autofill_format(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.ToStringProto)
  return target;
}

size_t ToStringProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.ToStringProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .autofill_assistant.ValueReferenceProto value = 3;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *value_);
  }

  switch (format_options_case()) {
    // .autofill_assistant.DateFormatProto date_format = 2;
    case kDateFormat: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *format_options_.date_format_);
      break;
    }
    // .autofill_assistant.AutofillFormatProto autofill_format = 4;
    case kAutofillFormat: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *format_options_.autofill_format_);
      break;
    }
    case FORMAT_OPTIONS_NOT_SET: {
      break;
    }
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ToStringProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ToStringProto*>(
      &from));
}

void ToStringProto::MergeFrom(const ToStringProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.ToStringProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_value()) {
    _internal_mutable_value()->::autofill_assistant::ValueReferenceProto::MergeFrom(from._internal_value());
  }
  switch (from.format_options_case()) {
    case kDateFormat: {
      _internal_mutable_date_format()->::autofill_assistant::DateFormatProto::MergeFrom(from._internal_date_format());
      break;
    }
    case kAutofillFormat: {
      _internal_mutable_autofill_format()->::autofill_assistant::AutofillFormatProto::MergeFrom(from._internal_autofill_format());
      break;
    }
    case FORMAT_OPTIONS_NOT_SET: {
      break;
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ToStringProto::CopyFrom(const ToStringProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.ToStringProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ToStringProto::IsInitialized() const {
  return true;
}

void ToStringProto::InternalSwap(ToStringProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(value_, other->value_);
  swap(format_options_, other->format_options_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

std::string ToStringProto::GetTypeName() const {
  return "autofill_assistant.ToStringProto";
}


// ===================================================================

class DateFormatProto::_Internal {
 public:
  using HasBits = decltype(std::declval<DateFormatProto>()._has_bits_);
  static void set_has_date_format(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

DateFormatProto::DateFormatProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.DateFormatProto)
}
DateFormatProto::DateFormatProto(const DateFormatProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  date_format_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    date_format_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_date_format()) {
    date_format_.Set(from._internal_date_format(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.DateFormatProto)
}

inline void DateFormatProto::SharedCtor() {
date_format_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  date_format_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

DateFormatProto::~DateFormatProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.DateFormatProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DateFormatProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  date_format_.Destroy();
}

void DateFormatProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void DateFormatProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.DateFormatProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    date_format_.ClearNonDefaultToEmpty();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* DateFormatProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string date_format = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_date_format();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DateFormatProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.DateFormatProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string date_format = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_date_format(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.DateFormatProto)
  return target;
}

size_t DateFormatProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.DateFormatProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string date_format = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_date_format());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DateFormatProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DateFormatProto*>(
      &from));
}

void DateFormatProto::MergeFrom(const DateFormatProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.DateFormatProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_date_format()) {
    _internal_set_date_format(from._internal_date_format());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DateFormatProto::CopyFrom(const DateFormatProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.DateFormatProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DateFormatProto::IsInitialized() const {
  return true;
}

void DateFormatProto::InternalSwap(DateFormatProto* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &date_format_, lhs_arena,
      &other->date_format_, rhs_arena
  );
}

std::string DateFormatProto::GetTypeName() const {
  return "autofill_assistant.DateFormatProto";
}


// ===================================================================

class AutofillFormatProto::_Internal {
 public:
  using HasBits = decltype(std::declval<AutofillFormatProto>()._has_bits_);
  static const ::autofill_assistant::ValueExpression& value_expression(const AutofillFormatProto* msg);
  static void set_has_value_expression(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_locale(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::autofill_assistant::ValueExpression&
AutofillFormatProto::_Internal::value_expression(const AutofillFormatProto* msg) {
  return *msg->value_expression_;
}
void AutofillFormatProto::clear_value_expression() {
  if (value_expression_ != nullptr) value_expression_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
AutofillFormatProto::AutofillFormatProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.AutofillFormatProto)
}
AutofillFormatProto::AutofillFormatProto(const AutofillFormatProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  locale_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    locale_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_locale()) {
    locale_.Set(from._internal_locale(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_value_expression()) {
    value_expression_ = new ::autofill_assistant::ValueExpression(*from.value_expression_);
  } else {
    value_expression_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.AutofillFormatProto)
}

inline void AutofillFormatProto::SharedCtor() {
locale_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  locale_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
value_expression_ = nullptr;
}

AutofillFormatProto::~AutofillFormatProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.AutofillFormatProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AutofillFormatProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  locale_.Destroy();
  if (this != internal_default_instance()) delete value_expression_;
}

void AutofillFormatProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void AutofillFormatProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.AutofillFormatProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      locale_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(value_expression_ != nullptr);
      value_expression_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* AutofillFormatProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string locale = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_locale();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .autofill_assistant.ValueExpression value_expression = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_value_expression(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AutofillFormatProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.AutofillFormatProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string locale = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_locale(), target);
  }

  // optional .autofill_assistant.ValueExpression value_expression = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::value_expression(this),
        _Internal::value_expression(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.AutofillFormatProto)
  return target;
}

size_t AutofillFormatProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.AutofillFormatProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string locale = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_locale());
    }

    // optional .autofill_assistant.ValueExpression value_expression = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *value_expression_);
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void AutofillFormatProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const AutofillFormatProto*>(
      &from));
}

void AutofillFormatProto::MergeFrom(const AutofillFormatProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.AutofillFormatProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_locale(from._internal_locale());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_value_expression()->::autofill_assistant::ValueExpression::MergeFrom(from._internal_value_expression());
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void AutofillFormatProto::CopyFrom(const AutofillFormatProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.AutofillFormatProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AutofillFormatProto::IsInitialized() const {
  return true;
}

void AutofillFormatProto::InternalSwap(AutofillFormatProto* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &locale_, lhs_arena,
      &other->locale_, rhs_arena
  );
  swap(value_expression_, other->value_expression_);
}

std::string AutofillFormatProto::GetTypeName() const {
  return "autofill_assistant.AutofillFormatProto";
}


// ===================================================================

class ValueComparisonProto::_Internal {
 public:
  using HasBits = decltype(std::declval<ValueComparisonProto>()._has_bits_);
  static const ::autofill_assistant::ValueReferenceProto& value_a(const ValueComparisonProto* msg);
  static void set_has_value_a(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::autofill_assistant::ValueReferenceProto& value_b(const ValueComparisonProto* msg);
  static void set_has_value_b(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_mode(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::autofill_assistant::ValueReferenceProto&
ValueComparisonProto::_Internal::value_a(const ValueComparisonProto* msg) {
  return *msg->value_a_;
}
const ::autofill_assistant::ValueReferenceProto&
ValueComparisonProto::_Internal::value_b(const ValueComparisonProto* msg) {
  return *msg->value_b_;
}
void ValueComparisonProto::clear_value_a() {
  if (value_a_ != nullptr) value_a_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
void ValueComparisonProto::clear_value_b() {
  if (value_b_ != nullptr) value_b_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
ValueComparisonProto::ValueComparisonProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.ValueComparisonProto)
}
ValueComparisonProto::ValueComparisonProto(const ValueComparisonProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_value_a()) {
    value_a_ = new ::autofill_assistant::ValueReferenceProto(*from.value_a_);
  } else {
    value_a_ = nullptr;
  }
  if (from._internal_has_value_b()) {
    value_b_ = new ::autofill_assistant::ValueReferenceProto(*from.value_b_);
  } else {
    value_b_ = nullptr;
  }
  mode_ = from.mode_;
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.ValueComparisonProto)
}

inline void ValueComparisonProto::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&value_a_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&mode_) -
    reinterpret_cast<char*>(&value_a_)) + sizeof(mode_));
}

ValueComparisonProto::~ValueComparisonProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.ValueComparisonProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ValueComparisonProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete value_a_;
  if (this != internal_default_instance()) delete value_b_;
}

void ValueComparisonProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ValueComparisonProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.ValueComparisonProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(value_a_ != nullptr);
      value_a_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(value_b_ != nullptr);
      value_b_->Clear();
    }
  }
  mode_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ValueComparisonProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .autofill_assistant.ValueComparisonProto.Mode mode = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::autofill_assistant::ValueComparisonProto_Mode_IsValid(val))) {
            _internal_set_mode(static_cast<::autofill_assistant::ValueComparisonProto_Mode>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .autofill_assistant.ValueReferenceProto value_a = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_value_a(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .autofill_assistant.ValueReferenceProto value_b = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_value_b(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ValueComparisonProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.ValueComparisonProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .autofill_assistant.ValueComparisonProto.Mode mode = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_mode(), target);
  }

  // optional .autofill_assistant.ValueReferenceProto value_a = 4;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::value_a(this),
        _Internal::value_a(this).GetCachedSize(), target, stream);
  }

  // optional .autofill_assistant.ValueReferenceProto value_b = 5;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::value_b(this),
        _Internal::value_b(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.ValueComparisonProto)
  return target;
}

size_t ValueComparisonProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.ValueComparisonProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .autofill_assistant.ValueReferenceProto value_a = 4;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *value_a_);
    }

    // optional .autofill_assistant.ValueReferenceProto value_b = 5;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *value_b_);
    }

    // optional .autofill_assistant.ValueComparisonProto.Mode mode = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_mode());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ValueComparisonProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ValueComparisonProto*>(
      &from));
}

void ValueComparisonProto::MergeFrom(const ValueComparisonProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.ValueComparisonProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_value_a()->::autofill_assistant::ValueReferenceProto::MergeFrom(from._internal_value_a());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_value_b()->::autofill_assistant::ValueReferenceProto::MergeFrom(from._internal_value_b());
    }
    if (cached_has_bits & 0x00000004u) {
      mode_ = from.mode_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ValueComparisonProto::CopyFrom(const ValueComparisonProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.ValueComparisonProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ValueComparisonProto::IsInitialized() const {
  return true;
}

void ValueComparisonProto::InternalSwap(ValueComparisonProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ValueComparisonProto, mode_)
      + sizeof(ValueComparisonProto::mode_)
      - PROTOBUF_FIELD_OFFSET(ValueComparisonProto, value_a_)>(
          reinterpret_cast<char*>(&value_a_),
          reinterpret_cast<char*>(&other->value_a_));
}

std::string ValueComparisonProto::GetTypeName() const {
  return "autofill_assistant.ValueComparisonProto";
}


// ===================================================================

class IntegerSumProto::_Internal {
 public:
};

void IntegerSumProto::clear_values() {
  values_.Clear();
}
IntegerSumProto::IntegerSumProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  values_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.IntegerSumProto)
}
IntegerSumProto::IntegerSumProto(const IntegerSumProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      values_(from.values_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.IntegerSumProto)
}

inline void IntegerSumProto::SharedCtor() {
}

IntegerSumProto::~IntegerSumProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.IntegerSumProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void IntegerSumProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void IntegerSumProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void IntegerSumProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.IntegerSumProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  values_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* IntegerSumProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .autofill_assistant.ValueReferenceProto values = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_values(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* IntegerSumProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.IntegerSumProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .autofill_assistant.ValueReferenceProto values = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_values_size()); i < n; i++) {
    const auto& repfield = this->_internal_values(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.IntegerSumProto)
  return target;
}

size_t IntegerSumProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.IntegerSumProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .autofill_assistant.ValueReferenceProto values = 3;
  total_size += 1UL * this->_internal_values_size();
  for (const auto& msg : this->values_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void IntegerSumProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const IntegerSumProto*>(
      &from));
}

void IntegerSumProto::MergeFrom(const IntegerSumProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.IntegerSumProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  values_.MergeFrom(from.values_);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void IntegerSumProto::CopyFrom(const IntegerSumProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.IntegerSumProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IntegerSumProto::IsInitialized() const {
  return true;
}

void IntegerSumProto::InternalSwap(IntegerSumProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  values_.InternalSwap(&other->values_);
}

std::string IntegerSumProto::GetTypeName() const {
  return "autofill_assistant.IntegerSumProto";
}


// ===================================================================

class CreateCreditCardResponseProto::_Internal {
 public:
  using HasBits = decltype(std::declval<CreateCreditCardResponseProto>()._has_bits_);
  static const ::autofill_assistant::ValueReferenceProto& value(const CreateCreditCardResponseProto* msg);
  static void set_has_value(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::autofill_assistant::ValueReferenceProto&
CreateCreditCardResponseProto::_Internal::value(const CreateCreditCardResponseProto* msg) {
  return *msg->value_;
}
void CreateCreditCardResponseProto::clear_value() {
  if (value_ != nullptr) value_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
CreateCreditCardResponseProto::CreateCreditCardResponseProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.CreateCreditCardResponseProto)
}
CreateCreditCardResponseProto::CreateCreditCardResponseProto(const CreateCreditCardResponseProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_value()) {
    value_ = new ::autofill_assistant::ValueReferenceProto(*from.value_);
  } else {
    value_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.CreateCreditCardResponseProto)
}

inline void CreateCreditCardResponseProto::SharedCtor() {
value_ = nullptr;
}

CreateCreditCardResponseProto::~CreateCreditCardResponseProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.CreateCreditCardResponseProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CreateCreditCardResponseProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete value_;
}

void CreateCreditCardResponseProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CreateCreditCardResponseProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.CreateCreditCardResponseProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(value_ != nullptr);
    value_->Clear();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CreateCreditCardResponseProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .autofill_assistant.ValueReferenceProto value = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_value(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CreateCreditCardResponseProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.CreateCreditCardResponseProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .autofill_assistant.ValueReferenceProto value = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::value(this),
        _Internal::value(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.CreateCreditCardResponseProto)
  return target;
}

size_t CreateCreditCardResponseProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.CreateCreditCardResponseProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .autofill_assistant.ValueReferenceProto value = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *value_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CreateCreditCardResponseProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CreateCreditCardResponseProto*>(
      &from));
}

void CreateCreditCardResponseProto::MergeFrom(const CreateCreditCardResponseProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.CreateCreditCardResponseProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_value()) {
    _internal_mutable_value()->::autofill_assistant::ValueReferenceProto::MergeFrom(from._internal_value());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CreateCreditCardResponseProto::CopyFrom(const CreateCreditCardResponseProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.CreateCreditCardResponseProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CreateCreditCardResponseProto::IsInitialized() const {
  return true;
}

void CreateCreditCardResponseProto::InternalSwap(CreateCreditCardResponseProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(value_, other->value_);
}

std::string CreateCreditCardResponseProto::GetTypeName() const {
  return "autofill_assistant.CreateCreditCardResponseProto";
}


// ===================================================================

class CreateLoginOptionResponseProto::_Internal {
 public:
  using HasBits = decltype(std::declval<CreateLoginOptionResponseProto>()._has_bits_);
  static const ::autofill_assistant::ValueReferenceProto& value(const CreateLoginOptionResponseProto* msg);
  static void set_has_value(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::autofill_assistant::ValueReferenceProto&
CreateLoginOptionResponseProto::_Internal::value(const CreateLoginOptionResponseProto* msg) {
  return *msg->value_;
}
void CreateLoginOptionResponseProto::clear_value() {
  if (value_ != nullptr) value_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
CreateLoginOptionResponseProto::CreateLoginOptionResponseProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.CreateLoginOptionResponseProto)
}
CreateLoginOptionResponseProto::CreateLoginOptionResponseProto(const CreateLoginOptionResponseProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_value()) {
    value_ = new ::autofill_assistant::ValueReferenceProto(*from.value_);
  } else {
    value_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.CreateLoginOptionResponseProto)
}

inline void CreateLoginOptionResponseProto::SharedCtor() {
value_ = nullptr;
}

CreateLoginOptionResponseProto::~CreateLoginOptionResponseProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.CreateLoginOptionResponseProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CreateLoginOptionResponseProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete value_;
}

void CreateLoginOptionResponseProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CreateLoginOptionResponseProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.CreateLoginOptionResponseProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(value_ != nullptr);
    value_->Clear();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CreateLoginOptionResponseProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .autofill_assistant.ValueReferenceProto value = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_value(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CreateLoginOptionResponseProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.CreateLoginOptionResponseProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .autofill_assistant.ValueReferenceProto value = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::value(this),
        _Internal::value(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.CreateLoginOptionResponseProto)
  return target;
}

size_t CreateLoginOptionResponseProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.CreateLoginOptionResponseProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .autofill_assistant.ValueReferenceProto value = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *value_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CreateLoginOptionResponseProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CreateLoginOptionResponseProto*>(
      &from));
}

void CreateLoginOptionResponseProto::MergeFrom(const CreateLoginOptionResponseProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.CreateLoginOptionResponseProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_value()) {
    _internal_mutable_value()->::autofill_assistant::ValueReferenceProto::MergeFrom(from._internal_value());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CreateLoginOptionResponseProto::CopyFrom(const CreateLoginOptionResponseProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.CreateLoginOptionResponseProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CreateLoginOptionResponseProto::IsInitialized() const {
  return true;
}

void CreateLoginOptionResponseProto::InternalSwap(CreateLoginOptionResponseProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(value_, other->value_);
}

std::string CreateLoginOptionResponseProto::GetTypeName() const {
  return "autofill_assistant.CreateLoginOptionResponseProto";
}


// ===================================================================

class StringEmptyProto::_Internal {
 public:
  using HasBits = decltype(std::declval<StringEmptyProto>()._has_bits_);
  static const ::autofill_assistant::ValueReferenceProto& value(const StringEmptyProto* msg);
  static void set_has_value(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::autofill_assistant::ValueReferenceProto&
StringEmptyProto::_Internal::value(const StringEmptyProto* msg) {
  return *msg->value_;
}
void StringEmptyProto::clear_value() {
  if (value_ != nullptr) value_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
StringEmptyProto::StringEmptyProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.StringEmptyProto)
}
StringEmptyProto::StringEmptyProto(const StringEmptyProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_value()) {
    value_ = new ::autofill_assistant::ValueReferenceProto(*from.value_);
  } else {
    value_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.StringEmptyProto)
}

inline void StringEmptyProto::SharedCtor() {
value_ = nullptr;
}

StringEmptyProto::~StringEmptyProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.StringEmptyProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StringEmptyProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete value_;
}

void StringEmptyProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void StringEmptyProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.StringEmptyProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(value_ != nullptr);
    value_->Clear();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* StringEmptyProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .autofill_assistant.ValueReferenceProto value = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_value(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StringEmptyProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.StringEmptyProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .autofill_assistant.ValueReferenceProto value = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::value(this),
        _Internal::value(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.StringEmptyProto)
  return target;
}

size_t StringEmptyProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.StringEmptyProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .autofill_assistant.ValueReferenceProto value = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *value_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void StringEmptyProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const StringEmptyProto*>(
      &from));
}

void StringEmptyProto::MergeFrom(const StringEmptyProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.StringEmptyProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_value()) {
    _internal_mutable_value()->::autofill_assistant::ValueReferenceProto::MergeFrom(from._internal_value());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void StringEmptyProto::CopyFrom(const StringEmptyProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.StringEmptyProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StringEmptyProto::IsInitialized() const {
  return true;
}

void StringEmptyProto::InternalSwap(StringEmptyProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(value_, other->value_);
}

std::string StringEmptyProto::GetTypeName() const {
  return "autofill_assistant.StringEmptyProto";
}


// ===================================================================

class ShowInfoPopupProto::_Internal {
 public:
  using HasBits = decltype(std::declval<ShowInfoPopupProto>()._has_bits_);
  static const ::autofill_assistant::InfoPopupProto& info_popup(const ShowInfoPopupProto* msg);
  static void set_has_info_popup(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::autofill_assistant::InfoPopupProto&
ShowInfoPopupProto::_Internal::info_popup(const ShowInfoPopupProto* msg) {
  return *msg->info_popup_;
}
void ShowInfoPopupProto::clear_info_popup() {
  if (info_popup_ != nullptr) info_popup_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
ShowInfoPopupProto::ShowInfoPopupProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.ShowInfoPopupProto)
}
ShowInfoPopupProto::ShowInfoPopupProto(const ShowInfoPopupProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_info_popup()) {
    info_popup_ = new ::autofill_assistant::InfoPopupProto(*from.info_popup_);
  } else {
    info_popup_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.ShowInfoPopupProto)
}

inline void ShowInfoPopupProto::SharedCtor() {
info_popup_ = nullptr;
}

ShowInfoPopupProto::~ShowInfoPopupProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.ShowInfoPopupProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ShowInfoPopupProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete info_popup_;
}

void ShowInfoPopupProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ShowInfoPopupProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.ShowInfoPopupProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(info_popup_ != nullptr);
    info_popup_->Clear();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ShowInfoPopupProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .autofill_assistant.InfoPopupProto info_popup = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_info_popup(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ShowInfoPopupProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.ShowInfoPopupProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .autofill_assistant.InfoPopupProto info_popup = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::info_popup(this),
        _Internal::info_popup(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.ShowInfoPopupProto)
  return target;
}

size_t ShowInfoPopupProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.ShowInfoPopupProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .autofill_assistant.InfoPopupProto info_popup = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *info_popup_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ShowInfoPopupProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ShowInfoPopupProto*>(
      &from));
}

void ShowInfoPopupProto::MergeFrom(const ShowInfoPopupProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.ShowInfoPopupProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_info_popup()) {
    _internal_mutable_info_popup()->::autofill_assistant::InfoPopupProto::MergeFrom(from._internal_info_popup());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ShowInfoPopupProto::CopyFrom(const ShowInfoPopupProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.ShowInfoPopupProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ShowInfoPopupProto::IsInitialized() const {
  return true;
}

void ShowInfoPopupProto::InternalSwap(ShowInfoPopupProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(info_popup_, other->info_popup_);
}

std::string ShowInfoPopupProto::GetTypeName() const {
  return "autofill_assistant.ShowInfoPopupProto";
}


// ===================================================================

class ShowListPopupProto::_Internal {
 public:
  using HasBits = decltype(std::declval<ShowListPopupProto>()._has_bits_);
  static const ::autofill_assistant::ValueReferenceProto& item_names(const ShowListPopupProto* msg);
  static void set_has_item_names(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::autofill_assistant::ValueReferenceProto& item_types(const ShowListPopupProto* msg);
  static void set_has_item_types(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_selected_item_indices_model_identifier(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_allow_multiselect(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_selected_item_names_model_identifier(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::autofill_assistant::ValueReferenceProto&
ShowListPopupProto::_Internal::item_names(const ShowListPopupProto* msg) {
  return *msg->item_names_;
}
const ::autofill_assistant::ValueReferenceProto&
ShowListPopupProto::_Internal::item_types(const ShowListPopupProto* msg) {
  return *msg->item_types_;
}
void ShowListPopupProto::clear_item_names() {
  if (item_names_ != nullptr) item_names_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
void ShowListPopupProto::clear_item_types() {
  if (item_types_ != nullptr) item_types_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
ShowListPopupProto::ShowListPopupProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.ShowListPopupProto)
}
ShowListPopupProto::ShowListPopupProto(const ShowListPopupProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  selected_item_indices_model_identifier_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    selected_item_indices_model_identifier_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_selected_item_indices_model_identifier()) {
    selected_item_indices_model_identifier_.Set(from._internal_selected_item_indices_model_identifier(), 
      GetArenaForAllocation());
  }
  selected_item_names_model_identifier_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    selected_item_names_model_identifier_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_selected_item_names_model_identifier()) {
    selected_item_names_model_identifier_.Set(from._internal_selected_item_names_model_identifier(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_item_names()) {
    item_names_ = new ::autofill_assistant::ValueReferenceProto(*from.item_names_);
  } else {
    item_names_ = nullptr;
  }
  if (from._internal_has_item_types()) {
    item_types_ = new ::autofill_assistant::ValueReferenceProto(*from.item_types_);
  } else {
    item_types_ = nullptr;
  }
  allow_multiselect_ = from.allow_multiselect_;
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.ShowListPopupProto)
}

inline void ShowListPopupProto::SharedCtor() {
selected_item_indices_model_identifier_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  selected_item_indices_model_identifier_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
selected_item_names_model_identifier_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  selected_item_names_model_identifier_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&item_names_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&allow_multiselect_) -
    reinterpret_cast<char*>(&item_names_)) + sizeof(allow_multiselect_));
}

ShowListPopupProto::~ShowListPopupProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.ShowListPopupProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ShowListPopupProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  selected_item_indices_model_identifier_.Destroy();
  selected_item_names_model_identifier_.Destroy();
  if (this != internal_default_instance()) delete item_names_;
  if (this != internal_default_instance()) delete item_types_;
}

void ShowListPopupProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ShowListPopupProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.ShowListPopupProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      selected_item_indices_model_identifier_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      selected_item_names_model_identifier_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(item_names_ != nullptr);
      item_names_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(item_types_ != nullptr);
      item_types_->Clear();
    }
  }
  allow_multiselect_ = false;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ShowListPopupProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string selected_item_indices_model_identifier = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_selected_item_indices_model_identifier();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool allow_multiselect = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_allow_multiselect(&has_bits);
          allow_multiselect_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string selected_item_names_model_identifier = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_selected_item_names_model_identifier();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .autofill_assistant.ValueReferenceProto item_names = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_item_names(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .autofill_assistant.ValueReferenceProto item_types = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_item_types(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ShowListPopupProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.ShowListPopupProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string selected_item_indices_model_identifier = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_selected_item_indices_model_identifier(), target);
  }

  // optional bool allow_multiselect = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_allow_multiselect(), target);
  }

  // optional string selected_item_names_model_identifier = 5;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_selected_item_names_model_identifier(), target);
  }

  // optional .autofill_assistant.ValueReferenceProto item_names = 6;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::item_names(this),
        _Internal::item_names(this).GetCachedSize(), target, stream);
  }

  // optional .autofill_assistant.ValueReferenceProto item_types = 7;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::item_types(this),
        _Internal::item_types(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.ShowListPopupProto)
  return target;
}

size_t ShowListPopupProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.ShowListPopupProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional string selected_item_indices_model_identifier = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_selected_item_indices_model_identifier());
    }

    // optional string selected_item_names_model_identifier = 5;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_selected_item_names_model_identifier());
    }

    // optional .autofill_assistant.ValueReferenceProto item_names = 6;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *item_names_);
    }

    // optional .autofill_assistant.ValueReferenceProto item_types = 7;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *item_types_);
    }

    // optional bool allow_multiselect = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 1;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ShowListPopupProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ShowListPopupProto*>(
      &from));
}

void ShowListPopupProto::MergeFrom(const ShowListPopupProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.ShowListPopupProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_selected_item_indices_model_identifier(from._internal_selected_item_indices_model_identifier());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_selected_item_names_model_identifier(from._internal_selected_item_names_model_identifier());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_item_names()->::autofill_assistant::ValueReferenceProto::MergeFrom(from._internal_item_names());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_mutable_item_types()->::autofill_assistant::ValueReferenceProto::MergeFrom(from._internal_item_types());
    }
    if (cached_has_bits & 0x00000010u) {
      allow_multiselect_ = from.allow_multiselect_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ShowListPopupProto::CopyFrom(const ShowListPopupProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.ShowListPopupProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ShowListPopupProto::IsInitialized() const {
  return true;
}

void ShowListPopupProto::InternalSwap(ShowListPopupProto* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &selected_item_indices_model_identifier_, lhs_arena,
      &other->selected_item_indices_model_identifier_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &selected_item_names_model_identifier_, lhs_arena,
      &other->selected_item_names_model_identifier_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ShowListPopupProto, allow_multiselect_)
      + sizeof(ShowListPopupProto::allow_multiselect_)
      - PROTOBUF_FIELD_OFFSET(ShowListPopupProto, item_names_)>(
          reinterpret_cast<char*>(&item_names_),
          reinterpret_cast<char*>(&other->item_names_));
}

std::string ShowListPopupProto::GetTypeName() const {
  return "autofill_assistant.ShowListPopupProto";
}


// ===================================================================

class SetUserActionsProto::_Internal {
 public:
  using HasBits = decltype(std::declval<SetUserActionsProto>()._has_bits_);
  static const ::autofill_assistant::ValueReferenceProto& user_actions(const SetUserActionsProto* msg);
  static void set_has_user_actions(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::autofill_assistant::ValueReferenceProto&
SetUserActionsProto::_Internal::user_actions(const SetUserActionsProto* msg) {
  return *msg->user_actions_;
}
void SetUserActionsProto::clear_user_actions() {
  if (user_actions_ != nullptr) user_actions_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
SetUserActionsProto::SetUserActionsProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.SetUserActionsProto)
}
SetUserActionsProto::SetUserActionsProto(const SetUserActionsProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_user_actions()) {
    user_actions_ = new ::autofill_assistant::ValueReferenceProto(*from.user_actions_);
  } else {
    user_actions_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.SetUserActionsProto)
}

inline void SetUserActionsProto::SharedCtor() {
user_actions_ = nullptr;
}

SetUserActionsProto::~SetUserActionsProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.SetUserActionsProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SetUserActionsProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete user_actions_;
}

void SetUserActionsProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SetUserActionsProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.SetUserActionsProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(user_actions_ != nullptr);
    user_actions_->Clear();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* SetUserActionsProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .autofill_assistant.ValueReferenceProto user_actions = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_user_actions(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SetUserActionsProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.SetUserActionsProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .autofill_assistant.ValueReferenceProto user_actions = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::user_actions(this),
        _Internal::user_actions(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.SetUserActionsProto)
  return target;
}

size_t SetUserActionsProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.SetUserActionsProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .autofill_assistant.ValueReferenceProto user_actions = 2;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *user_actions_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SetUserActionsProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const SetUserActionsProto*>(
      &from));
}

void SetUserActionsProto::MergeFrom(const SetUserActionsProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.SetUserActionsProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_user_actions()) {
    _internal_mutable_user_actions()->::autofill_assistant::ValueReferenceProto::MergeFrom(from._internal_user_actions());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SetUserActionsProto::CopyFrom(const SetUserActionsProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.SetUserActionsProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SetUserActionsProto::IsInitialized() const {
  return true;
}

void SetUserActionsProto::InternalSwap(SetUserActionsProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(user_actions_, other->user_actions_);
}

std::string SetUserActionsProto::GetTypeName() const {
  return "autofill_assistant.SetUserActionsProto";
}


// ===================================================================

class ToggleUserActionProto::_Internal {
 public:
  using HasBits = decltype(std::declval<ToggleUserActionProto>()._has_bits_);
  static void set_has_user_actions_model_identifier(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_user_action_identifier(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::autofill_assistant::ValueReferenceProto& enabled(const ToggleUserActionProto* msg);
  static void set_has_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::autofill_assistant::ValueReferenceProto&
ToggleUserActionProto::_Internal::enabled(const ToggleUserActionProto* msg) {
  return *msg->enabled_;
}
void ToggleUserActionProto::clear_enabled() {
  if (enabled_ != nullptr) enabled_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
ToggleUserActionProto::ToggleUserActionProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.ToggleUserActionProto)
}
ToggleUserActionProto::ToggleUserActionProto(const ToggleUserActionProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  user_actions_model_identifier_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    user_actions_model_identifier_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_user_actions_model_identifier()) {
    user_actions_model_identifier_.Set(from._internal_user_actions_model_identifier(), 
      GetArenaForAllocation());
  }
  user_action_identifier_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    user_action_identifier_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_user_action_identifier()) {
    user_action_identifier_.Set(from._internal_user_action_identifier(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_enabled()) {
    enabled_ = new ::autofill_assistant::ValueReferenceProto(*from.enabled_);
  } else {
    enabled_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.ToggleUserActionProto)
}

inline void ToggleUserActionProto::SharedCtor() {
user_actions_model_identifier_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  user_actions_model_identifier_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
user_action_identifier_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  user_action_identifier_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
enabled_ = nullptr;
}

ToggleUserActionProto::~ToggleUserActionProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.ToggleUserActionProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ToggleUserActionProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  user_actions_model_identifier_.Destroy();
  user_action_identifier_.Destroy();
  if (this != internal_default_instance()) delete enabled_;
}

void ToggleUserActionProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ToggleUserActionProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.ToggleUserActionProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      user_actions_model_identifier_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      user_action_identifier_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(enabled_ != nullptr);
      enabled_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ToggleUserActionProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string user_actions_model_identifier = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_user_actions_model_identifier();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string user_action_identifier = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_user_action_identifier();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .autofill_assistant.ValueReferenceProto enabled = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_enabled(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ToggleUserActionProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.ToggleUserActionProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string user_actions_model_identifier = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_user_actions_model_identifier(), target);
  }

  // optional string user_action_identifier = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_user_action_identifier(), target);
  }

  // optional .autofill_assistant.ValueReferenceProto enabled = 4;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::enabled(this),
        _Internal::enabled(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.ToggleUserActionProto)
  return target;
}

size_t ToggleUserActionProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.ToggleUserActionProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string user_actions_model_identifier = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_user_actions_model_identifier());
    }

    // optional string user_action_identifier = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_user_action_identifier());
    }

    // optional .autofill_assistant.ValueReferenceProto enabled = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *enabled_);
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ToggleUserActionProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ToggleUserActionProto*>(
      &from));
}

void ToggleUserActionProto::MergeFrom(const ToggleUserActionProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.ToggleUserActionProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_user_actions_model_identifier(from._internal_user_actions_model_identifier());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_user_action_identifier(from._internal_user_action_identifier());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_enabled()->::autofill_assistant::ValueReferenceProto::MergeFrom(from._internal_enabled());
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ToggleUserActionProto::CopyFrom(const ToggleUserActionProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.ToggleUserActionProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ToggleUserActionProto::IsInitialized() const {
  return true;
}

void ToggleUserActionProto::InternalSwap(ToggleUserActionProto* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &user_actions_model_identifier_, lhs_arena,
      &other->user_actions_model_identifier_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &user_action_identifier_, lhs_arena,
      &other->user_action_identifier_, rhs_arena
  );
  swap(enabled_, other->enabled_);
}

std::string ToggleUserActionProto::GetTypeName() const {
  return "autofill_assistant.ToggleUserActionProto";
}


// ===================================================================

class EndActionProto::_Internal {
 public:
  using HasBits = decltype(std::declval<EndActionProto>()._has_bits_);
  static void set_has_status(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

EndActionProto::EndActionProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.EndActionProto)
}
EndActionProto::EndActionProto(const EndActionProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  status_ = from.status_;
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.EndActionProto)
}

inline void EndActionProto::SharedCtor() {
status_ = 0;
}

EndActionProto::~EndActionProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.EndActionProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void EndActionProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void EndActionProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void EndActionProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.EndActionProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  status_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* EndActionProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .autofill_assistant.ProcessedActionStatusProto status = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::autofill_assistant::ProcessedActionStatusProto_IsValid(val))) {
            _internal_set_status(static_cast<::autofill_assistant::ProcessedActionStatusProto>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* EndActionProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.EndActionProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .autofill_assistant.ProcessedActionStatusProto status = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_status(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.EndActionProto)
  return target;
}

size_t EndActionProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.EndActionProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .autofill_assistant.ProcessedActionStatusProto status = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_status());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void EndActionProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const EndActionProto*>(
      &from));
}

void EndActionProto::MergeFrom(const EndActionProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.EndActionProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_status()) {
    _internal_set_status(from._internal_status());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void EndActionProto::CopyFrom(const EndActionProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.EndActionProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EndActionProto::IsInitialized() const {
  return true;
}

void EndActionProto::InternalSwap(EndActionProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(status_, other->status_);
}

std::string EndActionProto::GetTypeName() const {
  return "autofill_assistant.EndActionProto";
}


// ===================================================================

class ShowCalendarPopupProto::_Internal {
 public:
  using HasBits = decltype(std::declval<ShowCalendarPopupProto>()._has_bits_);
  static void set_has_date_model_identifier(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::autofill_assistant::ValueReferenceProto& min_date(const ShowCalendarPopupProto* msg);
  static void set_has_min_date(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::autofill_assistant::ValueReferenceProto& max_date(const ShowCalendarPopupProto* msg);
  static void set_has_max_date(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::autofill_assistant::ValueReferenceProto&
ShowCalendarPopupProto::_Internal::min_date(const ShowCalendarPopupProto* msg) {
  return *msg->min_date_;
}
const ::autofill_assistant::ValueReferenceProto&
ShowCalendarPopupProto::_Internal::max_date(const ShowCalendarPopupProto* msg) {
  return *msg->max_date_;
}
void ShowCalendarPopupProto::clear_min_date() {
  if (min_date_ != nullptr) min_date_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
void ShowCalendarPopupProto::clear_max_date() {
  if (max_date_ != nullptr) max_date_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
ShowCalendarPopupProto::ShowCalendarPopupProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.ShowCalendarPopupProto)
}
ShowCalendarPopupProto::ShowCalendarPopupProto(const ShowCalendarPopupProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  date_model_identifier_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    date_model_identifier_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_date_model_identifier()) {
    date_model_identifier_.Set(from._internal_date_model_identifier(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_min_date()) {
    min_date_ = new ::autofill_assistant::ValueReferenceProto(*from.min_date_);
  } else {
    min_date_ = nullptr;
  }
  if (from._internal_has_max_date()) {
    max_date_ = new ::autofill_assistant::ValueReferenceProto(*from.max_date_);
  } else {
    max_date_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.ShowCalendarPopupProto)
}

inline void ShowCalendarPopupProto::SharedCtor() {
date_model_identifier_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  date_model_identifier_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&min_date_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&max_date_) -
    reinterpret_cast<char*>(&min_date_)) + sizeof(max_date_));
}

ShowCalendarPopupProto::~ShowCalendarPopupProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.ShowCalendarPopupProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ShowCalendarPopupProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  date_model_identifier_.Destroy();
  if (this != internal_default_instance()) delete min_date_;
  if (this != internal_default_instance()) delete max_date_;
}

void ShowCalendarPopupProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ShowCalendarPopupProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.ShowCalendarPopupProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      date_model_identifier_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(min_date_ != nullptr);
      min_date_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(max_date_ != nullptr);
      max_date_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ShowCalendarPopupProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string date_model_identifier = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_date_model_identifier();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .autofill_assistant.ValueReferenceProto min_date = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_min_date(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .autofill_assistant.ValueReferenceProto max_date = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_max_date(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ShowCalendarPopupProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.ShowCalendarPopupProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string date_model_identifier = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_date_model_identifier(), target);
  }

  // optional .autofill_assistant.ValueReferenceProto min_date = 4;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::min_date(this),
        _Internal::min_date(this).GetCachedSize(), target, stream);
  }

  // optional .autofill_assistant.ValueReferenceProto max_date = 5;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::max_date(this),
        _Internal::max_date(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.ShowCalendarPopupProto)
  return target;
}

size_t ShowCalendarPopupProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.ShowCalendarPopupProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string date_model_identifier = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_date_model_identifier());
    }

    // optional .autofill_assistant.ValueReferenceProto min_date = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *min_date_);
    }

    // optional .autofill_assistant.ValueReferenceProto max_date = 5;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *max_date_);
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ShowCalendarPopupProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ShowCalendarPopupProto*>(
      &from));
}

void ShowCalendarPopupProto::MergeFrom(const ShowCalendarPopupProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.ShowCalendarPopupProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_date_model_identifier(from._internal_date_model_identifier());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_min_date()->::autofill_assistant::ValueReferenceProto::MergeFrom(from._internal_min_date());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_max_date()->::autofill_assistant::ValueReferenceProto::MergeFrom(from._internal_max_date());
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ShowCalendarPopupProto::CopyFrom(const ShowCalendarPopupProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.ShowCalendarPopupProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ShowCalendarPopupProto::IsInitialized() const {
  return true;
}

void ShowCalendarPopupProto::InternalSwap(ShowCalendarPopupProto* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &date_model_identifier_, lhs_arena,
      &other->date_model_identifier_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ShowCalendarPopupProto, max_date_)
      + sizeof(ShowCalendarPopupProto::max_date_)
      - PROTOBUF_FIELD_OFFSET(ShowCalendarPopupProto, min_date_)>(
          reinterpret_cast<char*>(&min_date_),
          reinterpret_cast<char*>(&other->min_date_));
}

std::string ShowCalendarPopupProto::GetTypeName() const {
  return "autofill_assistant.ShowCalendarPopupProto";
}


// ===================================================================

class SetTextProto::_Internal {
 public:
  using HasBits = decltype(std::declval<SetTextProto>()._has_bits_);
  static const ::autofill_assistant::ValueReferenceProto& text(const SetTextProto* msg);
  static void set_has_text(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_view_identifier(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::autofill_assistant::ValueReferenceProto&
SetTextProto::_Internal::text(const SetTextProto* msg) {
  return *msg->text_;
}
void SetTextProto::clear_text() {
  if (text_ != nullptr) text_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
SetTextProto::SetTextProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.SetTextProto)
}
SetTextProto::SetTextProto(const SetTextProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  view_identifier_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    view_identifier_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_view_identifier()) {
    view_identifier_.Set(from._internal_view_identifier(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_text()) {
    text_ = new ::autofill_assistant::ValueReferenceProto(*from.text_);
  } else {
    text_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.SetTextProto)
}

inline void SetTextProto::SharedCtor() {
view_identifier_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  view_identifier_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
text_ = nullptr;
}

SetTextProto::~SetTextProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.SetTextProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SetTextProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  view_identifier_.Destroy();
  if (this != internal_default_instance()) delete text_;
}

void SetTextProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SetTextProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.SetTextProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      view_identifier_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(text_ != nullptr);
      text_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* SetTextProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string view_identifier = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_view_identifier();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .autofill_assistant.ValueReferenceProto text = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_text(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SetTextProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.SetTextProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string view_identifier = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_view_identifier(), target);
  }

  // optional .autofill_assistant.ValueReferenceProto text = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::text(this),
        _Internal::text(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.SetTextProto)
  return target;
}

size_t SetTextProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.SetTextProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string view_identifier = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_view_identifier());
    }

    // optional .autofill_assistant.ValueReferenceProto text = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *text_);
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SetTextProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const SetTextProto*>(
      &from));
}

void SetTextProto::MergeFrom(const SetTextProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.SetTextProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_view_identifier(from._internal_view_identifier());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_text()->::autofill_assistant::ValueReferenceProto::MergeFrom(from._internal_text());
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SetTextProto::CopyFrom(const SetTextProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.SetTextProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SetTextProto::IsInitialized() const {
  return true;
}

void SetTextProto::InternalSwap(SetTextProto* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &view_identifier_, lhs_arena,
      &other->view_identifier_, rhs_arena
  );
  swap(text_, other->text_);
}

std::string SetTextProto::GetTypeName() const {
  return "autofill_assistant.SetTextProto";
}


// ===================================================================

class SetViewVisibilityProto::_Internal {
 public:
  using HasBits = decltype(std::declval<SetViewVisibilityProto>()._has_bits_);
  static void set_has_view_identifier(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::autofill_assistant::ValueReferenceProto& visible(const SetViewVisibilityProto* msg);
  static void set_has_visible(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::autofill_assistant::ValueReferenceProto&
SetViewVisibilityProto::_Internal::visible(const SetViewVisibilityProto* msg) {
  return *msg->visible_;
}
void SetViewVisibilityProto::clear_visible() {
  if (visible_ != nullptr) visible_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
SetViewVisibilityProto::SetViewVisibilityProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.SetViewVisibilityProto)
}
SetViewVisibilityProto::SetViewVisibilityProto(const SetViewVisibilityProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  view_identifier_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    view_identifier_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_view_identifier()) {
    view_identifier_.Set(from._internal_view_identifier(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_visible()) {
    visible_ = new ::autofill_assistant::ValueReferenceProto(*from.visible_);
  } else {
    visible_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.SetViewVisibilityProto)
}

inline void SetViewVisibilityProto::SharedCtor() {
view_identifier_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  view_identifier_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
visible_ = nullptr;
}

SetViewVisibilityProto::~SetViewVisibilityProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.SetViewVisibilityProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SetViewVisibilityProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  view_identifier_.Destroy();
  if (this != internal_default_instance()) delete visible_;
}

void SetViewVisibilityProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SetViewVisibilityProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.SetViewVisibilityProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      view_identifier_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(visible_ != nullptr);
      visible_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* SetViewVisibilityProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string view_identifier = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_view_identifier();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .autofill_assistant.ValueReferenceProto visible = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_visible(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SetViewVisibilityProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.SetViewVisibilityProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string view_identifier = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_view_identifier(), target);
  }

  // optional .autofill_assistant.ValueReferenceProto visible = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::visible(this),
        _Internal::visible(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.SetViewVisibilityProto)
  return target;
}

size_t SetViewVisibilityProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.SetViewVisibilityProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string view_identifier = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_view_identifier());
    }

    // optional .autofill_assistant.ValueReferenceProto visible = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *visible_);
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SetViewVisibilityProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const SetViewVisibilityProto*>(
      &from));
}

void SetViewVisibilityProto::MergeFrom(const SetViewVisibilityProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.SetViewVisibilityProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_view_identifier(from._internal_view_identifier());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_visible()->::autofill_assistant::ValueReferenceProto::MergeFrom(from._internal_visible());
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SetViewVisibilityProto::CopyFrom(const SetViewVisibilityProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.SetViewVisibilityProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SetViewVisibilityProto::IsInitialized() const {
  return true;
}

void SetViewVisibilityProto::InternalSwap(SetViewVisibilityProto* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &view_identifier_, lhs_arena,
      &other->view_identifier_, rhs_arena
  );
  swap(visible_, other->visible_);
}

std::string SetViewVisibilityProto::GetTypeName() const {
  return "autofill_assistant.SetViewVisibilityProto";
}


// ===================================================================

class ShowGenericUiPopupProto::_Internal {
 public:
  using HasBits = decltype(std::declval<ShowGenericUiPopupProto>()._has_bits_);
  static const ::autofill_assistant::GenericUserInterfaceProto& generic_ui(const ShowGenericUiPopupProto* msg);
  static void set_has_generic_ui(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_popup_identifier(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::autofill_assistant::GenericUserInterfaceProto&
ShowGenericUiPopupProto::_Internal::generic_ui(const ShowGenericUiPopupProto* msg) {
  return *msg->generic_ui_;
}
ShowGenericUiPopupProto::ShowGenericUiPopupProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.ShowGenericUiPopupProto)
}
ShowGenericUiPopupProto::ShowGenericUiPopupProto(const ShowGenericUiPopupProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  popup_identifier_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    popup_identifier_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_popup_identifier()) {
    popup_identifier_.Set(from._internal_popup_identifier(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_generic_ui()) {
    generic_ui_ = new ::autofill_assistant::GenericUserInterfaceProto(*from.generic_ui_);
  } else {
    generic_ui_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.ShowGenericUiPopupProto)
}

inline void ShowGenericUiPopupProto::SharedCtor() {
popup_identifier_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  popup_identifier_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
generic_ui_ = nullptr;
}

ShowGenericUiPopupProto::~ShowGenericUiPopupProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.ShowGenericUiPopupProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ShowGenericUiPopupProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  popup_identifier_.Destroy();
  if (this != internal_default_instance()) delete generic_ui_;
}

void ShowGenericUiPopupProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ShowGenericUiPopupProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.ShowGenericUiPopupProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      popup_identifier_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(generic_ui_ != nullptr);
      generic_ui_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ShowGenericUiPopupProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .autofill_assistant.GenericUserInterfaceProto generic_ui = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_generic_ui(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string popup_identifier = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_popup_identifier();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ShowGenericUiPopupProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.ShowGenericUiPopupProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .autofill_assistant.GenericUserInterfaceProto generic_ui = 1;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::generic_ui(this),
        _Internal::generic_ui(this).GetCachedSize(), target, stream);
  }

  // optional string popup_identifier = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_popup_identifier(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.ShowGenericUiPopupProto)
  return target;
}

size_t ShowGenericUiPopupProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.ShowGenericUiPopupProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string popup_identifier = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_popup_identifier());
    }

    // optional .autofill_assistant.GenericUserInterfaceProto generic_ui = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *generic_ui_);
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ShowGenericUiPopupProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ShowGenericUiPopupProto*>(
      &from));
}

void ShowGenericUiPopupProto::MergeFrom(const ShowGenericUiPopupProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.ShowGenericUiPopupProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_popup_identifier(from._internal_popup_identifier());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_generic_ui()->::autofill_assistant::GenericUserInterfaceProto::MergeFrom(from._internal_generic_ui());
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ShowGenericUiPopupProto::CopyFrom(const ShowGenericUiPopupProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.ShowGenericUiPopupProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ShowGenericUiPopupProto::IsInitialized() const {
  return true;
}

void ShowGenericUiPopupProto::InternalSwap(ShowGenericUiPopupProto* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &popup_identifier_, lhs_arena,
      &other->popup_identifier_, rhs_arena
  );
  swap(generic_ui_, other->generic_ui_);
}

std::string ShowGenericUiPopupProto::GetTypeName() const {
  return "autofill_assistant.ShowGenericUiPopupProto";
}


// ===================================================================

class SetViewEnabledProto::_Internal {
 public:
  using HasBits = decltype(std::declval<SetViewEnabledProto>()._has_bits_);
  static void set_has_view_identifier(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::autofill_assistant::ValueReferenceProto& enabled(const SetViewEnabledProto* msg);
  static void set_has_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::autofill_assistant::ValueReferenceProto&
SetViewEnabledProto::_Internal::enabled(const SetViewEnabledProto* msg) {
  return *msg->enabled_;
}
void SetViewEnabledProto::clear_enabled() {
  if (enabled_ != nullptr) enabled_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
SetViewEnabledProto::SetViewEnabledProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.SetViewEnabledProto)
}
SetViewEnabledProto::SetViewEnabledProto(const SetViewEnabledProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  view_identifier_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    view_identifier_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_view_identifier()) {
    view_identifier_.Set(from._internal_view_identifier(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_enabled()) {
    enabled_ = new ::autofill_assistant::ValueReferenceProto(*from.enabled_);
  } else {
    enabled_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.SetViewEnabledProto)
}

inline void SetViewEnabledProto::SharedCtor() {
view_identifier_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  view_identifier_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
enabled_ = nullptr;
}

SetViewEnabledProto::~SetViewEnabledProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.SetViewEnabledProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SetViewEnabledProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  view_identifier_.Destroy();
  if (this != internal_default_instance()) delete enabled_;
}

void SetViewEnabledProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SetViewEnabledProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.SetViewEnabledProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      view_identifier_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(enabled_ != nullptr);
      enabled_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* SetViewEnabledProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string view_identifier = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_view_identifier();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .autofill_assistant.ValueReferenceProto enabled = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_enabled(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SetViewEnabledProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.SetViewEnabledProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string view_identifier = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_view_identifier(), target);
  }

  // optional .autofill_assistant.ValueReferenceProto enabled = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::enabled(this),
        _Internal::enabled(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.SetViewEnabledProto)
  return target;
}

size_t SetViewEnabledProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.SetViewEnabledProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string view_identifier = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_view_identifier());
    }

    // optional .autofill_assistant.ValueReferenceProto enabled = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *enabled_);
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SetViewEnabledProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const SetViewEnabledProto*>(
      &from));
}

void SetViewEnabledProto::MergeFrom(const SetViewEnabledProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.SetViewEnabledProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_view_identifier(from._internal_view_identifier());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_enabled()->::autofill_assistant::ValueReferenceProto::MergeFrom(from._internal_enabled());
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SetViewEnabledProto::CopyFrom(const SetViewEnabledProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.SetViewEnabledProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SetViewEnabledProto::IsInitialized() const {
  return true;
}

void SetViewEnabledProto::InternalSwap(SetViewEnabledProto* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &view_identifier_, lhs_arena,
      &other->view_identifier_, rhs_arena
  );
  swap(enabled_, other->enabled_);
}

std::string SetViewEnabledProto::GetTypeName() const {
  return "autofill_assistant.SetViewEnabledProto";
}


// ===================================================================

class CreateNestedGenericUiProto::_Internal {
 public:
  using HasBits = decltype(std::declval<CreateNestedGenericUiProto>()._has_bits_);
  static void set_has_generic_ui_identifier(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::autofill_assistant::GenericUserInterfaceProto& generic_ui(const CreateNestedGenericUiProto* msg);
  static void set_has_generic_ui(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_parent_view_identifier(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::autofill_assistant::GenericUserInterfaceProto&
CreateNestedGenericUiProto::_Internal::generic_ui(const CreateNestedGenericUiProto* msg) {
  return *msg->generic_ui_;
}
CreateNestedGenericUiProto::CreateNestedGenericUiProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.CreateNestedGenericUiProto)
}
CreateNestedGenericUiProto::CreateNestedGenericUiProto(const CreateNestedGenericUiProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  generic_ui_identifier_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    generic_ui_identifier_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_generic_ui_identifier()) {
    generic_ui_identifier_.Set(from._internal_generic_ui_identifier(), 
      GetArenaForAllocation());
  }
  parent_view_identifier_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    parent_view_identifier_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_parent_view_identifier()) {
    parent_view_identifier_.Set(from._internal_parent_view_identifier(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_generic_ui()) {
    generic_ui_ = new ::autofill_assistant::GenericUserInterfaceProto(*from.generic_ui_);
  } else {
    generic_ui_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.CreateNestedGenericUiProto)
}

inline void CreateNestedGenericUiProto::SharedCtor() {
generic_ui_identifier_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  generic_ui_identifier_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
parent_view_identifier_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  parent_view_identifier_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
generic_ui_ = nullptr;
}

CreateNestedGenericUiProto::~CreateNestedGenericUiProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.CreateNestedGenericUiProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CreateNestedGenericUiProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  generic_ui_identifier_.Destroy();
  parent_view_identifier_.Destroy();
  if (this != internal_default_instance()) delete generic_ui_;
}

void CreateNestedGenericUiProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CreateNestedGenericUiProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.CreateNestedGenericUiProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      generic_ui_identifier_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      parent_view_identifier_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(generic_ui_ != nullptr);
      generic_ui_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CreateNestedGenericUiProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string generic_ui_identifier = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_generic_ui_identifier();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .autofill_assistant.GenericUserInterfaceProto generic_ui = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_generic_ui(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string parent_view_identifier = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_parent_view_identifier();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CreateNestedGenericUiProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.CreateNestedGenericUiProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string generic_ui_identifier = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_generic_ui_identifier(), target);
  }

  // optional .autofill_assistant.GenericUserInterfaceProto generic_ui = 2;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::generic_ui(this),
        _Internal::generic_ui(this).GetCachedSize(), target, stream);
  }

  // optional string parent_view_identifier = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_parent_view_identifier(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.CreateNestedGenericUiProto)
  return target;
}

size_t CreateNestedGenericUiProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.CreateNestedGenericUiProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string generic_ui_identifier = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_generic_ui_identifier());
    }

    // optional string parent_view_identifier = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_parent_view_identifier());
    }

    // optional .autofill_assistant.GenericUserInterfaceProto generic_ui = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *generic_ui_);
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CreateNestedGenericUiProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CreateNestedGenericUiProto*>(
      &from));
}

void CreateNestedGenericUiProto::MergeFrom(const CreateNestedGenericUiProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.CreateNestedGenericUiProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_generic_ui_identifier(from._internal_generic_ui_identifier());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_parent_view_identifier(from._internal_parent_view_identifier());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_generic_ui()->::autofill_assistant::GenericUserInterfaceProto::MergeFrom(from._internal_generic_ui());
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CreateNestedGenericUiProto::CopyFrom(const CreateNestedGenericUiProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.CreateNestedGenericUiProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CreateNestedGenericUiProto::IsInitialized() const {
  return true;
}

void CreateNestedGenericUiProto::InternalSwap(CreateNestedGenericUiProto* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &generic_ui_identifier_, lhs_arena,
      &other->generic_ui_identifier_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &parent_view_identifier_, lhs_arena,
      &other->parent_view_identifier_, rhs_arena
  );
  swap(generic_ui_, other->generic_ui_);
}

std::string CreateNestedGenericUiProto::GetTypeName() const {
  return "autofill_assistant.CreateNestedGenericUiProto";
}


// ===================================================================

class ClearViewContainerProto::_Internal {
 public:
  using HasBits = decltype(std::declval<ClearViewContainerProto>()._has_bits_);
  static void set_has_view_identifier(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

ClearViewContainerProto::ClearViewContainerProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.ClearViewContainerProto)
}
ClearViewContainerProto::ClearViewContainerProto(const ClearViewContainerProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  view_identifier_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    view_identifier_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_view_identifier()) {
    view_identifier_.Set(from._internal_view_identifier(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.ClearViewContainerProto)
}

inline void ClearViewContainerProto::SharedCtor() {
view_identifier_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  view_identifier_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ClearViewContainerProto::~ClearViewContainerProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.ClearViewContainerProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ClearViewContainerProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  view_identifier_.Destroy();
}

void ClearViewContainerProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ClearViewContainerProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.ClearViewContainerProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    view_identifier_.ClearNonDefaultToEmpty();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ClearViewContainerProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string view_identifier = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_view_identifier();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ClearViewContainerProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.ClearViewContainerProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string view_identifier = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_view_identifier(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.ClearViewContainerProto)
  return target;
}

size_t ClearViewContainerProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.ClearViewContainerProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string view_identifier = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_view_identifier());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ClearViewContainerProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ClearViewContainerProto*>(
      &from));
}

void ClearViewContainerProto::MergeFrom(const ClearViewContainerProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.ClearViewContainerProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_view_identifier()) {
    _internal_set_view_identifier(from._internal_view_identifier());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClearViewContainerProto::CopyFrom(const ClearViewContainerProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.ClearViewContainerProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClearViewContainerProto::IsInitialized() const {
  return true;
}

void ClearViewContainerProto::InternalSwap(ClearViewContainerProto* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &view_identifier_, lhs_arena,
      &other->view_identifier_, rhs_arena
  );
}

std::string ClearViewContainerProto::GetTypeName() const {
  return "autofill_assistant.ClearViewContainerProto";
}


// ===================================================================

class ForEachProto::_Internal {
 public:
  using HasBits = decltype(std::declval<ForEachProto>()._has_bits_);
  static void set_has_loop_counter(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_loop_value_model_identifier(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

ForEachProto::ForEachProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  callbacks_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:autofill_assistant.ForEachProto)
}
ForEachProto::ForEachProto(const ForEachProto& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      callbacks_(from.callbacks_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  loop_counter_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    loop_counter_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_loop_counter()) {
    loop_counter_.Set(from._internal_loop_counter(), 
      GetArenaForAllocation());
  }
  loop_value_model_identifier_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    loop_value_model_identifier_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_loop_value_model_identifier()) {
    loop_value_model_identifier_.Set(from._internal_loop_value_model_identifier(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:autofill_assistant.ForEachProto)
}

inline void ForEachProto::SharedCtor() {
loop_counter_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  loop_counter_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
loop_value_model_identifier_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  loop_value_model_identifier_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ForEachProto::~ForEachProto() {
  // @@protoc_insertion_point(destructor:autofill_assistant.ForEachProto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ForEachProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  loop_counter_.Destroy();
  loop_value_model_identifier_.Destroy();
}

void ForEachProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ForEachProto::Clear() {
// @@protoc_insertion_point(message_clear_start:autofill_assistant.ForEachProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  callbacks_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      loop_counter_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      loop_value_model_identifier_.ClearNonDefaultToEmpty();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ForEachProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string loop_counter = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_loop_counter();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string loop_value_model_identifier = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_loop_value_model_identifier();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .autofill_assistant.CallbackProto callbacks = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_callbacks(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ForEachProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:autofill_assistant.ForEachProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string loop_counter = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_loop_counter(), target);
  }

  // optional string loop_value_model_identifier = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_loop_value_model_identifier(), target);
  }

  // repeated .autofill_assistant.CallbackProto callbacks = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_callbacks_size()); i < n; i++) {
    const auto& repfield = this->_internal_callbacks(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autofill_assistant.ForEachProto)
  return target;
}

size_t ForEachProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autofill_assistant.ForEachProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .autofill_assistant.CallbackProto callbacks = 3;
  total_size += 1UL * this->_internal_callbacks_size();
  for (const auto& msg : this->callbacks_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string loop_counter = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_loop_counter());
    }

    // optional string loop_value_model_identifier = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_loop_value_model_identifier());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ForEachProto::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ForEachProto*>(
      &from));
}

void ForEachProto::MergeFrom(const ForEachProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autofill_assistant.ForEachProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  callbacks_.MergeFrom(from.callbacks_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_loop_counter(from._internal_loop_counter());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_loop_value_model_identifier(from._internal_loop_value_model_identifier());
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ForEachProto::CopyFrom(const ForEachProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autofill_assistant.ForEachProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ForEachProto::IsInitialized() const {
  return true;
}

void ForEachProto::InternalSwap(ForEachProto* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  callbacks_.InternalSwap(&other->callbacks_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &loop_counter_, lhs_arena,
      &other->loop_counter_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &loop_value_model_identifier_, lhs_arena,
      &other->loop_value_model_identifier_, rhs_arena
  );
}

std::string ForEachProto::GetTypeName() const {
  return "autofill_assistant.ForEachProto";
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace autofill_assistant
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::autofill_assistant::GenericUserInterfaceProto*
Arena::CreateMaybeMessage< ::autofill_assistant::GenericUserInterfaceProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::GenericUserInterfaceProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::InteractionsProto*
Arena::CreateMaybeMessage< ::autofill_assistant::InteractionsProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::InteractionsProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::InteractionProto*
Arena::CreateMaybeMessage< ::autofill_assistant::InteractionProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::InteractionProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::CallbackProto*
Arena::CreateMaybeMessage< ::autofill_assistant::CallbackProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::CallbackProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::EventProto*
Arena::CreateMaybeMessage< ::autofill_assistant::EventProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::EventProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::OnModelValueChangedEventProto*
Arena::CreateMaybeMessage< ::autofill_assistant::OnModelValueChangedEventProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::OnModelValueChangedEventProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::OnViewClickedEventProto*
Arena::CreateMaybeMessage< ::autofill_assistant::OnViewClickedEventProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::OnViewClickedEventProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::OnUserActionCalled*
Arena::CreateMaybeMessage< ::autofill_assistant::OnUserActionCalled >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::OnUserActionCalled >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::OnTextLinkClickedProto*
Arena::CreateMaybeMessage< ::autofill_assistant::OnTextLinkClickedProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::OnTextLinkClickedProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::OnPopupDismissedProto*
Arena::CreateMaybeMessage< ::autofill_assistant::OnPopupDismissedProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::OnPopupDismissedProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::OnViewContainerClearedProto*
Arena::CreateMaybeMessage< ::autofill_assistant::OnViewContainerClearedProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::OnViewContainerClearedProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::SetModelValueProto*
Arena::CreateMaybeMessage< ::autofill_assistant::SetModelValueProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::SetModelValueProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::ComputeValueProto*
Arena::CreateMaybeMessage< ::autofill_assistant::ComputeValueProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::ComputeValueProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::BooleanAndProto*
Arena::CreateMaybeMessage< ::autofill_assistant::BooleanAndProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::BooleanAndProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::BooleanOrProto*
Arena::CreateMaybeMessage< ::autofill_assistant::BooleanOrProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::BooleanOrProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::BooleanNotProto*
Arena::CreateMaybeMessage< ::autofill_assistant::BooleanNotProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::BooleanNotProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::ToStringProto*
Arena::CreateMaybeMessage< ::autofill_assistant::ToStringProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::ToStringProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::DateFormatProto*
Arena::CreateMaybeMessage< ::autofill_assistant::DateFormatProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::DateFormatProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::AutofillFormatProto*
Arena::CreateMaybeMessage< ::autofill_assistant::AutofillFormatProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::AutofillFormatProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::ValueComparisonProto*
Arena::CreateMaybeMessage< ::autofill_assistant::ValueComparisonProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::ValueComparisonProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::IntegerSumProto*
Arena::CreateMaybeMessage< ::autofill_assistant::IntegerSumProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::IntegerSumProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::CreateCreditCardResponseProto*
Arena::CreateMaybeMessage< ::autofill_assistant::CreateCreditCardResponseProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::CreateCreditCardResponseProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::CreateLoginOptionResponseProto*
Arena::CreateMaybeMessage< ::autofill_assistant::CreateLoginOptionResponseProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::CreateLoginOptionResponseProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::StringEmptyProto*
Arena::CreateMaybeMessage< ::autofill_assistant::StringEmptyProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::StringEmptyProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::ShowInfoPopupProto*
Arena::CreateMaybeMessage< ::autofill_assistant::ShowInfoPopupProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::ShowInfoPopupProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::ShowListPopupProto*
Arena::CreateMaybeMessage< ::autofill_assistant::ShowListPopupProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::ShowListPopupProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::SetUserActionsProto*
Arena::CreateMaybeMessage< ::autofill_assistant::SetUserActionsProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::SetUserActionsProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::ToggleUserActionProto*
Arena::CreateMaybeMessage< ::autofill_assistant::ToggleUserActionProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::ToggleUserActionProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::EndActionProto*
Arena::CreateMaybeMessage< ::autofill_assistant::EndActionProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::EndActionProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::ShowCalendarPopupProto*
Arena::CreateMaybeMessage< ::autofill_assistant::ShowCalendarPopupProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::ShowCalendarPopupProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::SetTextProto*
Arena::CreateMaybeMessage< ::autofill_assistant::SetTextProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::SetTextProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::SetViewVisibilityProto*
Arena::CreateMaybeMessage< ::autofill_assistant::SetViewVisibilityProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::SetViewVisibilityProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::ShowGenericUiPopupProto*
Arena::CreateMaybeMessage< ::autofill_assistant::ShowGenericUiPopupProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::ShowGenericUiPopupProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::SetViewEnabledProto*
Arena::CreateMaybeMessage< ::autofill_assistant::SetViewEnabledProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::SetViewEnabledProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::CreateNestedGenericUiProto*
Arena::CreateMaybeMessage< ::autofill_assistant::CreateNestedGenericUiProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::CreateNestedGenericUiProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::ClearViewContainerProto*
Arena::CreateMaybeMessage< ::autofill_assistant::ClearViewContainerProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::ClearViewContainerProto >(arena);
}
template<> PROTOBUF_NOINLINE ::autofill_assistant::ForEachProto*
Arena::CreateMaybeMessage< ::autofill_assistant::ForEachProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::autofill_assistant::ForEachProto >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
