// components/services/app_service/public/mojom/types.mojom.h is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2013 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef COMPONENTS_SERVICES_APP_SERVICE_PUBLIC_MOJOM_TYPES_MOJOM_H_
#define COMPONENTS_SERVICES_APP_SERVICE_PUBLIC_MOJOM_TYPES_MOJOM_H_

#include <stdint.h>

#include <limits>
#include <type_traits>
#include <utility>

#include "third_party/abseil-cpp/absl/types/optional.h"
#include "mojo/public/cpp/bindings/clone_traits.h"
#include "mojo/public/cpp/bindings/equals_traits.h"
#include "mojo/public/cpp/bindings/lib/serialization.h"
#include "mojo/public/cpp/bindings/struct_ptr.h"
#include "mojo/public/cpp/bindings/struct_traits.h"
#include "mojo/public/cpp/bindings/union_traits.h"

#include "third_party/perfetto/include/perfetto/tracing/traced_value_forward.h"

#include "components/services/app_service/public/mojom/types.mojom-shared.h"
#include "components/services/app_service/public/mojom/types.mojom-forward.h"
#include "mojo/public/mojom/base/file_path.mojom.h"
#include "mojo/public/mojom/base/safe_base_name.mojom.h"
#include "mojo/public/mojom/base/time.mojom.h"
#include "ui/gfx/image/mojom/image.mojom.h"
#include "url/mojom/url.mojom.h"
#include <string>
#include <vector>

#include "mojo/public/cpp/bindings/lib/control_message_handler.h"
#include "mojo/public/cpp/bindings/raw_ptr_impl_ref_traits.h"






namespace apps {
namespace mojom {







class  IconKey {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<IconKey, T>::value>;
  using DataView = IconKeyDataView;
  using Data_ = internal::IconKey_Data;
  
  static constexpr uint64_t kDoesNotChangeOverTime = 0ULL;
  
  static constexpr int32_t kInvalidResourceId = 0;

  template <typename... Args>
  static IconKeyPtr New(Args&&... args) {
    return IconKeyPtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static IconKeyPtr From(const U& u) {
    return mojo::TypeConverter<IconKeyPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, IconKey>::Convert(*this);
  }


  IconKey();

  IconKey(
      uint64_t timeline,
      int32_t resource_id,
      uint32_t icon_effects);


  ~IconKey();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = IconKeyPtr>
  IconKeyPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, IconKey::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, IconKey::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  size_t Hash(size_t seed) const;
  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        IconKey::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        IconKey::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::IconKey_UnserializedMessageContext<
            UserType, IconKey::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<IconKey::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return IconKey::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::IconKey_UnserializedMessageContext<
            UserType, IconKey::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<IconKey::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
  uint64_t timeline;
  
  int32_t resource_id;
  
  uint32_t icon_effects;

  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, IconKey::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, IconKey::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, IconKey::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, IconKey::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}







class  ConditionValue {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<ConditionValue, T>::value>;
  using DataView = ConditionValueDataView;
  using Data_ = internal::ConditionValue_Data;

  template <typename... Args>
  static ConditionValuePtr New(Args&&... args) {
    return ConditionValuePtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static ConditionValuePtr From(const U& u) {
    return mojo::TypeConverter<ConditionValuePtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, ConditionValue>::Convert(*this);
  }


  ConditionValue();

  ConditionValue(
      const std::string& value,
      PatternMatchType match_type);


  ~ConditionValue();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = ConditionValuePtr>
  ConditionValuePtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, ConditionValue::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, ConditionValue::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  size_t Hash(size_t seed) const;
  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        ConditionValue::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        ConditionValue::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::ConditionValue_UnserializedMessageContext<
            UserType, ConditionValue::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<ConditionValue::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return ConditionValue::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::ConditionValue_UnserializedMessageContext<
            UserType, ConditionValue::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<ConditionValue::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
  std::string value;
  
  PatternMatchType match_type;

  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, ConditionValue::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, ConditionValue::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, ConditionValue::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, ConditionValue::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}













class  CapabilityAccess {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<CapabilityAccess, T>::value>;
  using DataView = CapabilityAccessDataView;
  using Data_ = internal::CapabilityAccess_Data;

  template <typename... Args>
  static CapabilityAccessPtr New(Args&&... args) {
    return CapabilityAccessPtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static CapabilityAccessPtr From(const U& u) {
    return mojo::TypeConverter<CapabilityAccessPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, CapabilityAccess>::Convert(*this);
  }


  CapabilityAccess();

  CapabilityAccess(
      const std::string& app_id,
      OptionalBool camera,
      OptionalBool microphone);


  ~CapabilityAccess();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = CapabilityAccessPtr>
  CapabilityAccessPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, CapabilityAccess::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, CapabilityAccess::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  size_t Hash(size_t seed) const;
  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        CapabilityAccess::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        CapabilityAccess::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::CapabilityAccess_UnserializedMessageContext<
            UserType, CapabilityAccess::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<CapabilityAccess::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return CapabilityAccess::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::CapabilityAccess_UnserializedMessageContext<
            UserType, CapabilityAccess::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<CapabilityAccess::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
  std::string app_id;
  
  OptionalBool camera;
  
  OptionalBool microphone;

  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, CapabilityAccess::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, CapabilityAccess::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, CapabilityAccess::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, CapabilityAccess::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





class  Rect {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<Rect, T>::value>;
  using DataView = RectDataView;
  using Data_ = internal::Rect_Data;

  template <typename... Args>
  static RectPtr New(Args&&... args) {
    return RectPtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static RectPtr From(const U& u) {
    return mojo::TypeConverter<RectPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, Rect>::Convert(*this);
  }


  Rect();

  Rect(
      int32_t x,
      int32_t y,
      int32_t width,
      int32_t height);


  ~Rect();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = RectPtr>
  RectPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, Rect::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, Rect::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  size_t Hash(size_t seed) const;
  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        Rect::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        Rect::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::Rect_UnserializedMessageContext<
            UserType, Rect::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<Rect::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return Rect::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::Rect_UnserializedMessageContext<
            UserType, Rect::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<Rect::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
  int32_t x;
  
  int32_t y;
  
  int32_t width;
  
  int32_t height;

  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, Rect::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, Rect::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, Rect::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, Rect::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}






class  RunOnOsLogin {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<RunOnOsLogin, T>::value>;
  using DataView = RunOnOsLoginDataView;
  using Data_ = internal::RunOnOsLogin_Data;

  template <typename... Args>
  static RunOnOsLoginPtr New(Args&&... args) {
    return RunOnOsLoginPtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static RunOnOsLoginPtr From(const U& u) {
    return mojo::TypeConverter<RunOnOsLoginPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, RunOnOsLogin>::Convert(*this);
  }


  RunOnOsLogin();

  RunOnOsLogin(
      RunOnOsLoginMode login_mode,
      bool is_managed);


  ~RunOnOsLogin();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = RunOnOsLoginPtr>
  RunOnOsLoginPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, RunOnOsLogin::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, RunOnOsLogin::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  size_t Hash(size_t seed) const;
  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        RunOnOsLogin::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        RunOnOsLogin::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::RunOnOsLogin_UnserializedMessageContext<
            UserType, RunOnOsLogin::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<RunOnOsLogin::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return RunOnOsLogin::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::RunOnOsLogin_UnserializedMessageContext<
            UserType, RunOnOsLogin::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<RunOnOsLogin::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
  RunOnOsLoginMode login_mode;
  
  bool is_managed;

  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, RunOnOsLogin::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, RunOnOsLogin::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, RunOnOsLogin::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, RunOnOsLogin::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





class  PermissionValue {
 public:
  using DataView = PermissionValueDataView;
  using Data_ = internal::PermissionValue_Data;
  using Tag = Data_::PermissionValue_Tag;

  template <typename... Args>
  static PermissionValuePtr New(Args&&... args) {
    static_assert(
        sizeof...(args) < 0,
        "Do not use Union::New(); to create a union of a given subtype, use "
        "New<SubType>(), not New() followed by set_<sub_type>(). To represent "
        "an empty union, mark the field or parameter as nullable in the mojom "
        "definition.");
  }
  // Construct an instance holding |bool_value|.
  static PermissionValuePtr
  NewBoolValue(
      bool bool_value) {
    auto result = PermissionValuePtr(absl::in_place);
    result->set_bool_value(std::move(bool_value));
    return result;
  }
  // Construct an instance holding |tristate_value|.
  static PermissionValuePtr
  NewTristateValue(
      TriState tristate_value) {
    auto result = PermissionValuePtr(absl::in_place);
    result->set_tristate_value(std::move(tristate_value));
    return result;
  }

  template <typename U>
  static PermissionValuePtr From(const U& u) {
    return mojo::TypeConverter<PermissionValuePtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, PermissionValue>::Convert(*this);
  }

  PermissionValue();
  ~PermissionValue();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename UnionPtrType = PermissionValuePtr>
  PermissionValuePtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T,
            typename std::enable_if<std::is_same<
                T, PermissionValue>::value>::type* = nullptr>
  bool Equals(const T& other) const;

  template <typename T,
            typename std::enable_if<std::is_same<
                T, PermissionValue>::value>::type* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  size_t Hash(size_t seed) const;

  Tag which() const {
    return tag_;
  }


  
  bool is_bool_value() const { return tag_ == Tag::kBoolValue; }

  
  bool get_bool_value() const {
    CHECK(tag_ == Tag::kBoolValue);
    return data_.bool_value;
  }

  
  void set_bool_value(
      bool bool_value);
  
  bool is_tristate_value() const { return tag_ == Tag::kTristateValue; }

  
  TriState get_tristate_value() const {
    CHECK(tag_ == Tag::kTristateValue);
    return data_.tristate_value;
  }

  
  void set_tristate_value(
      TriState tristate_value);

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        PermissionValue::DataView>(input);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    return mojo::internal::DeserializeImpl<PermissionValue::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

 private:
  union Union_ {
    Union_() = default;
    ~Union_() = default;
    bool bool_value;
    TriState tristate_value;
  };

  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);

  void DestroyActive();
  Tag tag_;
  Union_ data_;
};





class  App {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<App, T>::value>;
  using DataView = AppDataView;
  using Data_ = internal::App_Data;

  template <typename... Args>
  static AppPtr New(Args&&... args) {
    return AppPtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static AppPtr From(const U& u) {
    return mojo::TypeConverter<AppPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, App>::Convert(*this);
  }


  App();

  App(
      AppType app_type,
      const std::string& app_id,
      Readiness readiness,
      const absl::optional<std::string>& name,
      const absl::optional<std::string>& short_name,
      const absl::optional<std::string>& publisher_id,
      const absl::optional<std::string>& description,
      const absl::optional<std::string>& version,
      std::vector<std::string> additional_search_terms,
      IconKeyPtr icon_key,
      absl::optional<::base::Time> last_launch_time,
      absl::optional<::base::Time> install_time,
      std::vector<PermissionPtr> permissions,
      InstallReason install_reason,
      InstallSource install_source,
      const absl::optional<std::string>& policy_id,
      OptionalBool is_platform_app,
      OptionalBool recommendable,
      OptionalBool searchable,
      OptionalBool show_in_launcher,
      OptionalBool show_in_shelf,
      OptionalBool show_in_search,
      OptionalBool show_in_management,
      OptionalBool handles_intents,
      OptionalBool allow_uninstall,
      OptionalBool has_badge,
      OptionalBool paused,
      std::vector<IntentFilterPtr> intent_filters,
      OptionalBool resize_locked,
      WindowMode window_mode,
      RunOnOsLoginPtr run_on_os_login);

App(const App&) = delete;
App& operator=(const App&) = delete;

  ~App();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = AppPtr>
  AppPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, App::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, App::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        App::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        App::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::App_UnserializedMessageContext<
            UserType, App::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<App::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return App::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::App_UnserializedMessageContext<
            UserType, App::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<App::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
  AppType app_type;
  
  std::string app_id;
  
  Readiness readiness;
  
  absl::optional<std::string> name;
  
  absl::optional<std::string> short_name;
  
  absl::optional<std::string> publisher_id;
  
  absl::optional<std::string> description;
  
  absl::optional<std::string> version;
  
  std::vector<std::string> additional_search_terms;
  
  IconKeyPtr icon_key;
  
  absl::optional<::base::Time> last_launch_time;
  
  absl::optional<::base::Time> install_time;
  
  std::vector<PermissionPtr> permissions;
  
  InstallReason install_reason;
  
  InstallSource install_source;
  
  absl::optional<std::string> policy_id;
  
  OptionalBool is_platform_app;
  
  OptionalBool recommendable;
  
  OptionalBool searchable;
  
  OptionalBool show_in_launcher;
  
  OptionalBool show_in_shelf;
  
  OptionalBool show_in_search;
  
  OptionalBool show_in_management;
  
  OptionalBool handles_intents;
  
  OptionalBool allow_uninstall;
  
  OptionalBool has_badge;
  
  OptionalBool paused;
  
  std::vector<IntentFilterPtr> intent_filters;
  
  OptionalBool resize_locked;
  
  WindowMode window_mode;
  
  RunOnOsLoginPtr run_on_os_login;

  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, App::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, App::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, App::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, App::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





class  Permission {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<Permission, T>::value>;
  using DataView = PermissionDataView;
  using Data_ = internal::Permission_Data;

  template <typename... Args>
  static PermissionPtr New(Args&&... args) {
    return PermissionPtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static PermissionPtr From(const U& u) {
    return mojo::TypeConverter<PermissionPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, Permission>::Convert(*this);
  }


  Permission();

  Permission(
      PermissionType permission_type,
      PermissionValuePtr value,
      bool is_managed);

Permission(const Permission&) = delete;
Permission& operator=(const Permission&) = delete;

  ~Permission();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = PermissionPtr>
  PermissionPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, Permission::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, Permission::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  size_t Hash(size_t seed) const;
  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        Permission::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        Permission::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::Permission_UnserializedMessageContext<
            UserType, Permission::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<Permission::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return Permission::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::Permission_UnserializedMessageContext<
            UserType, Permission::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<Permission::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
  PermissionType permission_type;
  
  PermissionValuePtr value;
  
  bool is_managed;

  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, Permission::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, Permission::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, Permission::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, Permission::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}






class  MenuItems {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<MenuItems, T>::value>;
  using DataView = MenuItemsDataView;
  using Data_ = internal::MenuItems_Data;

  template <typename... Args>
  static MenuItemsPtr New(Args&&... args) {
    return MenuItemsPtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static MenuItemsPtr From(const U& u) {
    return mojo::TypeConverter<MenuItemsPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, MenuItems>::Convert(*this);
  }


  MenuItems();

  explicit MenuItems(
      std::vector<MenuItemPtr> items);

MenuItems(const MenuItems&) = delete;
MenuItems& operator=(const MenuItems&) = delete;

  ~MenuItems();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = MenuItemsPtr>
  MenuItemsPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, MenuItems::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, MenuItems::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        MenuItems::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::MenuItems_UnserializedMessageContext<
            UserType, MenuItems::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<MenuItems::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return MenuItems::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::MenuItems_UnserializedMessageContext<
            UserType, MenuItems::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<MenuItems::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
  std::vector<MenuItemPtr> items;

  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, MenuItems::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, MenuItems::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, MenuItems::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, MenuItems::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





class  MenuItem {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<MenuItem, T>::value>;
  using DataView = MenuItemDataView;
  using Data_ = internal::MenuItem_Data;

  template <typename... Args>
  static MenuItemPtr New(Args&&... args) {
    return MenuItemPtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static MenuItemPtr From(const U& u) {
    return mojo::TypeConverter<MenuItemPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, MenuItem>::Convert(*this);
  }


  MenuItem();

  MenuItem(
      MenuItemType type,
      int32_t command_id,
      int32_t string_id,
      std::vector<MenuItemPtr> submenu,
      int32_t radio_group_id,
      const std::string& shortcut_id,
      const std::string& label,
      const ::gfx::ImageSkia& image);

MenuItem(const MenuItem&) = delete;
MenuItem& operator=(const MenuItem&) = delete;

  ~MenuItem();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = MenuItemPtr>
  MenuItemPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, MenuItem::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, MenuItem::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        MenuItem::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::MenuItem_UnserializedMessageContext<
            UserType, MenuItem::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<MenuItem::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return MenuItem::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::MenuItem_UnserializedMessageContext<
            UserType, MenuItem::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<MenuItem::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
  MenuItemType type;
  
  int32_t command_id;
  
  int32_t string_id;
  
  std::vector<MenuItemPtr> submenu;
  
  int32_t radio_group_id;
  
  std::string shortcut_id;
  
  std::string label;
  
  ::gfx::ImageSkia image;

  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, MenuItem::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, MenuItem::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, MenuItem::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, MenuItem::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}






class  Condition {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<Condition, T>::value>;
  using DataView = ConditionDataView;
  using Data_ = internal::Condition_Data;

  template <typename... Args>
  static ConditionPtr New(Args&&... args) {
    return ConditionPtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static ConditionPtr From(const U& u) {
    return mojo::TypeConverter<ConditionPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, Condition>::Convert(*this);
  }


  Condition();

  Condition(
      ConditionType condition_type,
      std::vector<ConditionValuePtr> condition_values);

Condition(const Condition&) = delete;
Condition& operator=(const Condition&) = delete;

  ~Condition();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = ConditionPtr>
  ConditionPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, Condition::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, Condition::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        Condition::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        Condition::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::Condition_UnserializedMessageContext<
            UserType, Condition::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<Condition::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return Condition::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::Condition_UnserializedMessageContext<
            UserType, Condition::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<Condition::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
  ConditionType condition_type;
  
  std::vector<ConditionValuePtr> condition_values;

  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, Condition::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, Condition::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, Condition::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, Condition::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





class  IntentFilter {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<IntentFilter, T>::value>;
  using DataView = IntentFilterDataView;
  using Data_ = internal::IntentFilter_Data;

  template <typename... Args>
  static IntentFilterPtr New(Args&&... args) {
    return IntentFilterPtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static IntentFilterPtr From(const U& u) {
    return mojo::TypeConverter<IntentFilterPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, IntentFilter>::Convert(*this);
  }


  IntentFilter();

  IntentFilter(
      std::vector<ConditionPtr> conditions,
      const absl::optional<std::string>& activity_name,
      const absl::optional<std::string>& activity_label);

IntentFilter(const IntentFilter&) = delete;
IntentFilter& operator=(const IntentFilter&) = delete;

  ~IntentFilter();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = IntentFilterPtr>
  IntentFilterPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, IntentFilter::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, IntentFilter::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        IntentFilter::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        IntentFilter::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::IntentFilter_UnserializedMessageContext<
            UserType, IntentFilter::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<IntentFilter::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return IntentFilter::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::IntentFilter_UnserializedMessageContext<
            UserType, IntentFilter::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<IntentFilter::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
  std::vector<ConditionPtr> conditions;
  
  absl::optional<std::string> activity_name;
  
  absl::optional<std::string> activity_label;

  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, IntentFilter::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, IntentFilter::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, IntentFilter::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, IntentFilter::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





class  IntentFile {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<IntentFile, T>::value>;
  using DataView = IntentFileDataView;
  using Data_ = internal::IntentFile_Data;

  template <typename... Args>
  static IntentFilePtr New(Args&&... args) {
    return IntentFilePtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static IntentFilePtr From(const U& u) {
    return mojo::TypeConverter<IntentFilePtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, IntentFile>::Convert(*this);
  }


  IntentFile();

  IntentFile(
      const ::GURL& url,
      const absl::optional<std::string>& mime_type,
      const absl::optional<::base::SafeBaseName>& file_name,
      uint64_t file_size,
      OptionalBool is_directory);


  ~IntentFile();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = IntentFilePtr>
  IntentFilePtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, IntentFile::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, IntentFile::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        IntentFile::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        IntentFile::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::IntentFile_UnserializedMessageContext<
            UserType, IntentFile::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<IntentFile::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return IntentFile::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::IntentFile_UnserializedMessageContext<
            UserType, IntentFile::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<IntentFile::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
  ::GURL url;
  
  absl::optional<std::string> mime_type;
  
  absl::optional<::base::SafeBaseName> file_name;
  
  uint64_t file_size;
  
  OptionalBool is_directory;

  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, IntentFile::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, IntentFile::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, IntentFile::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, IntentFile::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





class  Intent {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<Intent, T>::value>;
  using DataView = IntentDataView;
  using Data_ = internal::Intent_Data;

  template <typename... Args>
  static IntentPtr New(Args&&... args) {
    return IntentPtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static IntentPtr From(const U& u) {
    return mojo::TypeConverter<IntentPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, Intent>::Convert(*this);
  }


  Intent();

  Intent(
      const std::string& action,
      const absl::optional<::GURL>& url,
      const absl::optional<std::string>& mime_type,
      absl::optional<std::vector<IntentFilePtr>> files,
      const absl::optional<std::string>& activity_name,
      const absl::optional<::GURL>& drive_share_url,
      const absl::optional<std::string>& share_text,
      const absl::optional<std::string>& share_title,
      const absl::optional<std::string>& start_type,
      absl::optional<std::vector<std::string>> categories,
      const absl::optional<std::string>& data,
      OptionalBool ui_bypassed,
      const absl::optional<base::flat_map<std::string, std::string>>& extras);

Intent(const Intent&) = delete;
Intent& operator=(const Intent&) = delete;

  ~Intent();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = IntentPtr>
  IntentPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, Intent::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, Intent::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        Intent::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        Intent::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::Intent_UnserializedMessageContext<
            UserType, Intent::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<Intent::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return Intent::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::Intent_UnserializedMessageContext<
            UserType, Intent::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<Intent::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
  std::string action;
  
  absl::optional<::GURL> url;
  
  absl::optional<std::string> mime_type;
  
  absl::optional<std::vector<IntentFilePtr>> files;
  
  absl::optional<std::string> activity_name;
  
  absl::optional<::GURL> drive_share_url;
  
  absl::optional<std::string> share_text;
  
  absl::optional<std::string> share_title;
  
  absl::optional<std::string> start_type;
  
  absl::optional<std::vector<std::string>> categories;
  
  absl::optional<std::string> data;
  
  OptionalBool ui_bypassed;
  
  absl::optional<base::flat_map<std::string, std::string>> extras;

  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, Intent::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, Intent::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, Intent::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, Intent::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





class  ReplacedAppPreferences {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<ReplacedAppPreferences, T>::value>;
  using DataView = ReplacedAppPreferencesDataView;
  using Data_ = internal::ReplacedAppPreferences_Data;

  template <typename... Args>
  static ReplacedAppPreferencesPtr New(Args&&... args) {
    return ReplacedAppPreferencesPtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static ReplacedAppPreferencesPtr From(const U& u) {
    return mojo::TypeConverter<ReplacedAppPreferencesPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, ReplacedAppPreferences>::Convert(*this);
  }


  ReplacedAppPreferences();

  explicit ReplacedAppPreferences(
      base::flat_map<std::string, std::vector<IntentFilterPtr>> replaced_preference);

ReplacedAppPreferences(const ReplacedAppPreferences&) = delete;
ReplacedAppPreferences& operator=(const ReplacedAppPreferences&) = delete;

  ~ReplacedAppPreferences();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = ReplacedAppPreferencesPtr>
  ReplacedAppPreferencesPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, ReplacedAppPreferences::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, ReplacedAppPreferences::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        ReplacedAppPreferences::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        ReplacedAppPreferences::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::ReplacedAppPreferences_UnserializedMessageContext<
            UserType, ReplacedAppPreferences::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<ReplacedAppPreferences::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return ReplacedAppPreferences::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::ReplacedAppPreferences_UnserializedMessageContext<
            UserType, ReplacedAppPreferences::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<ReplacedAppPreferences::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
  base::flat_map<std::string, std::vector<IntentFilterPtr>> replaced_preference;

  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, ReplacedAppPreferences::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, ReplacedAppPreferences::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, ReplacedAppPreferences::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, ReplacedAppPreferences::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





class  PreferredAppChanges {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<PreferredAppChanges, T>::value>;
  using DataView = PreferredAppChangesDataView;
  using Data_ = internal::PreferredAppChanges_Data;

  template <typename... Args>
  static PreferredAppChangesPtr New(Args&&... args) {
    return PreferredAppChangesPtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static PreferredAppChangesPtr From(const U& u) {
    return mojo::TypeConverter<PreferredAppChangesPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, PreferredAppChanges>::Convert(*this);
  }


  PreferredAppChanges();

  PreferredAppChanges(
      base::flat_map<std::string, std::vector<IntentFilterPtr>> added_filters,
      base::flat_map<std::string, std::vector<IntentFilterPtr>> removed_filters);

PreferredAppChanges(const PreferredAppChanges&) = delete;
PreferredAppChanges& operator=(const PreferredAppChanges&) = delete;

  ~PreferredAppChanges();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = PreferredAppChangesPtr>
  PreferredAppChangesPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, PreferredAppChanges::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, PreferredAppChanges::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        PreferredAppChanges::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        PreferredAppChanges::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::PreferredAppChanges_UnserializedMessageContext<
            UserType, PreferredAppChanges::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<PreferredAppChanges::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return PreferredAppChanges::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::PreferredAppChanges_UnserializedMessageContext<
            UserType, PreferredAppChanges::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<PreferredAppChanges::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
  base::flat_map<std::string, std::vector<IntentFilterPtr>> added_filters;
  
  base::flat_map<std::string, std::vector<IntentFilterPtr>> removed_filters;

  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, PreferredAppChanges::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, PreferredAppChanges::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, PreferredAppChanges::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, PreferredAppChanges::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





class  PreferredApp {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<PreferredApp, T>::value>;
  using DataView = PreferredAppDataView;
  using Data_ = internal::PreferredApp_Data;

  template <typename... Args>
  static PreferredAppPtr New(Args&&... args) {
    return PreferredAppPtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static PreferredAppPtr From(const U& u) {
    return mojo::TypeConverter<PreferredAppPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, PreferredApp>::Convert(*this);
  }


  PreferredApp();

  PreferredApp(
      IntentFilterPtr intent_filter,
      const std::string& app_id);

PreferredApp(const PreferredApp&) = delete;
PreferredApp& operator=(const PreferredApp&) = delete;

  ~PreferredApp();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = PreferredAppPtr>
  PreferredAppPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, PreferredApp::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, PreferredApp::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        PreferredApp::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        PreferredApp::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::PreferredApp_UnserializedMessageContext<
            UserType, PreferredApp::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<PreferredApp::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return PreferredApp::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::PreferredApp_UnserializedMessageContext<
            UserType, PreferredApp::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<PreferredApp::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
  IntentFilterPtr intent_filter;
  
  std::string app_id;

  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, PreferredApp::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, PreferredApp::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, PreferredApp::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, PreferredApp::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





class  FilePaths {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<FilePaths, T>::value>;
  using DataView = FilePathsDataView;
  using Data_ = internal::FilePaths_Data;

  template <typename... Args>
  static FilePathsPtr New(Args&&... args) {
    return FilePathsPtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static FilePathsPtr From(const U& u) {
    return mojo::TypeConverter<FilePathsPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, FilePaths>::Convert(*this);
  }


  FilePaths();

  explicit FilePaths(
      std::vector<::base::FilePath> file_paths);


  ~FilePaths();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = FilePathsPtr>
  FilePathsPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, FilePaths::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, FilePaths::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        FilePaths::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        FilePaths::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::FilePaths_UnserializedMessageContext<
            UserType, FilePaths::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<FilePaths::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return FilePaths::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::FilePaths_UnserializedMessageContext<
            UserType, FilePaths::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<FilePaths::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
  std::vector<::base::FilePath> file_paths;

  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, FilePaths::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, FilePaths::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, FilePaths::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, FilePaths::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}







class  WindowInfo {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<WindowInfo, T>::value>;
  using DataView = WindowInfoDataView;
  using Data_ = internal::WindowInfo_Data;

  template <typename... Args>
  static WindowInfoPtr New(Args&&... args) {
    return WindowInfoPtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static WindowInfoPtr From(const U& u) {
    return mojo::TypeConverter<WindowInfoPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, WindowInfo>::Convert(*this);
  }


  WindowInfo();

  WindowInfo(
      int32_t window_id,
      int32_t state,
      int64_t display_id,
      RectPtr bounds);

WindowInfo(const WindowInfo&) = delete;
WindowInfo& operator=(const WindowInfo&) = delete;

  ~WindowInfo();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = WindowInfoPtr>
  WindowInfoPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, WindowInfo::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, WindowInfo::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        WindowInfo::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        WindowInfo::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::WindowInfo_UnserializedMessageContext<
            UserType, WindowInfo::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<WindowInfo::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return WindowInfo::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::WindowInfo_UnserializedMessageContext<
            UserType, WindowInfo::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<WindowInfo::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
  int32_t window_id;
  
  int32_t state;
  
  int64_t display_id;
  
  RectPtr bounds;

  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, WindowInfo::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, WindowInfo::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, WindowInfo::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, WindowInfo::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}


template <typename UnionPtrType>
PermissionValuePtr PermissionValue::Clone() const {
  switch (tag_) {
    case Tag::kBoolValue:
      return NewBoolValue(
          mojo::Clone(data_.bool_value));
    case Tag::kTristateValue:
      return NewTristateValue(
          mojo::Clone(data_.tristate_value));
  }
  return nullptr;
}

template <typename T,
          typename std::enable_if<std::is_same<
              T, PermissionValue>::value>::type*>
bool PermissionValue::Equals(const T& other) const {
  if (tag_ != other.which())
    return false;

  switch (tag_) {
    case Tag::kBoolValue:
      return mojo::Equals(data_.bool_value, other.data_.bool_value);
    case Tag::kTristateValue:
      return mojo::Equals(data_.tristate_value, other.data_.tristate_value);
  }

  return false;
}
template <typename StructPtrType>
AppPtr App::Clone() const {
  return New(
      mojo::Clone(app_type),
      mojo::Clone(app_id),
      mojo::Clone(readiness),
      mojo::Clone(name),
      mojo::Clone(short_name),
      mojo::Clone(publisher_id),
      mojo::Clone(description),
      mojo::Clone(version),
      mojo::Clone(additional_search_terms),
      mojo::Clone(icon_key),
      mojo::Clone(last_launch_time),
      mojo::Clone(install_time),
      mojo::Clone(permissions),
      mojo::Clone(install_reason),
      mojo::Clone(install_source),
      mojo::Clone(policy_id),
      mojo::Clone(is_platform_app),
      mojo::Clone(recommendable),
      mojo::Clone(searchable),
      mojo::Clone(show_in_launcher),
      mojo::Clone(show_in_shelf),
      mojo::Clone(show_in_search),
      mojo::Clone(show_in_management),
      mojo::Clone(handles_intents),
      mojo::Clone(allow_uninstall),
      mojo::Clone(has_badge),
      mojo::Clone(paused),
      mojo::Clone(intent_filters),
      mojo::Clone(resize_locked),
      mojo::Clone(window_mode),
      mojo::Clone(run_on_os_login)
  );
}

template <typename T, App::EnableIfSame<T>*>
bool App::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->app_type, other_struct.app_type))
    return false;
  if (!mojo::Equals(this->app_id, other_struct.app_id))
    return false;
  if (!mojo::Equals(this->readiness, other_struct.readiness))
    return false;
  if (!mojo::Equals(this->name, other_struct.name))
    return false;
  if (!mojo::Equals(this->short_name, other_struct.short_name))
    return false;
  if (!mojo::Equals(this->publisher_id, other_struct.publisher_id))
    return false;
  if (!mojo::Equals(this->description, other_struct.description))
    return false;
  if (!mojo::Equals(this->version, other_struct.version))
    return false;
  if (!mojo::Equals(this->additional_search_terms, other_struct.additional_search_terms))
    return false;
  if (!mojo::Equals(this->icon_key, other_struct.icon_key))
    return false;
  if (!mojo::Equals(this->last_launch_time, other_struct.last_launch_time))
    return false;
  if (!mojo::Equals(this->install_time, other_struct.install_time))
    return false;
  if (!mojo::Equals(this->permissions, other_struct.permissions))
    return false;
  if (!mojo::Equals(this->install_reason, other_struct.install_reason))
    return false;
  if (!mojo::Equals(this->install_source, other_struct.install_source))
    return false;
  if (!mojo::Equals(this->policy_id, other_struct.policy_id))
    return false;
  if (!mojo::Equals(this->is_platform_app, other_struct.is_platform_app))
    return false;
  if (!mojo::Equals(this->recommendable, other_struct.recommendable))
    return false;
  if (!mojo::Equals(this->searchable, other_struct.searchable))
    return false;
  if (!mojo::Equals(this->show_in_launcher, other_struct.show_in_launcher))
    return false;
  if (!mojo::Equals(this->show_in_shelf, other_struct.show_in_shelf))
    return false;
  if (!mojo::Equals(this->show_in_search, other_struct.show_in_search))
    return false;
  if (!mojo::Equals(this->show_in_management, other_struct.show_in_management))
    return false;
  if (!mojo::Equals(this->handles_intents, other_struct.handles_intents))
    return false;
  if (!mojo::Equals(this->allow_uninstall, other_struct.allow_uninstall))
    return false;
  if (!mojo::Equals(this->has_badge, other_struct.has_badge))
    return false;
  if (!mojo::Equals(this->paused, other_struct.paused))
    return false;
  if (!mojo::Equals(this->intent_filters, other_struct.intent_filters))
    return false;
  if (!mojo::Equals(this->resize_locked, other_struct.resize_locked))
    return false;
  if (!mojo::Equals(this->window_mode, other_struct.window_mode))
    return false;
  if (!mojo::Equals(this->run_on_os_login, other_struct.run_on_os_login))
    return false;
  return true;
}

template <typename T, App::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.app_type < rhs.app_type)
    return true;
  if (rhs.app_type < lhs.app_type)
    return false;
  if (lhs.app_id < rhs.app_id)
    return true;
  if (rhs.app_id < lhs.app_id)
    return false;
  if (lhs.readiness < rhs.readiness)
    return true;
  if (rhs.readiness < lhs.readiness)
    return false;
  if (lhs.name < rhs.name)
    return true;
  if (rhs.name < lhs.name)
    return false;
  if (lhs.short_name < rhs.short_name)
    return true;
  if (rhs.short_name < lhs.short_name)
    return false;
  if (lhs.publisher_id < rhs.publisher_id)
    return true;
  if (rhs.publisher_id < lhs.publisher_id)
    return false;
  if (lhs.description < rhs.description)
    return true;
  if (rhs.description < lhs.description)
    return false;
  if (lhs.version < rhs.version)
    return true;
  if (rhs.version < lhs.version)
    return false;
  if (lhs.additional_search_terms < rhs.additional_search_terms)
    return true;
  if (rhs.additional_search_terms < lhs.additional_search_terms)
    return false;
  if (lhs.icon_key < rhs.icon_key)
    return true;
  if (rhs.icon_key < lhs.icon_key)
    return false;
  if (lhs.last_launch_time < rhs.last_launch_time)
    return true;
  if (rhs.last_launch_time < lhs.last_launch_time)
    return false;
  if (lhs.install_time < rhs.install_time)
    return true;
  if (rhs.install_time < lhs.install_time)
    return false;
  if (lhs.permissions < rhs.permissions)
    return true;
  if (rhs.permissions < lhs.permissions)
    return false;
  if (lhs.install_reason < rhs.install_reason)
    return true;
  if (rhs.install_reason < lhs.install_reason)
    return false;
  if (lhs.install_source < rhs.install_source)
    return true;
  if (rhs.install_source < lhs.install_source)
    return false;
  if (lhs.policy_id < rhs.policy_id)
    return true;
  if (rhs.policy_id < lhs.policy_id)
    return false;
  if (lhs.is_platform_app < rhs.is_platform_app)
    return true;
  if (rhs.is_platform_app < lhs.is_platform_app)
    return false;
  if (lhs.recommendable < rhs.recommendable)
    return true;
  if (rhs.recommendable < lhs.recommendable)
    return false;
  if (lhs.searchable < rhs.searchable)
    return true;
  if (rhs.searchable < lhs.searchable)
    return false;
  if (lhs.show_in_launcher < rhs.show_in_launcher)
    return true;
  if (rhs.show_in_launcher < lhs.show_in_launcher)
    return false;
  if (lhs.show_in_shelf < rhs.show_in_shelf)
    return true;
  if (rhs.show_in_shelf < lhs.show_in_shelf)
    return false;
  if (lhs.show_in_search < rhs.show_in_search)
    return true;
  if (rhs.show_in_search < lhs.show_in_search)
    return false;
  if (lhs.show_in_management < rhs.show_in_management)
    return true;
  if (rhs.show_in_management < lhs.show_in_management)
    return false;
  if (lhs.handles_intents < rhs.handles_intents)
    return true;
  if (rhs.handles_intents < lhs.handles_intents)
    return false;
  if (lhs.allow_uninstall < rhs.allow_uninstall)
    return true;
  if (rhs.allow_uninstall < lhs.allow_uninstall)
    return false;
  if (lhs.has_badge < rhs.has_badge)
    return true;
  if (rhs.has_badge < lhs.has_badge)
    return false;
  if (lhs.paused < rhs.paused)
    return true;
  if (rhs.paused < lhs.paused)
    return false;
  if (lhs.intent_filters < rhs.intent_filters)
    return true;
  if (rhs.intent_filters < lhs.intent_filters)
    return false;
  if (lhs.resize_locked < rhs.resize_locked)
    return true;
  if (rhs.resize_locked < lhs.resize_locked)
    return false;
  if (lhs.window_mode < rhs.window_mode)
    return true;
  if (rhs.window_mode < lhs.window_mode)
    return false;
  if (lhs.run_on_os_login < rhs.run_on_os_login)
    return true;
  if (rhs.run_on_os_login < lhs.run_on_os_login)
    return false;
  return false;
}
template <typename StructPtrType>
PermissionPtr Permission::Clone() const {
  return New(
      mojo::Clone(permission_type),
      mojo::Clone(value),
      mojo::Clone(is_managed)
  );
}

template <typename T, Permission::EnableIfSame<T>*>
bool Permission::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->permission_type, other_struct.permission_type))
    return false;
  if (!mojo::Equals(this->value, other_struct.value))
    return false;
  if (!mojo::Equals(this->is_managed, other_struct.is_managed))
    return false;
  return true;
}

template <typename T, Permission::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.permission_type < rhs.permission_type)
    return true;
  if (rhs.permission_type < lhs.permission_type)
    return false;
  if (lhs.value < rhs.value)
    return true;
  if (rhs.value < lhs.value)
    return false;
  if (lhs.is_managed < rhs.is_managed)
    return true;
  if (rhs.is_managed < lhs.is_managed)
    return false;
  return false;
}
template <typename StructPtrType>
IconKeyPtr IconKey::Clone() const {
  return New(
      mojo::Clone(timeline),
      mojo::Clone(resource_id),
      mojo::Clone(icon_effects)
  );
}

template <typename T, IconKey::EnableIfSame<T>*>
bool IconKey::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->timeline, other_struct.timeline))
    return false;
  if (!mojo::Equals(this->resource_id, other_struct.resource_id))
    return false;
  if (!mojo::Equals(this->icon_effects, other_struct.icon_effects))
    return false;
  return true;
}

template <typename T, IconKey::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.timeline < rhs.timeline)
    return true;
  if (rhs.timeline < lhs.timeline)
    return false;
  if (lhs.resource_id < rhs.resource_id)
    return true;
  if (rhs.resource_id < lhs.resource_id)
    return false;
  if (lhs.icon_effects < rhs.icon_effects)
    return true;
  if (rhs.icon_effects < lhs.icon_effects)
    return false;
  return false;
}
template <typename StructPtrType>
MenuItemsPtr MenuItems::Clone() const {
  return New(
      mojo::Clone(items)
  );
}

template <typename T, MenuItems::EnableIfSame<T>*>
bool MenuItems::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->items, other_struct.items))
    return false;
  return true;
}

template <typename T, MenuItems::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.items < rhs.items)
    return true;
  if (rhs.items < lhs.items)
    return false;
  return false;
}
template <typename StructPtrType>
MenuItemPtr MenuItem::Clone() const {
  return New(
      mojo::Clone(type),
      mojo::Clone(command_id),
      mojo::Clone(string_id),
      mojo::Clone(submenu),
      mojo::Clone(radio_group_id),
      mojo::Clone(shortcut_id),
      mojo::Clone(label),
      mojo::Clone(image)
  );
}

template <typename T, MenuItem::EnableIfSame<T>*>
bool MenuItem::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->type, other_struct.type))
    return false;
  if (!mojo::Equals(this->command_id, other_struct.command_id))
    return false;
  if (!mojo::Equals(this->string_id, other_struct.string_id))
    return false;
  if (!mojo::Equals(this->submenu, other_struct.submenu))
    return false;
  if (!mojo::Equals(this->radio_group_id, other_struct.radio_group_id))
    return false;
  if (!mojo::Equals(this->shortcut_id, other_struct.shortcut_id))
    return false;
  if (!mojo::Equals(this->label, other_struct.label))
    return false;
  if (!mojo::Equals(this->image, other_struct.image))
    return false;
  return true;
}

template <typename T, MenuItem::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.type < rhs.type)
    return true;
  if (rhs.type < lhs.type)
    return false;
  if (lhs.command_id < rhs.command_id)
    return true;
  if (rhs.command_id < lhs.command_id)
    return false;
  if (lhs.string_id < rhs.string_id)
    return true;
  if (rhs.string_id < lhs.string_id)
    return false;
  if (lhs.submenu < rhs.submenu)
    return true;
  if (rhs.submenu < lhs.submenu)
    return false;
  if (lhs.radio_group_id < rhs.radio_group_id)
    return true;
  if (rhs.radio_group_id < lhs.radio_group_id)
    return false;
  if (lhs.shortcut_id < rhs.shortcut_id)
    return true;
  if (rhs.shortcut_id < lhs.shortcut_id)
    return false;
  if (lhs.label < rhs.label)
    return true;
  if (rhs.label < lhs.label)
    return false;
  if (lhs.image < rhs.image)
    return true;
  if (rhs.image < lhs.image)
    return false;
  return false;
}
template <typename StructPtrType>
ConditionValuePtr ConditionValue::Clone() const {
  return New(
      mojo::Clone(value),
      mojo::Clone(match_type)
  );
}

template <typename T, ConditionValue::EnableIfSame<T>*>
bool ConditionValue::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->value, other_struct.value))
    return false;
  if (!mojo::Equals(this->match_type, other_struct.match_type))
    return false;
  return true;
}

template <typename T, ConditionValue::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.value < rhs.value)
    return true;
  if (rhs.value < lhs.value)
    return false;
  if (lhs.match_type < rhs.match_type)
    return true;
  if (rhs.match_type < lhs.match_type)
    return false;
  return false;
}
template <typename StructPtrType>
ConditionPtr Condition::Clone() const {
  return New(
      mojo::Clone(condition_type),
      mojo::Clone(condition_values)
  );
}

template <typename T, Condition::EnableIfSame<T>*>
bool Condition::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->condition_type, other_struct.condition_type))
    return false;
  if (!mojo::Equals(this->condition_values, other_struct.condition_values))
    return false;
  return true;
}

template <typename T, Condition::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.condition_type < rhs.condition_type)
    return true;
  if (rhs.condition_type < lhs.condition_type)
    return false;
  if (lhs.condition_values < rhs.condition_values)
    return true;
  if (rhs.condition_values < lhs.condition_values)
    return false;
  return false;
}
template <typename StructPtrType>
IntentFilterPtr IntentFilter::Clone() const {
  return New(
      mojo::Clone(conditions),
      mojo::Clone(activity_name),
      mojo::Clone(activity_label)
  );
}

template <typename T, IntentFilter::EnableIfSame<T>*>
bool IntentFilter::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->conditions, other_struct.conditions))
    return false;
  if (!mojo::Equals(this->activity_name, other_struct.activity_name))
    return false;
  if (!mojo::Equals(this->activity_label, other_struct.activity_label))
    return false;
  return true;
}

template <typename T, IntentFilter::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.conditions < rhs.conditions)
    return true;
  if (rhs.conditions < lhs.conditions)
    return false;
  if (lhs.activity_name < rhs.activity_name)
    return true;
  if (rhs.activity_name < lhs.activity_name)
    return false;
  if (lhs.activity_label < rhs.activity_label)
    return true;
  if (rhs.activity_label < lhs.activity_label)
    return false;
  return false;
}
template <typename StructPtrType>
IntentFilePtr IntentFile::Clone() const {
  return New(
      mojo::Clone(url),
      mojo::Clone(mime_type),
      mojo::Clone(file_name),
      mojo::Clone(file_size),
      mojo::Clone(is_directory)
  );
}

template <typename T, IntentFile::EnableIfSame<T>*>
bool IntentFile::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->url, other_struct.url))
    return false;
  if (!mojo::Equals(this->mime_type, other_struct.mime_type))
    return false;
  if (!mojo::Equals(this->file_name, other_struct.file_name))
    return false;
  if (!mojo::Equals(this->file_size, other_struct.file_size))
    return false;
  if (!mojo::Equals(this->is_directory, other_struct.is_directory))
    return false;
  return true;
}

template <typename T, IntentFile::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.url < rhs.url)
    return true;
  if (rhs.url < lhs.url)
    return false;
  if (lhs.mime_type < rhs.mime_type)
    return true;
  if (rhs.mime_type < lhs.mime_type)
    return false;
  if (lhs.file_name < rhs.file_name)
    return true;
  if (rhs.file_name < lhs.file_name)
    return false;
  if (lhs.file_size < rhs.file_size)
    return true;
  if (rhs.file_size < lhs.file_size)
    return false;
  if (lhs.is_directory < rhs.is_directory)
    return true;
  if (rhs.is_directory < lhs.is_directory)
    return false;
  return false;
}
template <typename StructPtrType>
IntentPtr Intent::Clone() const {
  return New(
      mojo::Clone(action),
      mojo::Clone(url),
      mojo::Clone(mime_type),
      mojo::Clone(files),
      mojo::Clone(activity_name),
      mojo::Clone(drive_share_url),
      mojo::Clone(share_text),
      mojo::Clone(share_title),
      mojo::Clone(start_type),
      mojo::Clone(categories),
      mojo::Clone(data),
      mojo::Clone(ui_bypassed),
      mojo::Clone(extras)
  );
}

template <typename T, Intent::EnableIfSame<T>*>
bool Intent::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->action, other_struct.action))
    return false;
  if (!mojo::Equals(this->url, other_struct.url))
    return false;
  if (!mojo::Equals(this->mime_type, other_struct.mime_type))
    return false;
  if (!mojo::Equals(this->files, other_struct.files))
    return false;
  if (!mojo::Equals(this->activity_name, other_struct.activity_name))
    return false;
  if (!mojo::Equals(this->drive_share_url, other_struct.drive_share_url))
    return false;
  if (!mojo::Equals(this->share_text, other_struct.share_text))
    return false;
  if (!mojo::Equals(this->share_title, other_struct.share_title))
    return false;
  if (!mojo::Equals(this->start_type, other_struct.start_type))
    return false;
  if (!mojo::Equals(this->categories, other_struct.categories))
    return false;
  if (!mojo::Equals(this->data, other_struct.data))
    return false;
  if (!mojo::Equals(this->ui_bypassed, other_struct.ui_bypassed))
    return false;
  if (!mojo::Equals(this->extras, other_struct.extras))
    return false;
  return true;
}

template <typename T, Intent::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.action < rhs.action)
    return true;
  if (rhs.action < lhs.action)
    return false;
  if (lhs.url < rhs.url)
    return true;
  if (rhs.url < lhs.url)
    return false;
  if (lhs.mime_type < rhs.mime_type)
    return true;
  if (rhs.mime_type < lhs.mime_type)
    return false;
  if (lhs.files < rhs.files)
    return true;
  if (rhs.files < lhs.files)
    return false;
  if (lhs.activity_name < rhs.activity_name)
    return true;
  if (rhs.activity_name < lhs.activity_name)
    return false;
  if (lhs.drive_share_url < rhs.drive_share_url)
    return true;
  if (rhs.drive_share_url < lhs.drive_share_url)
    return false;
  if (lhs.share_text < rhs.share_text)
    return true;
  if (rhs.share_text < lhs.share_text)
    return false;
  if (lhs.share_title < rhs.share_title)
    return true;
  if (rhs.share_title < lhs.share_title)
    return false;
  if (lhs.start_type < rhs.start_type)
    return true;
  if (rhs.start_type < lhs.start_type)
    return false;
  if (lhs.categories < rhs.categories)
    return true;
  if (rhs.categories < lhs.categories)
    return false;
  if (lhs.data < rhs.data)
    return true;
  if (rhs.data < lhs.data)
    return false;
  if (lhs.ui_bypassed < rhs.ui_bypassed)
    return true;
  if (rhs.ui_bypassed < lhs.ui_bypassed)
    return false;
  if (lhs.extras < rhs.extras)
    return true;
  if (rhs.extras < lhs.extras)
    return false;
  return false;
}
template <typename StructPtrType>
ReplacedAppPreferencesPtr ReplacedAppPreferences::Clone() const {
  return New(
      mojo::Clone(replaced_preference)
  );
}

template <typename T, ReplacedAppPreferences::EnableIfSame<T>*>
bool ReplacedAppPreferences::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->replaced_preference, other_struct.replaced_preference))
    return false;
  return true;
}

template <typename T, ReplacedAppPreferences::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.replaced_preference < rhs.replaced_preference)
    return true;
  if (rhs.replaced_preference < lhs.replaced_preference)
    return false;
  return false;
}
template <typename StructPtrType>
PreferredAppChangesPtr PreferredAppChanges::Clone() const {
  return New(
      mojo::Clone(added_filters),
      mojo::Clone(removed_filters)
  );
}

template <typename T, PreferredAppChanges::EnableIfSame<T>*>
bool PreferredAppChanges::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->added_filters, other_struct.added_filters))
    return false;
  if (!mojo::Equals(this->removed_filters, other_struct.removed_filters))
    return false;
  return true;
}

template <typename T, PreferredAppChanges::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.added_filters < rhs.added_filters)
    return true;
  if (rhs.added_filters < lhs.added_filters)
    return false;
  if (lhs.removed_filters < rhs.removed_filters)
    return true;
  if (rhs.removed_filters < lhs.removed_filters)
    return false;
  return false;
}
template <typename StructPtrType>
PreferredAppPtr PreferredApp::Clone() const {
  return New(
      mojo::Clone(intent_filter),
      mojo::Clone(app_id)
  );
}

template <typename T, PreferredApp::EnableIfSame<T>*>
bool PreferredApp::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->intent_filter, other_struct.intent_filter))
    return false;
  if (!mojo::Equals(this->app_id, other_struct.app_id))
    return false;
  return true;
}

template <typename T, PreferredApp::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.intent_filter < rhs.intent_filter)
    return true;
  if (rhs.intent_filter < lhs.intent_filter)
    return false;
  if (lhs.app_id < rhs.app_id)
    return true;
  if (rhs.app_id < lhs.app_id)
    return false;
  return false;
}
template <typename StructPtrType>
FilePathsPtr FilePaths::Clone() const {
  return New(
      mojo::Clone(file_paths)
  );
}

template <typename T, FilePaths::EnableIfSame<T>*>
bool FilePaths::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->file_paths, other_struct.file_paths))
    return false;
  return true;
}

template <typename T, FilePaths::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.file_paths < rhs.file_paths)
    return true;
  if (rhs.file_paths < lhs.file_paths)
    return false;
  return false;
}
template <typename StructPtrType>
CapabilityAccessPtr CapabilityAccess::Clone() const {
  return New(
      mojo::Clone(app_id),
      mojo::Clone(camera),
      mojo::Clone(microphone)
  );
}

template <typename T, CapabilityAccess::EnableIfSame<T>*>
bool CapabilityAccess::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->app_id, other_struct.app_id))
    return false;
  if (!mojo::Equals(this->camera, other_struct.camera))
    return false;
  if (!mojo::Equals(this->microphone, other_struct.microphone))
    return false;
  return true;
}

template <typename T, CapabilityAccess::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.app_id < rhs.app_id)
    return true;
  if (rhs.app_id < lhs.app_id)
    return false;
  if (lhs.camera < rhs.camera)
    return true;
  if (rhs.camera < lhs.camera)
    return false;
  if (lhs.microphone < rhs.microphone)
    return true;
  if (rhs.microphone < lhs.microphone)
    return false;
  return false;
}
template <typename StructPtrType>
RectPtr Rect::Clone() const {
  return New(
      mojo::Clone(x),
      mojo::Clone(y),
      mojo::Clone(width),
      mojo::Clone(height)
  );
}

template <typename T, Rect::EnableIfSame<T>*>
bool Rect::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->x, other_struct.x))
    return false;
  if (!mojo::Equals(this->y, other_struct.y))
    return false;
  if (!mojo::Equals(this->width, other_struct.width))
    return false;
  if (!mojo::Equals(this->height, other_struct.height))
    return false;
  return true;
}

template <typename T, Rect::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.x < rhs.x)
    return true;
  if (rhs.x < lhs.x)
    return false;
  if (lhs.y < rhs.y)
    return true;
  if (rhs.y < lhs.y)
    return false;
  if (lhs.width < rhs.width)
    return true;
  if (rhs.width < lhs.width)
    return false;
  if (lhs.height < rhs.height)
    return true;
  if (rhs.height < lhs.height)
    return false;
  return false;
}
template <typename StructPtrType>
WindowInfoPtr WindowInfo::Clone() const {
  return New(
      mojo::Clone(window_id),
      mojo::Clone(state),
      mojo::Clone(display_id),
      mojo::Clone(bounds)
  );
}

template <typename T, WindowInfo::EnableIfSame<T>*>
bool WindowInfo::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->window_id, other_struct.window_id))
    return false;
  if (!mojo::Equals(this->state, other_struct.state))
    return false;
  if (!mojo::Equals(this->display_id, other_struct.display_id))
    return false;
  if (!mojo::Equals(this->bounds, other_struct.bounds))
    return false;
  return true;
}

template <typename T, WindowInfo::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.window_id < rhs.window_id)
    return true;
  if (rhs.window_id < lhs.window_id)
    return false;
  if (lhs.state < rhs.state)
    return true;
  if (rhs.state < lhs.state)
    return false;
  if (lhs.display_id < rhs.display_id)
    return true;
  if (rhs.display_id < lhs.display_id)
    return false;
  if (lhs.bounds < rhs.bounds)
    return true;
  if (rhs.bounds < lhs.bounds)
    return false;
  return false;
}
template <typename StructPtrType>
RunOnOsLoginPtr RunOnOsLogin::Clone() const {
  return New(
      mojo::Clone(login_mode),
      mojo::Clone(is_managed)
  );
}

template <typename T, RunOnOsLogin::EnableIfSame<T>*>
bool RunOnOsLogin::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->login_mode, other_struct.login_mode))
    return false;
  if (!mojo::Equals(this->is_managed, other_struct.is_managed))
    return false;
  return true;
}

template <typename T, RunOnOsLogin::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.login_mode < rhs.login_mode)
    return true;
  if (rhs.login_mode < lhs.login_mode)
    return false;
  if (lhs.is_managed < rhs.is_managed)
    return true;
  if (rhs.is_managed < lhs.is_managed)
    return false;
  return false;
}


}  // namespace mojom
}  // namespace apps

namespace mojo {


template <>
struct  StructTraits<::apps::mojom::App::DataView,
                                         ::apps::mojom::AppPtr> {
  static bool IsNull(const ::apps::mojom::AppPtr& input) { return !input; }
  static void SetToNull(::apps::mojom::AppPtr* output) { output->reset(); }

  static decltype(::apps::mojom::App::app_type) app_type(
      const ::apps::mojom::AppPtr& input) {
    return input->app_type;
  }

  static const decltype(::apps::mojom::App::app_id)& app_id(
      const ::apps::mojom::AppPtr& input) {
    return input->app_id;
  }

  static decltype(::apps::mojom::App::readiness) readiness(
      const ::apps::mojom::AppPtr& input) {
    return input->readiness;
  }

  static const decltype(::apps::mojom::App::name)& name(
      const ::apps::mojom::AppPtr& input) {
    return input->name;
  }

  static const decltype(::apps::mojom::App::short_name)& short_name(
      const ::apps::mojom::AppPtr& input) {
    return input->short_name;
  }

  static const decltype(::apps::mojom::App::publisher_id)& publisher_id(
      const ::apps::mojom::AppPtr& input) {
    return input->publisher_id;
  }

  static const decltype(::apps::mojom::App::description)& description(
      const ::apps::mojom::AppPtr& input) {
    return input->description;
  }

  static const decltype(::apps::mojom::App::version)& version(
      const ::apps::mojom::AppPtr& input) {
    return input->version;
  }

  static const decltype(::apps::mojom::App::additional_search_terms)& additional_search_terms(
      const ::apps::mojom::AppPtr& input) {
    return input->additional_search_terms;
  }

  static const decltype(::apps::mojom::App::icon_key)& icon_key(
      const ::apps::mojom::AppPtr& input) {
    return input->icon_key;
  }

  static const decltype(::apps::mojom::App::last_launch_time)& last_launch_time(
      const ::apps::mojom::AppPtr& input) {
    return input->last_launch_time;
  }

  static const decltype(::apps::mojom::App::install_time)& install_time(
      const ::apps::mojom::AppPtr& input) {
    return input->install_time;
  }

  static const decltype(::apps::mojom::App::permissions)& permissions(
      const ::apps::mojom::AppPtr& input) {
    return input->permissions;
  }

  static decltype(::apps::mojom::App::install_reason) install_reason(
      const ::apps::mojom::AppPtr& input) {
    return input->install_reason;
  }

  static decltype(::apps::mojom::App::install_source) install_source(
      const ::apps::mojom::AppPtr& input) {
    return input->install_source;
  }

  static const decltype(::apps::mojom::App::policy_id)& policy_id(
      const ::apps::mojom::AppPtr& input) {
    return input->policy_id;
  }

  static decltype(::apps::mojom::App::is_platform_app) is_platform_app(
      const ::apps::mojom::AppPtr& input) {
    return input->is_platform_app;
  }

  static decltype(::apps::mojom::App::recommendable) recommendable(
      const ::apps::mojom::AppPtr& input) {
    return input->recommendable;
  }

  static decltype(::apps::mojom::App::searchable) searchable(
      const ::apps::mojom::AppPtr& input) {
    return input->searchable;
  }

  static decltype(::apps::mojom::App::show_in_launcher) show_in_launcher(
      const ::apps::mojom::AppPtr& input) {
    return input->show_in_launcher;
  }

  static decltype(::apps::mojom::App::show_in_shelf) show_in_shelf(
      const ::apps::mojom::AppPtr& input) {
    return input->show_in_shelf;
  }

  static decltype(::apps::mojom::App::show_in_search) show_in_search(
      const ::apps::mojom::AppPtr& input) {
    return input->show_in_search;
  }

  static decltype(::apps::mojom::App::show_in_management) show_in_management(
      const ::apps::mojom::AppPtr& input) {
    return input->show_in_management;
  }

  static decltype(::apps::mojom::App::handles_intents) handles_intents(
      const ::apps::mojom::AppPtr& input) {
    return input->handles_intents;
  }

  static decltype(::apps::mojom::App::allow_uninstall) allow_uninstall(
      const ::apps::mojom::AppPtr& input) {
    return input->allow_uninstall;
  }

  static decltype(::apps::mojom::App::has_badge) has_badge(
      const ::apps::mojom::AppPtr& input) {
    return input->has_badge;
  }

  static decltype(::apps::mojom::App::paused) paused(
      const ::apps::mojom::AppPtr& input) {
    return input->paused;
  }

  static const decltype(::apps::mojom::App::intent_filters)& intent_filters(
      const ::apps::mojom::AppPtr& input) {
    return input->intent_filters;
  }

  static decltype(::apps::mojom::App::resize_locked) resize_locked(
      const ::apps::mojom::AppPtr& input) {
    return input->resize_locked;
  }

  static decltype(::apps::mojom::App::window_mode) window_mode(
      const ::apps::mojom::AppPtr& input) {
    return input->window_mode;
  }

  static const decltype(::apps::mojom::App::run_on_os_login)& run_on_os_login(
      const ::apps::mojom::AppPtr& input) {
    return input->run_on_os_login;
  }

  static bool Read(::apps::mojom::App::DataView input, ::apps::mojom::AppPtr* output);
};


template <>
struct  StructTraits<::apps::mojom::Permission::DataView,
                                         ::apps::mojom::PermissionPtr> {
  static bool IsNull(const ::apps::mojom::PermissionPtr& input) { return !input; }
  static void SetToNull(::apps::mojom::PermissionPtr* output) { output->reset(); }

  static decltype(::apps::mojom::Permission::permission_type) permission_type(
      const ::apps::mojom::PermissionPtr& input) {
    return input->permission_type;
  }

  static const decltype(::apps::mojom::Permission::value)& value(
      const ::apps::mojom::PermissionPtr& input) {
    return input->value;
  }

  static decltype(::apps::mojom::Permission::is_managed) is_managed(
      const ::apps::mojom::PermissionPtr& input) {
    return input->is_managed;
  }

  static bool Read(::apps::mojom::Permission::DataView input, ::apps::mojom::PermissionPtr* output);
};


template <>
struct  StructTraits<::apps::mojom::IconKey::DataView,
                                         ::apps::mojom::IconKeyPtr> {
  static bool IsNull(const ::apps::mojom::IconKeyPtr& input) { return !input; }
  static void SetToNull(::apps::mojom::IconKeyPtr* output) { output->reset(); }

  static decltype(::apps::mojom::IconKey::timeline) timeline(
      const ::apps::mojom::IconKeyPtr& input) {
    return input->timeline;
  }

  static decltype(::apps::mojom::IconKey::resource_id) resource_id(
      const ::apps::mojom::IconKeyPtr& input) {
    return input->resource_id;
  }

  static decltype(::apps::mojom::IconKey::icon_effects) icon_effects(
      const ::apps::mojom::IconKeyPtr& input) {
    return input->icon_effects;
  }

  static bool Read(::apps::mojom::IconKey::DataView input, ::apps::mojom::IconKeyPtr* output);
};


template <>
struct  StructTraits<::apps::mojom::MenuItems::DataView,
                                         ::apps::mojom::MenuItemsPtr> {
  static bool IsNull(const ::apps::mojom::MenuItemsPtr& input) { return !input; }
  static void SetToNull(::apps::mojom::MenuItemsPtr* output) { output->reset(); }

  static  decltype(::apps::mojom::MenuItems::items)& items(
       ::apps::mojom::MenuItemsPtr& input) {
    return input->items;
  }

  static bool Read(::apps::mojom::MenuItems::DataView input, ::apps::mojom::MenuItemsPtr* output);
};


template <>
struct  StructTraits<::apps::mojom::MenuItem::DataView,
                                         ::apps::mojom::MenuItemPtr> {
  static bool IsNull(const ::apps::mojom::MenuItemPtr& input) { return !input; }
  static void SetToNull(::apps::mojom::MenuItemPtr* output) { output->reset(); }

  static decltype(::apps::mojom::MenuItem::type) type(
      const ::apps::mojom::MenuItemPtr& input) {
    return input->type;
  }

  static decltype(::apps::mojom::MenuItem::command_id) command_id(
      const ::apps::mojom::MenuItemPtr& input) {
    return input->command_id;
  }

  static decltype(::apps::mojom::MenuItem::string_id) string_id(
      const ::apps::mojom::MenuItemPtr& input) {
    return input->string_id;
  }

  static  decltype(::apps::mojom::MenuItem::submenu)& submenu(
       ::apps::mojom::MenuItemPtr& input) {
    return input->submenu;
  }

  static decltype(::apps::mojom::MenuItem::radio_group_id) radio_group_id(
      const ::apps::mojom::MenuItemPtr& input) {
    return input->radio_group_id;
  }

  static const decltype(::apps::mojom::MenuItem::shortcut_id)& shortcut_id(
      const ::apps::mojom::MenuItemPtr& input) {
    return input->shortcut_id;
  }

  static const decltype(::apps::mojom::MenuItem::label)& label(
      const ::apps::mojom::MenuItemPtr& input) {
    return input->label;
  }

  static  decltype(::apps::mojom::MenuItem::image)& image(
       ::apps::mojom::MenuItemPtr& input) {
    return input->image;
  }

  static bool Read(::apps::mojom::MenuItem::DataView input, ::apps::mojom::MenuItemPtr* output);
};


template <>
struct  StructTraits<::apps::mojom::ConditionValue::DataView,
                                         ::apps::mojom::ConditionValuePtr> {
  static bool IsNull(const ::apps::mojom::ConditionValuePtr& input) { return !input; }
  static void SetToNull(::apps::mojom::ConditionValuePtr* output) { output->reset(); }

  static const decltype(::apps::mojom::ConditionValue::value)& value(
      const ::apps::mojom::ConditionValuePtr& input) {
    return input->value;
  }

  static decltype(::apps::mojom::ConditionValue::match_type) match_type(
      const ::apps::mojom::ConditionValuePtr& input) {
    return input->match_type;
  }

  static bool Read(::apps::mojom::ConditionValue::DataView input, ::apps::mojom::ConditionValuePtr* output);
};


template <>
struct  StructTraits<::apps::mojom::Condition::DataView,
                                         ::apps::mojom::ConditionPtr> {
  static bool IsNull(const ::apps::mojom::ConditionPtr& input) { return !input; }
  static void SetToNull(::apps::mojom::ConditionPtr* output) { output->reset(); }

  static decltype(::apps::mojom::Condition::condition_type) condition_type(
      const ::apps::mojom::ConditionPtr& input) {
    return input->condition_type;
  }

  static const decltype(::apps::mojom::Condition::condition_values)& condition_values(
      const ::apps::mojom::ConditionPtr& input) {
    return input->condition_values;
  }

  static bool Read(::apps::mojom::Condition::DataView input, ::apps::mojom::ConditionPtr* output);
};


template <>
struct  StructTraits<::apps::mojom::IntentFilter::DataView,
                                         ::apps::mojom::IntentFilterPtr> {
  static bool IsNull(const ::apps::mojom::IntentFilterPtr& input) { return !input; }
  static void SetToNull(::apps::mojom::IntentFilterPtr* output) { output->reset(); }

  static const decltype(::apps::mojom::IntentFilter::conditions)& conditions(
      const ::apps::mojom::IntentFilterPtr& input) {
    return input->conditions;
  }

  static const decltype(::apps::mojom::IntentFilter::activity_name)& activity_name(
      const ::apps::mojom::IntentFilterPtr& input) {
    return input->activity_name;
  }

  static const decltype(::apps::mojom::IntentFilter::activity_label)& activity_label(
      const ::apps::mojom::IntentFilterPtr& input) {
    return input->activity_label;
  }

  static bool Read(::apps::mojom::IntentFilter::DataView input, ::apps::mojom::IntentFilterPtr* output);
};


template <>
struct  StructTraits<::apps::mojom::IntentFile::DataView,
                                         ::apps::mojom::IntentFilePtr> {
  static bool IsNull(const ::apps::mojom::IntentFilePtr& input) { return !input; }
  static void SetToNull(::apps::mojom::IntentFilePtr* output) { output->reset(); }

  static const decltype(::apps::mojom::IntentFile::url)& url(
      const ::apps::mojom::IntentFilePtr& input) {
    return input->url;
  }

  static const decltype(::apps::mojom::IntentFile::mime_type)& mime_type(
      const ::apps::mojom::IntentFilePtr& input) {
    return input->mime_type;
  }

  static const decltype(::apps::mojom::IntentFile::file_name)& file_name(
      const ::apps::mojom::IntentFilePtr& input) {
    return input->file_name;
  }

  static decltype(::apps::mojom::IntentFile::file_size) file_size(
      const ::apps::mojom::IntentFilePtr& input) {
    return input->file_size;
  }

  static decltype(::apps::mojom::IntentFile::is_directory) is_directory(
      const ::apps::mojom::IntentFilePtr& input) {
    return input->is_directory;
  }

  static bool Read(::apps::mojom::IntentFile::DataView input, ::apps::mojom::IntentFilePtr* output);
};


template <>
struct  StructTraits<::apps::mojom::Intent::DataView,
                                         ::apps::mojom::IntentPtr> {
  static bool IsNull(const ::apps::mojom::IntentPtr& input) { return !input; }
  static void SetToNull(::apps::mojom::IntentPtr* output) { output->reset(); }

  static const decltype(::apps::mojom::Intent::action)& action(
      const ::apps::mojom::IntentPtr& input) {
    return input->action;
  }

  static const decltype(::apps::mojom::Intent::url)& url(
      const ::apps::mojom::IntentPtr& input) {
    return input->url;
  }

  static const decltype(::apps::mojom::Intent::mime_type)& mime_type(
      const ::apps::mojom::IntentPtr& input) {
    return input->mime_type;
  }

  static const decltype(::apps::mojom::Intent::files)& files(
      const ::apps::mojom::IntentPtr& input) {
    return input->files;
  }

  static const decltype(::apps::mojom::Intent::activity_name)& activity_name(
      const ::apps::mojom::IntentPtr& input) {
    return input->activity_name;
  }

  static const decltype(::apps::mojom::Intent::drive_share_url)& drive_share_url(
      const ::apps::mojom::IntentPtr& input) {
    return input->drive_share_url;
  }

  static const decltype(::apps::mojom::Intent::share_text)& share_text(
      const ::apps::mojom::IntentPtr& input) {
    return input->share_text;
  }

  static const decltype(::apps::mojom::Intent::share_title)& share_title(
      const ::apps::mojom::IntentPtr& input) {
    return input->share_title;
  }

  static const decltype(::apps::mojom::Intent::start_type)& start_type(
      const ::apps::mojom::IntentPtr& input) {
    return input->start_type;
  }

  static const decltype(::apps::mojom::Intent::categories)& categories(
      const ::apps::mojom::IntentPtr& input) {
    return input->categories;
  }

  static const decltype(::apps::mojom::Intent::data)& data(
      const ::apps::mojom::IntentPtr& input) {
    return input->data;
  }

  static decltype(::apps::mojom::Intent::ui_bypassed) ui_bypassed(
      const ::apps::mojom::IntentPtr& input) {
    return input->ui_bypassed;
  }

  static const decltype(::apps::mojom::Intent::extras)& extras(
      const ::apps::mojom::IntentPtr& input) {
    return input->extras;
  }

  static bool Read(::apps::mojom::Intent::DataView input, ::apps::mojom::IntentPtr* output);
};


template <>
struct  StructTraits<::apps::mojom::ReplacedAppPreferences::DataView,
                                         ::apps::mojom::ReplacedAppPreferencesPtr> {
  static bool IsNull(const ::apps::mojom::ReplacedAppPreferencesPtr& input) { return !input; }
  static void SetToNull(::apps::mojom::ReplacedAppPreferencesPtr* output) { output->reset(); }

  static const decltype(::apps::mojom::ReplacedAppPreferences::replaced_preference)& replaced_preference(
      const ::apps::mojom::ReplacedAppPreferencesPtr& input) {
    return input->replaced_preference;
  }

  static bool Read(::apps::mojom::ReplacedAppPreferences::DataView input, ::apps::mojom::ReplacedAppPreferencesPtr* output);
};


template <>
struct  StructTraits<::apps::mojom::PreferredAppChanges::DataView,
                                         ::apps::mojom::PreferredAppChangesPtr> {
  static bool IsNull(const ::apps::mojom::PreferredAppChangesPtr& input) { return !input; }
  static void SetToNull(::apps::mojom::PreferredAppChangesPtr* output) { output->reset(); }

  static const decltype(::apps::mojom::PreferredAppChanges::added_filters)& added_filters(
      const ::apps::mojom::PreferredAppChangesPtr& input) {
    return input->added_filters;
  }

  static const decltype(::apps::mojom::PreferredAppChanges::removed_filters)& removed_filters(
      const ::apps::mojom::PreferredAppChangesPtr& input) {
    return input->removed_filters;
  }

  static bool Read(::apps::mojom::PreferredAppChanges::DataView input, ::apps::mojom::PreferredAppChangesPtr* output);
};


template <>
struct  StructTraits<::apps::mojom::PreferredApp::DataView,
                                         ::apps::mojom::PreferredAppPtr> {
  static bool IsNull(const ::apps::mojom::PreferredAppPtr& input) { return !input; }
  static void SetToNull(::apps::mojom::PreferredAppPtr* output) { output->reset(); }

  static const decltype(::apps::mojom::PreferredApp::intent_filter)& intent_filter(
      const ::apps::mojom::PreferredAppPtr& input) {
    return input->intent_filter;
  }

  static const decltype(::apps::mojom::PreferredApp::app_id)& app_id(
      const ::apps::mojom::PreferredAppPtr& input) {
    return input->app_id;
  }

  static bool Read(::apps::mojom::PreferredApp::DataView input, ::apps::mojom::PreferredAppPtr* output);
};


template <>
struct  StructTraits<::apps::mojom::FilePaths::DataView,
                                         ::apps::mojom::FilePathsPtr> {
  static bool IsNull(const ::apps::mojom::FilePathsPtr& input) { return !input; }
  static void SetToNull(::apps::mojom::FilePathsPtr* output) { output->reset(); }

  static const decltype(::apps::mojom::FilePaths::file_paths)& file_paths(
      const ::apps::mojom::FilePathsPtr& input) {
    return input->file_paths;
  }

  static bool Read(::apps::mojom::FilePaths::DataView input, ::apps::mojom::FilePathsPtr* output);
};


template <>
struct  StructTraits<::apps::mojom::CapabilityAccess::DataView,
                                         ::apps::mojom::CapabilityAccessPtr> {
  static bool IsNull(const ::apps::mojom::CapabilityAccessPtr& input) { return !input; }
  static void SetToNull(::apps::mojom::CapabilityAccessPtr* output) { output->reset(); }

  static const decltype(::apps::mojom::CapabilityAccess::app_id)& app_id(
      const ::apps::mojom::CapabilityAccessPtr& input) {
    return input->app_id;
  }

  static decltype(::apps::mojom::CapabilityAccess::camera) camera(
      const ::apps::mojom::CapabilityAccessPtr& input) {
    return input->camera;
  }

  static decltype(::apps::mojom::CapabilityAccess::microphone) microphone(
      const ::apps::mojom::CapabilityAccessPtr& input) {
    return input->microphone;
  }

  static bool Read(::apps::mojom::CapabilityAccess::DataView input, ::apps::mojom::CapabilityAccessPtr* output);
};


template <>
struct  StructTraits<::apps::mojom::Rect::DataView,
                                         ::apps::mojom::RectPtr> {
  static bool IsNull(const ::apps::mojom::RectPtr& input) { return !input; }
  static void SetToNull(::apps::mojom::RectPtr* output) { output->reset(); }

  static decltype(::apps::mojom::Rect::x) x(
      const ::apps::mojom::RectPtr& input) {
    return input->x;
  }

  static decltype(::apps::mojom::Rect::y) y(
      const ::apps::mojom::RectPtr& input) {
    return input->y;
  }

  static decltype(::apps::mojom::Rect::width) width(
      const ::apps::mojom::RectPtr& input) {
    return input->width;
  }

  static decltype(::apps::mojom::Rect::height) height(
      const ::apps::mojom::RectPtr& input) {
    return input->height;
  }

  static bool Read(::apps::mojom::Rect::DataView input, ::apps::mojom::RectPtr* output);
};


template <>
struct  StructTraits<::apps::mojom::WindowInfo::DataView,
                                         ::apps::mojom::WindowInfoPtr> {
  static bool IsNull(const ::apps::mojom::WindowInfoPtr& input) { return !input; }
  static void SetToNull(::apps::mojom::WindowInfoPtr* output) { output->reset(); }

  static decltype(::apps::mojom::WindowInfo::window_id) window_id(
      const ::apps::mojom::WindowInfoPtr& input) {
    return input->window_id;
  }

  static decltype(::apps::mojom::WindowInfo::state) state(
      const ::apps::mojom::WindowInfoPtr& input) {
    return input->state;
  }

  static decltype(::apps::mojom::WindowInfo::display_id) display_id(
      const ::apps::mojom::WindowInfoPtr& input) {
    return input->display_id;
  }

  static const decltype(::apps::mojom::WindowInfo::bounds)& bounds(
      const ::apps::mojom::WindowInfoPtr& input) {
    return input->bounds;
  }

  static bool Read(::apps::mojom::WindowInfo::DataView input, ::apps::mojom::WindowInfoPtr* output);
};


template <>
struct  StructTraits<::apps::mojom::RunOnOsLogin::DataView,
                                         ::apps::mojom::RunOnOsLoginPtr> {
  static bool IsNull(const ::apps::mojom::RunOnOsLoginPtr& input) { return !input; }
  static void SetToNull(::apps::mojom::RunOnOsLoginPtr* output) { output->reset(); }

  static decltype(::apps::mojom::RunOnOsLogin::login_mode) login_mode(
      const ::apps::mojom::RunOnOsLoginPtr& input) {
    return input->login_mode;
  }

  static decltype(::apps::mojom::RunOnOsLogin::is_managed) is_managed(
      const ::apps::mojom::RunOnOsLoginPtr& input) {
    return input->is_managed;
  }

  static bool Read(::apps::mojom::RunOnOsLogin::DataView input, ::apps::mojom::RunOnOsLoginPtr* output);
};


template <>
struct  UnionTraits<::apps::mojom::PermissionValue::DataView,
                                        ::apps::mojom::PermissionValuePtr> {
  static bool IsNull(const ::apps::mojom::PermissionValuePtr& input) { return !input; }
  static void SetToNull(::apps::mojom::PermissionValuePtr* output) { output->reset(); }

  static ::apps::mojom::PermissionValue::Tag GetTag(const ::apps::mojom::PermissionValuePtr& input) {
    return input->which();
  }

  static  bool bool_value(const ::apps::mojom::PermissionValuePtr& input) {
    return input->get_bool_value();
  }

  static  ::apps::mojom::TriState tristate_value(const ::apps::mojom::PermissionValuePtr& input) {
    return input->get_tristate_value();
  }

  static bool Read(::apps::mojom::PermissionValue::DataView input, ::apps::mojom::PermissionValuePtr* output);
};

}  // namespace mojo

#endif  // COMPONENTS_SERVICES_APP_SERVICE_PUBLIC_MOJOM_TYPES_MOJOM_H_