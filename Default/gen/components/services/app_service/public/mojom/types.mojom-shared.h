// components/services/app_service/public/mojom/types.mojom-shared.h is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2016 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef COMPONENTS_SERVICES_APP_SERVICE_PUBLIC_MOJOM_TYPES_MOJOM_SHARED_H_
#define COMPONENTS_SERVICES_APP_SERVICE_PUBLIC_MOJOM_TYPES_MOJOM_SHARED_H_

#include <stdint.h>

#include <functional>
#include <iosfwd>
#include <type_traits>
#include <utility>
#include "mojo/public/cpp/bindings/array_data_view.h"
#include "mojo/public/cpp/bindings/enum_traits.h"
#include "mojo/public/cpp/bindings/interface_data_view.h"
#include "mojo/public/cpp/bindings/lib/bindings_internal.h"
#include "mojo/public/cpp/bindings/lib/serialization.h"
#include "mojo/public/cpp/bindings/map_data_view.h"
#include "mojo/public/cpp/bindings/string_data_view.h"

#include "third_party/perfetto/include/perfetto/tracing/traced_value_forward.h"

#include "components/services/app_service/public/mojom/types.mojom-shared-internal.h"
#include "mojo/public/mojom/base/file_path.mojom-shared.h"
#include "mojo/public/mojom/base/safe_base_name.mojom-shared.h"
#include "mojo/public/mojom/base/time.mojom-shared.h"
#include "ui/gfx/image/mojom/image.mojom-shared.h"
#include "url/mojom/url.mojom-shared.h"
#include "mojo/public/cpp/bindings/lib/interface_serialization.h"






namespace apps {
namespace mojom {
class AppDataView;

class PermissionDataView;

class IconKeyDataView;

class MenuItemsDataView;

class MenuItemDataView;

class ConditionValueDataView;

class ConditionDataView;

class IntentFilterDataView;

class IntentFileDataView;

class IntentDataView;

class ReplacedAppPreferencesDataView;

class PreferredAppChangesDataView;

class PreferredAppDataView;

class FilePathsDataView;

class CapabilityAccessDataView;

class RectDataView;

class WindowInfoDataView;

class RunOnOsLoginDataView;

class PermissionValueDataView;


}  // namespace mojom
}  // namespace apps

namespace mojo {
namespace internal {

template <>
struct MojomTypeTraits<::apps::mojom::AppDataView> {
  using Data = ::apps::mojom::internal::App_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::apps::mojom::PermissionDataView> {
  using Data = ::apps::mojom::internal::Permission_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::apps::mojom::IconKeyDataView> {
  using Data = ::apps::mojom::internal::IconKey_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::apps::mojom::MenuItemsDataView> {
  using Data = ::apps::mojom::internal::MenuItems_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::apps::mojom::MenuItemDataView> {
  using Data = ::apps::mojom::internal::MenuItem_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::apps::mojom::ConditionValueDataView> {
  using Data = ::apps::mojom::internal::ConditionValue_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::apps::mojom::ConditionDataView> {
  using Data = ::apps::mojom::internal::Condition_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::apps::mojom::IntentFilterDataView> {
  using Data = ::apps::mojom::internal::IntentFilter_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::apps::mojom::IntentFileDataView> {
  using Data = ::apps::mojom::internal::IntentFile_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::apps::mojom::IntentDataView> {
  using Data = ::apps::mojom::internal::Intent_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::apps::mojom::ReplacedAppPreferencesDataView> {
  using Data = ::apps::mojom::internal::ReplacedAppPreferences_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::apps::mojom::PreferredAppChangesDataView> {
  using Data = ::apps::mojom::internal::PreferredAppChanges_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::apps::mojom::PreferredAppDataView> {
  using Data = ::apps::mojom::internal::PreferredApp_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::apps::mojom::FilePathsDataView> {
  using Data = ::apps::mojom::internal::FilePaths_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::apps::mojom::CapabilityAccessDataView> {
  using Data = ::apps::mojom::internal::CapabilityAccess_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::apps::mojom::RectDataView> {
  using Data = ::apps::mojom::internal::Rect_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::apps::mojom::WindowInfoDataView> {
  using Data = ::apps::mojom::internal::WindowInfo_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::apps::mojom::RunOnOsLoginDataView> {
  using Data = ::apps::mojom::internal::RunOnOsLogin_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::apps::mojom::PermissionValueDataView> {
  using Data = ::apps::mojom::internal::PermissionValue_Data;
  using DataAsArrayElement = Data;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kUnion;
};

}  // namespace internal
}  // namespace mojo


namespace apps {
namespace mojom {


enum class PermissionType : int32_t {
  
  kUnknown = 0,
  
  kCamera = 1,
  
  kLocation = 2,
  
  kMicrophone = 3,
  
  kNotifications = 4,
  
  kContacts = 5,
  
  kStorage = 6,
  
  kPrinting = 7,
  
  kFileHandling = 8,
  kMinValue = 0,
  kMaxValue = 8,
};

 std::ostream& operator<<(std::ostream& os, PermissionType value);
inline bool IsKnownEnumValue(PermissionType value) {
  return internal::PermissionType_Data::IsKnownValue(
      static_cast<int32_t>(value));
}


enum class AppType : int32_t {
  
  kUnknown = 0,
  
  kArc = 1,
  
  kBuiltIn = 2,
  
  kCrostini = 3,
  
  kChromeApp = 4,
  
  kWeb = 5,
  
  kMacOs = 6,
  
  kPluginVm = 7,
  
  kStandaloneBrowser = 8,
  
  kRemote = 9,
  
  kBorealis = 10,
  
  kSystemWeb = 11,
  
  kStandaloneBrowserChromeApp = 12,
  
  kExtension = 13,
  
  kStandaloneBrowserExtension = 14,
  kMinValue = 0,
  kMaxValue = 14,
};

 std::ostream& operator<<(std::ostream& os, AppType value);
inline bool IsKnownEnumValue(AppType value) {
  return internal::AppType_Data::IsKnownValue(
      static_cast<int32_t>(value));
}


enum class Readiness : int32_t {
  
  kUnknown = 0,
  
  kReady = 1,
  
  kDisabledByBlocklist = 2,
  
  kDisabledByPolicy = 3,
  
  kDisabledByUser = 4,
  
  kTerminated = 5,
  
  kUninstalledByUser = 6,
  
  kRemoved = 7,
  
  kUninstalledByMigration = 8,
  kMinValue = 0,
  kMaxValue = 8,
};

 std::ostream& operator<<(std::ostream& os, Readiness value);
inline bool IsKnownEnumValue(Readiness value) {
  return internal::Readiness_Data::IsKnownValue(
      static_cast<int32_t>(value));
}


enum class InstallReason : int32_t {
  
  kUnknown = 0,
  
  kSystem = 1,
  
  kPolicy = 2,
  
  kOem = 3,
  
  kDefault = 4,
  
  kSync = 5,
  
  kUser = 6,
  
  kSubApp = 7,
  kMinValue = 0,
  kMaxValue = 7,
};

 std::ostream& operator<<(std::ostream& os, InstallReason value);
inline bool IsKnownEnumValue(InstallReason value) {
  return internal::InstallReason_Data::IsKnownValue(
      static_cast<int32_t>(value));
}


enum class InstallSource : int32_t {
  
  kUnknown = 0,
  
  kSystem = 1,
  
  kSync = 2,
  
  kPlayStore = 3,
  
  kChromeWebStore = 4,
  
  kBrowser = 5,
  kMinValue = 0,
  kMaxValue = 5,
};

 std::ostream& operator<<(std::ostream& os, InstallSource value);
inline bool IsKnownEnumValue(InstallSource value) {
  return internal::InstallSource_Data::IsKnownValue(
      static_cast<int32_t>(value));
}


enum class UninstallSource : int32_t {
  
  kUnknown = 0,
  
  kAppList = 1,
  
  kAppManagement = 2,
  
  kShelf = 3,
  
  kMigration = 4,
  kMinValue = 0,
  kMaxValue = 4,
};

 std::ostream& operator<<(std::ostream& os, UninstallSource value);
inline bool IsKnownEnumValue(UninstallSource value) {
  return internal::UninstallSource_Data::IsKnownValue(
      static_cast<int32_t>(value));
}


enum class OptionalBool : int32_t {
  
  kUnknown = 0,
  
  kFalse = 1,
  
  kTrue = 2,
  kMinValue = 0,
  kMaxValue = 2,
};

 std::ostream& operator<<(std::ostream& os, OptionalBool value);
inline bool IsKnownEnumValue(OptionalBool value) {
  return internal::OptionalBool_Data::IsKnownValue(
      static_cast<int32_t>(value));
}


enum class IconType : int32_t {
  
  kUnknown = 0,
  
  kUncompressed = 1,
  
  kCompressed = 2,
  
  kStandard = 3,
  kMinValue = 0,
  kMaxValue = 3,
};

 std::ostream& operator<<(std::ostream& os, IconType value);
inline bool IsKnownEnumValue(IconType value) {
  return internal::IconType_Data::IsKnownValue(
      static_cast<int32_t>(value));
}


enum class LaunchSource : int32_t {
  
  kUnknown = 0,
  
  kFromAppListGrid = 1,
  
  kFromAppListGridContextMenu = 2,
  
  kFromAppListQuery = 3,
  
  kFromAppListQueryContextMenu = 4,
  
  kFromAppListRecommendation = 5,
  
  kFromParentalControls = 6,
  
  kFromShelf = 7,
  
  kFromFileManager = 8,
  
  kFromLink = 9,
  
  kFromOmnibox = 10,
  
  kFromChromeInternal = 11,
  
  kFromKeyboard = 12,
  
  kFromOtherApp = 13,
  
  kFromMenu = 14,
  
  kFromInstalledNotification = 15,
  
  kFromTest = 16,
  
  kFromArc = 17,
  
  kFromSharesheet = 18,
  
  kFromReleaseNotesNotification = 19,
  
  kFromFullRestore = 20,
  
  kFromSmartTextContextMenu = 21,
  
  kFromDiscoverTabNotification = 22,
  
  kFromManagementApi = 23,
  
  kFromKiosk = 24,
  
  kFromCommandLine = 25,
  
  kFromBackgroundMode = 26,
  
  kFromNewTabPage = 27,
  
  kFromIntentUrl = 28,
  
  kFromOsLogin = 29,
  
  kFromProtocolHandler = 30,
  
  kFromUrlHandler = 31,
  kMinValue = 0,
  kMaxValue = 31,
};

 std::ostream& operator<<(std::ostream& os, LaunchSource value);
inline bool IsKnownEnumValue(LaunchSource value) {
  return internal::LaunchSource_Data::IsKnownValue(
      static_cast<int32_t>(value));
}


enum class TriState : int32_t {
  
  kAllow = 0,
  
  kBlock = 1,
  
  kAsk = 2,
  kMinValue = 0,
  kMaxValue = 2,
};

 std::ostream& operator<<(std::ostream& os, TriState value);
inline bool IsKnownEnumValue(TriState value) {
  return internal::TriState_Data::IsKnownValue(
      static_cast<int32_t>(value));
}


enum class MenuItemType : int32_t {
  
  kCommand = 0,
  
  kRadio = 1,
  
  kSeparator = 2,
  
  kSubmenu = 3,
  
  kPublisherCommand = 4,
  kMinValue = 0,
  kMaxValue = 4,
};

 std::ostream& operator<<(std::ostream& os, MenuItemType value);
inline bool IsKnownEnumValue(MenuItemType value) {
  return internal::MenuItemType_Data::IsKnownValue(
      static_cast<int32_t>(value));
}


enum class MenuType : int32_t {
  
  kAppList = 0,
  
  kShelf = 1,
  kMinValue = 0,
  kMaxValue = 1,
};

 std::ostream& operator<<(std::ostream& os, MenuType value);
inline bool IsKnownEnumValue(MenuType value) {
  return internal::MenuType_Data::IsKnownValue(
      static_cast<int32_t>(value));
}


enum class ConditionType : int32_t {
  
  kScheme = 0,
  
  kHost = 1,
  
  kPath = 2,
  
  kAction = 3,
  
  kMimeType = 4,
  
  kFile = 5,
  kMinValue = 0,
  kMaxValue = 5,
};

 std::ostream& operator<<(std::ostream& os, ConditionType value);
inline bool IsKnownEnumValue(ConditionType value) {
  return internal::ConditionType_Data::IsKnownValue(
      static_cast<int32_t>(value));
}


enum class PatternMatchType : int32_t {
  
  kLiteral = 1,
  
  kPrefix = 2,
  
  kGlob = 3,
  
  kMimeType = 4,
  
  kFileExtension = 5,
  
  kIsDirectory = 6,
  
  kSuffix = 7,
  kMinValue = 1,
  kMaxValue = 7,
};

 std::ostream& operator<<(std::ostream& os, PatternMatchType value);
inline bool IsKnownEnumValue(PatternMatchType value) {
  return internal::PatternMatchType_Data::IsKnownValue(
      static_cast<int32_t>(value));
}


enum class LaunchContainer : int32_t {
  
  kLaunchContainerWindow = 0,
  
  kLaunchContainerPanelDeprecated = 1,
  
  kLaunchContainerTab = 2,
  
  kLaunchContainerNone = 3,
  kMinValue = 0,
  kMaxValue = 3,
};

 std::ostream& operator<<(std::ostream& os, LaunchContainer value);
inline bool IsKnownEnumValue(LaunchContainer value) {
  return internal::LaunchContainer_Data::IsKnownValue(
      static_cast<int32_t>(value));
}


enum class WindowMode : int32_t {
  
  kUnknown = 0,
  
  kWindow = 1,
  
  kBrowser = 2,
  
  kTabbedWindow = 3,
  kMinValue = 0,
  kMaxValue = 3,
};

 std::ostream& operator<<(std::ostream& os, WindowMode value);
inline bool IsKnownEnumValue(WindowMode value) {
  return internal::WindowMode_Data::IsKnownValue(
      static_cast<int32_t>(value));
}


enum class RunOnOsLoginMode : int32_t {
  
  kUnknown = 0,
  
  kNotRun = 1,
  
  kWindowed = 2,
  kMinValue = 0,
  kMaxValue = 2,
};

 std::ostream& operator<<(std::ostream& os, RunOnOsLoginMode value);
inline bool IsKnownEnumValue(RunOnOsLoginMode value) {
  return internal::RunOnOsLoginMode_Data::IsKnownValue(
      static_cast<int32_t>(value));
}


class AppDataView {
 public:
  AppDataView() = default;

  AppDataView(
      internal::App_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  template <typename UserType>
  [[nodiscard]] bool ReadAppType(UserType* output) const {
    auto data_value = data_->app_type;
    return mojo::internal::Deserialize<::apps::mojom::AppType>(
        data_value, output);
  }
  AppType app_type() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::apps::mojom::AppType>(data_->app_type));
  }
  inline void GetAppIdDataView(
      mojo::StringDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadAppId(UserType* output) {
    
    auto* pointer = data_->app_id.Get();
    return mojo::internal::Deserialize<mojo::StringDataView>(
        pointer, output, message_);
  }
  template <typename UserType>
  [[nodiscard]] bool ReadReadiness(UserType* output) const {
    auto data_value = data_->readiness;
    return mojo::internal::Deserialize<::apps::mojom::Readiness>(
        data_value, output);
  }
  Readiness readiness() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::apps::mojom::Readiness>(data_->readiness));
  }
  inline void GetNameDataView(
      mojo::StringDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadName(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        mojo::StringDataView, UserType>(),
    "Attempting to read the optional `name` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadName` instead "
    "of `ReadName if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->name.Get();
    return mojo::internal::Deserialize<mojo::StringDataView>(
        pointer, output, message_);
  }
  inline void GetShortNameDataView(
      mojo::StringDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadShortName(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        mojo::StringDataView, UserType>(),
    "Attempting to read the optional `short_name` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadShortName` instead "
    "of `ReadShortName if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->short_name.Get();
    return mojo::internal::Deserialize<mojo::StringDataView>(
        pointer, output, message_);
  }
  inline void GetPublisherIdDataView(
      mojo::StringDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadPublisherId(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        mojo::StringDataView, UserType>(),
    "Attempting to read the optional `publisher_id` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadPublisherId` instead "
    "of `ReadPublisherId if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->publisher_id.Get();
    return mojo::internal::Deserialize<mojo::StringDataView>(
        pointer, output, message_);
  }
  inline void GetDescriptionDataView(
      mojo::StringDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadDescription(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        mojo::StringDataView, UserType>(),
    "Attempting to read the optional `description` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadDescription` instead "
    "of `ReadDescription if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->description.Get();
    return mojo::internal::Deserialize<mojo::StringDataView>(
        pointer, output, message_);
  }
  inline void GetVersionDataView(
      mojo::StringDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadVersion(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        mojo::StringDataView, UserType>(),
    "Attempting to read the optional `version` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadVersion` instead "
    "of `ReadVersion if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->version.Get();
    return mojo::internal::Deserialize<mojo::StringDataView>(
        pointer, output, message_);
  }
  inline void GetAdditionalSearchTermsDataView(
      mojo::ArrayDataView<mojo::StringDataView>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadAdditionalSearchTerms(UserType* output) {
    
    auto* pointer = data_->additional_search_terms.Get();
    return mojo::internal::Deserialize<mojo::ArrayDataView<mojo::StringDataView>>(
        pointer, output, message_);
  }
  inline void GetIconKeyDataView(
      IconKeyDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadIconKey(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::apps::mojom::IconKeyDataView, UserType>(),
    "Attempting to read the optional `icon_key` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadIconKey` instead "
    "of `ReadIconKey if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->icon_key.Get();
    return mojo::internal::Deserialize<::apps::mojom::IconKeyDataView>(
        pointer, output, message_);
  }
  inline void GetLastLaunchTimeDataView(
      ::mojo_base::mojom::TimeDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadLastLaunchTime(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::mojo_base::mojom::TimeDataView, UserType>(),
    "Attempting to read the optional `last_launch_time` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadLastLaunchTime` instead "
    "of `ReadLastLaunchTime if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->last_launch_time.Get();
    return mojo::internal::Deserialize<::mojo_base::mojom::TimeDataView>(
        pointer, output, message_);
  }
  inline void GetInstallTimeDataView(
      ::mojo_base::mojom::TimeDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadInstallTime(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::mojo_base::mojom::TimeDataView, UserType>(),
    "Attempting to read the optional `install_time` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadInstallTime` instead "
    "of `ReadInstallTime if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->install_time.Get();
    return mojo::internal::Deserialize<::mojo_base::mojom::TimeDataView>(
        pointer, output, message_);
  }
  inline void GetPermissionsDataView(
      mojo::ArrayDataView<PermissionDataView>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadPermissions(UserType* output) {
    
    auto* pointer = data_->permissions.Get();
    return mojo::internal::Deserialize<mojo::ArrayDataView<::apps::mojom::PermissionDataView>>(
        pointer, output, message_);
  }
  template <typename UserType>
  [[nodiscard]] bool ReadInstallReason(UserType* output) const {
    auto data_value = data_->install_reason;
    return mojo::internal::Deserialize<::apps::mojom::InstallReason>(
        data_value, output);
  }
  InstallReason install_reason() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::apps::mojom::InstallReason>(data_->install_reason));
  }
  template <typename UserType>
  [[nodiscard]] bool ReadInstallSource(UserType* output) const {
    auto data_value = data_->install_source;
    return mojo::internal::Deserialize<::apps::mojom::InstallSource>(
        data_value, output);
  }
  InstallSource install_source() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::apps::mojom::InstallSource>(data_->install_source));
  }
  inline void GetPolicyIdDataView(
      mojo::StringDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadPolicyId(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        mojo::StringDataView, UserType>(),
    "Attempting to read the optional `policy_id` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadPolicyId` instead "
    "of `ReadPolicyId if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->policy_id.Get();
    return mojo::internal::Deserialize<mojo::StringDataView>(
        pointer, output, message_);
  }
  template <typename UserType>
  [[nodiscard]] bool ReadIsPlatformApp(UserType* output) const {
    auto data_value = data_->is_platform_app;
    return mojo::internal::Deserialize<::apps::mojom::OptionalBool>(
        data_value, output);
  }
  OptionalBool is_platform_app() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::apps::mojom::OptionalBool>(data_->is_platform_app));
  }
  template <typename UserType>
  [[nodiscard]] bool ReadRecommendable(UserType* output) const {
    auto data_value = data_->recommendable;
    return mojo::internal::Deserialize<::apps::mojom::OptionalBool>(
        data_value, output);
  }
  OptionalBool recommendable() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::apps::mojom::OptionalBool>(data_->recommendable));
  }
  template <typename UserType>
  [[nodiscard]] bool ReadSearchable(UserType* output) const {
    auto data_value = data_->searchable;
    return mojo::internal::Deserialize<::apps::mojom::OptionalBool>(
        data_value, output);
  }
  OptionalBool searchable() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::apps::mojom::OptionalBool>(data_->searchable));
  }
  template <typename UserType>
  [[nodiscard]] bool ReadShowInLauncher(UserType* output) const {
    auto data_value = data_->show_in_launcher;
    return mojo::internal::Deserialize<::apps::mojom::OptionalBool>(
        data_value, output);
  }
  OptionalBool show_in_launcher() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::apps::mojom::OptionalBool>(data_->show_in_launcher));
  }
  template <typename UserType>
  [[nodiscard]] bool ReadShowInShelf(UserType* output) const {
    auto data_value = data_->show_in_shelf;
    return mojo::internal::Deserialize<::apps::mojom::OptionalBool>(
        data_value, output);
  }
  OptionalBool show_in_shelf() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::apps::mojom::OptionalBool>(data_->show_in_shelf));
  }
  template <typename UserType>
  [[nodiscard]] bool ReadShowInSearch(UserType* output) const {
    auto data_value = data_->show_in_search;
    return mojo::internal::Deserialize<::apps::mojom::OptionalBool>(
        data_value, output);
  }
  OptionalBool show_in_search() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::apps::mojom::OptionalBool>(data_->show_in_search));
  }
  template <typename UserType>
  [[nodiscard]] bool ReadShowInManagement(UserType* output) const {
    auto data_value = data_->show_in_management;
    return mojo::internal::Deserialize<::apps::mojom::OptionalBool>(
        data_value, output);
  }
  OptionalBool show_in_management() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::apps::mojom::OptionalBool>(data_->show_in_management));
  }
  template <typename UserType>
  [[nodiscard]] bool ReadHandlesIntents(UserType* output) const {
    auto data_value = data_->handles_intents;
    return mojo::internal::Deserialize<::apps::mojom::OptionalBool>(
        data_value, output);
  }
  OptionalBool handles_intents() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::apps::mojom::OptionalBool>(data_->handles_intents));
  }
  template <typename UserType>
  [[nodiscard]] bool ReadAllowUninstall(UserType* output) const {
    auto data_value = data_->allow_uninstall;
    return mojo::internal::Deserialize<::apps::mojom::OptionalBool>(
        data_value, output);
  }
  OptionalBool allow_uninstall() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::apps::mojom::OptionalBool>(data_->allow_uninstall));
  }
  template <typename UserType>
  [[nodiscard]] bool ReadHasBadge(UserType* output) const {
    auto data_value = data_->has_badge;
    return mojo::internal::Deserialize<::apps::mojom::OptionalBool>(
        data_value, output);
  }
  OptionalBool has_badge() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::apps::mojom::OptionalBool>(data_->has_badge));
  }
  template <typename UserType>
  [[nodiscard]] bool ReadPaused(UserType* output) const {
    auto data_value = data_->paused;
    return mojo::internal::Deserialize<::apps::mojom::OptionalBool>(
        data_value, output);
  }
  OptionalBool paused() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::apps::mojom::OptionalBool>(data_->paused));
  }
  inline void GetIntentFiltersDataView(
      mojo::ArrayDataView<IntentFilterDataView>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadIntentFilters(UserType* output) {
    
    auto* pointer = data_->intent_filters.Get();
    return mojo::internal::Deserialize<mojo::ArrayDataView<::apps::mojom::IntentFilterDataView>>(
        pointer, output, message_);
  }
  template <typename UserType>
  [[nodiscard]] bool ReadResizeLocked(UserType* output) const {
    auto data_value = data_->resize_locked;
    return mojo::internal::Deserialize<::apps::mojom::OptionalBool>(
        data_value, output);
  }
  OptionalBool resize_locked() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::apps::mojom::OptionalBool>(data_->resize_locked));
  }
  template <typename UserType>
  [[nodiscard]] bool ReadWindowMode(UserType* output) const {
    auto data_value = data_->window_mode;
    return mojo::internal::Deserialize<::apps::mojom::WindowMode>(
        data_value, output);
  }
  WindowMode window_mode() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::apps::mojom::WindowMode>(data_->window_mode));
  }
  inline void GetRunOnOsLoginDataView(
      RunOnOsLoginDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadRunOnOsLogin(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::apps::mojom::RunOnOsLoginDataView, UserType>(),
    "Attempting to read the optional `run_on_os_login` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadRunOnOsLogin` instead "
    "of `ReadRunOnOsLogin if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->run_on_os_login.Get();
    return mojo::internal::Deserialize<::apps::mojom::RunOnOsLoginDataView>(
        pointer, output, message_);
  }
 private:
  internal::App_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class PermissionDataView {
 public:
  PermissionDataView() = default;

  PermissionDataView(
      internal::Permission_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  template <typename UserType>
  [[nodiscard]] bool ReadPermissionType(UserType* output) const {
    auto data_value = data_->permission_type;
    return mojo::internal::Deserialize<::apps::mojom::PermissionType>(
        data_value, output);
  }
  PermissionType permission_type() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::apps::mojom::PermissionType>(data_->permission_type));
  }
  inline void GetValueDataView(
      PermissionValueDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadValue(UserType* output) {
    
    auto* pointer = !data_->value.is_null() ? &data_->value : nullptr;
    return mojo::internal::Deserialize<::apps::mojom::PermissionValueDataView>(
        pointer, output, message_);
  }
  bool is_managed() const {
    return data_->is_managed;
  }
 private:
  internal::Permission_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class IconKeyDataView {
 public:
  IconKeyDataView() = default;

  IconKeyDataView(
      internal::IconKey_Data* data,
      mojo::Message* message)
      : data_(data) {}

  bool is_null() const { return !data_; }
  uint64_t timeline() const {
    return data_->timeline;
  }
  int32_t resource_id() const {
    return data_->resource_id;
  }
  uint32_t icon_effects() const {
    return data_->icon_effects;
  }
 private:
  internal::IconKey_Data* data_ = nullptr;
};



class MenuItemsDataView {
 public:
  MenuItemsDataView() = default;

  MenuItemsDataView(
      internal::MenuItems_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  inline void GetItemsDataView(
      mojo::ArrayDataView<MenuItemDataView>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadItems(UserType* output) {
    
    auto* pointer = data_->items.Get();
    return mojo::internal::Deserialize<mojo::ArrayDataView<::apps::mojom::MenuItemDataView>>(
        pointer, output, message_);
  }
 private:
  internal::MenuItems_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class MenuItemDataView {
 public:
  MenuItemDataView() = default;

  MenuItemDataView(
      internal::MenuItem_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  template <typename UserType>
  [[nodiscard]] bool ReadType(UserType* output) const {
    auto data_value = data_->type;
    return mojo::internal::Deserialize<::apps::mojom::MenuItemType>(
        data_value, output);
  }
  MenuItemType type() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::apps::mojom::MenuItemType>(data_->type));
  }
  int32_t command_id() const {
    return data_->command_id;
  }
  int32_t string_id() const {
    return data_->string_id;
  }
  inline void GetSubmenuDataView(
      mojo::ArrayDataView<MenuItemDataView>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadSubmenu(UserType* output) {
    
    auto* pointer = data_->submenu.Get();
    return mojo::internal::Deserialize<mojo::ArrayDataView<::apps::mojom::MenuItemDataView>>(
        pointer, output, message_);
  }
  int32_t radio_group_id() const {
    return data_->radio_group_id;
  }
  inline void GetShortcutIdDataView(
      mojo::StringDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadShortcutId(UserType* output) {
    
    auto* pointer = data_->shortcut_id.Get();
    return mojo::internal::Deserialize<mojo::StringDataView>(
        pointer, output, message_);
  }
  inline void GetLabelDataView(
      mojo::StringDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadLabel(UserType* output) {
    
    auto* pointer = data_->label.Get();
    return mojo::internal::Deserialize<mojo::StringDataView>(
        pointer, output, message_);
  }
  inline void GetImageDataView(
      ::gfx::mojom::ImageSkiaDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadImage(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::gfx::mojom::ImageSkiaDataView, UserType>(),
    "Attempting to read the optional `image` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadImage` instead "
    "of `ReadImage if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->image.Get();
    return mojo::internal::Deserialize<::gfx::mojom::ImageSkiaDataView>(
        pointer, output, message_);
  }
 private:
  internal::MenuItem_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class ConditionValueDataView {
 public:
  ConditionValueDataView() = default;

  ConditionValueDataView(
      internal::ConditionValue_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  inline void GetValueDataView(
      mojo::StringDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadValue(UserType* output) {
    
    auto* pointer = data_->value.Get();
    return mojo::internal::Deserialize<mojo::StringDataView>(
        pointer, output, message_);
  }
  template <typename UserType>
  [[nodiscard]] bool ReadMatchType(UserType* output) const {
    auto data_value = data_->match_type;
    return mojo::internal::Deserialize<::apps::mojom::PatternMatchType>(
        data_value, output);
  }
  PatternMatchType match_type() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::apps::mojom::PatternMatchType>(data_->match_type));
  }
 private:
  internal::ConditionValue_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class ConditionDataView {
 public:
  ConditionDataView() = default;

  ConditionDataView(
      internal::Condition_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  template <typename UserType>
  [[nodiscard]] bool ReadConditionType(UserType* output) const {
    auto data_value = data_->condition_type;
    return mojo::internal::Deserialize<::apps::mojom::ConditionType>(
        data_value, output);
  }
  ConditionType condition_type() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::apps::mojom::ConditionType>(data_->condition_type));
  }
  inline void GetConditionValuesDataView(
      mojo::ArrayDataView<ConditionValueDataView>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadConditionValues(UserType* output) {
    
    auto* pointer = data_->condition_values.Get();
    return mojo::internal::Deserialize<mojo::ArrayDataView<::apps::mojom::ConditionValueDataView>>(
        pointer, output, message_);
  }
 private:
  internal::Condition_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class IntentFilterDataView {
 public:
  IntentFilterDataView() = default;

  IntentFilterDataView(
      internal::IntentFilter_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  inline void GetConditionsDataView(
      mojo::ArrayDataView<ConditionDataView>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadConditions(UserType* output) {
    
    auto* pointer = data_->conditions.Get();
    return mojo::internal::Deserialize<mojo::ArrayDataView<::apps::mojom::ConditionDataView>>(
        pointer, output, message_);
  }
  inline void GetActivityNameDataView(
      mojo::StringDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadActivityName(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        mojo::StringDataView, UserType>(),
    "Attempting to read the optional `activity_name` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadActivityName` instead "
    "of `ReadActivityName if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->activity_name.Get();
    return mojo::internal::Deserialize<mojo::StringDataView>(
        pointer, output, message_);
  }
  inline void GetActivityLabelDataView(
      mojo::StringDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadActivityLabel(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        mojo::StringDataView, UserType>(),
    "Attempting to read the optional `activity_label` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadActivityLabel` instead "
    "of `ReadActivityLabel if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->activity_label.Get();
    return mojo::internal::Deserialize<mojo::StringDataView>(
        pointer, output, message_);
  }
 private:
  internal::IntentFilter_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class IntentFileDataView {
 public:
  IntentFileDataView() = default;

  IntentFileDataView(
      internal::IntentFile_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  inline void GetUrlDataView(
      ::url::mojom::UrlDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadUrl(UserType* output) {
    
    auto* pointer = data_->url.Get();
    return mojo::internal::Deserialize<::url::mojom::UrlDataView>(
        pointer, output, message_);
  }
  inline void GetMimeTypeDataView(
      mojo::StringDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadMimeType(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        mojo::StringDataView, UserType>(),
    "Attempting to read the optional `mime_type` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadMimeType` instead "
    "of `ReadMimeType if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->mime_type.Get();
    return mojo::internal::Deserialize<mojo::StringDataView>(
        pointer, output, message_);
  }
  inline void GetFileNameDataView(
      ::mojo_base::mojom::SafeBaseNameDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadFileName(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::mojo_base::mojom::SafeBaseNameDataView, UserType>(),
    "Attempting to read the optional `file_name` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadFileName` instead "
    "of `ReadFileName if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->file_name.Get();
    return mojo::internal::Deserialize<::mojo_base::mojom::SafeBaseNameDataView>(
        pointer, output, message_);
  }
  uint64_t file_size() const {
    return data_->file_size;
  }
  template <typename UserType>
  [[nodiscard]] bool ReadIsDirectory(UserType* output) const {
    auto data_value = data_->is_directory;
    return mojo::internal::Deserialize<::apps::mojom::OptionalBool>(
        data_value, output);
  }
  OptionalBool is_directory() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::apps::mojom::OptionalBool>(data_->is_directory));
  }
 private:
  internal::IntentFile_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class IntentDataView {
 public:
  IntentDataView() = default;

  IntentDataView(
      internal::Intent_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  inline void GetActionDataView(
      mojo::StringDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadAction(UserType* output) {
    
    auto* pointer = data_->action.Get();
    return mojo::internal::Deserialize<mojo::StringDataView>(
        pointer, output, message_);
  }
  inline void GetUrlDataView(
      ::url::mojom::UrlDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadUrl(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::url::mojom::UrlDataView, UserType>(),
    "Attempting to read the optional `url` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadUrl` instead "
    "of `ReadUrl if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->url.Get();
    return mojo::internal::Deserialize<::url::mojom::UrlDataView>(
        pointer, output, message_);
  }
  inline void GetMimeTypeDataView(
      mojo::StringDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadMimeType(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        mojo::StringDataView, UserType>(),
    "Attempting to read the optional `mime_type` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadMimeType` instead "
    "of `ReadMimeType if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->mime_type.Get();
    return mojo::internal::Deserialize<mojo::StringDataView>(
        pointer, output, message_);
  }
  inline void GetFilesDataView(
      mojo::ArrayDataView<IntentFileDataView>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadFiles(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        mojo::ArrayDataView<::apps::mojom::IntentFileDataView>, UserType>(),
    "Attempting to read the optional `files` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadFiles` instead "
    "of `ReadFiles if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->files.Get();
    return mojo::internal::Deserialize<mojo::ArrayDataView<::apps::mojom::IntentFileDataView>>(
        pointer, output, message_);
  }
  inline void GetActivityNameDataView(
      mojo::StringDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadActivityName(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        mojo::StringDataView, UserType>(),
    "Attempting to read the optional `activity_name` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadActivityName` instead "
    "of `ReadActivityName if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->activity_name.Get();
    return mojo::internal::Deserialize<mojo::StringDataView>(
        pointer, output, message_);
  }
  inline void GetDriveShareUrlDataView(
      ::url::mojom::UrlDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadDriveShareUrl(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::url::mojom::UrlDataView, UserType>(),
    "Attempting to read the optional `drive_share_url` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadDriveShareUrl` instead "
    "of `ReadDriveShareUrl if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->drive_share_url.Get();
    return mojo::internal::Deserialize<::url::mojom::UrlDataView>(
        pointer, output, message_);
  }
  inline void GetShareTextDataView(
      mojo::StringDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadShareText(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        mojo::StringDataView, UserType>(),
    "Attempting to read the optional `share_text` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadShareText` instead "
    "of `ReadShareText if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->share_text.Get();
    return mojo::internal::Deserialize<mojo::StringDataView>(
        pointer, output, message_);
  }
  inline void GetShareTitleDataView(
      mojo::StringDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadShareTitle(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        mojo::StringDataView, UserType>(),
    "Attempting to read the optional `share_title` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadShareTitle` instead "
    "of `ReadShareTitle if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->share_title.Get();
    return mojo::internal::Deserialize<mojo::StringDataView>(
        pointer, output, message_);
  }
  inline void GetStartTypeDataView(
      mojo::StringDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadStartType(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        mojo::StringDataView, UserType>(),
    "Attempting to read the optional `start_type` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadStartType` instead "
    "of `ReadStartType if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->start_type.Get();
    return mojo::internal::Deserialize<mojo::StringDataView>(
        pointer, output, message_);
  }
  inline void GetCategoriesDataView(
      mojo::ArrayDataView<mojo::StringDataView>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadCategories(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        mojo::ArrayDataView<mojo::StringDataView>, UserType>(),
    "Attempting to read the optional `categories` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadCategories` instead "
    "of `ReadCategories if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->categories.Get();
    return mojo::internal::Deserialize<mojo::ArrayDataView<mojo::StringDataView>>(
        pointer, output, message_);
  }
  inline void GetDataDataView(
      mojo::StringDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadData(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        mojo::StringDataView, UserType>(),
    "Attempting to read the optional `data` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadData` instead "
    "of `ReadData if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->data.Get();
    return mojo::internal::Deserialize<mojo::StringDataView>(
        pointer, output, message_);
  }
  template <typename UserType>
  [[nodiscard]] bool ReadUiBypassed(UserType* output) const {
    auto data_value = data_->ui_bypassed;
    return mojo::internal::Deserialize<::apps::mojom::OptionalBool>(
        data_value, output);
  }
  OptionalBool ui_bypassed() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::apps::mojom::OptionalBool>(data_->ui_bypassed));
  }
  inline void GetExtrasDataView(
      mojo::MapDataView<mojo::StringDataView, mojo::StringDataView>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadExtras(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        mojo::MapDataView<mojo::StringDataView, mojo::StringDataView>, UserType>(),
    "Attempting to read the optional `extras` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadExtras` instead "
    "of `ReadExtras if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->extras.Get();
    return mojo::internal::Deserialize<mojo::MapDataView<mojo::StringDataView, mojo::StringDataView>>(
        pointer, output, message_);
  }
 private:
  internal::Intent_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class ReplacedAppPreferencesDataView {
 public:
  ReplacedAppPreferencesDataView() = default;

  ReplacedAppPreferencesDataView(
      internal::ReplacedAppPreferences_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  inline void GetReplacedPreferenceDataView(
      mojo::MapDataView<mojo::StringDataView, mojo::ArrayDataView<IntentFilterDataView>>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadReplacedPreference(UserType* output) {
    
    auto* pointer = data_->replaced_preference.Get();
    return mojo::internal::Deserialize<mojo::MapDataView<mojo::StringDataView, mojo::ArrayDataView<::apps::mojom::IntentFilterDataView>>>(
        pointer, output, message_);
  }
 private:
  internal::ReplacedAppPreferences_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class PreferredAppChangesDataView {
 public:
  PreferredAppChangesDataView() = default;

  PreferredAppChangesDataView(
      internal::PreferredAppChanges_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  inline void GetAddedFiltersDataView(
      mojo::MapDataView<mojo::StringDataView, mojo::ArrayDataView<IntentFilterDataView>>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadAddedFilters(UserType* output) {
    
    auto* pointer = data_->added_filters.Get();
    return mojo::internal::Deserialize<mojo::MapDataView<mojo::StringDataView, mojo::ArrayDataView<::apps::mojom::IntentFilterDataView>>>(
        pointer, output, message_);
  }
  inline void GetRemovedFiltersDataView(
      mojo::MapDataView<mojo::StringDataView, mojo::ArrayDataView<IntentFilterDataView>>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadRemovedFilters(UserType* output) {
    
    auto* pointer = data_->removed_filters.Get();
    return mojo::internal::Deserialize<mojo::MapDataView<mojo::StringDataView, mojo::ArrayDataView<::apps::mojom::IntentFilterDataView>>>(
        pointer, output, message_);
  }
 private:
  internal::PreferredAppChanges_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class PreferredAppDataView {
 public:
  PreferredAppDataView() = default;

  PreferredAppDataView(
      internal::PreferredApp_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  inline void GetIntentFilterDataView(
      IntentFilterDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadIntentFilter(UserType* output) {
    
    auto* pointer = data_->intent_filter.Get();
    return mojo::internal::Deserialize<::apps::mojom::IntentFilterDataView>(
        pointer, output, message_);
  }
  inline void GetAppIdDataView(
      mojo::StringDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadAppId(UserType* output) {
    
    auto* pointer = data_->app_id.Get();
    return mojo::internal::Deserialize<mojo::StringDataView>(
        pointer, output, message_);
  }
 private:
  internal::PreferredApp_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class FilePathsDataView {
 public:
  FilePathsDataView() = default;

  FilePathsDataView(
      internal::FilePaths_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  inline void GetFilePathsDataView(
      mojo::ArrayDataView<::mojo_base::mojom::FilePathDataView>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadFilePaths(UserType* output) {
    
    auto* pointer = data_->file_paths.Get();
    return mojo::internal::Deserialize<mojo::ArrayDataView<::mojo_base::mojom::FilePathDataView>>(
        pointer, output, message_);
  }
 private:
  internal::FilePaths_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class CapabilityAccessDataView {
 public:
  CapabilityAccessDataView() = default;

  CapabilityAccessDataView(
      internal::CapabilityAccess_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  inline void GetAppIdDataView(
      mojo::StringDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadAppId(UserType* output) {
    
    auto* pointer = data_->app_id.Get();
    return mojo::internal::Deserialize<mojo::StringDataView>(
        pointer, output, message_);
  }
  template <typename UserType>
  [[nodiscard]] bool ReadCamera(UserType* output) const {
    auto data_value = data_->camera;
    return mojo::internal::Deserialize<::apps::mojom::OptionalBool>(
        data_value, output);
  }
  OptionalBool camera() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::apps::mojom::OptionalBool>(data_->camera));
  }
  template <typename UserType>
  [[nodiscard]] bool ReadMicrophone(UserType* output) const {
    auto data_value = data_->microphone;
    return mojo::internal::Deserialize<::apps::mojom::OptionalBool>(
        data_value, output);
  }
  OptionalBool microphone() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::apps::mojom::OptionalBool>(data_->microphone));
  }
 private:
  internal::CapabilityAccess_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class RectDataView {
 public:
  RectDataView() = default;

  RectDataView(
      internal::Rect_Data* data,
      mojo::Message* message)
      : data_(data) {}

  bool is_null() const { return !data_; }
  int32_t x() const {
    return data_->x;
  }
  int32_t y() const {
    return data_->y;
  }
  int32_t width() const {
    return data_->width;
  }
  int32_t height() const {
    return data_->height;
  }
 private:
  internal::Rect_Data* data_ = nullptr;
};



class WindowInfoDataView {
 public:
  WindowInfoDataView() = default;

  WindowInfoDataView(
      internal::WindowInfo_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  int32_t window_id() const {
    return data_->window_id;
  }
  int32_t state() const {
    return data_->state;
  }
  int64_t display_id() const {
    return data_->display_id;
  }
  inline void GetBoundsDataView(
      RectDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadBounds(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::apps::mojom::RectDataView, UserType>(),
    "Attempting to read the optional `bounds` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadBounds` instead "
    "of `ReadBounds if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->bounds.Get();
    return mojo::internal::Deserialize<::apps::mojom::RectDataView>(
        pointer, output, message_);
  }
 private:
  internal::WindowInfo_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class RunOnOsLoginDataView {
 public:
  RunOnOsLoginDataView() = default;

  RunOnOsLoginDataView(
      internal::RunOnOsLogin_Data* data,
      mojo::Message* message)
      : data_(data) {}

  bool is_null() const { return !data_; }
  template <typename UserType>
  [[nodiscard]] bool ReadLoginMode(UserType* output) const {
    auto data_value = data_->login_mode;
    return mojo::internal::Deserialize<::apps::mojom::RunOnOsLoginMode>(
        data_value, output);
  }
  RunOnOsLoginMode login_mode() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::apps::mojom::RunOnOsLoginMode>(data_->login_mode));
  }
  bool is_managed() const {
    return data_->is_managed;
  }
 private:
  internal::RunOnOsLogin_Data* data_ = nullptr;
};



class PermissionValueDataView {
 public:
  using Tag = internal::PermissionValue_Data::PermissionValue_Tag;

  PermissionValueDataView() = default;

  PermissionValueDataView(
      internal::PermissionValue_Data* data,
      mojo::Message* message)
      : data_(data) {}

  bool is_null() const {
    // For inlined unions, |data_| is always non-null. In that case we need to
    // check |data_->is_null()|.
    return !data_ || data_->is_null();
  }

  Tag tag() const { return data_->tag; }
  bool is_bool_value() const { return data_->tag == Tag::kBoolValue; }
  bool bool_value() const {
    CHECK(is_bool_value());
    return data_->data.f_bool_value;
  }
  bool is_tristate_value() const { return data_->tag == Tag::kTristateValue; }
  template <typename UserType>
  [[nodiscard]] bool ReadTristateValue(UserType* output) const {
    CHECK(is_tristate_value());
    return mojo::internal::Deserialize<::apps::mojom::TriState>(
        data_->data.f_tristate_value, output);
  }
  TriState tristate_value() const {
    CHECK(is_tristate_value());
    // TODO(dcheng): This seems incorrect, as it bypasses enum traits.
    return ::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::apps::mojom::TriState>(data_->data.f_tristate_value));
  }

 private:
  internal::PermissionValue_Data* data_ = nullptr;
};



}  // namespace mojom
}  // namespace apps

namespace std {

template <>
struct hash<::apps::mojom::PermissionType>
    : public mojo::internal::EnumHashImpl<::apps::mojom::PermissionType> {};

template <>
struct hash<::apps::mojom::AppType>
    : public mojo::internal::EnumHashImpl<::apps::mojom::AppType> {};

template <>
struct hash<::apps::mojom::Readiness>
    : public mojo::internal::EnumHashImpl<::apps::mojom::Readiness> {};

template <>
struct hash<::apps::mojom::InstallReason>
    : public mojo::internal::EnumHashImpl<::apps::mojom::InstallReason> {};

template <>
struct hash<::apps::mojom::InstallSource>
    : public mojo::internal::EnumHashImpl<::apps::mojom::InstallSource> {};

template <>
struct hash<::apps::mojom::UninstallSource>
    : public mojo::internal::EnumHashImpl<::apps::mojom::UninstallSource> {};

template <>
struct hash<::apps::mojom::OptionalBool>
    : public mojo::internal::EnumHashImpl<::apps::mojom::OptionalBool> {};

template <>
struct hash<::apps::mojom::IconType>
    : public mojo::internal::EnumHashImpl<::apps::mojom::IconType> {};

template <>
struct hash<::apps::mojom::LaunchSource>
    : public mojo::internal::EnumHashImpl<::apps::mojom::LaunchSource> {};

template <>
struct hash<::apps::mojom::TriState>
    : public mojo::internal::EnumHashImpl<::apps::mojom::TriState> {};

template <>
struct hash<::apps::mojom::MenuItemType>
    : public mojo::internal::EnumHashImpl<::apps::mojom::MenuItemType> {};

template <>
struct hash<::apps::mojom::MenuType>
    : public mojo::internal::EnumHashImpl<::apps::mojom::MenuType> {};

template <>
struct hash<::apps::mojom::ConditionType>
    : public mojo::internal::EnumHashImpl<::apps::mojom::ConditionType> {};

template <>
struct hash<::apps::mojom::PatternMatchType>
    : public mojo::internal::EnumHashImpl<::apps::mojom::PatternMatchType> {};

template <>
struct hash<::apps::mojom::LaunchContainer>
    : public mojo::internal::EnumHashImpl<::apps::mojom::LaunchContainer> {};

template <>
struct hash<::apps::mojom::WindowMode>
    : public mojo::internal::EnumHashImpl<::apps::mojom::WindowMode> {};

template <>
struct hash<::apps::mojom::RunOnOsLoginMode>
    : public mojo::internal::EnumHashImpl<::apps::mojom::RunOnOsLoginMode> {};

}  // namespace std

namespace mojo {


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::apps::mojom::PermissionType, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::apps::mojom::PermissionType, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::apps::mojom::PermissionType>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::apps::mojom::AppType, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::apps::mojom::AppType, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::apps::mojom::AppType>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::apps::mojom::Readiness, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::apps::mojom::Readiness, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::apps::mojom::Readiness>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::apps::mojom::InstallReason, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::apps::mojom::InstallReason, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::apps::mojom::InstallReason>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::apps::mojom::InstallSource, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::apps::mojom::InstallSource, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::apps::mojom::InstallSource>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::apps::mojom::UninstallSource, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::apps::mojom::UninstallSource, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::apps::mojom::UninstallSource>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::apps::mojom::OptionalBool, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::apps::mojom::OptionalBool, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::apps::mojom::OptionalBool>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::apps::mojom::IconType, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::apps::mojom::IconType, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::apps::mojom::IconType>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::apps::mojom::LaunchSource, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::apps::mojom::LaunchSource, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::apps::mojom::LaunchSource>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::apps::mojom::TriState, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::apps::mojom::TriState, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::apps::mojom::TriState>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::apps::mojom::MenuItemType, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::apps::mojom::MenuItemType, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::apps::mojom::MenuItemType>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::apps::mojom::MenuType, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::apps::mojom::MenuType, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::apps::mojom::MenuType>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::apps::mojom::ConditionType, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::apps::mojom::ConditionType, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::apps::mojom::ConditionType>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::apps::mojom::PatternMatchType, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::apps::mojom::PatternMatchType, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::apps::mojom::PatternMatchType>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::apps::mojom::LaunchContainer, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::apps::mojom::LaunchContainer, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::apps::mojom::LaunchContainer>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::apps::mojom::WindowMode, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::apps::mojom::WindowMode, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::apps::mojom::WindowMode>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::apps::mojom::RunOnOsLoginMode, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::apps::mojom::RunOnOsLoginMode, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::apps::mojom::RunOnOsLoginMode>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::apps::mojom::AppDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::apps::mojom::AppDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::apps::mojom::internal::App_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    mojo::internal::Serialize<::apps::mojom::AppType>(
        Traits::app_type(input), &fragment->app_type);
    decltype(Traits::app_id(input)) in_app_id = Traits::app_id(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->app_id)::BaseType> app_id_fragment(
            fragment.message());
    mojo::internal::Serialize<mojo::StringDataView>(
        in_app_id, app_id_fragment);
    fragment->app_id.Set(
        app_id_fragment.is_null() ? nullptr : app_id_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->app_id.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null app_id in App struct");
    mojo::internal::Serialize<::apps::mojom::Readiness>(
        Traits::readiness(input), &fragment->readiness);
    decltype(Traits::name(input)) in_name = Traits::name(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->name)::BaseType> name_fragment(
            fragment.message());
    mojo::internal::Serialize<mojo::StringDataView>(
        in_name, name_fragment);
    fragment->name.Set(
        name_fragment.is_null() ? nullptr : name_fragment.data());
    decltype(Traits::short_name(input)) in_short_name = Traits::short_name(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->short_name)::BaseType> short_name_fragment(
            fragment.message());
    mojo::internal::Serialize<mojo::StringDataView>(
        in_short_name, short_name_fragment);
    fragment->short_name.Set(
        short_name_fragment.is_null() ? nullptr : short_name_fragment.data());
    decltype(Traits::publisher_id(input)) in_publisher_id = Traits::publisher_id(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->publisher_id)::BaseType> publisher_id_fragment(
            fragment.message());
    mojo::internal::Serialize<mojo::StringDataView>(
        in_publisher_id, publisher_id_fragment);
    fragment->publisher_id.Set(
        publisher_id_fragment.is_null() ? nullptr : publisher_id_fragment.data());
    decltype(Traits::description(input)) in_description = Traits::description(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->description)::BaseType> description_fragment(
            fragment.message());
    mojo::internal::Serialize<mojo::StringDataView>(
        in_description, description_fragment);
    fragment->description.Set(
        description_fragment.is_null() ? nullptr : description_fragment.data());
    decltype(Traits::version(input)) in_version = Traits::version(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->version)::BaseType> version_fragment(
            fragment.message());
    mojo::internal::Serialize<mojo::StringDataView>(
        in_version, version_fragment);
    fragment->version.Set(
        version_fragment.is_null() ? nullptr : version_fragment.data());
    decltype(Traits::additional_search_terms(input)) in_additional_search_terms = Traits::additional_search_terms(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->additional_search_terms)::BaseType>
        additional_search_terms_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams additional_search_terms_validate_params(
        0, false, new mojo::internal::ContainerValidateParams(0, false, nullptr));
    mojo::internal::Serialize<mojo::ArrayDataView<mojo::StringDataView>>(
        in_additional_search_terms, additional_search_terms_fragment, &additional_search_terms_validate_params);
    fragment->additional_search_terms.Set(
        additional_search_terms_fragment.is_null() ? nullptr : additional_search_terms_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->additional_search_terms.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null additional_search_terms in App struct");
    decltype(Traits::icon_key(input)) in_icon_key = Traits::icon_key(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->icon_key)::BaseType> icon_key_fragment(
            fragment.message());
    mojo::internal::Serialize<::apps::mojom::IconKeyDataView>(
        in_icon_key, icon_key_fragment);
    fragment->icon_key.Set(
        icon_key_fragment.is_null() ? nullptr : icon_key_fragment.data());
    decltype(Traits::last_launch_time(input)) in_last_launch_time = Traits::last_launch_time(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->last_launch_time)::BaseType> last_launch_time_fragment(
            fragment.message());
    mojo::internal::Serialize<::mojo_base::mojom::TimeDataView>(
        in_last_launch_time, last_launch_time_fragment);
    fragment->last_launch_time.Set(
        last_launch_time_fragment.is_null() ? nullptr : last_launch_time_fragment.data());
    decltype(Traits::install_time(input)) in_install_time = Traits::install_time(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->install_time)::BaseType> install_time_fragment(
            fragment.message());
    mojo::internal::Serialize<::mojo_base::mojom::TimeDataView>(
        in_install_time, install_time_fragment);
    fragment->install_time.Set(
        install_time_fragment.is_null() ? nullptr : install_time_fragment.data());
    decltype(Traits::permissions(input)) in_permissions = Traits::permissions(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->permissions)::BaseType>
        permissions_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams permissions_validate_params(
        0, false, nullptr);
    mojo::internal::Serialize<mojo::ArrayDataView<::apps::mojom::PermissionDataView>>(
        in_permissions, permissions_fragment, &permissions_validate_params);
    fragment->permissions.Set(
        permissions_fragment.is_null() ? nullptr : permissions_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->permissions.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null permissions in App struct");
    mojo::internal::Serialize<::apps::mojom::InstallReason>(
        Traits::install_reason(input), &fragment->install_reason);
    mojo::internal::Serialize<::apps::mojom::InstallSource>(
        Traits::install_source(input), &fragment->install_source);
    decltype(Traits::policy_id(input)) in_policy_id = Traits::policy_id(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->policy_id)::BaseType> policy_id_fragment(
            fragment.message());
    mojo::internal::Serialize<mojo::StringDataView>(
        in_policy_id, policy_id_fragment);
    fragment->policy_id.Set(
        policy_id_fragment.is_null() ? nullptr : policy_id_fragment.data());
    mojo::internal::Serialize<::apps::mojom::OptionalBool>(
        Traits::is_platform_app(input), &fragment->is_platform_app);
    mojo::internal::Serialize<::apps::mojom::OptionalBool>(
        Traits::recommendable(input), &fragment->recommendable);
    mojo::internal::Serialize<::apps::mojom::OptionalBool>(
        Traits::searchable(input), &fragment->searchable);
    mojo::internal::Serialize<::apps::mojom::OptionalBool>(
        Traits::show_in_launcher(input), &fragment->show_in_launcher);
    mojo::internal::Serialize<::apps::mojom::OptionalBool>(
        Traits::show_in_shelf(input), &fragment->show_in_shelf);
    mojo::internal::Serialize<::apps::mojom::OptionalBool>(
        Traits::show_in_search(input), &fragment->show_in_search);
    mojo::internal::Serialize<::apps::mojom::OptionalBool>(
        Traits::show_in_management(input), &fragment->show_in_management);
    mojo::internal::Serialize<::apps::mojom::OptionalBool>(
        Traits::handles_intents(input), &fragment->handles_intents);
    mojo::internal::Serialize<::apps::mojom::OptionalBool>(
        Traits::allow_uninstall(input), &fragment->allow_uninstall);
    mojo::internal::Serialize<::apps::mojom::OptionalBool>(
        Traits::has_badge(input), &fragment->has_badge);
    mojo::internal::Serialize<::apps::mojom::OptionalBool>(
        Traits::paused(input), &fragment->paused);
    decltype(Traits::intent_filters(input)) in_intent_filters = Traits::intent_filters(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->intent_filters)::BaseType>
        intent_filters_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams intent_filters_validate_params(
        0, false, nullptr);
    mojo::internal::Serialize<mojo::ArrayDataView<::apps::mojom::IntentFilterDataView>>(
        in_intent_filters, intent_filters_fragment, &intent_filters_validate_params);
    fragment->intent_filters.Set(
        intent_filters_fragment.is_null() ? nullptr : intent_filters_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->intent_filters.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null intent_filters in App struct");
    mojo::internal::Serialize<::apps::mojom::OptionalBool>(
        Traits::resize_locked(input), &fragment->resize_locked);
    mojo::internal::Serialize<::apps::mojom::WindowMode>(
        Traits::window_mode(input), &fragment->window_mode);
    decltype(Traits::run_on_os_login(input)) in_run_on_os_login = Traits::run_on_os_login(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->run_on_os_login)::BaseType> run_on_os_login_fragment(
            fragment.message());
    mojo::internal::Serialize<::apps::mojom::RunOnOsLoginDataView>(
        in_run_on_os_login, run_on_os_login_fragment);
    fragment->run_on_os_login.Set(
        run_on_os_login_fragment.is_null() ? nullptr : run_on_os_login_fragment.data());
  }

  static bool Deserialize(::apps::mojom::internal::App_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::apps::mojom::AppDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::apps::mojom::PermissionDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::apps::mojom::PermissionDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::apps::mojom::internal::Permission_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    mojo::internal::Serialize<::apps::mojom::PermissionType>(
        Traits::permission_type(input), &fragment->permission_type);
    decltype(Traits::value(input)) in_value = Traits::value(input);
    mojo::internal::MessageFragment<decltype(fragment->value)>
        value_fragment(fragment.message());
    value_fragment.Claim(&fragment->value);
    mojo::internal::Serialize<::apps::mojom::PermissionValueDataView>(
        in_value, value_fragment, true);
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->value.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null value in Permission struct");
    fragment->is_managed = Traits::is_managed(input);
  }

  static bool Deserialize(::apps::mojom::internal::Permission_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::apps::mojom::PermissionDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::apps::mojom::IconKeyDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::apps::mojom::IconKeyDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::apps::mojom::internal::IconKey_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    fragment->timeline = Traits::timeline(input);
    fragment->resource_id = Traits::resource_id(input);
    fragment->icon_effects = Traits::icon_effects(input);
  }

  static bool Deserialize(::apps::mojom::internal::IconKey_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::apps::mojom::IconKeyDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::apps::mojom::MenuItemsDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::apps::mojom::MenuItemsDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::apps::mojom::internal::MenuItems_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    decltype(Traits::items(input)) in_items = Traits::items(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->items)::BaseType>
        items_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams items_validate_params(
        0, false, nullptr);
    mojo::internal::Serialize<mojo::ArrayDataView<::apps::mojom::MenuItemDataView>>(
        in_items, items_fragment, &items_validate_params);
    fragment->items.Set(
        items_fragment.is_null() ? nullptr : items_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->items.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null items in MenuItems struct");
  }

  static bool Deserialize(::apps::mojom::internal::MenuItems_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::apps::mojom::MenuItemsDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::apps::mojom::MenuItemDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::apps::mojom::MenuItemDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::apps::mojom::internal::MenuItem_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    mojo::internal::Serialize<::apps::mojom::MenuItemType>(
        Traits::type(input), &fragment->type);
    fragment->command_id = Traits::command_id(input);
    fragment->string_id = Traits::string_id(input);
    decltype(Traits::submenu(input)) in_submenu = Traits::submenu(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->submenu)::BaseType>
        submenu_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams submenu_validate_params(
        0, false, nullptr);
    mojo::internal::Serialize<mojo::ArrayDataView<::apps::mojom::MenuItemDataView>>(
        in_submenu, submenu_fragment, &submenu_validate_params);
    fragment->submenu.Set(
        submenu_fragment.is_null() ? nullptr : submenu_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->submenu.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null submenu in MenuItem struct");
    fragment->radio_group_id = Traits::radio_group_id(input);
    decltype(Traits::shortcut_id(input)) in_shortcut_id = Traits::shortcut_id(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->shortcut_id)::BaseType> shortcut_id_fragment(
            fragment.message());
    mojo::internal::Serialize<mojo::StringDataView>(
        in_shortcut_id, shortcut_id_fragment);
    fragment->shortcut_id.Set(
        shortcut_id_fragment.is_null() ? nullptr : shortcut_id_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->shortcut_id.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null shortcut_id in MenuItem struct");
    decltype(Traits::label(input)) in_label = Traits::label(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->label)::BaseType> label_fragment(
            fragment.message());
    mojo::internal::Serialize<mojo::StringDataView>(
        in_label, label_fragment);
    fragment->label.Set(
        label_fragment.is_null() ? nullptr : label_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->label.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null label in MenuItem struct");
    decltype(Traits::image(input)) in_image = Traits::image(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->image)::BaseType> image_fragment(
            fragment.message());
    mojo::internal::Serialize<::gfx::mojom::ImageSkiaDataView>(
        in_image, image_fragment);
    fragment->image.Set(
        image_fragment.is_null() ? nullptr : image_fragment.data());
  }

  static bool Deserialize(::apps::mojom::internal::MenuItem_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::apps::mojom::MenuItemDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::apps::mojom::ConditionValueDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::apps::mojom::ConditionValueDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::apps::mojom::internal::ConditionValue_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    decltype(Traits::value(input)) in_value = Traits::value(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->value)::BaseType> value_fragment(
            fragment.message());
    mojo::internal::Serialize<mojo::StringDataView>(
        in_value, value_fragment);
    fragment->value.Set(
        value_fragment.is_null() ? nullptr : value_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->value.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null value in ConditionValue struct");
    mojo::internal::Serialize<::apps::mojom::PatternMatchType>(
        Traits::match_type(input), &fragment->match_type);
  }

  static bool Deserialize(::apps::mojom::internal::ConditionValue_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::apps::mojom::ConditionValueDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::apps::mojom::ConditionDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::apps::mojom::ConditionDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::apps::mojom::internal::Condition_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    mojo::internal::Serialize<::apps::mojom::ConditionType>(
        Traits::condition_type(input), &fragment->condition_type);
    decltype(Traits::condition_values(input)) in_condition_values = Traits::condition_values(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->condition_values)::BaseType>
        condition_values_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams condition_values_validate_params(
        0, false, nullptr);
    mojo::internal::Serialize<mojo::ArrayDataView<::apps::mojom::ConditionValueDataView>>(
        in_condition_values, condition_values_fragment, &condition_values_validate_params);
    fragment->condition_values.Set(
        condition_values_fragment.is_null() ? nullptr : condition_values_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->condition_values.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null condition_values in Condition struct");
  }

  static bool Deserialize(::apps::mojom::internal::Condition_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::apps::mojom::ConditionDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::apps::mojom::IntentFilterDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::apps::mojom::IntentFilterDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::apps::mojom::internal::IntentFilter_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    decltype(Traits::conditions(input)) in_conditions = Traits::conditions(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->conditions)::BaseType>
        conditions_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams conditions_validate_params(
        0, false, nullptr);
    mojo::internal::Serialize<mojo::ArrayDataView<::apps::mojom::ConditionDataView>>(
        in_conditions, conditions_fragment, &conditions_validate_params);
    fragment->conditions.Set(
        conditions_fragment.is_null() ? nullptr : conditions_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->conditions.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null conditions in IntentFilter struct");
    decltype(Traits::activity_name(input)) in_activity_name = Traits::activity_name(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->activity_name)::BaseType> activity_name_fragment(
            fragment.message());
    mojo::internal::Serialize<mojo::StringDataView>(
        in_activity_name, activity_name_fragment);
    fragment->activity_name.Set(
        activity_name_fragment.is_null() ? nullptr : activity_name_fragment.data());
    decltype(Traits::activity_label(input)) in_activity_label = Traits::activity_label(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->activity_label)::BaseType> activity_label_fragment(
            fragment.message());
    mojo::internal::Serialize<mojo::StringDataView>(
        in_activity_label, activity_label_fragment);
    fragment->activity_label.Set(
        activity_label_fragment.is_null() ? nullptr : activity_label_fragment.data());
  }

  static bool Deserialize(::apps::mojom::internal::IntentFilter_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::apps::mojom::IntentFilterDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::apps::mojom::IntentFileDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::apps::mojom::IntentFileDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::apps::mojom::internal::IntentFile_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    decltype(Traits::url(input)) in_url = Traits::url(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->url)::BaseType> url_fragment(
            fragment.message());
    mojo::internal::Serialize<::url::mojom::UrlDataView>(
        in_url, url_fragment);
    fragment->url.Set(
        url_fragment.is_null() ? nullptr : url_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->url.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null url in IntentFile struct");
    decltype(Traits::mime_type(input)) in_mime_type = Traits::mime_type(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->mime_type)::BaseType> mime_type_fragment(
            fragment.message());
    mojo::internal::Serialize<mojo::StringDataView>(
        in_mime_type, mime_type_fragment);
    fragment->mime_type.Set(
        mime_type_fragment.is_null() ? nullptr : mime_type_fragment.data());
    decltype(Traits::file_name(input)) in_file_name = Traits::file_name(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->file_name)::BaseType> file_name_fragment(
            fragment.message());
    mojo::internal::Serialize<::mojo_base::mojom::SafeBaseNameDataView>(
        in_file_name, file_name_fragment);
    fragment->file_name.Set(
        file_name_fragment.is_null() ? nullptr : file_name_fragment.data());
    fragment->file_size = Traits::file_size(input);
    mojo::internal::Serialize<::apps::mojom::OptionalBool>(
        Traits::is_directory(input), &fragment->is_directory);
  }

  static bool Deserialize(::apps::mojom::internal::IntentFile_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::apps::mojom::IntentFileDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::apps::mojom::IntentDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::apps::mojom::IntentDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::apps::mojom::internal::Intent_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    decltype(Traits::action(input)) in_action = Traits::action(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->action)::BaseType> action_fragment(
            fragment.message());
    mojo::internal::Serialize<mojo::StringDataView>(
        in_action, action_fragment);
    fragment->action.Set(
        action_fragment.is_null() ? nullptr : action_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->action.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null action in Intent struct");
    decltype(Traits::url(input)) in_url = Traits::url(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->url)::BaseType> url_fragment(
            fragment.message());
    mojo::internal::Serialize<::url::mojom::UrlDataView>(
        in_url, url_fragment);
    fragment->url.Set(
        url_fragment.is_null() ? nullptr : url_fragment.data());
    decltype(Traits::mime_type(input)) in_mime_type = Traits::mime_type(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->mime_type)::BaseType> mime_type_fragment(
            fragment.message());
    mojo::internal::Serialize<mojo::StringDataView>(
        in_mime_type, mime_type_fragment);
    fragment->mime_type.Set(
        mime_type_fragment.is_null() ? nullptr : mime_type_fragment.data());
    decltype(Traits::files(input)) in_files = Traits::files(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->files)::BaseType>
        files_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams files_validate_params(
        0, false, nullptr);
    mojo::internal::Serialize<mojo::ArrayDataView<::apps::mojom::IntentFileDataView>>(
        in_files, files_fragment, &files_validate_params);
    fragment->files.Set(
        files_fragment.is_null() ? nullptr : files_fragment.data());
    decltype(Traits::activity_name(input)) in_activity_name = Traits::activity_name(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->activity_name)::BaseType> activity_name_fragment(
            fragment.message());
    mojo::internal::Serialize<mojo::StringDataView>(
        in_activity_name, activity_name_fragment);
    fragment->activity_name.Set(
        activity_name_fragment.is_null() ? nullptr : activity_name_fragment.data());
    decltype(Traits::drive_share_url(input)) in_drive_share_url = Traits::drive_share_url(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->drive_share_url)::BaseType> drive_share_url_fragment(
            fragment.message());
    mojo::internal::Serialize<::url::mojom::UrlDataView>(
        in_drive_share_url, drive_share_url_fragment);
    fragment->drive_share_url.Set(
        drive_share_url_fragment.is_null() ? nullptr : drive_share_url_fragment.data());
    decltype(Traits::share_text(input)) in_share_text = Traits::share_text(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->share_text)::BaseType> share_text_fragment(
            fragment.message());
    mojo::internal::Serialize<mojo::StringDataView>(
        in_share_text, share_text_fragment);
    fragment->share_text.Set(
        share_text_fragment.is_null() ? nullptr : share_text_fragment.data());
    decltype(Traits::share_title(input)) in_share_title = Traits::share_title(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->share_title)::BaseType> share_title_fragment(
            fragment.message());
    mojo::internal::Serialize<mojo::StringDataView>(
        in_share_title, share_title_fragment);
    fragment->share_title.Set(
        share_title_fragment.is_null() ? nullptr : share_title_fragment.data());
    decltype(Traits::start_type(input)) in_start_type = Traits::start_type(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->start_type)::BaseType> start_type_fragment(
            fragment.message());
    mojo::internal::Serialize<mojo::StringDataView>(
        in_start_type, start_type_fragment);
    fragment->start_type.Set(
        start_type_fragment.is_null() ? nullptr : start_type_fragment.data());
    decltype(Traits::categories(input)) in_categories = Traits::categories(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->categories)::BaseType>
        categories_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams categories_validate_params(
        0, false, new mojo::internal::ContainerValidateParams(0, false, nullptr));
    mojo::internal::Serialize<mojo::ArrayDataView<mojo::StringDataView>>(
        in_categories, categories_fragment, &categories_validate_params);
    fragment->categories.Set(
        categories_fragment.is_null() ? nullptr : categories_fragment.data());
    decltype(Traits::data(input)) in_data = Traits::data(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->data)::BaseType> data_fragment(
            fragment.message());
    mojo::internal::Serialize<mojo::StringDataView>(
        in_data, data_fragment);
    fragment->data.Set(
        data_fragment.is_null() ? nullptr : data_fragment.data());
    mojo::internal::Serialize<::apps::mojom::OptionalBool>(
        Traits::ui_bypassed(input), &fragment->ui_bypassed);
    decltype(Traits::extras(input)) in_extras = Traits::extras(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->extras)::BaseType>
        extras_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams extras_validate_params(
        new mojo::internal::ContainerValidateParams(0, false, new mojo::internal::ContainerValidateParams(0, false, nullptr)), new mojo::internal::ContainerValidateParams(0, false, new mojo::internal::ContainerValidateParams(0, false, nullptr)));
    mojo::internal::Serialize<mojo::MapDataView<mojo::StringDataView, mojo::StringDataView>>(
        in_extras, extras_fragment, &extras_validate_params);
    fragment->extras.Set(
        extras_fragment.is_null() ? nullptr : extras_fragment.data());
  }

  static bool Deserialize(::apps::mojom::internal::Intent_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::apps::mojom::IntentDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::apps::mojom::ReplacedAppPreferencesDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::apps::mojom::ReplacedAppPreferencesDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::apps::mojom::internal::ReplacedAppPreferences_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    decltype(Traits::replaced_preference(input)) in_replaced_preference = Traits::replaced_preference(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->replaced_preference)::BaseType>
        replaced_preference_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams replaced_preference_validate_params(
        new mojo::internal::ContainerValidateParams(0, false, new mojo::internal::ContainerValidateParams(0, false, nullptr)), new mojo::internal::ContainerValidateParams(0, false, new mojo::internal::ContainerValidateParams(0, false, nullptr)));
    mojo::internal::Serialize<mojo::MapDataView<mojo::StringDataView, mojo::ArrayDataView<::apps::mojom::IntentFilterDataView>>>(
        in_replaced_preference, replaced_preference_fragment, &replaced_preference_validate_params);
    fragment->replaced_preference.Set(
        replaced_preference_fragment.is_null() ? nullptr : replaced_preference_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->replaced_preference.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null replaced_preference in ReplacedAppPreferences struct");
  }

  static bool Deserialize(::apps::mojom::internal::ReplacedAppPreferences_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::apps::mojom::ReplacedAppPreferencesDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::apps::mojom::PreferredAppChangesDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::apps::mojom::PreferredAppChangesDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::apps::mojom::internal::PreferredAppChanges_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    decltype(Traits::added_filters(input)) in_added_filters = Traits::added_filters(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->added_filters)::BaseType>
        added_filters_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams added_filters_validate_params(
        new mojo::internal::ContainerValidateParams(0, false, new mojo::internal::ContainerValidateParams(0, false, nullptr)), new mojo::internal::ContainerValidateParams(0, false, new mojo::internal::ContainerValidateParams(0, false, nullptr)));
    mojo::internal::Serialize<mojo::MapDataView<mojo::StringDataView, mojo::ArrayDataView<::apps::mojom::IntentFilterDataView>>>(
        in_added_filters, added_filters_fragment, &added_filters_validate_params);
    fragment->added_filters.Set(
        added_filters_fragment.is_null() ? nullptr : added_filters_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->added_filters.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null added_filters in PreferredAppChanges struct");
    decltype(Traits::removed_filters(input)) in_removed_filters = Traits::removed_filters(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->removed_filters)::BaseType>
        removed_filters_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams removed_filters_validate_params(
        new mojo::internal::ContainerValidateParams(0, false, new mojo::internal::ContainerValidateParams(0, false, nullptr)), new mojo::internal::ContainerValidateParams(0, false, new mojo::internal::ContainerValidateParams(0, false, nullptr)));
    mojo::internal::Serialize<mojo::MapDataView<mojo::StringDataView, mojo::ArrayDataView<::apps::mojom::IntentFilterDataView>>>(
        in_removed_filters, removed_filters_fragment, &removed_filters_validate_params);
    fragment->removed_filters.Set(
        removed_filters_fragment.is_null() ? nullptr : removed_filters_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->removed_filters.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null removed_filters in PreferredAppChanges struct");
  }

  static bool Deserialize(::apps::mojom::internal::PreferredAppChanges_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::apps::mojom::PreferredAppChangesDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::apps::mojom::PreferredAppDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::apps::mojom::PreferredAppDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::apps::mojom::internal::PreferredApp_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    decltype(Traits::intent_filter(input)) in_intent_filter = Traits::intent_filter(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->intent_filter)::BaseType> intent_filter_fragment(
            fragment.message());
    mojo::internal::Serialize<::apps::mojom::IntentFilterDataView>(
        in_intent_filter, intent_filter_fragment);
    fragment->intent_filter.Set(
        intent_filter_fragment.is_null() ? nullptr : intent_filter_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->intent_filter.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null intent_filter in PreferredApp struct");
    decltype(Traits::app_id(input)) in_app_id = Traits::app_id(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->app_id)::BaseType> app_id_fragment(
            fragment.message());
    mojo::internal::Serialize<mojo::StringDataView>(
        in_app_id, app_id_fragment);
    fragment->app_id.Set(
        app_id_fragment.is_null() ? nullptr : app_id_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->app_id.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null app_id in PreferredApp struct");
  }

  static bool Deserialize(::apps::mojom::internal::PreferredApp_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::apps::mojom::PreferredAppDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::apps::mojom::FilePathsDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::apps::mojom::FilePathsDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::apps::mojom::internal::FilePaths_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    decltype(Traits::file_paths(input)) in_file_paths = Traits::file_paths(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->file_paths)::BaseType>
        file_paths_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams file_paths_validate_params(
        0, false, nullptr);
    mojo::internal::Serialize<mojo::ArrayDataView<::mojo_base::mojom::FilePathDataView>>(
        in_file_paths, file_paths_fragment, &file_paths_validate_params);
    fragment->file_paths.Set(
        file_paths_fragment.is_null() ? nullptr : file_paths_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->file_paths.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null file_paths in FilePaths struct");
  }

  static bool Deserialize(::apps::mojom::internal::FilePaths_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::apps::mojom::FilePathsDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::apps::mojom::CapabilityAccessDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::apps::mojom::CapabilityAccessDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::apps::mojom::internal::CapabilityAccess_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    decltype(Traits::app_id(input)) in_app_id = Traits::app_id(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->app_id)::BaseType> app_id_fragment(
            fragment.message());
    mojo::internal::Serialize<mojo::StringDataView>(
        in_app_id, app_id_fragment);
    fragment->app_id.Set(
        app_id_fragment.is_null() ? nullptr : app_id_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->app_id.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null app_id in CapabilityAccess struct");
    mojo::internal::Serialize<::apps::mojom::OptionalBool>(
        Traits::camera(input), &fragment->camera);
    mojo::internal::Serialize<::apps::mojom::OptionalBool>(
        Traits::microphone(input), &fragment->microphone);
  }

  static bool Deserialize(::apps::mojom::internal::CapabilityAccess_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::apps::mojom::CapabilityAccessDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::apps::mojom::RectDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::apps::mojom::RectDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::apps::mojom::internal::Rect_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    fragment->x = Traits::x(input);
    fragment->y = Traits::y(input);
    fragment->width = Traits::width(input);
    fragment->height = Traits::height(input);
  }

  static bool Deserialize(::apps::mojom::internal::Rect_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::apps::mojom::RectDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::apps::mojom::WindowInfoDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::apps::mojom::WindowInfoDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::apps::mojom::internal::WindowInfo_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    fragment->window_id = Traits::window_id(input);
    fragment->state = Traits::state(input);
    fragment->display_id = Traits::display_id(input);
    decltype(Traits::bounds(input)) in_bounds = Traits::bounds(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->bounds)::BaseType> bounds_fragment(
            fragment.message());
    mojo::internal::Serialize<::apps::mojom::RectDataView>(
        in_bounds, bounds_fragment);
    fragment->bounds.Set(
        bounds_fragment.is_null() ? nullptr : bounds_fragment.data());
  }

  static bool Deserialize(::apps::mojom::internal::WindowInfo_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::apps::mojom::WindowInfoDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::apps::mojom::RunOnOsLoginDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::apps::mojom::RunOnOsLoginDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::apps::mojom::internal::RunOnOsLogin_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    mojo::internal::Serialize<::apps::mojom::RunOnOsLoginMode>(
        Traits::login_mode(input), &fragment->login_mode);
    fragment->is_managed = Traits::is_managed(input);
  }

  static bool Deserialize(::apps::mojom::internal::RunOnOsLogin_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::apps::mojom::RunOnOsLoginDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::apps::mojom::PermissionValueDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = UnionTraits<::apps::mojom::PermissionValueDataView, UserType>;

  static void Serialize(MaybeConstUserType& input,
                        MessageFragment<::apps::mojom::internal::PermissionValue_Data>& fragment,
                        bool inlined) {
    if (CallIsNullIfExists<Traits>(input)) {
       if (inlined)
        fragment->set_null();
      return;
    }

    if (!inlined)
      fragment.Allocate();

    // TODO(azani): Handle unknown and objects.
    // Set the not-null flag.
    fragment->size = kUnionDataSize;
    fragment->tag = Traits::GetTag(input);
    switch (fragment->tag) {
      case ::apps::mojom::PermissionValueDataView::Tag::kBoolValue: {
        decltype(Traits::bool_value(input))
            in_bool_value = Traits::bool_value(input);
        fragment->data.f_bool_value = in_bool_value;
        break;
      }
      case ::apps::mojom::PermissionValueDataView::Tag::kTristateValue: {
        decltype(Traits::tristate_value(input))
            in_tristate_value = Traits::tristate_value(input);
        mojo::internal::Serialize<::apps::mojom::TriState>(
            in_tristate_value, &fragment->data.f_tristate_value);
        break;
      }
    }
  }

  static bool Deserialize(::apps::mojom::internal::PermissionValue_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input || input->is_null())
      return CallSetToNullIfExists<Traits>(output);

    ::apps::mojom::PermissionValueDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal

}  // namespace mojo


namespace apps {
namespace mojom {

inline void AppDataView::GetAppIdDataView(
    mojo::StringDataView* output) {
  auto pointer = data_->app_id.Get();
  *output = mojo::StringDataView(pointer, message_);
}
inline void AppDataView::GetNameDataView(
    mojo::StringDataView* output) {
  auto pointer = data_->name.Get();
  *output = mojo::StringDataView(pointer, message_);
}
inline void AppDataView::GetShortNameDataView(
    mojo::StringDataView* output) {
  auto pointer = data_->short_name.Get();
  *output = mojo::StringDataView(pointer, message_);
}
inline void AppDataView::GetPublisherIdDataView(
    mojo::StringDataView* output) {
  auto pointer = data_->publisher_id.Get();
  *output = mojo::StringDataView(pointer, message_);
}
inline void AppDataView::GetDescriptionDataView(
    mojo::StringDataView* output) {
  auto pointer = data_->description.Get();
  *output = mojo::StringDataView(pointer, message_);
}
inline void AppDataView::GetVersionDataView(
    mojo::StringDataView* output) {
  auto pointer = data_->version.Get();
  *output = mojo::StringDataView(pointer, message_);
}
inline void AppDataView::GetAdditionalSearchTermsDataView(
    mojo::ArrayDataView<mojo::StringDataView>* output) {
  auto pointer = data_->additional_search_terms.Get();
  *output = mojo::ArrayDataView<mojo::StringDataView>(pointer, message_);
}
inline void AppDataView::GetIconKeyDataView(
    IconKeyDataView* output) {
  auto pointer = data_->icon_key.Get();
  *output = IconKeyDataView(pointer, message_);
}
inline void AppDataView::GetLastLaunchTimeDataView(
    ::mojo_base::mojom::TimeDataView* output) {
  auto pointer = data_->last_launch_time.Get();
  *output = ::mojo_base::mojom::TimeDataView(pointer, message_);
}
inline void AppDataView::GetInstallTimeDataView(
    ::mojo_base::mojom::TimeDataView* output) {
  auto pointer = data_->install_time.Get();
  *output = ::mojo_base::mojom::TimeDataView(pointer, message_);
}
inline void AppDataView::GetPermissionsDataView(
    mojo::ArrayDataView<PermissionDataView>* output) {
  auto pointer = data_->permissions.Get();
  *output = mojo::ArrayDataView<PermissionDataView>(pointer, message_);
}
inline void AppDataView::GetPolicyIdDataView(
    mojo::StringDataView* output) {
  auto pointer = data_->policy_id.Get();
  *output = mojo::StringDataView(pointer, message_);
}
inline void AppDataView::GetIntentFiltersDataView(
    mojo::ArrayDataView<IntentFilterDataView>* output) {
  auto pointer = data_->intent_filters.Get();
  *output = mojo::ArrayDataView<IntentFilterDataView>(pointer, message_);
}
inline void AppDataView::GetRunOnOsLoginDataView(
    RunOnOsLoginDataView* output) {
  auto pointer = data_->run_on_os_login.Get();
  *output = RunOnOsLoginDataView(pointer, message_);
}


inline void PermissionDataView::GetValueDataView(
    PermissionValueDataView* output) {
  auto pointer = &data_->value;
  *output = PermissionValueDataView(pointer, message_);
}




inline void MenuItemsDataView::GetItemsDataView(
    mojo::ArrayDataView<MenuItemDataView>* output) {
  auto pointer = data_->items.Get();
  *output = mojo::ArrayDataView<MenuItemDataView>(pointer, message_);
}


inline void MenuItemDataView::GetSubmenuDataView(
    mojo::ArrayDataView<MenuItemDataView>* output) {
  auto pointer = data_->submenu.Get();
  *output = mojo::ArrayDataView<MenuItemDataView>(pointer, message_);
}
inline void MenuItemDataView::GetShortcutIdDataView(
    mojo::StringDataView* output) {
  auto pointer = data_->shortcut_id.Get();
  *output = mojo::StringDataView(pointer, message_);
}
inline void MenuItemDataView::GetLabelDataView(
    mojo::StringDataView* output) {
  auto pointer = data_->label.Get();
  *output = mojo::StringDataView(pointer, message_);
}
inline void MenuItemDataView::GetImageDataView(
    ::gfx::mojom::ImageSkiaDataView* output) {
  auto pointer = data_->image.Get();
  *output = ::gfx::mojom::ImageSkiaDataView(pointer, message_);
}


inline void ConditionValueDataView::GetValueDataView(
    mojo::StringDataView* output) {
  auto pointer = data_->value.Get();
  *output = mojo::StringDataView(pointer, message_);
}


inline void ConditionDataView::GetConditionValuesDataView(
    mojo::ArrayDataView<ConditionValueDataView>* output) {
  auto pointer = data_->condition_values.Get();
  *output = mojo::ArrayDataView<ConditionValueDataView>(pointer, message_);
}


inline void IntentFilterDataView::GetConditionsDataView(
    mojo::ArrayDataView<ConditionDataView>* output) {
  auto pointer = data_->conditions.Get();
  *output = mojo::ArrayDataView<ConditionDataView>(pointer, message_);
}
inline void IntentFilterDataView::GetActivityNameDataView(
    mojo::StringDataView* output) {
  auto pointer = data_->activity_name.Get();
  *output = mojo::StringDataView(pointer, message_);
}
inline void IntentFilterDataView::GetActivityLabelDataView(
    mojo::StringDataView* output) {
  auto pointer = data_->activity_label.Get();
  *output = mojo::StringDataView(pointer, message_);
}


inline void IntentFileDataView::GetUrlDataView(
    ::url::mojom::UrlDataView* output) {
  auto pointer = data_->url.Get();
  *output = ::url::mojom::UrlDataView(pointer, message_);
}
inline void IntentFileDataView::GetMimeTypeDataView(
    mojo::StringDataView* output) {
  auto pointer = data_->mime_type.Get();
  *output = mojo::StringDataView(pointer, message_);
}
inline void IntentFileDataView::GetFileNameDataView(
    ::mojo_base::mojom::SafeBaseNameDataView* output) {
  auto pointer = data_->file_name.Get();
  *output = ::mojo_base::mojom::SafeBaseNameDataView(pointer, message_);
}


inline void IntentDataView::GetActionDataView(
    mojo::StringDataView* output) {
  auto pointer = data_->action.Get();
  *output = mojo::StringDataView(pointer, message_);
}
inline void IntentDataView::GetUrlDataView(
    ::url::mojom::UrlDataView* output) {
  auto pointer = data_->url.Get();
  *output = ::url::mojom::UrlDataView(pointer, message_);
}
inline void IntentDataView::GetMimeTypeDataView(
    mojo::StringDataView* output) {
  auto pointer = data_->mime_type.Get();
  *output = mojo::StringDataView(pointer, message_);
}
inline void IntentDataView::GetFilesDataView(
    mojo::ArrayDataView<IntentFileDataView>* output) {
  auto pointer = data_->files.Get();
  *output = mojo::ArrayDataView<IntentFileDataView>(pointer, message_);
}
inline void IntentDataView::GetActivityNameDataView(
    mojo::StringDataView* output) {
  auto pointer = data_->activity_name.Get();
  *output = mojo::StringDataView(pointer, message_);
}
inline void IntentDataView::GetDriveShareUrlDataView(
    ::url::mojom::UrlDataView* output) {
  auto pointer = data_->drive_share_url.Get();
  *output = ::url::mojom::UrlDataView(pointer, message_);
}
inline void IntentDataView::GetShareTextDataView(
    mojo::StringDataView* output) {
  auto pointer = data_->share_text.Get();
  *output = mojo::StringDataView(pointer, message_);
}
inline void IntentDataView::GetShareTitleDataView(
    mojo::StringDataView* output) {
  auto pointer = data_->share_title.Get();
  *output = mojo::StringDataView(pointer, message_);
}
inline void IntentDataView::GetStartTypeDataView(
    mojo::StringDataView* output) {
  auto pointer = data_->start_type.Get();
  *output = mojo::StringDataView(pointer, message_);
}
inline void IntentDataView::GetCategoriesDataView(
    mojo::ArrayDataView<mojo::StringDataView>* output) {
  auto pointer = data_->categories.Get();
  *output = mojo::ArrayDataView<mojo::StringDataView>(pointer, message_);
}
inline void IntentDataView::GetDataDataView(
    mojo::StringDataView* output) {
  auto pointer = data_->data.Get();
  *output = mojo::StringDataView(pointer, message_);
}
inline void IntentDataView::GetExtrasDataView(
    mojo::MapDataView<mojo::StringDataView, mojo::StringDataView>* output) {
  auto pointer = data_->extras.Get();
  *output = mojo::MapDataView<mojo::StringDataView, mojo::StringDataView>(pointer, message_);
}


inline void ReplacedAppPreferencesDataView::GetReplacedPreferenceDataView(
    mojo::MapDataView<mojo::StringDataView, mojo::ArrayDataView<IntentFilterDataView>>* output) {
  auto pointer = data_->replaced_preference.Get();
  *output = mojo::MapDataView<mojo::StringDataView, mojo::ArrayDataView<IntentFilterDataView>>(pointer, message_);
}


inline void PreferredAppChangesDataView::GetAddedFiltersDataView(
    mojo::MapDataView<mojo::StringDataView, mojo::ArrayDataView<IntentFilterDataView>>* output) {
  auto pointer = data_->added_filters.Get();
  *output = mojo::MapDataView<mojo::StringDataView, mojo::ArrayDataView<IntentFilterDataView>>(pointer, message_);
}
inline void PreferredAppChangesDataView::GetRemovedFiltersDataView(
    mojo::MapDataView<mojo::StringDataView, mojo::ArrayDataView<IntentFilterDataView>>* output) {
  auto pointer = data_->removed_filters.Get();
  *output = mojo::MapDataView<mojo::StringDataView, mojo::ArrayDataView<IntentFilterDataView>>(pointer, message_);
}


inline void PreferredAppDataView::GetIntentFilterDataView(
    IntentFilterDataView* output) {
  auto pointer = data_->intent_filter.Get();
  *output = IntentFilterDataView(pointer, message_);
}
inline void PreferredAppDataView::GetAppIdDataView(
    mojo::StringDataView* output) {
  auto pointer = data_->app_id.Get();
  *output = mojo::StringDataView(pointer, message_);
}


inline void FilePathsDataView::GetFilePathsDataView(
    mojo::ArrayDataView<::mojo_base::mojom::FilePathDataView>* output) {
  auto pointer = data_->file_paths.Get();
  *output = mojo::ArrayDataView<::mojo_base::mojom::FilePathDataView>(pointer, message_);
}


inline void CapabilityAccessDataView::GetAppIdDataView(
    mojo::StringDataView* output) {
  auto pointer = data_->app_id.Get();
  *output = mojo::StringDataView(pointer, message_);
}




inline void WindowInfoDataView::GetBoundsDataView(
    RectDataView* output) {
  auto pointer = data_->bounds.Get();
  *output = RectDataView(pointer, message_);
}






}  // namespace mojom
}  // namespace apps

// Declare TraceFormatTraits for enums, which should be defined in ::perfetto
// namespace.

namespace perfetto {

template <>
struct  TraceFormatTraits<::apps::mojom::PermissionType> {
 static void WriteIntoTrace(perfetto::TracedValue context, ::apps::mojom::PermissionType value);
};

} // namespace perfetto

namespace perfetto {

template <>
struct  TraceFormatTraits<::apps::mojom::AppType> {
 static void WriteIntoTrace(perfetto::TracedValue context, ::apps::mojom::AppType value);
};

} // namespace perfetto

namespace perfetto {

template <>
struct  TraceFormatTraits<::apps::mojom::Readiness> {
 static void WriteIntoTrace(perfetto::TracedValue context, ::apps::mojom::Readiness value);
};

} // namespace perfetto

namespace perfetto {

template <>
struct  TraceFormatTraits<::apps::mojom::InstallReason> {
 static void WriteIntoTrace(perfetto::TracedValue context, ::apps::mojom::InstallReason value);
};

} // namespace perfetto

namespace perfetto {

template <>
struct  TraceFormatTraits<::apps::mojom::InstallSource> {
 static void WriteIntoTrace(perfetto::TracedValue context, ::apps::mojom::InstallSource value);
};

} // namespace perfetto

namespace perfetto {

template <>
struct  TraceFormatTraits<::apps::mojom::UninstallSource> {
 static void WriteIntoTrace(perfetto::TracedValue context, ::apps::mojom::UninstallSource value);
};

} // namespace perfetto

namespace perfetto {

template <>
struct  TraceFormatTraits<::apps::mojom::OptionalBool> {
 static void WriteIntoTrace(perfetto::TracedValue context, ::apps::mojom::OptionalBool value);
};

} // namespace perfetto

namespace perfetto {

template <>
struct  TraceFormatTraits<::apps::mojom::IconType> {
 static void WriteIntoTrace(perfetto::TracedValue context, ::apps::mojom::IconType value);
};

} // namespace perfetto

namespace perfetto {

template <>
struct  TraceFormatTraits<::apps::mojom::LaunchSource> {
 static void WriteIntoTrace(perfetto::TracedValue context, ::apps::mojom::LaunchSource value);
};

} // namespace perfetto

namespace perfetto {

template <>
struct  TraceFormatTraits<::apps::mojom::TriState> {
 static void WriteIntoTrace(perfetto::TracedValue context, ::apps::mojom::TriState value);
};

} // namespace perfetto

namespace perfetto {

template <>
struct  TraceFormatTraits<::apps::mojom::MenuItemType> {
 static void WriteIntoTrace(perfetto::TracedValue context, ::apps::mojom::MenuItemType value);
};

} // namespace perfetto

namespace perfetto {

template <>
struct  TraceFormatTraits<::apps::mojom::MenuType> {
 static void WriteIntoTrace(perfetto::TracedValue context, ::apps::mojom::MenuType value);
};

} // namespace perfetto

namespace perfetto {

template <>
struct  TraceFormatTraits<::apps::mojom::ConditionType> {
 static void WriteIntoTrace(perfetto::TracedValue context, ::apps::mojom::ConditionType value);
};

} // namespace perfetto

namespace perfetto {

template <>
struct  TraceFormatTraits<::apps::mojom::PatternMatchType> {
 static void WriteIntoTrace(perfetto::TracedValue context, ::apps::mojom::PatternMatchType value);
};

} // namespace perfetto

namespace perfetto {

template <>
struct  TraceFormatTraits<::apps::mojom::LaunchContainer> {
 static void WriteIntoTrace(perfetto::TracedValue context, ::apps::mojom::LaunchContainer value);
};

} // namespace perfetto

namespace perfetto {

template <>
struct  TraceFormatTraits<::apps::mojom::WindowMode> {
 static void WriteIntoTrace(perfetto::TracedValue context, ::apps::mojom::WindowMode value);
};

} // namespace perfetto

namespace perfetto {

template <>
struct  TraceFormatTraits<::apps::mojom::RunOnOsLoginMode> {
 static void WriteIntoTrace(perfetto::TracedValue context, ::apps::mojom::RunOnOsLoginMode value);
};

} // namespace perfetto

#endif  // COMPONENTS_SERVICES_APP_SERVICE_PUBLIC_MOJOM_TYPES_MOJOM_SHARED_H_