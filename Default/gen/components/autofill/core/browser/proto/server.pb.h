// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: server.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_server_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_server_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3020000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3020000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry_lite.h>
#include <google/protobuf/map_field_lite.h>
#include <google/protobuf/generated_enum_util.h>
#include "password_requirements.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_server_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_server_2eproto {
  static const uint32_t offsets[];
};
namespace autofill {
class AutofillQueryContents;
struct AutofillQueryContentsDefaultTypeInternal;
extern AutofillQueryContentsDefaultTypeInternal _AutofillQueryContents_default_instance_;
class AutofillQueryContents_Form;
struct AutofillQueryContents_FormDefaultTypeInternal;
extern AutofillQueryContents_FormDefaultTypeInternal _AutofillQueryContents_Form_default_instance_;
class AutofillQueryContents_Form_Field;
struct AutofillQueryContents_Form_FieldDefaultTypeInternal;
extern AutofillQueryContents_Form_FieldDefaultTypeInternal _AutofillQueryContents_Form_Field_default_instance_;
class AutofillQueryResponseContents;
struct AutofillQueryResponseContentsDefaultTypeInternal;
extern AutofillQueryResponseContentsDefaultTypeInternal _AutofillQueryResponseContents_default_instance_;
class AutofillQueryResponseContents_Field;
struct AutofillQueryResponseContents_FieldDefaultTypeInternal;
extern AutofillQueryResponseContents_FieldDefaultTypeInternal _AutofillQueryResponseContents_Field_default_instance_;
class AutofillQueryResponseContents_Field_FieldPrediction;
struct AutofillQueryResponseContents_Field_FieldPredictionDefaultTypeInternal;
extern AutofillQueryResponseContents_Field_FieldPredictionDefaultTypeInternal _AutofillQueryResponseContents_Field_FieldPrediction_default_instance_;
class AutofillRandomizedFieldMetadata;
struct AutofillRandomizedFieldMetadataDefaultTypeInternal;
extern AutofillRandomizedFieldMetadataDefaultTypeInternal _AutofillRandomizedFieldMetadata_default_instance_;
class AutofillRandomizedFormMetadata;
struct AutofillRandomizedFormMetadataDefaultTypeInternal;
extern AutofillRandomizedFormMetadataDefaultTypeInternal _AutofillRandomizedFormMetadata_default_instance_;
class AutofillRandomizedFormMetadata_ButtonTitle;
struct AutofillRandomizedFormMetadata_ButtonTitleDefaultTypeInternal;
extern AutofillRandomizedFormMetadata_ButtonTitleDefaultTypeInternal _AutofillRandomizedFormMetadata_ButtonTitle_default_instance_;
class AutofillRandomizedValue;
struct AutofillRandomizedValueDefaultTypeInternal;
extern AutofillRandomizedValueDefaultTypeInternal _AutofillRandomizedValue_default_instance_;
class AutofillUploadContents;
struct AutofillUploadContentsDefaultTypeInternal;
extern AutofillUploadContentsDefaultTypeInternal _AutofillUploadContents_default_instance_;
class AutofillUploadContents_ButtonTitle;
struct AutofillUploadContents_ButtonTitleDefaultTypeInternal;
extern AutofillUploadContents_ButtonTitleDefaultTypeInternal _AutofillUploadContents_ButtonTitle_default_instance_;
class AutofillUploadContents_Field;
struct AutofillUploadContents_FieldDefaultTypeInternal;
extern AutofillUploadContents_FieldDefaultTypeInternal _AutofillUploadContents_Field_default_instance_;
class AutofillUploadContents_Field_AutofillTypeValiditiesPair;
struct AutofillUploadContents_Field_AutofillTypeValiditiesPairDefaultTypeInternal;
extern AutofillUploadContents_Field_AutofillTypeValiditiesPairDefaultTypeInternal _AutofillUploadContents_Field_AutofillTypeValiditiesPair_default_instance_;
class AutofillUploadContents_SingleUsernameData;
struct AutofillUploadContents_SingleUsernameDataDefaultTypeInternal;
extern AutofillUploadContents_SingleUsernameDataDefaultTypeInternal _AutofillUploadContents_SingleUsernameData_default_instance_;
class ProfileValidityMap;
struct ProfileValidityMapDefaultTypeInternal;
extern ProfileValidityMapDefaultTypeInternal _ProfileValidityMap_default_instance_;
class ProfileValidityMap_FieldValidityStatesEntry_DoNotUse;
struct ProfileValidityMap_FieldValidityStatesEntry_DoNotUseDefaultTypeInternal;
extern ProfileValidityMap_FieldValidityStatesEntry_DoNotUseDefaultTypeInternal _ProfileValidityMap_FieldValidityStatesEntry_DoNotUse_default_instance_;
class UserProfileValidityMap;
struct UserProfileValidityMapDefaultTypeInternal;
extern UserProfileValidityMapDefaultTypeInternal _UserProfileValidityMap_default_instance_;
class UserProfileValidityMap_ProfileValidityEntry_DoNotUse;
struct UserProfileValidityMap_ProfileValidityEntry_DoNotUseDefaultTypeInternal;
extern UserProfileValidityMap_ProfileValidityEntry_DoNotUseDefaultTypeInternal _UserProfileValidityMap_ProfileValidityEntry_DoNotUse_default_instance_;
}  // namespace autofill
PROTOBUF_NAMESPACE_OPEN
template<> ::autofill::AutofillQueryContents* Arena::CreateMaybeMessage<::autofill::AutofillQueryContents>(Arena*);
template<> ::autofill::AutofillQueryContents_Form* Arena::CreateMaybeMessage<::autofill::AutofillQueryContents_Form>(Arena*);
template<> ::autofill::AutofillQueryContents_Form_Field* Arena::CreateMaybeMessage<::autofill::AutofillQueryContents_Form_Field>(Arena*);
template<> ::autofill::AutofillQueryResponseContents* Arena::CreateMaybeMessage<::autofill::AutofillQueryResponseContents>(Arena*);
template<> ::autofill::AutofillQueryResponseContents_Field* Arena::CreateMaybeMessage<::autofill::AutofillQueryResponseContents_Field>(Arena*);
template<> ::autofill::AutofillQueryResponseContents_Field_FieldPrediction* Arena::CreateMaybeMessage<::autofill::AutofillQueryResponseContents_Field_FieldPrediction>(Arena*);
template<> ::autofill::AutofillRandomizedFieldMetadata* Arena::CreateMaybeMessage<::autofill::AutofillRandomizedFieldMetadata>(Arena*);
template<> ::autofill::AutofillRandomizedFormMetadata* Arena::CreateMaybeMessage<::autofill::AutofillRandomizedFormMetadata>(Arena*);
template<> ::autofill::AutofillRandomizedFormMetadata_ButtonTitle* Arena::CreateMaybeMessage<::autofill::AutofillRandomizedFormMetadata_ButtonTitle>(Arena*);
template<> ::autofill::AutofillRandomizedValue* Arena::CreateMaybeMessage<::autofill::AutofillRandomizedValue>(Arena*);
template<> ::autofill::AutofillUploadContents* Arena::CreateMaybeMessage<::autofill::AutofillUploadContents>(Arena*);
template<> ::autofill::AutofillUploadContents_ButtonTitle* Arena::CreateMaybeMessage<::autofill::AutofillUploadContents_ButtonTitle>(Arena*);
template<> ::autofill::AutofillUploadContents_Field* Arena::CreateMaybeMessage<::autofill::AutofillUploadContents_Field>(Arena*);
template<> ::autofill::AutofillUploadContents_Field_AutofillTypeValiditiesPair* Arena::CreateMaybeMessage<::autofill::AutofillUploadContents_Field_AutofillTypeValiditiesPair>(Arena*);
template<> ::autofill::AutofillUploadContents_SingleUsernameData* Arena::CreateMaybeMessage<::autofill::AutofillUploadContents_SingleUsernameData>(Arena*);
template<> ::autofill::ProfileValidityMap* Arena::CreateMaybeMessage<::autofill::ProfileValidityMap>(Arena*);
template<> ::autofill::ProfileValidityMap_FieldValidityStatesEntry_DoNotUse* Arena::CreateMaybeMessage<::autofill::ProfileValidityMap_FieldValidityStatesEntry_DoNotUse>(Arena*);
template<> ::autofill::UserProfileValidityMap* Arena::CreateMaybeMessage<::autofill::UserProfileValidityMap>(Arena*);
template<> ::autofill::UserProfileValidityMap_ProfileValidityEntry_DoNotUse* Arena::CreateMaybeMessage<::autofill::UserProfileValidityMap_ProfileValidityEntry_DoNotUse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace autofill {

enum AutofillRandomizedValue_EncodingType : int {
  AutofillRandomizedValue_EncodingType_UNSPECIFIED_ENCODING_TYPE = -1,
  AutofillRandomizedValue_EncodingType_BIT_0 = 0,
  AutofillRandomizedValue_EncodingType_BIT_1 = 1,
  AutofillRandomizedValue_EncodingType_BIT_2 = 2,
  AutofillRandomizedValue_EncodingType_BIT_3 = 3,
  AutofillRandomizedValue_EncodingType_BIT_4 = 4,
  AutofillRandomizedValue_EncodingType_BIT_5 = 5,
  AutofillRandomizedValue_EncodingType_BIT_6 = 6,
  AutofillRandomizedValue_EncodingType_BIT_7 = 7,
  AutofillRandomizedValue_EncodingType_EVEN_BITS = 8,
  AutofillRandomizedValue_EncodingType_ODD_BITS = 9,
  AutofillRandomizedValue_EncodingType_ALL_BITS = 10
};
bool AutofillRandomizedValue_EncodingType_IsValid(int value);
constexpr AutofillRandomizedValue_EncodingType AutofillRandomizedValue_EncodingType_EncodingType_MIN = AutofillRandomizedValue_EncodingType_UNSPECIFIED_ENCODING_TYPE;
constexpr AutofillRandomizedValue_EncodingType AutofillRandomizedValue_EncodingType_EncodingType_MAX = AutofillRandomizedValue_EncodingType_ALL_BITS;
constexpr int AutofillRandomizedValue_EncodingType_EncodingType_ARRAYSIZE = AutofillRandomizedValue_EncodingType_EncodingType_MAX + 1;

const std::string& AutofillRandomizedValue_EncodingType_Name(AutofillRandomizedValue_EncodingType value);
template<typename T>
inline const std::string& AutofillRandomizedValue_EncodingType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AutofillRandomizedValue_EncodingType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AutofillRandomizedValue_EncodingType_Name.");
  return AutofillRandomizedValue_EncodingType_Name(static_cast<AutofillRandomizedValue_EncodingType>(enum_t_value));
}
bool AutofillRandomizedValue_EncodingType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AutofillRandomizedValue_EncodingType* value);
enum AutofillUploadContents_Field_PasswordGenerationType : int {
  AutofillUploadContents_Field_PasswordGenerationType_NO_GENERATION = 0,
  AutofillUploadContents_Field_PasswordGenerationType_AUTOMATICALLY_TRIGGERED_GENERATION_ON_SIGN_UP_FORM = 1,
  AutofillUploadContents_Field_PasswordGenerationType_AUTOMATICALLY_TRIGGERED_GENERATION_ON_CHANGE_PASSWORD_FORM = 2,
  AutofillUploadContents_Field_PasswordGenerationType_MANUALLY_TRIGGERED_GENERATION_ON_SIGN_UP_FORM = 3,
  AutofillUploadContents_Field_PasswordGenerationType_MANUALLY_TRIGGERED_GENERATION_ON_CHANGE_PASSWORD_FORM = 4,
  AutofillUploadContents_Field_PasswordGenerationType_IGNORED_GENERATION_POPUP = 5
};
bool AutofillUploadContents_Field_PasswordGenerationType_IsValid(int value);
constexpr AutofillUploadContents_Field_PasswordGenerationType AutofillUploadContents_Field_PasswordGenerationType_PasswordGenerationType_MIN = AutofillUploadContents_Field_PasswordGenerationType_NO_GENERATION;
constexpr AutofillUploadContents_Field_PasswordGenerationType AutofillUploadContents_Field_PasswordGenerationType_PasswordGenerationType_MAX = AutofillUploadContents_Field_PasswordGenerationType_IGNORED_GENERATION_POPUP;
constexpr int AutofillUploadContents_Field_PasswordGenerationType_PasswordGenerationType_ARRAYSIZE = AutofillUploadContents_Field_PasswordGenerationType_PasswordGenerationType_MAX + 1;

const std::string& AutofillUploadContents_Field_PasswordGenerationType_Name(AutofillUploadContents_Field_PasswordGenerationType value);
template<typename T>
inline const std::string& AutofillUploadContents_Field_PasswordGenerationType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AutofillUploadContents_Field_PasswordGenerationType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AutofillUploadContents_Field_PasswordGenerationType_Name.");
  return AutofillUploadContents_Field_PasswordGenerationType_Name(static_cast<AutofillUploadContents_Field_PasswordGenerationType>(enum_t_value));
}
bool AutofillUploadContents_Field_PasswordGenerationType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AutofillUploadContents_Field_PasswordGenerationType* value);
enum AutofillUploadContents_Field_VoteType : int {
  AutofillUploadContents_Field_VoteType_NO_INFORMATION = 0,
  AutofillUploadContents_Field_VoteType_CREDENTIALS_REUSED = 1,
  AutofillUploadContents_Field_VoteType_USERNAME_OVERWRITTEN = 2,
  AutofillUploadContents_Field_VoteType_USERNAME_EDITED = 3,
  AutofillUploadContents_Field_VoteType_BASE_HEURISTIC = 4,
  AutofillUploadContents_Field_VoteType_HTML_CLASSIFIER = 5,
  AutofillUploadContents_Field_VoteType_FIRST_USE = 6
};
bool AutofillUploadContents_Field_VoteType_IsValid(int value);
constexpr AutofillUploadContents_Field_VoteType AutofillUploadContents_Field_VoteType_VoteType_MIN = AutofillUploadContents_Field_VoteType_NO_INFORMATION;
constexpr AutofillUploadContents_Field_VoteType AutofillUploadContents_Field_VoteType_VoteType_MAX = AutofillUploadContents_Field_VoteType_FIRST_USE;
constexpr int AutofillUploadContents_Field_VoteType_VoteType_ARRAYSIZE = AutofillUploadContents_Field_VoteType_VoteType_MAX + 1;

const std::string& AutofillUploadContents_Field_VoteType_Name(AutofillUploadContents_Field_VoteType value);
template<typename T>
inline const std::string& AutofillUploadContents_Field_VoteType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AutofillUploadContents_Field_VoteType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AutofillUploadContents_Field_VoteType_Name.");
  return AutofillUploadContents_Field_VoteType_Name(static_cast<AutofillUploadContents_Field_VoteType>(enum_t_value));
}
bool AutofillUploadContents_Field_VoteType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AutofillUploadContents_Field_VoteType* value);
enum AutofillUploadContents_Field_SingleUsernameVoteType : int {
  AutofillUploadContents_Field_SingleUsernameVoteType_DEFAULT = 0,
  AutofillUploadContents_Field_SingleUsernameVoteType_WEAK = 1,
  AutofillUploadContents_Field_SingleUsernameVoteType_STRONG = 2
};
bool AutofillUploadContents_Field_SingleUsernameVoteType_IsValid(int value);
constexpr AutofillUploadContents_Field_SingleUsernameVoteType AutofillUploadContents_Field_SingleUsernameVoteType_SingleUsernameVoteType_MIN = AutofillUploadContents_Field_SingleUsernameVoteType_DEFAULT;
constexpr AutofillUploadContents_Field_SingleUsernameVoteType AutofillUploadContents_Field_SingleUsernameVoteType_SingleUsernameVoteType_MAX = AutofillUploadContents_Field_SingleUsernameVoteType_STRONG;
constexpr int AutofillUploadContents_Field_SingleUsernameVoteType_SingleUsernameVoteType_ARRAYSIZE = AutofillUploadContents_Field_SingleUsernameVoteType_SingleUsernameVoteType_MAX + 1;

const std::string& AutofillUploadContents_Field_SingleUsernameVoteType_Name(AutofillUploadContents_Field_SingleUsernameVoteType value);
template<typename T>
inline const std::string& AutofillUploadContents_Field_SingleUsernameVoteType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AutofillUploadContents_Field_SingleUsernameVoteType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AutofillUploadContents_Field_SingleUsernameVoteType_Name.");
  return AutofillUploadContents_Field_SingleUsernameVoteType_Name(static_cast<AutofillUploadContents_Field_SingleUsernameVoteType>(enum_t_value));
}
bool AutofillUploadContents_Field_SingleUsernameVoteType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AutofillUploadContents_Field_SingleUsernameVoteType* value);
enum AutofillUploadContents_SubmissionIndicatorEvent : int {
  AutofillUploadContents_SubmissionIndicatorEvent_NONE = 0,
  AutofillUploadContents_SubmissionIndicatorEvent_HTML_FORM_SUBMISSION = 1,
  AutofillUploadContents_SubmissionIndicatorEvent_SAME_DOCUMENT_NAVIGATION = 2,
  AutofillUploadContents_SubmissionIndicatorEvent_XHR_SUCCEEDED = 3,
  AutofillUploadContents_SubmissionIndicatorEvent_FRAME_DETACHED = 4,
  AutofillUploadContents_SubmissionIndicatorEvent_DEPRECATED_MANUAL_SAVE = 5,
  AutofillUploadContents_SubmissionIndicatorEvent_DOM_MUTATION_AFTER_XHR = 6,
  AutofillUploadContents_SubmissionIndicatorEvent_PROVISIONALLY_SAVED_FORM_ON_START_PROVISIONAL_LOAD = 7,
  AutofillUploadContents_SubmissionIndicatorEvent_DEPRECATED_FILLED_FORM_ON_START_PROVISIONAL_LOAD = 8,
  AutofillUploadContents_SubmissionIndicatorEvent_DEPRECATED_FILLED_INPUT_ELEMENTS_ON_START_PROVISIONAL_LOAD = 9,
  AutofillUploadContents_SubmissionIndicatorEvent_PROBABLE_FORM_SUBMISSION = 10,
  AutofillUploadContents_SubmissionIndicatorEvent_CHANGE_PASSWORD_FORM_CLEARED = 11
};
bool AutofillUploadContents_SubmissionIndicatorEvent_IsValid(int value);
constexpr AutofillUploadContents_SubmissionIndicatorEvent AutofillUploadContents_SubmissionIndicatorEvent_SubmissionIndicatorEvent_MIN = AutofillUploadContents_SubmissionIndicatorEvent_NONE;
constexpr AutofillUploadContents_SubmissionIndicatorEvent AutofillUploadContents_SubmissionIndicatorEvent_SubmissionIndicatorEvent_MAX = AutofillUploadContents_SubmissionIndicatorEvent_CHANGE_PASSWORD_FORM_CLEARED;
constexpr int AutofillUploadContents_SubmissionIndicatorEvent_SubmissionIndicatorEvent_ARRAYSIZE = AutofillUploadContents_SubmissionIndicatorEvent_SubmissionIndicatorEvent_MAX + 1;

const std::string& AutofillUploadContents_SubmissionIndicatorEvent_Name(AutofillUploadContents_SubmissionIndicatorEvent value);
template<typename T>
inline const std::string& AutofillUploadContents_SubmissionIndicatorEvent_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AutofillUploadContents_SubmissionIndicatorEvent>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AutofillUploadContents_SubmissionIndicatorEvent_Name.");
  return AutofillUploadContents_SubmissionIndicatorEvent_Name(static_cast<AutofillUploadContents_SubmissionIndicatorEvent>(enum_t_value));
}
bool AutofillUploadContents_SubmissionIndicatorEvent_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AutofillUploadContents_SubmissionIndicatorEvent* value);
enum AutofillUploadContents_ValueType : int {
  AutofillUploadContents_ValueType_TYPE_UNSPECIFIED = 0,
  AutofillUploadContents_ValueType_NO_VALUE_TYPE = 1,
  AutofillUploadContents_ValueType_STORED_FOR_CURRENT_DOMAIN = 2,
  AutofillUploadContents_ValueType_STORED_FOR_ANOTHER_DOMAIN = 3,
  AutofillUploadContents_ValueType_EMAIL = 4,
  AutofillUploadContents_ValueType_PHONE = 5,
  AutofillUploadContents_ValueType_USERNAME_LIKE = 6,
  AutofillUploadContents_ValueType_VALUE_WITH_NO_WHITESPACE = 7,
  AutofillUploadContents_ValueType_VALUE_WITH_WHITESPACE = 8
};
bool AutofillUploadContents_ValueType_IsValid(int value);
constexpr AutofillUploadContents_ValueType AutofillUploadContents_ValueType_ValueType_MIN = AutofillUploadContents_ValueType_TYPE_UNSPECIFIED;
constexpr AutofillUploadContents_ValueType AutofillUploadContents_ValueType_ValueType_MAX = AutofillUploadContents_ValueType_VALUE_WITH_WHITESPACE;
constexpr int AutofillUploadContents_ValueType_ValueType_ARRAYSIZE = AutofillUploadContents_ValueType_ValueType_MAX + 1;

const std::string& AutofillUploadContents_ValueType_Name(AutofillUploadContents_ValueType value);
template<typename T>
inline const std::string& AutofillUploadContents_ValueType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AutofillUploadContents_ValueType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AutofillUploadContents_ValueType_Name.");
  return AutofillUploadContents_ValueType_Name(static_cast<AutofillUploadContents_ValueType>(enum_t_value));
}
bool AutofillUploadContents_ValueType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AutofillUploadContents_ValueType* value);
enum AutofillUploadContents_SingleUsernamePromptEdit : int {
  AutofillUploadContents_SingleUsernamePromptEdit_EDIT_UNSPECIFIED = 0,
  AutofillUploadContents_SingleUsernamePromptEdit_NOT_EDITED_POSITIVE = 1,
  AutofillUploadContents_SingleUsernamePromptEdit_NOT_EDITED_NEGATIVE = 2,
  AutofillUploadContents_SingleUsernamePromptEdit_EDITED_POSITIVE = 3,
  AutofillUploadContents_SingleUsernamePromptEdit_EDITED_NEGATIVE = 4
};
bool AutofillUploadContents_SingleUsernamePromptEdit_IsValid(int value);
constexpr AutofillUploadContents_SingleUsernamePromptEdit AutofillUploadContents_SingleUsernamePromptEdit_SingleUsernamePromptEdit_MIN = AutofillUploadContents_SingleUsernamePromptEdit_EDIT_UNSPECIFIED;
constexpr AutofillUploadContents_SingleUsernamePromptEdit AutofillUploadContents_SingleUsernamePromptEdit_SingleUsernamePromptEdit_MAX = AutofillUploadContents_SingleUsernamePromptEdit_EDITED_NEGATIVE;
constexpr int AutofillUploadContents_SingleUsernamePromptEdit_SingleUsernamePromptEdit_ARRAYSIZE = AutofillUploadContents_SingleUsernamePromptEdit_SingleUsernamePromptEdit_MAX + 1;

const std::string& AutofillUploadContents_SingleUsernamePromptEdit_Name(AutofillUploadContents_SingleUsernamePromptEdit value);
template<typename T>
inline const std::string& AutofillUploadContents_SingleUsernamePromptEdit_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AutofillUploadContents_SingleUsernamePromptEdit>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AutofillUploadContents_SingleUsernamePromptEdit_Name.");
  return AutofillUploadContents_SingleUsernamePromptEdit_Name(static_cast<AutofillUploadContents_SingleUsernamePromptEdit>(enum_t_value));
}
bool AutofillUploadContents_SingleUsernamePromptEdit_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AutofillUploadContents_SingleUsernamePromptEdit* value);
enum ButtonTitleType : int {
  NONE = 0,
  BUTTON_ELEMENT_SUBMIT_TYPE = 1,
  BUTTON_ELEMENT_BUTTON_TYPE = 2,
  INPUT_ELEMENT_SUBMIT_TYPE = 3,
  INPUT_ELEMENT_BUTTON_TYPE = 4,
  HYPERLINK = 5,
  DIV = 6,
  SPAN = 7
};
bool ButtonTitleType_IsValid(int value);
constexpr ButtonTitleType ButtonTitleType_MIN = NONE;
constexpr ButtonTitleType ButtonTitleType_MAX = SPAN;
constexpr int ButtonTitleType_ARRAYSIZE = ButtonTitleType_MAX + 1;

const std::string& ButtonTitleType_Name(ButtonTitleType value);
template<typename T>
inline const std::string& ButtonTitleType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ButtonTitleType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ButtonTitleType_Name.");
  return ButtonTitleType_Name(static_cast<ButtonTitleType>(enum_t_value));
}
bool ButtonTitleType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ButtonTitleType* value);
// ===================================================================

class AutofillQueryContents_Form_Field final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill.AutofillQueryContents.Form.Field) */ {
 public:
  inline AutofillQueryContents_Form_Field() : AutofillQueryContents_Form_Field(nullptr) {}
  ~AutofillQueryContents_Form_Field() override;
  explicit PROTOBUF_CONSTEXPR AutofillQueryContents_Form_Field(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AutofillQueryContents_Form_Field(const AutofillQueryContents_Form_Field& from);
  AutofillQueryContents_Form_Field(AutofillQueryContents_Form_Field&& from) noexcept
    : AutofillQueryContents_Form_Field() {
    *this = ::std::move(from);
  }

  inline AutofillQueryContents_Form_Field& operator=(const AutofillQueryContents_Form_Field& from) {
    CopyFrom(from);
    return *this;
  }
  inline AutofillQueryContents_Form_Field& operator=(AutofillQueryContents_Form_Field&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const AutofillQueryContents_Form_Field& default_instance() {
    return *internal_default_instance();
  }
  static inline const AutofillQueryContents_Form_Field* internal_default_instance() {
    return reinterpret_cast<const AutofillQueryContents_Form_Field*>(
               &_AutofillQueryContents_Form_Field_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(AutofillQueryContents_Form_Field& a, AutofillQueryContents_Form_Field& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(AutofillQueryContents_Form_Field* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AutofillQueryContents_Form_Field* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AutofillQueryContents_Form_Field* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AutofillQueryContents_Form_Field>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const AutofillQueryContents_Form_Field& from);
  void MergeFrom(const AutofillQueryContents_Form_Field& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AutofillQueryContents_Form_Field* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill.AutofillQueryContents.Form.Field";
  }
  protected:
  explicit AutofillQueryContents_Form_Field(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 8,
    kTypeFieldNumber = 9,
    kFieldMetadataFieldNumber = 13,
    kSignatureFieldNumber = 5,
  };
  // optional string name = 8;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional string type = 9;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  const std::string& type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* type);
  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // optional .autofill.AutofillRandomizedFieldMetadata field_metadata = 13;
  bool has_field_metadata() const;
  private:
  bool _internal_has_field_metadata() const;
  public:
  void clear_field_metadata();
  const ::autofill::AutofillRandomizedFieldMetadata& field_metadata() const;
  PROTOBUF_NODISCARD ::autofill::AutofillRandomizedFieldMetadata* release_field_metadata();
  ::autofill::AutofillRandomizedFieldMetadata* mutable_field_metadata();
  void set_allocated_field_metadata(::autofill::AutofillRandomizedFieldMetadata* field_metadata);
  private:
  const ::autofill::AutofillRandomizedFieldMetadata& _internal_field_metadata() const;
  ::autofill::AutofillRandomizedFieldMetadata* _internal_mutable_field_metadata();
  public:
  void unsafe_arena_set_allocated_field_metadata(
      ::autofill::AutofillRandomizedFieldMetadata* field_metadata);
  ::autofill::AutofillRandomizedFieldMetadata* unsafe_arena_release_field_metadata();

  // required fixed32 signature = 5;
  bool has_signature() const;
  private:
  bool _internal_has_signature() const;
  public:
  void clear_signature();
  uint32_t signature() const;
  void set_signature(uint32_t value);
  private:
  uint32_t _internal_signature() const;
  void _internal_set_signature(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:autofill.AutofillQueryContents.Form.Field)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
  ::autofill::AutofillRandomizedFieldMetadata* field_metadata_;
  uint32_t signature_;
  friend struct ::TableStruct_server_2eproto;
};
// -------------------------------------------------------------------

class AutofillQueryContents_Form final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill.AutofillQueryContents.Form) */ {
 public:
  inline AutofillQueryContents_Form() : AutofillQueryContents_Form(nullptr) {}
  ~AutofillQueryContents_Form() override;
  explicit PROTOBUF_CONSTEXPR AutofillQueryContents_Form(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AutofillQueryContents_Form(const AutofillQueryContents_Form& from);
  AutofillQueryContents_Form(AutofillQueryContents_Form&& from) noexcept
    : AutofillQueryContents_Form() {
    *this = ::std::move(from);
  }

  inline AutofillQueryContents_Form& operator=(const AutofillQueryContents_Form& from) {
    CopyFrom(from);
    return *this;
  }
  inline AutofillQueryContents_Form& operator=(AutofillQueryContents_Form&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const AutofillQueryContents_Form& default_instance() {
    return *internal_default_instance();
  }
  static inline const AutofillQueryContents_Form* internal_default_instance() {
    return reinterpret_cast<const AutofillQueryContents_Form*>(
               &_AutofillQueryContents_Form_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(AutofillQueryContents_Form& a, AutofillQueryContents_Form& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(AutofillQueryContents_Form* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AutofillQueryContents_Form* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AutofillQueryContents_Form* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AutofillQueryContents_Form>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const AutofillQueryContents_Form& from);
  void MergeFrom(const AutofillQueryContents_Form& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AutofillQueryContents_Form* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill.AutofillQueryContents.Form";
  }
  protected:
  explicit AutofillQueryContents_Form(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef AutofillQueryContents_Form_Field Field;

  // accessors -------------------------------------------------------

  enum : int {
    kFieldFieldNumber = 4,
    kFormMetadataFieldNumber = 12,
    kSignatureFieldNumber = 3,
  };
  // repeated group Field = 4 { ... };
  int field_size() const;
  private:
  int _internal_field_size() const;
  public:
  void clear_field();
  ::autofill::AutofillQueryContents_Form_Field* mutable_field(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill::AutofillQueryContents_Form_Field >*
      mutable_field();
  private:
  const ::autofill::AutofillQueryContents_Form_Field& _internal_field(int index) const;
  ::autofill::AutofillQueryContents_Form_Field* _internal_add_field();
  public:
  const ::autofill::AutofillQueryContents_Form_Field& field(int index) const;
  ::autofill::AutofillQueryContents_Form_Field* add_field();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill::AutofillQueryContents_Form_Field >&
      field() const;

  // optional .autofill.AutofillRandomizedFormMetadata form_metadata = 12;
  bool has_form_metadata() const;
  private:
  bool _internal_has_form_metadata() const;
  public:
  void clear_form_metadata();
  const ::autofill::AutofillRandomizedFormMetadata& form_metadata() const;
  PROTOBUF_NODISCARD ::autofill::AutofillRandomizedFormMetadata* release_form_metadata();
  ::autofill::AutofillRandomizedFormMetadata* mutable_form_metadata();
  void set_allocated_form_metadata(::autofill::AutofillRandomizedFormMetadata* form_metadata);
  private:
  const ::autofill::AutofillRandomizedFormMetadata& _internal_form_metadata() const;
  ::autofill::AutofillRandomizedFormMetadata* _internal_mutable_form_metadata();
  public:
  void unsafe_arena_set_allocated_form_metadata(
      ::autofill::AutofillRandomizedFormMetadata* form_metadata);
  ::autofill::AutofillRandomizedFormMetadata* unsafe_arena_release_form_metadata();

  // required fixed64 signature = 3;
  bool has_signature() const;
  private:
  bool _internal_has_signature() const;
  public:
  void clear_signature();
  uint64_t signature() const;
  void set_signature(uint64_t value);
  private:
  uint64_t _internal_signature() const;
  void _internal_set_signature(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:autofill.AutofillQueryContents.Form)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill::AutofillQueryContents_Form_Field > field_;
  ::autofill::AutofillRandomizedFormMetadata* form_metadata_;
  uint64_t signature_;
  friend struct ::TableStruct_server_2eproto;
};
// -------------------------------------------------------------------

class AutofillQueryContents final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill.AutofillQueryContents) */ {
 public:
  inline AutofillQueryContents() : AutofillQueryContents(nullptr) {}
  ~AutofillQueryContents() override;
  explicit PROTOBUF_CONSTEXPR AutofillQueryContents(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AutofillQueryContents(const AutofillQueryContents& from);
  AutofillQueryContents(AutofillQueryContents&& from) noexcept
    : AutofillQueryContents() {
    *this = ::std::move(from);
  }

  inline AutofillQueryContents& operator=(const AutofillQueryContents& from) {
    CopyFrom(from);
    return *this;
  }
  inline AutofillQueryContents& operator=(AutofillQueryContents&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const AutofillQueryContents& default_instance() {
    return *internal_default_instance();
  }
  static inline const AutofillQueryContents* internal_default_instance() {
    return reinterpret_cast<const AutofillQueryContents*>(
               &_AutofillQueryContents_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(AutofillQueryContents& a, AutofillQueryContents& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(AutofillQueryContents* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AutofillQueryContents* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AutofillQueryContents* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AutofillQueryContents>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const AutofillQueryContents& from);
  void MergeFrom(const AutofillQueryContents& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AutofillQueryContents* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill.AutofillQueryContents";
  }
  protected:
  explicit AutofillQueryContents(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef AutofillQueryContents_Form Form;

  // accessors -------------------------------------------------------

  enum : int {
    kFormFieldNumber = 2,
    kExperimentsFieldNumber = 14,
    kClientVersionFieldNumber = 1,
  };
  // repeated group Form = 2 { ... };
  int form_size() const;
  private:
  int _internal_form_size() const;
  public:
  void clear_form();
  ::autofill::AutofillQueryContents_Form* mutable_form(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill::AutofillQueryContents_Form >*
      mutable_form();
  private:
  const ::autofill::AutofillQueryContents_Form& _internal_form(int index) const;
  ::autofill::AutofillQueryContents_Form* _internal_add_form();
  public:
  const ::autofill::AutofillQueryContents_Form& form(int index) const;
  ::autofill::AutofillQueryContents_Form* add_form();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill::AutofillQueryContents_Form >&
      form() const;

  // repeated int64 experiments = 14;
  int experiments_size() const;
  private:
  int _internal_experiments_size() const;
  public:
  void clear_experiments();
  private:
  int64_t _internal_experiments(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      _internal_experiments() const;
  void _internal_add_experiments(int64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      _internal_mutable_experiments();
  public:
  int64_t experiments(int index) const;
  void set_experiments(int index, int64_t value);
  void add_experiments(int64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      experiments() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      mutable_experiments();

  // required string client_version = 1;
  bool has_client_version() const;
  private:
  bool _internal_has_client_version() const;
  public:
  void clear_client_version();
  const std::string& client_version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_client_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_client_version();
  PROTOBUF_NODISCARD std::string* release_client_version();
  void set_allocated_client_version(std::string* client_version);
  private:
  const std::string& _internal_client_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_client_version(const std::string& value);
  std::string* _internal_mutable_client_version();
  public:

  // @@protoc_insertion_point(class_scope:autofill.AutofillQueryContents)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill::AutofillQueryContents_Form > form_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t > experiments_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr client_version_;
  friend struct ::TableStruct_server_2eproto;
};
// -------------------------------------------------------------------

class AutofillQueryResponseContents_Field_FieldPrediction final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill.AutofillQueryResponseContents.Field.FieldPrediction) */ {
 public:
  inline AutofillQueryResponseContents_Field_FieldPrediction() : AutofillQueryResponseContents_Field_FieldPrediction(nullptr) {}
  ~AutofillQueryResponseContents_Field_FieldPrediction() override;
  explicit PROTOBUF_CONSTEXPR AutofillQueryResponseContents_Field_FieldPrediction(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AutofillQueryResponseContents_Field_FieldPrediction(const AutofillQueryResponseContents_Field_FieldPrediction& from);
  AutofillQueryResponseContents_Field_FieldPrediction(AutofillQueryResponseContents_Field_FieldPrediction&& from) noexcept
    : AutofillQueryResponseContents_Field_FieldPrediction() {
    *this = ::std::move(from);
  }

  inline AutofillQueryResponseContents_Field_FieldPrediction& operator=(const AutofillQueryResponseContents_Field_FieldPrediction& from) {
    CopyFrom(from);
    return *this;
  }
  inline AutofillQueryResponseContents_Field_FieldPrediction& operator=(AutofillQueryResponseContents_Field_FieldPrediction&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const AutofillQueryResponseContents_Field_FieldPrediction& default_instance() {
    return *internal_default_instance();
  }
  static inline const AutofillQueryResponseContents_Field_FieldPrediction* internal_default_instance() {
    return reinterpret_cast<const AutofillQueryResponseContents_Field_FieldPrediction*>(
               &_AutofillQueryResponseContents_Field_FieldPrediction_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(AutofillQueryResponseContents_Field_FieldPrediction& a, AutofillQueryResponseContents_Field_FieldPrediction& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(AutofillQueryResponseContents_Field_FieldPrediction* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AutofillQueryResponseContents_Field_FieldPrediction* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AutofillQueryResponseContents_Field_FieldPrediction* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AutofillQueryResponseContents_Field_FieldPrediction>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const AutofillQueryResponseContents_Field_FieldPrediction& from);
  void MergeFrom(const AutofillQueryResponseContents_Field_FieldPrediction& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AutofillQueryResponseContents_Field_FieldPrediction* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill.AutofillQueryResponseContents.Field.FieldPrediction";
  }
  protected:
  explicit AutofillQueryResponseContents_Field_FieldPrediction(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
    kMayUsePrefilledPlaceholderFieldNumber = 2,
  };
  // optional fixed32 type = 1;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  uint32_t type() const;
  void set_type(uint32_t value);
  private:
  uint32_t _internal_type() const;
  void _internal_set_type(uint32_t value);
  public:

  // optional bool may_use_prefilled_placeholder = 2;
  bool has_may_use_prefilled_placeholder() const;
  private:
  bool _internal_has_may_use_prefilled_placeholder() const;
  public:
  void clear_may_use_prefilled_placeholder();
  bool may_use_prefilled_placeholder() const;
  void set_may_use_prefilled_placeholder(bool value);
  private:
  bool _internal_may_use_prefilled_placeholder() const;
  void _internal_set_may_use_prefilled_placeholder(bool value);
  public:

  // @@protoc_insertion_point(class_scope:autofill.AutofillQueryResponseContents.Field.FieldPrediction)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t type_;
  bool may_use_prefilled_placeholder_;
  friend struct ::TableStruct_server_2eproto;
};
// -------------------------------------------------------------------

class AutofillQueryResponseContents_Field final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill.AutofillQueryResponseContents.Field) */ {
 public:
  inline AutofillQueryResponseContents_Field() : AutofillQueryResponseContents_Field(nullptr) {}
  ~AutofillQueryResponseContents_Field() override;
  explicit PROTOBUF_CONSTEXPR AutofillQueryResponseContents_Field(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AutofillQueryResponseContents_Field(const AutofillQueryResponseContents_Field& from);
  AutofillQueryResponseContents_Field(AutofillQueryResponseContents_Field&& from) noexcept
    : AutofillQueryResponseContents_Field() {
    *this = ::std::move(from);
  }

  inline AutofillQueryResponseContents_Field& operator=(const AutofillQueryResponseContents_Field& from) {
    CopyFrom(from);
    return *this;
  }
  inline AutofillQueryResponseContents_Field& operator=(AutofillQueryResponseContents_Field&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const AutofillQueryResponseContents_Field& default_instance() {
    return *internal_default_instance();
  }
  static inline const AutofillQueryResponseContents_Field* internal_default_instance() {
    return reinterpret_cast<const AutofillQueryResponseContents_Field*>(
               &_AutofillQueryResponseContents_Field_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(AutofillQueryResponseContents_Field& a, AutofillQueryResponseContents_Field& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(AutofillQueryResponseContents_Field* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AutofillQueryResponseContents_Field* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AutofillQueryResponseContents_Field* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AutofillQueryResponseContents_Field>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const AutofillQueryResponseContents_Field& from);
  void MergeFrom(const AutofillQueryResponseContents_Field& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AutofillQueryResponseContents_Field* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill.AutofillQueryResponseContents.Field";
  }
  protected:
  explicit AutofillQueryResponseContents_Field(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef AutofillQueryResponseContents_Field_FieldPrediction FieldPrediction;

  // accessors -------------------------------------------------------

  enum : int {
    kPredictionsFieldNumber = 7,
    kPasswordRequirementsFieldNumber = 9,
    kOverallTypePredictionFieldNumber = 3,
  };
  // repeated .autofill.AutofillQueryResponseContents.Field.FieldPrediction predictions = 7;
  int predictions_size() const;
  private:
  int _internal_predictions_size() const;
  public:
  void clear_predictions();
  ::autofill::AutofillQueryResponseContents_Field_FieldPrediction* mutable_predictions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill::AutofillQueryResponseContents_Field_FieldPrediction >*
      mutable_predictions();
  private:
  const ::autofill::AutofillQueryResponseContents_Field_FieldPrediction& _internal_predictions(int index) const;
  ::autofill::AutofillQueryResponseContents_Field_FieldPrediction* _internal_add_predictions();
  public:
  const ::autofill::AutofillQueryResponseContents_Field_FieldPrediction& predictions(int index) const;
  ::autofill::AutofillQueryResponseContents_Field_FieldPrediction* add_predictions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill::AutofillQueryResponseContents_Field_FieldPrediction >&
      predictions() const;

  // optional .autofill.PasswordRequirementsSpec password_requirements = 9;
  bool has_password_requirements() const;
  private:
  bool _internal_has_password_requirements() const;
  public:
  void clear_password_requirements();
  const ::autofill::PasswordRequirementsSpec& password_requirements() const;
  PROTOBUF_NODISCARD ::autofill::PasswordRequirementsSpec* release_password_requirements();
  ::autofill::PasswordRequirementsSpec* mutable_password_requirements();
  void set_allocated_password_requirements(::autofill::PasswordRequirementsSpec* password_requirements);
  private:
  const ::autofill::PasswordRequirementsSpec& _internal_password_requirements() const;
  ::autofill::PasswordRequirementsSpec* _internal_mutable_password_requirements();
  public:
  void unsafe_arena_set_allocated_password_requirements(
      ::autofill::PasswordRequirementsSpec* password_requirements);
  ::autofill::PasswordRequirementsSpec* unsafe_arena_release_password_requirements();

  // required fixed32 overall_type_prediction = 3;
  bool has_overall_type_prediction() const;
  private:
  bool _internal_has_overall_type_prediction() const;
  public:
  void clear_overall_type_prediction();
  uint32_t overall_type_prediction() const;
  void set_overall_type_prediction(uint32_t value);
  private:
  uint32_t _internal_overall_type_prediction() const;
  void _internal_set_overall_type_prediction(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:autofill.AutofillQueryResponseContents.Field)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill::AutofillQueryResponseContents_Field_FieldPrediction > predictions_;
  ::autofill::PasswordRequirementsSpec* password_requirements_;
  uint32_t overall_type_prediction_;
  friend struct ::TableStruct_server_2eproto;
};
// -------------------------------------------------------------------

class AutofillQueryResponseContents final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill.AutofillQueryResponseContents) */ {
 public:
  inline AutofillQueryResponseContents() : AutofillQueryResponseContents(nullptr) {}
  ~AutofillQueryResponseContents() override;
  explicit PROTOBUF_CONSTEXPR AutofillQueryResponseContents(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AutofillQueryResponseContents(const AutofillQueryResponseContents& from);
  AutofillQueryResponseContents(AutofillQueryResponseContents&& from) noexcept
    : AutofillQueryResponseContents() {
    *this = ::std::move(from);
  }

  inline AutofillQueryResponseContents& operator=(const AutofillQueryResponseContents& from) {
    CopyFrom(from);
    return *this;
  }
  inline AutofillQueryResponseContents& operator=(AutofillQueryResponseContents&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const AutofillQueryResponseContents& default_instance() {
    return *internal_default_instance();
  }
  static inline const AutofillQueryResponseContents* internal_default_instance() {
    return reinterpret_cast<const AutofillQueryResponseContents*>(
               &_AutofillQueryResponseContents_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(AutofillQueryResponseContents& a, AutofillQueryResponseContents& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(AutofillQueryResponseContents* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AutofillQueryResponseContents* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AutofillQueryResponseContents* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AutofillQueryResponseContents>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const AutofillQueryResponseContents& from);
  void MergeFrom(const AutofillQueryResponseContents& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AutofillQueryResponseContents* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill.AutofillQueryResponseContents";
  }
  protected:
  explicit AutofillQueryResponseContents(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef AutofillQueryResponseContents_Field Field;

  // accessors -------------------------------------------------------

  enum : int {
    kFieldFieldNumber = 2,
    kUploadRequiredFieldNumber = 1,
  };
  // repeated group Field = 2 { ... };
  int field_size() const;
  private:
  int _internal_field_size() const;
  public:
  void clear_field();
  ::autofill::AutofillQueryResponseContents_Field* mutable_field(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill::AutofillQueryResponseContents_Field >*
      mutable_field();
  private:
  const ::autofill::AutofillQueryResponseContents_Field& _internal_field(int index) const;
  ::autofill::AutofillQueryResponseContents_Field* _internal_add_field();
  public:
  const ::autofill::AutofillQueryResponseContents_Field& field(int index) const;
  ::autofill::AutofillQueryResponseContents_Field* add_field();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill::AutofillQueryResponseContents_Field >&
      field() const;

  // optional bool upload_required = 1 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_upload_required() const;
  private:
  bool _internal_has_upload_required() const;
  public:
  PROTOBUF_DEPRECATED void clear_upload_required();
  PROTOBUF_DEPRECATED bool upload_required() const;
  PROTOBUF_DEPRECATED void set_upload_required(bool value);
  private:
  bool _internal_upload_required() const;
  void _internal_set_upload_required(bool value);
  public:

  // @@protoc_insertion_point(class_scope:autofill.AutofillQueryResponseContents)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill::AutofillQueryResponseContents_Field > field_;
  bool upload_required_;
  friend struct ::TableStruct_server_2eproto;
};
// -------------------------------------------------------------------

class AutofillRandomizedValue final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill.AutofillRandomizedValue) */ {
 public:
  inline AutofillRandomizedValue() : AutofillRandomizedValue(nullptr) {}
  ~AutofillRandomizedValue() override;
  explicit PROTOBUF_CONSTEXPR AutofillRandomizedValue(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AutofillRandomizedValue(const AutofillRandomizedValue& from);
  AutofillRandomizedValue(AutofillRandomizedValue&& from) noexcept
    : AutofillRandomizedValue() {
    *this = ::std::move(from);
  }

  inline AutofillRandomizedValue& operator=(const AutofillRandomizedValue& from) {
    CopyFrom(from);
    return *this;
  }
  inline AutofillRandomizedValue& operator=(AutofillRandomizedValue&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const AutofillRandomizedValue& default_instance() {
    return *internal_default_instance();
  }
  static inline const AutofillRandomizedValue* internal_default_instance() {
    return reinterpret_cast<const AutofillRandomizedValue*>(
               &_AutofillRandomizedValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(AutofillRandomizedValue& a, AutofillRandomizedValue& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(AutofillRandomizedValue* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AutofillRandomizedValue* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AutofillRandomizedValue* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AutofillRandomizedValue>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const AutofillRandomizedValue& from);
  void MergeFrom(const AutofillRandomizedValue& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AutofillRandomizedValue* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill.AutofillRandomizedValue";
  }
  protected:
  explicit AutofillRandomizedValue(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef AutofillRandomizedValue_EncodingType EncodingType;
  static constexpr EncodingType UNSPECIFIED_ENCODING_TYPE =
    AutofillRandomizedValue_EncodingType_UNSPECIFIED_ENCODING_TYPE;
  static constexpr EncodingType BIT_0 =
    AutofillRandomizedValue_EncodingType_BIT_0;
  static constexpr EncodingType BIT_1 =
    AutofillRandomizedValue_EncodingType_BIT_1;
  static constexpr EncodingType BIT_2 =
    AutofillRandomizedValue_EncodingType_BIT_2;
  static constexpr EncodingType BIT_3 =
    AutofillRandomizedValue_EncodingType_BIT_3;
  static constexpr EncodingType BIT_4 =
    AutofillRandomizedValue_EncodingType_BIT_4;
  static constexpr EncodingType BIT_5 =
    AutofillRandomizedValue_EncodingType_BIT_5;
  static constexpr EncodingType BIT_6 =
    AutofillRandomizedValue_EncodingType_BIT_6;
  static constexpr EncodingType BIT_7 =
    AutofillRandomizedValue_EncodingType_BIT_7;
  static constexpr EncodingType EVEN_BITS =
    AutofillRandomizedValue_EncodingType_EVEN_BITS;
  static constexpr EncodingType ODD_BITS =
    AutofillRandomizedValue_EncodingType_ODD_BITS;
  static constexpr EncodingType ALL_BITS =
    AutofillRandomizedValue_EncodingType_ALL_BITS;
  static inline bool EncodingType_IsValid(int value) {
    return AutofillRandomizedValue_EncodingType_IsValid(value);
  }
  static constexpr EncodingType EncodingType_MIN =
    AutofillRandomizedValue_EncodingType_EncodingType_MIN;
  static constexpr EncodingType EncodingType_MAX =
    AutofillRandomizedValue_EncodingType_EncodingType_MAX;
  static constexpr int EncodingType_ARRAYSIZE =
    AutofillRandomizedValue_EncodingType_EncodingType_ARRAYSIZE;
  template<typename T>
  static inline const std::string& EncodingType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, EncodingType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function EncodingType_Name.");
    return AutofillRandomizedValue_EncodingType_Name(enum_t_value);
  }
  static inline bool EncodingType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      EncodingType* value) {
    return AutofillRandomizedValue_EncodingType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kEncodedBitsFieldNumber = 2,
    kChecksumFieldNumber = 3,
    kEncodingTypeFieldNumber = 1,
  };
  // optional bytes encoded_bits = 2;
  bool has_encoded_bits() const;
  private:
  bool _internal_has_encoded_bits() const;
  public:
  void clear_encoded_bits();
  const std::string& encoded_bits() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_encoded_bits(ArgT0&& arg0, ArgT... args);
  std::string* mutable_encoded_bits();
  PROTOBUF_NODISCARD std::string* release_encoded_bits();
  void set_allocated_encoded_bits(std::string* encoded_bits);
  private:
  const std::string& _internal_encoded_bits() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_encoded_bits(const std::string& value);
  std::string* _internal_mutable_encoded_bits();
  public:

  // optional fixed32 checksum = 3;
  bool has_checksum() const;
  private:
  bool _internal_has_checksum() const;
  public:
  void clear_checksum();
  uint32_t checksum() const;
  void set_checksum(uint32_t value);
  private:
  uint32_t _internal_checksum() const;
  void _internal_set_checksum(uint32_t value);
  public:

  // optional .autofill.AutofillRandomizedValue.EncodingType encoding_type = 1 [default = UNSPECIFIED_ENCODING_TYPE];
  bool has_encoding_type() const;
  private:
  bool _internal_has_encoding_type() const;
  public:
  void clear_encoding_type();
  ::autofill::AutofillRandomizedValue_EncodingType encoding_type() const;
  void set_encoding_type(::autofill::AutofillRandomizedValue_EncodingType value);
  private:
  ::autofill::AutofillRandomizedValue_EncodingType _internal_encoding_type() const;
  void _internal_set_encoding_type(::autofill::AutofillRandomizedValue_EncodingType value);
  public:

  // @@protoc_insertion_point(class_scope:autofill.AutofillRandomizedValue)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr encoded_bits_;
  uint32_t checksum_;
  int encoding_type_;
  friend struct ::TableStruct_server_2eproto;
};
// -------------------------------------------------------------------

class AutofillRandomizedFormMetadata_ButtonTitle final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill.AutofillRandomizedFormMetadata.ButtonTitle) */ {
 public:
  inline AutofillRandomizedFormMetadata_ButtonTitle() : AutofillRandomizedFormMetadata_ButtonTitle(nullptr) {}
  ~AutofillRandomizedFormMetadata_ButtonTitle() override;
  explicit PROTOBUF_CONSTEXPR AutofillRandomizedFormMetadata_ButtonTitle(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AutofillRandomizedFormMetadata_ButtonTitle(const AutofillRandomizedFormMetadata_ButtonTitle& from);
  AutofillRandomizedFormMetadata_ButtonTitle(AutofillRandomizedFormMetadata_ButtonTitle&& from) noexcept
    : AutofillRandomizedFormMetadata_ButtonTitle() {
    *this = ::std::move(from);
  }

  inline AutofillRandomizedFormMetadata_ButtonTitle& operator=(const AutofillRandomizedFormMetadata_ButtonTitle& from) {
    CopyFrom(from);
    return *this;
  }
  inline AutofillRandomizedFormMetadata_ButtonTitle& operator=(AutofillRandomizedFormMetadata_ButtonTitle&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const AutofillRandomizedFormMetadata_ButtonTitle& default_instance() {
    return *internal_default_instance();
  }
  static inline const AutofillRandomizedFormMetadata_ButtonTitle* internal_default_instance() {
    return reinterpret_cast<const AutofillRandomizedFormMetadata_ButtonTitle*>(
               &_AutofillRandomizedFormMetadata_ButtonTitle_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(AutofillRandomizedFormMetadata_ButtonTitle& a, AutofillRandomizedFormMetadata_ButtonTitle& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(AutofillRandomizedFormMetadata_ButtonTitle* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AutofillRandomizedFormMetadata_ButtonTitle* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AutofillRandomizedFormMetadata_ButtonTitle* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AutofillRandomizedFormMetadata_ButtonTitle>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const AutofillRandomizedFormMetadata_ButtonTitle& from);
  void MergeFrom(const AutofillRandomizedFormMetadata_ButtonTitle& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AutofillRandomizedFormMetadata_ButtonTitle* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill.AutofillRandomizedFormMetadata.ButtonTitle";
  }
  protected:
  explicit AutofillRandomizedFormMetadata_ButtonTitle(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTitleFieldNumber = 1,
    kTypeFieldNumber = 2,
  };
  // optional .autofill.AutofillRandomizedValue title = 1;
  bool has_title() const;
  private:
  bool _internal_has_title() const;
  public:
  void clear_title();
  const ::autofill::AutofillRandomizedValue& title() const;
  PROTOBUF_NODISCARD ::autofill::AutofillRandomizedValue* release_title();
  ::autofill::AutofillRandomizedValue* mutable_title();
  void set_allocated_title(::autofill::AutofillRandomizedValue* title);
  private:
  const ::autofill::AutofillRandomizedValue& _internal_title() const;
  ::autofill::AutofillRandomizedValue* _internal_mutable_title();
  public:
  void unsafe_arena_set_allocated_title(
      ::autofill::AutofillRandomizedValue* title);
  ::autofill::AutofillRandomizedValue* unsafe_arena_release_title();

  // optional .autofill.ButtonTitleType type = 2;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::autofill::ButtonTitleType type() const;
  void set_type(::autofill::ButtonTitleType value);
  private:
  ::autofill::ButtonTitleType _internal_type() const;
  void _internal_set_type(::autofill::ButtonTitleType value);
  public:

  // @@protoc_insertion_point(class_scope:autofill.AutofillRandomizedFormMetadata.ButtonTitle)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::autofill::AutofillRandomizedValue* title_;
  int type_;
  friend struct ::TableStruct_server_2eproto;
};
// -------------------------------------------------------------------

class AutofillRandomizedFormMetadata final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill.AutofillRandomizedFormMetadata) */ {
 public:
  inline AutofillRandomizedFormMetadata() : AutofillRandomizedFormMetadata(nullptr) {}
  ~AutofillRandomizedFormMetadata() override;
  explicit PROTOBUF_CONSTEXPR AutofillRandomizedFormMetadata(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AutofillRandomizedFormMetadata(const AutofillRandomizedFormMetadata& from);
  AutofillRandomizedFormMetadata(AutofillRandomizedFormMetadata&& from) noexcept
    : AutofillRandomizedFormMetadata() {
    *this = ::std::move(from);
  }

  inline AutofillRandomizedFormMetadata& operator=(const AutofillRandomizedFormMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline AutofillRandomizedFormMetadata& operator=(AutofillRandomizedFormMetadata&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const AutofillRandomizedFormMetadata& default_instance() {
    return *internal_default_instance();
  }
  static inline const AutofillRandomizedFormMetadata* internal_default_instance() {
    return reinterpret_cast<const AutofillRandomizedFormMetadata*>(
               &_AutofillRandomizedFormMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(AutofillRandomizedFormMetadata& a, AutofillRandomizedFormMetadata& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(AutofillRandomizedFormMetadata* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AutofillRandomizedFormMetadata* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AutofillRandomizedFormMetadata* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AutofillRandomizedFormMetadata>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const AutofillRandomizedFormMetadata& from);
  void MergeFrom(const AutofillRandomizedFormMetadata& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AutofillRandomizedFormMetadata* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill.AutofillRandomizedFormMetadata";
  }
  protected:
  explicit AutofillRandomizedFormMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef AutofillRandomizedFormMetadata_ButtonTitle ButtonTitle;

  // accessors -------------------------------------------------------

  enum : int {
    kButtonTitleFieldNumber = 5,
    kIdFieldNumber = 1,
    kNameFieldNumber = 2,
    kActionFieldNumber = 3,
    kUrlFieldNumber = 4,
  };
  // repeated .autofill.AutofillRandomizedFormMetadata.ButtonTitle button_title = 5;
  int button_title_size() const;
  private:
  int _internal_button_title_size() const;
  public:
  void clear_button_title();
  ::autofill::AutofillRandomizedFormMetadata_ButtonTitle* mutable_button_title(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill::AutofillRandomizedFormMetadata_ButtonTitle >*
      mutable_button_title();
  private:
  const ::autofill::AutofillRandomizedFormMetadata_ButtonTitle& _internal_button_title(int index) const;
  ::autofill::AutofillRandomizedFormMetadata_ButtonTitle* _internal_add_button_title();
  public:
  const ::autofill::AutofillRandomizedFormMetadata_ButtonTitle& button_title(int index) const;
  ::autofill::AutofillRandomizedFormMetadata_ButtonTitle* add_button_title();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill::AutofillRandomizedFormMetadata_ButtonTitle >&
      button_title() const;

  // optional .autofill.AutofillRandomizedValue id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  const ::autofill::AutofillRandomizedValue& id() const;
  PROTOBUF_NODISCARD ::autofill::AutofillRandomizedValue* release_id();
  ::autofill::AutofillRandomizedValue* mutable_id();
  void set_allocated_id(::autofill::AutofillRandomizedValue* id);
  private:
  const ::autofill::AutofillRandomizedValue& _internal_id() const;
  ::autofill::AutofillRandomizedValue* _internal_mutable_id();
  public:
  void unsafe_arena_set_allocated_id(
      ::autofill::AutofillRandomizedValue* id);
  ::autofill::AutofillRandomizedValue* unsafe_arena_release_id();

  // optional .autofill.AutofillRandomizedValue name = 2;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const ::autofill::AutofillRandomizedValue& name() const;
  PROTOBUF_NODISCARD ::autofill::AutofillRandomizedValue* release_name();
  ::autofill::AutofillRandomizedValue* mutable_name();
  void set_allocated_name(::autofill::AutofillRandomizedValue* name);
  private:
  const ::autofill::AutofillRandomizedValue& _internal_name() const;
  ::autofill::AutofillRandomizedValue* _internal_mutable_name();
  public:
  void unsafe_arena_set_allocated_name(
      ::autofill::AutofillRandomizedValue* name);
  ::autofill::AutofillRandomizedValue* unsafe_arena_release_name();

  // optional .autofill.AutofillRandomizedValue action = 3;
  bool has_action() const;
  private:
  bool _internal_has_action() const;
  public:
  void clear_action();
  const ::autofill::AutofillRandomizedValue& action() const;
  PROTOBUF_NODISCARD ::autofill::AutofillRandomizedValue* release_action();
  ::autofill::AutofillRandomizedValue* mutable_action();
  void set_allocated_action(::autofill::AutofillRandomizedValue* action);
  private:
  const ::autofill::AutofillRandomizedValue& _internal_action() const;
  ::autofill::AutofillRandomizedValue* _internal_mutable_action();
  public:
  void unsafe_arena_set_allocated_action(
      ::autofill::AutofillRandomizedValue* action);
  ::autofill::AutofillRandomizedValue* unsafe_arena_release_action();

  // optional .autofill.AutofillRandomizedValue url = 4;
  bool has_url() const;
  private:
  bool _internal_has_url() const;
  public:
  void clear_url();
  const ::autofill::AutofillRandomizedValue& url() const;
  PROTOBUF_NODISCARD ::autofill::AutofillRandomizedValue* release_url();
  ::autofill::AutofillRandomizedValue* mutable_url();
  void set_allocated_url(::autofill::AutofillRandomizedValue* url);
  private:
  const ::autofill::AutofillRandomizedValue& _internal_url() const;
  ::autofill::AutofillRandomizedValue* _internal_mutable_url();
  public:
  void unsafe_arena_set_allocated_url(
      ::autofill::AutofillRandomizedValue* url);
  ::autofill::AutofillRandomizedValue* unsafe_arena_release_url();

  // @@protoc_insertion_point(class_scope:autofill.AutofillRandomizedFormMetadata)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill::AutofillRandomizedFormMetadata_ButtonTitle > button_title_;
  ::autofill::AutofillRandomizedValue* id_;
  ::autofill::AutofillRandomizedValue* name_;
  ::autofill::AutofillRandomizedValue* action_;
  ::autofill::AutofillRandomizedValue* url_;
  friend struct ::TableStruct_server_2eproto;
};
// -------------------------------------------------------------------

class AutofillRandomizedFieldMetadata final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill.AutofillRandomizedFieldMetadata) */ {
 public:
  inline AutofillRandomizedFieldMetadata() : AutofillRandomizedFieldMetadata(nullptr) {}
  ~AutofillRandomizedFieldMetadata() override;
  explicit PROTOBUF_CONSTEXPR AutofillRandomizedFieldMetadata(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AutofillRandomizedFieldMetadata(const AutofillRandomizedFieldMetadata& from);
  AutofillRandomizedFieldMetadata(AutofillRandomizedFieldMetadata&& from) noexcept
    : AutofillRandomizedFieldMetadata() {
    *this = ::std::move(from);
  }

  inline AutofillRandomizedFieldMetadata& operator=(const AutofillRandomizedFieldMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline AutofillRandomizedFieldMetadata& operator=(AutofillRandomizedFieldMetadata&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const AutofillRandomizedFieldMetadata& default_instance() {
    return *internal_default_instance();
  }
  static inline const AutofillRandomizedFieldMetadata* internal_default_instance() {
    return reinterpret_cast<const AutofillRandomizedFieldMetadata*>(
               &_AutofillRandomizedFieldMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(AutofillRandomizedFieldMetadata& a, AutofillRandomizedFieldMetadata& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(AutofillRandomizedFieldMetadata* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AutofillRandomizedFieldMetadata* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AutofillRandomizedFieldMetadata* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AutofillRandomizedFieldMetadata>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const AutofillRandomizedFieldMetadata& from);
  void MergeFrom(const AutofillRandomizedFieldMetadata& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AutofillRandomizedFieldMetadata* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill.AutofillRandomizedFieldMetadata";
  }
  protected:
  explicit AutofillRandomizedFieldMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kNameFieldNumber = 2,
    kTypeFieldNumber = 3,
    kLabelFieldNumber = 4,
    kAriaLabelFieldNumber = 5,
    kAriaDescriptionFieldNumber = 6,
    kCssClassFieldNumber = 7,
    kPlaceholderFieldNumber = 8,
    kInitialValueHashFieldNumber = 9,
    kAutocompleteFieldNumber = 10,
  };
  // optional .autofill.AutofillRandomizedValue id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  const ::autofill::AutofillRandomizedValue& id() const;
  PROTOBUF_NODISCARD ::autofill::AutofillRandomizedValue* release_id();
  ::autofill::AutofillRandomizedValue* mutable_id();
  void set_allocated_id(::autofill::AutofillRandomizedValue* id);
  private:
  const ::autofill::AutofillRandomizedValue& _internal_id() const;
  ::autofill::AutofillRandomizedValue* _internal_mutable_id();
  public:
  void unsafe_arena_set_allocated_id(
      ::autofill::AutofillRandomizedValue* id);
  ::autofill::AutofillRandomizedValue* unsafe_arena_release_id();

  // optional .autofill.AutofillRandomizedValue name = 2;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const ::autofill::AutofillRandomizedValue& name() const;
  PROTOBUF_NODISCARD ::autofill::AutofillRandomizedValue* release_name();
  ::autofill::AutofillRandomizedValue* mutable_name();
  void set_allocated_name(::autofill::AutofillRandomizedValue* name);
  private:
  const ::autofill::AutofillRandomizedValue& _internal_name() const;
  ::autofill::AutofillRandomizedValue* _internal_mutable_name();
  public:
  void unsafe_arena_set_allocated_name(
      ::autofill::AutofillRandomizedValue* name);
  ::autofill::AutofillRandomizedValue* unsafe_arena_release_name();

  // optional .autofill.AutofillRandomizedValue type = 3;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  const ::autofill::AutofillRandomizedValue& type() const;
  PROTOBUF_NODISCARD ::autofill::AutofillRandomizedValue* release_type();
  ::autofill::AutofillRandomizedValue* mutable_type();
  void set_allocated_type(::autofill::AutofillRandomizedValue* type);
  private:
  const ::autofill::AutofillRandomizedValue& _internal_type() const;
  ::autofill::AutofillRandomizedValue* _internal_mutable_type();
  public:
  void unsafe_arena_set_allocated_type(
      ::autofill::AutofillRandomizedValue* type);
  ::autofill::AutofillRandomizedValue* unsafe_arena_release_type();

  // optional .autofill.AutofillRandomizedValue label = 4;
  bool has_label() const;
  private:
  bool _internal_has_label() const;
  public:
  void clear_label();
  const ::autofill::AutofillRandomizedValue& label() const;
  PROTOBUF_NODISCARD ::autofill::AutofillRandomizedValue* release_label();
  ::autofill::AutofillRandomizedValue* mutable_label();
  void set_allocated_label(::autofill::AutofillRandomizedValue* label);
  private:
  const ::autofill::AutofillRandomizedValue& _internal_label() const;
  ::autofill::AutofillRandomizedValue* _internal_mutable_label();
  public:
  void unsafe_arena_set_allocated_label(
      ::autofill::AutofillRandomizedValue* label);
  ::autofill::AutofillRandomizedValue* unsafe_arena_release_label();

  // optional .autofill.AutofillRandomizedValue aria_label = 5;
  bool has_aria_label() const;
  private:
  bool _internal_has_aria_label() const;
  public:
  void clear_aria_label();
  const ::autofill::AutofillRandomizedValue& aria_label() const;
  PROTOBUF_NODISCARD ::autofill::AutofillRandomizedValue* release_aria_label();
  ::autofill::AutofillRandomizedValue* mutable_aria_label();
  void set_allocated_aria_label(::autofill::AutofillRandomizedValue* aria_label);
  private:
  const ::autofill::AutofillRandomizedValue& _internal_aria_label() const;
  ::autofill::AutofillRandomizedValue* _internal_mutable_aria_label();
  public:
  void unsafe_arena_set_allocated_aria_label(
      ::autofill::AutofillRandomizedValue* aria_label);
  ::autofill::AutofillRandomizedValue* unsafe_arena_release_aria_label();

  // optional .autofill.AutofillRandomizedValue aria_description = 6;
  bool has_aria_description() const;
  private:
  bool _internal_has_aria_description() const;
  public:
  void clear_aria_description();
  const ::autofill::AutofillRandomizedValue& aria_description() const;
  PROTOBUF_NODISCARD ::autofill::AutofillRandomizedValue* release_aria_description();
  ::autofill::AutofillRandomizedValue* mutable_aria_description();
  void set_allocated_aria_description(::autofill::AutofillRandomizedValue* aria_description);
  private:
  const ::autofill::AutofillRandomizedValue& _internal_aria_description() const;
  ::autofill::AutofillRandomizedValue* _internal_mutable_aria_description();
  public:
  void unsafe_arena_set_allocated_aria_description(
      ::autofill::AutofillRandomizedValue* aria_description);
  ::autofill::AutofillRandomizedValue* unsafe_arena_release_aria_description();

  // optional .autofill.AutofillRandomizedValue css_class = 7;
  bool has_css_class() const;
  private:
  bool _internal_has_css_class() const;
  public:
  void clear_css_class();
  const ::autofill::AutofillRandomizedValue& css_class() const;
  PROTOBUF_NODISCARD ::autofill::AutofillRandomizedValue* release_css_class();
  ::autofill::AutofillRandomizedValue* mutable_css_class();
  void set_allocated_css_class(::autofill::AutofillRandomizedValue* css_class);
  private:
  const ::autofill::AutofillRandomizedValue& _internal_css_class() const;
  ::autofill::AutofillRandomizedValue* _internal_mutable_css_class();
  public:
  void unsafe_arena_set_allocated_css_class(
      ::autofill::AutofillRandomizedValue* css_class);
  ::autofill::AutofillRandomizedValue* unsafe_arena_release_css_class();

  // optional .autofill.AutofillRandomizedValue placeholder = 8;
  bool has_placeholder() const;
  private:
  bool _internal_has_placeholder() const;
  public:
  void clear_placeholder();
  const ::autofill::AutofillRandomizedValue& placeholder() const;
  PROTOBUF_NODISCARD ::autofill::AutofillRandomizedValue* release_placeholder();
  ::autofill::AutofillRandomizedValue* mutable_placeholder();
  void set_allocated_placeholder(::autofill::AutofillRandomizedValue* placeholder);
  private:
  const ::autofill::AutofillRandomizedValue& _internal_placeholder() const;
  ::autofill::AutofillRandomizedValue* _internal_mutable_placeholder();
  public:
  void unsafe_arena_set_allocated_placeholder(
      ::autofill::AutofillRandomizedValue* placeholder);
  ::autofill::AutofillRandomizedValue* unsafe_arena_release_placeholder();

  // optional .autofill.AutofillRandomizedValue initial_value_hash = 9;
  bool has_initial_value_hash() const;
  private:
  bool _internal_has_initial_value_hash() const;
  public:
  void clear_initial_value_hash();
  const ::autofill::AutofillRandomizedValue& initial_value_hash() const;
  PROTOBUF_NODISCARD ::autofill::AutofillRandomizedValue* release_initial_value_hash();
  ::autofill::AutofillRandomizedValue* mutable_initial_value_hash();
  void set_allocated_initial_value_hash(::autofill::AutofillRandomizedValue* initial_value_hash);
  private:
  const ::autofill::AutofillRandomizedValue& _internal_initial_value_hash() const;
  ::autofill::AutofillRandomizedValue* _internal_mutable_initial_value_hash();
  public:
  void unsafe_arena_set_allocated_initial_value_hash(
      ::autofill::AutofillRandomizedValue* initial_value_hash);
  ::autofill::AutofillRandomizedValue* unsafe_arena_release_initial_value_hash();

  // optional .autofill.AutofillRandomizedValue autocomplete = 10;
  bool has_autocomplete() const;
  private:
  bool _internal_has_autocomplete() const;
  public:
  void clear_autocomplete();
  const ::autofill::AutofillRandomizedValue& autocomplete() const;
  PROTOBUF_NODISCARD ::autofill::AutofillRandomizedValue* release_autocomplete();
  ::autofill::AutofillRandomizedValue* mutable_autocomplete();
  void set_allocated_autocomplete(::autofill::AutofillRandomizedValue* autocomplete);
  private:
  const ::autofill::AutofillRandomizedValue& _internal_autocomplete() const;
  ::autofill::AutofillRandomizedValue* _internal_mutable_autocomplete();
  public:
  void unsafe_arena_set_allocated_autocomplete(
      ::autofill::AutofillRandomizedValue* autocomplete);
  ::autofill::AutofillRandomizedValue* unsafe_arena_release_autocomplete();

  // @@protoc_insertion_point(class_scope:autofill.AutofillRandomizedFieldMetadata)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::autofill::AutofillRandomizedValue* id_;
  ::autofill::AutofillRandomizedValue* name_;
  ::autofill::AutofillRandomizedValue* type_;
  ::autofill::AutofillRandomizedValue* label_;
  ::autofill::AutofillRandomizedValue* aria_label_;
  ::autofill::AutofillRandomizedValue* aria_description_;
  ::autofill::AutofillRandomizedValue* css_class_;
  ::autofill::AutofillRandomizedValue* placeholder_;
  ::autofill::AutofillRandomizedValue* initial_value_hash_;
  ::autofill::AutofillRandomizedValue* autocomplete_;
  friend struct ::TableStruct_server_2eproto;
};
// -------------------------------------------------------------------

class AutofillUploadContents_Field_AutofillTypeValiditiesPair final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill.AutofillUploadContents.Field.AutofillTypeValiditiesPair) */ {
 public:
  inline AutofillUploadContents_Field_AutofillTypeValiditiesPair() : AutofillUploadContents_Field_AutofillTypeValiditiesPair(nullptr) {}
  ~AutofillUploadContents_Field_AutofillTypeValiditiesPair() override;
  explicit PROTOBUF_CONSTEXPR AutofillUploadContents_Field_AutofillTypeValiditiesPair(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AutofillUploadContents_Field_AutofillTypeValiditiesPair(const AutofillUploadContents_Field_AutofillTypeValiditiesPair& from);
  AutofillUploadContents_Field_AutofillTypeValiditiesPair(AutofillUploadContents_Field_AutofillTypeValiditiesPair&& from) noexcept
    : AutofillUploadContents_Field_AutofillTypeValiditiesPair() {
    *this = ::std::move(from);
  }

  inline AutofillUploadContents_Field_AutofillTypeValiditiesPair& operator=(const AutofillUploadContents_Field_AutofillTypeValiditiesPair& from) {
    CopyFrom(from);
    return *this;
  }
  inline AutofillUploadContents_Field_AutofillTypeValiditiesPair& operator=(AutofillUploadContents_Field_AutofillTypeValiditiesPair&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const AutofillUploadContents_Field_AutofillTypeValiditiesPair& default_instance() {
    return *internal_default_instance();
  }
  static inline const AutofillUploadContents_Field_AutofillTypeValiditiesPair* internal_default_instance() {
    return reinterpret_cast<const AutofillUploadContents_Field_AutofillTypeValiditiesPair*>(
               &_AutofillUploadContents_Field_AutofillTypeValiditiesPair_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(AutofillUploadContents_Field_AutofillTypeValiditiesPair& a, AutofillUploadContents_Field_AutofillTypeValiditiesPair& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(AutofillUploadContents_Field_AutofillTypeValiditiesPair* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AutofillUploadContents_Field_AutofillTypeValiditiesPair* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AutofillUploadContents_Field_AutofillTypeValiditiesPair* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AutofillUploadContents_Field_AutofillTypeValiditiesPair>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const AutofillUploadContents_Field_AutofillTypeValiditiesPair& from);
  void MergeFrom(const AutofillUploadContents_Field_AutofillTypeValiditiesPair& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AutofillUploadContents_Field_AutofillTypeValiditiesPair* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill.AutofillUploadContents.Field.AutofillTypeValiditiesPair";
  }
  protected:
  explicit AutofillUploadContents_Field_AutofillTypeValiditiesPair(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValidityFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // repeated int32 validity = 2;
  int validity_size() const;
  private:
  int _internal_validity_size() const;
  public:
  void clear_validity();
  private:
  int32_t _internal_validity(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_validity() const;
  void _internal_add_validity(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_validity();
  public:
  int32_t validity(int index) const;
  void set_validity(int index, int32_t value);
  void add_validity(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      validity() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_validity();

  // required int32 type = 1;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  int32_t type() const;
  void set_type(int32_t value);
  private:
  int32_t _internal_type() const;
  void _internal_set_type(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:autofill.AutofillUploadContents.Field.AutofillTypeValiditiesPair)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > validity_;
  int32_t type_;
  friend struct ::TableStruct_server_2eproto;
};
// -------------------------------------------------------------------

class AutofillUploadContents_Field final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill.AutofillUploadContents.Field) */ {
 public:
  inline AutofillUploadContents_Field() : AutofillUploadContents_Field(nullptr) {}
  ~AutofillUploadContents_Field() override;
  explicit PROTOBUF_CONSTEXPR AutofillUploadContents_Field(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AutofillUploadContents_Field(const AutofillUploadContents_Field& from);
  AutofillUploadContents_Field(AutofillUploadContents_Field&& from) noexcept
    : AutofillUploadContents_Field() {
    *this = ::std::move(from);
  }

  inline AutofillUploadContents_Field& operator=(const AutofillUploadContents_Field& from) {
    CopyFrom(from);
    return *this;
  }
  inline AutofillUploadContents_Field& operator=(AutofillUploadContents_Field&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const AutofillUploadContents_Field& default_instance() {
    return *internal_default_instance();
  }
  static inline const AutofillUploadContents_Field* internal_default_instance() {
    return reinterpret_cast<const AutofillUploadContents_Field*>(
               &_AutofillUploadContents_Field_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(AutofillUploadContents_Field& a, AutofillUploadContents_Field& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(AutofillUploadContents_Field* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AutofillUploadContents_Field* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AutofillUploadContents_Field* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AutofillUploadContents_Field>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const AutofillUploadContents_Field& from);
  void MergeFrom(const AutofillUploadContents_Field& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AutofillUploadContents_Field* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill.AutofillUploadContents.Field";
  }
  protected:
  explicit AutofillUploadContents_Field(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef AutofillUploadContents_Field_AutofillTypeValiditiesPair AutofillTypeValiditiesPair;

  typedef AutofillUploadContents_Field_PasswordGenerationType PasswordGenerationType;
  static constexpr PasswordGenerationType NO_GENERATION =
    AutofillUploadContents_Field_PasswordGenerationType_NO_GENERATION;
  static constexpr PasswordGenerationType AUTOMATICALLY_TRIGGERED_GENERATION_ON_SIGN_UP_FORM =
    AutofillUploadContents_Field_PasswordGenerationType_AUTOMATICALLY_TRIGGERED_GENERATION_ON_SIGN_UP_FORM;
  static constexpr PasswordGenerationType AUTOMATICALLY_TRIGGERED_GENERATION_ON_CHANGE_PASSWORD_FORM =
    AutofillUploadContents_Field_PasswordGenerationType_AUTOMATICALLY_TRIGGERED_GENERATION_ON_CHANGE_PASSWORD_FORM;
  static constexpr PasswordGenerationType MANUALLY_TRIGGERED_GENERATION_ON_SIGN_UP_FORM =
    AutofillUploadContents_Field_PasswordGenerationType_MANUALLY_TRIGGERED_GENERATION_ON_SIGN_UP_FORM;
  static constexpr PasswordGenerationType MANUALLY_TRIGGERED_GENERATION_ON_CHANGE_PASSWORD_FORM =
    AutofillUploadContents_Field_PasswordGenerationType_MANUALLY_TRIGGERED_GENERATION_ON_CHANGE_PASSWORD_FORM;
  static constexpr PasswordGenerationType IGNORED_GENERATION_POPUP =
    AutofillUploadContents_Field_PasswordGenerationType_IGNORED_GENERATION_POPUP;
  static inline bool PasswordGenerationType_IsValid(int value) {
    return AutofillUploadContents_Field_PasswordGenerationType_IsValid(value);
  }
  static constexpr PasswordGenerationType PasswordGenerationType_MIN =
    AutofillUploadContents_Field_PasswordGenerationType_PasswordGenerationType_MIN;
  static constexpr PasswordGenerationType PasswordGenerationType_MAX =
    AutofillUploadContents_Field_PasswordGenerationType_PasswordGenerationType_MAX;
  static constexpr int PasswordGenerationType_ARRAYSIZE =
    AutofillUploadContents_Field_PasswordGenerationType_PasswordGenerationType_ARRAYSIZE;
  template<typename T>
  static inline const std::string& PasswordGenerationType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, PasswordGenerationType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function PasswordGenerationType_Name.");
    return AutofillUploadContents_Field_PasswordGenerationType_Name(enum_t_value);
  }
  static inline bool PasswordGenerationType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      PasswordGenerationType* value) {
    return AutofillUploadContents_Field_PasswordGenerationType_Parse(name, value);
  }

  typedef AutofillUploadContents_Field_VoteType VoteType;
  static constexpr VoteType NO_INFORMATION =
    AutofillUploadContents_Field_VoteType_NO_INFORMATION;
  static constexpr VoteType CREDENTIALS_REUSED =
    AutofillUploadContents_Field_VoteType_CREDENTIALS_REUSED;
  static constexpr VoteType USERNAME_OVERWRITTEN =
    AutofillUploadContents_Field_VoteType_USERNAME_OVERWRITTEN;
  static constexpr VoteType USERNAME_EDITED =
    AutofillUploadContents_Field_VoteType_USERNAME_EDITED;
  static constexpr VoteType BASE_HEURISTIC =
    AutofillUploadContents_Field_VoteType_BASE_HEURISTIC;
  static constexpr VoteType HTML_CLASSIFIER =
    AutofillUploadContents_Field_VoteType_HTML_CLASSIFIER;
  static constexpr VoteType FIRST_USE =
    AutofillUploadContents_Field_VoteType_FIRST_USE;
  static inline bool VoteType_IsValid(int value) {
    return AutofillUploadContents_Field_VoteType_IsValid(value);
  }
  static constexpr VoteType VoteType_MIN =
    AutofillUploadContents_Field_VoteType_VoteType_MIN;
  static constexpr VoteType VoteType_MAX =
    AutofillUploadContents_Field_VoteType_VoteType_MAX;
  static constexpr int VoteType_ARRAYSIZE =
    AutofillUploadContents_Field_VoteType_VoteType_ARRAYSIZE;
  template<typename T>
  static inline const std::string& VoteType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, VoteType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function VoteType_Name.");
    return AutofillUploadContents_Field_VoteType_Name(enum_t_value);
  }
  static inline bool VoteType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      VoteType* value) {
    return AutofillUploadContents_Field_VoteType_Parse(name, value);
  }

  typedef AutofillUploadContents_Field_SingleUsernameVoteType SingleUsernameVoteType;
  static constexpr SingleUsernameVoteType DEFAULT =
    AutofillUploadContents_Field_SingleUsernameVoteType_DEFAULT;
  static constexpr SingleUsernameVoteType WEAK =
    AutofillUploadContents_Field_SingleUsernameVoteType_WEAK;
  static constexpr SingleUsernameVoteType STRONG =
    AutofillUploadContents_Field_SingleUsernameVoteType_STRONG;
  static inline bool SingleUsernameVoteType_IsValid(int value) {
    return AutofillUploadContents_Field_SingleUsernameVoteType_IsValid(value);
  }
  static constexpr SingleUsernameVoteType SingleUsernameVoteType_MIN =
    AutofillUploadContents_Field_SingleUsernameVoteType_SingleUsernameVoteType_MIN;
  static constexpr SingleUsernameVoteType SingleUsernameVoteType_MAX =
    AutofillUploadContents_Field_SingleUsernameVoteType_SingleUsernameVoteType_MAX;
  static constexpr int SingleUsernameVoteType_ARRAYSIZE =
    AutofillUploadContents_Field_SingleUsernameVoteType_SingleUsernameVoteType_ARRAYSIZE;
  template<typename T>
  static inline const std::string& SingleUsernameVoteType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, SingleUsernameVoteType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function SingleUsernameVoteType_Name.");
    return AutofillUploadContents_Field_SingleUsernameVoteType_Name(enum_t_value);
  }
  static inline bool SingleUsernameVoteType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      SingleUsernameVoteType* value) {
    return AutofillUploadContents_Field_SingleUsernameVoteType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kAutofillTypeFieldNumber = 7,
    kAutofillTypeValiditiesFieldNumber = 35,
    kNameFieldNumber = 8,
    kAutocompleteFieldNumber = 9,
    kTypeFieldNumber = 10,
    kCssClassesFieldNumber = 19,
    kIdFieldNumber = 21,
    kRandomizedFieldMetadataFieldNumber = 33,
    kSignatureFieldNumber = 6,
    kGenerationTypeFieldNumber = 17,
    kPropertiesMaskFieldNumber = 20,
    kGeneratedPasswordChangedFieldNumber = 22,
    kVoteTypeFieldNumber = 23,
    kInitialValueHashFieldNumber = 40,
    kSingleUsernameVoteTypeFieldNumber = 41,
  };
  // repeated fixed32 autofill_type = 7;
  int autofill_type_size() const;
  private:
  int _internal_autofill_type_size() const;
  public:
  void clear_autofill_type();
  private:
  uint32_t _internal_autofill_type(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      _internal_autofill_type() const;
  void _internal_add_autofill_type(uint32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      _internal_mutable_autofill_type();
  public:
  uint32_t autofill_type(int index) const;
  void set_autofill_type(int index, uint32_t value);
  void add_autofill_type(uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      autofill_type() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      mutable_autofill_type();

  // repeated .autofill.AutofillUploadContents.Field.AutofillTypeValiditiesPair autofill_type_validities = 35 [deprecated = true];
  PROTOBUF_DEPRECATED int autofill_type_validities_size() const;
  private:
  int _internal_autofill_type_validities_size() const;
  public:
  PROTOBUF_DEPRECATED void clear_autofill_type_validities();
  PROTOBUF_DEPRECATED ::autofill::AutofillUploadContents_Field_AutofillTypeValiditiesPair* mutable_autofill_type_validities(int index);
  PROTOBUF_DEPRECATED ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill::AutofillUploadContents_Field_AutofillTypeValiditiesPair >*
      mutable_autofill_type_validities();
  private:
  const ::autofill::AutofillUploadContents_Field_AutofillTypeValiditiesPair& _internal_autofill_type_validities(int index) const;
  ::autofill::AutofillUploadContents_Field_AutofillTypeValiditiesPair* _internal_add_autofill_type_validities();
  public:
  PROTOBUF_DEPRECATED const ::autofill::AutofillUploadContents_Field_AutofillTypeValiditiesPair& autofill_type_validities(int index) const;
  PROTOBUF_DEPRECATED ::autofill::AutofillUploadContents_Field_AutofillTypeValiditiesPair* add_autofill_type_validities();
  PROTOBUF_DEPRECATED const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill::AutofillUploadContents_Field_AutofillTypeValiditiesPair >&
      autofill_type_validities() const;

  // optional string name = 8;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional string autocomplete = 9;
  bool has_autocomplete() const;
  private:
  bool _internal_has_autocomplete() const;
  public:
  void clear_autocomplete();
  const std::string& autocomplete() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_autocomplete(ArgT0&& arg0, ArgT... args);
  std::string* mutable_autocomplete();
  PROTOBUF_NODISCARD std::string* release_autocomplete();
  void set_allocated_autocomplete(std::string* autocomplete);
  private:
  const std::string& _internal_autocomplete() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_autocomplete(const std::string& value);
  std::string* _internal_mutable_autocomplete();
  public:

  // optional string type = 10;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  const std::string& type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* type);
  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // optional string css_classes = 19;
  bool has_css_classes() const;
  private:
  bool _internal_has_css_classes() const;
  public:
  void clear_css_classes();
  const std::string& css_classes() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_css_classes(ArgT0&& arg0, ArgT... args);
  std::string* mutable_css_classes();
  PROTOBUF_NODISCARD std::string* release_css_classes();
  void set_allocated_css_classes(std::string* css_classes);
  private:
  const std::string& _internal_css_classes() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_css_classes(const std::string& value);
  std::string* _internal_mutable_css_classes();
  public:

  // optional string id = 21;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // optional .autofill.AutofillRandomizedFieldMetadata randomized_field_metadata = 33;
  bool has_randomized_field_metadata() const;
  private:
  bool _internal_has_randomized_field_metadata() const;
  public:
  void clear_randomized_field_metadata();
  const ::autofill::AutofillRandomizedFieldMetadata& randomized_field_metadata() const;
  PROTOBUF_NODISCARD ::autofill::AutofillRandomizedFieldMetadata* release_randomized_field_metadata();
  ::autofill::AutofillRandomizedFieldMetadata* mutable_randomized_field_metadata();
  void set_allocated_randomized_field_metadata(::autofill::AutofillRandomizedFieldMetadata* randomized_field_metadata);
  private:
  const ::autofill::AutofillRandomizedFieldMetadata& _internal_randomized_field_metadata() const;
  ::autofill::AutofillRandomizedFieldMetadata* _internal_mutable_randomized_field_metadata();
  public:
  void unsafe_arena_set_allocated_randomized_field_metadata(
      ::autofill::AutofillRandomizedFieldMetadata* randomized_field_metadata);
  ::autofill::AutofillRandomizedFieldMetadata* unsafe_arena_release_randomized_field_metadata();

  // required fixed32 signature = 6;
  bool has_signature() const;
  private:
  bool _internal_has_signature() const;
  public:
  void clear_signature();
  uint32_t signature() const;
  void set_signature(uint32_t value);
  private:
  uint32_t _internal_signature() const;
  void _internal_set_signature(uint32_t value);
  public:

  // optional .autofill.AutofillUploadContents.Field.PasswordGenerationType generation_type = 17;
  bool has_generation_type() const;
  private:
  bool _internal_has_generation_type() const;
  public:
  void clear_generation_type();
  ::autofill::AutofillUploadContents_Field_PasswordGenerationType generation_type() const;
  void set_generation_type(::autofill::AutofillUploadContents_Field_PasswordGenerationType value);
  private:
  ::autofill::AutofillUploadContents_Field_PasswordGenerationType _internal_generation_type() const;
  void _internal_set_generation_type(::autofill::AutofillUploadContents_Field_PasswordGenerationType value);
  public:

  // optional uint32 properties_mask = 20;
  bool has_properties_mask() const;
  private:
  bool _internal_has_properties_mask() const;
  public:
  void clear_properties_mask();
  uint32_t properties_mask() const;
  void set_properties_mask(uint32_t value);
  private:
  uint32_t _internal_properties_mask() const;
  void _internal_set_properties_mask(uint32_t value);
  public:

  // optional bool generated_password_changed = 22;
  bool has_generated_password_changed() const;
  private:
  bool _internal_has_generated_password_changed() const;
  public:
  void clear_generated_password_changed();
  bool generated_password_changed() const;
  void set_generated_password_changed(bool value);
  private:
  bool _internal_generated_password_changed() const;
  void _internal_set_generated_password_changed(bool value);
  public:

  // optional .autofill.AutofillUploadContents.Field.VoteType vote_type = 23;
  bool has_vote_type() const;
  private:
  bool _internal_has_vote_type() const;
  public:
  void clear_vote_type();
  ::autofill::AutofillUploadContents_Field_VoteType vote_type() const;
  void set_vote_type(::autofill::AutofillUploadContents_Field_VoteType value);
  private:
  ::autofill::AutofillUploadContents_Field_VoteType _internal_vote_type() const;
  void _internal_set_vote_type(::autofill::AutofillUploadContents_Field_VoteType value);
  public:

  // optional uint32 initial_value_hash = 40;
  bool has_initial_value_hash() const;
  private:
  bool _internal_has_initial_value_hash() const;
  public:
  void clear_initial_value_hash();
  uint32_t initial_value_hash() const;
  void set_initial_value_hash(uint32_t value);
  private:
  uint32_t _internal_initial_value_hash() const;
  void _internal_set_initial_value_hash(uint32_t value);
  public:

  // optional .autofill.AutofillUploadContents.Field.SingleUsernameVoteType single_username_vote_type = 41;
  bool has_single_username_vote_type() const;
  private:
  bool _internal_has_single_username_vote_type() const;
  public:
  void clear_single_username_vote_type();
  ::autofill::AutofillUploadContents_Field_SingleUsernameVoteType single_username_vote_type() const;
  void set_single_username_vote_type(::autofill::AutofillUploadContents_Field_SingleUsernameVoteType value);
  private:
  ::autofill::AutofillUploadContents_Field_SingleUsernameVoteType _internal_single_username_vote_type() const;
  void _internal_set_single_username_vote_type(::autofill::AutofillUploadContents_Field_SingleUsernameVoteType value);
  public:

  // @@protoc_insertion_point(class_scope:autofill.AutofillUploadContents.Field)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t > autofill_type_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill::AutofillUploadContents_Field_AutofillTypeValiditiesPair > autofill_type_validities_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr autocomplete_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr css_classes_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::autofill::AutofillRandomizedFieldMetadata* randomized_field_metadata_;
  uint32_t signature_;
  int generation_type_;
  uint32_t properties_mask_;
  bool generated_password_changed_;
  int vote_type_;
  uint32_t initial_value_hash_;
  int single_username_vote_type_;
  friend struct ::TableStruct_server_2eproto;
};
// -------------------------------------------------------------------

class AutofillUploadContents_ButtonTitle final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill.AutofillUploadContents.ButtonTitle) */ {
 public:
  inline AutofillUploadContents_ButtonTitle() : AutofillUploadContents_ButtonTitle(nullptr) {}
  ~AutofillUploadContents_ButtonTitle() override;
  explicit PROTOBUF_CONSTEXPR AutofillUploadContents_ButtonTitle(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AutofillUploadContents_ButtonTitle(const AutofillUploadContents_ButtonTitle& from);
  AutofillUploadContents_ButtonTitle(AutofillUploadContents_ButtonTitle&& from) noexcept
    : AutofillUploadContents_ButtonTitle() {
    *this = ::std::move(from);
  }

  inline AutofillUploadContents_ButtonTitle& operator=(const AutofillUploadContents_ButtonTitle& from) {
    CopyFrom(from);
    return *this;
  }
  inline AutofillUploadContents_ButtonTitle& operator=(AutofillUploadContents_ButtonTitle&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const AutofillUploadContents_ButtonTitle& default_instance() {
    return *internal_default_instance();
  }
  static inline const AutofillUploadContents_ButtonTitle* internal_default_instance() {
    return reinterpret_cast<const AutofillUploadContents_ButtonTitle*>(
               &_AutofillUploadContents_ButtonTitle_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(AutofillUploadContents_ButtonTitle& a, AutofillUploadContents_ButtonTitle& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(AutofillUploadContents_ButtonTitle* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AutofillUploadContents_ButtonTitle* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AutofillUploadContents_ButtonTitle* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AutofillUploadContents_ButtonTitle>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const AutofillUploadContents_ButtonTitle& from);
  void MergeFrom(const AutofillUploadContents_ButtonTitle& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AutofillUploadContents_ButtonTitle* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill.AutofillUploadContents.ButtonTitle";
  }
  protected:
  explicit AutofillUploadContents_ButtonTitle(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTitleFieldNumber = 1,
    kTypeFieldNumber = 2,
  };
  // optional string title = 1;
  bool has_title() const;
  private:
  bool _internal_has_title() const;
  public:
  void clear_title();
  const std::string& title() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_title(ArgT0&& arg0, ArgT... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* title);
  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(const std::string& value);
  std::string* _internal_mutable_title();
  public:

  // optional .autofill.ButtonTitleType type = 2;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::autofill::ButtonTitleType type() const;
  void set_type(::autofill::ButtonTitleType value);
  private:
  ::autofill::ButtonTitleType _internal_type() const;
  void _internal_set_type(::autofill::ButtonTitleType value);
  public:

  // @@protoc_insertion_point(class_scope:autofill.AutofillUploadContents.ButtonTitle)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_;
  int type_;
  friend struct ::TableStruct_server_2eproto;
};
// -------------------------------------------------------------------

class AutofillUploadContents_SingleUsernameData final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill.AutofillUploadContents.SingleUsernameData) */ {
 public:
  inline AutofillUploadContents_SingleUsernameData() : AutofillUploadContents_SingleUsernameData(nullptr) {}
  ~AutofillUploadContents_SingleUsernameData() override;
  explicit PROTOBUF_CONSTEXPR AutofillUploadContents_SingleUsernameData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AutofillUploadContents_SingleUsernameData(const AutofillUploadContents_SingleUsernameData& from);
  AutofillUploadContents_SingleUsernameData(AutofillUploadContents_SingleUsernameData&& from) noexcept
    : AutofillUploadContents_SingleUsernameData() {
    *this = ::std::move(from);
  }

  inline AutofillUploadContents_SingleUsernameData& operator=(const AutofillUploadContents_SingleUsernameData& from) {
    CopyFrom(from);
    return *this;
  }
  inline AutofillUploadContents_SingleUsernameData& operator=(AutofillUploadContents_SingleUsernameData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const AutofillUploadContents_SingleUsernameData& default_instance() {
    return *internal_default_instance();
  }
  static inline const AutofillUploadContents_SingleUsernameData* internal_default_instance() {
    return reinterpret_cast<const AutofillUploadContents_SingleUsernameData*>(
               &_AutofillUploadContents_SingleUsernameData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(AutofillUploadContents_SingleUsernameData& a, AutofillUploadContents_SingleUsernameData& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(AutofillUploadContents_SingleUsernameData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AutofillUploadContents_SingleUsernameData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AutofillUploadContents_SingleUsernameData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AutofillUploadContents_SingleUsernameData>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const AutofillUploadContents_SingleUsernameData& from);
  void MergeFrom(const AutofillUploadContents_SingleUsernameData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AutofillUploadContents_SingleUsernameData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill.AutofillUploadContents.SingleUsernameData";
  }
  protected:
  explicit AutofillUploadContents_SingleUsernameData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUsernameFormSignatureFieldNumber = 1,
    kUsernameFieldSignatureFieldNumber = 2,
    kValueTypeFieldNumber = 3,
    kPromptEditFieldNumber = 4,
  };
  // optional fixed64 username_form_signature = 1;
  bool has_username_form_signature() const;
  private:
  bool _internal_has_username_form_signature() const;
  public:
  void clear_username_form_signature();
  uint64_t username_form_signature() const;
  void set_username_form_signature(uint64_t value);
  private:
  uint64_t _internal_username_form_signature() const;
  void _internal_set_username_form_signature(uint64_t value);
  public:

  // optional fixed32 username_field_signature = 2;
  bool has_username_field_signature() const;
  private:
  bool _internal_has_username_field_signature() const;
  public:
  void clear_username_field_signature();
  uint32_t username_field_signature() const;
  void set_username_field_signature(uint32_t value);
  private:
  uint32_t _internal_username_field_signature() const;
  void _internal_set_username_field_signature(uint32_t value);
  public:

  // optional .autofill.AutofillUploadContents.ValueType value_type = 3;
  bool has_value_type() const;
  private:
  bool _internal_has_value_type() const;
  public:
  void clear_value_type();
  ::autofill::AutofillUploadContents_ValueType value_type() const;
  void set_value_type(::autofill::AutofillUploadContents_ValueType value);
  private:
  ::autofill::AutofillUploadContents_ValueType _internal_value_type() const;
  void _internal_set_value_type(::autofill::AutofillUploadContents_ValueType value);
  public:

  // optional .autofill.AutofillUploadContents.SingleUsernamePromptEdit prompt_edit = 4;
  bool has_prompt_edit() const;
  private:
  bool _internal_has_prompt_edit() const;
  public:
  void clear_prompt_edit();
  ::autofill::AutofillUploadContents_SingleUsernamePromptEdit prompt_edit() const;
  void set_prompt_edit(::autofill::AutofillUploadContents_SingleUsernamePromptEdit value);
  private:
  ::autofill::AutofillUploadContents_SingleUsernamePromptEdit _internal_prompt_edit() const;
  void _internal_set_prompt_edit(::autofill::AutofillUploadContents_SingleUsernamePromptEdit value);
  public:

  // @@protoc_insertion_point(class_scope:autofill.AutofillUploadContents.SingleUsernameData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint64_t username_form_signature_;
  uint32_t username_field_signature_;
  int value_type_;
  int prompt_edit_;
  friend struct ::TableStruct_server_2eproto;
};
// -------------------------------------------------------------------

class AutofillUploadContents final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill.AutofillUploadContents) */ {
 public:
  inline AutofillUploadContents() : AutofillUploadContents(nullptr) {}
  ~AutofillUploadContents() override;
  explicit PROTOBUF_CONSTEXPR AutofillUploadContents(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AutofillUploadContents(const AutofillUploadContents& from);
  AutofillUploadContents(AutofillUploadContents&& from) noexcept
    : AutofillUploadContents() {
    *this = ::std::move(from);
  }

  inline AutofillUploadContents& operator=(const AutofillUploadContents& from) {
    CopyFrom(from);
    return *this;
  }
  inline AutofillUploadContents& operator=(AutofillUploadContents&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const AutofillUploadContents& default_instance() {
    return *internal_default_instance();
  }
  static inline const AutofillUploadContents* internal_default_instance() {
    return reinterpret_cast<const AutofillUploadContents*>(
               &_AutofillUploadContents_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(AutofillUploadContents& a, AutofillUploadContents& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(AutofillUploadContents* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AutofillUploadContents* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AutofillUploadContents* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AutofillUploadContents>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const AutofillUploadContents& from);
  void MergeFrom(const AutofillUploadContents& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AutofillUploadContents* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill.AutofillUploadContents";
  }
  protected:
  explicit AutofillUploadContents(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef AutofillUploadContents_Field Field;
  typedef AutofillUploadContents_ButtonTitle ButtonTitle;
  typedef AutofillUploadContents_SingleUsernameData SingleUsernameData;

  typedef AutofillUploadContents_SubmissionIndicatorEvent SubmissionIndicatorEvent;
  static constexpr SubmissionIndicatorEvent NONE =
    AutofillUploadContents_SubmissionIndicatorEvent_NONE;
  static constexpr SubmissionIndicatorEvent HTML_FORM_SUBMISSION =
    AutofillUploadContents_SubmissionIndicatorEvent_HTML_FORM_SUBMISSION;
  static constexpr SubmissionIndicatorEvent SAME_DOCUMENT_NAVIGATION =
    AutofillUploadContents_SubmissionIndicatorEvent_SAME_DOCUMENT_NAVIGATION;
  static constexpr SubmissionIndicatorEvent XHR_SUCCEEDED =
    AutofillUploadContents_SubmissionIndicatorEvent_XHR_SUCCEEDED;
  static constexpr SubmissionIndicatorEvent FRAME_DETACHED =
    AutofillUploadContents_SubmissionIndicatorEvent_FRAME_DETACHED;
  static constexpr SubmissionIndicatorEvent DEPRECATED_MANUAL_SAVE =
    AutofillUploadContents_SubmissionIndicatorEvent_DEPRECATED_MANUAL_SAVE;
  static constexpr SubmissionIndicatorEvent DOM_MUTATION_AFTER_XHR =
    AutofillUploadContents_SubmissionIndicatorEvent_DOM_MUTATION_AFTER_XHR;
  static constexpr SubmissionIndicatorEvent PROVISIONALLY_SAVED_FORM_ON_START_PROVISIONAL_LOAD =
    AutofillUploadContents_SubmissionIndicatorEvent_PROVISIONALLY_SAVED_FORM_ON_START_PROVISIONAL_LOAD;
  static constexpr SubmissionIndicatorEvent DEPRECATED_FILLED_FORM_ON_START_PROVISIONAL_LOAD =
    AutofillUploadContents_SubmissionIndicatorEvent_DEPRECATED_FILLED_FORM_ON_START_PROVISIONAL_LOAD;
  static constexpr SubmissionIndicatorEvent DEPRECATED_FILLED_INPUT_ELEMENTS_ON_START_PROVISIONAL_LOAD =
    AutofillUploadContents_SubmissionIndicatorEvent_DEPRECATED_FILLED_INPUT_ELEMENTS_ON_START_PROVISIONAL_LOAD;
  static constexpr SubmissionIndicatorEvent PROBABLE_FORM_SUBMISSION =
    AutofillUploadContents_SubmissionIndicatorEvent_PROBABLE_FORM_SUBMISSION;
  static constexpr SubmissionIndicatorEvent CHANGE_PASSWORD_FORM_CLEARED =
    AutofillUploadContents_SubmissionIndicatorEvent_CHANGE_PASSWORD_FORM_CLEARED;
  static inline bool SubmissionIndicatorEvent_IsValid(int value) {
    return AutofillUploadContents_SubmissionIndicatorEvent_IsValid(value);
  }
  static constexpr SubmissionIndicatorEvent SubmissionIndicatorEvent_MIN =
    AutofillUploadContents_SubmissionIndicatorEvent_SubmissionIndicatorEvent_MIN;
  static constexpr SubmissionIndicatorEvent SubmissionIndicatorEvent_MAX =
    AutofillUploadContents_SubmissionIndicatorEvent_SubmissionIndicatorEvent_MAX;
  static constexpr int SubmissionIndicatorEvent_ARRAYSIZE =
    AutofillUploadContents_SubmissionIndicatorEvent_SubmissionIndicatorEvent_ARRAYSIZE;
  template<typename T>
  static inline const std::string& SubmissionIndicatorEvent_Name(T enum_t_value) {
    static_assert(::std::is_same<T, SubmissionIndicatorEvent>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function SubmissionIndicatorEvent_Name.");
    return AutofillUploadContents_SubmissionIndicatorEvent_Name(enum_t_value);
  }
  static inline bool SubmissionIndicatorEvent_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      SubmissionIndicatorEvent* value) {
    return AutofillUploadContents_SubmissionIndicatorEvent_Parse(name, value);
  }

  typedef AutofillUploadContents_ValueType ValueType;
  static constexpr ValueType TYPE_UNSPECIFIED =
    AutofillUploadContents_ValueType_TYPE_UNSPECIFIED;
  static constexpr ValueType NO_VALUE_TYPE =
    AutofillUploadContents_ValueType_NO_VALUE_TYPE;
  static constexpr ValueType STORED_FOR_CURRENT_DOMAIN =
    AutofillUploadContents_ValueType_STORED_FOR_CURRENT_DOMAIN;
  static constexpr ValueType STORED_FOR_ANOTHER_DOMAIN =
    AutofillUploadContents_ValueType_STORED_FOR_ANOTHER_DOMAIN;
  static constexpr ValueType EMAIL =
    AutofillUploadContents_ValueType_EMAIL;
  static constexpr ValueType PHONE =
    AutofillUploadContents_ValueType_PHONE;
  static constexpr ValueType USERNAME_LIKE =
    AutofillUploadContents_ValueType_USERNAME_LIKE;
  static constexpr ValueType VALUE_WITH_NO_WHITESPACE =
    AutofillUploadContents_ValueType_VALUE_WITH_NO_WHITESPACE;
  static constexpr ValueType VALUE_WITH_WHITESPACE =
    AutofillUploadContents_ValueType_VALUE_WITH_WHITESPACE;
  static inline bool ValueType_IsValid(int value) {
    return AutofillUploadContents_ValueType_IsValid(value);
  }
  static constexpr ValueType ValueType_MIN =
    AutofillUploadContents_ValueType_ValueType_MIN;
  static constexpr ValueType ValueType_MAX =
    AutofillUploadContents_ValueType_ValueType_MAX;
  static constexpr int ValueType_ARRAYSIZE =
    AutofillUploadContents_ValueType_ValueType_ARRAYSIZE;
  template<typename T>
  static inline const std::string& ValueType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ValueType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ValueType_Name.");
    return AutofillUploadContents_ValueType_Name(enum_t_value);
  }
  static inline bool ValueType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ValueType* value) {
    return AutofillUploadContents_ValueType_Parse(name, value);
  }

  typedef AutofillUploadContents_SingleUsernamePromptEdit SingleUsernamePromptEdit;
  static constexpr SingleUsernamePromptEdit EDIT_UNSPECIFIED =
    AutofillUploadContents_SingleUsernamePromptEdit_EDIT_UNSPECIFIED;
  static constexpr SingleUsernamePromptEdit NOT_EDITED_POSITIVE =
    AutofillUploadContents_SingleUsernamePromptEdit_NOT_EDITED_POSITIVE;
  static constexpr SingleUsernamePromptEdit NOT_EDITED_NEGATIVE =
    AutofillUploadContents_SingleUsernamePromptEdit_NOT_EDITED_NEGATIVE;
  static constexpr SingleUsernamePromptEdit EDITED_POSITIVE =
    AutofillUploadContents_SingleUsernamePromptEdit_EDITED_POSITIVE;
  static constexpr SingleUsernamePromptEdit EDITED_NEGATIVE =
    AutofillUploadContents_SingleUsernamePromptEdit_EDITED_NEGATIVE;
  static inline bool SingleUsernamePromptEdit_IsValid(int value) {
    return AutofillUploadContents_SingleUsernamePromptEdit_IsValid(value);
  }
  static constexpr SingleUsernamePromptEdit SingleUsernamePromptEdit_MIN =
    AutofillUploadContents_SingleUsernamePromptEdit_SingleUsernamePromptEdit_MIN;
  static constexpr SingleUsernamePromptEdit SingleUsernamePromptEdit_MAX =
    AutofillUploadContents_SingleUsernamePromptEdit_SingleUsernamePromptEdit_MAX;
  static constexpr int SingleUsernamePromptEdit_ARRAYSIZE =
    AutofillUploadContents_SingleUsernamePromptEdit_SingleUsernamePromptEdit_ARRAYSIZE;
  template<typename T>
  static inline const std::string& SingleUsernamePromptEdit_Name(T enum_t_value) {
    static_assert(::std::is_same<T, SingleUsernamePromptEdit>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function SingleUsernamePromptEdit_Name.");
    return AutofillUploadContents_SingleUsernamePromptEdit_Name(enum_t_value);
  }
  static inline bool SingleUsernamePromptEdit_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      SingleUsernamePromptEdit* value) {
    return AutofillUploadContents_SingleUsernamePromptEdit_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kFieldFieldNumber = 5,
    kButtonTitleFieldNumber = 36,
    kClientVersionFieldNumber = 1,
    kDataPresentFieldNumber = 4,
    kFormNameFieldNumber = 16,
    kLanguageFieldNumber = 31,
    kRandomizedFormMetadataFieldNumber = 32,
    kSingleUsernameDataFieldNumber = 42,
    kFormSignatureFieldNumber = 2,
    kActionSignatureFieldNumber = 13,
    kLoginFormSignatureFieldNumber = 14,
    kAutofillUsedFieldNumber = 3,
    kSubmissionFieldNumber = 15,
    kPasswordsRevealedFieldNumber = 24,
    kPasswordHasLowercaseLetterFieldNumber = 25,
    kPasswordLengthFieldNumber = 29,
    kPasswordHasUppercaseLetterFieldNumber = 26,
    kPasswordHasNumericFieldNumber = 27,
    kPasswordHasSpecialSymbolFieldNumber = 28,
    kHasFormTagFieldNumber = 37,
    kSubmissionEventFieldNumber = 30,
    kSecondaryFormSignatureFieldNumber = 34,
    kWasThrottleableFieldNumber = 38,
    kPasswordSpecialSymbolFieldNumber = 39,
  };
  // repeated group Field = 5 { ... };
  int field_size() const;
  private:
  int _internal_field_size() const;
  public:
  void clear_field();
  ::autofill::AutofillUploadContents_Field* mutable_field(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill::AutofillUploadContents_Field >*
      mutable_field();
  private:
  const ::autofill::AutofillUploadContents_Field& _internal_field(int index) const;
  ::autofill::AutofillUploadContents_Field* _internal_add_field();
  public:
  const ::autofill::AutofillUploadContents_Field& field(int index) const;
  ::autofill::AutofillUploadContents_Field* add_field();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill::AutofillUploadContents_Field >&
      field() const;

  // repeated .autofill.AutofillUploadContents.ButtonTitle button_title = 36;
  int button_title_size() const;
  private:
  int _internal_button_title_size() const;
  public:
  void clear_button_title();
  ::autofill::AutofillUploadContents_ButtonTitle* mutable_button_title(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill::AutofillUploadContents_ButtonTitle >*
      mutable_button_title();
  private:
  const ::autofill::AutofillUploadContents_ButtonTitle& _internal_button_title(int index) const;
  ::autofill::AutofillUploadContents_ButtonTitle* _internal_add_button_title();
  public:
  const ::autofill::AutofillUploadContents_ButtonTitle& button_title(int index) const;
  ::autofill::AutofillUploadContents_ButtonTitle* add_button_title();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill::AutofillUploadContents_ButtonTitle >&
      button_title() const;

  // required string client_version = 1;
  bool has_client_version() const;
  private:
  bool _internal_has_client_version() const;
  public:
  void clear_client_version();
  const std::string& client_version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_client_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_client_version();
  PROTOBUF_NODISCARD std::string* release_client_version();
  void set_allocated_client_version(std::string* client_version);
  private:
  const std::string& _internal_client_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_client_version(const std::string& value);
  std::string* _internal_mutable_client_version();
  public:

  // required string data_present = 4;
  bool has_data_present() const;
  private:
  bool _internal_has_data_present() const;
  public:
  void clear_data_present();
  const std::string& data_present() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data_present(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data_present();
  PROTOBUF_NODISCARD std::string* release_data_present();
  void set_allocated_data_present(std::string* data_present);
  private:
  const std::string& _internal_data_present() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data_present(const std::string& value);
  std::string* _internal_mutable_data_present();
  public:

  // optional string form_name = 16;
  bool has_form_name() const;
  private:
  bool _internal_has_form_name() const;
  public:
  void clear_form_name();
  const std::string& form_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_form_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_form_name();
  PROTOBUF_NODISCARD std::string* release_form_name();
  void set_allocated_form_name(std::string* form_name);
  private:
  const std::string& _internal_form_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_form_name(const std::string& value);
  std::string* _internal_mutable_form_name();
  public:

  // optional string language = 31;
  bool has_language() const;
  private:
  bool _internal_has_language() const;
  public:
  void clear_language();
  const std::string& language() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_language(ArgT0&& arg0, ArgT... args);
  std::string* mutable_language();
  PROTOBUF_NODISCARD std::string* release_language();
  void set_allocated_language(std::string* language);
  private:
  const std::string& _internal_language() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_language(const std::string& value);
  std::string* _internal_mutable_language();
  public:

  // optional .autofill.AutofillRandomizedFormMetadata randomized_form_metadata = 32;
  bool has_randomized_form_metadata() const;
  private:
  bool _internal_has_randomized_form_metadata() const;
  public:
  void clear_randomized_form_metadata();
  const ::autofill::AutofillRandomizedFormMetadata& randomized_form_metadata() const;
  PROTOBUF_NODISCARD ::autofill::AutofillRandomizedFormMetadata* release_randomized_form_metadata();
  ::autofill::AutofillRandomizedFormMetadata* mutable_randomized_form_metadata();
  void set_allocated_randomized_form_metadata(::autofill::AutofillRandomizedFormMetadata* randomized_form_metadata);
  private:
  const ::autofill::AutofillRandomizedFormMetadata& _internal_randomized_form_metadata() const;
  ::autofill::AutofillRandomizedFormMetadata* _internal_mutable_randomized_form_metadata();
  public:
  void unsafe_arena_set_allocated_randomized_form_metadata(
      ::autofill::AutofillRandomizedFormMetadata* randomized_form_metadata);
  ::autofill::AutofillRandomizedFormMetadata* unsafe_arena_release_randomized_form_metadata();

  // optional .autofill.AutofillUploadContents.SingleUsernameData single_username_data = 42;
  bool has_single_username_data() const;
  private:
  bool _internal_has_single_username_data() const;
  public:
  void clear_single_username_data();
  const ::autofill::AutofillUploadContents_SingleUsernameData& single_username_data() const;
  PROTOBUF_NODISCARD ::autofill::AutofillUploadContents_SingleUsernameData* release_single_username_data();
  ::autofill::AutofillUploadContents_SingleUsernameData* mutable_single_username_data();
  void set_allocated_single_username_data(::autofill::AutofillUploadContents_SingleUsernameData* single_username_data);
  private:
  const ::autofill::AutofillUploadContents_SingleUsernameData& _internal_single_username_data() const;
  ::autofill::AutofillUploadContents_SingleUsernameData* _internal_mutable_single_username_data();
  public:
  void unsafe_arena_set_allocated_single_username_data(
      ::autofill::AutofillUploadContents_SingleUsernameData* single_username_data);
  ::autofill::AutofillUploadContents_SingleUsernameData* unsafe_arena_release_single_username_data();

  // required fixed64 form_signature = 2;
  bool has_form_signature() const;
  private:
  bool _internal_has_form_signature() const;
  public:
  void clear_form_signature();
  uint64_t form_signature() const;
  void set_form_signature(uint64_t value);
  private:
  uint64_t _internal_form_signature() const;
  void _internal_set_form_signature(uint64_t value);
  public:

  // optional fixed64 action_signature = 13;
  bool has_action_signature() const;
  private:
  bool _internal_has_action_signature() const;
  public:
  void clear_action_signature();
  uint64_t action_signature() const;
  void set_action_signature(uint64_t value);
  private:
  uint64_t _internal_action_signature() const;
  void _internal_set_action_signature(uint64_t value);
  public:

  // optional fixed64 login_form_signature = 14;
  bool has_login_form_signature() const;
  private:
  bool _internal_has_login_form_signature() const;
  public:
  void clear_login_form_signature();
  uint64_t login_form_signature() const;
  void set_login_form_signature(uint64_t value);
  private:
  uint64_t _internal_login_form_signature() const;
  void _internal_set_login_form_signature(uint64_t value);
  public:

  // required bool autofill_used = 3;
  bool has_autofill_used() const;
  private:
  bool _internal_has_autofill_used() const;
  public:
  void clear_autofill_used();
  bool autofill_used() const;
  void set_autofill_used(bool value);
  private:
  bool _internal_autofill_used() const;
  void _internal_set_autofill_used(bool value);
  public:

  // optional bool submission = 15;
  bool has_submission() const;
  private:
  bool _internal_has_submission() const;
  public:
  void clear_submission();
  bool submission() const;
  void set_submission(bool value);
  private:
  bool _internal_submission() const;
  void _internal_set_submission(bool value);
  public:

  // optional bool passwords_revealed = 24;
  bool has_passwords_revealed() const;
  private:
  bool _internal_has_passwords_revealed() const;
  public:
  void clear_passwords_revealed();
  bool passwords_revealed() const;
  void set_passwords_revealed(bool value);
  private:
  bool _internal_passwords_revealed() const;
  void _internal_set_passwords_revealed(bool value);
  public:

  // optional bool password_has_lowercase_letter = 25;
  bool has_password_has_lowercase_letter() const;
  private:
  bool _internal_has_password_has_lowercase_letter() const;
  public:
  void clear_password_has_lowercase_letter();
  bool password_has_lowercase_letter() const;
  void set_password_has_lowercase_letter(bool value);
  private:
  bool _internal_password_has_lowercase_letter() const;
  void _internal_set_password_has_lowercase_letter(bool value);
  public:

  // optional uint32 password_length = 29;
  bool has_password_length() const;
  private:
  bool _internal_has_password_length() const;
  public:
  void clear_password_length();
  uint32_t password_length() const;
  void set_password_length(uint32_t value);
  private:
  uint32_t _internal_password_length() const;
  void _internal_set_password_length(uint32_t value);
  public:

  // optional bool password_has_uppercase_letter = 26 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_password_has_uppercase_letter() const;
  private:
  bool _internal_has_password_has_uppercase_letter() const;
  public:
  PROTOBUF_DEPRECATED void clear_password_has_uppercase_letter();
  PROTOBUF_DEPRECATED bool password_has_uppercase_letter() const;
  PROTOBUF_DEPRECATED void set_password_has_uppercase_letter(bool value);
  private:
  bool _internal_password_has_uppercase_letter() const;
  void _internal_set_password_has_uppercase_letter(bool value);
  public:

  // optional bool password_has_numeric = 27 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_password_has_numeric() const;
  private:
  bool _internal_has_password_has_numeric() const;
  public:
  PROTOBUF_DEPRECATED void clear_password_has_numeric();
  PROTOBUF_DEPRECATED bool password_has_numeric() const;
  PROTOBUF_DEPRECATED void set_password_has_numeric(bool value);
  private:
  bool _internal_password_has_numeric() const;
  void _internal_set_password_has_numeric(bool value);
  public:

  // optional bool password_has_special_symbol = 28;
  bool has_password_has_special_symbol() const;
  private:
  bool _internal_has_password_has_special_symbol() const;
  public:
  void clear_password_has_special_symbol();
  bool password_has_special_symbol() const;
  void set_password_has_special_symbol(bool value);
  private:
  bool _internal_password_has_special_symbol() const;
  void _internal_set_password_has_special_symbol(bool value);
  public:

  // optional bool has_form_tag = 37;
  bool has_has_form_tag() const;
  private:
  bool _internal_has_has_form_tag() const;
  public:
  void clear_has_form_tag();
  bool has_form_tag() const;
  void set_has_form_tag(bool value);
  private:
  bool _internal_has_form_tag() const;
  void _internal_set_has_form_tag(bool value);
  public:

  // optional .autofill.AutofillUploadContents.SubmissionIndicatorEvent submission_event = 30;
  bool has_submission_event() const;
  private:
  bool _internal_has_submission_event() const;
  public:
  void clear_submission_event();
  ::autofill::AutofillUploadContents_SubmissionIndicatorEvent submission_event() const;
  void set_submission_event(::autofill::AutofillUploadContents_SubmissionIndicatorEvent value);
  private:
  ::autofill::AutofillUploadContents_SubmissionIndicatorEvent _internal_submission_event() const;
  void _internal_set_submission_event(::autofill::AutofillUploadContents_SubmissionIndicatorEvent value);
  public:

  // optional fixed64 secondary_form_signature = 34;
  bool has_secondary_form_signature() const;
  private:
  bool _internal_has_secondary_form_signature() const;
  public:
  void clear_secondary_form_signature();
  uint64_t secondary_form_signature() const;
  void set_secondary_form_signature(uint64_t value);
  private:
  uint64_t _internal_secondary_form_signature() const;
  void _internal_set_secondary_form_signature(uint64_t value);
  public:

  // optional bool was_throttleable = 38;
  bool has_was_throttleable() const;
  private:
  bool _internal_has_was_throttleable() const;
  public:
  void clear_was_throttleable();
  bool was_throttleable() const;
  void set_was_throttleable(bool value);
  private:
  bool _internal_was_throttleable() const;
  void _internal_set_was_throttleable(bool value);
  public:

  // optional uint32 password_special_symbol = 39;
  bool has_password_special_symbol() const;
  private:
  bool _internal_has_password_special_symbol() const;
  public:
  void clear_password_special_symbol();
  uint32_t password_special_symbol() const;
  void set_password_special_symbol(uint32_t value);
  private:
  uint32_t _internal_password_special_symbol() const;
  void _internal_set_password_special_symbol(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:autofill.AutofillUploadContents)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill::AutofillUploadContents_Field > field_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill::AutofillUploadContents_ButtonTitle > button_title_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr client_version_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_present_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr form_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr language_;
  ::autofill::AutofillRandomizedFormMetadata* randomized_form_metadata_;
  ::autofill::AutofillUploadContents_SingleUsernameData* single_username_data_;
  uint64_t form_signature_;
  uint64_t action_signature_;
  uint64_t login_form_signature_;
  bool autofill_used_;
  bool submission_;
  bool passwords_revealed_;
  bool password_has_lowercase_letter_;
  uint32_t password_length_;
  bool password_has_uppercase_letter_;
  bool password_has_numeric_;
  bool password_has_special_symbol_;
  bool has_form_tag_;
  int submission_event_;
  uint64_t secondary_form_signature_;
  bool was_throttleable_;
  uint32_t password_special_symbol_;
  friend struct ::TableStruct_server_2eproto;
};
// -------------------------------------------------------------------

class ProfileValidityMap_FieldValidityStatesEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntryLite<ProfileValidityMap_FieldValidityStatesEntry_DoNotUse, 
    int32_t, int32_t,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntryLite<ProfileValidityMap_FieldValidityStatesEntry_DoNotUse, 
    int32_t, int32_t,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32> SuperType;
  ProfileValidityMap_FieldValidityStatesEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR ProfileValidityMap_FieldValidityStatesEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit ProfileValidityMap_FieldValidityStatesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const ProfileValidityMap_FieldValidityStatesEntry_DoNotUse& other);
  static const ProfileValidityMap_FieldValidityStatesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const ProfileValidityMap_FieldValidityStatesEntry_DoNotUse*>(&_ProfileValidityMap_FieldValidityStatesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(void*) { return true; }
  static bool ValidateValue(void*) { return true; }
  friend struct ::TableStruct_server_2eproto;
};

// -------------------------------------------------------------------

class ProfileValidityMap final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill.ProfileValidityMap) */ {
 public:
  inline ProfileValidityMap() : ProfileValidityMap(nullptr) {}
  ~ProfileValidityMap() override;
  explicit PROTOBUF_CONSTEXPR ProfileValidityMap(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ProfileValidityMap(const ProfileValidityMap& from);
  ProfileValidityMap(ProfileValidityMap&& from) noexcept
    : ProfileValidityMap() {
    *this = ::std::move(from);
  }

  inline ProfileValidityMap& operator=(const ProfileValidityMap& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProfileValidityMap& operator=(ProfileValidityMap&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ProfileValidityMap& default_instance() {
    return *internal_default_instance();
  }
  static inline const ProfileValidityMap* internal_default_instance() {
    return reinterpret_cast<const ProfileValidityMap*>(
               &_ProfileValidityMap_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(ProfileValidityMap& a, ProfileValidityMap& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(ProfileValidityMap* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProfileValidityMap* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ProfileValidityMap* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ProfileValidityMap>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ProfileValidityMap& from);
  void MergeFrom(const ProfileValidityMap& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ProfileValidityMap* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill.ProfileValidityMap";
  }
  protected:
  explicit ProfileValidityMap(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kFieldValidityStatesFieldNumber = 1,
  };
  // map<int32, int32> field_validity_states = 1;
  int field_validity_states_size() const;
  private:
  int _internal_field_validity_states_size() const;
  public:
  void clear_field_validity_states();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< int32_t, int32_t >&
      _internal_field_validity_states() const;
  ::PROTOBUF_NAMESPACE_ID::Map< int32_t, int32_t >*
      _internal_mutable_field_validity_states();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< int32_t, int32_t >&
      field_validity_states() const;
  ::PROTOBUF_NAMESPACE_ID::Map< int32_t, int32_t >*
      mutable_field_validity_states();

  // @@protoc_insertion_point(class_scope:autofill.ProfileValidityMap)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapFieldLite<
      ProfileValidityMap_FieldValidityStatesEntry_DoNotUse,
      int32_t, int32_t,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32> field_validity_states_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_server_2eproto;
};
// -------------------------------------------------------------------

class UserProfileValidityMap_ProfileValidityEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntryLite<UserProfileValidityMap_ProfileValidityEntry_DoNotUse, 
    std::string, ::autofill::ProfileValidityMap,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntryLite<UserProfileValidityMap_ProfileValidityEntry_DoNotUse, 
    std::string, ::autofill::ProfileValidityMap,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  UserProfileValidityMap_ProfileValidityEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR UserProfileValidityMap_ProfileValidityEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit UserProfileValidityMap_ProfileValidityEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const UserProfileValidityMap_ProfileValidityEntry_DoNotUse& other);
  static const UserProfileValidityMap_ProfileValidityEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const UserProfileValidityMap_ProfileValidityEntry_DoNotUse*>(&_UserProfileValidityMap_ProfileValidityEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(void*) { return true; }
  static bool ValidateValue(void*) { return true; }
  friend struct ::TableStruct_server_2eproto;
};

// -------------------------------------------------------------------

class UserProfileValidityMap final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill.UserProfileValidityMap) */ {
 public:
  inline UserProfileValidityMap() : UserProfileValidityMap(nullptr) {}
  ~UserProfileValidityMap() override;
  explicit PROTOBUF_CONSTEXPR UserProfileValidityMap(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UserProfileValidityMap(const UserProfileValidityMap& from);
  UserProfileValidityMap(UserProfileValidityMap&& from) noexcept
    : UserProfileValidityMap() {
    *this = ::std::move(from);
  }

  inline UserProfileValidityMap& operator=(const UserProfileValidityMap& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserProfileValidityMap& operator=(UserProfileValidityMap&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const UserProfileValidityMap& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserProfileValidityMap* internal_default_instance() {
    return reinterpret_cast<const UserProfileValidityMap*>(
               &_UserProfileValidityMap_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(UserProfileValidityMap& a, UserProfileValidityMap& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(UserProfileValidityMap* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserProfileValidityMap* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserProfileValidityMap* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserProfileValidityMap>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const UserProfileValidityMap& from);
  void MergeFrom(const UserProfileValidityMap& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(UserProfileValidityMap* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill.UserProfileValidityMap";
  }
  protected:
  explicit UserProfileValidityMap(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kProfileValidityFieldNumber = 1,
  };
  // map<string, .autofill.ProfileValidityMap> profile_validity = 1;
  int profile_validity_size() const;
  private:
  int _internal_profile_validity_size() const;
  public:
  void clear_profile_validity();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::autofill::ProfileValidityMap >&
      _internal_profile_validity() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::autofill::ProfileValidityMap >*
      _internal_mutable_profile_validity();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::autofill::ProfileValidityMap >&
      profile_validity() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::autofill::ProfileValidityMap >*
      mutable_profile_validity();

  // @@protoc_insertion_point(class_scope:autofill.UserProfileValidityMap)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapFieldLite<
      UserProfileValidityMap_ProfileValidityEntry_DoNotUse,
      std::string, ::autofill::ProfileValidityMap,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> profile_validity_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_server_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// AutofillQueryContents_Form_Field

// required fixed32 signature = 5;
inline bool AutofillQueryContents_Form_Field::_internal_has_signature() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool AutofillQueryContents_Form_Field::has_signature() const {
  return _internal_has_signature();
}
inline void AutofillQueryContents_Form_Field::clear_signature() {
  signature_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline uint32_t AutofillQueryContents_Form_Field::_internal_signature() const {
  return signature_;
}
inline uint32_t AutofillQueryContents_Form_Field::signature() const {
  // @@protoc_insertion_point(field_get:autofill.AutofillQueryContents.Form.Field.signature)
  return _internal_signature();
}
inline void AutofillQueryContents_Form_Field::_internal_set_signature(uint32_t value) {
  _has_bits_[0] |= 0x00000008u;
  signature_ = value;
}
inline void AutofillQueryContents_Form_Field::set_signature(uint32_t value) {
  _internal_set_signature(value);
  // @@protoc_insertion_point(field_set:autofill.AutofillQueryContents.Form.Field.signature)
}

// optional string name = 8;
inline bool AutofillQueryContents_Form_Field::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AutofillQueryContents_Form_Field::has_name() const {
  return _internal_has_name();
}
inline void AutofillQueryContents_Form_Field::clear_name() {
  name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AutofillQueryContents_Form_Field::name() const {
  // @@protoc_insertion_point(field_get:autofill.AutofillQueryContents.Form.Field.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AutofillQueryContents_Form_Field::set_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill.AutofillQueryContents.Form.Field.name)
}
inline std::string* AutofillQueryContents_Form_Field::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:autofill.AutofillQueryContents.Form.Field.name)
  return _s;
}
inline const std::string& AutofillQueryContents_Form_Field::_internal_name() const {
  return name_.Get();
}
inline void AutofillQueryContents_Form_Field::_internal_set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(value, GetArenaForAllocation());
}
inline std::string* AutofillQueryContents_Form_Field::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  return name_.Mutable(GetArenaForAllocation());
}
inline std::string* AutofillQueryContents_Form_Field::release_name() {
  // @@protoc_insertion_point(field_release:autofill.AutofillQueryContents.Form.Field.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault()) {
    name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AutofillQueryContents_Form_Field::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault()) {
    name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill.AutofillQueryContents.Form.Field.name)
}

// optional string type = 9;
inline bool AutofillQueryContents_Form_Field::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool AutofillQueryContents_Form_Field::has_type() const {
  return _internal_has_type();
}
inline void AutofillQueryContents_Form_Field::clear_type() {
  type_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& AutofillQueryContents_Form_Field::type() const {
  // @@protoc_insertion_point(field_get:autofill.AutofillQueryContents.Form.Field.type)
  return _internal_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AutofillQueryContents_Form_Field::set_type(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill.AutofillQueryContents.Form.Field.type)
}
inline std::string* AutofillQueryContents_Form_Field::mutable_type() {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:autofill.AutofillQueryContents.Form.Field.type)
  return _s;
}
inline const std::string& AutofillQueryContents_Form_Field::_internal_type() const {
  return type_.Get();
}
inline void AutofillQueryContents_Form_Field::_internal_set_type(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  type_.Set(value, GetArenaForAllocation());
}
inline std::string* AutofillQueryContents_Form_Field::_internal_mutable_type() {
  _has_bits_[0] |= 0x00000002u;
  return type_.Mutable(GetArenaForAllocation());
}
inline std::string* AutofillQueryContents_Form_Field::release_type() {
  // @@protoc_insertion_point(field_release:autofill.AutofillQueryContents.Form.Field.type)
  if (!_internal_has_type()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = type_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (type_.IsDefault()) {
    type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AutofillQueryContents_Form_Field::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  type_.SetAllocated(type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (type_.IsDefault()) {
    type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill.AutofillQueryContents.Form.Field.type)
}

// optional .autofill.AutofillRandomizedFieldMetadata field_metadata = 13;
inline bool AutofillQueryContents_Form_Field::_internal_has_field_metadata() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || field_metadata_ != nullptr);
  return value;
}
inline bool AutofillQueryContents_Form_Field::has_field_metadata() const {
  return _internal_has_field_metadata();
}
inline void AutofillQueryContents_Form_Field::clear_field_metadata() {
  if (field_metadata_ != nullptr) field_metadata_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::autofill::AutofillRandomizedFieldMetadata& AutofillQueryContents_Form_Field::_internal_field_metadata() const {
  const ::autofill::AutofillRandomizedFieldMetadata* p = field_metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill::AutofillRandomizedFieldMetadata&>(
      ::autofill::_AutofillRandomizedFieldMetadata_default_instance_);
}
inline const ::autofill::AutofillRandomizedFieldMetadata& AutofillQueryContents_Form_Field::field_metadata() const {
  // @@protoc_insertion_point(field_get:autofill.AutofillQueryContents.Form.Field.field_metadata)
  return _internal_field_metadata();
}
inline void AutofillQueryContents_Form_Field::unsafe_arena_set_allocated_field_metadata(
    ::autofill::AutofillRandomizedFieldMetadata* field_metadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(field_metadata_);
  }
  field_metadata_ = field_metadata;
  if (field_metadata) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill.AutofillQueryContents.Form.Field.field_metadata)
}
inline ::autofill::AutofillRandomizedFieldMetadata* AutofillQueryContents_Form_Field::release_field_metadata() {
  _has_bits_[0] &= ~0x00000004u;
  ::autofill::AutofillRandomizedFieldMetadata* temp = field_metadata_;
  field_metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill::AutofillRandomizedFieldMetadata* AutofillQueryContents_Form_Field::unsafe_arena_release_field_metadata() {
  // @@protoc_insertion_point(field_release:autofill.AutofillQueryContents.Form.Field.field_metadata)
  _has_bits_[0] &= ~0x00000004u;
  ::autofill::AutofillRandomizedFieldMetadata* temp = field_metadata_;
  field_metadata_ = nullptr;
  return temp;
}
inline ::autofill::AutofillRandomizedFieldMetadata* AutofillQueryContents_Form_Field::_internal_mutable_field_metadata() {
  _has_bits_[0] |= 0x00000004u;
  if (field_metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill::AutofillRandomizedFieldMetadata>(GetArenaForAllocation());
    field_metadata_ = p;
  }
  return field_metadata_;
}
inline ::autofill::AutofillRandomizedFieldMetadata* AutofillQueryContents_Form_Field::mutable_field_metadata() {
  ::autofill::AutofillRandomizedFieldMetadata* _msg = _internal_mutable_field_metadata();
  // @@protoc_insertion_point(field_mutable:autofill.AutofillQueryContents.Form.Field.field_metadata)
  return _msg;
}
inline void AutofillQueryContents_Form_Field::set_allocated_field_metadata(::autofill::AutofillRandomizedFieldMetadata* field_metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete field_metadata_;
  }
  if (field_metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(field_metadata);
    if (message_arena != submessage_arena) {
      field_metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, field_metadata, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  field_metadata_ = field_metadata;
  // @@protoc_insertion_point(field_set_allocated:autofill.AutofillQueryContents.Form.Field.field_metadata)
}

// -------------------------------------------------------------------

// AutofillQueryContents_Form

// required fixed64 signature = 3;
inline bool AutofillQueryContents_Form::_internal_has_signature() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool AutofillQueryContents_Form::has_signature() const {
  return _internal_has_signature();
}
inline void AutofillQueryContents_Form::clear_signature() {
  signature_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000002u;
}
inline uint64_t AutofillQueryContents_Form::_internal_signature() const {
  return signature_;
}
inline uint64_t AutofillQueryContents_Form::signature() const {
  // @@protoc_insertion_point(field_get:autofill.AutofillQueryContents.Form.signature)
  return _internal_signature();
}
inline void AutofillQueryContents_Form::_internal_set_signature(uint64_t value) {
  _has_bits_[0] |= 0x00000002u;
  signature_ = value;
}
inline void AutofillQueryContents_Form::set_signature(uint64_t value) {
  _internal_set_signature(value);
  // @@protoc_insertion_point(field_set:autofill.AutofillQueryContents.Form.signature)
}

// optional .autofill.AutofillRandomizedFormMetadata form_metadata = 12;
inline bool AutofillQueryContents_Form::_internal_has_form_metadata() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || form_metadata_ != nullptr);
  return value;
}
inline bool AutofillQueryContents_Form::has_form_metadata() const {
  return _internal_has_form_metadata();
}
inline void AutofillQueryContents_Form::clear_form_metadata() {
  if (form_metadata_ != nullptr) form_metadata_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::autofill::AutofillRandomizedFormMetadata& AutofillQueryContents_Form::_internal_form_metadata() const {
  const ::autofill::AutofillRandomizedFormMetadata* p = form_metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill::AutofillRandomizedFormMetadata&>(
      ::autofill::_AutofillRandomizedFormMetadata_default_instance_);
}
inline const ::autofill::AutofillRandomizedFormMetadata& AutofillQueryContents_Form::form_metadata() const {
  // @@protoc_insertion_point(field_get:autofill.AutofillQueryContents.Form.form_metadata)
  return _internal_form_metadata();
}
inline void AutofillQueryContents_Form::unsafe_arena_set_allocated_form_metadata(
    ::autofill::AutofillRandomizedFormMetadata* form_metadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(form_metadata_);
  }
  form_metadata_ = form_metadata;
  if (form_metadata) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill.AutofillQueryContents.Form.form_metadata)
}
inline ::autofill::AutofillRandomizedFormMetadata* AutofillQueryContents_Form::release_form_metadata() {
  _has_bits_[0] &= ~0x00000001u;
  ::autofill::AutofillRandomizedFormMetadata* temp = form_metadata_;
  form_metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill::AutofillRandomizedFormMetadata* AutofillQueryContents_Form::unsafe_arena_release_form_metadata() {
  // @@protoc_insertion_point(field_release:autofill.AutofillQueryContents.Form.form_metadata)
  _has_bits_[0] &= ~0x00000001u;
  ::autofill::AutofillRandomizedFormMetadata* temp = form_metadata_;
  form_metadata_ = nullptr;
  return temp;
}
inline ::autofill::AutofillRandomizedFormMetadata* AutofillQueryContents_Form::_internal_mutable_form_metadata() {
  _has_bits_[0] |= 0x00000001u;
  if (form_metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill::AutofillRandomizedFormMetadata>(GetArenaForAllocation());
    form_metadata_ = p;
  }
  return form_metadata_;
}
inline ::autofill::AutofillRandomizedFormMetadata* AutofillQueryContents_Form::mutable_form_metadata() {
  ::autofill::AutofillRandomizedFormMetadata* _msg = _internal_mutable_form_metadata();
  // @@protoc_insertion_point(field_mutable:autofill.AutofillQueryContents.Form.form_metadata)
  return _msg;
}
inline void AutofillQueryContents_Form::set_allocated_form_metadata(::autofill::AutofillRandomizedFormMetadata* form_metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete form_metadata_;
  }
  if (form_metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(form_metadata);
    if (message_arena != submessage_arena) {
      form_metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, form_metadata, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  form_metadata_ = form_metadata;
  // @@protoc_insertion_point(field_set_allocated:autofill.AutofillQueryContents.Form.form_metadata)
}

// repeated group Field = 4 { ... };
inline int AutofillQueryContents_Form::_internal_field_size() const {
  return field_.size();
}
inline int AutofillQueryContents_Form::field_size() const {
  return _internal_field_size();
}
inline void AutofillQueryContents_Form::clear_field() {
  field_.Clear();
}
inline ::autofill::AutofillQueryContents_Form_Field* AutofillQueryContents_Form::mutable_field(int index) {
  // @@protoc_insertion_point(field_mutable:autofill.AutofillQueryContents.Form.field)
  return field_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill::AutofillQueryContents_Form_Field >*
AutofillQueryContents_Form::mutable_field() {
  // @@protoc_insertion_point(field_mutable_list:autofill.AutofillQueryContents.Form.field)
  return &field_;
}
inline const ::autofill::AutofillQueryContents_Form_Field& AutofillQueryContents_Form::_internal_field(int index) const {
  return field_.Get(index);
}
inline const ::autofill::AutofillQueryContents_Form_Field& AutofillQueryContents_Form::field(int index) const {
  // @@protoc_insertion_point(field_get:autofill.AutofillQueryContents.Form.field)
  return _internal_field(index);
}
inline ::autofill::AutofillQueryContents_Form_Field* AutofillQueryContents_Form::_internal_add_field() {
  return field_.Add();
}
inline ::autofill::AutofillQueryContents_Form_Field* AutofillQueryContents_Form::add_field() {
  ::autofill::AutofillQueryContents_Form_Field* _add = _internal_add_field();
  // @@protoc_insertion_point(field_add:autofill.AutofillQueryContents.Form.field)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill::AutofillQueryContents_Form_Field >&
AutofillQueryContents_Form::field() const {
  // @@protoc_insertion_point(field_list:autofill.AutofillQueryContents.Form.field)
  return field_;
}

// -------------------------------------------------------------------

// AutofillQueryContents

// required string client_version = 1;
inline bool AutofillQueryContents::_internal_has_client_version() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AutofillQueryContents::has_client_version() const {
  return _internal_has_client_version();
}
inline void AutofillQueryContents::clear_client_version() {
  client_version_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AutofillQueryContents::client_version() const {
  // @@protoc_insertion_point(field_get:autofill.AutofillQueryContents.client_version)
  return _internal_client_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AutofillQueryContents::set_client_version(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 client_version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill.AutofillQueryContents.client_version)
}
inline std::string* AutofillQueryContents::mutable_client_version() {
  std::string* _s = _internal_mutable_client_version();
  // @@protoc_insertion_point(field_mutable:autofill.AutofillQueryContents.client_version)
  return _s;
}
inline const std::string& AutofillQueryContents::_internal_client_version() const {
  return client_version_.Get();
}
inline void AutofillQueryContents::_internal_set_client_version(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  client_version_.Set(value, GetArenaForAllocation());
}
inline std::string* AutofillQueryContents::_internal_mutable_client_version() {
  _has_bits_[0] |= 0x00000001u;
  return client_version_.Mutable(GetArenaForAllocation());
}
inline std::string* AutofillQueryContents::release_client_version() {
  // @@protoc_insertion_point(field_release:autofill.AutofillQueryContents.client_version)
  if (!_internal_has_client_version()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = client_version_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (client_version_.IsDefault()) {
    client_version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AutofillQueryContents::set_allocated_client_version(std::string* client_version) {
  if (client_version != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  client_version_.SetAllocated(client_version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (client_version_.IsDefault()) {
    client_version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill.AutofillQueryContents.client_version)
}

// repeated group Form = 2 { ... };
inline int AutofillQueryContents::_internal_form_size() const {
  return form_.size();
}
inline int AutofillQueryContents::form_size() const {
  return _internal_form_size();
}
inline void AutofillQueryContents::clear_form() {
  form_.Clear();
}
inline ::autofill::AutofillQueryContents_Form* AutofillQueryContents::mutable_form(int index) {
  // @@protoc_insertion_point(field_mutable:autofill.AutofillQueryContents.form)
  return form_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill::AutofillQueryContents_Form >*
AutofillQueryContents::mutable_form() {
  // @@protoc_insertion_point(field_mutable_list:autofill.AutofillQueryContents.form)
  return &form_;
}
inline const ::autofill::AutofillQueryContents_Form& AutofillQueryContents::_internal_form(int index) const {
  return form_.Get(index);
}
inline const ::autofill::AutofillQueryContents_Form& AutofillQueryContents::form(int index) const {
  // @@protoc_insertion_point(field_get:autofill.AutofillQueryContents.form)
  return _internal_form(index);
}
inline ::autofill::AutofillQueryContents_Form* AutofillQueryContents::_internal_add_form() {
  return form_.Add();
}
inline ::autofill::AutofillQueryContents_Form* AutofillQueryContents::add_form() {
  ::autofill::AutofillQueryContents_Form* _add = _internal_add_form();
  // @@protoc_insertion_point(field_add:autofill.AutofillQueryContents.form)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill::AutofillQueryContents_Form >&
AutofillQueryContents::form() const {
  // @@protoc_insertion_point(field_list:autofill.AutofillQueryContents.form)
  return form_;
}

// repeated int64 experiments = 14;
inline int AutofillQueryContents::_internal_experiments_size() const {
  return experiments_.size();
}
inline int AutofillQueryContents::experiments_size() const {
  return _internal_experiments_size();
}
inline void AutofillQueryContents::clear_experiments() {
  experiments_.Clear();
}
inline int64_t AutofillQueryContents::_internal_experiments(int index) const {
  return experiments_.Get(index);
}
inline int64_t AutofillQueryContents::experiments(int index) const {
  // @@protoc_insertion_point(field_get:autofill.AutofillQueryContents.experiments)
  return _internal_experiments(index);
}
inline void AutofillQueryContents::set_experiments(int index, int64_t value) {
  experiments_.Set(index, value);
  // @@protoc_insertion_point(field_set:autofill.AutofillQueryContents.experiments)
}
inline void AutofillQueryContents::_internal_add_experiments(int64_t value) {
  experiments_.Add(value);
}
inline void AutofillQueryContents::add_experiments(int64_t value) {
  _internal_add_experiments(value);
  // @@protoc_insertion_point(field_add:autofill.AutofillQueryContents.experiments)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
AutofillQueryContents::_internal_experiments() const {
  return experiments_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
AutofillQueryContents::experiments() const {
  // @@protoc_insertion_point(field_list:autofill.AutofillQueryContents.experiments)
  return _internal_experiments();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
AutofillQueryContents::_internal_mutable_experiments() {
  return &experiments_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
AutofillQueryContents::mutable_experiments() {
  // @@protoc_insertion_point(field_mutable_list:autofill.AutofillQueryContents.experiments)
  return _internal_mutable_experiments();
}

// -------------------------------------------------------------------

// AutofillQueryResponseContents_Field_FieldPrediction

// optional fixed32 type = 1;
inline bool AutofillQueryResponseContents_Field_FieldPrediction::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AutofillQueryResponseContents_Field_FieldPrediction::has_type() const {
  return _internal_has_type();
}
inline void AutofillQueryResponseContents_Field_FieldPrediction::clear_type() {
  type_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline uint32_t AutofillQueryResponseContents_Field_FieldPrediction::_internal_type() const {
  return type_;
}
inline uint32_t AutofillQueryResponseContents_Field_FieldPrediction::type() const {
  // @@protoc_insertion_point(field_get:autofill.AutofillQueryResponseContents.Field.FieldPrediction.type)
  return _internal_type();
}
inline void AutofillQueryResponseContents_Field_FieldPrediction::_internal_set_type(uint32_t value) {
  _has_bits_[0] |= 0x00000001u;
  type_ = value;
}
inline void AutofillQueryResponseContents_Field_FieldPrediction::set_type(uint32_t value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:autofill.AutofillQueryResponseContents.Field.FieldPrediction.type)
}

// optional bool may_use_prefilled_placeholder = 2;
inline bool AutofillQueryResponseContents_Field_FieldPrediction::_internal_has_may_use_prefilled_placeholder() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool AutofillQueryResponseContents_Field_FieldPrediction::has_may_use_prefilled_placeholder() const {
  return _internal_has_may_use_prefilled_placeholder();
}
inline void AutofillQueryResponseContents_Field_FieldPrediction::clear_may_use_prefilled_placeholder() {
  may_use_prefilled_placeholder_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool AutofillQueryResponseContents_Field_FieldPrediction::_internal_may_use_prefilled_placeholder() const {
  return may_use_prefilled_placeholder_;
}
inline bool AutofillQueryResponseContents_Field_FieldPrediction::may_use_prefilled_placeholder() const {
  // @@protoc_insertion_point(field_get:autofill.AutofillQueryResponseContents.Field.FieldPrediction.may_use_prefilled_placeholder)
  return _internal_may_use_prefilled_placeholder();
}
inline void AutofillQueryResponseContents_Field_FieldPrediction::_internal_set_may_use_prefilled_placeholder(bool value) {
  _has_bits_[0] |= 0x00000002u;
  may_use_prefilled_placeholder_ = value;
}
inline void AutofillQueryResponseContents_Field_FieldPrediction::set_may_use_prefilled_placeholder(bool value) {
  _internal_set_may_use_prefilled_placeholder(value);
  // @@protoc_insertion_point(field_set:autofill.AutofillQueryResponseContents.Field.FieldPrediction.may_use_prefilled_placeholder)
}

// -------------------------------------------------------------------

// AutofillQueryResponseContents_Field

// required fixed32 overall_type_prediction = 3;
inline bool AutofillQueryResponseContents_Field::_internal_has_overall_type_prediction() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool AutofillQueryResponseContents_Field::has_overall_type_prediction() const {
  return _internal_has_overall_type_prediction();
}
inline void AutofillQueryResponseContents_Field::clear_overall_type_prediction() {
  overall_type_prediction_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline uint32_t AutofillQueryResponseContents_Field::_internal_overall_type_prediction() const {
  return overall_type_prediction_;
}
inline uint32_t AutofillQueryResponseContents_Field::overall_type_prediction() const {
  // @@protoc_insertion_point(field_get:autofill.AutofillQueryResponseContents.Field.overall_type_prediction)
  return _internal_overall_type_prediction();
}
inline void AutofillQueryResponseContents_Field::_internal_set_overall_type_prediction(uint32_t value) {
  _has_bits_[0] |= 0x00000002u;
  overall_type_prediction_ = value;
}
inline void AutofillQueryResponseContents_Field::set_overall_type_prediction(uint32_t value) {
  _internal_set_overall_type_prediction(value);
  // @@protoc_insertion_point(field_set:autofill.AutofillQueryResponseContents.Field.overall_type_prediction)
}

// repeated .autofill.AutofillQueryResponseContents.Field.FieldPrediction predictions = 7;
inline int AutofillQueryResponseContents_Field::_internal_predictions_size() const {
  return predictions_.size();
}
inline int AutofillQueryResponseContents_Field::predictions_size() const {
  return _internal_predictions_size();
}
inline void AutofillQueryResponseContents_Field::clear_predictions() {
  predictions_.Clear();
}
inline ::autofill::AutofillQueryResponseContents_Field_FieldPrediction* AutofillQueryResponseContents_Field::mutable_predictions(int index) {
  // @@protoc_insertion_point(field_mutable:autofill.AutofillQueryResponseContents.Field.predictions)
  return predictions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill::AutofillQueryResponseContents_Field_FieldPrediction >*
AutofillQueryResponseContents_Field::mutable_predictions() {
  // @@protoc_insertion_point(field_mutable_list:autofill.AutofillQueryResponseContents.Field.predictions)
  return &predictions_;
}
inline const ::autofill::AutofillQueryResponseContents_Field_FieldPrediction& AutofillQueryResponseContents_Field::_internal_predictions(int index) const {
  return predictions_.Get(index);
}
inline const ::autofill::AutofillQueryResponseContents_Field_FieldPrediction& AutofillQueryResponseContents_Field::predictions(int index) const {
  // @@protoc_insertion_point(field_get:autofill.AutofillQueryResponseContents.Field.predictions)
  return _internal_predictions(index);
}
inline ::autofill::AutofillQueryResponseContents_Field_FieldPrediction* AutofillQueryResponseContents_Field::_internal_add_predictions() {
  return predictions_.Add();
}
inline ::autofill::AutofillQueryResponseContents_Field_FieldPrediction* AutofillQueryResponseContents_Field::add_predictions() {
  ::autofill::AutofillQueryResponseContents_Field_FieldPrediction* _add = _internal_add_predictions();
  // @@protoc_insertion_point(field_add:autofill.AutofillQueryResponseContents.Field.predictions)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill::AutofillQueryResponseContents_Field_FieldPrediction >&
AutofillQueryResponseContents_Field::predictions() const {
  // @@protoc_insertion_point(field_list:autofill.AutofillQueryResponseContents.Field.predictions)
  return predictions_;
}

// optional .autofill.PasswordRequirementsSpec password_requirements = 9;
inline bool AutofillQueryResponseContents_Field::_internal_has_password_requirements() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || password_requirements_ != nullptr);
  return value;
}
inline bool AutofillQueryResponseContents_Field::has_password_requirements() const {
  return _internal_has_password_requirements();
}
inline const ::autofill::PasswordRequirementsSpec& AutofillQueryResponseContents_Field::_internal_password_requirements() const {
  const ::autofill::PasswordRequirementsSpec* p = password_requirements_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill::PasswordRequirementsSpec&>(
      ::autofill::_PasswordRequirementsSpec_default_instance_);
}
inline const ::autofill::PasswordRequirementsSpec& AutofillQueryResponseContents_Field::password_requirements() const {
  // @@protoc_insertion_point(field_get:autofill.AutofillQueryResponseContents.Field.password_requirements)
  return _internal_password_requirements();
}
inline void AutofillQueryResponseContents_Field::unsafe_arena_set_allocated_password_requirements(
    ::autofill::PasswordRequirementsSpec* password_requirements) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(password_requirements_);
  }
  password_requirements_ = password_requirements;
  if (password_requirements) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill.AutofillQueryResponseContents.Field.password_requirements)
}
inline ::autofill::PasswordRequirementsSpec* AutofillQueryResponseContents_Field::release_password_requirements() {
  _has_bits_[0] &= ~0x00000001u;
  ::autofill::PasswordRequirementsSpec* temp = password_requirements_;
  password_requirements_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill::PasswordRequirementsSpec* AutofillQueryResponseContents_Field::unsafe_arena_release_password_requirements() {
  // @@protoc_insertion_point(field_release:autofill.AutofillQueryResponseContents.Field.password_requirements)
  _has_bits_[0] &= ~0x00000001u;
  ::autofill::PasswordRequirementsSpec* temp = password_requirements_;
  password_requirements_ = nullptr;
  return temp;
}
inline ::autofill::PasswordRequirementsSpec* AutofillQueryResponseContents_Field::_internal_mutable_password_requirements() {
  _has_bits_[0] |= 0x00000001u;
  if (password_requirements_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill::PasswordRequirementsSpec>(GetArenaForAllocation());
    password_requirements_ = p;
  }
  return password_requirements_;
}
inline ::autofill::PasswordRequirementsSpec* AutofillQueryResponseContents_Field::mutable_password_requirements() {
  ::autofill::PasswordRequirementsSpec* _msg = _internal_mutable_password_requirements();
  // @@protoc_insertion_point(field_mutable:autofill.AutofillQueryResponseContents.Field.password_requirements)
  return _msg;
}
inline void AutofillQueryResponseContents_Field::set_allocated_password_requirements(::autofill::PasswordRequirementsSpec* password_requirements) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(password_requirements_);
  }
  if (password_requirements) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(password_requirements));
    if (message_arena != submessage_arena) {
      password_requirements = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, password_requirements, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  password_requirements_ = password_requirements;
  // @@protoc_insertion_point(field_set_allocated:autofill.AutofillQueryResponseContents.Field.password_requirements)
}

// -------------------------------------------------------------------

// AutofillQueryResponseContents

// optional bool upload_required = 1 [deprecated = true];
inline bool AutofillQueryResponseContents::_internal_has_upload_required() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AutofillQueryResponseContents::has_upload_required() const {
  return _internal_has_upload_required();
}
inline void AutofillQueryResponseContents::clear_upload_required() {
  upload_required_ = false;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool AutofillQueryResponseContents::_internal_upload_required() const {
  return upload_required_;
}
inline bool AutofillQueryResponseContents::upload_required() const {
  // @@protoc_insertion_point(field_get:autofill.AutofillQueryResponseContents.upload_required)
  return _internal_upload_required();
}
inline void AutofillQueryResponseContents::_internal_set_upload_required(bool value) {
  _has_bits_[0] |= 0x00000001u;
  upload_required_ = value;
}
inline void AutofillQueryResponseContents::set_upload_required(bool value) {
  _internal_set_upload_required(value);
  // @@protoc_insertion_point(field_set:autofill.AutofillQueryResponseContents.upload_required)
}

// repeated group Field = 2 { ... };
inline int AutofillQueryResponseContents::_internal_field_size() const {
  return field_.size();
}
inline int AutofillQueryResponseContents::field_size() const {
  return _internal_field_size();
}
inline void AutofillQueryResponseContents::clear_field() {
  field_.Clear();
}
inline ::autofill::AutofillQueryResponseContents_Field* AutofillQueryResponseContents::mutable_field(int index) {
  // @@protoc_insertion_point(field_mutable:autofill.AutofillQueryResponseContents.field)
  return field_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill::AutofillQueryResponseContents_Field >*
AutofillQueryResponseContents::mutable_field() {
  // @@protoc_insertion_point(field_mutable_list:autofill.AutofillQueryResponseContents.field)
  return &field_;
}
inline const ::autofill::AutofillQueryResponseContents_Field& AutofillQueryResponseContents::_internal_field(int index) const {
  return field_.Get(index);
}
inline const ::autofill::AutofillQueryResponseContents_Field& AutofillQueryResponseContents::field(int index) const {
  // @@protoc_insertion_point(field_get:autofill.AutofillQueryResponseContents.field)
  return _internal_field(index);
}
inline ::autofill::AutofillQueryResponseContents_Field* AutofillQueryResponseContents::_internal_add_field() {
  return field_.Add();
}
inline ::autofill::AutofillQueryResponseContents_Field* AutofillQueryResponseContents::add_field() {
  ::autofill::AutofillQueryResponseContents_Field* _add = _internal_add_field();
  // @@protoc_insertion_point(field_add:autofill.AutofillQueryResponseContents.field)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill::AutofillQueryResponseContents_Field >&
AutofillQueryResponseContents::field() const {
  // @@protoc_insertion_point(field_list:autofill.AutofillQueryResponseContents.field)
  return field_;
}

// -------------------------------------------------------------------

// AutofillRandomizedValue

// optional .autofill.AutofillRandomizedValue.EncodingType encoding_type = 1 [default = UNSPECIFIED_ENCODING_TYPE];
inline bool AutofillRandomizedValue::_internal_has_encoding_type() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool AutofillRandomizedValue::has_encoding_type() const {
  return _internal_has_encoding_type();
}
inline void AutofillRandomizedValue::clear_encoding_type() {
  encoding_type_ = -1;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::autofill::AutofillRandomizedValue_EncodingType AutofillRandomizedValue::_internal_encoding_type() const {
  return static_cast< ::autofill::AutofillRandomizedValue_EncodingType >(encoding_type_);
}
inline ::autofill::AutofillRandomizedValue_EncodingType AutofillRandomizedValue::encoding_type() const {
  // @@protoc_insertion_point(field_get:autofill.AutofillRandomizedValue.encoding_type)
  return _internal_encoding_type();
}
inline void AutofillRandomizedValue::_internal_set_encoding_type(::autofill::AutofillRandomizedValue_EncodingType value) {
  assert(::autofill::AutofillRandomizedValue_EncodingType_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  encoding_type_ = value;
}
inline void AutofillRandomizedValue::set_encoding_type(::autofill::AutofillRandomizedValue_EncodingType value) {
  _internal_set_encoding_type(value);
  // @@protoc_insertion_point(field_set:autofill.AutofillRandomizedValue.encoding_type)
}

// optional bytes encoded_bits = 2;
inline bool AutofillRandomizedValue::_internal_has_encoded_bits() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AutofillRandomizedValue::has_encoded_bits() const {
  return _internal_has_encoded_bits();
}
inline void AutofillRandomizedValue::clear_encoded_bits() {
  encoded_bits_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AutofillRandomizedValue::encoded_bits() const {
  // @@protoc_insertion_point(field_get:autofill.AutofillRandomizedValue.encoded_bits)
  return _internal_encoded_bits();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AutofillRandomizedValue::set_encoded_bits(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 encoded_bits_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill.AutofillRandomizedValue.encoded_bits)
}
inline std::string* AutofillRandomizedValue::mutable_encoded_bits() {
  std::string* _s = _internal_mutable_encoded_bits();
  // @@protoc_insertion_point(field_mutable:autofill.AutofillRandomizedValue.encoded_bits)
  return _s;
}
inline const std::string& AutofillRandomizedValue::_internal_encoded_bits() const {
  return encoded_bits_.Get();
}
inline void AutofillRandomizedValue::_internal_set_encoded_bits(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  encoded_bits_.Set(value, GetArenaForAllocation());
}
inline std::string* AutofillRandomizedValue::_internal_mutable_encoded_bits() {
  _has_bits_[0] |= 0x00000001u;
  return encoded_bits_.Mutable(GetArenaForAllocation());
}
inline std::string* AutofillRandomizedValue::release_encoded_bits() {
  // @@protoc_insertion_point(field_release:autofill.AutofillRandomizedValue.encoded_bits)
  if (!_internal_has_encoded_bits()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = encoded_bits_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (encoded_bits_.IsDefault()) {
    encoded_bits_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AutofillRandomizedValue::set_allocated_encoded_bits(std::string* encoded_bits) {
  if (encoded_bits != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  encoded_bits_.SetAllocated(encoded_bits, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (encoded_bits_.IsDefault()) {
    encoded_bits_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill.AutofillRandomizedValue.encoded_bits)
}

// optional fixed32 checksum = 3;
inline bool AutofillRandomizedValue::_internal_has_checksum() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool AutofillRandomizedValue::has_checksum() const {
  return _internal_has_checksum();
}
inline void AutofillRandomizedValue::clear_checksum() {
  checksum_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline uint32_t AutofillRandomizedValue::_internal_checksum() const {
  return checksum_;
}
inline uint32_t AutofillRandomizedValue::checksum() const {
  // @@protoc_insertion_point(field_get:autofill.AutofillRandomizedValue.checksum)
  return _internal_checksum();
}
inline void AutofillRandomizedValue::_internal_set_checksum(uint32_t value) {
  _has_bits_[0] |= 0x00000002u;
  checksum_ = value;
}
inline void AutofillRandomizedValue::set_checksum(uint32_t value) {
  _internal_set_checksum(value);
  // @@protoc_insertion_point(field_set:autofill.AutofillRandomizedValue.checksum)
}

// -------------------------------------------------------------------

// AutofillRandomizedFormMetadata_ButtonTitle

// optional .autofill.AutofillRandomizedValue title = 1;
inline bool AutofillRandomizedFormMetadata_ButtonTitle::_internal_has_title() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || title_ != nullptr);
  return value;
}
inline bool AutofillRandomizedFormMetadata_ButtonTitle::has_title() const {
  return _internal_has_title();
}
inline void AutofillRandomizedFormMetadata_ButtonTitle::clear_title() {
  if (title_ != nullptr) title_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::autofill::AutofillRandomizedValue& AutofillRandomizedFormMetadata_ButtonTitle::_internal_title() const {
  const ::autofill::AutofillRandomizedValue* p = title_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill::AutofillRandomizedValue&>(
      ::autofill::_AutofillRandomizedValue_default_instance_);
}
inline const ::autofill::AutofillRandomizedValue& AutofillRandomizedFormMetadata_ButtonTitle::title() const {
  // @@protoc_insertion_point(field_get:autofill.AutofillRandomizedFormMetadata.ButtonTitle.title)
  return _internal_title();
}
inline void AutofillRandomizedFormMetadata_ButtonTitle::unsafe_arena_set_allocated_title(
    ::autofill::AutofillRandomizedValue* title) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(title_);
  }
  title_ = title;
  if (title) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill.AutofillRandomizedFormMetadata.ButtonTitle.title)
}
inline ::autofill::AutofillRandomizedValue* AutofillRandomizedFormMetadata_ButtonTitle::release_title() {
  _has_bits_[0] &= ~0x00000001u;
  ::autofill::AutofillRandomizedValue* temp = title_;
  title_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill::AutofillRandomizedValue* AutofillRandomizedFormMetadata_ButtonTitle::unsafe_arena_release_title() {
  // @@protoc_insertion_point(field_release:autofill.AutofillRandomizedFormMetadata.ButtonTitle.title)
  _has_bits_[0] &= ~0x00000001u;
  ::autofill::AutofillRandomizedValue* temp = title_;
  title_ = nullptr;
  return temp;
}
inline ::autofill::AutofillRandomizedValue* AutofillRandomizedFormMetadata_ButtonTitle::_internal_mutable_title() {
  _has_bits_[0] |= 0x00000001u;
  if (title_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill::AutofillRandomizedValue>(GetArenaForAllocation());
    title_ = p;
  }
  return title_;
}
inline ::autofill::AutofillRandomizedValue* AutofillRandomizedFormMetadata_ButtonTitle::mutable_title() {
  ::autofill::AutofillRandomizedValue* _msg = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:autofill.AutofillRandomizedFormMetadata.ButtonTitle.title)
  return _msg;
}
inline void AutofillRandomizedFormMetadata_ButtonTitle::set_allocated_title(::autofill::AutofillRandomizedValue* title) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete title_;
  }
  if (title) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(title);
    if (message_arena != submessage_arena) {
      title = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, title, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  title_ = title;
  // @@protoc_insertion_point(field_set_allocated:autofill.AutofillRandomizedFormMetadata.ButtonTitle.title)
}

// optional .autofill.ButtonTitleType type = 2;
inline bool AutofillRandomizedFormMetadata_ButtonTitle::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool AutofillRandomizedFormMetadata_ButtonTitle::has_type() const {
  return _internal_has_type();
}
inline void AutofillRandomizedFormMetadata_ButtonTitle::clear_type() {
  type_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::autofill::ButtonTitleType AutofillRandomizedFormMetadata_ButtonTitle::_internal_type() const {
  return static_cast< ::autofill::ButtonTitleType >(type_);
}
inline ::autofill::ButtonTitleType AutofillRandomizedFormMetadata_ButtonTitle::type() const {
  // @@protoc_insertion_point(field_get:autofill.AutofillRandomizedFormMetadata.ButtonTitle.type)
  return _internal_type();
}
inline void AutofillRandomizedFormMetadata_ButtonTitle::_internal_set_type(::autofill::ButtonTitleType value) {
  assert(::autofill::ButtonTitleType_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  type_ = value;
}
inline void AutofillRandomizedFormMetadata_ButtonTitle::set_type(::autofill::ButtonTitleType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:autofill.AutofillRandomizedFormMetadata.ButtonTitle.type)
}

// -------------------------------------------------------------------

// AutofillRandomizedFormMetadata

// optional .autofill.AutofillRandomizedValue id = 1;
inline bool AutofillRandomizedFormMetadata::_internal_has_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || id_ != nullptr);
  return value;
}
inline bool AutofillRandomizedFormMetadata::has_id() const {
  return _internal_has_id();
}
inline void AutofillRandomizedFormMetadata::clear_id() {
  if (id_ != nullptr) id_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::autofill::AutofillRandomizedValue& AutofillRandomizedFormMetadata::_internal_id() const {
  const ::autofill::AutofillRandomizedValue* p = id_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill::AutofillRandomizedValue&>(
      ::autofill::_AutofillRandomizedValue_default_instance_);
}
inline const ::autofill::AutofillRandomizedValue& AutofillRandomizedFormMetadata::id() const {
  // @@protoc_insertion_point(field_get:autofill.AutofillRandomizedFormMetadata.id)
  return _internal_id();
}
inline void AutofillRandomizedFormMetadata::unsafe_arena_set_allocated_id(
    ::autofill::AutofillRandomizedValue* id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(id_);
  }
  id_ = id;
  if (id) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill.AutofillRandomizedFormMetadata.id)
}
inline ::autofill::AutofillRandomizedValue* AutofillRandomizedFormMetadata::release_id() {
  _has_bits_[0] &= ~0x00000001u;
  ::autofill::AutofillRandomizedValue* temp = id_;
  id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill::AutofillRandomizedValue* AutofillRandomizedFormMetadata::unsafe_arena_release_id() {
  // @@protoc_insertion_point(field_release:autofill.AutofillRandomizedFormMetadata.id)
  _has_bits_[0] &= ~0x00000001u;
  ::autofill::AutofillRandomizedValue* temp = id_;
  id_ = nullptr;
  return temp;
}
inline ::autofill::AutofillRandomizedValue* AutofillRandomizedFormMetadata::_internal_mutable_id() {
  _has_bits_[0] |= 0x00000001u;
  if (id_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill::AutofillRandomizedValue>(GetArenaForAllocation());
    id_ = p;
  }
  return id_;
}
inline ::autofill::AutofillRandomizedValue* AutofillRandomizedFormMetadata::mutable_id() {
  ::autofill::AutofillRandomizedValue* _msg = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:autofill.AutofillRandomizedFormMetadata.id)
  return _msg;
}
inline void AutofillRandomizedFormMetadata::set_allocated_id(::autofill::AutofillRandomizedValue* id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete id_;
  }
  if (id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(id);
    if (message_arena != submessage_arena) {
      id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, id, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  id_ = id;
  // @@protoc_insertion_point(field_set_allocated:autofill.AutofillRandomizedFormMetadata.id)
}

// optional .autofill.AutofillRandomizedValue name = 2;
inline bool AutofillRandomizedFormMetadata::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || name_ != nullptr);
  return value;
}
inline bool AutofillRandomizedFormMetadata::has_name() const {
  return _internal_has_name();
}
inline void AutofillRandomizedFormMetadata::clear_name() {
  if (name_ != nullptr) name_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::autofill::AutofillRandomizedValue& AutofillRandomizedFormMetadata::_internal_name() const {
  const ::autofill::AutofillRandomizedValue* p = name_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill::AutofillRandomizedValue&>(
      ::autofill::_AutofillRandomizedValue_default_instance_);
}
inline const ::autofill::AutofillRandomizedValue& AutofillRandomizedFormMetadata::name() const {
  // @@protoc_insertion_point(field_get:autofill.AutofillRandomizedFormMetadata.name)
  return _internal_name();
}
inline void AutofillRandomizedFormMetadata::unsafe_arena_set_allocated_name(
    ::autofill::AutofillRandomizedValue* name) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(name_);
  }
  name_ = name;
  if (name) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill.AutofillRandomizedFormMetadata.name)
}
inline ::autofill::AutofillRandomizedValue* AutofillRandomizedFormMetadata::release_name() {
  _has_bits_[0] &= ~0x00000002u;
  ::autofill::AutofillRandomizedValue* temp = name_;
  name_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill::AutofillRandomizedValue* AutofillRandomizedFormMetadata::unsafe_arena_release_name() {
  // @@protoc_insertion_point(field_release:autofill.AutofillRandomizedFormMetadata.name)
  _has_bits_[0] &= ~0x00000002u;
  ::autofill::AutofillRandomizedValue* temp = name_;
  name_ = nullptr;
  return temp;
}
inline ::autofill::AutofillRandomizedValue* AutofillRandomizedFormMetadata::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000002u;
  if (name_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill::AutofillRandomizedValue>(GetArenaForAllocation());
    name_ = p;
  }
  return name_;
}
inline ::autofill::AutofillRandomizedValue* AutofillRandomizedFormMetadata::mutable_name() {
  ::autofill::AutofillRandomizedValue* _msg = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:autofill.AutofillRandomizedFormMetadata.name)
  return _msg;
}
inline void AutofillRandomizedFormMetadata::set_allocated_name(::autofill::AutofillRandomizedValue* name) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete name_;
  }
  if (name) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(name);
    if (message_arena != submessage_arena) {
      name = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, name, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  name_ = name;
  // @@protoc_insertion_point(field_set_allocated:autofill.AutofillRandomizedFormMetadata.name)
}

// optional .autofill.AutofillRandomizedValue action = 3;
inline bool AutofillRandomizedFormMetadata::_internal_has_action() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || action_ != nullptr);
  return value;
}
inline bool AutofillRandomizedFormMetadata::has_action() const {
  return _internal_has_action();
}
inline void AutofillRandomizedFormMetadata::clear_action() {
  if (action_ != nullptr) action_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::autofill::AutofillRandomizedValue& AutofillRandomizedFormMetadata::_internal_action() const {
  const ::autofill::AutofillRandomizedValue* p = action_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill::AutofillRandomizedValue&>(
      ::autofill::_AutofillRandomizedValue_default_instance_);
}
inline const ::autofill::AutofillRandomizedValue& AutofillRandomizedFormMetadata::action() const {
  // @@protoc_insertion_point(field_get:autofill.AutofillRandomizedFormMetadata.action)
  return _internal_action();
}
inline void AutofillRandomizedFormMetadata::unsafe_arena_set_allocated_action(
    ::autofill::AutofillRandomizedValue* action) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(action_);
  }
  action_ = action;
  if (action) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill.AutofillRandomizedFormMetadata.action)
}
inline ::autofill::AutofillRandomizedValue* AutofillRandomizedFormMetadata::release_action() {
  _has_bits_[0] &= ~0x00000004u;
  ::autofill::AutofillRandomizedValue* temp = action_;
  action_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill::AutofillRandomizedValue* AutofillRandomizedFormMetadata::unsafe_arena_release_action() {
  // @@protoc_insertion_point(field_release:autofill.AutofillRandomizedFormMetadata.action)
  _has_bits_[0] &= ~0x00000004u;
  ::autofill::AutofillRandomizedValue* temp = action_;
  action_ = nullptr;
  return temp;
}
inline ::autofill::AutofillRandomizedValue* AutofillRandomizedFormMetadata::_internal_mutable_action() {
  _has_bits_[0] |= 0x00000004u;
  if (action_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill::AutofillRandomizedValue>(GetArenaForAllocation());
    action_ = p;
  }
  return action_;
}
inline ::autofill::AutofillRandomizedValue* AutofillRandomizedFormMetadata::mutable_action() {
  ::autofill::AutofillRandomizedValue* _msg = _internal_mutable_action();
  // @@protoc_insertion_point(field_mutable:autofill.AutofillRandomizedFormMetadata.action)
  return _msg;
}
inline void AutofillRandomizedFormMetadata::set_allocated_action(::autofill::AutofillRandomizedValue* action) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete action_;
  }
  if (action) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(action);
    if (message_arena != submessage_arena) {
      action = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, action, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  action_ = action;
  // @@protoc_insertion_point(field_set_allocated:autofill.AutofillRandomizedFormMetadata.action)
}

// optional .autofill.AutofillRandomizedValue url = 4;
inline bool AutofillRandomizedFormMetadata::_internal_has_url() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || url_ != nullptr);
  return value;
}
inline bool AutofillRandomizedFormMetadata::has_url() const {
  return _internal_has_url();
}
inline void AutofillRandomizedFormMetadata::clear_url() {
  if (url_ != nullptr) url_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::autofill::AutofillRandomizedValue& AutofillRandomizedFormMetadata::_internal_url() const {
  const ::autofill::AutofillRandomizedValue* p = url_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill::AutofillRandomizedValue&>(
      ::autofill::_AutofillRandomizedValue_default_instance_);
}
inline const ::autofill::AutofillRandomizedValue& AutofillRandomizedFormMetadata::url() const {
  // @@protoc_insertion_point(field_get:autofill.AutofillRandomizedFormMetadata.url)
  return _internal_url();
}
inline void AutofillRandomizedFormMetadata::unsafe_arena_set_allocated_url(
    ::autofill::AutofillRandomizedValue* url) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(url_);
  }
  url_ = url;
  if (url) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill.AutofillRandomizedFormMetadata.url)
}
inline ::autofill::AutofillRandomizedValue* AutofillRandomizedFormMetadata::release_url() {
  _has_bits_[0] &= ~0x00000008u;
  ::autofill::AutofillRandomizedValue* temp = url_;
  url_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill::AutofillRandomizedValue* AutofillRandomizedFormMetadata::unsafe_arena_release_url() {
  // @@protoc_insertion_point(field_release:autofill.AutofillRandomizedFormMetadata.url)
  _has_bits_[0] &= ~0x00000008u;
  ::autofill::AutofillRandomizedValue* temp = url_;
  url_ = nullptr;
  return temp;
}
inline ::autofill::AutofillRandomizedValue* AutofillRandomizedFormMetadata::_internal_mutable_url() {
  _has_bits_[0] |= 0x00000008u;
  if (url_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill::AutofillRandomizedValue>(GetArenaForAllocation());
    url_ = p;
  }
  return url_;
}
inline ::autofill::AutofillRandomizedValue* AutofillRandomizedFormMetadata::mutable_url() {
  ::autofill::AutofillRandomizedValue* _msg = _internal_mutable_url();
  // @@protoc_insertion_point(field_mutable:autofill.AutofillRandomizedFormMetadata.url)
  return _msg;
}
inline void AutofillRandomizedFormMetadata::set_allocated_url(::autofill::AutofillRandomizedValue* url) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete url_;
  }
  if (url) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(url);
    if (message_arena != submessage_arena) {
      url = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, url, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  url_ = url;
  // @@protoc_insertion_point(field_set_allocated:autofill.AutofillRandomizedFormMetadata.url)
}

// repeated .autofill.AutofillRandomizedFormMetadata.ButtonTitle button_title = 5;
inline int AutofillRandomizedFormMetadata::_internal_button_title_size() const {
  return button_title_.size();
}
inline int AutofillRandomizedFormMetadata::button_title_size() const {
  return _internal_button_title_size();
}
inline void AutofillRandomizedFormMetadata::clear_button_title() {
  button_title_.Clear();
}
inline ::autofill::AutofillRandomizedFormMetadata_ButtonTitle* AutofillRandomizedFormMetadata::mutable_button_title(int index) {
  // @@protoc_insertion_point(field_mutable:autofill.AutofillRandomizedFormMetadata.button_title)
  return button_title_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill::AutofillRandomizedFormMetadata_ButtonTitle >*
AutofillRandomizedFormMetadata::mutable_button_title() {
  // @@protoc_insertion_point(field_mutable_list:autofill.AutofillRandomizedFormMetadata.button_title)
  return &button_title_;
}
inline const ::autofill::AutofillRandomizedFormMetadata_ButtonTitle& AutofillRandomizedFormMetadata::_internal_button_title(int index) const {
  return button_title_.Get(index);
}
inline const ::autofill::AutofillRandomizedFormMetadata_ButtonTitle& AutofillRandomizedFormMetadata::button_title(int index) const {
  // @@protoc_insertion_point(field_get:autofill.AutofillRandomizedFormMetadata.button_title)
  return _internal_button_title(index);
}
inline ::autofill::AutofillRandomizedFormMetadata_ButtonTitle* AutofillRandomizedFormMetadata::_internal_add_button_title() {
  return button_title_.Add();
}
inline ::autofill::AutofillRandomizedFormMetadata_ButtonTitle* AutofillRandomizedFormMetadata::add_button_title() {
  ::autofill::AutofillRandomizedFormMetadata_ButtonTitle* _add = _internal_add_button_title();
  // @@protoc_insertion_point(field_add:autofill.AutofillRandomizedFormMetadata.button_title)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill::AutofillRandomizedFormMetadata_ButtonTitle >&
AutofillRandomizedFormMetadata::button_title() const {
  // @@protoc_insertion_point(field_list:autofill.AutofillRandomizedFormMetadata.button_title)
  return button_title_;
}

// -------------------------------------------------------------------

// AutofillRandomizedFieldMetadata

// optional .autofill.AutofillRandomizedValue id = 1;
inline bool AutofillRandomizedFieldMetadata::_internal_has_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || id_ != nullptr);
  return value;
}
inline bool AutofillRandomizedFieldMetadata::has_id() const {
  return _internal_has_id();
}
inline void AutofillRandomizedFieldMetadata::clear_id() {
  if (id_ != nullptr) id_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::autofill::AutofillRandomizedValue& AutofillRandomizedFieldMetadata::_internal_id() const {
  const ::autofill::AutofillRandomizedValue* p = id_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill::AutofillRandomizedValue&>(
      ::autofill::_AutofillRandomizedValue_default_instance_);
}
inline const ::autofill::AutofillRandomizedValue& AutofillRandomizedFieldMetadata::id() const {
  // @@protoc_insertion_point(field_get:autofill.AutofillRandomizedFieldMetadata.id)
  return _internal_id();
}
inline void AutofillRandomizedFieldMetadata::unsafe_arena_set_allocated_id(
    ::autofill::AutofillRandomizedValue* id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(id_);
  }
  id_ = id;
  if (id) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill.AutofillRandomizedFieldMetadata.id)
}
inline ::autofill::AutofillRandomizedValue* AutofillRandomizedFieldMetadata::release_id() {
  _has_bits_[0] &= ~0x00000001u;
  ::autofill::AutofillRandomizedValue* temp = id_;
  id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill::AutofillRandomizedValue* AutofillRandomizedFieldMetadata::unsafe_arena_release_id() {
  // @@protoc_insertion_point(field_release:autofill.AutofillRandomizedFieldMetadata.id)
  _has_bits_[0] &= ~0x00000001u;
  ::autofill::AutofillRandomizedValue* temp = id_;
  id_ = nullptr;
  return temp;
}
inline ::autofill::AutofillRandomizedValue* AutofillRandomizedFieldMetadata::_internal_mutable_id() {
  _has_bits_[0] |= 0x00000001u;
  if (id_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill::AutofillRandomizedValue>(GetArenaForAllocation());
    id_ = p;
  }
  return id_;
}
inline ::autofill::AutofillRandomizedValue* AutofillRandomizedFieldMetadata::mutable_id() {
  ::autofill::AutofillRandomizedValue* _msg = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:autofill.AutofillRandomizedFieldMetadata.id)
  return _msg;
}
inline void AutofillRandomizedFieldMetadata::set_allocated_id(::autofill::AutofillRandomizedValue* id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete id_;
  }
  if (id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(id);
    if (message_arena != submessage_arena) {
      id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, id, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  id_ = id;
  // @@protoc_insertion_point(field_set_allocated:autofill.AutofillRandomizedFieldMetadata.id)
}

// optional .autofill.AutofillRandomizedValue name = 2;
inline bool AutofillRandomizedFieldMetadata::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || name_ != nullptr);
  return value;
}
inline bool AutofillRandomizedFieldMetadata::has_name() const {
  return _internal_has_name();
}
inline void AutofillRandomizedFieldMetadata::clear_name() {
  if (name_ != nullptr) name_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::autofill::AutofillRandomizedValue& AutofillRandomizedFieldMetadata::_internal_name() const {
  const ::autofill::AutofillRandomizedValue* p = name_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill::AutofillRandomizedValue&>(
      ::autofill::_AutofillRandomizedValue_default_instance_);
}
inline const ::autofill::AutofillRandomizedValue& AutofillRandomizedFieldMetadata::name() const {
  // @@protoc_insertion_point(field_get:autofill.AutofillRandomizedFieldMetadata.name)
  return _internal_name();
}
inline void AutofillRandomizedFieldMetadata::unsafe_arena_set_allocated_name(
    ::autofill::AutofillRandomizedValue* name) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(name_);
  }
  name_ = name;
  if (name) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill.AutofillRandomizedFieldMetadata.name)
}
inline ::autofill::AutofillRandomizedValue* AutofillRandomizedFieldMetadata::release_name() {
  _has_bits_[0] &= ~0x00000002u;
  ::autofill::AutofillRandomizedValue* temp = name_;
  name_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill::AutofillRandomizedValue* AutofillRandomizedFieldMetadata::unsafe_arena_release_name() {
  // @@protoc_insertion_point(field_release:autofill.AutofillRandomizedFieldMetadata.name)
  _has_bits_[0] &= ~0x00000002u;
  ::autofill::AutofillRandomizedValue* temp = name_;
  name_ = nullptr;
  return temp;
}
inline ::autofill::AutofillRandomizedValue* AutofillRandomizedFieldMetadata::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000002u;
  if (name_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill::AutofillRandomizedValue>(GetArenaForAllocation());
    name_ = p;
  }
  return name_;
}
inline ::autofill::AutofillRandomizedValue* AutofillRandomizedFieldMetadata::mutable_name() {
  ::autofill::AutofillRandomizedValue* _msg = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:autofill.AutofillRandomizedFieldMetadata.name)
  return _msg;
}
inline void AutofillRandomizedFieldMetadata::set_allocated_name(::autofill::AutofillRandomizedValue* name) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete name_;
  }
  if (name) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(name);
    if (message_arena != submessage_arena) {
      name = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, name, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  name_ = name;
  // @@protoc_insertion_point(field_set_allocated:autofill.AutofillRandomizedFieldMetadata.name)
}

// optional .autofill.AutofillRandomizedValue type = 3;
inline bool AutofillRandomizedFieldMetadata::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || type_ != nullptr);
  return value;
}
inline bool AutofillRandomizedFieldMetadata::has_type() const {
  return _internal_has_type();
}
inline void AutofillRandomizedFieldMetadata::clear_type() {
  if (type_ != nullptr) type_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::autofill::AutofillRandomizedValue& AutofillRandomizedFieldMetadata::_internal_type() const {
  const ::autofill::AutofillRandomizedValue* p = type_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill::AutofillRandomizedValue&>(
      ::autofill::_AutofillRandomizedValue_default_instance_);
}
inline const ::autofill::AutofillRandomizedValue& AutofillRandomizedFieldMetadata::type() const {
  // @@protoc_insertion_point(field_get:autofill.AutofillRandomizedFieldMetadata.type)
  return _internal_type();
}
inline void AutofillRandomizedFieldMetadata::unsafe_arena_set_allocated_type(
    ::autofill::AutofillRandomizedValue* type) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(type_);
  }
  type_ = type;
  if (type) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill.AutofillRandomizedFieldMetadata.type)
}
inline ::autofill::AutofillRandomizedValue* AutofillRandomizedFieldMetadata::release_type() {
  _has_bits_[0] &= ~0x00000004u;
  ::autofill::AutofillRandomizedValue* temp = type_;
  type_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill::AutofillRandomizedValue* AutofillRandomizedFieldMetadata::unsafe_arena_release_type() {
  // @@protoc_insertion_point(field_release:autofill.AutofillRandomizedFieldMetadata.type)
  _has_bits_[0] &= ~0x00000004u;
  ::autofill::AutofillRandomizedValue* temp = type_;
  type_ = nullptr;
  return temp;
}
inline ::autofill::AutofillRandomizedValue* AutofillRandomizedFieldMetadata::_internal_mutable_type() {
  _has_bits_[0] |= 0x00000004u;
  if (type_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill::AutofillRandomizedValue>(GetArenaForAllocation());
    type_ = p;
  }
  return type_;
}
inline ::autofill::AutofillRandomizedValue* AutofillRandomizedFieldMetadata::mutable_type() {
  ::autofill::AutofillRandomizedValue* _msg = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:autofill.AutofillRandomizedFieldMetadata.type)
  return _msg;
}
inline void AutofillRandomizedFieldMetadata::set_allocated_type(::autofill::AutofillRandomizedValue* type) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete type_;
  }
  if (type) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(type);
    if (message_arena != submessage_arena) {
      type = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, type, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  type_ = type;
  // @@protoc_insertion_point(field_set_allocated:autofill.AutofillRandomizedFieldMetadata.type)
}

// optional .autofill.AutofillRandomizedValue label = 4;
inline bool AutofillRandomizedFieldMetadata::_internal_has_label() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || label_ != nullptr);
  return value;
}
inline bool AutofillRandomizedFieldMetadata::has_label() const {
  return _internal_has_label();
}
inline void AutofillRandomizedFieldMetadata::clear_label() {
  if (label_ != nullptr) label_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::autofill::AutofillRandomizedValue& AutofillRandomizedFieldMetadata::_internal_label() const {
  const ::autofill::AutofillRandomizedValue* p = label_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill::AutofillRandomizedValue&>(
      ::autofill::_AutofillRandomizedValue_default_instance_);
}
inline const ::autofill::AutofillRandomizedValue& AutofillRandomizedFieldMetadata::label() const {
  // @@protoc_insertion_point(field_get:autofill.AutofillRandomizedFieldMetadata.label)
  return _internal_label();
}
inline void AutofillRandomizedFieldMetadata::unsafe_arena_set_allocated_label(
    ::autofill::AutofillRandomizedValue* label) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(label_);
  }
  label_ = label;
  if (label) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill.AutofillRandomizedFieldMetadata.label)
}
inline ::autofill::AutofillRandomizedValue* AutofillRandomizedFieldMetadata::release_label() {
  _has_bits_[0] &= ~0x00000008u;
  ::autofill::AutofillRandomizedValue* temp = label_;
  label_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill::AutofillRandomizedValue* AutofillRandomizedFieldMetadata::unsafe_arena_release_label() {
  // @@protoc_insertion_point(field_release:autofill.AutofillRandomizedFieldMetadata.label)
  _has_bits_[0] &= ~0x00000008u;
  ::autofill::AutofillRandomizedValue* temp = label_;
  label_ = nullptr;
  return temp;
}
inline ::autofill::AutofillRandomizedValue* AutofillRandomizedFieldMetadata::_internal_mutable_label() {
  _has_bits_[0] |= 0x00000008u;
  if (label_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill::AutofillRandomizedValue>(GetArenaForAllocation());
    label_ = p;
  }
  return label_;
}
inline ::autofill::AutofillRandomizedValue* AutofillRandomizedFieldMetadata::mutable_label() {
  ::autofill::AutofillRandomizedValue* _msg = _internal_mutable_label();
  // @@protoc_insertion_point(field_mutable:autofill.AutofillRandomizedFieldMetadata.label)
  return _msg;
}
inline void AutofillRandomizedFieldMetadata::set_allocated_label(::autofill::AutofillRandomizedValue* label) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete label_;
  }
  if (label) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(label);
    if (message_arena != submessage_arena) {
      label = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, label, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  label_ = label;
  // @@protoc_insertion_point(field_set_allocated:autofill.AutofillRandomizedFieldMetadata.label)
}

// optional .autofill.AutofillRandomizedValue aria_label = 5;
inline bool AutofillRandomizedFieldMetadata::_internal_has_aria_label() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || aria_label_ != nullptr);
  return value;
}
inline bool AutofillRandomizedFieldMetadata::has_aria_label() const {
  return _internal_has_aria_label();
}
inline void AutofillRandomizedFieldMetadata::clear_aria_label() {
  if (aria_label_ != nullptr) aria_label_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::autofill::AutofillRandomizedValue& AutofillRandomizedFieldMetadata::_internal_aria_label() const {
  const ::autofill::AutofillRandomizedValue* p = aria_label_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill::AutofillRandomizedValue&>(
      ::autofill::_AutofillRandomizedValue_default_instance_);
}
inline const ::autofill::AutofillRandomizedValue& AutofillRandomizedFieldMetadata::aria_label() const {
  // @@protoc_insertion_point(field_get:autofill.AutofillRandomizedFieldMetadata.aria_label)
  return _internal_aria_label();
}
inline void AutofillRandomizedFieldMetadata::unsafe_arena_set_allocated_aria_label(
    ::autofill::AutofillRandomizedValue* aria_label) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(aria_label_);
  }
  aria_label_ = aria_label;
  if (aria_label) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill.AutofillRandomizedFieldMetadata.aria_label)
}
inline ::autofill::AutofillRandomizedValue* AutofillRandomizedFieldMetadata::release_aria_label() {
  _has_bits_[0] &= ~0x00000010u;
  ::autofill::AutofillRandomizedValue* temp = aria_label_;
  aria_label_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill::AutofillRandomizedValue* AutofillRandomizedFieldMetadata::unsafe_arena_release_aria_label() {
  // @@protoc_insertion_point(field_release:autofill.AutofillRandomizedFieldMetadata.aria_label)
  _has_bits_[0] &= ~0x00000010u;
  ::autofill::AutofillRandomizedValue* temp = aria_label_;
  aria_label_ = nullptr;
  return temp;
}
inline ::autofill::AutofillRandomizedValue* AutofillRandomizedFieldMetadata::_internal_mutable_aria_label() {
  _has_bits_[0] |= 0x00000010u;
  if (aria_label_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill::AutofillRandomizedValue>(GetArenaForAllocation());
    aria_label_ = p;
  }
  return aria_label_;
}
inline ::autofill::AutofillRandomizedValue* AutofillRandomizedFieldMetadata::mutable_aria_label() {
  ::autofill::AutofillRandomizedValue* _msg = _internal_mutable_aria_label();
  // @@protoc_insertion_point(field_mutable:autofill.AutofillRandomizedFieldMetadata.aria_label)
  return _msg;
}
inline void AutofillRandomizedFieldMetadata::set_allocated_aria_label(::autofill::AutofillRandomizedValue* aria_label) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete aria_label_;
  }
  if (aria_label) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(aria_label);
    if (message_arena != submessage_arena) {
      aria_label = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, aria_label, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  aria_label_ = aria_label;
  // @@protoc_insertion_point(field_set_allocated:autofill.AutofillRandomizedFieldMetadata.aria_label)
}

// optional .autofill.AutofillRandomizedValue aria_description = 6;
inline bool AutofillRandomizedFieldMetadata::_internal_has_aria_description() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || aria_description_ != nullptr);
  return value;
}
inline bool AutofillRandomizedFieldMetadata::has_aria_description() const {
  return _internal_has_aria_description();
}
inline void AutofillRandomizedFieldMetadata::clear_aria_description() {
  if (aria_description_ != nullptr) aria_description_->Clear();
  _has_bits_[0] &= ~0x00000020u;
}
inline const ::autofill::AutofillRandomizedValue& AutofillRandomizedFieldMetadata::_internal_aria_description() const {
  const ::autofill::AutofillRandomizedValue* p = aria_description_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill::AutofillRandomizedValue&>(
      ::autofill::_AutofillRandomizedValue_default_instance_);
}
inline const ::autofill::AutofillRandomizedValue& AutofillRandomizedFieldMetadata::aria_description() const {
  // @@protoc_insertion_point(field_get:autofill.AutofillRandomizedFieldMetadata.aria_description)
  return _internal_aria_description();
}
inline void AutofillRandomizedFieldMetadata::unsafe_arena_set_allocated_aria_description(
    ::autofill::AutofillRandomizedValue* aria_description) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(aria_description_);
  }
  aria_description_ = aria_description;
  if (aria_description) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill.AutofillRandomizedFieldMetadata.aria_description)
}
inline ::autofill::AutofillRandomizedValue* AutofillRandomizedFieldMetadata::release_aria_description() {
  _has_bits_[0] &= ~0x00000020u;
  ::autofill::AutofillRandomizedValue* temp = aria_description_;
  aria_description_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill::AutofillRandomizedValue* AutofillRandomizedFieldMetadata::unsafe_arena_release_aria_description() {
  // @@protoc_insertion_point(field_release:autofill.AutofillRandomizedFieldMetadata.aria_description)
  _has_bits_[0] &= ~0x00000020u;
  ::autofill::AutofillRandomizedValue* temp = aria_description_;
  aria_description_ = nullptr;
  return temp;
}
inline ::autofill::AutofillRandomizedValue* AutofillRandomizedFieldMetadata::_internal_mutable_aria_description() {
  _has_bits_[0] |= 0x00000020u;
  if (aria_description_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill::AutofillRandomizedValue>(GetArenaForAllocation());
    aria_description_ = p;
  }
  return aria_description_;
}
inline ::autofill::AutofillRandomizedValue* AutofillRandomizedFieldMetadata::mutable_aria_description() {
  ::autofill::AutofillRandomizedValue* _msg = _internal_mutable_aria_description();
  // @@protoc_insertion_point(field_mutable:autofill.AutofillRandomizedFieldMetadata.aria_description)
  return _msg;
}
inline void AutofillRandomizedFieldMetadata::set_allocated_aria_description(::autofill::AutofillRandomizedValue* aria_description) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete aria_description_;
  }
  if (aria_description) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(aria_description);
    if (message_arena != submessage_arena) {
      aria_description = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, aria_description, submessage_arena);
    }
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  aria_description_ = aria_description;
  // @@protoc_insertion_point(field_set_allocated:autofill.AutofillRandomizedFieldMetadata.aria_description)
}

// optional .autofill.AutofillRandomizedValue css_class = 7;
inline bool AutofillRandomizedFieldMetadata::_internal_has_css_class() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || css_class_ != nullptr);
  return value;
}
inline bool AutofillRandomizedFieldMetadata::has_css_class() const {
  return _internal_has_css_class();
}
inline void AutofillRandomizedFieldMetadata::clear_css_class() {
  if (css_class_ != nullptr) css_class_->Clear();
  _has_bits_[0] &= ~0x00000040u;
}
inline const ::autofill::AutofillRandomizedValue& AutofillRandomizedFieldMetadata::_internal_css_class() const {
  const ::autofill::AutofillRandomizedValue* p = css_class_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill::AutofillRandomizedValue&>(
      ::autofill::_AutofillRandomizedValue_default_instance_);
}
inline const ::autofill::AutofillRandomizedValue& AutofillRandomizedFieldMetadata::css_class() const {
  // @@protoc_insertion_point(field_get:autofill.AutofillRandomizedFieldMetadata.css_class)
  return _internal_css_class();
}
inline void AutofillRandomizedFieldMetadata::unsafe_arena_set_allocated_css_class(
    ::autofill::AutofillRandomizedValue* css_class) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(css_class_);
  }
  css_class_ = css_class;
  if (css_class) {
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill.AutofillRandomizedFieldMetadata.css_class)
}
inline ::autofill::AutofillRandomizedValue* AutofillRandomizedFieldMetadata::release_css_class() {
  _has_bits_[0] &= ~0x00000040u;
  ::autofill::AutofillRandomizedValue* temp = css_class_;
  css_class_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill::AutofillRandomizedValue* AutofillRandomizedFieldMetadata::unsafe_arena_release_css_class() {
  // @@protoc_insertion_point(field_release:autofill.AutofillRandomizedFieldMetadata.css_class)
  _has_bits_[0] &= ~0x00000040u;
  ::autofill::AutofillRandomizedValue* temp = css_class_;
  css_class_ = nullptr;
  return temp;
}
inline ::autofill::AutofillRandomizedValue* AutofillRandomizedFieldMetadata::_internal_mutable_css_class() {
  _has_bits_[0] |= 0x00000040u;
  if (css_class_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill::AutofillRandomizedValue>(GetArenaForAllocation());
    css_class_ = p;
  }
  return css_class_;
}
inline ::autofill::AutofillRandomizedValue* AutofillRandomizedFieldMetadata::mutable_css_class() {
  ::autofill::AutofillRandomizedValue* _msg = _internal_mutable_css_class();
  // @@protoc_insertion_point(field_mutable:autofill.AutofillRandomizedFieldMetadata.css_class)
  return _msg;
}
inline void AutofillRandomizedFieldMetadata::set_allocated_css_class(::autofill::AutofillRandomizedValue* css_class) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete css_class_;
  }
  if (css_class) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(css_class);
    if (message_arena != submessage_arena) {
      css_class = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, css_class, submessage_arena);
    }
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  css_class_ = css_class;
  // @@protoc_insertion_point(field_set_allocated:autofill.AutofillRandomizedFieldMetadata.css_class)
}

// optional .autofill.AutofillRandomizedValue placeholder = 8;
inline bool AutofillRandomizedFieldMetadata::_internal_has_placeholder() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!value || placeholder_ != nullptr);
  return value;
}
inline bool AutofillRandomizedFieldMetadata::has_placeholder() const {
  return _internal_has_placeholder();
}
inline void AutofillRandomizedFieldMetadata::clear_placeholder() {
  if (placeholder_ != nullptr) placeholder_->Clear();
  _has_bits_[0] &= ~0x00000080u;
}
inline const ::autofill::AutofillRandomizedValue& AutofillRandomizedFieldMetadata::_internal_placeholder() const {
  const ::autofill::AutofillRandomizedValue* p = placeholder_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill::AutofillRandomizedValue&>(
      ::autofill::_AutofillRandomizedValue_default_instance_);
}
inline const ::autofill::AutofillRandomizedValue& AutofillRandomizedFieldMetadata::placeholder() const {
  // @@protoc_insertion_point(field_get:autofill.AutofillRandomizedFieldMetadata.placeholder)
  return _internal_placeholder();
}
inline void AutofillRandomizedFieldMetadata::unsafe_arena_set_allocated_placeholder(
    ::autofill::AutofillRandomizedValue* placeholder) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(placeholder_);
  }
  placeholder_ = placeholder;
  if (placeholder) {
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill.AutofillRandomizedFieldMetadata.placeholder)
}
inline ::autofill::AutofillRandomizedValue* AutofillRandomizedFieldMetadata::release_placeholder() {
  _has_bits_[0] &= ~0x00000080u;
  ::autofill::AutofillRandomizedValue* temp = placeholder_;
  placeholder_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill::AutofillRandomizedValue* AutofillRandomizedFieldMetadata::unsafe_arena_release_placeholder() {
  // @@protoc_insertion_point(field_release:autofill.AutofillRandomizedFieldMetadata.placeholder)
  _has_bits_[0] &= ~0x00000080u;
  ::autofill::AutofillRandomizedValue* temp = placeholder_;
  placeholder_ = nullptr;
  return temp;
}
inline ::autofill::AutofillRandomizedValue* AutofillRandomizedFieldMetadata::_internal_mutable_placeholder() {
  _has_bits_[0] |= 0x00000080u;
  if (placeholder_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill::AutofillRandomizedValue>(GetArenaForAllocation());
    placeholder_ = p;
  }
  return placeholder_;
}
inline ::autofill::AutofillRandomizedValue* AutofillRandomizedFieldMetadata::mutable_placeholder() {
  ::autofill::AutofillRandomizedValue* _msg = _internal_mutable_placeholder();
  // @@protoc_insertion_point(field_mutable:autofill.AutofillRandomizedFieldMetadata.placeholder)
  return _msg;
}
inline void AutofillRandomizedFieldMetadata::set_allocated_placeholder(::autofill::AutofillRandomizedValue* placeholder) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete placeholder_;
  }
  if (placeholder) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(placeholder);
    if (message_arena != submessage_arena) {
      placeholder = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, placeholder, submessage_arena);
    }
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  placeholder_ = placeholder;
  // @@protoc_insertion_point(field_set_allocated:autofill.AutofillRandomizedFieldMetadata.placeholder)
}

// optional .autofill.AutofillRandomizedValue initial_value_hash = 9;
inline bool AutofillRandomizedFieldMetadata::_internal_has_initial_value_hash() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  PROTOBUF_ASSUME(!value || initial_value_hash_ != nullptr);
  return value;
}
inline bool AutofillRandomizedFieldMetadata::has_initial_value_hash() const {
  return _internal_has_initial_value_hash();
}
inline void AutofillRandomizedFieldMetadata::clear_initial_value_hash() {
  if (initial_value_hash_ != nullptr) initial_value_hash_->Clear();
  _has_bits_[0] &= ~0x00000100u;
}
inline const ::autofill::AutofillRandomizedValue& AutofillRandomizedFieldMetadata::_internal_initial_value_hash() const {
  const ::autofill::AutofillRandomizedValue* p = initial_value_hash_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill::AutofillRandomizedValue&>(
      ::autofill::_AutofillRandomizedValue_default_instance_);
}
inline const ::autofill::AutofillRandomizedValue& AutofillRandomizedFieldMetadata::initial_value_hash() const {
  // @@protoc_insertion_point(field_get:autofill.AutofillRandomizedFieldMetadata.initial_value_hash)
  return _internal_initial_value_hash();
}
inline void AutofillRandomizedFieldMetadata::unsafe_arena_set_allocated_initial_value_hash(
    ::autofill::AutofillRandomizedValue* initial_value_hash) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(initial_value_hash_);
  }
  initial_value_hash_ = initial_value_hash;
  if (initial_value_hash) {
    _has_bits_[0] |= 0x00000100u;
  } else {
    _has_bits_[0] &= ~0x00000100u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill.AutofillRandomizedFieldMetadata.initial_value_hash)
}
inline ::autofill::AutofillRandomizedValue* AutofillRandomizedFieldMetadata::release_initial_value_hash() {
  _has_bits_[0] &= ~0x00000100u;
  ::autofill::AutofillRandomizedValue* temp = initial_value_hash_;
  initial_value_hash_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill::AutofillRandomizedValue* AutofillRandomizedFieldMetadata::unsafe_arena_release_initial_value_hash() {
  // @@protoc_insertion_point(field_release:autofill.AutofillRandomizedFieldMetadata.initial_value_hash)
  _has_bits_[0] &= ~0x00000100u;
  ::autofill::AutofillRandomizedValue* temp = initial_value_hash_;
  initial_value_hash_ = nullptr;
  return temp;
}
inline ::autofill::AutofillRandomizedValue* AutofillRandomizedFieldMetadata::_internal_mutable_initial_value_hash() {
  _has_bits_[0] |= 0x00000100u;
  if (initial_value_hash_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill::AutofillRandomizedValue>(GetArenaForAllocation());
    initial_value_hash_ = p;
  }
  return initial_value_hash_;
}
inline ::autofill::AutofillRandomizedValue* AutofillRandomizedFieldMetadata::mutable_initial_value_hash() {
  ::autofill::AutofillRandomizedValue* _msg = _internal_mutable_initial_value_hash();
  // @@protoc_insertion_point(field_mutable:autofill.AutofillRandomizedFieldMetadata.initial_value_hash)
  return _msg;
}
inline void AutofillRandomizedFieldMetadata::set_allocated_initial_value_hash(::autofill::AutofillRandomizedValue* initial_value_hash) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete initial_value_hash_;
  }
  if (initial_value_hash) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(initial_value_hash);
    if (message_arena != submessage_arena) {
      initial_value_hash = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, initial_value_hash, submessage_arena);
    }
    _has_bits_[0] |= 0x00000100u;
  } else {
    _has_bits_[0] &= ~0x00000100u;
  }
  initial_value_hash_ = initial_value_hash;
  // @@protoc_insertion_point(field_set_allocated:autofill.AutofillRandomizedFieldMetadata.initial_value_hash)
}

// optional .autofill.AutofillRandomizedValue autocomplete = 10;
inline bool AutofillRandomizedFieldMetadata::_internal_has_autocomplete() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  PROTOBUF_ASSUME(!value || autocomplete_ != nullptr);
  return value;
}
inline bool AutofillRandomizedFieldMetadata::has_autocomplete() const {
  return _internal_has_autocomplete();
}
inline void AutofillRandomizedFieldMetadata::clear_autocomplete() {
  if (autocomplete_ != nullptr) autocomplete_->Clear();
  _has_bits_[0] &= ~0x00000200u;
}
inline const ::autofill::AutofillRandomizedValue& AutofillRandomizedFieldMetadata::_internal_autocomplete() const {
  const ::autofill::AutofillRandomizedValue* p = autocomplete_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill::AutofillRandomizedValue&>(
      ::autofill::_AutofillRandomizedValue_default_instance_);
}
inline const ::autofill::AutofillRandomizedValue& AutofillRandomizedFieldMetadata::autocomplete() const {
  // @@protoc_insertion_point(field_get:autofill.AutofillRandomizedFieldMetadata.autocomplete)
  return _internal_autocomplete();
}
inline void AutofillRandomizedFieldMetadata::unsafe_arena_set_allocated_autocomplete(
    ::autofill::AutofillRandomizedValue* autocomplete) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(autocomplete_);
  }
  autocomplete_ = autocomplete;
  if (autocomplete) {
    _has_bits_[0] |= 0x00000200u;
  } else {
    _has_bits_[0] &= ~0x00000200u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill.AutofillRandomizedFieldMetadata.autocomplete)
}
inline ::autofill::AutofillRandomizedValue* AutofillRandomizedFieldMetadata::release_autocomplete() {
  _has_bits_[0] &= ~0x00000200u;
  ::autofill::AutofillRandomizedValue* temp = autocomplete_;
  autocomplete_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill::AutofillRandomizedValue* AutofillRandomizedFieldMetadata::unsafe_arena_release_autocomplete() {
  // @@protoc_insertion_point(field_release:autofill.AutofillRandomizedFieldMetadata.autocomplete)
  _has_bits_[0] &= ~0x00000200u;
  ::autofill::AutofillRandomizedValue* temp = autocomplete_;
  autocomplete_ = nullptr;
  return temp;
}
inline ::autofill::AutofillRandomizedValue* AutofillRandomizedFieldMetadata::_internal_mutable_autocomplete() {
  _has_bits_[0] |= 0x00000200u;
  if (autocomplete_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill::AutofillRandomizedValue>(GetArenaForAllocation());
    autocomplete_ = p;
  }
  return autocomplete_;
}
inline ::autofill::AutofillRandomizedValue* AutofillRandomizedFieldMetadata::mutable_autocomplete() {
  ::autofill::AutofillRandomizedValue* _msg = _internal_mutable_autocomplete();
  // @@protoc_insertion_point(field_mutable:autofill.AutofillRandomizedFieldMetadata.autocomplete)
  return _msg;
}
inline void AutofillRandomizedFieldMetadata::set_allocated_autocomplete(::autofill::AutofillRandomizedValue* autocomplete) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete autocomplete_;
  }
  if (autocomplete) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(autocomplete);
    if (message_arena != submessage_arena) {
      autocomplete = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, autocomplete, submessage_arena);
    }
    _has_bits_[0] |= 0x00000200u;
  } else {
    _has_bits_[0] &= ~0x00000200u;
  }
  autocomplete_ = autocomplete;
  // @@protoc_insertion_point(field_set_allocated:autofill.AutofillRandomizedFieldMetadata.autocomplete)
}

// -------------------------------------------------------------------

// AutofillUploadContents_Field_AutofillTypeValiditiesPair

// required int32 type = 1;
inline bool AutofillUploadContents_Field_AutofillTypeValiditiesPair::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AutofillUploadContents_Field_AutofillTypeValiditiesPair::has_type() const {
  return _internal_has_type();
}
inline void AutofillUploadContents_Field_AutofillTypeValiditiesPair::clear_type() {
  type_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline int32_t AutofillUploadContents_Field_AutofillTypeValiditiesPair::_internal_type() const {
  return type_;
}
inline int32_t AutofillUploadContents_Field_AutofillTypeValiditiesPair::type() const {
  // @@protoc_insertion_point(field_get:autofill.AutofillUploadContents.Field.AutofillTypeValiditiesPair.type)
  return _internal_type();
}
inline void AutofillUploadContents_Field_AutofillTypeValiditiesPair::_internal_set_type(int32_t value) {
  _has_bits_[0] |= 0x00000001u;
  type_ = value;
}
inline void AutofillUploadContents_Field_AutofillTypeValiditiesPair::set_type(int32_t value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:autofill.AutofillUploadContents.Field.AutofillTypeValiditiesPair.type)
}

// repeated int32 validity = 2;
inline int AutofillUploadContents_Field_AutofillTypeValiditiesPair::_internal_validity_size() const {
  return validity_.size();
}
inline int AutofillUploadContents_Field_AutofillTypeValiditiesPair::validity_size() const {
  return _internal_validity_size();
}
inline void AutofillUploadContents_Field_AutofillTypeValiditiesPair::clear_validity() {
  validity_.Clear();
}
inline int32_t AutofillUploadContents_Field_AutofillTypeValiditiesPair::_internal_validity(int index) const {
  return validity_.Get(index);
}
inline int32_t AutofillUploadContents_Field_AutofillTypeValiditiesPair::validity(int index) const {
  // @@protoc_insertion_point(field_get:autofill.AutofillUploadContents.Field.AutofillTypeValiditiesPair.validity)
  return _internal_validity(index);
}
inline void AutofillUploadContents_Field_AutofillTypeValiditiesPair::set_validity(int index, int32_t value) {
  validity_.Set(index, value);
  // @@protoc_insertion_point(field_set:autofill.AutofillUploadContents.Field.AutofillTypeValiditiesPair.validity)
}
inline void AutofillUploadContents_Field_AutofillTypeValiditiesPair::_internal_add_validity(int32_t value) {
  validity_.Add(value);
}
inline void AutofillUploadContents_Field_AutofillTypeValiditiesPair::add_validity(int32_t value) {
  _internal_add_validity(value);
  // @@protoc_insertion_point(field_add:autofill.AutofillUploadContents.Field.AutofillTypeValiditiesPair.validity)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
AutofillUploadContents_Field_AutofillTypeValiditiesPair::_internal_validity() const {
  return validity_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
AutofillUploadContents_Field_AutofillTypeValiditiesPair::validity() const {
  // @@protoc_insertion_point(field_list:autofill.AutofillUploadContents.Field.AutofillTypeValiditiesPair.validity)
  return _internal_validity();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
AutofillUploadContents_Field_AutofillTypeValiditiesPair::_internal_mutable_validity() {
  return &validity_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
AutofillUploadContents_Field_AutofillTypeValiditiesPair::mutable_validity() {
  // @@protoc_insertion_point(field_mutable_list:autofill.AutofillUploadContents.Field.AutofillTypeValiditiesPair.validity)
  return _internal_mutable_validity();
}

// -------------------------------------------------------------------

// AutofillUploadContents_Field

// required fixed32 signature = 6;
inline bool AutofillUploadContents_Field::_internal_has_signature() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool AutofillUploadContents_Field::has_signature() const {
  return _internal_has_signature();
}
inline void AutofillUploadContents_Field::clear_signature() {
  signature_ = 0u;
  _has_bits_[0] &= ~0x00000040u;
}
inline uint32_t AutofillUploadContents_Field::_internal_signature() const {
  return signature_;
}
inline uint32_t AutofillUploadContents_Field::signature() const {
  // @@protoc_insertion_point(field_get:autofill.AutofillUploadContents.Field.signature)
  return _internal_signature();
}
inline void AutofillUploadContents_Field::_internal_set_signature(uint32_t value) {
  _has_bits_[0] |= 0x00000040u;
  signature_ = value;
}
inline void AutofillUploadContents_Field::set_signature(uint32_t value) {
  _internal_set_signature(value);
  // @@protoc_insertion_point(field_set:autofill.AutofillUploadContents.Field.signature)
}

// repeated fixed32 autofill_type = 7;
inline int AutofillUploadContents_Field::_internal_autofill_type_size() const {
  return autofill_type_.size();
}
inline int AutofillUploadContents_Field::autofill_type_size() const {
  return _internal_autofill_type_size();
}
inline void AutofillUploadContents_Field::clear_autofill_type() {
  autofill_type_.Clear();
}
inline uint32_t AutofillUploadContents_Field::_internal_autofill_type(int index) const {
  return autofill_type_.Get(index);
}
inline uint32_t AutofillUploadContents_Field::autofill_type(int index) const {
  // @@protoc_insertion_point(field_get:autofill.AutofillUploadContents.Field.autofill_type)
  return _internal_autofill_type(index);
}
inline void AutofillUploadContents_Field::set_autofill_type(int index, uint32_t value) {
  autofill_type_.Set(index, value);
  // @@protoc_insertion_point(field_set:autofill.AutofillUploadContents.Field.autofill_type)
}
inline void AutofillUploadContents_Field::_internal_add_autofill_type(uint32_t value) {
  autofill_type_.Add(value);
}
inline void AutofillUploadContents_Field::add_autofill_type(uint32_t value) {
  _internal_add_autofill_type(value);
  // @@protoc_insertion_point(field_add:autofill.AutofillUploadContents.Field.autofill_type)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
AutofillUploadContents_Field::_internal_autofill_type() const {
  return autofill_type_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
AutofillUploadContents_Field::autofill_type() const {
  // @@protoc_insertion_point(field_list:autofill.AutofillUploadContents.Field.autofill_type)
  return _internal_autofill_type();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
AutofillUploadContents_Field::_internal_mutable_autofill_type() {
  return &autofill_type_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
AutofillUploadContents_Field::mutable_autofill_type() {
  // @@protoc_insertion_point(field_mutable_list:autofill.AutofillUploadContents.Field.autofill_type)
  return _internal_mutable_autofill_type();
}

// optional string name = 8;
inline bool AutofillUploadContents_Field::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AutofillUploadContents_Field::has_name() const {
  return _internal_has_name();
}
inline void AutofillUploadContents_Field::clear_name() {
  name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AutofillUploadContents_Field::name() const {
  // @@protoc_insertion_point(field_get:autofill.AutofillUploadContents.Field.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AutofillUploadContents_Field::set_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill.AutofillUploadContents.Field.name)
}
inline std::string* AutofillUploadContents_Field::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:autofill.AutofillUploadContents.Field.name)
  return _s;
}
inline const std::string& AutofillUploadContents_Field::_internal_name() const {
  return name_.Get();
}
inline void AutofillUploadContents_Field::_internal_set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(value, GetArenaForAllocation());
}
inline std::string* AutofillUploadContents_Field::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  return name_.Mutable(GetArenaForAllocation());
}
inline std::string* AutofillUploadContents_Field::release_name() {
  // @@protoc_insertion_point(field_release:autofill.AutofillUploadContents.Field.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault()) {
    name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AutofillUploadContents_Field::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault()) {
    name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill.AutofillUploadContents.Field.name)
}

// optional string autocomplete = 9;
inline bool AutofillUploadContents_Field::_internal_has_autocomplete() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool AutofillUploadContents_Field::has_autocomplete() const {
  return _internal_has_autocomplete();
}
inline void AutofillUploadContents_Field::clear_autocomplete() {
  autocomplete_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& AutofillUploadContents_Field::autocomplete() const {
  // @@protoc_insertion_point(field_get:autofill.AutofillUploadContents.Field.autocomplete)
  return _internal_autocomplete();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AutofillUploadContents_Field::set_autocomplete(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 autocomplete_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill.AutofillUploadContents.Field.autocomplete)
}
inline std::string* AutofillUploadContents_Field::mutable_autocomplete() {
  std::string* _s = _internal_mutable_autocomplete();
  // @@protoc_insertion_point(field_mutable:autofill.AutofillUploadContents.Field.autocomplete)
  return _s;
}
inline const std::string& AutofillUploadContents_Field::_internal_autocomplete() const {
  return autocomplete_.Get();
}
inline void AutofillUploadContents_Field::_internal_set_autocomplete(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  autocomplete_.Set(value, GetArenaForAllocation());
}
inline std::string* AutofillUploadContents_Field::_internal_mutable_autocomplete() {
  _has_bits_[0] |= 0x00000002u;
  return autocomplete_.Mutable(GetArenaForAllocation());
}
inline std::string* AutofillUploadContents_Field::release_autocomplete() {
  // @@protoc_insertion_point(field_release:autofill.AutofillUploadContents.Field.autocomplete)
  if (!_internal_has_autocomplete()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = autocomplete_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (autocomplete_.IsDefault()) {
    autocomplete_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AutofillUploadContents_Field::set_allocated_autocomplete(std::string* autocomplete) {
  if (autocomplete != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  autocomplete_.SetAllocated(autocomplete, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (autocomplete_.IsDefault()) {
    autocomplete_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill.AutofillUploadContents.Field.autocomplete)
}

// optional string type = 10;
inline bool AutofillUploadContents_Field::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool AutofillUploadContents_Field::has_type() const {
  return _internal_has_type();
}
inline void AutofillUploadContents_Field::clear_type() {
  type_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& AutofillUploadContents_Field::type() const {
  // @@protoc_insertion_point(field_get:autofill.AutofillUploadContents.Field.type)
  return _internal_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AutofillUploadContents_Field::set_type(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill.AutofillUploadContents.Field.type)
}
inline std::string* AutofillUploadContents_Field::mutable_type() {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:autofill.AutofillUploadContents.Field.type)
  return _s;
}
inline const std::string& AutofillUploadContents_Field::_internal_type() const {
  return type_.Get();
}
inline void AutofillUploadContents_Field::_internal_set_type(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  type_.Set(value, GetArenaForAllocation());
}
inline std::string* AutofillUploadContents_Field::_internal_mutable_type() {
  _has_bits_[0] |= 0x00000004u;
  return type_.Mutable(GetArenaForAllocation());
}
inline std::string* AutofillUploadContents_Field::release_type() {
  // @@protoc_insertion_point(field_release:autofill.AutofillUploadContents.Field.type)
  if (!_internal_has_type()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = type_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (type_.IsDefault()) {
    type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AutofillUploadContents_Field::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  type_.SetAllocated(type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (type_.IsDefault()) {
    type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill.AutofillUploadContents.Field.type)
}

// optional .autofill.AutofillRandomizedFieldMetadata randomized_field_metadata = 33;
inline bool AutofillUploadContents_Field::_internal_has_randomized_field_metadata() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || randomized_field_metadata_ != nullptr);
  return value;
}
inline bool AutofillUploadContents_Field::has_randomized_field_metadata() const {
  return _internal_has_randomized_field_metadata();
}
inline void AutofillUploadContents_Field::clear_randomized_field_metadata() {
  if (randomized_field_metadata_ != nullptr) randomized_field_metadata_->Clear();
  _has_bits_[0] &= ~0x00000020u;
}
inline const ::autofill::AutofillRandomizedFieldMetadata& AutofillUploadContents_Field::_internal_randomized_field_metadata() const {
  const ::autofill::AutofillRandomizedFieldMetadata* p = randomized_field_metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill::AutofillRandomizedFieldMetadata&>(
      ::autofill::_AutofillRandomizedFieldMetadata_default_instance_);
}
inline const ::autofill::AutofillRandomizedFieldMetadata& AutofillUploadContents_Field::randomized_field_metadata() const {
  // @@protoc_insertion_point(field_get:autofill.AutofillUploadContents.Field.randomized_field_metadata)
  return _internal_randomized_field_metadata();
}
inline void AutofillUploadContents_Field::unsafe_arena_set_allocated_randomized_field_metadata(
    ::autofill::AutofillRandomizedFieldMetadata* randomized_field_metadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(randomized_field_metadata_);
  }
  randomized_field_metadata_ = randomized_field_metadata;
  if (randomized_field_metadata) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill.AutofillUploadContents.Field.randomized_field_metadata)
}
inline ::autofill::AutofillRandomizedFieldMetadata* AutofillUploadContents_Field::release_randomized_field_metadata() {
  _has_bits_[0] &= ~0x00000020u;
  ::autofill::AutofillRandomizedFieldMetadata* temp = randomized_field_metadata_;
  randomized_field_metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill::AutofillRandomizedFieldMetadata* AutofillUploadContents_Field::unsafe_arena_release_randomized_field_metadata() {
  // @@protoc_insertion_point(field_release:autofill.AutofillUploadContents.Field.randomized_field_metadata)
  _has_bits_[0] &= ~0x00000020u;
  ::autofill::AutofillRandomizedFieldMetadata* temp = randomized_field_metadata_;
  randomized_field_metadata_ = nullptr;
  return temp;
}
inline ::autofill::AutofillRandomizedFieldMetadata* AutofillUploadContents_Field::_internal_mutable_randomized_field_metadata() {
  _has_bits_[0] |= 0x00000020u;
  if (randomized_field_metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill::AutofillRandomizedFieldMetadata>(GetArenaForAllocation());
    randomized_field_metadata_ = p;
  }
  return randomized_field_metadata_;
}
inline ::autofill::AutofillRandomizedFieldMetadata* AutofillUploadContents_Field::mutable_randomized_field_metadata() {
  ::autofill::AutofillRandomizedFieldMetadata* _msg = _internal_mutable_randomized_field_metadata();
  // @@protoc_insertion_point(field_mutable:autofill.AutofillUploadContents.Field.randomized_field_metadata)
  return _msg;
}
inline void AutofillUploadContents_Field::set_allocated_randomized_field_metadata(::autofill::AutofillRandomizedFieldMetadata* randomized_field_metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete randomized_field_metadata_;
  }
  if (randomized_field_metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(randomized_field_metadata);
    if (message_arena != submessage_arena) {
      randomized_field_metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, randomized_field_metadata, submessage_arena);
    }
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  randomized_field_metadata_ = randomized_field_metadata;
  // @@protoc_insertion_point(field_set_allocated:autofill.AutofillUploadContents.Field.randomized_field_metadata)
}

// optional .autofill.AutofillUploadContents.Field.PasswordGenerationType generation_type = 17;
inline bool AutofillUploadContents_Field::_internal_has_generation_type() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool AutofillUploadContents_Field::has_generation_type() const {
  return _internal_has_generation_type();
}
inline void AutofillUploadContents_Field::clear_generation_type() {
  generation_type_ = 0;
  _has_bits_[0] &= ~0x00000080u;
}
inline ::autofill::AutofillUploadContents_Field_PasswordGenerationType AutofillUploadContents_Field::_internal_generation_type() const {
  return static_cast< ::autofill::AutofillUploadContents_Field_PasswordGenerationType >(generation_type_);
}
inline ::autofill::AutofillUploadContents_Field_PasswordGenerationType AutofillUploadContents_Field::generation_type() const {
  // @@protoc_insertion_point(field_get:autofill.AutofillUploadContents.Field.generation_type)
  return _internal_generation_type();
}
inline void AutofillUploadContents_Field::_internal_set_generation_type(::autofill::AutofillUploadContents_Field_PasswordGenerationType value) {
  assert(::autofill::AutofillUploadContents_Field_PasswordGenerationType_IsValid(value));
  _has_bits_[0] |= 0x00000080u;
  generation_type_ = value;
}
inline void AutofillUploadContents_Field::set_generation_type(::autofill::AutofillUploadContents_Field_PasswordGenerationType value) {
  _internal_set_generation_type(value);
  // @@protoc_insertion_point(field_set:autofill.AutofillUploadContents.Field.generation_type)
}

// optional string css_classes = 19;
inline bool AutofillUploadContents_Field::_internal_has_css_classes() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool AutofillUploadContents_Field::has_css_classes() const {
  return _internal_has_css_classes();
}
inline void AutofillUploadContents_Field::clear_css_classes() {
  css_classes_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& AutofillUploadContents_Field::css_classes() const {
  // @@protoc_insertion_point(field_get:autofill.AutofillUploadContents.Field.css_classes)
  return _internal_css_classes();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AutofillUploadContents_Field::set_css_classes(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 css_classes_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill.AutofillUploadContents.Field.css_classes)
}
inline std::string* AutofillUploadContents_Field::mutable_css_classes() {
  std::string* _s = _internal_mutable_css_classes();
  // @@protoc_insertion_point(field_mutable:autofill.AutofillUploadContents.Field.css_classes)
  return _s;
}
inline const std::string& AutofillUploadContents_Field::_internal_css_classes() const {
  return css_classes_.Get();
}
inline void AutofillUploadContents_Field::_internal_set_css_classes(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  css_classes_.Set(value, GetArenaForAllocation());
}
inline std::string* AutofillUploadContents_Field::_internal_mutable_css_classes() {
  _has_bits_[0] |= 0x00000008u;
  return css_classes_.Mutable(GetArenaForAllocation());
}
inline std::string* AutofillUploadContents_Field::release_css_classes() {
  // @@protoc_insertion_point(field_release:autofill.AutofillUploadContents.Field.css_classes)
  if (!_internal_has_css_classes()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  auto* p = css_classes_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (css_classes_.IsDefault()) {
    css_classes_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AutofillUploadContents_Field::set_allocated_css_classes(std::string* css_classes) {
  if (css_classes != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  css_classes_.SetAllocated(css_classes, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (css_classes_.IsDefault()) {
    css_classes_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill.AutofillUploadContents.Field.css_classes)
}

// optional uint32 properties_mask = 20;
inline bool AutofillUploadContents_Field::_internal_has_properties_mask() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool AutofillUploadContents_Field::has_properties_mask() const {
  return _internal_has_properties_mask();
}
inline void AutofillUploadContents_Field::clear_properties_mask() {
  properties_mask_ = 0u;
  _has_bits_[0] &= ~0x00000100u;
}
inline uint32_t AutofillUploadContents_Field::_internal_properties_mask() const {
  return properties_mask_;
}
inline uint32_t AutofillUploadContents_Field::properties_mask() const {
  // @@protoc_insertion_point(field_get:autofill.AutofillUploadContents.Field.properties_mask)
  return _internal_properties_mask();
}
inline void AutofillUploadContents_Field::_internal_set_properties_mask(uint32_t value) {
  _has_bits_[0] |= 0x00000100u;
  properties_mask_ = value;
}
inline void AutofillUploadContents_Field::set_properties_mask(uint32_t value) {
  _internal_set_properties_mask(value);
  // @@protoc_insertion_point(field_set:autofill.AutofillUploadContents.Field.properties_mask)
}

// optional string id = 21;
inline bool AutofillUploadContents_Field::_internal_has_id() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool AutofillUploadContents_Field::has_id() const {
  return _internal_has_id();
}
inline void AutofillUploadContents_Field::clear_id() {
  id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000010u;
}
inline const std::string& AutofillUploadContents_Field::id() const {
  // @@protoc_insertion_point(field_get:autofill.AutofillUploadContents.Field.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AutofillUploadContents_Field::set_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000010u;
 id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill.AutofillUploadContents.Field.id)
}
inline std::string* AutofillUploadContents_Field::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:autofill.AutofillUploadContents.Field.id)
  return _s;
}
inline const std::string& AutofillUploadContents_Field::_internal_id() const {
  return id_.Get();
}
inline void AutofillUploadContents_Field::_internal_set_id(const std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  id_.Set(value, GetArenaForAllocation());
}
inline std::string* AutofillUploadContents_Field::_internal_mutable_id() {
  _has_bits_[0] |= 0x00000010u;
  return id_.Mutable(GetArenaForAllocation());
}
inline std::string* AutofillUploadContents_Field::release_id() {
  // @@protoc_insertion_point(field_release:autofill.AutofillUploadContents.Field.id)
  if (!_internal_has_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  auto* p = id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault()) {
    id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AutofillUploadContents_Field::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault()) {
    id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill.AutofillUploadContents.Field.id)
}

// optional bool generated_password_changed = 22;
inline bool AutofillUploadContents_Field::_internal_has_generated_password_changed() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool AutofillUploadContents_Field::has_generated_password_changed() const {
  return _internal_has_generated_password_changed();
}
inline void AutofillUploadContents_Field::clear_generated_password_changed() {
  generated_password_changed_ = false;
  _has_bits_[0] &= ~0x00000200u;
}
inline bool AutofillUploadContents_Field::_internal_generated_password_changed() const {
  return generated_password_changed_;
}
inline bool AutofillUploadContents_Field::generated_password_changed() const {
  // @@protoc_insertion_point(field_get:autofill.AutofillUploadContents.Field.generated_password_changed)
  return _internal_generated_password_changed();
}
inline void AutofillUploadContents_Field::_internal_set_generated_password_changed(bool value) {
  _has_bits_[0] |= 0x00000200u;
  generated_password_changed_ = value;
}
inline void AutofillUploadContents_Field::set_generated_password_changed(bool value) {
  _internal_set_generated_password_changed(value);
  // @@protoc_insertion_point(field_set:autofill.AutofillUploadContents.Field.generated_password_changed)
}

// optional .autofill.AutofillUploadContents.Field.VoteType vote_type = 23;
inline bool AutofillUploadContents_Field::_internal_has_vote_type() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool AutofillUploadContents_Field::has_vote_type() const {
  return _internal_has_vote_type();
}
inline void AutofillUploadContents_Field::clear_vote_type() {
  vote_type_ = 0;
  _has_bits_[0] &= ~0x00000400u;
}
inline ::autofill::AutofillUploadContents_Field_VoteType AutofillUploadContents_Field::_internal_vote_type() const {
  return static_cast< ::autofill::AutofillUploadContents_Field_VoteType >(vote_type_);
}
inline ::autofill::AutofillUploadContents_Field_VoteType AutofillUploadContents_Field::vote_type() const {
  // @@protoc_insertion_point(field_get:autofill.AutofillUploadContents.Field.vote_type)
  return _internal_vote_type();
}
inline void AutofillUploadContents_Field::_internal_set_vote_type(::autofill::AutofillUploadContents_Field_VoteType value) {
  assert(::autofill::AutofillUploadContents_Field_VoteType_IsValid(value));
  _has_bits_[0] |= 0x00000400u;
  vote_type_ = value;
}
inline void AutofillUploadContents_Field::set_vote_type(::autofill::AutofillUploadContents_Field_VoteType value) {
  _internal_set_vote_type(value);
  // @@protoc_insertion_point(field_set:autofill.AutofillUploadContents.Field.vote_type)
}

// repeated .autofill.AutofillUploadContents.Field.AutofillTypeValiditiesPair autofill_type_validities = 35 [deprecated = true];
inline int AutofillUploadContents_Field::_internal_autofill_type_validities_size() const {
  return autofill_type_validities_.size();
}
inline int AutofillUploadContents_Field::autofill_type_validities_size() const {
  return _internal_autofill_type_validities_size();
}
inline void AutofillUploadContents_Field::clear_autofill_type_validities() {
  autofill_type_validities_.Clear();
}
inline ::autofill::AutofillUploadContents_Field_AutofillTypeValiditiesPair* AutofillUploadContents_Field::mutable_autofill_type_validities(int index) {
  // @@protoc_insertion_point(field_mutable:autofill.AutofillUploadContents.Field.autofill_type_validities)
  return autofill_type_validities_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill::AutofillUploadContents_Field_AutofillTypeValiditiesPair >*
AutofillUploadContents_Field::mutable_autofill_type_validities() {
  // @@protoc_insertion_point(field_mutable_list:autofill.AutofillUploadContents.Field.autofill_type_validities)
  return &autofill_type_validities_;
}
inline const ::autofill::AutofillUploadContents_Field_AutofillTypeValiditiesPair& AutofillUploadContents_Field::_internal_autofill_type_validities(int index) const {
  return autofill_type_validities_.Get(index);
}
inline const ::autofill::AutofillUploadContents_Field_AutofillTypeValiditiesPair& AutofillUploadContents_Field::autofill_type_validities(int index) const {
  // @@protoc_insertion_point(field_get:autofill.AutofillUploadContents.Field.autofill_type_validities)
  return _internal_autofill_type_validities(index);
}
inline ::autofill::AutofillUploadContents_Field_AutofillTypeValiditiesPair* AutofillUploadContents_Field::_internal_add_autofill_type_validities() {
  return autofill_type_validities_.Add();
}
inline ::autofill::AutofillUploadContents_Field_AutofillTypeValiditiesPair* AutofillUploadContents_Field::add_autofill_type_validities() {
  ::autofill::AutofillUploadContents_Field_AutofillTypeValiditiesPair* _add = _internal_add_autofill_type_validities();
  // @@protoc_insertion_point(field_add:autofill.AutofillUploadContents.Field.autofill_type_validities)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill::AutofillUploadContents_Field_AutofillTypeValiditiesPair >&
AutofillUploadContents_Field::autofill_type_validities() const {
  // @@protoc_insertion_point(field_list:autofill.AutofillUploadContents.Field.autofill_type_validities)
  return autofill_type_validities_;
}

// optional uint32 initial_value_hash = 40;
inline bool AutofillUploadContents_Field::_internal_has_initial_value_hash() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool AutofillUploadContents_Field::has_initial_value_hash() const {
  return _internal_has_initial_value_hash();
}
inline void AutofillUploadContents_Field::clear_initial_value_hash() {
  initial_value_hash_ = 0u;
  _has_bits_[0] &= ~0x00000800u;
}
inline uint32_t AutofillUploadContents_Field::_internal_initial_value_hash() const {
  return initial_value_hash_;
}
inline uint32_t AutofillUploadContents_Field::initial_value_hash() const {
  // @@protoc_insertion_point(field_get:autofill.AutofillUploadContents.Field.initial_value_hash)
  return _internal_initial_value_hash();
}
inline void AutofillUploadContents_Field::_internal_set_initial_value_hash(uint32_t value) {
  _has_bits_[0] |= 0x00000800u;
  initial_value_hash_ = value;
}
inline void AutofillUploadContents_Field::set_initial_value_hash(uint32_t value) {
  _internal_set_initial_value_hash(value);
  // @@protoc_insertion_point(field_set:autofill.AutofillUploadContents.Field.initial_value_hash)
}

// optional .autofill.AutofillUploadContents.Field.SingleUsernameVoteType single_username_vote_type = 41;
inline bool AutofillUploadContents_Field::_internal_has_single_username_vote_type() const {
  bool value = (_has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool AutofillUploadContents_Field::has_single_username_vote_type() const {
  return _internal_has_single_username_vote_type();
}
inline void AutofillUploadContents_Field::clear_single_username_vote_type() {
  single_username_vote_type_ = 0;
  _has_bits_[0] &= ~0x00001000u;
}
inline ::autofill::AutofillUploadContents_Field_SingleUsernameVoteType AutofillUploadContents_Field::_internal_single_username_vote_type() const {
  return static_cast< ::autofill::AutofillUploadContents_Field_SingleUsernameVoteType >(single_username_vote_type_);
}
inline ::autofill::AutofillUploadContents_Field_SingleUsernameVoteType AutofillUploadContents_Field::single_username_vote_type() const {
  // @@protoc_insertion_point(field_get:autofill.AutofillUploadContents.Field.single_username_vote_type)
  return _internal_single_username_vote_type();
}
inline void AutofillUploadContents_Field::_internal_set_single_username_vote_type(::autofill::AutofillUploadContents_Field_SingleUsernameVoteType value) {
  assert(::autofill::AutofillUploadContents_Field_SingleUsernameVoteType_IsValid(value));
  _has_bits_[0] |= 0x00001000u;
  single_username_vote_type_ = value;
}
inline void AutofillUploadContents_Field::set_single_username_vote_type(::autofill::AutofillUploadContents_Field_SingleUsernameVoteType value) {
  _internal_set_single_username_vote_type(value);
  // @@protoc_insertion_point(field_set:autofill.AutofillUploadContents.Field.single_username_vote_type)
}

// -------------------------------------------------------------------

// AutofillUploadContents_ButtonTitle

// optional string title = 1;
inline bool AutofillUploadContents_ButtonTitle::_internal_has_title() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AutofillUploadContents_ButtonTitle::has_title() const {
  return _internal_has_title();
}
inline void AutofillUploadContents_ButtonTitle::clear_title() {
  title_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AutofillUploadContents_ButtonTitle::title() const {
  // @@protoc_insertion_point(field_get:autofill.AutofillUploadContents.ButtonTitle.title)
  return _internal_title();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AutofillUploadContents_ButtonTitle::set_title(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 title_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill.AutofillUploadContents.ButtonTitle.title)
}
inline std::string* AutofillUploadContents_ButtonTitle::mutable_title() {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:autofill.AutofillUploadContents.ButtonTitle.title)
  return _s;
}
inline const std::string& AutofillUploadContents_ButtonTitle::_internal_title() const {
  return title_.Get();
}
inline void AutofillUploadContents_ButtonTitle::_internal_set_title(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  title_.Set(value, GetArenaForAllocation());
}
inline std::string* AutofillUploadContents_ButtonTitle::_internal_mutable_title() {
  _has_bits_[0] |= 0x00000001u;
  return title_.Mutable(GetArenaForAllocation());
}
inline std::string* AutofillUploadContents_ButtonTitle::release_title() {
  // @@protoc_insertion_point(field_release:autofill.AutofillUploadContents.ButtonTitle.title)
  if (!_internal_has_title()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = title_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (title_.IsDefault()) {
    title_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AutofillUploadContents_ButtonTitle::set_allocated_title(std::string* title) {
  if (title != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  title_.SetAllocated(title, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (title_.IsDefault()) {
    title_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill.AutofillUploadContents.ButtonTitle.title)
}

// optional .autofill.ButtonTitleType type = 2;
inline bool AutofillUploadContents_ButtonTitle::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool AutofillUploadContents_ButtonTitle::has_type() const {
  return _internal_has_type();
}
inline void AutofillUploadContents_ButtonTitle::clear_type() {
  type_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::autofill::ButtonTitleType AutofillUploadContents_ButtonTitle::_internal_type() const {
  return static_cast< ::autofill::ButtonTitleType >(type_);
}
inline ::autofill::ButtonTitleType AutofillUploadContents_ButtonTitle::type() const {
  // @@protoc_insertion_point(field_get:autofill.AutofillUploadContents.ButtonTitle.type)
  return _internal_type();
}
inline void AutofillUploadContents_ButtonTitle::_internal_set_type(::autofill::ButtonTitleType value) {
  assert(::autofill::ButtonTitleType_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  type_ = value;
}
inline void AutofillUploadContents_ButtonTitle::set_type(::autofill::ButtonTitleType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:autofill.AutofillUploadContents.ButtonTitle.type)
}

// -------------------------------------------------------------------

// AutofillUploadContents_SingleUsernameData

// optional fixed64 username_form_signature = 1;
inline bool AutofillUploadContents_SingleUsernameData::_internal_has_username_form_signature() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AutofillUploadContents_SingleUsernameData::has_username_form_signature() const {
  return _internal_has_username_form_signature();
}
inline void AutofillUploadContents_SingleUsernameData::clear_username_form_signature() {
  username_form_signature_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000001u;
}
inline uint64_t AutofillUploadContents_SingleUsernameData::_internal_username_form_signature() const {
  return username_form_signature_;
}
inline uint64_t AutofillUploadContents_SingleUsernameData::username_form_signature() const {
  // @@protoc_insertion_point(field_get:autofill.AutofillUploadContents.SingleUsernameData.username_form_signature)
  return _internal_username_form_signature();
}
inline void AutofillUploadContents_SingleUsernameData::_internal_set_username_form_signature(uint64_t value) {
  _has_bits_[0] |= 0x00000001u;
  username_form_signature_ = value;
}
inline void AutofillUploadContents_SingleUsernameData::set_username_form_signature(uint64_t value) {
  _internal_set_username_form_signature(value);
  // @@protoc_insertion_point(field_set:autofill.AutofillUploadContents.SingleUsernameData.username_form_signature)
}

// optional fixed32 username_field_signature = 2;
inline bool AutofillUploadContents_SingleUsernameData::_internal_has_username_field_signature() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool AutofillUploadContents_SingleUsernameData::has_username_field_signature() const {
  return _internal_has_username_field_signature();
}
inline void AutofillUploadContents_SingleUsernameData::clear_username_field_signature() {
  username_field_signature_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline uint32_t AutofillUploadContents_SingleUsernameData::_internal_username_field_signature() const {
  return username_field_signature_;
}
inline uint32_t AutofillUploadContents_SingleUsernameData::username_field_signature() const {
  // @@protoc_insertion_point(field_get:autofill.AutofillUploadContents.SingleUsernameData.username_field_signature)
  return _internal_username_field_signature();
}
inline void AutofillUploadContents_SingleUsernameData::_internal_set_username_field_signature(uint32_t value) {
  _has_bits_[0] |= 0x00000002u;
  username_field_signature_ = value;
}
inline void AutofillUploadContents_SingleUsernameData::set_username_field_signature(uint32_t value) {
  _internal_set_username_field_signature(value);
  // @@protoc_insertion_point(field_set:autofill.AutofillUploadContents.SingleUsernameData.username_field_signature)
}

// optional .autofill.AutofillUploadContents.ValueType value_type = 3;
inline bool AutofillUploadContents_SingleUsernameData::_internal_has_value_type() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool AutofillUploadContents_SingleUsernameData::has_value_type() const {
  return _internal_has_value_type();
}
inline void AutofillUploadContents_SingleUsernameData::clear_value_type() {
  value_type_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::autofill::AutofillUploadContents_ValueType AutofillUploadContents_SingleUsernameData::_internal_value_type() const {
  return static_cast< ::autofill::AutofillUploadContents_ValueType >(value_type_);
}
inline ::autofill::AutofillUploadContents_ValueType AutofillUploadContents_SingleUsernameData::value_type() const {
  // @@protoc_insertion_point(field_get:autofill.AutofillUploadContents.SingleUsernameData.value_type)
  return _internal_value_type();
}
inline void AutofillUploadContents_SingleUsernameData::_internal_set_value_type(::autofill::AutofillUploadContents_ValueType value) {
  assert(::autofill::AutofillUploadContents_ValueType_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  value_type_ = value;
}
inline void AutofillUploadContents_SingleUsernameData::set_value_type(::autofill::AutofillUploadContents_ValueType value) {
  _internal_set_value_type(value);
  // @@protoc_insertion_point(field_set:autofill.AutofillUploadContents.SingleUsernameData.value_type)
}

// optional .autofill.AutofillUploadContents.SingleUsernamePromptEdit prompt_edit = 4;
inline bool AutofillUploadContents_SingleUsernameData::_internal_has_prompt_edit() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool AutofillUploadContents_SingleUsernameData::has_prompt_edit() const {
  return _internal_has_prompt_edit();
}
inline void AutofillUploadContents_SingleUsernameData::clear_prompt_edit() {
  prompt_edit_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::autofill::AutofillUploadContents_SingleUsernamePromptEdit AutofillUploadContents_SingleUsernameData::_internal_prompt_edit() const {
  return static_cast< ::autofill::AutofillUploadContents_SingleUsernamePromptEdit >(prompt_edit_);
}
inline ::autofill::AutofillUploadContents_SingleUsernamePromptEdit AutofillUploadContents_SingleUsernameData::prompt_edit() const {
  // @@protoc_insertion_point(field_get:autofill.AutofillUploadContents.SingleUsernameData.prompt_edit)
  return _internal_prompt_edit();
}
inline void AutofillUploadContents_SingleUsernameData::_internal_set_prompt_edit(::autofill::AutofillUploadContents_SingleUsernamePromptEdit value) {
  assert(::autofill::AutofillUploadContents_SingleUsernamePromptEdit_IsValid(value));
  _has_bits_[0] |= 0x00000008u;
  prompt_edit_ = value;
}
inline void AutofillUploadContents_SingleUsernameData::set_prompt_edit(::autofill::AutofillUploadContents_SingleUsernamePromptEdit value) {
  _internal_set_prompt_edit(value);
  // @@protoc_insertion_point(field_set:autofill.AutofillUploadContents.SingleUsernameData.prompt_edit)
}

// -------------------------------------------------------------------

// AutofillUploadContents

// required string client_version = 1;
inline bool AutofillUploadContents::_internal_has_client_version() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AutofillUploadContents::has_client_version() const {
  return _internal_has_client_version();
}
inline void AutofillUploadContents::clear_client_version() {
  client_version_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AutofillUploadContents::client_version() const {
  // @@protoc_insertion_point(field_get:autofill.AutofillUploadContents.client_version)
  return _internal_client_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AutofillUploadContents::set_client_version(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 client_version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill.AutofillUploadContents.client_version)
}
inline std::string* AutofillUploadContents::mutable_client_version() {
  std::string* _s = _internal_mutable_client_version();
  // @@protoc_insertion_point(field_mutable:autofill.AutofillUploadContents.client_version)
  return _s;
}
inline const std::string& AutofillUploadContents::_internal_client_version() const {
  return client_version_.Get();
}
inline void AutofillUploadContents::_internal_set_client_version(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  client_version_.Set(value, GetArenaForAllocation());
}
inline std::string* AutofillUploadContents::_internal_mutable_client_version() {
  _has_bits_[0] |= 0x00000001u;
  return client_version_.Mutable(GetArenaForAllocation());
}
inline std::string* AutofillUploadContents::release_client_version() {
  // @@protoc_insertion_point(field_release:autofill.AutofillUploadContents.client_version)
  if (!_internal_has_client_version()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = client_version_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (client_version_.IsDefault()) {
    client_version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AutofillUploadContents::set_allocated_client_version(std::string* client_version) {
  if (client_version != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  client_version_.SetAllocated(client_version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (client_version_.IsDefault()) {
    client_version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill.AutofillUploadContents.client_version)
}

// required fixed64 form_signature = 2;
inline bool AutofillUploadContents::_internal_has_form_signature() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool AutofillUploadContents::has_form_signature() const {
  return _internal_has_form_signature();
}
inline void AutofillUploadContents::clear_form_signature() {
  form_signature_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000040u;
}
inline uint64_t AutofillUploadContents::_internal_form_signature() const {
  return form_signature_;
}
inline uint64_t AutofillUploadContents::form_signature() const {
  // @@protoc_insertion_point(field_get:autofill.AutofillUploadContents.form_signature)
  return _internal_form_signature();
}
inline void AutofillUploadContents::_internal_set_form_signature(uint64_t value) {
  _has_bits_[0] |= 0x00000040u;
  form_signature_ = value;
}
inline void AutofillUploadContents::set_form_signature(uint64_t value) {
  _internal_set_form_signature(value);
  // @@protoc_insertion_point(field_set:autofill.AutofillUploadContents.form_signature)
}

// optional fixed64 secondary_form_signature = 34;
inline bool AutofillUploadContents::_internal_has_secondary_form_signature() const {
  bool value = (_has_bits_[0] & 0x00080000u) != 0;
  return value;
}
inline bool AutofillUploadContents::has_secondary_form_signature() const {
  return _internal_has_secondary_form_signature();
}
inline void AutofillUploadContents::clear_secondary_form_signature() {
  secondary_form_signature_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00080000u;
}
inline uint64_t AutofillUploadContents::_internal_secondary_form_signature() const {
  return secondary_form_signature_;
}
inline uint64_t AutofillUploadContents::secondary_form_signature() const {
  // @@protoc_insertion_point(field_get:autofill.AutofillUploadContents.secondary_form_signature)
  return _internal_secondary_form_signature();
}
inline void AutofillUploadContents::_internal_set_secondary_form_signature(uint64_t value) {
  _has_bits_[0] |= 0x00080000u;
  secondary_form_signature_ = value;
}
inline void AutofillUploadContents::set_secondary_form_signature(uint64_t value) {
  _internal_set_secondary_form_signature(value);
  // @@protoc_insertion_point(field_set:autofill.AutofillUploadContents.secondary_form_signature)
}

// required bool autofill_used = 3;
inline bool AutofillUploadContents::_internal_has_autofill_used() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool AutofillUploadContents::has_autofill_used() const {
  return _internal_has_autofill_used();
}
inline void AutofillUploadContents::clear_autofill_used() {
  autofill_used_ = false;
  _has_bits_[0] &= ~0x00000200u;
}
inline bool AutofillUploadContents::_internal_autofill_used() const {
  return autofill_used_;
}
inline bool AutofillUploadContents::autofill_used() const {
  // @@protoc_insertion_point(field_get:autofill.AutofillUploadContents.autofill_used)
  return _internal_autofill_used();
}
inline void AutofillUploadContents::_internal_set_autofill_used(bool value) {
  _has_bits_[0] |= 0x00000200u;
  autofill_used_ = value;
}
inline void AutofillUploadContents::set_autofill_used(bool value) {
  _internal_set_autofill_used(value);
  // @@protoc_insertion_point(field_set:autofill.AutofillUploadContents.autofill_used)
}

// required string data_present = 4;
inline bool AutofillUploadContents::_internal_has_data_present() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool AutofillUploadContents::has_data_present() const {
  return _internal_has_data_present();
}
inline void AutofillUploadContents::clear_data_present() {
  data_present_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& AutofillUploadContents::data_present() const {
  // @@protoc_insertion_point(field_get:autofill.AutofillUploadContents.data_present)
  return _internal_data_present();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AutofillUploadContents::set_data_present(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 data_present_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill.AutofillUploadContents.data_present)
}
inline std::string* AutofillUploadContents::mutable_data_present() {
  std::string* _s = _internal_mutable_data_present();
  // @@protoc_insertion_point(field_mutable:autofill.AutofillUploadContents.data_present)
  return _s;
}
inline const std::string& AutofillUploadContents::_internal_data_present() const {
  return data_present_.Get();
}
inline void AutofillUploadContents::_internal_set_data_present(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  data_present_.Set(value, GetArenaForAllocation());
}
inline std::string* AutofillUploadContents::_internal_mutable_data_present() {
  _has_bits_[0] |= 0x00000002u;
  return data_present_.Mutable(GetArenaForAllocation());
}
inline std::string* AutofillUploadContents::release_data_present() {
  // @@protoc_insertion_point(field_release:autofill.AutofillUploadContents.data_present)
  if (!_internal_has_data_present()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = data_present_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (data_present_.IsDefault()) {
    data_present_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AutofillUploadContents::set_allocated_data_present(std::string* data_present) {
  if (data_present != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  data_present_.SetAllocated(data_present, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (data_present_.IsDefault()) {
    data_present_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill.AutofillUploadContents.data_present)
}

// repeated group Field = 5 { ... };
inline int AutofillUploadContents::_internal_field_size() const {
  return field_.size();
}
inline int AutofillUploadContents::field_size() const {
  return _internal_field_size();
}
inline void AutofillUploadContents::clear_field() {
  field_.Clear();
}
inline ::autofill::AutofillUploadContents_Field* AutofillUploadContents::mutable_field(int index) {
  // @@protoc_insertion_point(field_mutable:autofill.AutofillUploadContents.field)
  return field_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill::AutofillUploadContents_Field >*
AutofillUploadContents::mutable_field() {
  // @@protoc_insertion_point(field_mutable_list:autofill.AutofillUploadContents.field)
  return &field_;
}
inline const ::autofill::AutofillUploadContents_Field& AutofillUploadContents::_internal_field(int index) const {
  return field_.Get(index);
}
inline const ::autofill::AutofillUploadContents_Field& AutofillUploadContents::field(int index) const {
  // @@protoc_insertion_point(field_get:autofill.AutofillUploadContents.field)
  return _internal_field(index);
}
inline ::autofill::AutofillUploadContents_Field* AutofillUploadContents::_internal_add_field() {
  return field_.Add();
}
inline ::autofill::AutofillUploadContents_Field* AutofillUploadContents::add_field() {
  ::autofill::AutofillUploadContents_Field* _add = _internal_add_field();
  // @@protoc_insertion_point(field_add:autofill.AutofillUploadContents.field)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill::AutofillUploadContents_Field >&
AutofillUploadContents::field() const {
  // @@protoc_insertion_point(field_list:autofill.AutofillUploadContents.field)
  return field_;
}

// optional fixed64 action_signature = 13;
inline bool AutofillUploadContents::_internal_has_action_signature() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool AutofillUploadContents::has_action_signature() const {
  return _internal_has_action_signature();
}
inline void AutofillUploadContents::clear_action_signature() {
  action_signature_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000080u;
}
inline uint64_t AutofillUploadContents::_internal_action_signature() const {
  return action_signature_;
}
inline uint64_t AutofillUploadContents::action_signature() const {
  // @@protoc_insertion_point(field_get:autofill.AutofillUploadContents.action_signature)
  return _internal_action_signature();
}
inline void AutofillUploadContents::_internal_set_action_signature(uint64_t value) {
  _has_bits_[0] |= 0x00000080u;
  action_signature_ = value;
}
inline void AutofillUploadContents::set_action_signature(uint64_t value) {
  _internal_set_action_signature(value);
  // @@protoc_insertion_point(field_set:autofill.AutofillUploadContents.action_signature)
}

// optional fixed64 login_form_signature = 14;
inline bool AutofillUploadContents::_internal_has_login_form_signature() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool AutofillUploadContents::has_login_form_signature() const {
  return _internal_has_login_form_signature();
}
inline void AutofillUploadContents::clear_login_form_signature() {
  login_form_signature_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000100u;
}
inline uint64_t AutofillUploadContents::_internal_login_form_signature() const {
  return login_form_signature_;
}
inline uint64_t AutofillUploadContents::login_form_signature() const {
  // @@protoc_insertion_point(field_get:autofill.AutofillUploadContents.login_form_signature)
  return _internal_login_form_signature();
}
inline void AutofillUploadContents::_internal_set_login_form_signature(uint64_t value) {
  _has_bits_[0] |= 0x00000100u;
  login_form_signature_ = value;
}
inline void AutofillUploadContents::set_login_form_signature(uint64_t value) {
  _internal_set_login_form_signature(value);
  // @@protoc_insertion_point(field_set:autofill.AutofillUploadContents.login_form_signature)
}

// optional bool submission = 15;
inline bool AutofillUploadContents::_internal_has_submission() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool AutofillUploadContents::has_submission() const {
  return _internal_has_submission();
}
inline void AutofillUploadContents::clear_submission() {
  submission_ = false;
  _has_bits_[0] &= ~0x00000400u;
}
inline bool AutofillUploadContents::_internal_submission() const {
  return submission_;
}
inline bool AutofillUploadContents::submission() const {
  // @@protoc_insertion_point(field_get:autofill.AutofillUploadContents.submission)
  return _internal_submission();
}
inline void AutofillUploadContents::_internal_set_submission(bool value) {
  _has_bits_[0] |= 0x00000400u;
  submission_ = value;
}
inline void AutofillUploadContents::set_submission(bool value) {
  _internal_set_submission(value);
  // @@protoc_insertion_point(field_set:autofill.AutofillUploadContents.submission)
}

// optional string form_name = 16;
inline bool AutofillUploadContents::_internal_has_form_name() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool AutofillUploadContents::has_form_name() const {
  return _internal_has_form_name();
}
inline void AutofillUploadContents::clear_form_name() {
  form_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& AutofillUploadContents::form_name() const {
  // @@protoc_insertion_point(field_get:autofill.AutofillUploadContents.form_name)
  return _internal_form_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AutofillUploadContents::set_form_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 form_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill.AutofillUploadContents.form_name)
}
inline std::string* AutofillUploadContents::mutable_form_name() {
  std::string* _s = _internal_mutable_form_name();
  // @@protoc_insertion_point(field_mutable:autofill.AutofillUploadContents.form_name)
  return _s;
}
inline const std::string& AutofillUploadContents::_internal_form_name() const {
  return form_name_.Get();
}
inline void AutofillUploadContents::_internal_set_form_name(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  form_name_.Set(value, GetArenaForAllocation());
}
inline std::string* AutofillUploadContents::_internal_mutable_form_name() {
  _has_bits_[0] |= 0x00000004u;
  return form_name_.Mutable(GetArenaForAllocation());
}
inline std::string* AutofillUploadContents::release_form_name() {
  // @@protoc_insertion_point(field_release:autofill.AutofillUploadContents.form_name)
  if (!_internal_has_form_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = form_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (form_name_.IsDefault()) {
    form_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AutofillUploadContents::set_allocated_form_name(std::string* form_name) {
  if (form_name != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  form_name_.SetAllocated(form_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (form_name_.IsDefault()) {
    form_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill.AutofillUploadContents.form_name)
}

// optional bool passwords_revealed = 24;
inline bool AutofillUploadContents::_internal_has_passwords_revealed() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool AutofillUploadContents::has_passwords_revealed() const {
  return _internal_has_passwords_revealed();
}
inline void AutofillUploadContents::clear_passwords_revealed() {
  passwords_revealed_ = false;
  _has_bits_[0] &= ~0x00000800u;
}
inline bool AutofillUploadContents::_internal_passwords_revealed() const {
  return passwords_revealed_;
}
inline bool AutofillUploadContents::passwords_revealed() const {
  // @@protoc_insertion_point(field_get:autofill.AutofillUploadContents.passwords_revealed)
  return _internal_passwords_revealed();
}
inline void AutofillUploadContents::_internal_set_passwords_revealed(bool value) {
  _has_bits_[0] |= 0x00000800u;
  passwords_revealed_ = value;
}
inline void AutofillUploadContents::set_passwords_revealed(bool value) {
  _internal_set_passwords_revealed(value);
  // @@protoc_insertion_point(field_set:autofill.AutofillUploadContents.passwords_revealed)
}

// optional bool password_has_lowercase_letter = 25;
inline bool AutofillUploadContents::_internal_has_password_has_lowercase_letter() const {
  bool value = (_has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool AutofillUploadContents::has_password_has_lowercase_letter() const {
  return _internal_has_password_has_lowercase_letter();
}
inline void AutofillUploadContents::clear_password_has_lowercase_letter() {
  password_has_lowercase_letter_ = false;
  _has_bits_[0] &= ~0x00001000u;
}
inline bool AutofillUploadContents::_internal_password_has_lowercase_letter() const {
  return password_has_lowercase_letter_;
}
inline bool AutofillUploadContents::password_has_lowercase_letter() const {
  // @@protoc_insertion_point(field_get:autofill.AutofillUploadContents.password_has_lowercase_letter)
  return _internal_password_has_lowercase_letter();
}
inline void AutofillUploadContents::_internal_set_password_has_lowercase_letter(bool value) {
  _has_bits_[0] |= 0x00001000u;
  password_has_lowercase_letter_ = value;
}
inline void AutofillUploadContents::set_password_has_lowercase_letter(bool value) {
  _internal_set_password_has_lowercase_letter(value);
  // @@protoc_insertion_point(field_set:autofill.AutofillUploadContents.password_has_lowercase_letter)
}

// optional bool password_has_uppercase_letter = 26 [deprecated = true];
inline bool AutofillUploadContents::_internal_has_password_has_uppercase_letter() const {
  bool value = (_has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool AutofillUploadContents::has_password_has_uppercase_letter() const {
  return _internal_has_password_has_uppercase_letter();
}
inline void AutofillUploadContents::clear_password_has_uppercase_letter() {
  password_has_uppercase_letter_ = false;
  _has_bits_[0] &= ~0x00004000u;
}
inline bool AutofillUploadContents::_internal_password_has_uppercase_letter() const {
  return password_has_uppercase_letter_;
}
inline bool AutofillUploadContents::password_has_uppercase_letter() const {
  // @@protoc_insertion_point(field_get:autofill.AutofillUploadContents.password_has_uppercase_letter)
  return _internal_password_has_uppercase_letter();
}
inline void AutofillUploadContents::_internal_set_password_has_uppercase_letter(bool value) {
  _has_bits_[0] |= 0x00004000u;
  password_has_uppercase_letter_ = value;
}
inline void AutofillUploadContents::set_password_has_uppercase_letter(bool value) {
  _internal_set_password_has_uppercase_letter(value);
  // @@protoc_insertion_point(field_set:autofill.AutofillUploadContents.password_has_uppercase_letter)
}

// optional bool password_has_numeric = 27 [deprecated = true];
inline bool AutofillUploadContents::_internal_has_password_has_numeric() const {
  bool value = (_has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline bool AutofillUploadContents::has_password_has_numeric() const {
  return _internal_has_password_has_numeric();
}
inline void AutofillUploadContents::clear_password_has_numeric() {
  password_has_numeric_ = false;
  _has_bits_[0] &= ~0x00008000u;
}
inline bool AutofillUploadContents::_internal_password_has_numeric() const {
  return password_has_numeric_;
}
inline bool AutofillUploadContents::password_has_numeric() const {
  // @@protoc_insertion_point(field_get:autofill.AutofillUploadContents.password_has_numeric)
  return _internal_password_has_numeric();
}
inline void AutofillUploadContents::_internal_set_password_has_numeric(bool value) {
  _has_bits_[0] |= 0x00008000u;
  password_has_numeric_ = value;
}
inline void AutofillUploadContents::set_password_has_numeric(bool value) {
  _internal_set_password_has_numeric(value);
  // @@protoc_insertion_point(field_set:autofill.AutofillUploadContents.password_has_numeric)
}

// optional bool password_has_special_symbol = 28;
inline bool AutofillUploadContents::_internal_has_password_has_special_symbol() const {
  bool value = (_has_bits_[0] & 0x00010000u) != 0;
  return value;
}
inline bool AutofillUploadContents::has_password_has_special_symbol() const {
  return _internal_has_password_has_special_symbol();
}
inline void AutofillUploadContents::clear_password_has_special_symbol() {
  password_has_special_symbol_ = false;
  _has_bits_[0] &= ~0x00010000u;
}
inline bool AutofillUploadContents::_internal_password_has_special_symbol() const {
  return password_has_special_symbol_;
}
inline bool AutofillUploadContents::password_has_special_symbol() const {
  // @@protoc_insertion_point(field_get:autofill.AutofillUploadContents.password_has_special_symbol)
  return _internal_password_has_special_symbol();
}
inline void AutofillUploadContents::_internal_set_password_has_special_symbol(bool value) {
  _has_bits_[0] |= 0x00010000u;
  password_has_special_symbol_ = value;
}
inline void AutofillUploadContents::set_password_has_special_symbol(bool value) {
  _internal_set_password_has_special_symbol(value);
  // @@protoc_insertion_point(field_set:autofill.AutofillUploadContents.password_has_special_symbol)
}

// optional uint32 password_length = 29;
inline bool AutofillUploadContents::_internal_has_password_length() const {
  bool value = (_has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool AutofillUploadContents::has_password_length() const {
  return _internal_has_password_length();
}
inline void AutofillUploadContents::clear_password_length() {
  password_length_ = 0u;
  _has_bits_[0] &= ~0x00002000u;
}
inline uint32_t AutofillUploadContents::_internal_password_length() const {
  return password_length_;
}
inline uint32_t AutofillUploadContents::password_length() const {
  // @@protoc_insertion_point(field_get:autofill.AutofillUploadContents.password_length)
  return _internal_password_length();
}
inline void AutofillUploadContents::_internal_set_password_length(uint32_t value) {
  _has_bits_[0] |= 0x00002000u;
  password_length_ = value;
}
inline void AutofillUploadContents::set_password_length(uint32_t value) {
  _internal_set_password_length(value);
  // @@protoc_insertion_point(field_set:autofill.AutofillUploadContents.password_length)
}

// optional uint32 password_special_symbol = 39;
inline bool AutofillUploadContents::_internal_has_password_special_symbol() const {
  bool value = (_has_bits_[0] & 0x00200000u) != 0;
  return value;
}
inline bool AutofillUploadContents::has_password_special_symbol() const {
  return _internal_has_password_special_symbol();
}
inline void AutofillUploadContents::clear_password_special_symbol() {
  password_special_symbol_ = 0u;
  _has_bits_[0] &= ~0x00200000u;
}
inline uint32_t AutofillUploadContents::_internal_password_special_symbol() const {
  return password_special_symbol_;
}
inline uint32_t AutofillUploadContents::password_special_symbol() const {
  // @@protoc_insertion_point(field_get:autofill.AutofillUploadContents.password_special_symbol)
  return _internal_password_special_symbol();
}
inline void AutofillUploadContents::_internal_set_password_special_symbol(uint32_t value) {
  _has_bits_[0] |= 0x00200000u;
  password_special_symbol_ = value;
}
inline void AutofillUploadContents::set_password_special_symbol(uint32_t value) {
  _internal_set_password_special_symbol(value);
  // @@protoc_insertion_point(field_set:autofill.AutofillUploadContents.password_special_symbol)
}

// optional .autofill.AutofillUploadContents.SubmissionIndicatorEvent submission_event = 30;
inline bool AutofillUploadContents::_internal_has_submission_event() const {
  bool value = (_has_bits_[0] & 0x00040000u) != 0;
  return value;
}
inline bool AutofillUploadContents::has_submission_event() const {
  return _internal_has_submission_event();
}
inline void AutofillUploadContents::clear_submission_event() {
  submission_event_ = 0;
  _has_bits_[0] &= ~0x00040000u;
}
inline ::autofill::AutofillUploadContents_SubmissionIndicatorEvent AutofillUploadContents::_internal_submission_event() const {
  return static_cast< ::autofill::AutofillUploadContents_SubmissionIndicatorEvent >(submission_event_);
}
inline ::autofill::AutofillUploadContents_SubmissionIndicatorEvent AutofillUploadContents::submission_event() const {
  // @@protoc_insertion_point(field_get:autofill.AutofillUploadContents.submission_event)
  return _internal_submission_event();
}
inline void AutofillUploadContents::_internal_set_submission_event(::autofill::AutofillUploadContents_SubmissionIndicatorEvent value) {
  assert(::autofill::AutofillUploadContents_SubmissionIndicatorEvent_IsValid(value));
  _has_bits_[0] |= 0x00040000u;
  submission_event_ = value;
}
inline void AutofillUploadContents::set_submission_event(::autofill::AutofillUploadContents_SubmissionIndicatorEvent value) {
  _internal_set_submission_event(value);
  // @@protoc_insertion_point(field_set:autofill.AutofillUploadContents.submission_event)
}

// optional string language = 31;
inline bool AutofillUploadContents::_internal_has_language() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool AutofillUploadContents::has_language() const {
  return _internal_has_language();
}
inline void AutofillUploadContents::clear_language() {
  language_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& AutofillUploadContents::language() const {
  // @@protoc_insertion_point(field_get:autofill.AutofillUploadContents.language)
  return _internal_language();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AutofillUploadContents::set_language(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 language_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill.AutofillUploadContents.language)
}
inline std::string* AutofillUploadContents::mutable_language() {
  std::string* _s = _internal_mutable_language();
  // @@protoc_insertion_point(field_mutable:autofill.AutofillUploadContents.language)
  return _s;
}
inline const std::string& AutofillUploadContents::_internal_language() const {
  return language_.Get();
}
inline void AutofillUploadContents::_internal_set_language(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  language_.Set(value, GetArenaForAllocation());
}
inline std::string* AutofillUploadContents::_internal_mutable_language() {
  _has_bits_[0] |= 0x00000008u;
  return language_.Mutable(GetArenaForAllocation());
}
inline std::string* AutofillUploadContents::release_language() {
  // @@protoc_insertion_point(field_release:autofill.AutofillUploadContents.language)
  if (!_internal_has_language()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  auto* p = language_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (language_.IsDefault()) {
    language_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AutofillUploadContents::set_allocated_language(std::string* language) {
  if (language != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  language_.SetAllocated(language, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (language_.IsDefault()) {
    language_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill.AutofillUploadContents.language)
}

// optional .autofill.AutofillRandomizedFormMetadata randomized_form_metadata = 32;
inline bool AutofillUploadContents::_internal_has_randomized_form_metadata() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || randomized_form_metadata_ != nullptr);
  return value;
}
inline bool AutofillUploadContents::has_randomized_form_metadata() const {
  return _internal_has_randomized_form_metadata();
}
inline void AutofillUploadContents::clear_randomized_form_metadata() {
  if (randomized_form_metadata_ != nullptr) randomized_form_metadata_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::autofill::AutofillRandomizedFormMetadata& AutofillUploadContents::_internal_randomized_form_metadata() const {
  const ::autofill::AutofillRandomizedFormMetadata* p = randomized_form_metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill::AutofillRandomizedFormMetadata&>(
      ::autofill::_AutofillRandomizedFormMetadata_default_instance_);
}
inline const ::autofill::AutofillRandomizedFormMetadata& AutofillUploadContents::randomized_form_metadata() const {
  // @@protoc_insertion_point(field_get:autofill.AutofillUploadContents.randomized_form_metadata)
  return _internal_randomized_form_metadata();
}
inline void AutofillUploadContents::unsafe_arena_set_allocated_randomized_form_metadata(
    ::autofill::AutofillRandomizedFormMetadata* randomized_form_metadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(randomized_form_metadata_);
  }
  randomized_form_metadata_ = randomized_form_metadata;
  if (randomized_form_metadata) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill.AutofillUploadContents.randomized_form_metadata)
}
inline ::autofill::AutofillRandomizedFormMetadata* AutofillUploadContents::release_randomized_form_metadata() {
  _has_bits_[0] &= ~0x00000010u;
  ::autofill::AutofillRandomizedFormMetadata* temp = randomized_form_metadata_;
  randomized_form_metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill::AutofillRandomizedFormMetadata* AutofillUploadContents::unsafe_arena_release_randomized_form_metadata() {
  // @@protoc_insertion_point(field_release:autofill.AutofillUploadContents.randomized_form_metadata)
  _has_bits_[0] &= ~0x00000010u;
  ::autofill::AutofillRandomizedFormMetadata* temp = randomized_form_metadata_;
  randomized_form_metadata_ = nullptr;
  return temp;
}
inline ::autofill::AutofillRandomizedFormMetadata* AutofillUploadContents::_internal_mutable_randomized_form_metadata() {
  _has_bits_[0] |= 0x00000010u;
  if (randomized_form_metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill::AutofillRandomizedFormMetadata>(GetArenaForAllocation());
    randomized_form_metadata_ = p;
  }
  return randomized_form_metadata_;
}
inline ::autofill::AutofillRandomizedFormMetadata* AutofillUploadContents::mutable_randomized_form_metadata() {
  ::autofill::AutofillRandomizedFormMetadata* _msg = _internal_mutable_randomized_form_metadata();
  // @@protoc_insertion_point(field_mutable:autofill.AutofillUploadContents.randomized_form_metadata)
  return _msg;
}
inline void AutofillUploadContents::set_allocated_randomized_form_metadata(::autofill::AutofillRandomizedFormMetadata* randomized_form_metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete randomized_form_metadata_;
  }
  if (randomized_form_metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(randomized_form_metadata);
    if (message_arena != submessage_arena) {
      randomized_form_metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, randomized_form_metadata, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  randomized_form_metadata_ = randomized_form_metadata;
  // @@protoc_insertion_point(field_set_allocated:autofill.AutofillUploadContents.randomized_form_metadata)
}

// repeated .autofill.AutofillUploadContents.ButtonTitle button_title = 36;
inline int AutofillUploadContents::_internal_button_title_size() const {
  return button_title_.size();
}
inline int AutofillUploadContents::button_title_size() const {
  return _internal_button_title_size();
}
inline void AutofillUploadContents::clear_button_title() {
  button_title_.Clear();
}
inline ::autofill::AutofillUploadContents_ButtonTitle* AutofillUploadContents::mutable_button_title(int index) {
  // @@protoc_insertion_point(field_mutable:autofill.AutofillUploadContents.button_title)
  return button_title_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill::AutofillUploadContents_ButtonTitle >*
AutofillUploadContents::mutable_button_title() {
  // @@protoc_insertion_point(field_mutable_list:autofill.AutofillUploadContents.button_title)
  return &button_title_;
}
inline const ::autofill::AutofillUploadContents_ButtonTitle& AutofillUploadContents::_internal_button_title(int index) const {
  return button_title_.Get(index);
}
inline const ::autofill::AutofillUploadContents_ButtonTitle& AutofillUploadContents::button_title(int index) const {
  // @@protoc_insertion_point(field_get:autofill.AutofillUploadContents.button_title)
  return _internal_button_title(index);
}
inline ::autofill::AutofillUploadContents_ButtonTitle* AutofillUploadContents::_internal_add_button_title() {
  return button_title_.Add();
}
inline ::autofill::AutofillUploadContents_ButtonTitle* AutofillUploadContents::add_button_title() {
  ::autofill::AutofillUploadContents_ButtonTitle* _add = _internal_add_button_title();
  // @@protoc_insertion_point(field_add:autofill.AutofillUploadContents.button_title)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill::AutofillUploadContents_ButtonTitle >&
AutofillUploadContents::button_title() const {
  // @@protoc_insertion_point(field_list:autofill.AutofillUploadContents.button_title)
  return button_title_;
}

// optional bool has_form_tag = 37;
inline bool AutofillUploadContents::_internal_has_has_form_tag() const {
  bool value = (_has_bits_[0] & 0x00020000u) != 0;
  return value;
}
inline bool AutofillUploadContents::has_has_form_tag() const {
  return _internal_has_has_form_tag();
}
inline void AutofillUploadContents::clear_has_form_tag() {
  has_form_tag_ = false;
  _has_bits_[0] &= ~0x00020000u;
}
inline bool AutofillUploadContents::_internal_has_form_tag() const {
  return has_form_tag_;
}
inline bool AutofillUploadContents::has_form_tag() const {
  // @@protoc_insertion_point(field_get:autofill.AutofillUploadContents.has_form_tag)
  return _internal_has_form_tag();
}
inline void AutofillUploadContents::_internal_set_has_form_tag(bool value) {
  _has_bits_[0] |= 0x00020000u;
  has_form_tag_ = value;
}
inline void AutofillUploadContents::set_has_form_tag(bool value) {
  _internal_set_has_form_tag(value);
  // @@protoc_insertion_point(field_set:autofill.AutofillUploadContents.has_form_tag)
}

// optional bool was_throttleable = 38;
inline bool AutofillUploadContents::_internal_has_was_throttleable() const {
  bool value = (_has_bits_[0] & 0x00100000u) != 0;
  return value;
}
inline bool AutofillUploadContents::has_was_throttleable() const {
  return _internal_has_was_throttleable();
}
inline void AutofillUploadContents::clear_was_throttleable() {
  was_throttleable_ = false;
  _has_bits_[0] &= ~0x00100000u;
}
inline bool AutofillUploadContents::_internal_was_throttleable() const {
  return was_throttleable_;
}
inline bool AutofillUploadContents::was_throttleable() const {
  // @@protoc_insertion_point(field_get:autofill.AutofillUploadContents.was_throttleable)
  return _internal_was_throttleable();
}
inline void AutofillUploadContents::_internal_set_was_throttleable(bool value) {
  _has_bits_[0] |= 0x00100000u;
  was_throttleable_ = value;
}
inline void AutofillUploadContents::set_was_throttleable(bool value) {
  _internal_set_was_throttleable(value);
  // @@protoc_insertion_point(field_set:autofill.AutofillUploadContents.was_throttleable)
}

// optional .autofill.AutofillUploadContents.SingleUsernameData single_username_data = 42;
inline bool AutofillUploadContents::_internal_has_single_username_data() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || single_username_data_ != nullptr);
  return value;
}
inline bool AutofillUploadContents::has_single_username_data() const {
  return _internal_has_single_username_data();
}
inline void AutofillUploadContents::clear_single_username_data() {
  if (single_username_data_ != nullptr) single_username_data_->Clear();
  _has_bits_[0] &= ~0x00000020u;
}
inline const ::autofill::AutofillUploadContents_SingleUsernameData& AutofillUploadContents::_internal_single_username_data() const {
  const ::autofill::AutofillUploadContents_SingleUsernameData* p = single_username_data_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill::AutofillUploadContents_SingleUsernameData&>(
      ::autofill::_AutofillUploadContents_SingleUsernameData_default_instance_);
}
inline const ::autofill::AutofillUploadContents_SingleUsernameData& AutofillUploadContents::single_username_data() const {
  // @@protoc_insertion_point(field_get:autofill.AutofillUploadContents.single_username_data)
  return _internal_single_username_data();
}
inline void AutofillUploadContents::unsafe_arena_set_allocated_single_username_data(
    ::autofill::AutofillUploadContents_SingleUsernameData* single_username_data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(single_username_data_);
  }
  single_username_data_ = single_username_data;
  if (single_username_data) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill.AutofillUploadContents.single_username_data)
}
inline ::autofill::AutofillUploadContents_SingleUsernameData* AutofillUploadContents::release_single_username_data() {
  _has_bits_[0] &= ~0x00000020u;
  ::autofill::AutofillUploadContents_SingleUsernameData* temp = single_username_data_;
  single_username_data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill::AutofillUploadContents_SingleUsernameData* AutofillUploadContents::unsafe_arena_release_single_username_data() {
  // @@protoc_insertion_point(field_release:autofill.AutofillUploadContents.single_username_data)
  _has_bits_[0] &= ~0x00000020u;
  ::autofill::AutofillUploadContents_SingleUsernameData* temp = single_username_data_;
  single_username_data_ = nullptr;
  return temp;
}
inline ::autofill::AutofillUploadContents_SingleUsernameData* AutofillUploadContents::_internal_mutable_single_username_data() {
  _has_bits_[0] |= 0x00000020u;
  if (single_username_data_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill::AutofillUploadContents_SingleUsernameData>(GetArenaForAllocation());
    single_username_data_ = p;
  }
  return single_username_data_;
}
inline ::autofill::AutofillUploadContents_SingleUsernameData* AutofillUploadContents::mutable_single_username_data() {
  ::autofill::AutofillUploadContents_SingleUsernameData* _msg = _internal_mutable_single_username_data();
  // @@protoc_insertion_point(field_mutable:autofill.AutofillUploadContents.single_username_data)
  return _msg;
}
inline void AutofillUploadContents::set_allocated_single_username_data(::autofill::AutofillUploadContents_SingleUsernameData* single_username_data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete single_username_data_;
  }
  if (single_username_data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(single_username_data);
    if (message_arena != submessage_arena) {
      single_username_data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, single_username_data, submessage_arena);
    }
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  single_username_data_ = single_username_data;
  // @@protoc_insertion_point(field_set_allocated:autofill.AutofillUploadContents.single_username_data)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ProfileValidityMap

// map<int32, int32> field_validity_states = 1;
inline int ProfileValidityMap::_internal_field_validity_states_size() const {
  return field_validity_states_.size();
}
inline int ProfileValidityMap::field_validity_states_size() const {
  return _internal_field_validity_states_size();
}
inline void ProfileValidityMap::clear_field_validity_states() {
  field_validity_states_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< int32_t, int32_t >&
ProfileValidityMap::_internal_field_validity_states() const {
  return field_validity_states_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< int32_t, int32_t >&
ProfileValidityMap::field_validity_states() const {
  // @@protoc_insertion_point(field_map:autofill.ProfileValidityMap.field_validity_states)
  return _internal_field_validity_states();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< int32_t, int32_t >*
ProfileValidityMap::_internal_mutable_field_validity_states() {
  return field_validity_states_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< int32_t, int32_t >*
ProfileValidityMap::mutable_field_validity_states() {
  // @@protoc_insertion_point(field_mutable_map:autofill.ProfileValidityMap.field_validity_states)
  return _internal_mutable_field_validity_states();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// UserProfileValidityMap

// map<string, .autofill.ProfileValidityMap> profile_validity = 1;
inline int UserProfileValidityMap::_internal_profile_validity_size() const {
  return profile_validity_.size();
}
inline int UserProfileValidityMap::profile_validity_size() const {
  return _internal_profile_validity_size();
}
inline void UserProfileValidityMap::clear_profile_validity() {
  profile_validity_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::autofill::ProfileValidityMap >&
UserProfileValidityMap::_internal_profile_validity() const {
  return profile_validity_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::autofill::ProfileValidityMap >&
UserProfileValidityMap::profile_validity() const {
  // @@protoc_insertion_point(field_map:autofill.UserProfileValidityMap.profile_validity)
  return _internal_profile_validity();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::autofill::ProfileValidityMap >*
UserProfileValidityMap::_internal_mutable_profile_validity() {
  return profile_validity_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::autofill::ProfileValidityMap >*
UserProfileValidityMap::mutable_profile_validity() {
  // @@protoc_insertion_point(field_mutable_map:autofill.UserProfileValidityMap.profile_validity)
  return _internal_mutable_profile_validity();
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace autofill

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::autofill::AutofillRandomizedValue_EncodingType> : ::std::true_type {};
template <> struct is_proto_enum< ::autofill::AutofillUploadContents_Field_PasswordGenerationType> : ::std::true_type {};
template <> struct is_proto_enum< ::autofill::AutofillUploadContents_Field_VoteType> : ::std::true_type {};
template <> struct is_proto_enum< ::autofill::AutofillUploadContents_Field_SingleUsernameVoteType> : ::std::true_type {};
template <> struct is_proto_enum< ::autofill::AutofillUploadContents_SubmissionIndicatorEvent> : ::std::true_type {};
template <> struct is_proto_enum< ::autofill::AutofillUploadContents_ValueType> : ::std::true_type {};
template <> struct is_proto_enum< ::autofill::AutofillUploadContents_SingleUsernamePromptEdit> : ::std::true_type {};
template <> struct is_proto_enum< ::autofill::ButtonTitleType> : ::std::true_type {};

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_server_2eproto
