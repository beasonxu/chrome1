// components/autofill/core/common/mojom/autofill_types.mojom-shared-internal.h is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2016 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef COMPONENTS_AUTOFILL_CORE_COMMON_MOJOM_AUTOFILL_TYPES_MOJOM_SHARED_INTERNAL_H_
#define COMPONENTS_AUTOFILL_CORE_COMMON_MOJOM_AUTOFILL_TYPES_MOJOM_SHARED_INTERNAL_H_
#include "mojo/public/cpp/bindings/lib/array_internal.h"
#include "mojo/public/cpp/bindings/lib/bindings_internal.h"
#include "mojo/public/cpp/bindings/lib/map_data_internal.h"
#include "mojo/public/cpp/bindings/lib/buffer.h"
#include "mojo/public/mojom/base/text_direction.mojom-shared-internal.h"
#include "mojo/public/mojom/base/time.mojom-shared-internal.h"
#include "mojo/public/mojom/base/string16.mojom-shared-internal.h"
#include "mojo/public/mojom/base/unguessable_token.mojom-shared-internal.h"
#include "ui/gfx/geometry/mojom/geometry.mojom-shared-internal.h"
#include "url/mojom/origin.mojom-shared-internal.h"
#include "url/mojom/url.mojom-shared-internal.h"
#include "mojo/public/cpp/bindings/lib/native_enum_data.h"
#include "mojo/public/interfaces/bindings/native_struct.mojom-shared-internal.h"



namespace mojo {
namespace internal {
class ValidationContext;
}
}
namespace autofill {
namespace mojom {
namespace internal {
class FrameToken_Data;
class FrameTokenWithPredecessor_Data;
class FormRendererId_Data;
class FieldRendererId_Data;
class SelectOption_Data;
class SectionAutocomplete_Data;
class SectionFieldIdentifier_Data;
class Section_Data;
class FormFieldData_Data;
class ButtonTitleInfo_Data;
class FormData_Data;
class FormFieldDataPredictions_Data;
class FormDataPredictions_Data;
class PasswordAndMetadata_Data;
class PasswordFormFillData_Data;
class PasswordFormGenerationData_Data;
class PasswordGenerationUIData_Data;
class ParsingResult_Data;
class TouchToFillEligible_Data;
class SectionPrefix_Data;

struct SubmissionIndicatorEvent_Data {
 public:
  static bool constexpr kIsExtensible = false;

  static bool IsKnownValue(int32_t value) {
    switch (value) {
      case 0:
      case 1:
      case 2:
      case 3:
      case 4:
      case 6:
      case 7:
      case 10:
      case 11:
        return true;
    }
    return false;
  }

  static bool Validate(int32_t value,
                       mojo::internal::ValidationContext* validation_context) {
    if (kIsExtensible || IsKnownValue(value))
      return true;

    ReportValidationError(validation_context,
                          mojo::internal::VALIDATION_ERROR_UNKNOWN_ENUM_VALUE);
    return false;
  }
};

struct SubmissionSource_Data {
 public:
  static bool constexpr kIsExtensible = false;

  static bool IsKnownValue(int32_t value) {
    switch (value) {
      case 0:
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
      case 6:
        return true;
    }
    return false;
  }

  static bool Validate(int32_t value,
                       mojo::internal::ValidationContext* validation_context) {
    if (kIsExtensible || IsKnownValue(value))
      return true;

    ReportValidationError(validation_context,
                          mojo::internal::VALIDATION_ERROR_UNKNOWN_ENUM_VALUE);
    return false;
  }
};

struct FocusedFieldType_Data {
 public:
  static bool constexpr kIsExtensible = false;

  static bool IsKnownValue(int32_t value) {
    switch (value) {
      case 0:
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
      case 6:
        return true;
    }
    return false;
  }

  static bool Validate(int32_t value,
                       mojo::internal::ValidationContext* validation_context) {
    if (kIsExtensible || IsKnownValue(value))
      return true;

    ReportValidationError(validation_context,
                          mojo::internal::VALIDATION_ERROR_UNKNOWN_ENUM_VALUE);
    return false;
  }
};

struct ButtonTitleType_Data {
 public:
  static bool constexpr kIsExtensible = false;

  static bool IsKnownValue(int32_t value) {
    switch (value) {
      case 0:
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
      case 6:
      case 7:
        return true;
    }
    return false;
  }

  static bool Validate(int32_t value,
                       mojo::internal::ValidationContext* validation_context) {
    if (kIsExtensible || IsKnownValue(value))
      return true;

    ReportValidationError(validation_context,
                          mojo::internal::VALIDATION_ERROR_UNKNOWN_ENUM_VALUE);
    return false;
  }
};

struct SubmissionReadinessState_Data {
 public:
  static bool constexpr kIsExtensible = false;

  static bool IsKnownValue(int32_t value) {
    switch (value) {
      case 0:
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
      case 6:
      case 7:
        return true;
    }
    return false;
  }

  static bool Validate(int32_t value,
                       mojo::internal::ValidationContext* validation_context) {
    if (kIsExtensible || IsKnownValue(value))
      return true;

    ReportValidationError(validation_context,
                          mojo::internal::VALIDATION_ERROR_UNKNOWN_ENUM_VALUE);
    return false;
  }
};

struct AutofillState_Data {
 public:
  static bool constexpr kIsExtensible = false;

  static bool IsKnownValue(int32_t value) {
    switch (value) {
      case 0:
      case 1:
      case 2:
        return true;
    }
    return false;
  }

  static bool Validate(int32_t value,
                       mojo::internal::ValidationContext* validation_context) {
    if (kIsExtensible || IsKnownValue(value))
      return true;

    ReportValidationError(validation_context,
                          mojo::internal::VALIDATION_ERROR_UNKNOWN_ENUM_VALUE);
    return false;
  }
};

struct RendererFormDataAction_Data {
 public:
  static bool constexpr kIsExtensible = false;

  static bool IsKnownValue(int32_t value) {
    switch (value) {
      case 0:
      case 1:
        return true;
    }
    return false;
  }

  static bool Validate(int32_t value,
                       mojo::internal::ValidationContext* validation_context) {
    if (kIsExtensible || IsKnownValue(value))
      return true;

    ReportValidationError(validation_context,
                          mojo::internal::VALIDATION_ERROR_UNKNOWN_ENUM_VALUE);
    return false;
  }
};

struct FormFieldData_CheckStatus_Data {
 public:
  static bool constexpr kIsExtensible = false;

  static bool IsKnownValue(int32_t value) {
    switch (value) {
      case 0:
      case 1:
      case 2:
        return true;
    }
    return false;
  }

  static bool Validate(int32_t value,
                       mojo::internal::ValidationContext* validation_context) {
    if (kIsExtensible || IsKnownValue(value))
      return true;

    ReportValidationError(validation_context,
                          mojo::internal::VALIDATION_ERROR_UNKNOWN_ENUM_VALUE);
    return false;
  }
};

struct FormFieldData_RoleAttribute_Data {
 public:
  static bool constexpr kIsExtensible = false;

  static bool IsKnownValue(int32_t value) {
    switch (value) {
      case 0:
      case 1:
        return true;
    }
    return false;
  }

  static bool Validate(int32_t value,
                       mojo::internal::ValidationContext* validation_context) {
    if (kIsExtensible || IsKnownValue(value))
      return true;

    ReportValidationError(validation_context,
                          mojo::internal::VALIDATION_ERROR_UNKNOWN_ENUM_VALUE);
    return false;
  }
};

struct FormFieldData_LabelSource_Data {
 public:
  static bool constexpr kIsExtensible = false;

  static bool IsKnownValue(int32_t value) {
    switch (value) {
      case 0:
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
      case 6:
      case 7:
      case 8:
      case 9:
      case 10:
        return true;
    }
    return false;
  }

  static bool Validate(int32_t value,
                       mojo::internal::ValidationContext* validation_context) {
    if (kIsExtensible || IsKnownValue(value))
      return true;

    ReportValidationError(validation_context,
                          mojo::internal::VALIDATION_ERROR_UNKNOWN_ENUM_VALUE);
    return false;
  }
};

#pragma pack(push, 1)


class  SectionPrefix_Data {
 public:
  // Used to identify Mojom Union Data Classes.
  typedef void MojomUnionDataType;

  SectionPrefix_Data() = default;
  // Do nothing in the destructor since it won't be called when it is a
  // non-inlined union.
  ~SectionPrefix_Data() = default;

  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context,
                       bool inlined);

  bool is_null() const { return size == 0; }

  void set_null() {
    size = 0U;
    tag = static_cast<SectionPrefix_Tag>(0);
    data.unknown = 0U;
  }

  // TODO(crbug.com/1148486): SHOUTY_CASE values are being deprecated per C++ code style
  // guidelines (https://google.github.io/styleguide/cppguide.html#Enumerator_Names),
  // please use kCamelCase values instead.  Cleanup NULL_VALUE, BOOL_VALUE, INT_VALUE, etc.
  // generation once codebase is transitioned to kNullValue, kBoolValue, kIntValue, etc.
  enum class SectionPrefix_Tag : uint32_t {

    
    kDefaultPrefix,
    
    kAutocompleteSectionPrefix,
    
    kFromFieldPrefix,
    
    kCreditCardPrefix,
  };

  // A note on layout:
  // "Each non-static data member is allocated as if it were the sole member of
  // a struct." - Section 9.5.2 ISO/IEC 14882:2011 (The C++ Spec)
  union MOJO_ALIGNAS(8) Union_ {
    Union_() : unknown(0) {}
    uint8_t f_default_prefix : 1;
    mojo::internal::Pointer<internal::SectionAutocomplete_Data> f_autocomplete_section_prefix;
    mojo::internal::Pointer<internal::SectionFieldIdentifier_Data> f_from_field_prefix;
    uint8_t f_credit_card_prefix : 1;
    uint64_t unknown;
  };

  uint32_t size;
  SectionPrefix_Tag tag;
  Union_ data;
};
static_assert(sizeof(SectionPrefix_Data) == mojo::internal::kUnionDataSize,
              "Bad sizeof(SectionPrefix_Data)");
class  FrameToken_Data {
 public:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);

  mojo::internal::StructHeader header_;
  mojo::internal::Pointer<::mojo_base::mojom::internal::UnguessableToken_Data> token;
  uint8_t is_local : 1;
  uint8_t padfinal_[7];

 private:
  friend class mojo::internal::MessageFragment<FrameToken_Data>;

  FrameToken_Data();
  ~FrameToken_Data() = delete;
};
static_assert(sizeof(FrameToken_Data) == 24,
              "Bad sizeof(FrameToken_Data)");
// Used by FrameToken::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView>
struct FrameToken_UnserializedMessageContext
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  FrameToken_UnserializedMessageContext(
    uint32_t message_name,
    uint32_t message_flags,
    UserType input)
      : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
      , user_data_(std::move(input)) {}
  ~FrameToken_UnserializedMessageContext() override = default;

  UserType TakeData() {
    return std::move(user_data_);
  }

 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::Message& message) override {
    mojo::internal::MessageFragment<FrameToken_Data> fragment(message);
    mojo::internal::Serialize<DataView>(user_data_, fragment);
  }

  UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag
    FrameToken_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class  FrameTokenWithPredecessor_Data {
 public:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);

  mojo::internal::StructHeader header_;
  mojo::internal::Pointer<internal::FrameToken_Data> token;
  int32_t predecessor;
  uint8_t padfinal_[4];

 private:
  friend class mojo::internal::MessageFragment<FrameTokenWithPredecessor_Data>;

  FrameTokenWithPredecessor_Data();
  ~FrameTokenWithPredecessor_Data() = delete;
};
static_assert(sizeof(FrameTokenWithPredecessor_Data) == 24,
              "Bad sizeof(FrameTokenWithPredecessor_Data)");
// Used by FrameTokenWithPredecessor::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView>
struct FrameTokenWithPredecessor_UnserializedMessageContext
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  FrameTokenWithPredecessor_UnserializedMessageContext(
    uint32_t message_name,
    uint32_t message_flags,
    UserType input)
      : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
      , user_data_(std::move(input)) {}
  ~FrameTokenWithPredecessor_UnserializedMessageContext() override = default;

  UserType TakeData() {
    return std::move(user_data_);
  }

 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::Message& message) override {
    mojo::internal::MessageFragment<FrameTokenWithPredecessor_Data> fragment(message);
    mojo::internal::Serialize<DataView>(user_data_, fragment);
  }

  UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag
    FrameTokenWithPredecessor_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class  FormRendererId_Data {
 public:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);

  mojo::internal::StructHeader header_;
  uint64_t id;

 private:
  friend class mojo::internal::MessageFragment<FormRendererId_Data>;

  FormRendererId_Data();
  ~FormRendererId_Data() = delete;
};
static_assert(sizeof(FormRendererId_Data) == 16,
              "Bad sizeof(FormRendererId_Data)");
// Used by FormRendererId::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView>
struct FormRendererId_UnserializedMessageContext
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  FormRendererId_UnserializedMessageContext(
    uint32_t message_name,
    uint32_t message_flags,
    UserType input)
      : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
      , user_data_(std::move(input)) {}
  ~FormRendererId_UnserializedMessageContext() override = default;

  UserType TakeData() {
    return std::move(user_data_);
  }

 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::Message& message) override {
    mojo::internal::MessageFragment<FormRendererId_Data> fragment(message);
    mojo::internal::Serialize<DataView>(user_data_, fragment);
  }

  UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag
    FormRendererId_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class  FieldRendererId_Data {
 public:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);

  mojo::internal::StructHeader header_;
  uint64_t id;

 private:
  friend class mojo::internal::MessageFragment<FieldRendererId_Data>;

  FieldRendererId_Data();
  ~FieldRendererId_Data() = delete;
};
static_assert(sizeof(FieldRendererId_Data) == 16,
              "Bad sizeof(FieldRendererId_Data)");
// Used by FieldRendererId::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView>
struct FieldRendererId_UnserializedMessageContext
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  FieldRendererId_UnserializedMessageContext(
    uint32_t message_name,
    uint32_t message_flags,
    UserType input)
      : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
      , user_data_(std::move(input)) {}
  ~FieldRendererId_UnserializedMessageContext() override = default;

  UserType TakeData() {
    return std::move(user_data_);
  }

 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::Message& message) override {
    mojo::internal::MessageFragment<FieldRendererId_Data> fragment(message);
    mojo::internal::Serialize<DataView>(user_data_, fragment);
  }

  UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag
    FieldRendererId_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class  SelectOption_Data {
 public:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);

  mojo::internal::StructHeader header_;
  mojo::internal::Pointer<::mojo_base::mojom::internal::String16_Data> value;
  mojo::internal::Pointer<::mojo_base::mojom::internal::String16_Data> content;

 private:
  friend class mojo::internal::MessageFragment<SelectOption_Data>;

  SelectOption_Data();
  ~SelectOption_Data() = delete;
};
static_assert(sizeof(SelectOption_Data) == 24,
              "Bad sizeof(SelectOption_Data)");
// Used by SelectOption::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView>
struct SelectOption_UnserializedMessageContext
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  SelectOption_UnserializedMessageContext(
    uint32_t message_name,
    uint32_t message_flags,
    UserType input)
      : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
      , user_data_(std::move(input)) {}
  ~SelectOption_UnserializedMessageContext() override = default;

  UserType TakeData() {
    return std::move(user_data_);
  }

 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::Message& message) override {
    mojo::internal::MessageFragment<SelectOption_Data> fragment(message);
    mojo::internal::Serialize<DataView>(user_data_, fragment);
  }

  UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag
    SelectOption_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class  SectionAutocomplete_Data {
 public:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);

  mojo::internal::StructHeader header_;
  mojo::internal::Pointer<mojo::internal::String_Data> section;
  uint8_t html_field_mode;
  uint8_t padfinal_[7];

 private:
  friend class mojo::internal::MessageFragment<SectionAutocomplete_Data>;

  SectionAutocomplete_Data();
  ~SectionAutocomplete_Data() = delete;
};
static_assert(sizeof(SectionAutocomplete_Data) == 24,
              "Bad sizeof(SectionAutocomplete_Data)");
// Used by SectionAutocomplete::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView>
struct SectionAutocomplete_UnserializedMessageContext
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  SectionAutocomplete_UnserializedMessageContext(
    uint32_t message_name,
    uint32_t message_flags,
    UserType input)
      : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
      , user_data_(std::move(input)) {}
  ~SectionAutocomplete_UnserializedMessageContext() override = default;

  UserType TakeData() {
    return std::move(user_data_);
  }

 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::Message& message) override {
    mojo::internal::MessageFragment<SectionAutocomplete_Data> fragment(message);
    mojo::internal::Serialize<DataView>(user_data_, fragment);
  }

  UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag
    SectionAutocomplete_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class  SectionFieldIdentifier_Data {
 public:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);

  mojo::internal::StructHeader header_;
  mojo::internal::Pointer<mojo::internal::String_Data> field_name;
  uint64_t local_frame_id;
  mojo::internal::Pointer<internal::FieldRendererId_Data> field_renderer_id;

 private:
  friend class mojo::internal::MessageFragment<SectionFieldIdentifier_Data>;

  SectionFieldIdentifier_Data();
  ~SectionFieldIdentifier_Data() = delete;
};
static_assert(sizeof(SectionFieldIdentifier_Data) == 32,
              "Bad sizeof(SectionFieldIdentifier_Data)");
// Used by SectionFieldIdentifier::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView>
struct SectionFieldIdentifier_UnserializedMessageContext
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  SectionFieldIdentifier_UnserializedMessageContext(
    uint32_t message_name,
    uint32_t message_flags,
    UserType input)
      : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
      , user_data_(std::move(input)) {}
  ~SectionFieldIdentifier_UnserializedMessageContext() override = default;

  UserType TakeData() {
    return std::move(user_data_);
  }

 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::Message& message) override {
    mojo::internal::MessageFragment<SectionFieldIdentifier_Data> fragment(message);
    mojo::internal::Serialize<DataView>(user_data_, fragment);
  }

  UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag
    SectionFieldIdentifier_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class  Section_Data {
 public:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);

  mojo::internal::StructHeader header_;
  uint8_t field_type_group;
  uint8_t pad0_[7];
  internal::SectionPrefix_Data prefix;

 private:
  friend class mojo::internal::MessageFragment<Section_Data>;

  Section_Data();
  ~Section_Data() = delete;
};
static_assert(sizeof(Section_Data) == 32,
              "Bad sizeof(Section_Data)");
// Used by Section::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView>
struct Section_UnserializedMessageContext
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  Section_UnserializedMessageContext(
    uint32_t message_name,
    uint32_t message_flags,
    UserType input)
      : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
      , user_data_(std::move(input)) {}
  ~Section_UnserializedMessageContext() override = default;

  UserType TakeData() {
    return std::move(user_data_);
  }

 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::Message& message) override {
    mojo::internal::MessageFragment<Section_Data> fragment(message);
    mojo::internal::Serialize<DataView>(user_data_, fragment);
  }

  UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag
    Section_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class  FormFieldData_Data {
 public:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);

  mojo::internal::StructHeader header_;
  mojo::internal::Pointer<::mojo_base::mojom::internal::String16_Data> label;
  mojo::internal::Pointer<::mojo_base::mojom::internal::String16_Data> name;
  mojo::internal::Pointer<::mojo_base::mojom::internal::String16_Data> id_attribute;
  mojo::internal::Pointer<::mojo_base::mojom::internal::String16_Data> name_attribute;
  mojo::internal::Pointer<::mojo_base::mojom::internal::String16_Data> value;
  mojo::internal::Pointer<mojo::internal::String_Data> form_control_type;
  mojo::internal::Pointer<mojo::internal::String_Data> autocomplete_attribute;
  mojo::internal::Pointer<::mojo_base::mojom::internal::String16_Data> placeholder;
  mojo::internal::Pointer<::mojo_base::mojom::internal::String16_Data> css_classes;
  mojo::internal::Pointer<::mojo_base::mojom::internal::String16_Data> aria_label;
  mojo::internal::Pointer<::mojo_base::mojom::internal::String16_Data> aria_description;
  mojo::internal::Pointer<internal::FieldRendererId_Data> unique_renderer_id;
  mojo::internal::Pointer<internal::FormRendererId_Data> host_form_id;
  uint32_t properties_mask;
  int32_t form_control_ax_id;
  uint64_t max_length;
  uint8_t is_autofilled : 1;
  uint8_t is_focusable : 1;
  uint8_t is_visible : 1;
  uint8_t should_autocomplete : 1;
  uint8_t is_enabled : 1;
  uint8_t is_readonly : 1;
  uint8_t force_override : 1;
  uint8_t pad22_[3];
  int32_t check_status;
  mojo::internal::Pointer<internal::Section_Data> section;
  int32_t role;
  int32_t text_direction;
  mojo::internal::Pointer<::mojo_base::mojom::internal::String16_Data> user_input;
  mojo::internal::Pointer<mojo::internal::Array_Data<mojo::internal::Pointer<internal::SelectOption_Data>>> options;
  int32_t label_source;
  uint8_t pad29_[4];
  mojo::internal::Pointer<::gfx::mojom::internal::RectF_Data> bounds;
  mojo::internal::Pointer<mojo::internal::Array_Data<mojo::internal::Pointer<::mojo_base::mojom::internal::String16_Data>>> datalist_values;
  mojo::internal::Pointer<mojo::internal::Array_Data<mojo::internal::Pointer<::mojo_base::mojom::internal::String16_Data>>> datalist_labels;

 private:
  friend class mojo::internal::MessageFragment<FormFieldData_Data>;

  FormFieldData_Data();
  ~FormFieldData_Data() = delete;
};
static_assert(sizeof(FormFieldData_Data) == 200,
              "Bad sizeof(FormFieldData_Data)");
// Used by FormFieldData::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView>
struct FormFieldData_UnserializedMessageContext
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  FormFieldData_UnserializedMessageContext(
    uint32_t message_name,
    uint32_t message_flags,
    UserType input)
      : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
      , user_data_(std::move(input)) {}
  ~FormFieldData_UnserializedMessageContext() override = default;

  UserType TakeData() {
    return std::move(user_data_);
  }

 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::Message& message) override {
    mojo::internal::MessageFragment<FormFieldData_Data> fragment(message);
    mojo::internal::Serialize<DataView>(user_data_, fragment);
  }

  UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag
    FormFieldData_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class  ButtonTitleInfo_Data {
 public:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);

  mojo::internal::StructHeader header_;
  mojo::internal::Pointer<::mojo_base::mojom::internal::String16_Data> title;
  int32_t type;
  uint8_t padfinal_[4];

 private:
  friend class mojo::internal::MessageFragment<ButtonTitleInfo_Data>;

  ButtonTitleInfo_Data();
  ~ButtonTitleInfo_Data() = delete;
};
static_assert(sizeof(ButtonTitleInfo_Data) == 24,
              "Bad sizeof(ButtonTitleInfo_Data)");
// Used by ButtonTitleInfo::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView>
struct ButtonTitleInfo_UnserializedMessageContext
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  ButtonTitleInfo_UnserializedMessageContext(
    uint32_t message_name,
    uint32_t message_flags,
    UserType input)
      : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
      , user_data_(std::move(input)) {}
  ~ButtonTitleInfo_UnserializedMessageContext() override = default;

  UserType TakeData() {
    return std::move(user_data_);
  }

 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::Message& message) override {
    mojo::internal::MessageFragment<ButtonTitleInfo_Data> fragment(message);
    mojo::internal::Serialize<DataView>(user_data_, fragment);
  }

  UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag
    ButtonTitleInfo_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class  FormData_Data {
 public:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);

  mojo::internal::StructHeader header_;
  mojo::internal::Pointer<::mojo_base::mojom::internal::String16_Data> id_attribute;
  mojo::internal::Pointer<::mojo_base::mojom::internal::String16_Data> name_attribute;
  mojo::internal::Pointer<::mojo_base::mojom::internal::String16_Data> name;
  mojo::internal::Pointer<mojo::internal::Array_Data<mojo::internal::Pointer<internal::ButtonTitleInfo_Data>>> button_titles;
  mojo::internal::Pointer<::url::mojom::internal::Url_Data> action;
  uint8_t is_action_empty : 1;
  uint8_t is_form_tag : 1;
  uint8_t is_gaia_with_skip_save_password_form : 1;
  uint8_t pad7_[3];
  int32_t submission_event;
  mojo::internal::Pointer<internal::FormRendererId_Data> unique_renderer_id;
  mojo::internal::Pointer<mojo::internal::Array_Data<mojo::internal::Pointer<internal::FrameTokenWithPredecessor_Data>>> child_frames;
  mojo::internal::Pointer<mojo::internal::Array_Data<mojo::internal::Pointer<internal::FormFieldData_Data>>> fields;
  mojo::internal::Pointer<mojo::internal::Array_Data<mojo::internal::Pointer<internal::FieldRendererId_Data>>> username_predictions;

 private:
  friend class mojo::internal::MessageFragment<FormData_Data>;

  FormData_Data();
  ~FormData_Data() = delete;
};
static_assert(sizeof(FormData_Data) == 88,
              "Bad sizeof(FormData_Data)");
// Used by FormData::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView>
struct FormData_UnserializedMessageContext
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  FormData_UnserializedMessageContext(
    uint32_t message_name,
    uint32_t message_flags,
    UserType input)
      : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
      , user_data_(std::move(input)) {}
  ~FormData_UnserializedMessageContext() override = default;

  UserType TakeData() {
    return std::move(user_data_);
  }

 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::Message& message) override {
    mojo::internal::MessageFragment<FormData_Data> fragment(message);
    mojo::internal::Serialize<DataView>(user_data_, fragment);
  }

  UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag
    FormData_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class  FormFieldDataPredictions_Data {
 public:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);

  mojo::internal::StructHeader header_;
  mojo::internal::Pointer<mojo::internal::String_Data> host_form_signature;
  mojo::internal::Pointer<mojo::internal::String_Data> signature;
  mojo::internal::Pointer<mojo::internal::String_Data> heuristic_type;
  mojo::internal::Pointer<mojo::internal::String_Data> server_type;
  mojo::internal::Pointer<mojo::internal::String_Data> overall_type;
  mojo::internal::Pointer<mojo::internal::String_Data> parseable_name;
  mojo::internal::Pointer<mojo::internal::String_Data> section;

 private:
  friend class mojo::internal::MessageFragment<FormFieldDataPredictions_Data>;

  FormFieldDataPredictions_Data();
  ~FormFieldDataPredictions_Data() = delete;
};
static_assert(sizeof(FormFieldDataPredictions_Data) == 64,
              "Bad sizeof(FormFieldDataPredictions_Data)");
// Used by FormFieldDataPredictions::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView>
struct FormFieldDataPredictions_UnserializedMessageContext
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  FormFieldDataPredictions_UnserializedMessageContext(
    uint32_t message_name,
    uint32_t message_flags,
    UserType input)
      : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
      , user_data_(std::move(input)) {}
  ~FormFieldDataPredictions_UnserializedMessageContext() override = default;

  UserType TakeData() {
    return std::move(user_data_);
  }

 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::Message& message) override {
    mojo::internal::MessageFragment<FormFieldDataPredictions_Data> fragment(message);
    mojo::internal::Serialize<DataView>(user_data_, fragment);
  }

  UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag
    FormFieldDataPredictions_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class  FormDataPredictions_Data {
 public:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);

  mojo::internal::StructHeader header_;
  mojo::internal::Pointer<internal::FormData_Data> data;
  mojo::internal::Pointer<mojo::internal::String_Data> signature;
  mojo::internal::Pointer<mojo::internal::Array_Data<mojo::internal::Pointer<internal::FormFieldDataPredictions_Data>>> fields;

 private:
  friend class mojo::internal::MessageFragment<FormDataPredictions_Data>;

  FormDataPredictions_Data();
  ~FormDataPredictions_Data() = delete;
};
static_assert(sizeof(FormDataPredictions_Data) == 32,
              "Bad sizeof(FormDataPredictions_Data)");
// Used by FormDataPredictions::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView>
struct FormDataPredictions_UnserializedMessageContext
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  FormDataPredictions_UnserializedMessageContext(
    uint32_t message_name,
    uint32_t message_flags,
    UserType input)
      : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
      , user_data_(std::move(input)) {}
  ~FormDataPredictions_UnserializedMessageContext() override = default;

  UserType TakeData() {
    return std::move(user_data_);
  }

 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::Message& message) override {
    mojo::internal::MessageFragment<FormDataPredictions_Data> fragment(message);
    mojo::internal::Serialize<DataView>(user_data_, fragment);
  }

  UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag
    FormDataPredictions_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class  PasswordAndMetadata_Data {
 public:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);

  mojo::internal::StructHeader header_;
  mojo::internal::Pointer<::mojo_base::mojom::internal::String16_Data> username;
  mojo::internal::Pointer<::mojo_base::mojom::internal::String16_Data> password;
  mojo::internal::Pointer<mojo::internal::String_Data> realm;
  uint8_t uses_account_store : 1;
  uint8_t padfinal_[7];

 private:
  friend class mojo::internal::MessageFragment<PasswordAndMetadata_Data>;

  PasswordAndMetadata_Data();
  ~PasswordAndMetadata_Data() = delete;
};
static_assert(sizeof(PasswordAndMetadata_Data) == 40,
              "Bad sizeof(PasswordAndMetadata_Data)");
// Used by PasswordAndMetadata::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView>
struct PasswordAndMetadata_UnserializedMessageContext
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  PasswordAndMetadata_UnserializedMessageContext(
    uint32_t message_name,
    uint32_t message_flags,
    UserType input)
      : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
      , user_data_(std::move(input)) {}
  ~PasswordAndMetadata_UnserializedMessageContext() override = default;

  UserType TakeData() {
    return std::move(user_data_);
  }

 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::Message& message) override {
    mojo::internal::MessageFragment<PasswordAndMetadata_Data> fragment(message);
    mojo::internal::Serialize<DataView>(user_data_, fragment);
  }

  UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag
    PasswordAndMetadata_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class  PasswordFormFillData_Data {
 public:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);

  mojo::internal::StructHeader header_;
  mojo::internal::Pointer<internal::FormRendererId_Data> form_renderer_id;
  mojo::internal::Pointer<::url::mojom::internal::Url_Data> url;
  mojo::internal::Pointer<::url::mojom::internal::Url_Data> action;
  mojo::internal::Pointer<internal::FormFieldData_Data> username_field;
  mojo::internal::Pointer<internal::FormFieldData_Data> password_field;
  uint8_t username_may_use_prefilled_placeholder : 1;
  uint8_t uses_account_store : 1;
  uint8_t wait_for_username : 1;
  uint8_t pad7_[7];
  mojo::internal::Pointer<mojo::internal::String_Data> preferred_realm;
  mojo::internal::Pointer<mojo::internal::Array_Data<mojo::internal::Pointer<internal::PasswordAndMetadata_Data>>> additional_logins;

 private:
  friend class mojo::internal::MessageFragment<PasswordFormFillData_Data>;

  PasswordFormFillData_Data();
  ~PasswordFormFillData_Data() = delete;
};
static_assert(sizeof(PasswordFormFillData_Data) == 72,
              "Bad sizeof(PasswordFormFillData_Data)");
// Used by PasswordFormFillData::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView>
struct PasswordFormFillData_UnserializedMessageContext
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  PasswordFormFillData_UnserializedMessageContext(
    uint32_t message_name,
    uint32_t message_flags,
    UserType input)
      : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
      , user_data_(std::move(input)) {}
  ~PasswordFormFillData_UnserializedMessageContext() override = default;

  UserType TakeData() {
    return std::move(user_data_);
  }

 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::Message& message) override {
    mojo::internal::MessageFragment<PasswordFormFillData_Data> fragment(message);
    mojo::internal::Serialize<DataView>(user_data_, fragment);
  }

  UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag
    PasswordFormFillData_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class  PasswordFormGenerationData_Data {
 public:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);

  mojo::internal::StructHeader header_;
  mojo::internal::Pointer<internal::FieldRendererId_Data> new_password_renderer_id;
  mojo::internal::Pointer<internal::FieldRendererId_Data> confirmation_password_renderer_id;

 private:
  friend class mojo::internal::MessageFragment<PasswordFormGenerationData_Data>;

  PasswordFormGenerationData_Data();
  ~PasswordFormGenerationData_Data() = delete;
};
static_assert(sizeof(PasswordFormGenerationData_Data) == 24,
              "Bad sizeof(PasswordFormGenerationData_Data)");
// Used by PasswordFormGenerationData::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView>
struct PasswordFormGenerationData_UnserializedMessageContext
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  PasswordFormGenerationData_UnserializedMessageContext(
    uint32_t message_name,
    uint32_t message_flags,
    UserType input)
      : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
      , user_data_(std::move(input)) {}
  ~PasswordFormGenerationData_UnserializedMessageContext() override = default;

  UserType TakeData() {
    return std::move(user_data_);
  }

 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::Message& message) override {
    mojo::internal::MessageFragment<PasswordFormGenerationData_Data> fragment(message);
    mojo::internal::Serialize<DataView>(user_data_, fragment);
  }

  UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag
    PasswordFormGenerationData_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class  PasswordGenerationUIData_Data {
 public:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);

  mojo::internal::StructHeader header_;
  mojo::internal::Pointer<::gfx::mojom::internal::RectF_Data> bounds;
  int32_t max_length;
  uint8_t is_generation_element_password_type : 1;
  uint8_t pad2_[3];
  mojo::internal::Pointer<::mojo_base::mojom::internal::String16_Data> generation_element;
  mojo::internal::Pointer<internal::FieldRendererId_Data> generation_element_id;
  int32_t text_direction;
  uint8_t pad5_[4];
  mojo::internal::Pointer<internal::FormData_Data> form_data;

 private:
  friend class mojo::internal::MessageFragment<PasswordGenerationUIData_Data>;

  PasswordGenerationUIData_Data();
  ~PasswordGenerationUIData_Data() = delete;
};
static_assert(sizeof(PasswordGenerationUIData_Data) == 56,
              "Bad sizeof(PasswordGenerationUIData_Data)");
// Used by PasswordGenerationUIData::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView>
struct PasswordGenerationUIData_UnserializedMessageContext
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  PasswordGenerationUIData_UnserializedMessageContext(
    uint32_t message_name,
    uint32_t message_flags,
    UserType input)
      : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
      , user_data_(std::move(input)) {}
  ~PasswordGenerationUIData_UnserializedMessageContext() override = default;

  UserType TakeData() {
    return std::move(user_data_);
  }

 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::Message& message) override {
    mojo::internal::MessageFragment<PasswordGenerationUIData_Data> fragment(message);
    mojo::internal::Serialize<DataView>(user_data_, fragment);
  }

  UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag
    PasswordGenerationUIData_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class  ParsingResult_Data {
 public:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);

  mojo::internal::StructHeader header_;
  mojo::internal::Pointer<internal::FieldRendererId_Data> username_renderer_id;
  mojo::internal::Pointer<internal::FieldRendererId_Data> password_renderer_id;
  mojo::internal::Pointer<internal::FieldRendererId_Data> new_password_renderer_id;
  mojo::internal::Pointer<internal::FieldRendererId_Data> confirm_password_renderer_id;

 private:
  friend class mojo::internal::MessageFragment<ParsingResult_Data>;

  ParsingResult_Data();
  ~ParsingResult_Data() = delete;
};
static_assert(sizeof(ParsingResult_Data) == 40,
              "Bad sizeof(ParsingResult_Data)");
// Used by ParsingResult::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView>
struct ParsingResult_UnserializedMessageContext
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  ParsingResult_UnserializedMessageContext(
    uint32_t message_name,
    uint32_t message_flags,
    UserType input)
      : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
      , user_data_(std::move(input)) {}
  ~ParsingResult_UnserializedMessageContext() override = default;

  UserType TakeData() {
    return std::move(user_data_);
  }

 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::Message& message) override {
    mojo::internal::MessageFragment<ParsingResult_Data> fragment(message);
    mojo::internal::Serialize<DataView>(user_data_, fragment);
  }

  UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag
    ParsingResult_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class  TouchToFillEligible_Data {
 public:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);

  mojo::internal::StructHeader header_;
  uint8_t eligible : 1;
  uint8_t padfinal_[7];

 private:
  friend class mojo::internal::MessageFragment<TouchToFillEligible_Data>;

  TouchToFillEligible_Data();
  ~TouchToFillEligible_Data() = delete;
};
static_assert(sizeof(TouchToFillEligible_Data) == 16,
              "Bad sizeof(TouchToFillEligible_Data)");
// Used by TouchToFillEligible::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView>
struct TouchToFillEligible_UnserializedMessageContext
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  TouchToFillEligible_UnserializedMessageContext(
    uint32_t message_name,
    uint32_t message_flags,
    UserType input)
      : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
      , user_data_(std::move(input)) {}
  ~TouchToFillEligible_UnserializedMessageContext() override = default;

  UserType TakeData() {
    return std::move(user_data_);
  }

 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::Message& message) override {
    mojo::internal::MessageFragment<TouchToFillEligible_Data> fragment(message);
    mojo::internal::Serialize<DataView>(user_data_, fragment);
  }

  UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag
    TouchToFillEligible_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};

#pragma pack(pop)

}  // namespace internal
}  // namespace mojom
}  // namespace autofill

#endif  // COMPONENTS_AUTOFILL_CORE_COMMON_MOJOM_AUTOFILL_TYPES_MOJOM_SHARED_INTERNAL_H_