// components/autofill/content/common/mojom/autofill_driver.mojom.cc is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2013 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#if defined(__clang__)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-private-field"
#endif

#include "components/autofill/content/common/mojom/autofill_driver.mojom.h"

#include <math.h>
#include <stdint.h>
#include <utility>

#include "base/debug/alias.h"
#include "base/hash/md5_constexpr.h"
#include "base/run_loop.h"
#include "base/strings/string_number_conversions.h"
#include "base/trace_event/trace_event.h"
#include "base/trace_event/typed_macros.h"
#include "mojo/public/cpp/bindings/lib/generated_code_util.h"
#include "mojo/public/cpp/bindings/lib/message_internal.h"
#include "mojo/public/cpp/bindings/lib/send_message_helper.h"
#include "mojo/public/cpp/bindings/lib/proxy_to_responder.h"
#include "mojo/public/cpp/bindings/lib/serialization_util.h"
#include "mojo/public/cpp/bindings/lib/unserialized_message_context.h"
#include "mojo/public/cpp/bindings/lib/validate_params.h"
#include "mojo/public/cpp/bindings/lib/validation_errors.h"
#include "mojo/public/cpp/bindings/mojo_buildflags.h"
#include "mojo/public/interfaces/bindings/interface_control_messages.mojom.h"
#include "third_party/perfetto/include/perfetto/tracing/traced_value.h"

#include "components/autofill/content/common/mojom/autofill_driver.mojom-params-data.h"
#include "components/autofill/content/common/mojom/autofill_driver.mojom-shared-message-ids.h"

#include "components/autofill/content/common/mojom/autofill_driver.mojom-import-headers.h"
#include "components/autofill/content/common/mojom/autofill_driver.mojom-test-utils.h"


#ifndef COMPONENTS_AUTOFILL_CONTENT_COMMON_MOJOM_AUTOFILL_DRIVER_MOJOM_JUMBO_H_
#define COMPONENTS_AUTOFILL_CONTENT_COMMON_MOJOM_AUTOFILL_DRIVER_MOJOM_JUMBO_H_
#endif



namespace autofill {
namespace mojom {
const char AutofillDriver::Name_[] = "autofill.mojom.AutofillDriver";

AutofillDriver::IPCStableHashFunction AutofillDriver::MessageToMethodInfo_(mojo::Message& message) {
#if !BUILDFLAG(IS_FUCHSIA)
  switch (message.name()) {
    case internal::kAutofillDriver_SetFormToBeProbablySubmitted_Name: {
      return &AutofillDriver::SetFormToBeProbablySubmitted_Sym::IPCStableHash;
    }
    case internal::kAutofillDriver_FormsSeen_Name: {
      return &AutofillDriver::FormsSeen_Sym::IPCStableHash;
    }
    case internal::kAutofillDriver_FormSubmitted_Name: {
      return &AutofillDriver::FormSubmitted_Sym::IPCStableHash;
    }
    case internal::kAutofillDriver_TextFieldDidChange_Name: {
      return &AutofillDriver::TextFieldDidChange_Sym::IPCStableHash;
    }
    case internal::kAutofillDriver_TextFieldDidScroll_Name: {
      return &AutofillDriver::TextFieldDidScroll_Sym::IPCStableHash;
    }
    case internal::kAutofillDriver_SelectControlDidChange_Name: {
      return &AutofillDriver::SelectControlDidChange_Sym::IPCStableHash;
    }
    case internal::kAutofillDriver_SelectFieldOptionsDidChange_Name: {
      return &AutofillDriver::SelectFieldOptionsDidChange_Sym::IPCStableHash;
    }
    case internal::kAutofillDriver_AskForValuesToFill_Name: {
      return &AutofillDriver::AskForValuesToFill_Sym::IPCStableHash;
    }
    case internal::kAutofillDriver_HidePopup_Name: {
      return &AutofillDriver::HidePopup_Sym::IPCStableHash;
    }
    case internal::kAutofillDriver_FocusNoLongerOnForm_Name: {
      return &AutofillDriver::FocusNoLongerOnForm_Sym::IPCStableHash;
    }
    case internal::kAutofillDriver_FocusOnFormField_Name: {
      return &AutofillDriver::FocusOnFormField_Sym::IPCStableHash;
    }
    case internal::kAutofillDriver_DidFillAutofillFormData_Name: {
      return &AutofillDriver::DidFillAutofillFormData_Sym::IPCStableHash;
    }
    case internal::kAutofillDriver_DidPreviewAutofillFormData_Name: {
      return &AutofillDriver::DidPreviewAutofillFormData_Sym::IPCStableHash;
    }
    case internal::kAutofillDriver_DidEndTextFieldEditing_Name: {
      return &AutofillDriver::DidEndTextFieldEditing_Sym::IPCStableHash;
    }
    case internal::kAutofillDriver_JavaScriptChangedAutofilledValue_Name: {
      return &AutofillDriver::JavaScriptChangedAutofilledValue_Sym::IPCStableHash;
    }
  }
#endif  // !BUILDFLAG(IS_FUCHSIA)
  return nullptr;
}


const char* AutofillDriver::MessageToMethodName_(mojo::Message& message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  bool is_response = message.has_flag(mojo::Message::kFlagIsResponse);
  if (!is_response) {
    switch (message.name()) {
      case internal::kAutofillDriver_SetFormToBeProbablySubmitted_Name:
            return "Receive autofill::mojom::AutofillDriver::SetFormToBeProbablySubmitted";
      case internal::kAutofillDriver_FormsSeen_Name:
            return "Receive autofill::mojom::AutofillDriver::FormsSeen";
      case internal::kAutofillDriver_FormSubmitted_Name:
            return "Receive autofill::mojom::AutofillDriver::FormSubmitted";
      case internal::kAutofillDriver_TextFieldDidChange_Name:
            return "Receive autofill::mojom::AutofillDriver::TextFieldDidChange";
      case internal::kAutofillDriver_TextFieldDidScroll_Name:
            return "Receive autofill::mojom::AutofillDriver::TextFieldDidScroll";
      case internal::kAutofillDriver_SelectControlDidChange_Name:
            return "Receive autofill::mojom::AutofillDriver::SelectControlDidChange";
      case internal::kAutofillDriver_SelectFieldOptionsDidChange_Name:
            return "Receive autofill::mojom::AutofillDriver::SelectFieldOptionsDidChange";
      case internal::kAutofillDriver_AskForValuesToFill_Name:
            return "Receive autofill::mojom::AutofillDriver::AskForValuesToFill";
      case internal::kAutofillDriver_HidePopup_Name:
            return "Receive autofill::mojom::AutofillDriver::HidePopup";
      case internal::kAutofillDriver_FocusNoLongerOnForm_Name:
            return "Receive autofill::mojom::AutofillDriver::FocusNoLongerOnForm";
      case internal::kAutofillDriver_FocusOnFormField_Name:
            return "Receive autofill::mojom::AutofillDriver::FocusOnFormField";
      case internal::kAutofillDriver_DidFillAutofillFormData_Name:
            return "Receive autofill::mojom::AutofillDriver::DidFillAutofillFormData";
      case internal::kAutofillDriver_DidPreviewAutofillFormData_Name:
            return "Receive autofill::mojom::AutofillDriver::DidPreviewAutofillFormData";
      case internal::kAutofillDriver_DidEndTextFieldEditing_Name:
            return "Receive autofill::mojom::AutofillDriver::DidEndTextFieldEditing";
      case internal::kAutofillDriver_JavaScriptChangedAutofilledValue_Name:
            return "Receive autofill::mojom::AutofillDriver::JavaScriptChangedAutofilledValue";
    }
  } else {
    switch (message.name()) {
      case internal::kAutofillDriver_SetFormToBeProbablySubmitted_Name:
            return "Receive reply autofill::mojom::AutofillDriver::SetFormToBeProbablySubmitted";
      case internal::kAutofillDriver_FormsSeen_Name:
            return "Receive reply autofill::mojom::AutofillDriver::FormsSeen";
      case internal::kAutofillDriver_FormSubmitted_Name:
            return "Receive reply autofill::mojom::AutofillDriver::FormSubmitted";
      case internal::kAutofillDriver_TextFieldDidChange_Name:
            return "Receive reply autofill::mojom::AutofillDriver::TextFieldDidChange";
      case internal::kAutofillDriver_TextFieldDidScroll_Name:
            return "Receive reply autofill::mojom::AutofillDriver::TextFieldDidScroll";
      case internal::kAutofillDriver_SelectControlDidChange_Name:
            return "Receive reply autofill::mojom::AutofillDriver::SelectControlDidChange";
      case internal::kAutofillDriver_SelectFieldOptionsDidChange_Name:
            return "Receive reply autofill::mojom::AutofillDriver::SelectFieldOptionsDidChange";
      case internal::kAutofillDriver_AskForValuesToFill_Name:
            return "Receive reply autofill::mojom::AutofillDriver::AskForValuesToFill";
      case internal::kAutofillDriver_HidePopup_Name:
            return "Receive reply autofill::mojom::AutofillDriver::HidePopup";
      case internal::kAutofillDriver_FocusNoLongerOnForm_Name:
            return "Receive reply autofill::mojom::AutofillDriver::FocusNoLongerOnForm";
      case internal::kAutofillDriver_FocusOnFormField_Name:
            return "Receive reply autofill::mojom::AutofillDriver::FocusOnFormField";
      case internal::kAutofillDriver_DidFillAutofillFormData_Name:
            return "Receive reply autofill::mojom::AutofillDriver::DidFillAutofillFormData";
      case internal::kAutofillDriver_DidPreviewAutofillFormData_Name:
            return "Receive reply autofill::mojom::AutofillDriver::DidPreviewAutofillFormData";
      case internal::kAutofillDriver_DidEndTextFieldEditing_Name:
            return "Receive reply autofill::mojom::AutofillDriver::DidEndTextFieldEditing";
      case internal::kAutofillDriver_JavaScriptChangedAutofilledValue_Name:
            return "Receive reply autofill::mojom::AutofillDriver::JavaScriptChangedAutofilledValue";
    }
  }
  return "Receive unknown mojo message";
#else
  bool is_response = message.has_flag(mojo::Message::kFlagIsResponse);
  if (is_response) {
    return "Receive mojo reply";
  } else {
    return "Receive mojo message";
  }
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
}

#if !BUILDFLAG(IS_FUCHSIA)
uint32_t AutofillDriver::SetFormToBeProbablySubmitted_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)autofill::mojom::AutofillDriver::SetFormToBeProbablySubmitted");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t AutofillDriver::FormsSeen_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)autofill::mojom::AutofillDriver::FormsSeen");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t AutofillDriver::FormSubmitted_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)autofill::mojom::AutofillDriver::FormSubmitted");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t AutofillDriver::TextFieldDidChange_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)autofill::mojom::AutofillDriver::TextFieldDidChange");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t AutofillDriver::TextFieldDidScroll_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)autofill::mojom::AutofillDriver::TextFieldDidScroll");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t AutofillDriver::SelectControlDidChange_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)autofill::mojom::AutofillDriver::SelectControlDidChange");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t AutofillDriver::SelectFieldOptionsDidChange_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)autofill::mojom::AutofillDriver::SelectFieldOptionsDidChange");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t AutofillDriver::AskForValuesToFill_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)autofill::mojom::AutofillDriver::AskForValuesToFill");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t AutofillDriver::HidePopup_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)autofill::mojom::AutofillDriver::HidePopup");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t AutofillDriver::FocusNoLongerOnForm_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)autofill::mojom::AutofillDriver::FocusNoLongerOnForm");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t AutofillDriver::FocusOnFormField_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)autofill::mojom::AutofillDriver::FocusOnFormField");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t AutofillDriver::DidFillAutofillFormData_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)autofill::mojom::AutofillDriver::DidFillAutofillFormData");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t AutofillDriver::DidPreviewAutofillFormData_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)autofill::mojom::AutofillDriver::DidPreviewAutofillFormData");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t AutofillDriver::DidEndTextFieldEditing_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)autofill::mojom::AutofillDriver::DidEndTextFieldEditing");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t AutofillDriver::JavaScriptChangedAutofilledValue_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)autofill::mojom::AutofillDriver::JavaScriptChangedAutofilledValue");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
# endif // !BUILDFLAG(IS_FUCHSIA)

AutofillDriverProxy::AutofillDriverProxy(mojo::MessageReceiverWithResponder* receiver)
    : receiver_(receiver) {
}

void AutofillDriverProxy::SetFormToBeProbablySubmitted(
    const absl::optional<::autofill::FormData>& in_form) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send autofill::mojom::AutofillDriver::SetFormToBeProbablySubmitted", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("form"), in_form,
                        "<value of type const absl::optional<::autofill::FormData>&>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kAutofillDriver_SetFormToBeProbablySubmitted_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::autofill::mojom::internal::AutofillDriver_SetFormToBeProbablySubmitted_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->form)::BaseType> form_fragment(
          params.message());
  mojo::internal::Serialize<::autofill::mojom::FormDataDataView>(
      in_form, form_fragment);
  params->form.Set(
      form_fragment.is_null() ? nullptr : form_fragment.data());

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(AutofillDriver::Name_);
  message.set_method_name("SetFormToBeProbablySubmitted");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void AutofillDriverProxy::FormsSeen(
    const std::vector<::autofill::FormData>& in_updated_forms, const std::vector<::autofill::FormRendererId>& in_removed_forms) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send autofill::mojom::AutofillDriver::FormsSeen", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("updated_forms"), in_updated_forms,
                        "<value of type const std::vector<::autofill::FormData>&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("removed_forms"), in_removed_forms,
                        "<value of type const std::vector<::autofill::FormRendererId>&>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kAutofillDriver_FormsSeen_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::autofill::mojom::internal::AutofillDriver_FormsSeen_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->updated_forms)::BaseType>
      updated_forms_fragment(params.message());
  const mojo::internal::ContainerValidateParams updated_forms_validate_params(
      0, false, nullptr);
  mojo::internal::Serialize<mojo::ArrayDataView<::autofill::mojom::FormDataDataView>>(
      in_updated_forms, updated_forms_fragment, &updated_forms_validate_params);
  params->updated_forms.Set(
      updated_forms_fragment.is_null() ? nullptr : updated_forms_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->updated_forms.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null updated_forms in AutofillDriver.FormsSeen request");
  mojo::internal::MessageFragment<
      typename decltype(params->removed_forms)::BaseType>
      removed_forms_fragment(params.message());
  const mojo::internal::ContainerValidateParams removed_forms_validate_params(
      0, false, nullptr);
  mojo::internal::Serialize<mojo::ArrayDataView<::autofill::mojom::FormRendererIdDataView>>(
      in_removed_forms, removed_forms_fragment, &removed_forms_validate_params);
  params->removed_forms.Set(
      removed_forms_fragment.is_null() ? nullptr : removed_forms_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->removed_forms.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null removed_forms in AutofillDriver.FormsSeen request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(AutofillDriver::Name_);
  message.set_method_name("FormsSeen");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void AutofillDriverProxy::FormSubmitted(
    const ::autofill::FormData& in_form, bool in_known_success, ::autofill::mojom::SubmissionSource in_source) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send autofill::mojom::AutofillDriver::FormSubmitted", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("form"), in_form,
                        "<value of type const ::autofill::FormData&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("known_success"), in_known_success,
                        "<value of type bool>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("source"), in_source,
                        "<value of type ::autofill::mojom::SubmissionSource>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kAutofillDriver_FormSubmitted_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::autofill::mojom::internal::AutofillDriver_FormSubmitted_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->form)::BaseType> form_fragment(
          params.message());
  mojo::internal::Serialize<::autofill::mojom::FormDataDataView>(
      in_form, form_fragment);
  params->form.Set(
      form_fragment.is_null() ? nullptr : form_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->form.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null form in AutofillDriver.FormSubmitted request");
  params->known_success = in_known_success;
  mojo::internal::Serialize<::autofill::mojom::SubmissionSource>(
      in_source, &params->source);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(AutofillDriver::Name_);
  message.set_method_name("FormSubmitted");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void AutofillDriverProxy::TextFieldDidChange(
    const ::autofill::FormData& in_form, const ::autofill::FormFieldData& in_field, const ::gfx::RectF& in_bounding_box, ::base::TimeTicks in_timestamp) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send autofill::mojom::AutofillDriver::TextFieldDidChange", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("form"), in_form,
                        "<value of type const ::autofill::FormData&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("field"), in_field,
                        "<value of type const ::autofill::FormFieldData&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("bounding_box"), in_bounding_box,
                        "<value of type const ::gfx::RectF&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("timestamp"), in_timestamp,
                        "<value of type ::base::TimeTicks>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kAutofillDriver_TextFieldDidChange_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::autofill::mojom::internal::AutofillDriver_TextFieldDidChange_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->form)::BaseType> form_fragment(
          params.message());
  mojo::internal::Serialize<::autofill::mojom::FormDataDataView>(
      in_form, form_fragment);
  params->form.Set(
      form_fragment.is_null() ? nullptr : form_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->form.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null form in AutofillDriver.TextFieldDidChange request");
  mojo::internal::MessageFragment<
      typename decltype(params->field)::BaseType> field_fragment(
          params.message());
  mojo::internal::Serialize<::autofill::mojom::FormFieldDataDataView>(
      in_field, field_fragment);
  params->field.Set(
      field_fragment.is_null() ? nullptr : field_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->field.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null field in AutofillDriver.TextFieldDidChange request");
  mojo::internal::MessageFragment<
      typename decltype(params->bounding_box)::BaseType> bounding_box_fragment(
          params.message());
  mojo::internal::Serialize<::gfx::mojom::RectFDataView>(
      in_bounding_box, bounding_box_fragment);
  params->bounding_box.Set(
      bounding_box_fragment.is_null() ? nullptr : bounding_box_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->bounding_box.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null bounding_box in AutofillDriver.TextFieldDidChange request");
  mojo::internal::MessageFragment<
      typename decltype(params->timestamp)::BaseType> timestamp_fragment(
          params.message());
  mojo::internal::Serialize<::mojo_base::mojom::TimeTicksDataView>(
      in_timestamp, timestamp_fragment);
  params->timestamp.Set(
      timestamp_fragment.is_null() ? nullptr : timestamp_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->timestamp.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null timestamp in AutofillDriver.TextFieldDidChange request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(AutofillDriver::Name_);
  message.set_method_name("TextFieldDidChange");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void AutofillDriverProxy::TextFieldDidScroll(
    const ::autofill::FormData& in_form, const ::autofill::FormFieldData& in_field, const ::gfx::RectF& in_bounding_box) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send autofill::mojom::AutofillDriver::TextFieldDidScroll", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("form"), in_form,
                        "<value of type const ::autofill::FormData&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("field"), in_field,
                        "<value of type const ::autofill::FormFieldData&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("bounding_box"), in_bounding_box,
                        "<value of type const ::gfx::RectF&>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kAutofillDriver_TextFieldDidScroll_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::autofill::mojom::internal::AutofillDriver_TextFieldDidScroll_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->form)::BaseType> form_fragment(
          params.message());
  mojo::internal::Serialize<::autofill::mojom::FormDataDataView>(
      in_form, form_fragment);
  params->form.Set(
      form_fragment.is_null() ? nullptr : form_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->form.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null form in AutofillDriver.TextFieldDidScroll request");
  mojo::internal::MessageFragment<
      typename decltype(params->field)::BaseType> field_fragment(
          params.message());
  mojo::internal::Serialize<::autofill::mojom::FormFieldDataDataView>(
      in_field, field_fragment);
  params->field.Set(
      field_fragment.is_null() ? nullptr : field_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->field.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null field in AutofillDriver.TextFieldDidScroll request");
  mojo::internal::MessageFragment<
      typename decltype(params->bounding_box)::BaseType> bounding_box_fragment(
          params.message());
  mojo::internal::Serialize<::gfx::mojom::RectFDataView>(
      in_bounding_box, bounding_box_fragment);
  params->bounding_box.Set(
      bounding_box_fragment.is_null() ? nullptr : bounding_box_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->bounding_box.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null bounding_box in AutofillDriver.TextFieldDidScroll request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(AutofillDriver::Name_);
  message.set_method_name("TextFieldDidScroll");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void AutofillDriverProxy::SelectControlDidChange(
    const ::autofill::FormData& in_form, const ::autofill::FormFieldData& in_field, const ::gfx::RectF& in_bounding_box) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send autofill::mojom::AutofillDriver::SelectControlDidChange", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("form"), in_form,
                        "<value of type const ::autofill::FormData&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("field"), in_field,
                        "<value of type const ::autofill::FormFieldData&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("bounding_box"), in_bounding_box,
                        "<value of type const ::gfx::RectF&>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kAutofillDriver_SelectControlDidChange_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::autofill::mojom::internal::AutofillDriver_SelectControlDidChange_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->form)::BaseType> form_fragment(
          params.message());
  mojo::internal::Serialize<::autofill::mojom::FormDataDataView>(
      in_form, form_fragment);
  params->form.Set(
      form_fragment.is_null() ? nullptr : form_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->form.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null form in AutofillDriver.SelectControlDidChange request");
  mojo::internal::MessageFragment<
      typename decltype(params->field)::BaseType> field_fragment(
          params.message());
  mojo::internal::Serialize<::autofill::mojom::FormFieldDataDataView>(
      in_field, field_fragment);
  params->field.Set(
      field_fragment.is_null() ? nullptr : field_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->field.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null field in AutofillDriver.SelectControlDidChange request");
  mojo::internal::MessageFragment<
      typename decltype(params->bounding_box)::BaseType> bounding_box_fragment(
          params.message());
  mojo::internal::Serialize<::gfx::mojom::RectFDataView>(
      in_bounding_box, bounding_box_fragment);
  params->bounding_box.Set(
      bounding_box_fragment.is_null() ? nullptr : bounding_box_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->bounding_box.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null bounding_box in AutofillDriver.SelectControlDidChange request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(AutofillDriver::Name_);
  message.set_method_name("SelectControlDidChange");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void AutofillDriverProxy::SelectFieldOptionsDidChange(
    const ::autofill::FormData& in_form) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send autofill::mojom::AutofillDriver::SelectFieldOptionsDidChange", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("form"), in_form,
                        "<value of type const ::autofill::FormData&>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kAutofillDriver_SelectFieldOptionsDidChange_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::autofill::mojom::internal::AutofillDriver_SelectFieldOptionsDidChange_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->form)::BaseType> form_fragment(
          params.message());
  mojo::internal::Serialize<::autofill::mojom::FormDataDataView>(
      in_form, form_fragment);
  params->form.Set(
      form_fragment.is_null() ? nullptr : form_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->form.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null form in AutofillDriver.SelectFieldOptionsDidChange request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(AutofillDriver::Name_);
  message.set_method_name("SelectFieldOptionsDidChange");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void AutofillDriverProxy::AskForValuesToFill(
    const ::autofill::FormData& in_form, const ::autofill::FormFieldData& in_field, const ::gfx::RectF& in_bounding_box, int32_t in_query_id, bool in_autoselect_first_suggestion, ::autofill::TouchToFillEligible in_touch_to_fill_eligible) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send autofill::mojom::AutofillDriver::AskForValuesToFill", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("form"), in_form,
                        "<value of type const ::autofill::FormData&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("field"), in_field,
                        "<value of type const ::autofill::FormFieldData&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("bounding_box"), in_bounding_box,
                        "<value of type const ::gfx::RectF&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("query_id"), in_query_id,
                        "<value of type int32_t>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("autoselect_first_suggestion"), in_autoselect_first_suggestion,
                        "<value of type bool>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("touch_to_fill_eligible"), in_touch_to_fill_eligible,
                        "<value of type ::autofill::TouchToFillEligible>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kAutofillDriver_AskForValuesToFill_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::autofill::mojom::internal::AutofillDriver_AskForValuesToFill_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->form)::BaseType> form_fragment(
          params.message());
  mojo::internal::Serialize<::autofill::mojom::FormDataDataView>(
      in_form, form_fragment);
  params->form.Set(
      form_fragment.is_null() ? nullptr : form_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->form.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null form in AutofillDriver.AskForValuesToFill request");
  mojo::internal::MessageFragment<
      typename decltype(params->field)::BaseType> field_fragment(
          params.message());
  mojo::internal::Serialize<::autofill::mojom::FormFieldDataDataView>(
      in_field, field_fragment);
  params->field.Set(
      field_fragment.is_null() ? nullptr : field_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->field.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null field in AutofillDriver.AskForValuesToFill request");
  mojo::internal::MessageFragment<
      typename decltype(params->bounding_box)::BaseType> bounding_box_fragment(
          params.message());
  mojo::internal::Serialize<::gfx::mojom::RectFDataView>(
      in_bounding_box, bounding_box_fragment);
  params->bounding_box.Set(
      bounding_box_fragment.is_null() ? nullptr : bounding_box_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->bounding_box.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null bounding_box in AutofillDriver.AskForValuesToFill request");
  params->query_id = in_query_id;
  params->autoselect_first_suggestion = in_autoselect_first_suggestion;
  mojo::internal::MessageFragment<
      typename decltype(params->touch_to_fill_eligible)::BaseType> touch_to_fill_eligible_fragment(
          params.message());
  mojo::internal::Serialize<::autofill::mojom::TouchToFillEligibleDataView>(
      in_touch_to_fill_eligible, touch_to_fill_eligible_fragment);
  params->touch_to_fill_eligible.Set(
      touch_to_fill_eligible_fragment.is_null() ? nullptr : touch_to_fill_eligible_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->touch_to_fill_eligible.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null touch_to_fill_eligible in AutofillDriver.AskForValuesToFill request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(AutofillDriver::Name_);
  message.set_method_name("AskForValuesToFill");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void AutofillDriverProxy::HidePopup(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send autofill::mojom::AutofillDriver::HidePopup");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kAutofillDriver_HidePopup_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::autofill::mojom::internal::AutofillDriver_HidePopup_Params_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(AutofillDriver::Name_);
  message.set_method_name("HidePopup");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void AutofillDriverProxy::FocusNoLongerOnForm(
    bool in_had_interacted_form) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send autofill::mojom::AutofillDriver::FocusNoLongerOnForm", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("had_interacted_form"), in_had_interacted_form,
                        "<value of type bool>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kAutofillDriver_FocusNoLongerOnForm_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::autofill::mojom::internal::AutofillDriver_FocusNoLongerOnForm_Params_Data> params(
          message);
  params.Allocate();
  params->had_interacted_form = in_had_interacted_form;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(AutofillDriver::Name_);
  message.set_method_name("FocusNoLongerOnForm");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void AutofillDriverProxy::FocusOnFormField(
    const ::autofill::FormData& in_form, const ::autofill::FormFieldData& in_field, const ::gfx::RectF& in_bounding_box) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send autofill::mojom::AutofillDriver::FocusOnFormField", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("form"), in_form,
                        "<value of type const ::autofill::FormData&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("field"), in_field,
                        "<value of type const ::autofill::FormFieldData&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("bounding_box"), in_bounding_box,
                        "<value of type const ::gfx::RectF&>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kAutofillDriver_FocusOnFormField_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::autofill::mojom::internal::AutofillDriver_FocusOnFormField_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->form)::BaseType> form_fragment(
          params.message());
  mojo::internal::Serialize<::autofill::mojom::FormDataDataView>(
      in_form, form_fragment);
  params->form.Set(
      form_fragment.is_null() ? nullptr : form_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->form.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null form in AutofillDriver.FocusOnFormField request");
  mojo::internal::MessageFragment<
      typename decltype(params->field)::BaseType> field_fragment(
          params.message());
  mojo::internal::Serialize<::autofill::mojom::FormFieldDataDataView>(
      in_field, field_fragment);
  params->field.Set(
      field_fragment.is_null() ? nullptr : field_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->field.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null field in AutofillDriver.FocusOnFormField request");
  mojo::internal::MessageFragment<
      typename decltype(params->bounding_box)::BaseType> bounding_box_fragment(
          params.message());
  mojo::internal::Serialize<::gfx::mojom::RectFDataView>(
      in_bounding_box, bounding_box_fragment);
  params->bounding_box.Set(
      bounding_box_fragment.is_null() ? nullptr : bounding_box_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->bounding_box.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null bounding_box in AutofillDriver.FocusOnFormField request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(AutofillDriver::Name_);
  message.set_method_name("FocusOnFormField");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void AutofillDriverProxy::DidFillAutofillFormData(
    const ::autofill::FormData& in_form, ::base::TimeTicks in_timestamp) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send autofill::mojom::AutofillDriver::DidFillAutofillFormData", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("form"), in_form,
                        "<value of type const ::autofill::FormData&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("timestamp"), in_timestamp,
                        "<value of type ::base::TimeTicks>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kAutofillDriver_DidFillAutofillFormData_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::autofill::mojom::internal::AutofillDriver_DidFillAutofillFormData_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->form)::BaseType> form_fragment(
          params.message());
  mojo::internal::Serialize<::autofill::mojom::FormDataDataView>(
      in_form, form_fragment);
  params->form.Set(
      form_fragment.is_null() ? nullptr : form_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->form.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null form in AutofillDriver.DidFillAutofillFormData request");
  mojo::internal::MessageFragment<
      typename decltype(params->timestamp)::BaseType> timestamp_fragment(
          params.message());
  mojo::internal::Serialize<::mojo_base::mojom::TimeTicksDataView>(
      in_timestamp, timestamp_fragment);
  params->timestamp.Set(
      timestamp_fragment.is_null() ? nullptr : timestamp_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->timestamp.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null timestamp in AutofillDriver.DidFillAutofillFormData request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(AutofillDriver::Name_);
  message.set_method_name("DidFillAutofillFormData");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void AutofillDriverProxy::DidPreviewAutofillFormData(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send autofill::mojom::AutofillDriver::DidPreviewAutofillFormData");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kAutofillDriver_DidPreviewAutofillFormData_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::autofill::mojom::internal::AutofillDriver_DidPreviewAutofillFormData_Params_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(AutofillDriver::Name_);
  message.set_method_name("DidPreviewAutofillFormData");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void AutofillDriverProxy::DidEndTextFieldEditing(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send autofill::mojom::AutofillDriver::DidEndTextFieldEditing");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kAutofillDriver_DidEndTextFieldEditing_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::autofill::mojom::internal::AutofillDriver_DidEndTextFieldEditing_Params_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(AutofillDriver::Name_);
  message.set_method_name("DidEndTextFieldEditing");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void AutofillDriverProxy::JavaScriptChangedAutofilledValue(
    const ::autofill::FormData& in_form, const ::autofill::FormFieldData& in_field, const ::std::u16string& in_old_value) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send autofill::mojom::AutofillDriver::JavaScriptChangedAutofilledValue", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("form"), in_form,
                        "<value of type const ::autofill::FormData&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("field"), in_field,
                        "<value of type const ::autofill::FormFieldData&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("old_value"), in_old_value,
                        "<value of type const ::std::u16string&>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kAutofillDriver_JavaScriptChangedAutofilledValue_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::autofill::mojom::internal::AutofillDriver_JavaScriptChangedAutofilledValue_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->form)::BaseType> form_fragment(
          params.message());
  mojo::internal::Serialize<::autofill::mojom::FormDataDataView>(
      in_form, form_fragment);
  params->form.Set(
      form_fragment.is_null() ? nullptr : form_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->form.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null form in AutofillDriver.JavaScriptChangedAutofilledValue request");
  mojo::internal::MessageFragment<
      typename decltype(params->field)::BaseType> field_fragment(
          params.message());
  mojo::internal::Serialize<::autofill::mojom::FormFieldDataDataView>(
      in_field, field_fragment);
  params->field.Set(
      field_fragment.is_null() ? nullptr : field_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->field.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null field in AutofillDriver.JavaScriptChangedAutofilledValue request");
  mojo::internal::MessageFragment<
      typename decltype(params->old_value)::BaseType> old_value_fragment(
          params.message());
  mojo::internal::Serialize<::mojo_base::mojom::String16DataView>(
      in_old_value, old_value_fragment);
  params->old_value.Set(
      old_value_fragment.is_null() ? nullptr : old_value_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->old_value.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null old_value in AutofillDriver.JavaScriptChangedAutofilledValue request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(AutofillDriver::Name_);
  message.set_method_name("JavaScriptChangedAutofilledValue");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

// static
bool AutofillDriverStubDispatch::Accept(
    AutofillDriver* impl,
    mojo::Message* message) {
  switch (message->header()->name) {
    case internal::kAutofillDriver_SetFormToBeProbablySubmitted_Name: {

      DCHECK(message->is_serialized());
      internal::AutofillDriver_SetFormToBeProbablySubmitted_Params_Data* params =
          reinterpret_cast<internal::AutofillDriver_SetFormToBeProbablySubmitted_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      absl::optional<::autofill::FormData> p_form{};
      AutofillDriver_SetFormToBeProbablySubmitted_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadForm(&p_form))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            AutofillDriver::Name_, 0, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SetFormToBeProbablySubmitted(
std::move(p_form));
      return true;
    }
    case internal::kAutofillDriver_FormsSeen_Name: {

      DCHECK(message->is_serialized());
      internal::AutofillDriver_FormsSeen_Params_Data* params =
          reinterpret_cast<internal::AutofillDriver_FormsSeen_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      std::vector<::autofill::FormData> p_updated_forms{};
      std::vector<::autofill::FormRendererId> p_removed_forms{};
      AutofillDriver_FormsSeen_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadUpdatedForms(&p_updated_forms))
        success = false;
      if (success && !input_data_view.ReadRemovedForms(&p_removed_forms))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            AutofillDriver::Name_, 1, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->FormsSeen(
std::move(p_updated_forms), 
std::move(p_removed_forms));
      return true;
    }
    case internal::kAutofillDriver_FormSubmitted_Name: {

      DCHECK(message->is_serialized());
      internal::AutofillDriver_FormSubmitted_Params_Data* params =
          reinterpret_cast<internal::AutofillDriver_FormSubmitted_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::autofill::FormData p_form{};
      bool p_known_success{};
      ::autofill::mojom::SubmissionSource p_source{};
      AutofillDriver_FormSubmitted_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadForm(&p_form))
        success = false;
      if (success)
        p_known_success = input_data_view.known_success();
      if (success && !input_data_view.ReadSource(&p_source))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            AutofillDriver::Name_, 2, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->FormSubmitted(
std::move(p_form), 
std::move(p_known_success), 
std::move(p_source));
      return true;
    }
    case internal::kAutofillDriver_TextFieldDidChange_Name: {

      DCHECK(message->is_serialized());
      internal::AutofillDriver_TextFieldDidChange_Params_Data* params =
          reinterpret_cast<internal::AutofillDriver_TextFieldDidChange_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::autofill::FormData p_form{};
      ::autofill::FormFieldData p_field{};
      ::gfx::RectF p_bounding_box{};
      ::base::TimeTicks p_timestamp{};
      AutofillDriver_TextFieldDidChange_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadForm(&p_form))
        success = false;
      if (success && !input_data_view.ReadField(&p_field))
        success = false;
      if (success && !input_data_view.ReadBoundingBox(&p_bounding_box))
        success = false;
      if (success && !input_data_view.ReadTimestamp(&p_timestamp))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            AutofillDriver::Name_, 3, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->TextFieldDidChange(
std::move(p_form), 
std::move(p_field), 
std::move(p_bounding_box), 
std::move(p_timestamp));
      return true;
    }
    case internal::kAutofillDriver_TextFieldDidScroll_Name: {

      DCHECK(message->is_serialized());
      internal::AutofillDriver_TextFieldDidScroll_Params_Data* params =
          reinterpret_cast<internal::AutofillDriver_TextFieldDidScroll_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::autofill::FormData p_form{};
      ::autofill::FormFieldData p_field{};
      ::gfx::RectF p_bounding_box{};
      AutofillDriver_TextFieldDidScroll_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadForm(&p_form))
        success = false;
      if (success && !input_data_view.ReadField(&p_field))
        success = false;
      if (success && !input_data_view.ReadBoundingBox(&p_bounding_box))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            AutofillDriver::Name_, 4, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->TextFieldDidScroll(
std::move(p_form), 
std::move(p_field), 
std::move(p_bounding_box));
      return true;
    }
    case internal::kAutofillDriver_SelectControlDidChange_Name: {

      DCHECK(message->is_serialized());
      internal::AutofillDriver_SelectControlDidChange_Params_Data* params =
          reinterpret_cast<internal::AutofillDriver_SelectControlDidChange_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::autofill::FormData p_form{};
      ::autofill::FormFieldData p_field{};
      ::gfx::RectF p_bounding_box{};
      AutofillDriver_SelectControlDidChange_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadForm(&p_form))
        success = false;
      if (success && !input_data_view.ReadField(&p_field))
        success = false;
      if (success && !input_data_view.ReadBoundingBox(&p_bounding_box))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            AutofillDriver::Name_, 5, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SelectControlDidChange(
std::move(p_form), 
std::move(p_field), 
std::move(p_bounding_box));
      return true;
    }
    case internal::kAutofillDriver_SelectFieldOptionsDidChange_Name: {

      DCHECK(message->is_serialized());
      internal::AutofillDriver_SelectFieldOptionsDidChange_Params_Data* params =
          reinterpret_cast<internal::AutofillDriver_SelectFieldOptionsDidChange_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::autofill::FormData p_form{};
      AutofillDriver_SelectFieldOptionsDidChange_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadForm(&p_form))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            AutofillDriver::Name_, 6, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SelectFieldOptionsDidChange(
std::move(p_form));
      return true;
    }
    case internal::kAutofillDriver_AskForValuesToFill_Name: {

      DCHECK(message->is_serialized());
      internal::AutofillDriver_AskForValuesToFill_Params_Data* params =
          reinterpret_cast<internal::AutofillDriver_AskForValuesToFill_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::autofill::FormData p_form{};
      ::autofill::FormFieldData p_field{};
      ::gfx::RectF p_bounding_box{};
      int32_t p_query_id{};
      bool p_autoselect_first_suggestion{};
      ::autofill::TouchToFillEligible p_touch_to_fill_eligible{};
      AutofillDriver_AskForValuesToFill_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadForm(&p_form))
        success = false;
      if (success && !input_data_view.ReadField(&p_field))
        success = false;
      if (success && !input_data_view.ReadBoundingBox(&p_bounding_box))
        success = false;
      if (success)
        p_query_id = input_data_view.query_id();
      if (success)
        p_autoselect_first_suggestion = input_data_view.autoselect_first_suggestion();
      if (success && !input_data_view.ReadTouchToFillEligible(&p_touch_to_fill_eligible))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            AutofillDriver::Name_, 7, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->AskForValuesToFill(
std::move(p_form), 
std::move(p_field), 
std::move(p_bounding_box), 
std::move(p_query_id), 
std::move(p_autoselect_first_suggestion), 
std::move(p_touch_to_fill_eligible));
      return true;
    }
    case internal::kAutofillDriver_HidePopup_Name: {

      DCHECK(message->is_serialized());
      internal::AutofillDriver_HidePopup_Params_Data* params =
          reinterpret_cast<internal::AutofillDriver_HidePopup_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      AutofillDriver_HidePopup_ParamsDataView input_data_view(params, message);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            AutofillDriver::Name_, 8, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->HidePopup();
      return true;
    }
    case internal::kAutofillDriver_FocusNoLongerOnForm_Name: {

      DCHECK(message->is_serialized());
      internal::AutofillDriver_FocusNoLongerOnForm_Params_Data* params =
          reinterpret_cast<internal::AutofillDriver_FocusNoLongerOnForm_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      bool p_had_interacted_form{};
      AutofillDriver_FocusNoLongerOnForm_ParamsDataView input_data_view(params, message);
      
      if (success)
        p_had_interacted_form = input_data_view.had_interacted_form();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            AutofillDriver::Name_, 9, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->FocusNoLongerOnForm(
std::move(p_had_interacted_form));
      return true;
    }
    case internal::kAutofillDriver_FocusOnFormField_Name: {

      DCHECK(message->is_serialized());
      internal::AutofillDriver_FocusOnFormField_Params_Data* params =
          reinterpret_cast<internal::AutofillDriver_FocusOnFormField_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::autofill::FormData p_form{};
      ::autofill::FormFieldData p_field{};
      ::gfx::RectF p_bounding_box{};
      AutofillDriver_FocusOnFormField_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadForm(&p_form))
        success = false;
      if (success && !input_data_view.ReadField(&p_field))
        success = false;
      if (success && !input_data_view.ReadBoundingBox(&p_bounding_box))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            AutofillDriver::Name_, 10, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->FocusOnFormField(
std::move(p_form), 
std::move(p_field), 
std::move(p_bounding_box));
      return true;
    }
    case internal::kAutofillDriver_DidFillAutofillFormData_Name: {

      DCHECK(message->is_serialized());
      internal::AutofillDriver_DidFillAutofillFormData_Params_Data* params =
          reinterpret_cast<internal::AutofillDriver_DidFillAutofillFormData_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::autofill::FormData p_form{};
      ::base::TimeTicks p_timestamp{};
      AutofillDriver_DidFillAutofillFormData_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadForm(&p_form))
        success = false;
      if (success && !input_data_view.ReadTimestamp(&p_timestamp))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            AutofillDriver::Name_, 11, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->DidFillAutofillFormData(
std::move(p_form), 
std::move(p_timestamp));
      return true;
    }
    case internal::kAutofillDriver_DidPreviewAutofillFormData_Name: {

      DCHECK(message->is_serialized());
      internal::AutofillDriver_DidPreviewAutofillFormData_Params_Data* params =
          reinterpret_cast<internal::AutofillDriver_DidPreviewAutofillFormData_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      AutofillDriver_DidPreviewAutofillFormData_ParamsDataView input_data_view(params, message);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            AutofillDriver::Name_, 12, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->DidPreviewAutofillFormData();
      return true;
    }
    case internal::kAutofillDriver_DidEndTextFieldEditing_Name: {

      DCHECK(message->is_serialized());
      internal::AutofillDriver_DidEndTextFieldEditing_Params_Data* params =
          reinterpret_cast<internal::AutofillDriver_DidEndTextFieldEditing_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      AutofillDriver_DidEndTextFieldEditing_ParamsDataView input_data_view(params, message);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            AutofillDriver::Name_, 13, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->DidEndTextFieldEditing();
      return true;
    }
    case internal::kAutofillDriver_JavaScriptChangedAutofilledValue_Name: {

      DCHECK(message->is_serialized());
      internal::AutofillDriver_JavaScriptChangedAutofilledValue_Params_Data* params =
          reinterpret_cast<internal::AutofillDriver_JavaScriptChangedAutofilledValue_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::autofill::FormData p_form{};
      ::autofill::FormFieldData p_field{};
      ::std::u16string p_old_value{};
      AutofillDriver_JavaScriptChangedAutofilledValue_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadForm(&p_form))
        success = false;
      if (success && !input_data_view.ReadField(&p_field))
        success = false;
      if (success && !input_data_view.ReadOldValue(&p_old_value))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            AutofillDriver::Name_, 14, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->JavaScriptChangedAutofilledValue(
std::move(p_form), 
std::move(p_field), 
std::move(p_old_value));
      return true;
    }
  }
  return false;
}

// static
bool AutofillDriverStubDispatch::AcceptWithResponder(
    AutofillDriver* impl,
    mojo::Message* message,
    std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
  [[maybe_unused]] const bool message_is_sync =
      message->has_flag(mojo::Message::kFlagIsSync);
  [[maybe_unused]] const uint64_t request_id = message->request_id();
  switch (message->header()->name) {
    case internal::kAutofillDriver_SetFormToBeProbablySubmitted_Name: {
      break;
    }
    case internal::kAutofillDriver_FormsSeen_Name: {
      break;
    }
    case internal::kAutofillDriver_FormSubmitted_Name: {
      break;
    }
    case internal::kAutofillDriver_TextFieldDidChange_Name: {
      break;
    }
    case internal::kAutofillDriver_TextFieldDidScroll_Name: {
      break;
    }
    case internal::kAutofillDriver_SelectControlDidChange_Name: {
      break;
    }
    case internal::kAutofillDriver_SelectFieldOptionsDidChange_Name: {
      break;
    }
    case internal::kAutofillDriver_AskForValuesToFill_Name: {
      break;
    }
    case internal::kAutofillDriver_HidePopup_Name: {
      break;
    }
    case internal::kAutofillDriver_FocusNoLongerOnForm_Name: {
      break;
    }
    case internal::kAutofillDriver_FocusOnFormField_Name: {
      break;
    }
    case internal::kAutofillDriver_DidFillAutofillFormData_Name: {
      break;
    }
    case internal::kAutofillDriver_DidPreviewAutofillFormData_Name: {
      break;
    }
    case internal::kAutofillDriver_DidEndTextFieldEditing_Name: {
      break;
    }
    case internal::kAutofillDriver_JavaScriptChangedAutofilledValue_Name: {
      break;
    }
  }
  return false;
}


static const mojo::internal::GenericValidationInfo kAutofillDriverValidationInfo[] = {
    {&internal::AutofillDriver_SetFormToBeProbablySubmitted_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::AutofillDriver_FormsSeen_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::AutofillDriver_FormSubmitted_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::AutofillDriver_TextFieldDidChange_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::AutofillDriver_TextFieldDidScroll_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::AutofillDriver_SelectControlDidChange_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::AutofillDriver_SelectFieldOptionsDidChange_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::AutofillDriver_AskForValuesToFill_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::AutofillDriver_HidePopup_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::AutofillDriver_FocusNoLongerOnForm_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::AutofillDriver_FocusOnFormField_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::AutofillDriver_DidFillAutofillFormData_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::AutofillDriver_DidPreviewAutofillFormData_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::AutofillDriver_DidEndTextFieldEditing_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::AutofillDriver_JavaScriptChangedAutofilledValue_Params_Data::Validate,
     nullptr /* no response */},
};

bool AutofillDriverRequestValidator::Accept(mojo::Message* message) {
  const char* name = ::autofill::mojom::AutofillDriver::Name_;
  return mojo::internal::ValidateRequestGenericPacked(message, name, kAutofillDriverValidationInfo);
}

const char PasswordManagerDriver::Name_[] = "autofill.mojom.PasswordManagerDriver";

PasswordManagerDriver::IPCStableHashFunction PasswordManagerDriver::MessageToMethodInfo_(mojo::Message& message) {
#if !BUILDFLAG(IS_FUCHSIA)
  switch (message.name()) {
    case internal::kPasswordManagerDriver_PasswordFormsParsed_Name: {
      return &PasswordManagerDriver::PasswordFormsParsed_Sym::IPCStableHash;
    }
    case internal::kPasswordManagerDriver_PasswordFormsRendered_Name: {
      return &PasswordManagerDriver::PasswordFormsRendered_Sym::IPCStableHash;
    }
    case internal::kPasswordManagerDriver_PasswordFormSubmitted_Name: {
      return &PasswordManagerDriver::PasswordFormSubmitted_Sym::IPCStableHash;
    }
    case internal::kPasswordManagerDriver_InformAboutUserInput_Name: {
      return &PasswordManagerDriver::InformAboutUserInput_Sym::IPCStableHash;
    }
    case internal::kPasswordManagerDriver_DynamicFormSubmission_Name: {
      return &PasswordManagerDriver::DynamicFormSubmission_Sym::IPCStableHash;
    }
    case internal::kPasswordManagerDriver_PasswordFormCleared_Name: {
      return &PasswordManagerDriver::PasswordFormCleared_Sym::IPCStableHash;
    }
    case internal::kPasswordManagerDriver_RecordSavePasswordProgress_Name: {
      return &PasswordManagerDriver::RecordSavePasswordProgress_Sym::IPCStableHash;
    }
    case internal::kPasswordManagerDriver_UserModifiedPasswordField_Name: {
      return &PasswordManagerDriver::UserModifiedPasswordField_Sym::IPCStableHash;
    }
    case internal::kPasswordManagerDriver_UserModifiedNonPasswordField_Name: {
      return &PasswordManagerDriver::UserModifiedNonPasswordField_Sym::IPCStableHash;
    }
    case internal::kPasswordManagerDriver_ShowPasswordSuggestions_Name: {
      return &PasswordManagerDriver::ShowPasswordSuggestions_Sym::IPCStableHash;
    }
    case internal::kPasswordManagerDriver_ShowTouchToFill_Name: {
      return &PasswordManagerDriver::ShowTouchToFill_Sym::IPCStableHash;
    }
    case internal::kPasswordManagerDriver_CheckSafeBrowsingReputation_Name: {
      return &PasswordManagerDriver::CheckSafeBrowsingReputation_Sym::IPCStableHash;
    }
    case internal::kPasswordManagerDriver_FocusedInputChanged_Name: {
      return &PasswordManagerDriver::FocusedInputChanged_Sym::IPCStableHash;
    }
    case internal::kPasswordManagerDriver_LogFirstFillingResult_Name: {
      return &PasswordManagerDriver::LogFirstFillingResult_Sym::IPCStableHash;
    }
  }
#endif  // !BUILDFLAG(IS_FUCHSIA)
  return nullptr;
}


const char* PasswordManagerDriver::MessageToMethodName_(mojo::Message& message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  bool is_response = message.has_flag(mojo::Message::kFlagIsResponse);
  if (!is_response) {
    switch (message.name()) {
      case internal::kPasswordManagerDriver_PasswordFormsParsed_Name:
            return "Receive autofill::mojom::PasswordManagerDriver::PasswordFormsParsed";
      case internal::kPasswordManagerDriver_PasswordFormsRendered_Name:
            return "Receive autofill::mojom::PasswordManagerDriver::PasswordFormsRendered";
      case internal::kPasswordManagerDriver_PasswordFormSubmitted_Name:
            return "Receive autofill::mojom::PasswordManagerDriver::PasswordFormSubmitted";
      case internal::kPasswordManagerDriver_InformAboutUserInput_Name:
            return "Receive autofill::mojom::PasswordManagerDriver::InformAboutUserInput";
      case internal::kPasswordManagerDriver_DynamicFormSubmission_Name:
            return "Receive autofill::mojom::PasswordManagerDriver::DynamicFormSubmission";
      case internal::kPasswordManagerDriver_PasswordFormCleared_Name:
            return "Receive autofill::mojom::PasswordManagerDriver::PasswordFormCleared";
      case internal::kPasswordManagerDriver_RecordSavePasswordProgress_Name:
            return "Receive autofill::mojom::PasswordManagerDriver::RecordSavePasswordProgress";
      case internal::kPasswordManagerDriver_UserModifiedPasswordField_Name:
            return "Receive autofill::mojom::PasswordManagerDriver::UserModifiedPasswordField";
      case internal::kPasswordManagerDriver_UserModifiedNonPasswordField_Name:
            return "Receive autofill::mojom::PasswordManagerDriver::UserModifiedNonPasswordField";
      case internal::kPasswordManagerDriver_ShowPasswordSuggestions_Name:
            return "Receive autofill::mojom::PasswordManagerDriver::ShowPasswordSuggestions";
      case internal::kPasswordManagerDriver_ShowTouchToFill_Name:
            return "Receive autofill::mojom::PasswordManagerDriver::ShowTouchToFill";
      case internal::kPasswordManagerDriver_CheckSafeBrowsingReputation_Name:
            return "Receive autofill::mojom::PasswordManagerDriver::CheckSafeBrowsingReputation";
      case internal::kPasswordManagerDriver_FocusedInputChanged_Name:
            return "Receive autofill::mojom::PasswordManagerDriver::FocusedInputChanged";
      case internal::kPasswordManagerDriver_LogFirstFillingResult_Name:
            return "Receive autofill::mojom::PasswordManagerDriver::LogFirstFillingResult";
    }
  } else {
    switch (message.name()) {
      case internal::kPasswordManagerDriver_PasswordFormsParsed_Name:
            return "Receive reply autofill::mojom::PasswordManagerDriver::PasswordFormsParsed";
      case internal::kPasswordManagerDriver_PasswordFormsRendered_Name:
            return "Receive reply autofill::mojom::PasswordManagerDriver::PasswordFormsRendered";
      case internal::kPasswordManagerDriver_PasswordFormSubmitted_Name:
            return "Receive reply autofill::mojom::PasswordManagerDriver::PasswordFormSubmitted";
      case internal::kPasswordManagerDriver_InformAboutUserInput_Name:
            return "Receive reply autofill::mojom::PasswordManagerDriver::InformAboutUserInput";
      case internal::kPasswordManagerDriver_DynamicFormSubmission_Name:
            return "Receive reply autofill::mojom::PasswordManagerDriver::DynamicFormSubmission";
      case internal::kPasswordManagerDriver_PasswordFormCleared_Name:
            return "Receive reply autofill::mojom::PasswordManagerDriver::PasswordFormCleared";
      case internal::kPasswordManagerDriver_RecordSavePasswordProgress_Name:
            return "Receive reply autofill::mojom::PasswordManagerDriver::RecordSavePasswordProgress";
      case internal::kPasswordManagerDriver_UserModifiedPasswordField_Name:
            return "Receive reply autofill::mojom::PasswordManagerDriver::UserModifiedPasswordField";
      case internal::kPasswordManagerDriver_UserModifiedNonPasswordField_Name:
            return "Receive reply autofill::mojom::PasswordManagerDriver::UserModifiedNonPasswordField";
      case internal::kPasswordManagerDriver_ShowPasswordSuggestions_Name:
            return "Receive reply autofill::mojom::PasswordManagerDriver::ShowPasswordSuggestions";
      case internal::kPasswordManagerDriver_ShowTouchToFill_Name:
            return "Receive reply autofill::mojom::PasswordManagerDriver::ShowTouchToFill";
      case internal::kPasswordManagerDriver_CheckSafeBrowsingReputation_Name:
            return "Receive reply autofill::mojom::PasswordManagerDriver::CheckSafeBrowsingReputation";
      case internal::kPasswordManagerDriver_FocusedInputChanged_Name:
            return "Receive reply autofill::mojom::PasswordManagerDriver::FocusedInputChanged";
      case internal::kPasswordManagerDriver_LogFirstFillingResult_Name:
            return "Receive reply autofill::mojom::PasswordManagerDriver::LogFirstFillingResult";
    }
  }
  return "Receive unknown mojo message";
#else
  bool is_response = message.has_flag(mojo::Message::kFlagIsResponse);
  if (is_response) {
    return "Receive mojo reply";
  } else {
    return "Receive mojo message";
  }
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
}

#if !BUILDFLAG(IS_FUCHSIA)
uint32_t PasswordManagerDriver::PasswordFormsParsed_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)autofill::mojom::PasswordManagerDriver::PasswordFormsParsed");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t PasswordManagerDriver::PasswordFormsRendered_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)autofill::mojom::PasswordManagerDriver::PasswordFormsRendered");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t PasswordManagerDriver::PasswordFormSubmitted_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)autofill::mojom::PasswordManagerDriver::PasswordFormSubmitted");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t PasswordManagerDriver::InformAboutUserInput_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)autofill::mojom::PasswordManagerDriver::InformAboutUserInput");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t PasswordManagerDriver::DynamicFormSubmission_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)autofill::mojom::PasswordManagerDriver::DynamicFormSubmission");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t PasswordManagerDriver::PasswordFormCleared_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)autofill::mojom::PasswordManagerDriver::PasswordFormCleared");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t PasswordManagerDriver::RecordSavePasswordProgress_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)autofill::mojom::PasswordManagerDriver::RecordSavePasswordProgress");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t PasswordManagerDriver::UserModifiedPasswordField_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)autofill::mojom::PasswordManagerDriver::UserModifiedPasswordField");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t PasswordManagerDriver::UserModifiedNonPasswordField_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)autofill::mojom::PasswordManagerDriver::UserModifiedNonPasswordField");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t PasswordManagerDriver::ShowPasswordSuggestions_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)autofill::mojom::PasswordManagerDriver::ShowPasswordSuggestions");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t PasswordManagerDriver::ShowTouchToFill_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)autofill::mojom::PasswordManagerDriver::ShowTouchToFill");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t PasswordManagerDriver::CheckSafeBrowsingReputation_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)autofill::mojom::PasswordManagerDriver::CheckSafeBrowsingReputation");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t PasswordManagerDriver::FocusedInputChanged_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)autofill::mojom::PasswordManagerDriver::FocusedInputChanged");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t PasswordManagerDriver::LogFirstFillingResult_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)autofill::mojom::PasswordManagerDriver::LogFirstFillingResult");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
# endif // !BUILDFLAG(IS_FUCHSIA)

PasswordManagerDriverProxy::PasswordManagerDriverProxy(mojo::MessageReceiverWithResponder* receiver)
    : receiver_(receiver) {
}

void PasswordManagerDriverProxy::PasswordFormsParsed(
    const std::vector<::autofill::FormData>& in_forms_data) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send autofill::mojom::PasswordManagerDriver::PasswordFormsParsed", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("forms_data"), in_forms_data,
                        "<value of type const std::vector<::autofill::FormData>&>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kPasswordManagerDriver_PasswordFormsParsed_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::autofill::mojom::internal::PasswordManagerDriver_PasswordFormsParsed_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->forms_data)::BaseType>
      forms_data_fragment(params.message());
  const mojo::internal::ContainerValidateParams forms_data_validate_params(
      0, false, nullptr);
  mojo::internal::Serialize<mojo::ArrayDataView<::autofill::mojom::FormDataDataView>>(
      in_forms_data, forms_data_fragment, &forms_data_validate_params);
  params->forms_data.Set(
      forms_data_fragment.is_null() ? nullptr : forms_data_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->forms_data.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null forms_data in PasswordManagerDriver.PasswordFormsParsed request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PasswordManagerDriver::Name_);
  message.set_method_name("PasswordFormsParsed");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void PasswordManagerDriverProxy::PasswordFormsRendered(
    const std::vector<::autofill::FormData>& in_visible_forms_data) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send autofill::mojom::PasswordManagerDriver::PasswordFormsRendered", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("visible_forms_data"), in_visible_forms_data,
                        "<value of type const std::vector<::autofill::FormData>&>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kPasswordManagerDriver_PasswordFormsRendered_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::autofill::mojom::internal::PasswordManagerDriver_PasswordFormsRendered_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->visible_forms_data)::BaseType>
      visible_forms_data_fragment(params.message());
  const mojo::internal::ContainerValidateParams visible_forms_data_validate_params(
      0, false, nullptr);
  mojo::internal::Serialize<mojo::ArrayDataView<::autofill::mojom::FormDataDataView>>(
      in_visible_forms_data, visible_forms_data_fragment, &visible_forms_data_validate_params);
  params->visible_forms_data.Set(
      visible_forms_data_fragment.is_null() ? nullptr : visible_forms_data_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->visible_forms_data.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null visible_forms_data in PasswordManagerDriver.PasswordFormsRendered request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PasswordManagerDriver::Name_);
  message.set_method_name("PasswordFormsRendered");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void PasswordManagerDriverProxy::PasswordFormSubmitted(
    const ::autofill::FormData& in_form_data) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send autofill::mojom::PasswordManagerDriver::PasswordFormSubmitted", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("form_data"), in_form_data,
                        "<value of type const ::autofill::FormData&>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kPasswordManagerDriver_PasswordFormSubmitted_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::autofill::mojom::internal::PasswordManagerDriver_PasswordFormSubmitted_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->form_data)::BaseType> form_data_fragment(
          params.message());
  mojo::internal::Serialize<::autofill::mojom::FormDataDataView>(
      in_form_data, form_data_fragment);
  params->form_data.Set(
      form_data_fragment.is_null() ? nullptr : form_data_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->form_data.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null form_data in PasswordManagerDriver.PasswordFormSubmitted request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PasswordManagerDriver::Name_);
  message.set_method_name("PasswordFormSubmitted");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void PasswordManagerDriverProxy::InformAboutUserInput(
    const ::autofill::FormData& in_form_data) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send autofill::mojom::PasswordManagerDriver::InformAboutUserInput", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("form_data"), in_form_data,
                        "<value of type const ::autofill::FormData&>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kPasswordManagerDriver_InformAboutUserInput_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::autofill::mojom::internal::PasswordManagerDriver_InformAboutUserInput_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->form_data)::BaseType> form_data_fragment(
          params.message());
  mojo::internal::Serialize<::autofill::mojom::FormDataDataView>(
      in_form_data, form_data_fragment);
  params->form_data.Set(
      form_data_fragment.is_null() ? nullptr : form_data_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->form_data.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null form_data in PasswordManagerDriver.InformAboutUserInput request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PasswordManagerDriver::Name_);
  message.set_method_name("InformAboutUserInput");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void PasswordManagerDriverProxy::DynamicFormSubmission(
    ::autofill::mojom::SubmissionIndicatorEvent in_submission_indication_event) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send autofill::mojom::PasswordManagerDriver::DynamicFormSubmission", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("submission_indication_event"), in_submission_indication_event,
                        "<value of type ::autofill::mojom::SubmissionIndicatorEvent>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kPasswordManagerDriver_DynamicFormSubmission_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::autofill::mojom::internal::PasswordManagerDriver_DynamicFormSubmission_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::Serialize<::autofill::mojom::SubmissionIndicatorEvent>(
      in_submission_indication_event, &params->submission_indication_event);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PasswordManagerDriver::Name_);
  message.set_method_name("DynamicFormSubmission");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void PasswordManagerDriverProxy::PasswordFormCleared(
    const ::autofill::FormData& in_form_data) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send autofill::mojom::PasswordManagerDriver::PasswordFormCleared", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("form_data"), in_form_data,
                        "<value of type const ::autofill::FormData&>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kPasswordManagerDriver_PasswordFormCleared_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::autofill::mojom::internal::PasswordManagerDriver_PasswordFormCleared_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->form_data)::BaseType> form_data_fragment(
          params.message());
  mojo::internal::Serialize<::autofill::mojom::FormDataDataView>(
      in_form_data, form_data_fragment);
  params->form_data.Set(
      form_data_fragment.is_null() ? nullptr : form_data_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->form_data.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null form_data in PasswordManagerDriver.PasswordFormCleared request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PasswordManagerDriver::Name_);
  message.set_method_name("PasswordFormCleared");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void PasswordManagerDriverProxy::RecordSavePasswordProgress(
    const std::string& in_log) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send autofill::mojom::PasswordManagerDriver::RecordSavePasswordProgress", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("log"), in_log,
                        "<value of type const std::string&>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kPasswordManagerDriver_RecordSavePasswordProgress_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::autofill::mojom::internal::PasswordManagerDriver_RecordSavePasswordProgress_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->log)::BaseType> log_fragment(
          params.message());
  mojo::internal::Serialize<mojo::StringDataView>(
      in_log, log_fragment);
  params->log.Set(
      log_fragment.is_null() ? nullptr : log_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->log.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null log in PasswordManagerDriver.RecordSavePasswordProgress request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PasswordManagerDriver::Name_);
  message.set_method_name("RecordSavePasswordProgress");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void PasswordManagerDriverProxy::UserModifiedPasswordField(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send autofill::mojom::PasswordManagerDriver::UserModifiedPasswordField");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kPasswordManagerDriver_UserModifiedPasswordField_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::autofill::mojom::internal::PasswordManagerDriver_UserModifiedPasswordField_Params_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PasswordManagerDriver::Name_);
  message.set_method_name("UserModifiedPasswordField");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void PasswordManagerDriverProxy::UserModifiedNonPasswordField(
    ::autofill::FieldRendererId in_renderer_id, const ::std::u16string& in_field_name, const ::std::u16string& in_value) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send autofill::mojom::PasswordManagerDriver::UserModifiedNonPasswordField", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("renderer_id"), in_renderer_id,
                        "<value of type ::autofill::FieldRendererId>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("field_name"), in_field_name,
                        "<value of type const ::std::u16string&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("value"), in_value,
                        "<value of type const ::std::u16string&>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kPasswordManagerDriver_UserModifiedNonPasswordField_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::autofill::mojom::internal::PasswordManagerDriver_UserModifiedNonPasswordField_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->renderer_id)::BaseType> renderer_id_fragment(
          params.message());
  mojo::internal::Serialize<::autofill::mojom::FieldRendererIdDataView>(
      in_renderer_id, renderer_id_fragment);
  params->renderer_id.Set(
      renderer_id_fragment.is_null() ? nullptr : renderer_id_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->renderer_id.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null renderer_id in PasswordManagerDriver.UserModifiedNonPasswordField request");
  mojo::internal::MessageFragment<
      typename decltype(params->field_name)::BaseType> field_name_fragment(
          params.message());
  mojo::internal::Serialize<::mojo_base::mojom::String16DataView>(
      in_field_name, field_name_fragment);
  params->field_name.Set(
      field_name_fragment.is_null() ? nullptr : field_name_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->field_name.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null field_name in PasswordManagerDriver.UserModifiedNonPasswordField request");
  mojo::internal::MessageFragment<
      typename decltype(params->value)::BaseType> value_fragment(
          params.message());
  mojo::internal::Serialize<::mojo_base::mojom::String16DataView>(
      in_value, value_fragment);
  params->value.Set(
      value_fragment.is_null() ? nullptr : value_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->value.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null value in PasswordManagerDriver.UserModifiedNonPasswordField request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PasswordManagerDriver::Name_);
  message.set_method_name("UserModifiedNonPasswordField");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void PasswordManagerDriverProxy::ShowPasswordSuggestions(
    ::base::i18n::TextDirection in_text_direction, const ::std::u16string& in_typed_username, int32_t in_options, const ::gfx::RectF& in_bounds) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send autofill::mojom::PasswordManagerDriver::ShowPasswordSuggestions", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("text_direction"), in_text_direction,
                        "<value of type ::base::i18n::TextDirection>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("typed_username"), in_typed_username,
                        "<value of type const ::std::u16string&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("options"), in_options,
                        "<value of type int32_t>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("bounds"), in_bounds,
                        "<value of type const ::gfx::RectF&>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kPasswordManagerDriver_ShowPasswordSuggestions_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::autofill::mojom::internal::PasswordManagerDriver_ShowPasswordSuggestions_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::Serialize<::mojo_base::mojom::TextDirection>(
      in_text_direction, &params->text_direction);
  mojo::internal::MessageFragment<
      typename decltype(params->typed_username)::BaseType> typed_username_fragment(
          params.message());
  mojo::internal::Serialize<::mojo_base::mojom::String16DataView>(
      in_typed_username, typed_username_fragment);
  params->typed_username.Set(
      typed_username_fragment.is_null() ? nullptr : typed_username_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->typed_username.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null typed_username in PasswordManagerDriver.ShowPasswordSuggestions request");
  params->options = in_options;
  mojo::internal::MessageFragment<
      typename decltype(params->bounds)::BaseType> bounds_fragment(
          params.message());
  mojo::internal::Serialize<::gfx::mojom::RectFDataView>(
      in_bounds, bounds_fragment);
  params->bounds.Set(
      bounds_fragment.is_null() ? nullptr : bounds_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->bounds.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null bounds in PasswordManagerDriver.ShowPasswordSuggestions request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PasswordManagerDriver::Name_);
  message.set_method_name("ShowPasswordSuggestions");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void PasswordManagerDriverProxy::ShowTouchToFill(
    ::autofill::mojom::SubmissionReadinessState in_submission_readiness) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send autofill::mojom::PasswordManagerDriver::ShowTouchToFill", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("submission_readiness"), in_submission_readiness,
                        "<value of type ::autofill::mojom::SubmissionReadinessState>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kPasswordManagerDriver_ShowTouchToFill_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::autofill::mojom::internal::PasswordManagerDriver_ShowTouchToFill_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::Serialize<::autofill::mojom::SubmissionReadinessState>(
      in_submission_readiness, &params->submission_readiness);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PasswordManagerDriver::Name_);
  message.set_method_name("ShowTouchToFill");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void PasswordManagerDriverProxy::CheckSafeBrowsingReputation(
    const ::GURL& in_form_action, const ::GURL& in_frame_url) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send autofill::mojom::PasswordManagerDriver::CheckSafeBrowsingReputation", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("form_action"), in_form_action,
                        "<value of type const ::GURL&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("frame_url"), in_frame_url,
                        "<value of type const ::GURL&>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kPasswordManagerDriver_CheckSafeBrowsingReputation_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::autofill::mojom::internal::PasswordManagerDriver_CheckSafeBrowsingReputation_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->form_action)::BaseType> form_action_fragment(
          params.message());
  mojo::internal::Serialize<::url::mojom::UrlDataView>(
      in_form_action, form_action_fragment);
  params->form_action.Set(
      form_action_fragment.is_null() ? nullptr : form_action_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->form_action.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null form_action in PasswordManagerDriver.CheckSafeBrowsingReputation request");
  mojo::internal::MessageFragment<
      typename decltype(params->frame_url)::BaseType> frame_url_fragment(
          params.message());
  mojo::internal::Serialize<::url::mojom::UrlDataView>(
      in_frame_url, frame_url_fragment);
  params->frame_url.Set(
      frame_url_fragment.is_null() ? nullptr : frame_url_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->frame_url.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null frame_url in PasswordManagerDriver.CheckSafeBrowsingReputation request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PasswordManagerDriver::Name_);
  message.set_method_name("CheckSafeBrowsingReputation");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void PasswordManagerDriverProxy::FocusedInputChanged(
    ::autofill::FieldRendererId in_focused_field_id, ::autofill::mojom::FocusedFieldType in_focused_field_type) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send autofill::mojom::PasswordManagerDriver::FocusedInputChanged", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("focused_field_id"), in_focused_field_id,
                        "<value of type ::autofill::FieldRendererId>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("focused_field_type"), in_focused_field_type,
                        "<value of type ::autofill::mojom::FocusedFieldType>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kPasswordManagerDriver_FocusedInputChanged_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::autofill::mojom::internal::PasswordManagerDriver_FocusedInputChanged_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->focused_field_id)::BaseType> focused_field_id_fragment(
          params.message());
  mojo::internal::Serialize<::autofill::mojom::FieldRendererIdDataView>(
      in_focused_field_id, focused_field_id_fragment);
  params->focused_field_id.Set(
      focused_field_id_fragment.is_null() ? nullptr : focused_field_id_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->focused_field_id.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null focused_field_id in PasswordManagerDriver.FocusedInputChanged request");
  mojo::internal::Serialize<::autofill::mojom::FocusedFieldType>(
      in_focused_field_type, &params->focused_field_type);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PasswordManagerDriver::Name_);
  message.set_method_name("FocusedInputChanged");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void PasswordManagerDriverProxy::LogFirstFillingResult(
    ::autofill::FormRendererId in_form_renderer_id, int32_t in_result) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send autofill::mojom::PasswordManagerDriver::LogFirstFillingResult", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("form_renderer_id"), in_form_renderer_id,
                        "<value of type ::autofill::FormRendererId>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("result"), in_result,
                        "<value of type int32_t>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kPasswordManagerDriver_LogFirstFillingResult_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::autofill::mojom::internal::PasswordManagerDriver_LogFirstFillingResult_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->form_renderer_id)::BaseType> form_renderer_id_fragment(
          params.message());
  mojo::internal::Serialize<::autofill::mojom::FormRendererIdDataView>(
      in_form_renderer_id, form_renderer_id_fragment);
  params->form_renderer_id.Set(
      form_renderer_id_fragment.is_null() ? nullptr : form_renderer_id_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->form_renderer_id.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null form_renderer_id in PasswordManagerDriver.LogFirstFillingResult request");
  params->result = in_result;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PasswordManagerDriver::Name_);
  message.set_method_name("LogFirstFillingResult");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

// static
bool PasswordManagerDriverStubDispatch::Accept(
    PasswordManagerDriver* impl,
    mojo::Message* message) {
  switch (message->header()->name) {
    case internal::kPasswordManagerDriver_PasswordFormsParsed_Name: {

      DCHECK(message->is_serialized());
      internal::PasswordManagerDriver_PasswordFormsParsed_Params_Data* params =
          reinterpret_cast<internal::PasswordManagerDriver_PasswordFormsParsed_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      std::vector<::autofill::FormData> p_forms_data{};
      PasswordManagerDriver_PasswordFormsParsed_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadFormsData(&p_forms_data))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            PasswordManagerDriver::Name_, 0, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->PasswordFormsParsed(
std::move(p_forms_data));
      return true;
    }
    case internal::kPasswordManagerDriver_PasswordFormsRendered_Name: {

      DCHECK(message->is_serialized());
      internal::PasswordManagerDriver_PasswordFormsRendered_Params_Data* params =
          reinterpret_cast<internal::PasswordManagerDriver_PasswordFormsRendered_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      std::vector<::autofill::FormData> p_visible_forms_data{};
      PasswordManagerDriver_PasswordFormsRendered_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadVisibleFormsData(&p_visible_forms_data))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            PasswordManagerDriver::Name_, 1, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->PasswordFormsRendered(
std::move(p_visible_forms_data));
      return true;
    }
    case internal::kPasswordManagerDriver_PasswordFormSubmitted_Name: {

      DCHECK(message->is_serialized());
      internal::PasswordManagerDriver_PasswordFormSubmitted_Params_Data* params =
          reinterpret_cast<internal::PasswordManagerDriver_PasswordFormSubmitted_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::autofill::FormData p_form_data{};
      PasswordManagerDriver_PasswordFormSubmitted_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadFormData(&p_form_data))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            PasswordManagerDriver::Name_, 2, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->PasswordFormSubmitted(
std::move(p_form_data));
      return true;
    }
    case internal::kPasswordManagerDriver_InformAboutUserInput_Name: {

      DCHECK(message->is_serialized());
      internal::PasswordManagerDriver_InformAboutUserInput_Params_Data* params =
          reinterpret_cast<internal::PasswordManagerDriver_InformAboutUserInput_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::autofill::FormData p_form_data{};
      PasswordManagerDriver_InformAboutUserInput_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadFormData(&p_form_data))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            PasswordManagerDriver::Name_, 3, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->InformAboutUserInput(
std::move(p_form_data));
      return true;
    }
    case internal::kPasswordManagerDriver_DynamicFormSubmission_Name: {

      DCHECK(message->is_serialized());
      internal::PasswordManagerDriver_DynamicFormSubmission_Params_Data* params =
          reinterpret_cast<internal::PasswordManagerDriver_DynamicFormSubmission_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::autofill::mojom::SubmissionIndicatorEvent p_submission_indication_event{};
      PasswordManagerDriver_DynamicFormSubmission_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadSubmissionIndicationEvent(&p_submission_indication_event))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            PasswordManagerDriver::Name_, 4, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->DynamicFormSubmission(
std::move(p_submission_indication_event));
      return true;
    }
    case internal::kPasswordManagerDriver_PasswordFormCleared_Name: {

      DCHECK(message->is_serialized());
      internal::PasswordManagerDriver_PasswordFormCleared_Params_Data* params =
          reinterpret_cast<internal::PasswordManagerDriver_PasswordFormCleared_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::autofill::FormData p_form_data{};
      PasswordManagerDriver_PasswordFormCleared_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadFormData(&p_form_data))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            PasswordManagerDriver::Name_, 5, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->PasswordFormCleared(
std::move(p_form_data));
      return true;
    }
    case internal::kPasswordManagerDriver_RecordSavePasswordProgress_Name: {

      DCHECK(message->is_serialized());
      internal::PasswordManagerDriver_RecordSavePasswordProgress_Params_Data* params =
          reinterpret_cast<internal::PasswordManagerDriver_RecordSavePasswordProgress_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      std::string p_log{};
      PasswordManagerDriver_RecordSavePasswordProgress_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadLog(&p_log))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            PasswordManagerDriver::Name_, 6, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->RecordSavePasswordProgress(
std::move(p_log));
      return true;
    }
    case internal::kPasswordManagerDriver_UserModifiedPasswordField_Name: {

      DCHECK(message->is_serialized());
      internal::PasswordManagerDriver_UserModifiedPasswordField_Params_Data* params =
          reinterpret_cast<internal::PasswordManagerDriver_UserModifiedPasswordField_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      PasswordManagerDriver_UserModifiedPasswordField_ParamsDataView input_data_view(params, message);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            PasswordManagerDriver::Name_, 7, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->UserModifiedPasswordField();
      return true;
    }
    case internal::kPasswordManagerDriver_UserModifiedNonPasswordField_Name: {

      DCHECK(message->is_serialized());
      internal::PasswordManagerDriver_UserModifiedNonPasswordField_Params_Data* params =
          reinterpret_cast<internal::PasswordManagerDriver_UserModifiedNonPasswordField_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::autofill::FieldRendererId p_renderer_id{};
      ::std::u16string p_field_name{};
      ::std::u16string p_value{};
      PasswordManagerDriver_UserModifiedNonPasswordField_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadRendererId(&p_renderer_id))
        success = false;
      if (success && !input_data_view.ReadFieldName(&p_field_name))
        success = false;
      if (success && !input_data_view.ReadValue(&p_value))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            PasswordManagerDriver::Name_, 8, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->UserModifiedNonPasswordField(
std::move(p_renderer_id), 
std::move(p_field_name), 
std::move(p_value));
      return true;
    }
    case internal::kPasswordManagerDriver_ShowPasswordSuggestions_Name: {

      DCHECK(message->is_serialized());
      internal::PasswordManagerDriver_ShowPasswordSuggestions_Params_Data* params =
          reinterpret_cast<internal::PasswordManagerDriver_ShowPasswordSuggestions_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::base::i18n::TextDirection p_text_direction{};
      ::std::u16string p_typed_username{};
      int32_t p_options{};
      ::gfx::RectF p_bounds{};
      PasswordManagerDriver_ShowPasswordSuggestions_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadTextDirection(&p_text_direction))
        success = false;
      if (success && !input_data_view.ReadTypedUsername(&p_typed_username))
        success = false;
      if (success)
        p_options = input_data_view.options();
      if (success && !input_data_view.ReadBounds(&p_bounds))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            PasswordManagerDriver::Name_, 9, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->ShowPasswordSuggestions(
std::move(p_text_direction), 
std::move(p_typed_username), 
std::move(p_options), 
std::move(p_bounds));
      return true;
    }
    case internal::kPasswordManagerDriver_ShowTouchToFill_Name: {

      DCHECK(message->is_serialized());
      internal::PasswordManagerDriver_ShowTouchToFill_Params_Data* params =
          reinterpret_cast<internal::PasswordManagerDriver_ShowTouchToFill_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::autofill::mojom::SubmissionReadinessState p_submission_readiness{};
      PasswordManagerDriver_ShowTouchToFill_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadSubmissionReadiness(&p_submission_readiness))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            PasswordManagerDriver::Name_, 10, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->ShowTouchToFill(
std::move(p_submission_readiness));
      return true;
    }
    case internal::kPasswordManagerDriver_CheckSafeBrowsingReputation_Name: {

      DCHECK(message->is_serialized());
      internal::PasswordManagerDriver_CheckSafeBrowsingReputation_Params_Data* params =
          reinterpret_cast<internal::PasswordManagerDriver_CheckSafeBrowsingReputation_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::GURL p_form_action{};
      ::GURL p_frame_url{};
      PasswordManagerDriver_CheckSafeBrowsingReputation_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadFormAction(&p_form_action))
        success = false;
      if (success && !input_data_view.ReadFrameUrl(&p_frame_url))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            PasswordManagerDriver::Name_, 11, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->CheckSafeBrowsingReputation(
std::move(p_form_action), 
std::move(p_frame_url));
      return true;
    }
    case internal::kPasswordManagerDriver_FocusedInputChanged_Name: {

      DCHECK(message->is_serialized());
      internal::PasswordManagerDriver_FocusedInputChanged_Params_Data* params =
          reinterpret_cast<internal::PasswordManagerDriver_FocusedInputChanged_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::autofill::FieldRendererId p_focused_field_id{};
      ::autofill::mojom::FocusedFieldType p_focused_field_type{};
      PasswordManagerDriver_FocusedInputChanged_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadFocusedFieldId(&p_focused_field_id))
        success = false;
      if (success && !input_data_view.ReadFocusedFieldType(&p_focused_field_type))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            PasswordManagerDriver::Name_, 12, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->FocusedInputChanged(
std::move(p_focused_field_id), 
std::move(p_focused_field_type));
      return true;
    }
    case internal::kPasswordManagerDriver_LogFirstFillingResult_Name: {

      DCHECK(message->is_serialized());
      internal::PasswordManagerDriver_LogFirstFillingResult_Params_Data* params =
          reinterpret_cast<internal::PasswordManagerDriver_LogFirstFillingResult_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::autofill::FormRendererId p_form_renderer_id{};
      int32_t p_result{};
      PasswordManagerDriver_LogFirstFillingResult_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadFormRendererId(&p_form_renderer_id))
        success = false;
      if (success)
        p_result = input_data_view.result();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            PasswordManagerDriver::Name_, 13, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->LogFirstFillingResult(
std::move(p_form_renderer_id), 
std::move(p_result));
      return true;
    }
  }
  return false;
}

// static
bool PasswordManagerDriverStubDispatch::AcceptWithResponder(
    PasswordManagerDriver* impl,
    mojo::Message* message,
    std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
  [[maybe_unused]] const bool message_is_sync =
      message->has_flag(mojo::Message::kFlagIsSync);
  [[maybe_unused]] const uint64_t request_id = message->request_id();
  switch (message->header()->name) {
    case internal::kPasswordManagerDriver_PasswordFormsParsed_Name: {
      break;
    }
    case internal::kPasswordManagerDriver_PasswordFormsRendered_Name: {
      break;
    }
    case internal::kPasswordManagerDriver_PasswordFormSubmitted_Name: {
      break;
    }
    case internal::kPasswordManagerDriver_InformAboutUserInput_Name: {
      break;
    }
    case internal::kPasswordManagerDriver_DynamicFormSubmission_Name: {
      break;
    }
    case internal::kPasswordManagerDriver_PasswordFormCleared_Name: {
      break;
    }
    case internal::kPasswordManagerDriver_RecordSavePasswordProgress_Name: {
      break;
    }
    case internal::kPasswordManagerDriver_UserModifiedPasswordField_Name: {
      break;
    }
    case internal::kPasswordManagerDriver_UserModifiedNonPasswordField_Name: {
      break;
    }
    case internal::kPasswordManagerDriver_ShowPasswordSuggestions_Name: {
      break;
    }
    case internal::kPasswordManagerDriver_ShowTouchToFill_Name: {
      break;
    }
    case internal::kPasswordManagerDriver_CheckSafeBrowsingReputation_Name: {
      break;
    }
    case internal::kPasswordManagerDriver_FocusedInputChanged_Name: {
      break;
    }
    case internal::kPasswordManagerDriver_LogFirstFillingResult_Name: {
      break;
    }
  }
  return false;
}


static const mojo::internal::GenericValidationInfo kPasswordManagerDriverValidationInfo[] = {
    {&internal::PasswordManagerDriver_PasswordFormsParsed_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::PasswordManagerDriver_PasswordFormsRendered_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::PasswordManagerDriver_PasswordFormSubmitted_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::PasswordManagerDriver_InformAboutUserInput_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::PasswordManagerDriver_DynamicFormSubmission_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::PasswordManagerDriver_PasswordFormCleared_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::PasswordManagerDriver_RecordSavePasswordProgress_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::PasswordManagerDriver_UserModifiedPasswordField_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::PasswordManagerDriver_UserModifiedNonPasswordField_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::PasswordManagerDriver_ShowPasswordSuggestions_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::PasswordManagerDriver_ShowTouchToFill_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::PasswordManagerDriver_CheckSafeBrowsingReputation_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::PasswordManagerDriver_FocusedInputChanged_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::PasswordManagerDriver_LogFirstFillingResult_Params_Data::Validate,
     nullptr /* no response */},
};

bool PasswordManagerDriverRequestValidator::Accept(mojo::Message* message) {
  const char* name = ::autofill::mojom::PasswordManagerDriver::Name_;
  return mojo::internal::ValidateRequestGenericPacked(message, name, kPasswordManagerDriverValidationInfo);
}

const char PasswordGenerationDriver::Name_[] = "autofill.mojom.PasswordGenerationDriver";

PasswordGenerationDriver::IPCStableHashFunction PasswordGenerationDriver::MessageToMethodInfo_(mojo::Message& message) {
#if !BUILDFLAG(IS_FUCHSIA)
  switch (message.name()) {
    case internal::kPasswordGenerationDriver_AutomaticGenerationAvailable_Name: {
      return &PasswordGenerationDriver::AutomaticGenerationAvailable_Sym::IPCStableHash;
    }
    case internal::kPasswordGenerationDriver_ShowPasswordEditingPopup_Name: {
      return &PasswordGenerationDriver::ShowPasswordEditingPopup_Sym::IPCStableHash;
    }
    case internal::kPasswordGenerationDriver_PasswordGenerationRejectedByTyping_Name: {
      return &PasswordGenerationDriver::PasswordGenerationRejectedByTyping_Sym::IPCStableHash;
    }
    case internal::kPasswordGenerationDriver_PresaveGeneratedPassword_Name: {
      return &PasswordGenerationDriver::PresaveGeneratedPassword_Sym::IPCStableHash;
    }
    case internal::kPasswordGenerationDriver_PasswordNoLongerGenerated_Name: {
      return &PasswordGenerationDriver::PasswordNoLongerGenerated_Sym::IPCStableHash;
    }
    case internal::kPasswordGenerationDriver_FrameWasScrolled_Name: {
      return &PasswordGenerationDriver::FrameWasScrolled_Sym::IPCStableHash;
    }
    case internal::kPasswordGenerationDriver_GenerationElementLostFocus_Name: {
      return &PasswordGenerationDriver::GenerationElementLostFocus_Sym::IPCStableHash;
    }
  }
#endif  // !BUILDFLAG(IS_FUCHSIA)
  return nullptr;
}


const char* PasswordGenerationDriver::MessageToMethodName_(mojo::Message& message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  bool is_response = message.has_flag(mojo::Message::kFlagIsResponse);
  if (!is_response) {
    switch (message.name()) {
      case internal::kPasswordGenerationDriver_AutomaticGenerationAvailable_Name:
            return "Receive autofill::mojom::PasswordGenerationDriver::AutomaticGenerationAvailable";
      case internal::kPasswordGenerationDriver_ShowPasswordEditingPopup_Name:
            return "Receive autofill::mojom::PasswordGenerationDriver::ShowPasswordEditingPopup";
      case internal::kPasswordGenerationDriver_PasswordGenerationRejectedByTyping_Name:
            return "Receive autofill::mojom::PasswordGenerationDriver::PasswordGenerationRejectedByTyping";
      case internal::kPasswordGenerationDriver_PresaveGeneratedPassword_Name:
            return "Receive autofill::mojom::PasswordGenerationDriver::PresaveGeneratedPassword";
      case internal::kPasswordGenerationDriver_PasswordNoLongerGenerated_Name:
            return "Receive autofill::mojom::PasswordGenerationDriver::PasswordNoLongerGenerated";
      case internal::kPasswordGenerationDriver_FrameWasScrolled_Name:
            return "Receive autofill::mojom::PasswordGenerationDriver::FrameWasScrolled";
      case internal::kPasswordGenerationDriver_GenerationElementLostFocus_Name:
            return "Receive autofill::mojom::PasswordGenerationDriver::GenerationElementLostFocus";
    }
  } else {
    switch (message.name()) {
      case internal::kPasswordGenerationDriver_AutomaticGenerationAvailable_Name:
            return "Receive reply autofill::mojom::PasswordGenerationDriver::AutomaticGenerationAvailable";
      case internal::kPasswordGenerationDriver_ShowPasswordEditingPopup_Name:
            return "Receive reply autofill::mojom::PasswordGenerationDriver::ShowPasswordEditingPopup";
      case internal::kPasswordGenerationDriver_PasswordGenerationRejectedByTyping_Name:
            return "Receive reply autofill::mojom::PasswordGenerationDriver::PasswordGenerationRejectedByTyping";
      case internal::kPasswordGenerationDriver_PresaveGeneratedPassword_Name:
            return "Receive reply autofill::mojom::PasswordGenerationDriver::PresaveGeneratedPassword";
      case internal::kPasswordGenerationDriver_PasswordNoLongerGenerated_Name:
            return "Receive reply autofill::mojom::PasswordGenerationDriver::PasswordNoLongerGenerated";
      case internal::kPasswordGenerationDriver_FrameWasScrolled_Name:
            return "Receive reply autofill::mojom::PasswordGenerationDriver::FrameWasScrolled";
      case internal::kPasswordGenerationDriver_GenerationElementLostFocus_Name:
            return "Receive reply autofill::mojom::PasswordGenerationDriver::GenerationElementLostFocus";
    }
  }
  return "Receive unknown mojo message";
#else
  bool is_response = message.has_flag(mojo::Message::kFlagIsResponse);
  if (is_response) {
    return "Receive mojo reply";
  } else {
    return "Receive mojo message";
  }
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
}

#if !BUILDFLAG(IS_FUCHSIA)
uint32_t PasswordGenerationDriver::AutomaticGenerationAvailable_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)autofill::mojom::PasswordGenerationDriver::AutomaticGenerationAvailable");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t PasswordGenerationDriver::ShowPasswordEditingPopup_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)autofill::mojom::PasswordGenerationDriver::ShowPasswordEditingPopup");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t PasswordGenerationDriver::PasswordGenerationRejectedByTyping_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)autofill::mojom::PasswordGenerationDriver::PasswordGenerationRejectedByTyping");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t PasswordGenerationDriver::PresaveGeneratedPassword_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)autofill::mojom::PasswordGenerationDriver::PresaveGeneratedPassword");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t PasswordGenerationDriver::PasswordNoLongerGenerated_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)autofill::mojom::PasswordGenerationDriver::PasswordNoLongerGenerated");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t PasswordGenerationDriver::FrameWasScrolled_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)autofill::mojom::PasswordGenerationDriver::FrameWasScrolled");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t PasswordGenerationDriver::GenerationElementLostFocus_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)autofill::mojom::PasswordGenerationDriver::GenerationElementLostFocus");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
# endif // !BUILDFLAG(IS_FUCHSIA)

PasswordGenerationDriverProxy::PasswordGenerationDriverProxy(mojo::MessageReceiverWithResponder* receiver)
    : receiver_(receiver) {
}

void PasswordGenerationDriverProxy::AutomaticGenerationAvailable(
    const ::autofill::password_generation::PasswordGenerationUIData& in_password_generation_ui_data) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send autofill::mojom::PasswordGenerationDriver::AutomaticGenerationAvailable", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("password_generation_ui_data"), in_password_generation_ui_data,
                        "<value of type const ::autofill::password_generation::PasswordGenerationUIData&>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kPasswordGenerationDriver_AutomaticGenerationAvailable_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::autofill::mojom::internal::PasswordGenerationDriver_AutomaticGenerationAvailable_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->password_generation_ui_data)::BaseType> password_generation_ui_data_fragment(
          params.message());
  mojo::internal::Serialize<::autofill::mojom::PasswordGenerationUIDataDataView>(
      in_password_generation_ui_data, password_generation_ui_data_fragment);
  params->password_generation_ui_data.Set(
      password_generation_ui_data_fragment.is_null() ? nullptr : password_generation_ui_data_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->password_generation_ui_data.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null password_generation_ui_data in PasswordGenerationDriver.AutomaticGenerationAvailable request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PasswordGenerationDriver::Name_);
  message.set_method_name("AutomaticGenerationAvailable");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void PasswordGenerationDriverProxy::ShowPasswordEditingPopup(
    const ::gfx::RectF& in_bounds, const ::autofill::FormData& in_form_data, ::autofill::FieldRendererId in_field_renderer_id, const ::std::u16string& in_password_value) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send autofill::mojom::PasswordGenerationDriver::ShowPasswordEditingPopup", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("bounds"), in_bounds,
                        "<value of type const ::gfx::RectF&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("form_data"), in_form_data,
                        "<value of type const ::autofill::FormData&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("field_renderer_id"), in_field_renderer_id,
                        "<value of type ::autofill::FieldRendererId>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("password_value"), in_password_value,
                        "<value of type const ::std::u16string&>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kPasswordGenerationDriver_ShowPasswordEditingPopup_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::autofill::mojom::internal::PasswordGenerationDriver_ShowPasswordEditingPopup_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->bounds)::BaseType> bounds_fragment(
          params.message());
  mojo::internal::Serialize<::gfx::mojom::RectFDataView>(
      in_bounds, bounds_fragment);
  params->bounds.Set(
      bounds_fragment.is_null() ? nullptr : bounds_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->bounds.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null bounds in PasswordGenerationDriver.ShowPasswordEditingPopup request");
  mojo::internal::MessageFragment<
      typename decltype(params->form_data)::BaseType> form_data_fragment(
          params.message());
  mojo::internal::Serialize<::autofill::mojom::FormDataDataView>(
      in_form_data, form_data_fragment);
  params->form_data.Set(
      form_data_fragment.is_null() ? nullptr : form_data_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->form_data.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null form_data in PasswordGenerationDriver.ShowPasswordEditingPopup request");
  mojo::internal::MessageFragment<
      typename decltype(params->field_renderer_id)::BaseType> field_renderer_id_fragment(
          params.message());
  mojo::internal::Serialize<::autofill::mojom::FieldRendererIdDataView>(
      in_field_renderer_id, field_renderer_id_fragment);
  params->field_renderer_id.Set(
      field_renderer_id_fragment.is_null() ? nullptr : field_renderer_id_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->field_renderer_id.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null field_renderer_id in PasswordGenerationDriver.ShowPasswordEditingPopup request");
  mojo::internal::MessageFragment<
      typename decltype(params->password_value)::BaseType> password_value_fragment(
          params.message());
  mojo::internal::Serialize<::mojo_base::mojom::String16DataView>(
      in_password_value, password_value_fragment);
  params->password_value.Set(
      password_value_fragment.is_null() ? nullptr : password_value_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->password_value.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null password_value in PasswordGenerationDriver.ShowPasswordEditingPopup request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PasswordGenerationDriver::Name_);
  message.set_method_name("ShowPasswordEditingPopup");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void PasswordGenerationDriverProxy::PasswordGenerationRejectedByTyping(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send autofill::mojom::PasswordGenerationDriver::PasswordGenerationRejectedByTyping");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kPasswordGenerationDriver_PasswordGenerationRejectedByTyping_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::autofill::mojom::internal::PasswordGenerationDriver_PasswordGenerationRejectedByTyping_Params_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PasswordGenerationDriver::Name_);
  message.set_method_name("PasswordGenerationRejectedByTyping");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void PasswordGenerationDriverProxy::PresaveGeneratedPassword(
    const ::autofill::FormData& in_form_data, const ::std::u16string& in_password_value) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send autofill::mojom::PasswordGenerationDriver::PresaveGeneratedPassword", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("form_data"), in_form_data,
                        "<value of type const ::autofill::FormData&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("password_value"), in_password_value,
                        "<value of type const ::std::u16string&>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kPasswordGenerationDriver_PresaveGeneratedPassword_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::autofill::mojom::internal::PasswordGenerationDriver_PresaveGeneratedPassword_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->form_data)::BaseType> form_data_fragment(
          params.message());
  mojo::internal::Serialize<::autofill::mojom::FormDataDataView>(
      in_form_data, form_data_fragment);
  params->form_data.Set(
      form_data_fragment.is_null() ? nullptr : form_data_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->form_data.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null form_data in PasswordGenerationDriver.PresaveGeneratedPassword request");
  mojo::internal::MessageFragment<
      typename decltype(params->password_value)::BaseType> password_value_fragment(
          params.message());
  mojo::internal::Serialize<::mojo_base::mojom::String16DataView>(
      in_password_value, password_value_fragment);
  params->password_value.Set(
      password_value_fragment.is_null() ? nullptr : password_value_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->password_value.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null password_value in PasswordGenerationDriver.PresaveGeneratedPassword request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PasswordGenerationDriver::Name_);
  message.set_method_name("PresaveGeneratedPassword");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void PasswordGenerationDriverProxy::PasswordNoLongerGenerated(
    const ::autofill::FormData& in_form_data) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send autofill::mojom::PasswordGenerationDriver::PasswordNoLongerGenerated", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("form_data"), in_form_data,
                        "<value of type const ::autofill::FormData&>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kPasswordGenerationDriver_PasswordNoLongerGenerated_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::autofill::mojom::internal::PasswordGenerationDriver_PasswordNoLongerGenerated_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->form_data)::BaseType> form_data_fragment(
          params.message());
  mojo::internal::Serialize<::autofill::mojom::FormDataDataView>(
      in_form_data, form_data_fragment);
  params->form_data.Set(
      form_data_fragment.is_null() ? nullptr : form_data_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->form_data.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null form_data in PasswordGenerationDriver.PasswordNoLongerGenerated request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PasswordGenerationDriver::Name_);
  message.set_method_name("PasswordNoLongerGenerated");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void PasswordGenerationDriverProxy::FrameWasScrolled(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send autofill::mojom::PasswordGenerationDriver::FrameWasScrolled");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kPasswordGenerationDriver_FrameWasScrolled_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::autofill::mojom::internal::PasswordGenerationDriver_FrameWasScrolled_Params_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PasswordGenerationDriver::Name_);
  message.set_method_name("FrameWasScrolled");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void PasswordGenerationDriverProxy::GenerationElementLostFocus(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send autofill::mojom::PasswordGenerationDriver::GenerationElementLostFocus");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kPasswordGenerationDriver_GenerationElementLostFocus_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::autofill::mojom::internal::PasswordGenerationDriver_GenerationElementLostFocus_Params_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PasswordGenerationDriver::Name_);
  message.set_method_name("GenerationElementLostFocus");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

// static
bool PasswordGenerationDriverStubDispatch::Accept(
    PasswordGenerationDriver* impl,
    mojo::Message* message) {
  switch (message->header()->name) {
    case internal::kPasswordGenerationDriver_AutomaticGenerationAvailable_Name: {

      DCHECK(message->is_serialized());
      internal::PasswordGenerationDriver_AutomaticGenerationAvailable_Params_Data* params =
          reinterpret_cast<internal::PasswordGenerationDriver_AutomaticGenerationAvailable_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::autofill::password_generation::PasswordGenerationUIData p_password_generation_ui_data{};
      PasswordGenerationDriver_AutomaticGenerationAvailable_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadPasswordGenerationUiData(&p_password_generation_ui_data))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            PasswordGenerationDriver::Name_, 0, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->AutomaticGenerationAvailable(
std::move(p_password_generation_ui_data));
      return true;
    }
    case internal::kPasswordGenerationDriver_ShowPasswordEditingPopup_Name: {

      DCHECK(message->is_serialized());
      internal::PasswordGenerationDriver_ShowPasswordEditingPopup_Params_Data* params =
          reinterpret_cast<internal::PasswordGenerationDriver_ShowPasswordEditingPopup_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::gfx::RectF p_bounds{};
      ::autofill::FormData p_form_data{};
      ::autofill::FieldRendererId p_field_renderer_id{};
      ::std::u16string p_password_value{};
      PasswordGenerationDriver_ShowPasswordEditingPopup_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadBounds(&p_bounds))
        success = false;
      if (success && !input_data_view.ReadFormData(&p_form_data))
        success = false;
      if (success && !input_data_view.ReadFieldRendererId(&p_field_renderer_id))
        success = false;
      if (success && !input_data_view.ReadPasswordValue(&p_password_value))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            PasswordGenerationDriver::Name_, 1, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->ShowPasswordEditingPopup(
std::move(p_bounds), 
std::move(p_form_data), 
std::move(p_field_renderer_id), 
std::move(p_password_value));
      return true;
    }
    case internal::kPasswordGenerationDriver_PasswordGenerationRejectedByTyping_Name: {

      DCHECK(message->is_serialized());
      internal::PasswordGenerationDriver_PasswordGenerationRejectedByTyping_Params_Data* params =
          reinterpret_cast<internal::PasswordGenerationDriver_PasswordGenerationRejectedByTyping_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      PasswordGenerationDriver_PasswordGenerationRejectedByTyping_ParamsDataView input_data_view(params, message);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            PasswordGenerationDriver::Name_, 2, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->PasswordGenerationRejectedByTyping();
      return true;
    }
    case internal::kPasswordGenerationDriver_PresaveGeneratedPassword_Name: {

      DCHECK(message->is_serialized());
      internal::PasswordGenerationDriver_PresaveGeneratedPassword_Params_Data* params =
          reinterpret_cast<internal::PasswordGenerationDriver_PresaveGeneratedPassword_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::autofill::FormData p_form_data{};
      ::std::u16string p_password_value{};
      PasswordGenerationDriver_PresaveGeneratedPassword_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadFormData(&p_form_data))
        success = false;
      if (success && !input_data_view.ReadPasswordValue(&p_password_value))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            PasswordGenerationDriver::Name_, 3, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->PresaveGeneratedPassword(
std::move(p_form_data), 
std::move(p_password_value));
      return true;
    }
    case internal::kPasswordGenerationDriver_PasswordNoLongerGenerated_Name: {

      DCHECK(message->is_serialized());
      internal::PasswordGenerationDriver_PasswordNoLongerGenerated_Params_Data* params =
          reinterpret_cast<internal::PasswordGenerationDriver_PasswordNoLongerGenerated_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::autofill::FormData p_form_data{};
      PasswordGenerationDriver_PasswordNoLongerGenerated_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadFormData(&p_form_data))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            PasswordGenerationDriver::Name_, 4, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->PasswordNoLongerGenerated(
std::move(p_form_data));
      return true;
    }
    case internal::kPasswordGenerationDriver_FrameWasScrolled_Name: {

      DCHECK(message->is_serialized());
      internal::PasswordGenerationDriver_FrameWasScrolled_Params_Data* params =
          reinterpret_cast<internal::PasswordGenerationDriver_FrameWasScrolled_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      PasswordGenerationDriver_FrameWasScrolled_ParamsDataView input_data_view(params, message);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            PasswordGenerationDriver::Name_, 5, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->FrameWasScrolled();
      return true;
    }
    case internal::kPasswordGenerationDriver_GenerationElementLostFocus_Name: {

      DCHECK(message->is_serialized());
      internal::PasswordGenerationDriver_GenerationElementLostFocus_Params_Data* params =
          reinterpret_cast<internal::PasswordGenerationDriver_GenerationElementLostFocus_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      PasswordGenerationDriver_GenerationElementLostFocus_ParamsDataView input_data_view(params, message);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            PasswordGenerationDriver::Name_, 6, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->GenerationElementLostFocus();
      return true;
    }
  }
  return false;
}

// static
bool PasswordGenerationDriverStubDispatch::AcceptWithResponder(
    PasswordGenerationDriver* impl,
    mojo::Message* message,
    std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
  [[maybe_unused]] const bool message_is_sync =
      message->has_flag(mojo::Message::kFlagIsSync);
  [[maybe_unused]] const uint64_t request_id = message->request_id();
  switch (message->header()->name) {
    case internal::kPasswordGenerationDriver_AutomaticGenerationAvailable_Name: {
      break;
    }
    case internal::kPasswordGenerationDriver_ShowPasswordEditingPopup_Name: {
      break;
    }
    case internal::kPasswordGenerationDriver_PasswordGenerationRejectedByTyping_Name: {
      break;
    }
    case internal::kPasswordGenerationDriver_PresaveGeneratedPassword_Name: {
      break;
    }
    case internal::kPasswordGenerationDriver_PasswordNoLongerGenerated_Name: {
      break;
    }
    case internal::kPasswordGenerationDriver_FrameWasScrolled_Name: {
      break;
    }
    case internal::kPasswordGenerationDriver_GenerationElementLostFocus_Name: {
      break;
    }
  }
  return false;
}


static const mojo::internal::GenericValidationInfo kPasswordGenerationDriverValidationInfo[] = {
    {&internal::PasswordGenerationDriver_AutomaticGenerationAvailable_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::PasswordGenerationDriver_ShowPasswordEditingPopup_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::PasswordGenerationDriver_PasswordGenerationRejectedByTyping_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::PasswordGenerationDriver_PresaveGeneratedPassword_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::PasswordGenerationDriver_PasswordNoLongerGenerated_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::PasswordGenerationDriver_FrameWasScrolled_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::PasswordGenerationDriver_GenerationElementLostFocus_Params_Data::Validate,
     nullptr /* no response */},
};

bool PasswordGenerationDriverRequestValidator::Accept(mojo::Message* message) {
  const char* name = ::autofill::mojom::PasswordGenerationDriver::Name_;
  return mojo::internal::ValidateRequestGenericPacked(message, name, kPasswordGenerationDriverValidationInfo);
}



}  // namespace mojom
}  // namespace autofill


namespace mojo {

}  // namespace mojo


// Symbols declared in the -test-utils.h header are defined here instead of a
// separate .cc file to save compile time.


namespace autofill {
namespace mojom {


void AutofillDriverInterceptorForTesting::SetFormToBeProbablySubmitted(const absl::optional<::autofill::FormData>& form) {
  GetForwardingInterface()->SetFormToBeProbablySubmitted(std::move(form));
}
void AutofillDriverInterceptorForTesting::FormsSeen(const std::vector<::autofill::FormData>& updated_forms, const std::vector<::autofill::FormRendererId>& removed_forms) {
  GetForwardingInterface()->FormsSeen(std::move(updated_forms), std::move(removed_forms));
}
void AutofillDriverInterceptorForTesting::FormSubmitted(const ::autofill::FormData& form, bool known_success, ::autofill::mojom::SubmissionSource source) {
  GetForwardingInterface()->FormSubmitted(std::move(form), std::move(known_success), std::move(source));
}
void AutofillDriverInterceptorForTesting::TextFieldDidChange(const ::autofill::FormData& form, const ::autofill::FormFieldData& field, const ::gfx::RectF& bounding_box, ::base::TimeTicks timestamp) {
  GetForwardingInterface()->TextFieldDidChange(std::move(form), std::move(field), std::move(bounding_box), std::move(timestamp));
}
void AutofillDriverInterceptorForTesting::TextFieldDidScroll(const ::autofill::FormData& form, const ::autofill::FormFieldData& field, const ::gfx::RectF& bounding_box) {
  GetForwardingInterface()->TextFieldDidScroll(std::move(form), std::move(field), std::move(bounding_box));
}
void AutofillDriverInterceptorForTesting::SelectControlDidChange(const ::autofill::FormData& form, const ::autofill::FormFieldData& field, const ::gfx::RectF& bounding_box) {
  GetForwardingInterface()->SelectControlDidChange(std::move(form), std::move(field), std::move(bounding_box));
}
void AutofillDriverInterceptorForTesting::SelectFieldOptionsDidChange(const ::autofill::FormData& form) {
  GetForwardingInterface()->SelectFieldOptionsDidChange(std::move(form));
}
void AutofillDriverInterceptorForTesting::AskForValuesToFill(const ::autofill::FormData& form, const ::autofill::FormFieldData& field, const ::gfx::RectF& bounding_box, int32_t query_id, bool autoselect_first_suggestion, ::autofill::TouchToFillEligible touch_to_fill_eligible) {
  GetForwardingInterface()->AskForValuesToFill(std::move(form), std::move(field), std::move(bounding_box), std::move(query_id), std::move(autoselect_first_suggestion), std::move(touch_to_fill_eligible));
}
void AutofillDriverInterceptorForTesting::HidePopup() {
  GetForwardingInterface()->HidePopup();
}
void AutofillDriverInterceptorForTesting::FocusNoLongerOnForm(bool had_interacted_form) {
  GetForwardingInterface()->FocusNoLongerOnForm(std::move(had_interacted_form));
}
void AutofillDriverInterceptorForTesting::FocusOnFormField(const ::autofill::FormData& form, const ::autofill::FormFieldData& field, const ::gfx::RectF& bounding_box) {
  GetForwardingInterface()->FocusOnFormField(std::move(form), std::move(field), std::move(bounding_box));
}
void AutofillDriverInterceptorForTesting::DidFillAutofillFormData(const ::autofill::FormData& form, ::base::TimeTicks timestamp) {
  GetForwardingInterface()->DidFillAutofillFormData(std::move(form), std::move(timestamp));
}
void AutofillDriverInterceptorForTesting::DidPreviewAutofillFormData() {
  GetForwardingInterface()->DidPreviewAutofillFormData();
}
void AutofillDriverInterceptorForTesting::DidEndTextFieldEditing() {
  GetForwardingInterface()->DidEndTextFieldEditing();
}
void AutofillDriverInterceptorForTesting::JavaScriptChangedAutofilledValue(const ::autofill::FormData& form, const ::autofill::FormFieldData& field, const ::std::u16string& old_value) {
  GetForwardingInterface()->JavaScriptChangedAutofilledValue(std::move(form), std::move(field), std::move(old_value));
}
AutofillDriverAsyncWaiter::AutofillDriverAsyncWaiter(
    AutofillDriver* proxy) : proxy_(proxy) {}

AutofillDriverAsyncWaiter::~AutofillDriverAsyncWaiter() = default;




void PasswordManagerDriverInterceptorForTesting::PasswordFormsParsed(const std::vector<::autofill::FormData>& forms_data) {
  GetForwardingInterface()->PasswordFormsParsed(std::move(forms_data));
}
void PasswordManagerDriverInterceptorForTesting::PasswordFormsRendered(const std::vector<::autofill::FormData>& visible_forms_data) {
  GetForwardingInterface()->PasswordFormsRendered(std::move(visible_forms_data));
}
void PasswordManagerDriverInterceptorForTesting::PasswordFormSubmitted(const ::autofill::FormData& form_data) {
  GetForwardingInterface()->PasswordFormSubmitted(std::move(form_data));
}
void PasswordManagerDriverInterceptorForTesting::InformAboutUserInput(const ::autofill::FormData& form_data) {
  GetForwardingInterface()->InformAboutUserInput(std::move(form_data));
}
void PasswordManagerDriverInterceptorForTesting::DynamicFormSubmission(::autofill::mojom::SubmissionIndicatorEvent submission_indication_event) {
  GetForwardingInterface()->DynamicFormSubmission(std::move(submission_indication_event));
}
void PasswordManagerDriverInterceptorForTesting::PasswordFormCleared(const ::autofill::FormData& form_data) {
  GetForwardingInterface()->PasswordFormCleared(std::move(form_data));
}
void PasswordManagerDriverInterceptorForTesting::RecordSavePasswordProgress(const std::string& log) {
  GetForwardingInterface()->RecordSavePasswordProgress(std::move(log));
}
void PasswordManagerDriverInterceptorForTesting::UserModifiedPasswordField() {
  GetForwardingInterface()->UserModifiedPasswordField();
}
void PasswordManagerDriverInterceptorForTesting::UserModifiedNonPasswordField(::autofill::FieldRendererId renderer_id, const ::std::u16string& field_name, const ::std::u16string& value) {
  GetForwardingInterface()->UserModifiedNonPasswordField(std::move(renderer_id), std::move(field_name), std::move(value));
}
void PasswordManagerDriverInterceptorForTesting::ShowPasswordSuggestions(::base::i18n::TextDirection text_direction, const ::std::u16string& typed_username, int32_t options, const ::gfx::RectF& bounds) {
  GetForwardingInterface()->ShowPasswordSuggestions(std::move(text_direction), std::move(typed_username), std::move(options), std::move(bounds));
}
void PasswordManagerDriverInterceptorForTesting::ShowTouchToFill(::autofill::mojom::SubmissionReadinessState submission_readiness) {
  GetForwardingInterface()->ShowTouchToFill(std::move(submission_readiness));
}
void PasswordManagerDriverInterceptorForTesting::CheckSafeBrowsingReputation(const ::GURL& form_action, const ::GURL& frame_url) {
  GetForwardingInterface()->CheckSafeBrowsingReputation(std::move(form_action), std::move(frame_url));
}
void PasswordManagerDriverInterceptorForTesting::FocusedInputChanged(::autofill::FieldRendererId focused_field_id, ::autofill::mojom::FocusedFieldType focused_field_type) {
  GetForwardingInterface()->FocusedInputChanged(std::move(focused_field_id), std::move(focused_field_type));
}
void PasswordManagerDriverInterceptorForTesting::LogFirstFillingResult(::autofill::FormRendererId form_renderer_id, int32_t result) {
  GetForwardingInterface()->LogFirstFillingResult(std::move(form_renderer_id), std::move(result));
}
PasswordManagerDriverAsyncWaiter::PasswordManagerDriverAsyncWaiter(
    PasswordManagerDriver* proxy) : proxy_(proxy) {}

PasswordManagerDriverAsyncWaiter::~PasswordManagerDriverAsyncWaiter() = default;




void PasswordGenerationDriverInterceptorForTesting::AutomaticGenerationAvailable(const ::autofill::password_generation::PasswordGenerationUIData& password_generation_ui_data) {
  GetForwardingInterface()->AutomaticGenerationAvailable(std::move(password_generation_ui_data));
}
void PasswordGenerationDriverInterceptorForTesting::ShowPasswordEditingPopup(const ::gfx::RectF& bounds, const ::autofill::FormData& form_data, ::autofill::FieldRendererId field_renderer_id, const ::std::u16string& password_value) {
  GetForwardingInterface()->ShowPasswordEditingPopup(std::move(bounds), std::move(form_data), std::move(field_renderer_id), std::move(password_value));
}
void PasswordGenerationDriverInterceptorForTesting::PasswordGenerationRejectedByTyping() {
  GetForwardingInterface()->PasswordGenerationRejectedByTyping();
}
void PasswordGenerationDriverInterceptorForTesting::PresaveGeneratedPassword(const ::autofill::FormData& form_data, const ::std::u16string& password_value) {
  GetForwardingInterface()->PresaveGeneratedPassword(std::move(form_data), std::move(password_value));
}
void PasswordGenerationDriverInterceptorForTesting::PasswordNoLongerGenerated(const ::autofill::FormData& form_data) {
  GetForwardingInterface()->PasswordNoLongerGenerated(std::move(form_data));
}
void PasswordGenerationDriverInterceptorForTesting::FrameWasScrolled() {
  GetForwardingInterface()->FrameWasScrolled();
}
void PasswordGenerationDriverInterceptorForTesting::GenerationElementLostFocus() {
  GetForwardingInterface()->GenerationElementLostFocus();
}
PasswordGenerationDriverAsyncWaiter::PasswordGenerationDriverAsyncWaiter(
    PasswordGenerationDriver* proxy) : proxy_(proxy) {}

PasswordGenerationDriverAsyncWaiter::~PasswordGenerationDriverAsyncWaiter() = default;






}  // namespace mojom
}  // namespace autofill


#if defined(__clang__)
#pragma clang diagnostic pop
#endif