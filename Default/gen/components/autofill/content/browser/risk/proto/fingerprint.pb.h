// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: fingerprint.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_fingerprint_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_fingerprint_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3020000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3020000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_fingerprint_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_fingerprint_2eproto {
  static const uint32_t offsets[];
};
namespace autofill {
namespace risk {
class Fingerprint;
struct FingerprintDefaultTypeInternal;
extern FingerprintDefaultTypeInternal _Fingerprint_default_instance_;
class Fingerprint_Dimension;
struct Fingerprint_DimensionDefaultTypeInternal;
extern Fingerprint_DimensionDefaultTypeInternal _Fingerprint_Dimension_default_instance_;
class Fingerprint_MachineCharacteristics;
struct Fingerprint_MachineCharacteristicsDefaultTypeInternal;
extern Fingerprint_MachineCharacteristicsDefaultTypeInternal _Fingerprint_MachineCharacteristics_default_instance_;
class Fingerprint_MachineCharacteristics_Cpu;
struct Fingerprint_MachineCharacteristics_CpuDefaultTypeInternal;
extern Fingerprint_MachineCharacteristics_CpuDefaultTypeInternal _Fingerprint_MachineCharacteristics_Cpu_default_instance_;
class Fingerprint_MachineCharacteristics_Graphics;
struct Fingerprint_MachineCharacteristics_GraphicsDefaultTypeInternal;
extern Fingerprint_MachineCharacteristics_GraphicsDefaultTypeInternal _Fingerprint_MachineCharacteristics_Graphics_default_instance_;
class Fingerprint_MachineCharacteristics_Plugin;
struct Fingerprint_MachineCharacteristics_PluginDefaultTypeInternal;
extern Fingerprint_MachineCharacteristics_PluginDefaultTypeInternal _Fingerprint_MachineCharacteristics_Plugin_default_instance_;
class Fingerprint_Metadata;
struct Fingerprint_MetadataDefaultTypeInternal;
extern Fingerprint_MetadataDefaultTypeInternal _Fingerprint_Metadata_default_instance_;
class Fingerprint_Performance;
struct Fingerprint_PerformanceDefaultTypeInternal;
extern Fingerprint_PerformanceDefaultTypeInternal _Fingerprint_Performance_default_instance_;
class Fingerprint_TransientState;
struct Fingerprint_TransientStateDefaultTypeInternal;
extern Fingerprint_TransientStateDefaultTypeInternal _Fingerprint_TransientState_default_instance_;
class Fingerprint_UserCharacteristics;
struct Fingerprint_UserCharacteristicsDefaultTypeInternal;
extern Fingerprint_UserCharacteristicsDefaultTypeInternal _Fingerprint_UserCharacteristics_default_instance_;
class Fingerprint_UserCharacteristics_Location;
struct Fingerprint_UserCharacteristics_LocationDefaultTypeInternal;
extern Fingerprint_UserCharacteristics_LocationDefaultTypeInternal _Fingerprint_UserCharacteristics_Location_default_instance_;
class Fingerprint_UserCharacteristics_Vector;
struct Fingerprint_UserCharacteristics_VectorDefaultTypeInternal;
extern Fingerprint_UserCharacteristics_VectorDefaultTypeInternal _Fingerprint_UserCharacteristics_Vector_default_instance_;
}  // namespace risk
}  // namespace autofill
PROTOBUF_NAMESPACE_OPEN
template<> ::autofill::risk::Fingerprint* Arena::CreateMaybeMessage<::autofill::risk::Fingerprint>(Arena*);
template<> ::autofill::risk::Fingerprint_Dimension* Arena::CreateMaybeMessage<::autofill::risk::Fingerprint_Dimension>(Arena*);
template<> ::autofill::risk::Fingerprint_MachineCharacteristics* Arena::CreateMaybeMessage<::autofill::risk::Fingerprint_MachineCharacteristics>(Arena*);
template<> ::autofill::risk::Fingerprint_MachineCharacteristics_Cpu* Arena::CreateMaybeMessage<::autofill::risk::Fingerprint_MachineCharacteristics_Cpu>(Arena*);
template<> ::autofill::risk::Fingerprint_MachineCharacteristics_Graphics* Arena::CreateMaybeMessage<::autofill::risk::Fingerprint_MachineCharacteristics_Graphics>(Arena*);
template<> ::autofill::risk::Fingerprint_MachineCharacteristics_Plugin* Arena::CreateMaybeMessage<::autofill::risk::Fingerprint_MachineCharacteristics_Plugin>(Arena*);
template<> ::autofill::risk::Fingerprint_Metadata* Arena::CreateMaybeMessage<::autofill::risk::Fingerprint_Metadata>(Arena*);
template<> ::autofill::risk::Fingerprint_Performance* Arena::CreateMaybeMessage<::autofill::risk::Fingerprint_Performance>(Arena*);
template<> ::autofill::risk::Fingerprint_TransientState* Arena::CreateMaybeMessage<::autofill::risk::Fingerprint_TransientState>(Arena*);
template<> ::autofill::risk::Fingerprint_UserCharacteristics* Arena::CreateMaybeMessage<::autofill::risk::Fingerprint_UserCharacteristics>(Arena*);
template<> ::autofill::risk::Fingerprint_UserCharacteristics_Location* Arena::CreateMaybeMessage<::autofill::risk::Fingerprint_UserCharacteristics_Location>(Arena*);
template<> ::autofill::risk::Fingerprint_UserCharacteristics_Vector* Arena::CreateMaybeMessage<::autofill::risk::Fingerprint_UserCharacteristics_Vector>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace autofill {
namespace risk {

enum Fingerprint_MachineCharacteristics_BrowserFeature : int {
  Fingerprint_MachineCharacteristics_BrowserFeature_FEATURE_UNKNOWN = 0,
  Fingerprint_MachineCharacteristics_BrowserFeature_DEPRECATED_FEATURE_AUTOCHECKOUT = 1,
  Fingerprint_MachineCharacteristics_BrowserFeature_FEATURE_REQUEST_AUTOCOMPLETE = 2
};
bool Fingerprint_MachineCharacteristics_BrowserFeature_IsValid(int value);
constexpr Fingerprint_MachineCharacteristics_BrowserFeature Fingerprint_MachineCharacteristics_BrowserFeature_BrowserFeature_MIN = Fingerprint_MachineCharacteristics_BrowserFeature_FEATURE_UNKNOWN;
constexpr Fingerprint_MachineCharacteristics_BrowserFeature Fingerprint_MachineCharacteristics_BrowserFeature_BrowserFeature_MAX = Fingerprint_MachineCharacteristics_BrowserFeature_FEATURE_REQUEST_AUTOCOMPLETE;
constexpr int Fingerprint_MachineCharacteristics_BrowserFeature_BrowserFeature_ARRAYSIZE = Fingerprint_MachineCharacteristics_BrowserFeature_BrowserFeature_MAX + 1;

const std::string& Fingerprint_MachineCharacteristics_BrowserFeature_Name(Fingerprint_MachineCharacteristics_BrowserFeature value);
template<typename T>
inline const std::string& Fingerprint_MachineCharacteristics_BrowserFeature_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Fingerprint_MachineCharacteristics_BrowserFeature>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Fingerprint_MachineCharacteristics_BrowserFeature_Name.");
  return Fingerprint_MachineCharacteristics_BrowserFeature_Name(static_cast<Fingerprint_MachineCharacteristics_BrowserFeature>(enum_t_value));
}
bool Fingerprint_MachineCharacteristics_BrowserFeature_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Fingerprint_MachineCharacteristics_BrowserFeature* value);
// ===================================================================

class Fingerprint_Dimension final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill.risk.Fingerprint.Dimension) */ {
 public:
  inline Fingerprint_Dimension() : Fingerprint_Dimension(nullptr) {}
  ~Fingerprint_Dimension() override;
  explicit PROTOBUF_CONSTEXPR Fingerprint_Dimension(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Fingerprint_Dimension(const Fingerprint_Dimension& from);
  Fingerprint_Dimension(Fingerprint_Dimension&& from) noexcept
    : Fingerprint_Dimension() {
    *this = ::std::move(from);
  }

  inline Fingerprint_Dimension& operator=(const Fingerprint_Dimension& from) {
    CopyFrom(from);
    return *this;
  }
  inline Fingerprint_Dimension& operator=(Fingerprint_Dimension&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const Fingerprint_Dimension& default_instance() {
    return *internal_default_instance();
  }
  static inline const Fingerprint_Dimension* internal_default_instance() {
    return reinterpret_cast<const Fingerprint_Dimension*>(
               &_Fingerprint_Dimension_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Fingerprint_Dimension& a, Fingerprint_Dimension& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(Fingerprint_Dimension* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Fingerprint_Dimension* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Fingerprint_Dimension* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Fingerprint_Dimension>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Fingerprint_Dimension& from);
  void MergeFrom(const Fingerprint_Dimension& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Fingerprint_Dimension* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill.risk.Fingerprint.Dimension";
  }
  protected:
  explicit Fingerprint_Dimension(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWidthFieldNumber = 1,
    kHeightFieldNumber = 2,
  };
  // optional int32 width = 1;
  bool has_width() const;
  private:
  bool _internal_has_width() const;
  public:
  void clear_width();
  int32_t width() const;
  void set_width(int32_t value);
  private:
  int32_t _internal_width() const;
  void _internal_set_width(int32_t value);
  public:

  // optional int32 height = 2;
  bool has_height() const;
  private:
  bool _internal_has_height() const;
  public:
  void clear_height();
  int32_t height() const;
  void set_height(int32_t value);
  private:
  int32_t _internal_height() const;
  void _internal_set_height(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:autofill.risk.Fingerprint.Dimension)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int32_t width_;
  int32_t height_;
  friend struct ::TableStruct_fingerprint_2eproto;
};
// -------------------------------------------------------------------

class Fingerprint_MachineCharacteristics_Plugin final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill.risk.Fingerprint.MachineCharacteristics.Plugin) */ {
 public:
  inline Fingerprint_MachineCharacteristics_Plugin() : Fingerprint_MachineCharacteristics_Plugin(nullptr) {}
  ~Fingerprint_MachineCharacteristics_Plugin() override;
  explicit PROTOBUF_CONSTEXPR Fingerprint_MachineCharacteristics_Plugin(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Fingerprint_MachineCharacteristics_Plugin(const Fingerprint_MachineCharacteristics_Plugin& from);
  Fingerprint_MachineCharacteristics_Plugin(Fingerprint_MachineCharacteristics_Plugin&& from) noexcept
    : Fingerprint_MachineCharacteristics_Plugin() {
    *this = ::std::move(from);
  }

  inline Fingerprint_MachineCharacteristics_Plugin& operator=(const Fingerprint_MachineCharacteristics_Plugin& from) {
    CopyFrom(from);
    return *this;
  }
  inline Fingerprint_MachineCharacteristics_Plugin& operator=(Fingerprint_MachineCharacteristics_Plugin&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const Fingerprint_MachineCharacteristics_Plugin& default_instance() {
    return *internal_default_instance();
  }
  static inline const Fingerprint_MachineCharacteristics_Plugin* internal_default_instance() {
    return reinterpret_cast<const Fingerprint_MachineCharacteristics_Plugin*>(
               &_Fingerprint_MachineCharacteristics_Plugin_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Fingerprint_MachineCharacteristics_Plugin& a, Fingerprint_MachineCharacteristics_Plugin& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(Fingerprint_MachineCharacteristics_Plugin* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Fingerprint_MachineCharacteristics_Plugin* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Fingerprint_MachineCharacteristics_Plugin* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Fingerprint_MachineCharacteristics_Plugin>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Fingerprint_MachineCharacteristics_Plugin& from);
  void MergeFrom(const Fingerprint_MachineCharacteristics_Plugin& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Fingerprint_MachineCharacteristics_Plugin* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill.risk.Fingerprint.MachineCharacteristics.Plugin";
  }
  protected:
  explicit Fingerprint_MachineCharacteristics_Plugin(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMimeTypeFieldNumber = 3,
    kNameFieldNumber = 1,
    kDescriptionFieldNumber = 2,
    kVersionFieldNumber = 4,
  };
  // repeated string mime_type = 3;
  int mime_type_size() const;
  private:
  int _internal_mime_type_size() const;
  public:
  void clear_mime_type();
  const std::string& mime_type(int index) const;
  std::string* mutable_mime_type(int index);
  void set_mime_type(int index, const std::string& value);
  void set_mime_type(int index, std::string&& value);
  void set_mime_type(int index, const char* value);
  void set_mime_type(int index, const char* value, size_t size);
  std::string* add_mime_type();
  void add_mime_type(const std::string& value);
  void add_mime_type(std::string&& value);
  void add_mime_type(const char* value);
  void add_mime_type(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& mime_type() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_mime_type();
  private:
  const std::string& _internal_mime_type(int index) const;
  std::string* _internal_add_mime_type();
  public:

  // optional string name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional string description = 2;
  bool has_description() const;
  private:
  bool _internal_has_description() const;
  public:
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // optional string version = 4;
  bool has_version() const;
  private:
  bool _internal_has_version() const;
  public:
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // @@protoc_insertion_point(class_scope:autofill.risk.Fingerprint.MachineCharacteristics.Plugin)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> mime_type_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
  friend struct ::TableStruct_fingerprint_2eproto;
};
// -------------------------------------------------------------------

class Fingerprint_MachineCharacteristics_Cpu final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill.risk.Fingerprint.MachineCharacteristics.Cpu) */ {
 public:
  inline Fingerprint_MachineCharacteristics_Cpu() : Fingerprint_MachineCharacteristics_Cpu(nullptr) {}
  ~Fingerprint_MachineCharacteristics_Cpu() override;
  explicit PROTOBUF_CONSTEXPR Fingerprint_MachineCharacteristics_Cpu(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Fingerprint_MachineCharacteristics_Cpu(const Fingerprint_MachineCharacteristics_Cpu& from);
  Fingerprint_MachineCharacteristics_Cpu(Fingerprint_MachineCharacteristics_Cpu&& from) noexcept
    : Fingerprint_MachineCharacteristics_Cpu() {
    *this = ::std::move(from);
  }

  inline Fingerprint_MachineCharacteristics_Cpu& operator=(const Fingerprint_MachineCharacteristics_Cpu& from) {
    CopyFrom(from);
    return *this;
  }
  inline Fingerprint_MachineCharacteristics_Cpu& operator=(Fingerprint_MachineCharacteristics_Cpu&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const Fingerprint_MachineCharacteristics_Cpu& default_instance() {
    return *internal_default_instance();
  }
  static inline const Fingerprint_MachineCharacteristics_Cpu* internal_default_instance() {
    return reinterpret_cast<const Fingerprint_MachineCharacteristics_Cpu*>(
               &_Fingerprint_MachineCharacteristics_Cpu_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Fingerprint_MachineCharacteristics_Cpu& a, Fingerprint_MachineCharacteristics_Cpu& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(Fingerprint_MachineCharacteristics_Cpu* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Fingerprint_MachineCharacteristics_Cpu* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Fingerprint_MachineCharacteristics_Cpu* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Fingerprint_MachineCharacteristics_Cpu>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Fingerprint_MachineCharacteristics_Cpu& from);
  void MergeFrom(const Fingerprint_MachineCharacteristics_Cpu& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Fingerprint_MachineCharacteristics_Cpu* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill.risk.Fingerprint.MachineCharacteristics.Cpu";
  }
  protected:
  explicit Fingerprint_MachineCharacteristics_Cpu(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVendorNameFieldNumber = 1,
    kBrandFieldNumber = 2,
  };
  // optional string vendor_name = 1;
  bool has_vendor_name() const;
  private:
  bool _internal_has_vendor_name() const;
  public:
  void clear_vendor_name();
  const std::string& vendor_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_vendor_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_vendor_name();
  PROTOBUF_NODISCARD std::string* release_vendor_name();
  void set_allocated_vendor_name(std::string* vendor_name);
  private:
  const std::string& _internal_vendor_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_vendor_name(const std::string& value);
  std::string* _internal_mutable_vendor_name();
  public:

  // optional string brand = 2;
  bool has_brand() const;
  private:
  bool _internal_has_brand() const;
  public:
  void clear_brand();
  const std::string& brand() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_brand(ArgT0&& arg0, ArgT... args);
  std::string* mutable_brand();
  PROTOBUF_NODISCARD std::string* release_brand();
  void set_allocated_brand(std::string* brand);
  private:
  const std::string& _internal_brand() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_brand(const std::string& value);
  std::string* _internal_mutable_brand();
  public:

  // @@protoc_insertion_point(class_scope:autofill.risk.Fingerprint.MachineCharacteristics.Cpu)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr vendor_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr brand_;
  friend struct ::TableStruct_fingerprint_2eproto;
};
// -------------------------------------------------------------------

class Fingerprint_MachineCharacteristics_Graphics final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill.risk.Fingerprint.MachineCharacteristics.Graphics) */ {
 public:
  inline Fingerprint_MachineCharacteristics_Graphics() : Fingerprint_MachineCharacteristics_Graphics(nullptr) {}
  ~Fingerprint_MachineCharacteristics_Graphics() override;
  explicit PROTOBUF_CONSTEXPR Fingerprint_MachineCharacteristics_Graphics(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Fingerprint_MachineCharacteristics_Graphics(const Fingerprint_MachineCharacteristics_Graphics& from);
  Fingerprint_MachineCharacteristics_Graphics(Fingerprint_MachineCharacteristics_Graphics&& from) noexcept
    : Fingerprint_MachineCharacteristics_Graphics() {
    *this = ::std::move(from);
  }

  inline Fingerprint_MachineCharacteristics_Graphics& operator=(const Fingerprint_MachineCharacteristics_Graphics& from) {
    CopyFrom(from);
    return *this;
  }
  inline Fingerprint_MachineCharacteristics_Graphics& operator=(Fingerprint_MachineCharacteristics_Graphics&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const Fingerprint_MachineCharacteristics_Graphics& default_instance() {
    return *internal_default_instance();
  }
  static inline const Fingerprint_MachineCharacteristics_Graphics* internal_default_instance() {
    return reinterpret_cast<const Fingerprint_MachineCharacteristics_Graphics*>(
               &_Fingerprint_MachineCharacteristics_Graphics_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Fingerprint_MachineCharacteristics_Graphics& a, Fingerprint_MachineCharacteristics_Graphics& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(Fingerprint_MachineCharacteristics_Graphics* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Fingerprint_MachineCharacteristics_Graphics* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Fingerprint_MachineCharacteristics_Graphics* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Fingerprint_MachineCharacteristics_Graphics>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Fingerprint_MachineCharacteristics_Graphics& from);
  void MergeFrom(const Fingerprint_MachineCharacteristics_Graphics& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Fingerprint_MachineCharacteristics_Graphics* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill.risk.Fingerprint.MachineCharacteristics.Graphics";
  }
  protected:
  explicit Fingerprint_MachineCharacteristics_Graphics(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDriverVersionFieldNumber = 3,
    kDriverDateFieldNumber = 4,
    kVendorIdFieldNumber = 1,
    kDeviceIdFieldNumber = 2,
  };
  // optional string driver_version = 3;
  bool has_driver_version() const;
  private:
  bool _internal_has_driver_version() const;
  public:
  void clear_driver_version();
  const std::string& driver_version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_driver_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_driver_version();
  PROTOBUF_NODISCARD std::string* release_driver_version();
  void set_allocated_driver_version(std::string* driver_version);
  private:
  const std::string& _internal_driver_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_driver_version(const std::string& value);
  std::string* _internal_mutable_driver_version();
  public:

  // optional string driver_date = 4;
  bool has_driver_date() const;
  private:
  bool _internal_has_driver_date() const;
  public:
  void clear_driver_date();
  const std::string& driver_date() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_driver_date(ArgT0&& arg0, ArgT... args);
  std::string* mutable_driver_date();
  PROTOBUF_NODISCARD std::string* release_driver_date();
  void set_allocated_driver_date(std::string* driver_date);
  private:
  const std::string& _internal_driver_date() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_driver_date(const std::string& value);
  std::string* _internal_mutable_driver_date();
  public:

  // optional uint32 vendor_id = 1;
  bool has_vendor_id() const;
  private:
  bool _internal_has_vendor_id() const;
  public:
  void clear_vendor_id();
  uint32_t vendor_id() const;
  void set_vendor_id(uint32_t value);
  private:
  uint32_t _internal_vendor_id() const;
  void _internal_set_vendor_id(uint32_t value);
  public:

  // optional uint32 device_id = 2;
  bool has_device_id() const;
  private:
  bool _internal_has_device_id() const;
  public:
  void clear_device_id();
  uint32_t device_id() const;
  void set_device_id(uint32_t value);
  private:
  uint32_t _internal_device_id() const;
  void _internal_set_device_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:autofill.risk.Fingerprint.MachineCharacteristics.Graphics)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr driver_version_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr driver_date_;
  uint32_t vendor_id_;
  uint32_t device_id_;
  friend struct ::TableStruct_fingerprint_2eproto;
};
// -------------------------------------------------------------------

class Fingerprint_MachineCharacteristics final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill.risk.Fingerprint.MachineCharacteristics) */ {
 public:
  inline Fingerprint_MachineCharacteristics() : Fingerprint_MachineCharacteristics(nullptr) {}
  ~Fingerprint_MachineCharacteristics() override;
  explicit PROTOBUF_CONSTEXPR Fingerprint_MachineCharacteristics(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Fingerprint_MachineCharacteristics(const Fingerprint_MachineCharacteristics& from);
  Fingerprint_MachineCharacteristics(Fingerprint_MachineCharacteristics&& from) noexcept
    : Fingerprint_MachineCharacteristics() {
    *this = ::std::move(from);
  }

  inline Fingerprint_MachineCharacteristics& operator=(const Fingerprint_MachineCharacteristics& from) {
    CopyFrom(from);
    return *this;
  }
  inline Fingerprint_MachineCharacteristics& operator=(Fingerprint_MachineCharacteristics&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const Fingerprint_MachineCharacteristics& default_instance() {
    return *internal_default_instance();
  }
  static inline const Fingerprint_MachineCharacteristics* internal_default_instance() {
    return reinterpret_cast<const Fingerprint_MachineCharacteristics*>(
               &_Fingerprint_MachineCharacteristics_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Fingerprint_MachineCharacteristics& a, Fingerprint_MachineCharacteristics& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(Fingerprint_MachineCharacteristics* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Fingerprint_MachineCharacteristics* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Fingerprint_MachineCharacteristics* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Fingerprint_MachineCharacteristics>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Fingerprint_MachineCharacteristics& from);
  void MergeFrom(const Fingerprint_MachineCharacteristics& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Fingerprint_MachineCharacteristics* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill.risk.Fingerprint.MachineCharacteristics";
  }
  protected:
  explicit Fingerprint_MachineCharacteristics(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef Fingerprint_MachineCharacteristics_Plugin Plugin;
  typedef Fingerprint_MachineCharacteristics_Cpu Cpu;
  typedef Fingerprint_MachineCharacteristics_Graphics Graphics;

  typedef Fingerprint_MachineCharacteristics_BrowserFeature BrowserFeature;
  static constexpr BrowserFeature FEATURE_UNKNOWN =
    Fingerprint_MachineCharacteristics_BrowserFeature_FEATURE_UNKNOWN;
  static constexpr BrowserFeature DEPRECATED_FEATURE_AUTOCHECKOUT =
    Fingerprint_MachineCharacteristics_BrowserFeature_DEPRECATED_FEATURE_AUTOCHECKOUT;
  static constexpr BrowserFeature FEATURE_REQUEST_AUTOCOMPLETE =
    Fingerprint_MachineCharacteristics_BrowserFeature_FEATURE_REQUEST_AUTOCOMPLETE;
  static inline bool BrowserFeature_IsValid(int value) {
    return Fingerprint_MachineCharacteristics_BrowserFeature_IsValid(value);
  }
  static constexpr BrowserFeature BrowserFeature_MIN =
    Fingerprint_MachineCharacteristics_BrowserFeature_BrowserFeature_MIN;
  static constexpr BrowserFeature BrowserFeature_MAX =
    Fingerprint_MachineCharacteristics_BrowserFeature_BrowserFeature_MAX;
  static constexpr int BrowserFeature_ARRAYSIZE =
    Fingerprint_MachineCharacteristics_BrowserFeature_BrowserFeature_ARRAYSIZE;
  template<typename T>
  static inline const std::string& BrowserFeature_Name(T enum_t_value) {
    static_assert(::std::is_same<T, BrowserFeature>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function BrowserFeature_Name.");
    return Fingerprint_MachineCharacteristics_BrowserFeature_Name(enum_t_value);
  }
  static inline bool BrowserFeature_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      BrowserFeature* value) {
    return Fingerprint_MachineCharacteristics_BrowserFeature_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kFontFieldNumber = 4,
    kPluginFieldNumber = 5,
    kRequestedLanguageFieldNumber = 8,
    kPartitionSizeFieldNumber = 15,
    kOperatingSystemBuildFieldNumber = 2,
    kBrowserLanguageFieldNumber = 7,
    kCharsetFieldNumber = 9,
    kUserAgentFieldNumber = 14,
    kBrowserBuildFieldNumber = 19,
    kScreenSizeFieldNumber = 11,
    kUnavailableScreenSizeFieldNumber = 13,
    kCpuFieldNumber = 16,
    kGraphicsCardFieldNumber = 18,
    kUserAndDeviceNameHashFieldNumber = 1,
    kBrowserInstallTimeHoursFieldNumber = 3,
    kUtcOffsetMsFieldNumber = 6,
    kScreenCountFieldNumber = 10,
    kScreenColorDepthFieldNumber = 12,
    kRamFieldNumber = 17,
    kBrowserFeatureFieldNumber = 20,
  };
  // repeated string font = 4;
  int font_size() const;
  private:
  int _internal_font_size() const;
  public:
  void clear_font();
  const std::string& font(int index) const;
  std::string* mutable_font(int index);
  void set_font(int index, const std::string& value);
  void set_font(int index, std::string&& value);
  void set_font(int index, const char* value);
  void set_font(int index, const char* value, size_t size);
  std::string* add_font();
  void add_font(const std::string& value);
  void add_font(std::string&& value);
  void add_font(const char* value);
  void add_font(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& font() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_font();
  private:
  const std::string& _internal_font(int index) const;
  std::string* _internal_add_font();
  public:

  // repeated .autofill.risk.Fingerprint.MachineCharacteristics.Plugin plugin = 5;
  int plugin_size() const;
  private:
  int _internal_plugin_size() const;
  public:
  void clear_plugin();
  ::autofill::risk::Fingerprint_MachineCharacteristics_Plugin* mutable_plugin(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill::risk::Fingerprint_MachineCharacteristics_Plugin >*
      mutable_plugin();
  private:
  const ::autofill::risk::Fingerprint_MachineCharacteristics_Plugin& _internal_plugin(int index) const;
  ::autofill::risk::Fingerprint_MachineCharacteristics_Plugin* _internal_add_plugin();
  public:
  const ::autofill::risk::Fingerprint_MachineCharacteristics_Plugin& plugin(int index) const;
  ::autofill::risk::Fingerprint_MachineCharacteristics_Plugin* add_plugin();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill::risk::Fingerprint_MachineCharacteristics_Plugin >&
      plugin() const;

  // repeated string requested_language = 8;
  int requested_language_size() const;
  private:
  int _internal_requested_language_size() const;
  public:
  void clear_requested_language();
  const std::string& requested_language(int index) const;
  std::string* mutable_requested_language(int index);
  void set_requested_language(int index, const std::string& value);
  void set_requested_language(int index, std::string&& value);
  void set_requested_language(int index, const char* value);
  void set_requested_language(int index, const char* value, size_t size);
  std::string* add_requested_language();
  void add_requested_language(const std::string& value);
  void add_requested_language(std::string&& value);
  void add_requested_language(const char* value);
  void add_requested_language(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& requested_language() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_requested_language();
  private:
  const std::string& _internal_requested_language(int index) const;
  std::string* _internal_add_requested_language();
  public:

  // repeated int32 partition_size = 15;
  int partition_size_size() const;
  private:
  int _internal_partition_size_size() const;
  public:
  void clear_partition_size();
  private:
  int32_t _internal_partition_size(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_partition_size() const;
  void _internal_add_partition_size(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_partition_size();
  public:
  int32_t partition_size(int index) const;
  void set_partition_size(int index, int32_t value);
  void add_partition_size(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      partition_size() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_partition_size();

  // optional string operating_system_build = 2;
  bool has_operating_system_build() const;
  private:
  bool _internal_has_operating_system_build() const;
  public:
  void clear_operating_system_build();
  const std::string& operating_system_build() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_operating_system_build(ArgT0&& arg0, ArgT... args);
  std::string* mutable_operating_system_build();
  PROTOBUF_NODISCARD std::string* release_operating_system_build();
  void set_allocated_operating_system_build(std::string* operating_system_build);
  private:
  const std::string& _internal_operating_system_build() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_operating_system_build(const std::string& value);
  std::string* _internal_mutable_operating_system_build();
  public:

  // optional string browser_language = 7;
  bool has_browser_language() const;
  private:
  bool _internal_has_browser_language() const;
  public:
  void clear_browser_language();
  const std::string& browser_language() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_browser_language(ArgT0&& arg0, ArgT... args);
  std::string* mutable_browser_language();
  PROTOBUF_NODISCARD std::string* release_browser_language();
  void set_allocated_browser_language(std::string* browser_language);
  private:
  const std::string& _internal_browser_language() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_browser_language(const std::string& value);
  std::string* _internal_mutable_browser_language();
  public:

  // optional string charset = 9;
  bool has_charset() const;
  private:
  bool _internal_has_charset() const;
  public:
  void clear_charset();
  const std::string& charset() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_charset(ArgT0&& arg0, ArgT... args);
  std::string* mutable_charset();
  PROTOBUF_NODISCARD std::string* release_charset();
  void set_allocated_charset(std::string* charset);
  private:
  const std::string& _internal_charset() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_charset(const std::string& value);
  std::string* _internal_mutable_charset();
  public:

  // optional string user_agent = 14;
  bool has_user_agent() const;
  private:
  bool _internal_has_user_agent() const;
  public:
  void clear_user_agent();
  const std::string& user_agent() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_agent(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_agent();
  PROTOBUF_NODISCARD std::string* release_user_agent();
  void set_allocated_user_agent(std::string* user_agent);
  private:
  const std::string& _internal_user_agent() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_agent(const std::string& value);
  std::string* _internal_mutable_user_agent();
  public:

  // optional string browser_build = 19;
  bool has_browser_build() const;
  private:
  bool _internal_has_browser_build() const;
  public:
  void clear_browser_build();
  const std::string& browser_build() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_browser_build(ArgT0&& arg0, ArgT... args);
  std::string* mutable_browser_build();
  PROTOBUF_NODISCARD std::string* release_browser_build();
  void set_allocated_browser_build(std::string* browser_build);
  private:
  const std::string& _internal_browser_build() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_browser_build(const std::string& value);
  std::string* _internal_mutable_browser_build();
  public:

  // optional .autofill.risk.Fingerprint.Dimension screen_size = 11;
  bool has_screen_size() const;
  private:
  bool _internal_has_screen_size() const;
  public:
  void clear_screen_size();
  const ::autofill::risk::Fingerprint_Dimension& screen_size() const;
  PROTOBUF_NODISCARD ::autofill::risk::Fingerprint_Dimension* release_screen_size();
  ::autofill::risk::Fingerprint_Dimension* mutable_screen_size();
  void set_allocated_screen_size(::autofill::risk::Fingerprint_Dimension* screen_size);
  private:
  const ::autofill::risk::Fingerprint_Dimension& _internal_screen_size() const;
  ::autofill::risk::Fingerprint_Dimension* _internal_mutable_screen_size();
  public:
  void unsafe_arena_set_allocated_screen_size(
      ::autofill::risk::Fingerprint_Dimension* screen_size);
  ::autofill::risk::Fingerprint_Dimension* unsafe_arena_release_screen_size();

  // optional .autofill.risk.Fingerprint.Dimension unavailable_screen_size = 13;
  bool has_unavailable_screen_size() const;
  private:
  bool _internal_has_unavailable_screen_size() const;
  public:
  void clear_unavailable_screen_size();
  const ::autofill::risk::Fingerprint_Dimension& unavailable_screen_size() const;
  PROTOBUF_NODISCARD ::autofill::risk::Fingerprint_Dimension* release_unavailable_screen_size();
  ::autofill::risk::Fingerprint_Dimension* mutable_unavailable_screen_size();
  void set_allocated_unavailable_screen_size(::autofill::risk::Fingerprint_Dimension* unavailable_screen_size);
  private:
  const ::autofill::risk::Fingerprint_Dimension& _internal_unavailable_screen_size() const;
  ::autofill::risk::Fingerprint_Dimension* _internal_mutable_unavailable_screen_size();
  public:
  void unsafe_arena_set_allocated_unavailable_screen_size(
      ::autofill::risk::Fingerprint_Dimension* unavailable_screen_size);
  ::autofill::risk::Fingerprint_Dimension* unsafe_arena_release_unavailable_screen_size();

  // optional .autofill.risk.Fingerprint.MachineCharacteristics.Cpu cpu = 16;
  bool has_cpu() const;
  private:
  bool _internal_has_cpu() const;
  public:
  void clear_cpu();
  const ::autofill::risk::Fingerprint_MachineCharacteristics_Cpu& cpu() const;
  PROTOBUF_NODISCARD ::autofill::risk::Fingerprint_MachineCharacteristics_Cpu* release_cpu();
  ::autofill::risk::Fingerprint_MachineCharacteristics_Cpu* mutable_cpu();
  void set_allocated_cpu(::autofill::risk::Fingerprint_MachineCharacteristics_Cpu* cpu);
  private:
  const ::autofill::risk::Fingerprint_MachineCharacteristics_Cpu& _internal_cpu() const;
  ::autofill::risk::Fingerprint_MachineCharacteristics_Cpu* _internal_mutable_cpu();
  public:
  void unsafe_arena_set_allocated_cpu(
      ::autofill::risk::Fingerprint_MachineCharacteristics_Cpu* cpu);
  ::autofill::risk::Fingerprint_MachineCharacteristics_Cpu* unsafe_arena_release_cpu();

  // optional .autofill.risk.Fingerprint.MachineCharacteristics.Graphics graphics_card = 18;
  bool has_graphics_card() const;
  private:
  bool _internal_has_graphics_card() const;
  public:
  void clear_graphics_card();
  const ::autofill::risk::Fingerprint_MachineCharacteristics_Graphics& graphics_card() const;
  PROTOBUF_NODISCARD ::autofill::risk::Fingerprint_MachineCharacteristics_Graphics* release_graphics_card();
  ::autofill::risk::Fingerprint_MachineCharacteristics_Graphics* mutable_graphics_card();
  void set_allocated_graphics_card(::autofill::risk::Fingerprint_MachineCharacteristics_Graphics* graphics_card);
  private:
  const ::autofill::risk::Fingerprint_MachineCharacteristics_Graphics& _internal_graphics_card() const;
  ::autofill::risk::Fingerprint_MachineCharacteristics_Graphics* _internal_mutable_graphics_card();
  public:
  void unsafe_arena_set_allocated_graphics_card(
      ::autofill::risk::Fingerprint_MachineCharacteristics_Graphics* graphics_card);
  ::autofill::risk::Fingerprint_MachineCharacteristics_Graphics* unsafe_arena_release_graphics_card();

  // optional fixed64 user_and_device_name_hash = 1;
  bool has_user_and_device_name_hash() const;
  private:
  bool _internal_has_user_and_device_name_hash() const;
  public:
  void clear_user_and_device_name_hash();
  uint64_t user_and_device_name_hash() const;
  void set_user_and_device_name_hash(uint64_t value);
  private:
  uint64_t _internal_user_and_device_name_hash() const;
  void _internal_set_user_and_device_name_hash(uint64_t value);
  public:

  // optional int64 browser_install_time_hours = 3;
  bool has_browser_install_time_hours() const;
  private:
  bool _internal_has_browser_install_time_hours() const;
  public:
  void clear_browser_install_time_hours();
  int64_t browser_install_time_hours() const;
  void set_browser_install_time_hours(int64_t value);
  private:
  int64_t _internal_browser_install_time_hours() const;
  void _internal_set_browser_install_time_hours(int64_t value);
  public:

  // optional int64 utc_offset_ms = 6;
  bool has_utc_offset_ms() const;
  private:
  bool _internal_has_utc_offset_ms() const;
  public:
  void clear_utc_offset_ms();
  int64_t utc_offset_ms() const;
  void set_utc_offset_ms(int64_t value);
  private:
  int64_t _internal_utc_offset_ms() const;
  void _internal_set_utc_offset_ms(int64_t value);
  public:

  // optional int32 screen_count = 10;
  bool has_screen_count() const;
  private:
  bool _internal_has_screen_count() const;
  public:
  void clear_screen_count();
  int32_t screen_count() const;
  void set_screen_count(int32_t value);
  private:
  int32_t _internal_screen_count() const;
  void _internal_set_screen_count(int32_t value);
  public:

  // optional int32 screen_color_depth = 12;
  bool has_screen_color_depth() const;
  private:
  bool _internal_has_screen_color_depth() const;
  public:
  void clear_screen_color_depth();
  int32_t screen_color_depth() const;
  void set_screen_color_depth(int32_t value);
  private:
  int32_t _internal_screen_color_depth() const;
  void _internal_set_screen_color_depth(int32_t value);
  public:

  // optional int64 ram = 17;
  bool has_ram() const;
  private:
  bool _internal_has_ram() const;
  public:
  void clear_ram();
  int64_t ram() const;
  void set_ram(int64_t value);
  private:
  int64_t _internal_ram() const;
  void _internal_set_ram(int64_t value);
  public:

  // optional .autofill.risk.Fingerprint.MachineCharacteristics.BrowserFeature browser_feature = 20;
  bool has_browser_feature() const;
  private:
  bool _internal_has_browser_feature() const;
  public:
  void clear_browser_feature();
  ::autofill::risk::Fingerprint_MachineCharacteristics_BrowserFeature browser_feature() const;
  void set_browser_feature(::autofill::risk::Fingerprint_MachineCharacteristics_BrowserFeature value);
  private:
  ::autofill::risk::Fingerprint_MachineCharacteristics_BrowserFeature _internal_browser_feature() const;
  void _internal_set_browser_feature(::autofill::risk::Fingerprint_MachineCharacteristics_BrowserFeature value);
  public:

  // @@protoc_insertion_point(class_scope:autofill.risk.Fingerprint.MachineCharacteristics)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> font_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill::risk::Fingerprint_MachineCharacteristics_Plugin > plugin_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> requested_language_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > partition_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr operating_system_build_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr browser_language_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr charset_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_agent_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr browser_build_;
  ::autofill::risk::Fingerprint_Dimension* screen_size_;
  ::autofill::risk::Fingerprint_Dimension* unavailable_screen_size_;
  ::autofill::risk::Fingerprint_MachineCharacteristics_Cpu* cpu_;
  ::autofill::risk::Fingerprint_MachineCharacteristics_Graphics* graphics_card_;
  uint64_t user_and_device_name_hash_;
  int64_t browser_install_time_hours_;
  int64_t utc_offset_ms_;
  int32_t screen_count_;
  int32_t screen_color_depth_;
  int64_t ram_;
  int browser_feature_;
  friend struct ::TableStruct_fingerprint_2eproto;
};
// -------------------------------------------------------------------

class Fingerprint_TransientState final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill.risk.Fingerprint.TransientState) */ {
 public:
  inline Fingerprint_TransientState() : Fingerprint_TransientState(nullptr) {}
  ~Fingerprint_TransientState() override;
  explicit PROTOBUF_CONSTEXPR Fingerprint_TransientState(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Fingerprint_TransientState(const Fingerprint_TransientState& from);
  Fingerprint_TransientState(Fingerprint_TransientState&& from) noexcept
    : Fingerprint_TransientState() {
    *this = ::std::move(from);
  }

  inline Fingerprint_TransientState& operator=(const Fingerprint_TransientState& from) {
    CopyFrom(from);
    return *this;
  }
  inline Fingerprint_TransientState& operator=(Fingerprint_TransientState&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const Fingerprint_TransientState& default_instance() {
    return *internal_default_instance();
  }
  static inline const Fingerprint_TransientState* internal_default_instance() {
    return reinterpret_cast<const Fingerprint_TransientState*>(
               &_Fingerprint_TransientState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Fingerprint_TransientState& a, Fingerprint_TransientState& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(Fingerprint_TransientState* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Fingerprint_TransientState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Fingerprint_TransientState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Fingerprint_TransientState>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Fingerprint_TransientState& from);
  void MergeFrom(const Fingerprint_TransientState& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Fingerprint_TransientState* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill.risk.Fingerprint.TransientState";
  }
  protected:
  explicit Fingerprint_TransientState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInnerWindowSizeFieldNumber = 1,
    kOuterWindowSizeFieldNumber = 2,
  };
  // optional .autofill.risk.Fingerprint.Dimension inner_window_size = 1;
  bool has_inner_window_size() const;
  private:
  bool _internal_has_inner_window_size() const;
  public:
  void clear_inner_window_size();
  const ::autofill::risk::Fingerprint_Dimension& inner_window_size() const;
  PROTOBUF_NODISCARD ::autofill::risk::Fingerprint_Dimension* release_inner_window_size();
  ::autofill::risk::Fingerprint_Dimension* mutable_inner_window_size();
  void set_allocated_inner_window_size(::autofill::risk::Fingerprint_Dimension* inner_window_size);
  private:
  const ::autofill::risk::Fingerprint_Dimension& _internal_inner_window_size() const;
  ::autofill::risk::Fingerprint_Dimension* _internal_mutable_inner_window_size();
  public:
  void unsafe_arena_set_allocated_inner_window_size(
      ::autofill::risk::Fingerprint_Dimension* inner_window_size);
  ::autofill::risk::Fingerprint_Dimension* unsafe_arena_release_inner_window_size();

  // optional .autofill.risk.Fingerprint.Dimension outer_window_size = 2;
  bool has_outer_window_size() const;
  private:
  bool _internal_has_outer_window_size() const;
  public:
  void clear_outer_window_size();
  const ::autofill::risk::Fingerprint_Dimension& outer_window_size() const;
  PROTOBUF_NODISCARD ::autofill::risk::Fingerprint_Dimension* release_outer_window_size();
  ::autofill::risk::Fingerprint_Dimension* mutable_outer_window_size();
  void set_allocated_outer_window_size(::autofill::risk::Fingerprint_Dimension* outer_window_size);
  private:
  const ::autofill::risk::Fingerprint_Dimension& _internal_outer_window_size() const;
  ::autofill::risk::Fingerprint_Dimension* _internal_mutable_outer_window_size();
  public:
  void unsafe_arena_set_allocated_outer_window_size(
      ::autofill::risk::Fingerprint_Dimension* outer_window_size);
  ::autofill::risk::Fingerprint_Dimension* unsafe_arena_release_outer_window_size();

  // @@protoc_insertion_point(class_scope:autofill.risk.Fingerprint.TransientState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::autofill::risk::Fingerprint_Dimension* inner_window_size_;
  ::autofill::risk::Fingerprint_Dimension* outer_window_size_;
  friend struct ::TableStruct_fingerprint_2eproto;
};
// -------------------------------------------------------------------

class Fingerprint_Performance final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill.risk.Fingerprint.Performance) */ {
 public:
  inline Fingerprint_Performance() : Fingerprint_Performance(nullptr) {}
  ~Fingerprint_Performance() override;
  explicit PROTOBUF_CONSTEXPR Fingerprint_Performance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Fingerprint_Performance(const Fingerprint_Performance& from);
  Fingerprint_Performance(Fingerprint_Performance&& from) noexcept
    : Fingerprint_Performance() {
    *this = ::std::move(from);
  }

  inline Fingerprint_Performance& operator=(const Fingerprint_Performance& from) {
    CopyFrom(from);
    return *this;
  }
  inline Fingerprint_Performance& operator=(Fingerprint_Performance&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const Fingerprint_Performance& default_instance() {
    return *internal_default_instance();
  }
  static inline const Fingerprint_Performance* internal_default_instance() {
    return reinterpret_cast<const Fingerprint_Performance*>(
               &_Fingerprint_Performance_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Fingerprint_Performance& a, Fingerprint_Performance& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(Fingerprint_Performance* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Fingerprint_Performance* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Fingerprint_Performance* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Fingerprint_Performance>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Fingerprint_Performance& from);
  void MergeFrom(const Fingerprint_Performance& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Fingerprint_Performance* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill.risk.Fingerprint.Performance";
  }
  protected:
  explicit Fingerprint_Performance(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNetworkTypeFieldNumber = 3,
    kBandwidthFieldNumber = 1,
    kMeteredFieldNumber = 2,
  };
  // optional string network_type = 3;
  bool has_network_type() const;
  private:
  bool _internal_has_network_type() const;
  public:
  void clear_network_type();
  const std::string& network_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_network_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_network_type();
  PROTOBUF_NODISCARD std::string* release_network_type();
  void set_allocated_network_type(std::string* network_type);
  private:
  const std::string& _internal_network_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_network_type(const std::string& value);
  std::string* _internal_mutable_network_type();
  public:

  // optional float bandwidth = 1;
  bool has_bandwidth() const;
  private:
  bool _internal_has_bandwidth() const;
  public:
  void clear_bandwidth();
  float bandwidth() const;
  void set_bandwidth(float value);
  private:
  float _internal_bandwidth() const;
  void _internal_set_bandwidth(float value);
  public:

  // optional bool metered = 2;
  bool has_metered() const;
  private:
  bool _internal_has_metered() const;
  public:
  void clear_metered();
  bool metered() const;
  void set_metered(bool value);
  private:
  bool _internal_metered() const;
  void _internal_set_metered(bool value);
  public:

  // @@protoc_insertion_point(class_scope:autofill.risk.Fingerprint.Performance)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr network_type_;
  float bandwidth_;
  bool metered_;
  friend struct ::TableStruct_fingerprint_2eproto;
};
// -------------------------------------------------------------------

class Fingerprint_UserCharacteristics_Vector final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill.risk.Fingerprint.UserCharacteristics.Vector) */ {
 public:
  inline Fingerprint_UserCharacteristics_Vector() : Fingerprint_UserCharacteristics_Vector(nullptr) {}
  ~Fingerprint_UserCharacteristics_Vector() override;
  explicit PROTOBUF_CONSTEXPR Fingerprint_UserCharacteristics_Vector(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Fingerprint_UserCharacteristics_Vector(const Fingerprint_UserCharacteristics_Vector& from);
  Fingerprint_UserCharacteristics_Vector(Fingerprint_UserCharacteristics_Vector&& from) noexcept
    : Fingerprint_UserCharacteristics_Vector() {
    *this = ::std::move(from);
  }

  inline Fingerprint_UserCharacteristics_Vector& operator=(const Fingerprint_UserCharacteristics_Vector& from) {
    CopyFrom(from);
    return *this;
  }
  inline Fingerprint_UserCharacteristics_Vector& operator=(Fingerprint_UserCharacteristics_Vector&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const Fingerprint_UserCharacteristics_Vector& default_instance() {
    return *internal_default_instance();
  }
  static inline const Fingerprint_UserCharacteristics_Vector* internal_default_instance() {
    return reinterpret_cast<const Fingerprint_UserCharacteristics_Vector*>(
               &_Fingerprint_UserCharacteristics_Vector_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Fingerprint_UserCharacteristics_Vector& a, Fingerprint_UserCharacteristics_Vector& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(Fingerprint_UserCharacteristics_Vector* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Fingerprint_UserCharacteristics_Vector* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Fingerprint_UserCharacteristics_Vector* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Fingerprint_UserCharacteristics_Vector>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Fingerprint_UserCharacteristics_Vector& from);
  void MergeFrom(const Fingerprint_UserCharacteristics_Vector& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Fingerprint_UserCharacteristics_Vector* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill.risk.Fingerprint.UserCharacteristics.Vector";
  }
  protected:
  explicit Fingerprint_UserCharacteristics_Vector(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
  };
  // optional int32 x = 1;
  bool has_x() const;
  private:
  bool _internal_has_x() const;
  public:
  void clear_x();
  int32_t x() const;
  void set_x(int32_t value);
  private:
  int32_t _internal_x() const;
  void _internal_set_x(int32_t value);
  public:

  // optional int32 y = 2;
  bool has_y() const;
  private:
  bool _internal_has_y() const;
  public:
  void clear_y();
  int32_t y() const;
  void set_y(int32_t value);
  private:
  int32_t _internal_y() const;
  void _internal_set_y(int32_t value);
  public:

  // optional int32 z = 3;
  bool has_z() const;
  private:
  bool _internal_has_z() const;
  public:
  void clear_z();
  int32_t z() const;
  void set_z(int32_t value);
  private:
  int32_t _internal_z() const;
  void _internal_set_z(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:autofill.risk.Fingerprint.UserCharacteristics.Vector)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int32_t x_;
  int32_t y_;
  int32_t z_;
  friend struct ::TableStruct_fingerprint_2eproto;
};
// -------------------------------------------------------------------

class Fingerprint_UserCharacteristics_Location final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill.risk.Fingerprint.UserCharacteristics.Location) */ {
 public:
  inline Fingerprint_UserCharacteristics_Location() : Fingerprint_UserCharacteristics_Location(nullptr) {}
  ~Fingerprint_UserCharacteristics_Location() override;
  explicit PROTOBUF_CONSTEXPR Fingerprint_UserCharacteristics_Location(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Fingerprint_UserCharacteristics_Location(const Fingerprint_UserCharacteristics_Location& from);
  Fingerprint_UserCharacteristics_Location(Fingerprint_UserCharacteristics_Location&& from) noexcept
    : Fingerprint_UserCharacteristics_Location() {
    *this = ::std::move(from);
  }

  inline Fingerprint_UserCharacteristics_Location& operator=(const Fingerprint_UserCharacteristics_Location& from) {
    CopyFrom(from);
    return *this;
  }
  inline Fingerprint_UserCharacteristics_Location& operator=(Fingerprint_UserCharacteristics_Location&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const Fingerprint_UserCharacteristics_Location& default_instance() {
    return *internal_default_instance();
  }
  static inline const Fingerprint_UserCharacteristics_Location* internal_default_instance() {
    return reinterpret_cast<const Fingerprint_UserCharacteristics_Location*>(
               &_Fingerprint_UserCharacteristics_Location_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Fingerprint_UserCharacteristics_Location& a, Fingerprint_UserCharacteristics_Location& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(Fingerprint_UserCharacteristics_Location* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Fingerprint_UserCharacteristics_Location* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Fingerprint_UserCharacteristics_Location* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Fingerprint_UserCharacteristics_Location>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Fingerprint_UserCharacteristics_Location& from);
  void MergeFrom(const Fingerprint_UserCharacteristics_Location& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Fingerprint_UserCharacteristics_Location* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill.risk.Fingerprint.UserCharacteristics.Location";
  }
  protected:
  explicit Fingerprint_UserCharacteristics_Location(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAltitudeFieldNumber = 1,
    kLatitudeFieldNumber = 2,
    kLongitudeFieldNumber = 3,
    kAccuracyFieldNumber = 4,
    kTimeInMsFieldNumber = 5,
  };
  // optional double altitude = 1;
  bool has_altitude() const;
  private:
  bool _internal_has_altitude() const;
  public:
  void clear_altitude();
  double altitude() const;
  void set_altitude(double value);
  private:
  double _internal_altitude() const;
  void _internal_set_altitude(double value);
  public:

  // optional double latitude = 2;
  bool has_latitude() const;
  private:
  bool _internal_has_latitude() const;
  public:
  void clear_latitude();
  double latitude() const;
  void set_latitude(double value);
  private:
  double _internal_latitude() const;
  void _internal_set_latitude(double value);
  public:

  // optional double longitude = 3;
  bool has_longitude() const;
  private:
  bool _internal_has_longitude() const;
  public:
  void clear_longitude();
  double longitude() const;
  void set_longitude(double value);
  private:
  double _internal_longitude() const;
  void _internal_set_longitude(double value);
  public:

  // optional double accuracy = 4;
  bool has_accuracy() const;
  private:
  bool _internal_has_accuracy() const;
  public:
  void clear_accuracy();
  double accuracy() const;
  void set_accuracy(double value);
  private:
  double _internal_accuracy() const;
  void _internal_set_accuracy(double value);
  public:

  // optional int64 time_in_ms = 5;
  bool has_time_in_ms() const;
  private:
  bool _internal_has_time_in_ms() const;
  public:
  void clear_time_in_ms();
  int64_t time_in_ms() const;
  void set_time_in_ms(int64_t value);
  private:
  int64_t _internal_time_in_ms() const;
  void _internal_set_time_in_ms(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:autofill.risk.Fingerprint.UserCharacteristics.Location)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  double altitude_;
  double latitude_;
  double longitude_;
  double accuracy_;
  int64_t time_in_ms_;
  friend struct ::TableStruct_fingerprint_2eproto;
};
// -------------------------------------------------------------------

class Fingerprint_UserCharacteristics final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill.risk.Fingerprint.UserCharacteristics) */ {
 public:
  inline Fingerprint_UserCharacteristics() : Fingerprint_UserCharacteristics(nullptr) {}
  ~Fingerprint_UserCharacteristics() override;
  explicit PROTOBUF_CONSTEXPR Fingerprint_UserCharacteristics(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Fingerprint_UserCharacteristics(const Fingerprint_UserCharacteristics& from);
  Fingerprint_UserCharacteristics(Fingerprint_UserCharacteristics&& from) noexcept
    : Fingerprint_UserCharacteristics() {
    *this = ::std::move(from);
  }

  inline Fingerprint_UserCharacteristics& operator=(const Fingerprint_UserCharacteristics& from) {
    CopyFrom(from);
    return *this;
  }
  inline Fingerprint_UserCharacteristics& operator=(Fingerprint_UserCharacteristics&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const Fingerprint_UserCharacteristics& default_instance() {
    return *internal_default_instance();
  }
  static inline const Fingerprint_UserCharacteristics* internal_default_instance() {
    return reinterpret_cast<const Fingerprint_UserCharacteristics*>(
               &_Fingerprint_UserCharacteristics_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(Fingerprint_UserCharacteristics& a, Fingerprint_UserCharacteristics& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(Fingerprint_UserCharacteristics* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Fingerprint_UserCharacteristics* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Fingerprint_UserCharacteristics* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Fingerprint_UserCharacteristics>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Fingerprint_UserCharacteristics& from);
  void MergeFrom(const Fingerprint_UserCharacteristics& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Fingerprint_UserCharacteristics* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill.risk.Fingerprint.UserCharacteristics";
  }
  protected:
  explicit Fingerprint_UserCharacteristics(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef Fingerprint_UserCharacteristics_Vector Vector;
  typedef Fingerprint_UserCharacteristics_Location Location;

  // accessors -------------------------------------------------------

  enum : int {
    kDeviceOrientationFieldNumber = 5,
    kDeviceAccelerationFieldNumber = 6,
    kLocationFieldNumber = 7,
    kForceFieldNumber = 1,
    kTouchWidthFieldNumber = 2,
    kTouchHeightFieldNumber = 3,
    kTouchRotationFieldNumber = 4,
  };
  // optional .autofill.risk.Fingerprint.UserCharacteristics.Vector device_orientation = 5;
  bool has_device_orientation() const;
  private:
  bool _internal_has_device_orientation() const;
  public:
  void clear_device_orientation();
  const ::autofill::risk::Fingerprint_UserCharacteristics_Vector& device_orientation() const;
  PROTOBUF_NODISCARD ::autofill::risk::Fingerprint_UserCharacteristics_Vector* release_device_orientation();
  ::autofill::risk::Fingerprint_UserCharacteristics_Vector* mutable_device_orientation();
  void set_allocated_device_orientation(::autofill::risk::Fingerprint_UserCharacteristics_Vector* device_orientation);
  private:
  const ::autofill::risk::Fingerprint_UserCharacteristics_Vector& _internal_device_orientation() const;
  ::autofill::risk::Fingerprint_UserCharacteristics_Vector* _internal_mutable_device_orientation();
  public:
  void unsafe_arena_set_allocated_device_orientation(
      ::autofill::risk::Fingerprint_UserCharacteristics_Vector* device_orientation);
  ::autofill::risk::Fingerprint_UserCharacteristics_Vector* unsafe_arena_release_device_orientation();

  // optional .autofill.risk.Fingerprint.UserCharacteristics.Vector device_acceleration = 6;
  bool has_device_acceleration() const;
  private:
  bool _internal_has_device_acceleration() const;
  public:
  void clear_device_acceleration();
  const ::autofill::risk::Fingerprint_UserCharacteristics_Vector& device_acceleration() const;
  PROTOBUF_NODISCARD ::autofill::risk::Fingerprint_UserCharacteristics_Vector* release_device_acceleration();
  ::autofill::risk::Fingerprint_UserCharacteristics_Vector* mutable_device_acceleration();
  void set_allocated_device_acceleration(::autofill::risk::Fingerprint_UserCharacteristics_Vector* device_acceleration);
  private:
  const ::autofill::risk::Fingerprint_UserCharacteristics_Vector& _internal_device_acceleration() const;
  ::autofill::risk::Fingerprint_UserCharacteristics_Vector* _internal_mutable_device_acceleration();
  public:
  void unsafe_arena_set_allocated_device_acceleration(
      ::autofill::risk::Fingerprint_UserCharacteristics_Vector* device_acceleration);
  ::autofill::risk::Fingerprint_UserCharacteristics_Vector* unsafe_arena_release_device_acceleration();

  // optional .autofill.risk.Fingerprint.UserCharacteristics.Location location = 7;
  bool has_location() const;
  private:
  bool _internal_has_location() const;
  public:
  void clear_location();
  const ::autofill::risk::Fingerprint_UserCharacteristics_Location& location() const;
  PROTOBUF_NODISCARD ::autofill::risk::Fingerprint_UserCharacteristics_Location* release_location();
  ::autofill::risk::Fingerprint_UserCharacteristics_Location* mutable_location();
  void set_allocated_location(::autofill::risk::Fingerprint_UserCharacteristics_Location* location);
  private:
  const ::autofill::risk::Fingerprint_UserCharacteristics_Location& _internal_location() const;
  ::autofill::risk::Fingerprint_UserCharacteristics_Location* _internal_mutable_location();
  public:
  void unsafe_arena_set_allocated_location(
      ::autofill::risk::Fingerprint_UserCharacteristics_Location* location);
  ::autofill::risk::Fingerprint_UserCharacteristics_Location* unsafe_arena_release_location();

  // optional float force = 1;
  bool has_force() const;
  private:
  bool _internal_has_force() const;
  public:
  void clear_force();
  float force() const;
  void set_force(float value);
  private:
  float _internal_force() const;
  void _internal_set_force(float value);
  public:

  // optional float touch_width = 2;
  bool has_touch_width() const;
  private:
  bool _internal_has_touch_width() const;
  public:
  void clear_touch_width();
  float touch_width() const;
  void set_touch_width(float value);
  private:
  float _internal_touch_width() const;
  void _internal_set_touch_width(float value);
  public:

  // optional float touch_height = 3;
  bool has_touch_height() const;
  private:
  bool _internal_has_touch_height() const;
  public:
  void clear_touch_height();
  float touch_height() const;
  void set_touch_height(float value);
  private:
  float _internal_touch_height() const;
  void _internal_set_touch_height(float value);
  public:

  // optional int32 touch_rotation = 4;
  bool has_touch_rotation() const;
  private:
  bool _internal_has_touch_rotation() const;
  public:
  void clear_touch_rotation();
  int32_t touch_rotation() const;
  void set_touch_rotation(int32_t value);
  private:
  int32_t _internal_touch_rotation() const;
  void _internal_set_touch_rotation(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:autofill.risk.Fingerprint.UserCharacteristics)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::autofill::risk::Fingerprint_UserCharacteristics_Vector* device_orientation_;
  ::autofill::risk::Fingerprint_UserCharacteristics_Vector* device_acceleration_;
  ::autofill::risk::Fingerprint_UserCharacteristics_Location* location_;
  float force_;
  float touch_width_;
  float touch_height_;
  int32_t touch_rotation_;
  friend struct ::TableStruct_fingerprint_2eproto;
};
// -------------------------------------------------------------------

class Fingerprint_Metadata final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill.risk.Fingerprint.Metadata) */ {
 public:
  inline Fingerprint_Metadata() : Fingerprint_Metadata(nullptr) {}
  ~Fingerprint_Metadata() override;
  explicit PROTOBUF_CONSTEXPR Fingerprint_Metadata(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Fingerprint_Metadata(const Fingerprint_Metadata& from);
  Fingerprint_Metadata(Fingerprint_Metadata&& from) noexcept
    : Fingerprint_Metadata() {
    *this = ::std::move(from);
  }

  inline Fingerprint_Metadata& operator=(const Fingerprint_Metadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline Fingerprint_Metadata& operator=(Fingerprint_Metadata&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const Fingerprint_Metadata& default_instance() {
    return *internal_default_instance();
  }
  static inline const Fingerprint_Metadata* internal_default_instance() {
    return reinterpret_cast<const Fingerprint_Metadata*>(
               &_Fingerprint_Metadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(Fingerprint_Metadata& a, Fingerprint_Metadata& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(Fingerprint_Metadata* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Fingerprint_Metadata* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Fingerprint_Metadata* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Fingerprint_Metadata>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Fingerprint_Metadata& from);
  void MergeFrom(const Fingerprint_Metadata& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Fingerprint_Metadata* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill.risk.Fingerprint.Metadata";
  }
  protected:
  explicit Fingerprint_Metadata(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTimestampMsFieldNumber = 1,
    kObfuscatedGaiaIdFieldNumber = 2,
    kFingerprinterVersionFieldNumber = 3,
  };
  // optional int64 timestamp_ms = 1;
  bool has_timestamp_ms() const;
  private:
  bool _internal_has_timestamp_ms() const;
  public:
  void clear_timestamp_ms();
  int64_t timestamp_ms() const;
  void set_timestamp_ms(int64_t value);
  private:
  int64_t _internal_timestamp_ms() const;
  void _internal_set_timestamp_ms(int64_t value);
  public:

  // optional uint64 obfuscated_gaia_id = 2;
  bool has_obfuscated_gaia_id() const;
  private:
  bool _internal_has_obfuscated_gaia_id() const;
  public:
  void clear_obfuscated_gaia_id();
  uint64_t obfuscated_gaia_id() const;
  void set_obfuscated_gaia_id(uint64_t value);
  private:
  uint64_t _internal_obfuscated_gaia_id() const;
  void _internal_set_obfuscated_gaia_id(uint64_t value);
  public:

  // optional int32 fingerprinter_version = 3;
  bool has_fingerprinter_version() const;
  private:
  bool _internal_has_fingerprinter_version() const;
  public:
  void clear_fingerprinter_version();
  int32_t fingerprinter_version() const;
  void set_fingerprinter_version(int32_t value);
  private:
  int32_t _internal_fingerprinter_version() const;
  void _internal_set_fingerprinter_version(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:autofill.risk.Fingerprint.Metadata)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int64_t timestamp_ms_;
  uint64_t obfuscated_gaia_id_;
  int32_t fingerprinter_version_;
  friend struct ::TableStruct_fingerprint_2eproto;
};
// -------------------------------------------------------------------

class Fingerprint final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill.risk.Fingerprint) */ {
 public:
  inline Fingerprint() : Fingerprint(nullptr) {}
  ~Fingerprint() override;
  explicit PROTOBUF_CONSTEXPR Fingerprint(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Fingerprint(const Fingerprint& from);
  Fingerprint(Fingerprint&& from) noexcept
    : Fingerprint() {
    *this = ::std::move(from);
  }

  inline Fingerprint& operator=(const Fingerprint& from) {
    CopyFrom(from);
    return *this;
  }
  inline Fingerprint& operator=(Fingerprint&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const Fingerprint& default_instance() {
    return *internal_default_instance();
  }
  static inline const Fingerprint* internal_default_instance() {
    return reinterpret_cast<const Fingerprint*>(
               &_Fingerprint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(Fingerprint& a, Fingerprint& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(Fingerprint* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Fingerprint* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Fingerprint* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Fingerprint>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Fingerprint& from);
  void MergeFrom(const Fingerprint& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Fingerprint* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "autofill.risk.Fingerprint";
  }
  protected:
  explicit Fingerprint(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef Fingerprint_Dimension Dimension;
  typedef Fingerprint_MachineCharacteristics MachineCharacteristics;
  typedef Fingerprint_TransientState TransientState;
  typedef Fingerprint_Performance Performance;
  typedef Fingerprint_UserCharacteristics UserCharacteristics;
  typedef Fingerprint_Metadata Metadata;

  // accessors -------------------------------------------------------

  enum : int {
    kMachineCharacteristicsFieldNumber = 1,
    kPerformanceFieldNumber = 2,
    kUserCharacteristicsFieldNumber = 3,
    kTransientStateFieldNumber = 4,
    kMetadataFieldNumber = 5,
  };
  // optional .autofill.risk.Fingerprint.MachineCharacteristics machine_characteristics = 1;
  bool has_machine_characteristics() const;
  private:
  bool _internal_has_machine_characteristics() const;
  public:
  void clear_machine_characteristics();
  const ::autofill::risk::Fingerprint_MachineCharacteristics& machine_characteristics() const;
  PROTOBUF_NODISCARD ::autofill::risk::Fingerprint_MachineCharacteristics* release_machine_characteristics();
  ::autofill::risk::Fingerprint_MachineCharacteristics* mutable_machine_characteristics();
  void set_allocated_machine_characteristics(::autofill::risk::Fingerprint_MachineCharacteristics* machine_characteristics);
  private:
  const ::autofill::risk::Fingerprint_MachineCharacteristics& _internal_machine_characteristics() const;
  ::autofill::risk::Fingerprint_MachineCharacteristics* _internal_mutable_machine_characteristics();
  public:
  void unsafe_arena_set_allocated_machine_characteristics(
      ::autofill::risk::Fingerprint_MachineCharacteristics* machine_characteristics);
  ::autofill::risk::Fingerprint_MachineCharacteristics* unsafe_arena_release_machine_characteristics();

  // optional .autofill.risk.Fingerprint.Performance performance = 2;
  bool has_performance() const;
  private:
  bool _internal_has_performance() const;
  public:
  void clear_performance();
  const ::autofill::risk::Fingerprint_Performance& performance() const;
  PROTOBUF_NODISCARD ::autofill::risk::Fingerprint_Performance* release_performance();
  ::autofill::risk::Fingerprint_Performance* mutable_performance();
  void set_allocated_performance(::autofill::risk::Fingerprint_Performance* performance);
  private:
  const ::autofill::risk::Fingerprint_Performance& _internal_performance() const;
  ::autofill::risk::Fingerprint_Performance* _internal_mutable_performance();
  public:
  void unsafe_arena_set_allocated_performance(
      ::autofill::risk::Fingerprint_Performance* performance);
  ::autofill::risk::Fingerprint_Performance* unsafe_arena_release_performance();

  // optional .autofill.risk.Fingerprint.UserCharacteristics user_characteristics = 3;
  bool has_user_characteristics() const;
  private:
  bool _internal_has_user_characteristics() const;
  public:
  void clear_user_characteristics();
  const ::autofill::risk::Fingerprint_UserCharacteristics& user_characteristics() const;
  PROTOBUF_NODISCARD ::autofill::risk::Fingerprint_UserCharacteristics* release_user_characteristics();
  ::autofill::risk::Fingerprint_UserCharacteristics* mutable_user_characteristics();
  void set_allocated_user_characteristics(::autofill::risk::Fingerprint_UserCharacteristics* user_characteristics);
  private:
  const ::autofill::risk::Fingerprint_UserCharacteristics& _internal_user_characteristics() const;
  ::autofill::risk::Fingerprint_UserCharacteristics* _internal_mutable_user_characteristics();
  public:
  void unsafe_arena_set_allocated_user_characteristics(
      ::autofill::risk::Fingerprint_UserCharacteristics* user_characteristics);
  ::autofill::risk::Fingerprint_UserCharacteristics* unsafe_arena_release_user_characteristics();

  // optional .autofill.risk.Fingerprint.TransientState transient_state = 4;
  bool has_transient_state() const;
  private:
  bool _internal_has_transient_state() const;
  public:
  void clear_transient_state();
  const ::autofill::risk::Fingerprint_TransientState& transient_state() const;
  PROTOBUF_NODISCARD ::autofill::risk::Fingerprint_TransientState* release_transient_state();
  ::autofill::risk::Fingerprint_TransientState* mutable_transient_state();
  void set_allocated_transient_state(::autofill::risk::Fingerprint_TransientState* transient_state);
  private:
  const ::autofill::risk::Fingerprint_TransientState& _internal_transient_state() const;
  ::autofill::risk::Fingerprint_TransientState* _internal_mutable_transient_state();
  public:
  void unsafe_arena_set_allocated_transient_state(
      ::autofill::risk::Fingerprint_TransientState* transient_state);
  ::autofill::risk::Fingerprint_TransientState* unsafe_arena_release_transient_state();

  // optional .autofill.risk.Fingerprint.Metadata metadata = 5;
  bool has_metadata() const;
  private:
  bool _internal_has_metadata() const;
  public:
  void clear_metadata();
  const ::autofill::risk::Fingerprint_Metadata& metadata() const;
  PROTOBUF_NODISCARD ::autofill::risk::Fingerprint_Metadata* release_metadata();
  ::autofill::risk::Fingerprint_Metadata* mutable_metadata();
  void set_allocated_metadata(::autofill::risk::Fingerprint_Metadata* metadata);
  private:
  const ::autofill::risk::Fingerprint_Metadata& _internal_metadata() const;
  ::autofill::risk::Fingerprint_Metadata* _internal_mutable_metadata();
  public:
  void unsafe_arena_set_allocated_metadata(
      ::autofill::risk::Fingerprint_Metadata* metadata);
  ::autofill::risk::Fingerprint_Metadata* unsafe_arena_release_metadata();

  // @@protoc_insertion_point(class_scope:autofill.risk.Fingerprint)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::autofill::risk::Fingerprint_MachineCharacteristics* machine_characteristics_;
  ::autofill::risk::Fingerprint_Performance* performance_;
  ::autofill::risk::Fingerprint_UserCharacteristics* user_characteristics_;
  ::autofill::risk::Fingerprint_TransientState* transient_state_;
  ::autofill::risk::Fingerprint_Metadata* metadata_;
  friend struct ::TableStruct_fingerprint_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Fingerprint_Dimension

// optional int32 width = 1;
inline bool Fingerprint_Dimension::_internal_has_width() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Fingerprint_Dimension::has_width() const {
  return _internal_has_width();
}
inline void Fingerprint_Dimension::clear_width() {
  width_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline int32_t Fingerprint_Dimension::_internal_width() const {
  return width_;
}
inline int32_t Fingerprint_Dimension::width() const {
  // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.Dimension.width)
  return _internal_width();
}
inline void Fingerprint_Dimension::_internal_set_width(int32_t value) {
  _has_bits_[0] |= 0x00000001u;
  width_ = value;
}
inline void Fingerprint_Dimension::set_width(int32_t value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.Dimension.width)
}

// optional int32 height = 2;
inline bool Fingerprint_Dimension::_internal_has_height() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Fingerprint_Dimension::has_height() const {
  return _internal_has_height();
}
inline void Fingerprint_Dimension::clear_height() {
  height_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline int32_t Fingerprint_Dimension::_internal_height() const {
  return height_;
}
inline int32_t Fingerprint_Dimension::height() const {
  // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.Dimension.height)
  return _internal_height();
}
inline void Fingerprint_Dimension::_internal_set_height(int32_t value) {
  _has_bits_[0] |= 0x00000002u;
  height_ = value;
}
inline void Fingerprint_Dimension::set_height(int32_t value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.Dimension.height)
}

// -------------------------------------------------------------------

// Fingerprint_MachineCharacteristics_Plugin

// optional string name = 1;
inline bool Fingerprint_MachineCharacteristics_Plugin::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Fingerprint_MachineCharacteristics_Plugin::has_name() const {
  return _internal_has_name();
}
inline void Fingerprint_MachineCharacteristics_Plugin::clear_name() {
  name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Fingerprint_MachineCharacteristics_Plugin::name() const {
  // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.MachineCharacteristics.Plugin.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Fingerprint_MachineCharacteristics_Plugin::set_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.MachineCharacteristics.Plugin.name)
}
inline std::string* Fingerprint_MachineCharacteristics_Plugin::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:autofill.risk.Fingerprint.MachineCharacteristics.Plugin.name)
  return _s;
}
inline const std::string& Fingerprint_MachineCharacteristics_Plugin::_internal_name() const {
  return name_.Get();
}
inline void Fingerprint_MachineCharacteristics_Plugin::_internal_set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(value, GetArenaForAllocation());
}
inline std::string* Fingerprint_MachineCharacteristics_Plugin::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  return name_.Mutable(GetArenaForAllocation());
}
inline std::string* Fingerprint_MachineCharacteristics_Plugin::release_name() {
  // @@protoc_insertion_point(field_release:autofill.risk.Fingerprint.MachineCharacteristics.Plugin.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault()) {
    name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Fingerprint_MachineCharacteristics_Plugin::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault()) {
    name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill.risk.Fingerprint.MachineCharacteristics.Plugin.name)
}

// optional string description = 2;
inline bool Fingerprint_MachineCharacteristics_Plugin::_internal_has_description() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Fingerprint_MachineCharacteristics_Plugin::has_description() const {
  return _internal_has_description();
}
inline void Fingerprint_MachineCharacteristics_Plugin::clear_description() {
  description_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Fingerprint_MachineCharacteristics_Plugin::description() const {
  // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.MachineCharacteristics.Plugin.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Fingerprint_MachineCharacteristics_Plugin::set_description(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.MachineCharacteristics.Plugin.description)
}
inline std::string* Fingerprint_MachineCharacteristics_Plugin::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:autofill.risk.Fingerprint.MachineCharacteristics.Plugin.description)
  return _s;
}
inline const std::string& Fingerprint_MachineCharacteristics_Plugin::_internal_description() const {
  return description_.Get();
}
inline void Fingerprint_MachineCharacteristics_Plugin::_internal_set_description(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  description_.Set(value, GetArenaForAllocation());
}
inline std::string* Fingerprint_MachineCharacteristics_Plugin::_internal_mutable_description() {
  _has_bits_[0] |= 0x00000002u;
  return description_.Mutable(GetArenaForAllocation());
}
inline std::string* Fingerprint_MachineCharacteristics_Plugin::release_description() {
  // @@protoc_insertion_point(field_release:autofill.risk.Fingerprint.MachineCharacteristics.Plugin.description)
  if (!_internal_has_description()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = description_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (description_.IsDefault()) {
    description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Fingerprint_MachineCharacteristics_Plugin::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (description_.IsDefault()) {
    description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill.risk.Fingerprint.MachineCharacteristics.Plugin.description)
}

// repeated string mime_type = 3;
inline int Fingerprint_MachineCharacteristics_Plugin::_internal_mime_type_size() const {
  return mime_type_.size();
}
inline int Fingerprint_MachineCharacteristics_Plugin::mime_type_size() const {
  return _internal_mime_type_size();
}
inline void Fingerprint_MachineCharacteristics_Plugin::clear_mime_type() {
  mime_type_.Clear();
}
inline std::string* Fingerprint_MachineCharacteristics_Plugin::add_mime_type() {
  std::string* _s = _internal_add_mime_type();
  // @@protoc_insertion_point(field_add_mutable:autofill.risk.Fingerprint.MachineCharacteristics.Plugin.mime_type)
  return _s;
}
inline const std::string& Fingerprint_MachineCharacteristics_Plugin::_internal_mime_type(int index) const {
  return mime_type_.Get(index);
}
inline const std::string& Fingerprint_MachineCharacteristics_Plugin::mime_type(int index) const {
  // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.MachineCharacteristics.Plugin.mime_type)
  return _internal_mime_type(index);
}
inline std::string* Fingerprint_MachineCharacteristics_Plugin::mutable_mime_type(int index) {
  // @@protoc_insertion_point(field_mutable:autofill.risk.Fingerprint.MachineCharacteristics.Plugin.mime_type)
  return mime_type_.Mutable(index);
}
inline void Fingerprint_MachineCharacteristics_Plugin::set_mime_type(int index, const std::string& value) {
  mime_type_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.MachineCharacteristics.Plugin.mime_type)
}
inline void Fingerprint_MachineCharacteristics_Plugin::set_mime_type(int index, std::string&& value) {
  mime_type_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.MachineCharacteristics.Plugin.mime_type)
}
inline void Fingerprint_MachineCharacteristics_Plugin::set_mime_type(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  mime_type_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:autofill.risk.Fingerprint.MachineCharacteristics.Plugin.mime_type)
}
inline void Fingerprint_MachineCharacteristics_Plugin::set_mime_type(int index, const char* value, size_t size) {
  mime_type_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:autofill.risk.Fingerprint.MachineCharacteristics.Plugin.mime_type)
}
inline std::string* Fingerprint_MachineCharacteristics_Plugin::_internal_add_mime_type() {
  return mime_type_.Add();
}
inline void Fingerprint_MachineCharacteristics_Plugin::add_mime_type(const std::string& value) {
  mime_type_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:autofill.risk.Fingerprint.MachineCharacteristics.Plugin.mime_type)
}
inline void Fingerprint_MachineCharacteristics_Plugin::add_mime_type(std::string&& value) {
  mime_type_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:autofill.risk.Fingerprint.MachineCharacteristics.Plugin.mime_type)
}
inline void Fingerprint_MachineCharacteristics_Plugin::add_mime_type(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  mime_type_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:autofill.risk.Fingerprint.MachineCharacteristics.Plugin.mime_type)
}
inline void Fingerprint_MachineCharacteristics_Plugin::add_mime_type(const char* value, size_t size) {
  mime_type_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:autofill.risk.Fingerprint.MachineCharacteristics.Plugin.mime_type)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Fingerprint_MachineCharacteristics_Plugin::mime_type() const {
  // @@protoc_insertion_point(field_list:autofill.risk.Fingerprint.MachineCharacteristics.Plugin.mime_type)
  return mime_type_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Fingerprint_MachineCharacteristics_Plugin::mutable_mime_type() {
  // @@protoc_insertion_point(field_mutable_list:autofill.risk.Fingerprint.MachineCharacteristics.Plugin.mime_type)
  return &mime_type_;
}

// optional string version = 4;
inline bool Fingerprint_MachineCharacteristics_Plugin::_internal_has_version() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Fingerprint_MachineCharacteristics_Plugin::has_version() const {
  return _internal_has_version();
}
inline void Fingerprint_MachineCharacteristics_Plugin::clear_version() {
  version_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& Fingerprint_MachineCharacteristics_Plugin::version() const {
  // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.MachineCharacteristics.Plugin.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Fingerprint_MachineCharacteristics_Plugin::set_version(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.MachineCharacteristics.Plugin.version)
}
inline std::string* Fingerprint_MachineCharacteristics_Plugin::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:autofill.risk.Fingerprint.MachineCharacteristics.Plugin.version)
  return _s;
}
inline const std::string& Fingerprint_MachineCharacteristics_Plugin::_internal_version() const {
  return version_.Get();
}
inline void Fingerprint_MachineCharacteristics_Plugin::_internal_set_version(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  version_.Set(value, GetArenaForAllocation());
}
inline std::string* Fingerprint_MachineCharacteristics_Plugin::_internal_mutable_version() {
  _has_bits_[0] |= 0x00000004u;
  return version_.Mutable(GetArenaForAllocation());
}
inline std::string* Fingerprint_MachineCharacteristics_Plugin::release_version() {
  // @@protoc_insertion_point(field_release:autofill.risk.Fingerprint.MachineCharacteristics.Plugin.version)
  if (!_internal_has_version()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = version_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (version_.IsDefault()) {
    version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Fingerprint_MachineCharacteristics_Plugin::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  version_.SetAllocated(version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (version_.IsDefault()) {
    version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill.risk.Fingerprint.MachineCharacteristics.Plugin.version)
}

// -------------------------------------------------------------------

// Fingerprint_MachineCharacteristics_Cpu

// optional string vendor_name = 1;
inline bool Fingerprint_MachineCharacteristics_Cpu::_internal_has_vendor_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Fingerprint_MachineCharacteristics_Cpu::has_vendor_name() const {
  return _internal_has_vendor_name();
}
inline void Fingerprint_MachineCharacteristics_Cpu::clear_vendor_name() {
  vendor_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Fingerprint_MachineCharacteristics_Cpu::vendor_name() const {
  // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.MachineCharacteristics.Cpu.vendor_name)
  return _internal_vendor_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Fingerprint_MachineCharacteristics_Cpu::set_vendor_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 vendor_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.MachineCharacteristics.Cpu.vendor_name)
}
inline std::string* Fingerprint_MachineCharacteristics_Cpu::mutable_vendor_name() {
  std::string* _s = _internal_mutable_vendor_name();
  // @@protoc_insertion_point(field_mutable:autofill.risk.Fingerprint.MachineCharacteristics.Cpu.vendor_name)
  return _s;
}
inline const std::string& Fingerprint_MachineCharacteristics_Cpu::_internal_vendor_name() const {
  return vendor_name_.Get();
}
inline void Fingerprint_MachineCharacteristics_Cpu::_internal_set_vendor_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  vendor_name_.Set(value, GetArenaForAllocation());
}
inline std::string* Fingerprint_MachineCharacteristics_Cpu::_internal_mutable_vendor_name() {
  _has_bits_[0] |= 0x00000001u;
  return vendor_name_.Mutable(GetArenaForAllocation());
}
inline std::string* Fingerprint_MachineCharacteristics_Cpu::release_vendor_name() {
  // @@protoc_insertion_point(field_release:autofill.risk.Fingerprint.MachineCharacteristics.Cpu.vendor_name)
  if (!_internal_has_vendor_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = vendor_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (vendor_name_.IsDefault()) {
    vendor_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Fingerprint_MachineCharacteristics_Cpu::set_allocated_vendor_name(std::string* vendor_name) {
  if (vendor_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  vendor_name_.SetAllocated(vendor_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (vendor_name_.IsDefault()) {
    vendor_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill.risk.Fingerprint.MachineCharacteristics.Cpu.vendor_name)
}

// optional string brand = 2;
inline bool Fingerprint_MachineCharacteristics_Cpu::_internal_has_brand() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Fingerprint_MachineCharacteristics_Cpu::has_brand() const {
  return _internal_has_brand();
}
inline void Fingerprint_MachineCharacteristics_Cpu::clear_brand() {
  brand_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Fingerprint_MachineCharacteristics_Cpu::brand() const {
  // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.MachineCharacteristics.Cpu.brand)
  return _internal_brand();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Fingerprint_MachineCharacteristics_Cpu::set_brand(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 brand_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.MachineCharacteristics.Cpu.brand)
}
inline std::string* Fingerprint_MachineCharacteristics_Cpu::mutable_brand() {
  std::string* _s = _internal_mutable_brand();
  // @@protoc_insertion_point(field_mutable:autofill.risk.Fingerprint.MachineCharacteristics.Cpu.brand)
  return _s;
}
inline const std::string& Fingerprint_MachineCharacteristics_Cpu::_internal_brand() const {
  return brand_.Get();
}
inline void Fingerprint_MachineCharacteristics_Cpu::_internal_set_brand(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  brand_.Set(value, GetArenaForAllocation());
}
inline std::string* Fingerprint_MachineCharacteristics_Cpu::_internal_mutable_brand() {
  _has_bits_[0] |= 0x00000002u;
  return brand_.Mutable(GetArenaForAllocation());
}
inline std::string* Fingerprint_MachineCharacteristics_Cpu::release_brand() {
  // @@protoc_insertion_point(field_release:autofill.risk.Fingerprint.MachineCharacteristics.Cpu.brand)
  if (!_internal_has_brand()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = brand_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (brand_.IsDefault()) {
    brand_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Fingerprint_MachineCharacteristics_Cpu::set_allocated_brand(std::string* brand) {
  if (brand != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  brand_.SetAllocated(brand, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (brand_.IsDefault()) {
    brand_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill.risk.Fingerprint.MachineCharacteristics.Cpu.brand)
}

// -------------------------------------------------------------------

// Fingerprint_MachineCharacteristics_Graphics

// optional uint32 vendor_id = 1;
inline bool Fingerprint_MachineCharacteristics_Graphics::_internal_has_vendor_id() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Fingerprint_MachineCharacteristics_Graphics::has_vendor_id() const {
  return _internal_has_vendor_id();
}
inline void Fingerprint_MachineCharacteristics_Graphics::clear_vendor_id() {
  vendor_id_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline uint32_t Fingerprint_MachineCharacteristics_Graphics::_internal_vendor_id() const {
  return vendor_id_;
}
inline uint32_t Fingerprint_MachineCharacteristics_Graphics::vendor_id() const {
  // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.MachineCharacteristics.Graphics.vendor_id)
  return _internal_vendor_id();
}
inline void Fingerprint_MachineCharacteristics_Graphics::_internal_set_vendor_id(uint32_t value) {
  _has_bits_[0] |= 0x00000004u;
  vendor_id_ = value;
}
inline void Fingerprint_MachineCharacteristics_Graphics::set_vendor_id(uint32_t value) {
  _internal_set_vendor_id(value);
  // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.MachineCharacteristics.Graphics.vendor_id)
}

// optional uint32 device_id = 2;
inline bool Fingerprint_MachineCharacteristics_Graphics::_internal_has_device_id() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Fingerprint_MachineCharacteristics_Graphics::has_device_id() const {
  return _internal_has_device_id();
}
inline void Fingerprint_MachineCharacteristics_Graphics::clear_device_id() {
  device_id_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline uint32_t Fingerprint_MachineCharacteristics_Graphics::_internal_device_id() const {
  return device_id_;
}
inline uint32_t Fingerprint_MachineCharacteristics_Graphics::device_id() const {
  // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.MachineCharacteristics.Graphics.device_id)
  return _internal_device_id();
}
inline void Fingerprint_MachineCharacteristics_Graphics::_internal_set_device_id(uint32_t value) {
  _has_bits_[0] |= 0x00000008u;
  device_id_ = value;
}
inline void Fingerprint_MachineCharacteristics_Graphics::set_device_id(uint32_t value) {
  _internal_set_device_id(value);
  // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.MachineCharacteristics.Graphics.device_id)
}

// optional string driver_version = 3;
inline bool Fingerprint_MachineCharacteristics_Graphics::_internal_has_driver_version() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Fingerprint_MachineCharacteristics_Graphics::has_driver_version() const {
  return _internal_has_driver_version();
}
inline void Fingerprint_MachineCharacteristics_Graphics::clear_driver_version() {
  driver_version_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Fingerprint_MachineCharacteristics_Graphics::driver_version() const {
  // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.MachineCharacteristics.Graphics.driver_version)
  return _internal_driver_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Fingerprint_MachineCharacteristics_Graphics::set_driver_version(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 driver_version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.MachineCharacteristics.Graphics.driver_version)
}
inline std::string* Fingerprint_MachineCharacteristics_Graphics::mutable_driver_version() {
  std::string* _s = _internal_mutable_driver_version();
  // @@protoc_insertion_point(field_mutable:autofill.risk.Fingerprint.MachineCharacteristics.Graphics.driver_version)
  return _s;
}
inline const std::string& Fingerprint_MachineCharacteristics_Graphics::_internal_driver_version() const {
  return driver_version_.Get();
}
inline void Fingerprint_MachineCharacteristics_Graphics::_internal_set_driver_version(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  driver_version_.Set(value, GetArenaForAllocation());
}
inline std::string* Fingerprint_MachineCharacteristics_Graphics::_internal_mutable_driver_version() {
  _has_bits_[0] |= 0x00000001u;
  return driver_version_.Mutable(GetArenaForAllocation());
}
inline std::string* Fingerprint_MachineCharacteristics_Graphics::release_driver_version() {
  // @@protoc_insertion_point(field_release:autofill.risk.Fingerprint.MachineCharacteristics.Graphics.driver_version)
  if (!_internal_has_driver_version()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = driver_version_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (driver_version_.IsDefault()) {
    driver_version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Fingerprint_MachineCharacteristics_Graphics::set_allocated_driver_version(std::string* driver_version) {
  if (driver_version != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  driver_version_.SetAllocated(driver_version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (driver_version_.IsDefault()) {
    driver_version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill.risk.Fingerprint.MachineCharacteristics.Graphics.driver_version)
}

// optional string driver_date = 4;
inline bool Fingerprint_MachineCharacteristics_Graphics::_internal_has_driver_date() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Fingerprint_MachineCharacteristics_Graphics::has_driver_date() const {
  return _internal_has_driver_date();
}
inline void Fingerprint_MachineCharacteristics_Graphics::clear_driver_date() {
  driver_date_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Fingerprint_MachineCharacteristics_Graphics::driver_date() const {
  // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.MachineCharacteristics.Graphics.driver_date)
  return _internal_driver_date();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Fingerprint_MachineCharacteristics_Graphics::set_driver_date(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 driver_date_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.MachineCharacteristics.Graphics.driver_date)
}
inline std::string* Fingerprint_MachineCharacteristics_Graphics::mutable_driver_date() {
  std::string* _s = _internal_mutable_driver_date();
  // @@protoc_insertion_point(field_mutable:autofill.risk.Fingerprint.MachineCharacteristics.Graphics.driver_date)
  return _s;
}
inline const std::string& Fingerprint_MachineCharacteristics_Graphics::_internal_driver_date() const {
  return driver_date_.Get();
}
inline void Fingerprint_MachineCharacteristics_Graphics::_internal_set_driver_date(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  driver_date_.Set(value, GetArenaForAllocation());
}
inline std::string* Fingerprint_MachineCharacteristics_Graphics::_internal_mutable_driver_date() {
  _has_bits_[0] |= 0x00000002u;
  return driver_date_.Mutable(GetArenaForAllocation());
}
inline std::string* Fingerprint_MachineCharacteristics_Graphics::release_driver_date() {
  // @@protoc_insertion_point(field_release:autofill.risk.Fingerprint.MachineCharacteristics.Graphics.driver_date)
  if (!_internal_has_driver_date()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = driver_date_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (driver_date_.IsDefault()) {
    driver_date_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Fingerprint_MachineCharacteristics_Graphics::set_allocated_driver_date(std::string* driver_date) {
  if (driver_date != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  driver_date_.SetAllocated(driver_date, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (driver_date_.IsDefault()) {
    driver_date_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill.risk.Fingerprint.MachineCharacteristics.Graphics.driver_date)
}

// -------------------------------------------------------------------

// Fingerprint_MachineCharacteristics

// optional fixed64 user_and_device_name_hash = 1;
inline bool Fingerprint_MachineCharacteristics::_internal_has_user_and_device_name_hash() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool Fingerprint_MachineCharacteristics::has_user_and_device_name_hash() const {
  return _internal_has_user_and_device_name_hash();
}
inline void Fingerprint_MachineCharacteristics::clear_user_and_device_name_hash() {
  user_and_device_name_hash_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000200u;
}
inline uint64_t Fingerprint_MachineCharacteristics::_internal_user_and_device_name_hash() const {
  return user_and_device_name_hash_;
}
inline uint64_t Fingerprint_MachineCharacteristics::user_and_device_name_hash() const {
  // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.MachineCharacteristics.user_and_device_name_hash)
  return _internal_user_and_device_name_hash();
}
inline void Fingerprint_MachineCharacteristics::_internal_set_user_and_device_name_hash(uint64_t value) {
  _has_bits_[0] |= 0x00000200u;
  user_and_device_name_hash_ = value;
}
inline void Fingerprint_MachineCharacteristics::set_user_and_device_name_hash(uint64_t value) {
  _internal_set_user_and_device_name_hash(value);
  // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.MachineCharacteristics.user_and_device_name_hash)
}

// optional string operating_system_build = 2;
inline bool Fingerprint_MachineCharacteristics::_internal_has_operating_system_build() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Fingerprint_MachineCharacteristics::has_operating_system_build() const {
  return _internal_has_operating_system_build();
}
inline void Fingerprint_MachineCharacteristics::clear_operating_system_build() {
  operating_system_build_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Fingerprint_MachineCharacteristics::operating_system_build() const {
  // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.MachineCharacteristics.operating_system_build)
  return _internal_operating_system_build();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Fingerprint_MachineCharacteristics::set_operating_system_build(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 operating_system_build_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.MachineCharacteristics.operating_system_build)
}
inline std::string* Fingerprint_MachineCharacteristics::mutable_operating_system_build() {
  std::string* _s = _internal_mutable_operating_system_build();
  // @@protoc_insertion_point(field_mutable:autofill.risk.Fingerprint.MachineCharacteristics.operating_system_build)
  return _s;
}
inline const std::string& Fingerprint_MachineCharacteristics::_internal_operating_system_build() const {
  return operating_system_build_.Get();
}
inline void Fingerprint_MachineCharacteristics::_internal_set_operating_system_build(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  operating_system_build_.Set(value, GetArenaForAllocation());
}
inline std::string* Fingerprint_MachineCharacteristics::_internal_mutable_operating_system_build() {
  _has_bits_[0] |= 0x00000001u;
  return operating_system_build_.Mutable(GetArenaForAllocation());
}
inline std::string* Fingerprint_MachineCharacteristics::release_operating_system_build() {
  // @@protoc_insertion_point(field_release:autofill.risk.Fingerprint.MachineCharacteristics.operating_system_build)
  if (!_internal_has_operating_system_build()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = operating_system_build_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (operating_system_build_.IsDefault()) {
    operating_system_build_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Fingerprint_MachineCharacteristics::set_allocated_operating_system_build(std::string* operating_system_build) {
  if (operating_system_build != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  operating_system_build_.SetAllocated(operating_system_build, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (operating_system_build_.IsDefault()) {
    operating_system_build_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill.risk.Fingerprint.MachineCharacteristics.operating_system_build)
}

// optional int64 browser_install_time_hours = 3;
inline bool Fingerprint_MachineCharacteristics::_internal_has_browser_install_time_hours() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool Fingerprint_MachineCharacteristics::has_browser_install_time_hours() const {
  return _internal_has_browser_install_time_hours();
}
inline void Fingerprint_MachineCharacteristics::clear_browser_install_time_hours() {
  browser_install_time_hours_ = int64_t{0};
  _has_bits_[0] &= ~0x00000400u;
}
inline int64_t Fingerprint_MachineCharacteristics::_internal_browser_install_time_hours() const {
  return browser_install_time_hours_;
}
inline int64_t Fingerprint_MachineCharacteristics::browser_install_time_hours() const {
  // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.MachineCharacteristics.browser_install_time_hours)
  return _internal_browser_install_time_hours();
}
inline void Fingerprint_MachineCharacteristics::_internal_set_browser_install_time_hours(int64_t value) {
  _has_bits_[0] |= 0x00000400u;
  browser_install_time_hours_ = value;
}
inline void Fingerprint_MachineCharacteristics::set_browser_install_time_hours(int64_t value) {
  _internal_set_browser_install_time_hours(value);
  // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.MachineCharacteristics.browser_install_time_hours)
}

// repeated string font = 4;
inline int Fingerprint_MachineCharacteristics::_internal_font_size() const {
  return font_.size();
}
inline int Fingerprint_MachineCharacteristics::font_size() const {
  return _internal_font_size();
}
inline void Fingerprint_MachineCharacteristics::clear_font() {
  font_.Clear();
}
inline std::string* Fingerprint_MachineCharacteristics::add_font() {
  std::string* _s = _internal_add_font();
  // @@protoc_insertion_point(field_add_mutable:autofill.risk.Fingerprint.MachineCharacteristics.font)
  return _s;
}
inline const std::string& Fingerprint_MachineCharacteristics::_internal_font(int index) const {
  return font_.Get(index);
}
inline const std::string& Fingerprint_MachineCharacteristics::font(int index) const {
  // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.MachineCharacteristics.font)
  return _internal_font(index);
}
inline std::string* Fingerprint_MachineCharacteristics::mutable_font(int index) {
  // @@protoc_insertion_point(field_mutable:autofill.risk.Fingerprint.MachineCharacteristics.font)
  return font_.Mutable(index);
}
inline void Fingerprint_MachineCharacteristics::set_font(int index, const std::string& value) {
  font_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.MachineCharacteristics.font)
}
inline void Fingerprint_MachineCharacteristics::set_font(int index, std::string&& value) {
  font_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.MachineCharacteristics.font)
}
inline void Fingerprint_MachineCharacteristics::set_font(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  font_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:autofill.risk.Fingerprint.MachineCharacteristics.font)
}
inline void Fingerprint_MachineCharacteristics::set_font(int index, const char* value, size_t size) {
  font_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:autofill.risk.Fingerprint.MachineCharacteristics.font)
}
inline std::string* Fingerprint_MachineCharacteristics::_internal_add_font() {
  return font_.Add();
}
inline void Fingerprint_MachineCharacteristics::add_font(const std::string& value) {
  font_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:autofill.risk.Fingerprint.MachineCharacteristics.font)
}
inline void Fingerprint_MachineCharacteristics::add_font(std::string&& value) {
  font_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:autofill.risk.Fingerprint.MachineCharacteristics.font)
}
inline void Fingerprint_MachineCharacteristics::add_font(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  font_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:autofill.risk.Fingerprint.MachineCharacteristics.font)
}
inline void Fingerprint_MachineCharacteristics::add_font(const char* value, size_t size) {
  font_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:autofill.risk.Fingerprint.MachineCharacteristics.font)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Fingerprint_MachineCharacteristics::font() const {
  // @@protoc_insertion_point(field_list:autofill.risk.Fingerprint.MachineCharacteristics.font)
  return font_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Fingerprint_MachineCharacteristics::mutable_font() {
  // @@protoc_insertion_point(field_mutable_list:autofill.risk.Fingerprint.MachineCharacteristics.font)
  return &font_;
}

// repeated .autofill.risk.Fingerprint.MachineCharacteristics.Plugin plugin = 5;
inline int Fingerprint_MachineCharacteristics::_internal_plugin_size() const {
  return plugin_.size();
}
inline int Fingerprint_MachineCharacteristics::plugin_size() const {
  return _internal_plugin_size();
}
inline void Fingerprint_MachineCharacteristics::clear_plugin() {
  plugin_.Clear();
}
inline ::autofill::risk::Fingerprint_MachineCharacteristics_Plugin* Fingerprint_MachineCharacteristics::mutable_plugin(int index) {
  // @@protoc_insertion_point(field_mutable:autofill.risk.Fingerprint.MachineCharacteristics.plugin)
  return plugin_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill::risk::Fingerprint_MachineCharacteristics_Plugin >*
Fingerprint_MachineCharacteristics::mutable_plugin() {
  // @@protoc_insertion_point(field_mutable_list:autofill.risk.Fingerprint.MachineCharacteristics.plugin)
  return &plugin_;
}
inline const ::autofill::risk::Fingerprint_MachineCharacteristics_Plugin& Fingerprint_MachineCharacteristics::_internal_plugin(int index) const {
  return plugin_.Get(index);
}
inline const ::autofill::risk::Fingerprint_MachineCharacteristics_Plugin& Fingerprint_MachineCharacteristics::plugin(int index) const {
  // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.MachineCharacteristics.plugin)
  return _internal_plugin(index);
}
inline ::autofill::risk::Fingerprint_MachineCharacteristics_Plugin* Fingerprint_MachineCharacteristics::_internal_add_plugin() {
  return plugin_.Add();
}
inline ::autofill::risk::Fingerprint_MachineCharacteristics_Plugin* Fingerprint_MachineCharacteristics::add_plugin() {
  ::autofill::risk::Fingerprint_MachineCharacteristics_Plugin* _add = _internal_add_plugin();
  // @@protoc_insertion_point(field_add:autofill.risk.Fingerprint.MachineCharacteristics.plugin)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::autofill::risk::Fingerprint_MachineCharacteristics_Plugin >&
Fingerprint_MachineCharacteristics::plugin() const {
  // @@protoc_insertion_point(field_list:autofill.risk.Fingerprint.MachineCharacteristics.plugin)
  return plugin_;
}

// optional int64 utc_offset_ms = 6;
inline bool Fingerprint_MachineCharacteristics::_internal_has_utc_offset_ms() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool Fingerprint_MachineCharacteristics::has_utc_offset_ms() const {
  return _internal_has_utc_offset_ms();
}
inline void Fingerprint_MachineCharacteristics::clear_utc_offset_ms() {
  utc_offset_ms_ = int64_t{0};
  _has_bits_[0] &= ~0x00000800u;
}
inline int64_t Fingerprint_MachineCharacteristics::_internal_utc_offset_ms() const {
  return utc_offset_ms_;
}
inline int64_t Fingerprint_MachineCharacteristics::utc_offset_ms() const {
  // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.MachineCharacteristics.utc_offset_ms)
  return _internal_utc_offset_ms();
}
inline void Fingerprint_MachineCharacteristics::_internal_set_utc_offset_ms(int64_t value) {
  _has_bits_[0] |= 0x00000800u;
  utc_offset_ms_ = value;
}
inline void Fingerprint_MachineCharacteristics::set_utc_offset_ms(int64_t value) {
  _internal_set_utc_offset_ms(value);
  // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.MachineCharacteristics.utc_offset_ms)
}

// optional string browser_language = 7;
inline bool Fingerprint_MachineCharacteristics::_internal_has_browser_language() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Fingerprint_MachineCharacteristics::has_browser_language() const {
  return _internal_has_browser_language();
}
inline void Fingerprint_MachineCharacteristics::clear_browser_language() {
  browser_language_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Fingerprint_MachineCharacteristics::browser_language() const {
  // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.MachineCharacteristics.browser_language)
  return _internal_browser_language();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Fingerprint_MachineCharacteristics::set_browser_language(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 browser_language_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.MachineCharacteristics.browser_language)
}
inline std::string* Fingerprint_MachineCharacteristics::mutable_browser_language() {
  std::string* _s = _internal_mutable_browser_language();
  // @@protoc_insertion_point(field_mutable:autofill.risk.Fingerprint.MachineCharacteristics.browser_language)
  return _s;
}
inline const std::string& Fingerprint_MachineCharacteristics::_internal_browser_language() const {
  return browser_language_.Get();
}
inline void Fingerprint_MachineCharacteristics::_internal_set_browser_language(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  browser_language_.Set(value, GetArenaForAllocation());
}
inline std::string* Fingerprint_MachineCharacteristics::_internal_mutable_browser_language() {
  _has_bits_[0] |= 0x00000002u;
  return browser_language_.Mutable(GetArenaForAllocation());
}
inline std::string* Fingerprint_MachineCharacteristics::release_browser_language() {
  // @@protoc_insertion_point(field_release:autofill.risk.Fingerprint.MachineCharacteristics.browser_language)
  if (!_internal_has_browser_language()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = browser_language_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (browser_language_.IsDefault()) {
    browser_language_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Fingerprint_MachineCharacteristics::set_allocated_browser_language(std::string* browser_language) {
  if (browser_language != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  browser_language_.SetAllocated(browser_language, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (browser_language_.IsDefault()) {
    browser_language_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill.risk.Fingerprint.MachineCharacteristics.browser_language)
}

// repeated string requested_language = 8;
inline int Fingerprint_MachineCharacteristics::_internal_requested_language_size() const {
  return requested_language_.size();
}
inline int Fingerprint_MachineCharacteristics::requested_language_size() const {
  return _internal_requested_language_size();
}
inline void Fingerprint_MachineCharacteristics::clear_requested_language() {
  requested_language_.Clear();
}
inline std::string* Fingerprint_MachineCharacteristics::add_requested_language() {
  std::string* _s = _internal_add_requested_language();
  // @@protoc_insertion_point(field_add_mutable:autofill.risk.Fingerprint.MachineCharacteristics.requested_language)
  return _s;
}
inline const std::string& Fingerprint_MachineCharacteristics::_internal_requested_language(int index) const {
  return requested_language_.Get(index);
}
inline const std::string& Fingerprint_MachineCharacteristics::requested_language(int index) const {
  // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.MachineCharacteristics.requested_language)
  return _internal_requested_language(index);
}
inline std::string* Fingerprint_MachineCharacteristics::mutable_requested_language(int index) {
  // @@protoc_insertion_point(field_mutable:autofill.risk.Fingerprint.MachineCharacteristics.requested_language)
  return requested_language_.Mutable(index);
}
inline void Fingerprint_MachineCharacteristics::set_requested_language(int index, const std::string& value) {
  requested_language_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.MachineCharacteristics.requested_language)
}
inline void Fingerprint_MachineCharacteristics::set_requested_language(int index, std::string&& value) {
  requested_language_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.MachineCharacteristics.requested_language)
}
inline void Fingerprint_MachineCharacteristics::set_requested_language(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  requested_language_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:autofill.risk.Fingerprint.MachineCharacteristics.requested_language)
}
inline void Fingerprint_MachineCharacteristics::set_requested_language(int index, const char* value, size_t size) {
  requested_language_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:autofill.risk.Fingerprint.MachineCharacteristics.requested_language)
}
inline std::string* Fingerprint_MachineCharacteristics::_internal_add_requested_language() {
  return requested_language_.Add();
}
inline void Fingerprint_MachineCharacteristics::add_requested_language(const std::string& value) {
  requested_language_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:autofill.risk.Fingerprint.MachineCharacteristics.requested_language)
}
inline void Fingerprint_MachineCharacteristics::add_requested_language(std::string&& value) {
  requested_language_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:autofill.risk.Fingerprint.MachineCharacteristics.requested_language)
}
inline void Fingerprint_MachineCharacteristics::add_requested_language(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  requested_language_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:autofill.risk.Fingerprint.MachineCharacteristics.requested_language)
}
inline void Fingerprint_MachineCharacteristics::add_requested_language(const char* value, size_t size) {
  requested_language_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:autofill.risk.Fingerprint.MachineCharacteristics.requested_language)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Fingerprint_MachineCharacteristics::requested_language() const {
  // @@protoc_insertion_point(field_list:autofill.risk.Fingerprint.MachineCharacteristics.requested_language)
  return requested_language_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Fingerprint_MachineCharacteristics::mutable_requested_language() {
  // @@protoc_insertion_point(field_mutable_list:autofill.risk.Fingerprint.MachineCharacteristics.requested_language)
  return &requested_language_;
}

// optional string charset = 9;
inline bool Fingerprint_MachineCharacteristics::_internal_has_charset() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Fingerprint_MachineCharacteristics::has_charset() const {
  return _internal_has_charset();
}
inline void Fingerprint_MachineCharacteristics::clear_charset() {
  charset_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& Fingerprint_MachineCharacteristics::charset() const {
  // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.MachineCharacteristics.charset)
  return _internal_charset();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Fingerprint_MachineCharacteristics::set_charset(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 charset_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.MachineCharacteristics.charset)
}
inline std::string* Fingerprint_MachineCharacteristics::mutable_charset() {
  std::string* _s = _internal_mutable_charset();
  // @@protoc_insertion_point(field_mutable:autofill.risk.Fingerprint.MachineCharacteristics.charset)
  return _s;
}
inline const std::string& Fingerprint_MachineCharacteristics::_internal_charset() const {
  return charset_.Get();
}
inline void Fingerprint_MachineCharacteristics::_internal_set_charset(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  charset_.Set(value, GetArenaForAllocation());
}
inline std::string* Fingerprint_MachineCharacteristics::_internal_mutable_charset() {
  _has_bits_[0] |= 0x00000004u;
  return charset_.Mutable(GetArenaForAllocation());
}
inline std::string* Fingerprint_MachineCharacteristics::release_charset() {
  // @@protoc_insertion_point(field_release:autofill.risk.Fingerprint.MachineCharacteristics.charset)
  if (!_internal_has_charset()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = charset_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (charset_.IsDefault()) {
    charset_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Fingerprint_MachineCharacteristics::set_allocated_charset(std::string* charset) {
  if (charset != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  charset_.SetAllocated(charset, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (charset_.IsDefault()) {
    charset_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill.risk.Fingerprint.MachineCharacteristics.charset)
}

// optional int32 screen_count = 10;
inline bool Fingerprint_MachineCharacteristics::_internal_has_screen_count() const {
  bool value = (_has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool Fingerprint_MachineCharacteristics::has_screen_count() const {
  return _internal_has_screen_count();
}
inline void Fingerprint_MachineCharacteristics::clear_screen_count() {
  screen_count_ = 0;
  _has_bits_[0] &= ~0x00001000u;
}
inline int32_t Fingerprint_MachineCharacteristics::_internal_screen_count() const {
  return screen_count_;
}
inline int32_t Fingerprint_MachineCharacteristics::screen_count() const {
  // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.MachineCharacteristics.screen_count)
  return _internal_screen_count();
}
inline void Fingerprint_MachineCharacteristics::_internal_set_screen_count(int32_t value) {
  _has_bits_[0] |= 0x00001000u;
  screen_count_ = value;
}
inline void Fingerprint_MachineCharacteristics::set_screen_count(int32_t value) {
  _internal_set_screen_count(value);
  // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.MachineCharacteristics.screen_count)
}

// optional .autofill.risk.Fingerprint.Dimension screen_size = 11;
inline bool Fingerprint_MachineCharacteristics::_internal_has_screen_size() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || screen_size_ != nullptr);
  return value;
}
inline bool Fingerprint_MachineCharacteristics::has_screen_size() const {
  return _internal_has_screen_size();
}
inline void Fingerprint_MachineCharacteristics::clear_screen_size() {
  if (screen_size_ != nullptr) screen_size_->Clear();
  _has_bits_[0] &= ~0x00000020u;
}
inline const ::autofill::risk::Fingerprint_Dimension& Fingerprint_MachineCharacteristics::_internal_screen_size() const {
  const ::autofill::risk::Fingerprint_Dimension* p = screen_size_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill::risk::Fingerprint_Dimension&>(
      ::autofill::risk::_Fingerprint_Dimension_default_instance_);
}
inline const ::autofill::risk::Fingerprint_Dimension& Fingerprint_MachineCharacteristics::screen_size() const {
  // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.MachineCharacteristics.screen_size)
  return _internal_screen_size();
}
inline void Fingerprint_MachineCharacteristics::unsafe_arena_set_allocated_screen_size(
    ::autofill::risk::Fingerprint_Dimension* screen_size) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(screen_size_);
  }
  screen_size_ = screen_size;
  if (screen_size) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill.risk.Fingerprint.MachineCharacteristics.screen_size)
}
inline ::autofill::risk::Fingerprint_Dimension* Fingerprint_MachineCharacteristics::release_screen_size() {
  _has_bits_[0] &= ~0x00000020u;
  ::autofill::risk::Fingerprint_Dimension* temp = screen_size_;
  screen_size_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill::risk::Fingerprint_Dimension* Fingerprint_MachineCharacteristics::unsafe_arena_release_screen_size() {
  // @@protoc_insertion_point(field_release:autofill.risk.Fingerprint.MachineCharacteristics.screen_size)
  _has_bits_[0] &= ~0x00000020u;
  ::autofill::risk::Fingerprint_Dimension* temp = screen_size_;
  screen_size_ = nullptr;
  return temp;
}
inline ::autofill::risk::Fingerprint_Dimension* Fingerprint_MachineCharacteristics::_internal_mutable_screen_size() {
  _has_bits_[0] |= 0x00000020u;
  if (screen_size_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill::risk::Fingerprint_Dimension>(GetArenaForAllocation());
    screen_size_ = p;
  }
  return screen_size_;
}
inline ::autofill::risk::Fingerprint_Dimension* Fingerprint_MachineCharacteristics::mutable_screen_size() {
  ::autofill::risk::Fingerprint_Dimension* _msg = _internal_mutable_screen_size();
  // @@protoc_insertion_point(field_mutable:autofill.risk.Fingerprint.MachineCharacteristics.screen_size)
  return _msg;
}
inline void Fingerprint_MachineCharacteristics::set_allocated_screen_size(::autofill::risk::Fingerprint_Dimension* screen_size) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete screen_size_;
  }
  if (screen_size) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(screen_size);
    if (message_arena != submessage_arena) {
      screen_size = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, screen_size, submessage_arena);
    }
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  screen_size_ = screen_size;
  // @@protoc_insertion_point(field_set_allocated:autofill.risk.Fingerprint.MachineCharacteristics.screen_size)
}

// optional int32 screen_color_depth = 12;
inline bool Fingerprint_MachineCharacteristics::_internal_has_screen_color_depth() const {
  bool value = (_has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool Fingerprint_MachineCharacteristics::has_screen_color_depth() const {
  return _internal_has_screen_color_depth();
}
inline void Fingerprint_MachineCharacteristics::clear_screen_color_depth() {
  screen_color_depth_ = 0;
  _has_bits_[0] &= ~0x00002000u;
}
inline int32_t Fingerprint_MachineCharacteristics::_internal_screen_color_depth() const {
  return screen_color_depth_;
}
inline int32_t Fingerprint_MachineCharacteristics::screen_color_depth() const {
  // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.MachineCharacteristics.screen_color_depth)
  return _internal_screen_color_depth();
}
inline void Fingerprint_MachineCharacteristics::_internal_set_screen_color_depth(int32_t value) {
  _has_bits_[0] |= 0x00002000u;
  screen_color_depth_ = value;
}
inline void Fingerprint_MachineCharacteristics::set_screen_color_depth(int32_t value) {
  _internal_set_screen_color_depth(value);
  // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.MachineCharacteristics.screen_color_depth)
}

// optional .autofill.risk.Fingerprint.Dimension unavailable_screen_size = 13;
inline bool Fingerprint_MachineCharacteristics::_internal_has_unavailable_screen_size() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || unavailable_screen_size_ != nullptr);
  return value;
}
inline bool Fingerprint_MachineCharacteristics::has_unavailable_screen_size() const {
  return _internal_has_unavailable_screen_size();
}
inline void Fingerprint_MachineCharacteristics::clear_unavailable_screen_size() {
  if (unavailable_screen_size_ != nullptr) unavailable_screen_size_->Clear();
  _has_bits_[0] &= ~0x00000040u;
}
inline const ::autofill::risk::Fingerprint_Dimension& Fingerprint_MachineCharacteristics::_internal_unavailable_screen_size() const {
  const ::autofill::risk::Fingerprint_Dimension* p = unavailable_screen_size_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill::risk::Fingerprint_Dimension&>(
      ::autofill::risk::_Fingerprint_Dimension_default_instance_);
}
inline const ::autofill::risk::Fingerprint_Dimension& Fingerprint_MachineCharacteristics::unavailable_screen_size() const {
  // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.MachineCharacteristics.unavailable_screen_size)
  return _internal_unavailable_screen_size();
}
inline void Fingerprint_MachineCharacteristics::unsafe_arena_set_allocated_unavailable_screen_size(
    ::autofill::risk::Fingerprint_Dimension* unavailable_screen_size) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(unavailable_screen_size_);
  }
  unavailable_screen_size_ = unavailable_screen_size;
  if (unavailable_screen_size) {
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill.risk.Fingerprint.MachineCharacteristics.unavailable_screen_size)
}
inline ::autofill::risk::Fingerprint_Dimension* Fingerprint_MachineCharacteristics::release_unavailable_screen_size() {
  _has_bits_[0] &= ~0x00000040u;
  ::autofill::risk::Fingerprint_Dimension* temp = unavailable_screen_size_;
  unavailable_screen_size_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill::risk::Fingerprint_Dimension* Fingerprint_MachineCharacteristics::unsafe_arena_release_unavailable_screen_size() {
  // @@protoc_insertion_point(field_release:autofill.risk.Fingerprint.MachineCharacteristics.unavailable_screen_size)
  _has_bits_[0] &= ~0x00000040u;
  ::autofill::risk::Fingerprint_Dimension* temp = unavailable_screen_size_;
  unavailable_screen_size_ = nullptr;
  return temp;
}
inline ::autofill::risk::Fingerprint_Dimension* Fingerprint_MachineCharacteristics::_internal_mutable_unavailable_screen_size() {
  _has_bits_[0] |= 0x00000040u;
  if (unavailable_screen_size_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill::risk::Fingerprint_Dimension>(GetArenaForAllocation());
    unavailable_screen_size_ = p;
  }
  return unavailable_screen_size_;
}
inline ::autofill::risk::Fingerprint_Dimension* Fingerprint_MachineCharacteristics::mutable_unavailable_screen_size() {
  ::autofill::risk::Fingerprint_Dimension* _msg = _internal_mutable_unavailable_screen_size();
  // @@protoc_insertion_point(field_mutable:autofill.risk.Fingerprint.MachineCharacteristics.unavailable_screen_size)
  return _msg;
}
inline void Fingerprint_MachineCharacteristics::set_allocated_unavailable_screen_size(::autofill::risk::Fingerprint_Dimension* unavailable_screen_size) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete unavailable_screen_size_;
  }
  if (unavailable_screen_size) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(unavailable_screen_size);
    if (message_arena != submessage_arena) {
      unavailable_screen_size = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, unavailable_screen_size, submessage_arena);
    }
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  unavailable_screen_size_ = unavailable_screen_size;
  // @@protoc_insertion_point(field_set_allocated:autofill.risk.Fingerprint.MachineCharacteristics.unavailable_screen_size)
}

// optional string user_agent = 14;
inline bool Fingerprint_MachineCharacteristics::_internal_has_user_agent() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Fingerprint_MachineCharacteristics::has_user_agent() const {
  return _internal_has_user_agent();
}
inline void Fingerprint_MachineCharacteristics::clear_user_agent() {
  user_agent_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& Fingerprint_MachineCharacteristics::user_agent() const {
  // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.MachineCharacteristics.user_agent)
  return _internal_user_agent();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Fingerprint_MachineCharacteristics::set_user_agent(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 user_agent_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.MachineCharacteristics.user_agent)
}
inline std::string* Fingerprint_MachineCharacteristics::mutable_user_agent() {
  std::string* _s = _internal_mutable_user_agent();
  // @@protoc_insertion_point(field_mutable:autofill.risk.Fingerprint.MachineCharacteristics.user_agent)
  return _s;
}
inline const std::string& Fingerprint_MachineCharacteristics::_internal_user_agent() const {
  return user_agent_.Get();
}
inline void Fingerprint_MachineCharacteristics::_internal_set_user_agent(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  user_agent_.Set(value, GetArenaForAllocation());
}
inline std::string* Fingerprint_MachineCharacteristics::_internal_mutable_user_agent() {
  _has_bits_[0] |= 0x00000008u;
  return user_agent_.Mutable(GetArenaForAllocation());
}
inline std::string* Fingerprint_MachineCharacteristics::release_user_agent() {
  // @@protoc_insertion_point(field_release:autofill.risk.Fingerprint.MachineCharacteristics.user_agent)
  if (!_internal_has_user_agent()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  auto* p = user_agent_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (user_agent_.IsDefault()) {
    user_agent_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Fingerprint_MachineCharacteristics::set_allocated_user_agent(std::string* user_agent) {
  if (user_agent != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  user_agent_.SetAllocated(user_agent, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (user_agent_.IsDefault()) {
    user_agent_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill.risk.Fingerprint.MachineCharacteristics.user_agent)
}

// repeated int32 partition_size = 15;
inline int Fingerprint_MachineCharacteristics::_internal_partition_size_size() const {
  return partition_size_.size();
}
inline int Fingerprint_MachineCharacteristics::partition_size_size() const {
  return _internal_partition_size_size();
}
inline void Fingerprint_MachineCharacteristics::clear_partition_size() {
  partition_size_.Clear();
}
inline int32_t Fingerprint_MachineCharacteristics::_internal_partition_size(int index) const {
  return partition_size_.Get(index);
}
inline int32_t Fingerprint_MachineCharacteristics::partition_size(int index) const {
  // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.MachineCharacteristics.partition_size)
  return _internal_partition_size(index);
}
inline void Fingerprint_MachineCharacteristics::set_partition_size(int index, int32_t value) {
  partition_size_.Set(index, value);
  // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.MachineCharacteristics.partition_size)
}
inline void Fingerprint_MachineCharacteristics::_internal_add_partition_size(int32_t value) {
  partition_size_.Add(value);
}
inline void Fingerprint_MachineCharacteristics::add_partition_size(int32_t value) {
  _internal_add_partition_size(value);
  // @@protoc_insertion_point(field_add:autofill.risk.Fingerprint.MachineCharacteristics.partition_size)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
Fingerprint_MachineCharacteristics::_internal_partition_size() const {
  return partition_size_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
Fingerprint_MachineCharacteristics::partition_size() const {
  // @@protoc_insertion_point(field_list:autofill.risk.Fingerprint.MachineCharacteristics.partition_size)
  return _internal_partition_size();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
Fingerprint_MachineCharacteristics::_internal_mutable_partition_size() {
  return &partition_size_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
Fingerprint_MachineCharacteristics::mutable_partition_size() {
  // @@protoc_insertion_point(field_mutable_list:autofill.risk.Fingerprint.MachineCharacteristics.partition_size)
  return _internal_mutable_partition_size();
}

// optional .autofill.risk.Fingerprint.MachineCharacteristics.Cpu cpu = 16;
inline bool Fingerprint_MachineCharacteristics::_internal_has_cpu() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!value || cpu_ != nullptr);
  return value;
}
inline bool Fingerprint_MachineCharacteristics::has_cpu() const {
  return _internal_has_cpu();
}
inline void Fingerprint_MachineCharacteristics::clear_cpu() {
  if (cpu_ != nullptr) cpu_->Clear();
  _has_bits_[0] &= ~0x00000080u;
}
inline const ::autofill::risk::Fingerprint_MachineCharacteristics_Cpu& Fingerprint_MachineCharacteristics::_internal_cpu() const {
  const ::autofill::risk::Fingerprint_MachineCharacteristics_Cpu* p = cpu_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill::risk::Fingerprint_MachineCharacteristics_Cpu&>(
      ::autofill::risk::_Fingerprint_MachineCharacteristics_Cpu_default_instance_);
}
inline const ::autofill::risk::Fingerprint_MachineCharacteristics_Cpu& Fingerprint_MachineCharacteristics::cpu() const {
  // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.MachineCharacteristics.cpu)
  return _internal_cpu();
}
inline void Fingerprint_MachineCharacteristics::unsafe_arena_set_allocated_cpu(
    ::autofill::risk::Fingerprint_MachineCharacteristics_Cpu* cpu) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(cpu_);
  }
  cpu_ = cpu;
  if (cpu) {
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill.risk.Fingerprint.MachineCharacteristics.cpu)
}
inline ::autofill::risk::Fingerprint_MachineCharacteristics_Cpu* Fingerprint_MachineCharacteristics::release_cpu() {
  _has_bits_[0] &= ~0x00000080u;
  ::autofill::risk::Fingerprint_MachineCharacteristics_Cpu* temp = cpu_;
  cpu_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill::risk::Fingerprint_MachineCharacteristics_Cpu* Fingerprint_MachineCharacteristics::unsafe_arena_release_cpu() {
  // @@protoc_insertion_point(field_release:autofill.risk.Fingerprint.MachineCharacteristics.cpu)
  _has_bits_[0] &= ~0x00000080u;
  ::autofill::risk::Fingerprint_MachineCharacteristics_Cpu* temp = cpu_;
  cpu_ = nullptr;
  return temp;
}
inline ::autofill::risk::Fingerprint_MachineCharacteristics_Cpu* Fingerprint_MachineCharacteristics::_internal_mutable_cpu() {
  _has_bits_[0] |= 0x00000080u;
  if (cpu_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill::risk::Fingerprint_MachineCharacteristics_Cpu>(GetArenaForAllocation());
    cpu_ = p;
  }
  return cpu_;
}
inline ::autofill::risk::Fingerprint_MachineCharacteristics_Cpu* Fingerprint_MachineCharacteristics::mutable_cpu() {
  ::autofill::risk::Fingerprint_MachineCharacteristics_Cpu* _msg = _internal_mutable_cpu();
  // @@protoc_insertion_point(field_mutable:autofill.risk.Fingerprint.MachineCharacteristics.cpu)
  return _msg;
}
inline void Fingerprint_MachineCharacteristics::set_allocated_cpu(::autofill::risk::Fingerprint_MachineCharacteristics_Cpu* cpu) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete cpu_;
  }
  if (cpu) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(cpu);
    if (message_arena != submessage_arena) {
      cpu = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cpu, submessage_arena);
    }
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  cpu_ = cpu;
  // @@protoc_insertion_point(field_set_allocated:autofill.risk.Fingerprint.MachineCharacteristics.cpu)
}

// optional int64 ram = 17;
inline bool Fingerprint_MachineCharacteristics::_internal_has_ram() const {
  bool value = (_has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool Fingerprint_MachineCharacteristics::has_ram() const {
  return _internal_has_ram();
}
inline void Fingerprint_MachineCharacteristics::clear_ram() {
  ram_ = int64_t{0};
  _has_bits_[0] &= ~0x00004000u;
}
inline int64_t Fingerprint_MachineCharacteristics::_internal_ram() const {
  return ram_;
}
inline int64_t Fingerprint_MachineCharacteristics::ram() const {
  // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.MachineCharacteristics.ram)
  return _internal_ram();
}
inline void Fingerprint_MachineCharacteristics::_internal_set_ram(int64_t value) {
  _has_bits_[0] |= 0x00004000u;
  ram_ = value;
}
inline void Fingerprint_MachineCharacteristics::set_ram(int64_t value) {
  _internal_set_ram(value);
  // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.MachineCharacteristics.ram)
}

// optional .autofill.risk.Fingerprint.MachineCharacteristics.Graphics graphics_card = 18;
inline bool Fingerprint_MachineCharacteristics::_internal_has_graphics_card() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  PROTOBUF_ASSUME(!value || graphics_card_ != nullptr);
  return value;
}
inline bool Fingerprint_MachineCharacteristics::has_graphics_card() const {
  return _internal_has_graphics_card();
}
inline void Fingerprint_MachineCharacteristics::clear_graphics_card() {
  if (graphics_card_ != nullptr) graphics_card_->Clear();
  _has_bits_[0] &= ~0x00000100u;
}
inline const ::autofill::risk::Fingerprint_MachineCharacteristics_Graphics& Fingerprint_MachineCharacteristics::_internal_graphics_card() const {
  const ::autofill::risk::Fingerprint_MachineCharacteristics_Graphics* p = graphics_card_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill::risk::Fingerprint_MachineCharacteristics_Graphics&>(
      ::autofill::risk::_Fingerprint_MachineCharacteristics_Graphics_default_instance_);
}
inline const ::autofill::risk::Fingerprint_MachineCharacteristics_Graphics& Fingerprint_MachineCharacteristics::graphics_card() const {
  // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.MachineCharacteristics.graphics_card)
  return _internal_graphics_card();
}
inline void Fingerprint_MachineCharacteristics::unsafe_arena_set_allocated_graphics_card(
    ::autofill::risk::Fingerprint_MachineCharacteristics_Graphics* graphics_card) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(graphics_card_);
  }
  graphics_card_ = graphics_card;
  if (graphics_card) {
    _has_bits_[0] |= 0x00000100u;
  } else {
    _has_bits_[0] &= ~0x00000100u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill.risk.Fingerprint.MachineCharacteristics.graphics_card)
}
inline ::autofill::risk::Fingerprint_MachineCharacteristics_Graphics* Fingerprint_MachineCharacteristics::release_graphics_card() {
  _has_bits_[0] &= ~0x00000100u;
  ::autofill::risk::Fingerprint_MachineCharacteristics_Graphics* temp = graphics_card_;
  graphics_card_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill::risk::Fingerprint_MachineCharacteristics_Graphics* Fingerprint_MachineCharacteristics::unsafe_arena_release_graphics_card() {
  // @@protoc_insertion_point(field_release:autofill.risk.Fingerprint.MachineCharacteristics.graphics_card)
  _has_bits_[0] &= ~0x00000100u;
  ::autofill::risk::Fingerprint_MachineCharacteristics_Graphics* temp = graphics_card_;
  graphics_card_ = nullptr;
  return temp;
}
inline ::autofill::risk::Fingerprint_MachineCharacteristics_Graphics* Fingerprint_MachineCharacteristics::_internal_mutable_graphics_card() {
  _has_bits_[0] |= 0x00000100u;
  if (graphics_card_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill::risk::Fingerprint_MachineCharacteristics_Graphics>(GetArenaForAllocation());
    graphics_card_ = p;
  }
  return graphics_card_;
}
inline ::autofill::risk::Fingerprint_MachineCharacteristics_Graphics* Fingerprint_MachineCharacteristics::mutable_graphics_card() {
  ::autofill::risk::Fingerprint_MachineCharacteristics_Graphics* _msg = _internal_mutable_graphics_card();
  // @@protoc_insertion_point(field_mutable:autofill.risk.Fingerprint.MachineCharacteristics.graphics_card)
  return _msg;
}
inline void Fingerprint_MachineCharacteristics::set_allocated_graphics_card(::autofill::risk::Fingerprint_MachineCharacteristics_Graphics* graphics_card) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete graphics_card_;
  }
  if (graphics_card) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(graphics_card);
    if (message_arena != submessage_arena) {
      graphics_card = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, graphics_card, submessage_arena);
    }
    _has_bits_[0] |= 0x00000100u;
  } else {
    _has_bits_[0] &= ~0x00000100u;
  }
  graphics_card_ = graphics_card;
  // @@protoc_insertion_point(field_set_allocated:autofill.risk.Fingerprint.MachineCharacteristics.graphics_card)
}

// optional string browser_build = 19;
inline bool Fingerprint_MachineCharacteristics::_internal_has_browser_build() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool Fingerprint_MachineCharacteristics::has_browser_build() const {
  return _internal_has_browser_build();
}
inline void Fingerprint_MachineCharacteristics::clear_browser_build() {
  browser_build_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000010u;
}
inline const std::string& Fingerprint_MachineCharacteristics::browser_build() const {
  // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.MachineCharacteristics.browser_build)
  return _internal_browser_build();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Fingerprint_MachineCharacteristics::set_browser_build(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000010u;
 browser_build_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.MachineCharacteristics.browser_build)
}
inline std::string* Fingerprint_MachineCharacteristics::mutable_browser_build() {
  std::string* _s = _internal_mutable_browser_build();
  // @@protoc_insertion_point(field_mutable:autofill.risk.Fingerprint.MachineCharacteristics.browser_build)
  return _s;
}
inline const std::string& Fingerprint_MachineCharacteristics::_internal_browser_build() const {
  return browser_build_.Get();
}
inline void Fingerprint_MachineCharacteristics::_internal_set_browser_build(const std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  browser_build_.Set(value, GetArenaForAllocation());
}
inline std::string* Fingerprint_MachineCharacteristics::_internal_mutable_browser_build() {
  _has_bits_[0] |= 0x00000010u;
  return browser_build_.Mutable(GetArenaForAllocation());
}
inline std::string* Fingerprint_MachineCharacteristics::release_browser_build() {
  // @@protoc_insertion_point(field_release:autofill.risk.Fingerprint.MachineCharacteristics.browser_build)
  if (!_internal_has_browser_build()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  auto* p = browser_build_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (browser_build_.IsDefault()) {
    browser_build_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Fingerprint_MachineCharacteristics::set_allocated_browser_build(std::string* browser_build) {
  if (browser_build != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  browser_build_.SetAllocated(browser_build, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (browser_build_.IsDefault()) {
    browser_build_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill.risk.Fingerprint.MachineCharacteristics.browser_build)
}

// optional .autofill.risk.Fingerprint.MachineCharacteristics.BrowserFeature browser_feature = 20;
inline bool Fingerprint_MachineCharacteristics::_internal_has_browser_feature() const {
  bool value = (_has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline bool Fingerprint_MachineCharacteristics::has_browser_feature() const {
  return _internal_has_browser_feature();
}
inline void Fingerprint_MachineCharacteristics::clear_browser_feature() {
  browser_feature_ = 0;
  _has_bits_[0] &= ~0x00008000u;
}
inline ::autofill::risk::Fingerprint_MachineCharacteristics_BrowserFeature Fingerprint_MachineCharacteristics::_internal_browser_feature() const {
  return static_cast< ::autofill::risk::Fingerprint_MachineCharacteristics_BrowserFeature >(browser_feature_);
}
inline ::autofill::risk::Fingerprint_MachineCharacteristics_BrowserFeature Fingerprint_MachineCharacteristics::browser_feature() const {
  // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.MachineCharacteristics.browser_feature)
  return _internal_browser_feature();
}
inline void Fingerprint_MachineCharacteristics::_internal_set_browser_feature(::autofill::risk::Fingerprint_MachineCharacteristics_BrowserFeature value) {
  assert(::autofill::risk::Fingerprint_MachineCharacteristics_BrowserFeature_IsValid(value));
  _has_bits_[0] |= 0x00008000u;
  browser_feature_ = value;
}
inline void Fingerprint_MachineCharacteristics::set_browser_feature(::autofill::risk::Fingerprint_MachineCharacteristics_BrowserFeature value) {
  _internal_set_browser_feature(value);
  // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.MachineCharacteristics.browser_feature)
}

// -------------------------------------------------------------------

// Fingerprint_TransientState

// optional .autofill.risk.Fingerprint.Dimension inner_window_size = 1;
inline bool Fingerprint_TransientState::_internal_has_inner_window_size() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || inner_window_size_ != nullptr);
  return value;
}
inline bool Fingerprint_TransientState::has_inner_window_size() const {
  return _internal_has_inner_window_size();
}
inline void Fingerprint_TransientState::clear_inner_window_size() {
  if (inner_window_size_ != nullptr) inner_window_size_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::autofill::risk::Fingerprint_Dimension& Fingerprint_TransientState::_internal_inner_window_size() const {
  const ::autofill::risk::Fingerprint_Dimension* p = inner_window_size_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill::risk::Fingerprint_Dimension&>(
      ::autofill::risk::_Fingerprint_Dimension_default_instance_);
}
inline const ::autofill::risk::Fingerprint_Dimension& Fingerprint_TransientState::inner_window_size() const {
  // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.TransientState.inner_window_size)
  return _internal_inner_window_size();
}
inline void Fingerprint_TransientState::unsafe_arena_set_allocated_inner_window_size(
    ::autofill::risk::Fingerprint_Dimension* inner_window_size) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(inner_window_size_);
  }
  inner_window_size_ = inner_window_size;
  if (inner_window_size) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill.risk.Fingerprint.TransientState.inner_window_size)
}
inline ::autofill::risk::Fingerprint_Dimension* Fingerprint_TransientState::release_inner_window_size() {
  _has_bits_[0] &= ~0x00000001u;
  ::autofill::risk::Fingerprint_Dimension* temp = inner_window_size_;
  inner_window_size_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill::risk::Fingerprint_Dimension* Fingerprint_TransientState::unsafe_arena_release_inner_window_size() {
  // @@protoc_insertion_point(field_release:autofill.risk.Fingerprint.TransientState.inner_window_size)
  _has_bits_[0] &= ~0x00000001u;
  ::autofill::risk::Fingerprint_Dimension* temp = inner_window_size_;
  inner_window_size_ = nullptr;
  return temp;
}
inline ::autofill::risk::Fingerprint_Dimension* Fingerprint_TransientState::_internal_mutable_inner_window_size() {
  _has_bits_[0] |= 0x00000001u;
  if (inner_window_size_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill::risk::Fingerprint_Dimension>(GetArenaForAllocation());
    inner_window_size_ = p;
  }
  return inner_window_size_;
}
inline ::autofill::risk::Fingerprint_Dimension* Fingerprint_TransientState::mutable_inner_window_size() {
  ::autofill::risk::Fingerprint_Dimension* _msg = _internal_mutable_inner_window_size();
  // @@protoc_insertion_point(field_mutable:autofill.risk.Fingerprint.TransientState.inner_window_size)
  return _msg;
}
inline void Fingerprint_TransientState::set_allocated_inner_window_size(::autofill::risk::Fingerprint_Dimension* inner_window_size) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete inner_window_size_;
  }
  if (inner_window_size) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(inner_window_size);
    if (message_arena != submessage_arena) {
      inner_window_size = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, inner_window_size, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  inner_window_size_ = inner_window_size;
  // @@protoc_insertion_point(field_set_allocated:autofill.risk.Fingerprint.TransientState.inner_window_size)
}

// optional .autofill.risk.Fingerprint.Dimension outer_window_size = 2;
inline bool Fingerprint_TransientState::_internal_has_outer_window_size() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || outer_window_size_ != nullptr);
  return value;
}
inline bool Fingerprint_TransientState::has_outer_window_size() const {
  return _internal_has_outer_window_size();
}
inline void Fingerprint_TransientState::clear_outer_window_size() {
  if (outer_window_size_ != nullptr) outer_window_size_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::autofill::risk::Fingerprint_Dimension& Fingerprint_TransientState::_internal_outer_window_size() const {
  const ::autofill::risk::Fingerprint_Dimension* p = outer_window_size_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill::risk::Fingerprint_Dimension&>(
      ::autofill::risk::_Fingerprint_Dimension_default_instance_);
}
inline const ::autofill::risk::Fingerprint_Dimension& Fingerprint_TransientState::outer_window_size() const {
  // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.TransientState.outer_window_size)
  return _internal_outer_window_size();
}
inline void Fingerprint_TransientState::unsafe_arena_set_allocated_outer_window_size(
    ::autofill::risk::Fingerprint_Dimension* outer_window_size) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(outer_window_size_);
  }
  outer_window_size_ = outer_window_size;
  if (outer_window_size) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill.risk.Fingerprint.TransientState.outer_window_size)
}
inline ::autofill::risk::Fingerprint_Dimension* Fingerprint_TransientState::release_outer_window_size() {
  _has_bits_[0] &= ~0x00000002u;
  ::autofill::risk::Fingerprint_Dimension* temp = outer_window_size_;
  outer_window_size_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill::risk::Fingerprint_Dimension* Fingerprint_TransientState::unsafe_arena_release_outer_window_size() {
  // @@protoc_insertion_point(field_release:autofill.risk.Fingerprint.TransientState.outer_window_size)
  _has_bits_[0] &= ~0x00000002u;
  ::autofill::risk::Fingerprint_Dimension* temp = outer_window_size_;
  outer_window_size_ = nullptr;
  return temp;
}
inline ::autofill::risk::Fingerprint_Dimension* Fingerprint_TransientState::_internal_mutable_outer_window_size() {
  _has_bits_[0] |= 0x00000002u;
  if (outer_window_size_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill::risk::Fingerprint_Dimension>(GetArenaForAllocation());
    outer_window_size_ = p;
  }
  return outer_window_size_;
}
inline ::autofill::risk::Fingerprint_Dimension* Fingerprint_TransientState::mutable_outer_window_size() {
  ::autofill::risk::Fingerprint_Dimension* _msg = _internal_mutable_outer_window_size();
  // @@protoc_insertion_point(field_mutable:autofill.risk.Fingerprint.TransientState.outer_window_size)
  return _msg;
}
inline void Fingerprint_TransientState::set_allocated_outer_window_size(::autofill::risk::Fingerprint_Dimension* outer_window_size) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete outer_window_size_;
  }
  if (outer_window_size) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(outer_window_size);
    if (message_arena != submessage_arena) {
      outer_window_size = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, outer_window_size, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  outer_window_size_ = outer_window_size;
  // @@protoc_insertion_point(field_set_allocated:autofill.risk.Fingerprint.TransientState.outer_window_size)
}

// -------------------------------------------------------------------

// Fingerprint_Performance

// optional float bandwidth = 1;
inline bool Fingerprint_Performance::_internal_has_bandwidth() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Fingerprint_Performance::has_bandwidth() const {
  return _internal_has_bandwidth();
}
inline void Fingerprint_Performance::clear_bandwidth() {
  bandwidth_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline float Fingerprint_Performance::_internal_bandwidth() const {
  return bandwidth_;
}
inline float Fingerprint_Performance::bandwidth() const {
  // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.Performance.bandwidth)
  return _internal_bandwidth();
}
inline void Fingerprint_Performance::_internal_set_bandwidth(float value) {
  _has_bits_[0] |= 0x00000002u;
  bandwidth_ = value;
}
inline void Fingerprint_Performance::set_bandwidth(float value) {
  _internal_set_bandwidth(value);
  // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.Performance.bandwidth)
}

// optional bool metered = 2;
inline bool Fingerprint_Performance::_internal_has_metered() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Fingerprint_Performance::has_metered() const {
  return _internal_has_metered();
}
inline void Fingerprint_Performance::clear_metered() {
  metered_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool Fingerprint_Performance::_internal_metered() const {
  return metered_;
}
inline bool Fingerprint_Performance::metered() const {
  // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.Performance.metered)
  return _internal_metered();
}
inline void Fingerprint_Performance::_internal_set_metered(bool value) {
  _has_bits_[0] |= 0x00000004u;
  metered_ = value;
}
inline void Fingerprint_Performance::set_metered(bool value) {
  _internal_set_metered(value);
  // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.Performance.metered)
}

// optional string network_type = 3;
inline bool Fingerprint_Performance::_internal_has_network_type() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Fingerprint_Performance::has_network_type() const {
  return _internal_has_network_type();
}
inline void Fingerprint_Performance::clear_network_type() {
  network_type_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Fingerprint_Performance::network_type() const {
  // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.Performance.network_type)
  return _internal_network_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Fingerprint_Performance::set_network_type(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 network_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.Performance.network_type)
}
inline std::string* Fingerprint_Performance::mutable_network_type() {
  std::string* _s = _internal_mutable_network_type();
  // @@protoc_insertion_point(field_mutable:autofill.risk.Fingerprint.Performance.network_type)
  return _s;
}
inline const std::string& Fingerprint_Performance::_internal_network_type() const {
  return network_type_.Get();
}
inline void Fingerprint_Performance::_internal_set_network_type(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  network_type_.Set(value, GetArenaForAllocation());
}
inline std::string* Fingerprint_Performance::_internal_mutable_network_type() {
  _has_bits_[0] |= 0x00000001u;
  return network_type_.Mutable(GetArenaForAllocation());
}
inline std::string* Fingerprint_Performance::release_network_type() {
  // @@protoc_insertion_point(field_release:autofill.risk.Fingerprint.Performance.network_type)
  if (!_internal_has_network_type()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = network_type_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (network_type_.IsDefault()) {
    network_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Fingerprint_Performance::set_allocated_network_type(std::string* network_type) {
  if (network_type != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  network_type_.SetAllocated(network_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (network_type_.IsDefault()) {
    network_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autofill.risk.Fingerprint.Performance.network_type)
}

// -------------------------------------------------------------------

// Fingerprint_UserCharacteristics_Vector

// optional int32 x = 1;
inline bool Fingerprint_UserCharacteristics_Vector::_internal_has_x() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Fingerprint_UserCharacteristics_Vector::has_x() const {
  return _internal_has_x();
}
inline void Fingerprint_UserCharacteristics_Vector::clear_x() {
  x_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline int32_t Fingerprint_UserCharacteristics_Vector::_internal_x() const {
  return x_;
}
inline int32_t Fingerprint_UserCharacteristics_Vector::x() const {
  // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.UserCharacteristics.Vector.x)
  return _internal_x();
}
inline void Fingerprint_UserCharacteristics_Vector::_internal_set_x(int32_t value) {
  _has_bits_[0] |= 0x00000001u;
  x_ = value;
}
inline void Fingerprint_UserCharacteristics_Vector::set_x(int32_t value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.UserCharacteristics.Vector.x)
}

// optional int32 y = 2;
inline bool Fingerprint_UserCharacteristics_Vector::_internal_has_y() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Fingerprint_UserCharacteristics_Vector::has_y() const {
  return _internal_has_y();
}
inline void Fingerprint_UserCharacteristics_Vector::clear_y() {
  y_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline int32_t Fingerprint_UserCharacteristics_Vector::_internal_y() const {
  return y_;
}
inline int32_t Fingerprint_UserCharacteristics_Vector::y() const {
  // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.UserCharacteristics.Vector.y)
  return _internal_y();
}
inline void Fingerprint_UserCharacteristics_Vector::_internal_set_y(int32_t value) {
  _has_bits_[0] |= 0x00000002u;
  y_ = value;
}
inline void Fingerprint_UserCharacteristics_Vector::set_y(int32_t value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.UserCharacteristics.Vector.y)
}

// optional int32 z = 3;
inline bool Fingerprint_UserCharacteristics_Vector::_internal_has_z() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Fingerprint_UserCharacteristics_Vector::has_z() const {
  return _internal_has_z();
}
inline void Fingerprint_UserCharacteristics_Vector::clear_z() {
  z_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline int32_t Fingerprint_UserCharacteristics_Vector::_internal_z() const {
  return z_;
}
inline int32_t Fingerprint_UserCharacteristics_Vector::z() const {
  // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.UserCharacteristics.Vector.z)
  return _internal_z();
}
inline void Fingerprint_UserCharacteristics_Vector::_internal_set_z(int32_t value) {
  _has_bits_[0] |= 0x00000004u;
  z_ = value;
}
inline void Fingerprint_UserCharacteristics_Vector::set_z(int32_t value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.UserCharacteristics.Vector.z)
}

// -------------------------------------------------------------------

// Fingerprint_UserCharacteristics_Location

// optional double altitude = 1;
inline bool Fingerprint_UserCharacteristics_Location::_internal_has_altitude() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Fingerprint_UserCharacteristics_Location::has_altitude() const {
  return _internal_has_altitude();
}
inline void Fingerprint_UserCharacteristics_Location::clear_altitude() {
  altitude_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline double Fingerprint_UserCharacteristics_Location::_internal_altitude() const {
  return altitude_;
}
inline double Fingerprint_UserCharacteristics_Location::altitude() const {
  // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.UserCharacteristics.Location.altitude)
  return _internal_altitude();
}
inline void Fingerprint_UserCharacteristics_Location::_internal_set_altitude(double value) {
  _has_bits_[0] |= 0x00000001u;
  altitude_ = value;
}
inline void Fingerprint_UserCharacteristics_Location::set_altitude(double value) {
  _internal_set_altitude(value);
  // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.UserCharacteristics.Location.altitude)
}

// optional double latitude = 2;
inline bool Fingerprint_UserCharacteristics_Location::_internal_has_latitude() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Fingerprint_UserCharacteristics_Location::has_latitude() const {
  return _internal_has_latitude();
}
inline void Fingerprint_UserCharacteristics_Location::clear_latitude() {
  latitude_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline double Fingerprint_UserCharacteristics_Location::_internal_latitude() const {
  return latitude_;
}
inline double Fingerprint_UserCharacteristics_Location::latitude() const {
  // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.UserCharacteristics.Location.latitude)
  return _internal_latitude();
}
inline void Fingerprint_UserCharacteristics_Location::_internal_set_latitude(double value) {
  _has_bits_[0] |= 0x00000002u;
  latitude_ = value;
}
inline void Fingerprint_UserCharacteristics_Location::set_latitude(double value) {
  _internal_set_latitude(value);
  // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.UserCharacteristics.Location.latitude)
}

// optional double longitude = 3;
inline bool Fingerprint_UserCharacteristics_Location::_internal_has_longitude() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Fingerprint_UserCharacteristics_Location::has_longitude() const {
  return _internal_has_longitude();
}
inline void Fingerprint_UserCharacteristics_Location::clear_longitude() {
  longitude_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline double Fingerprint_UserCharacteristics_Location::_internal_longitude() const {
  return longitude_;
}
inline double Fingerprint_UserCharacteristics_Location::longitude() const {
  // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.UserCharacteristics.Location.longitude)
  return _internal_longitude();
}
inline void Fingerprint_UserCharacteristics_Location::_internal_set_longitude(double value) {
  _has_bits_[0] |= 0x00000004u;
  longitude_ = value;
}
inline void Fingerprint_UserCharacteristics_Location::set_longitude(double value) {
  _internal_set_longitude(value);
  // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.UserCharacteristics.Location.longitude)
}

// optional double accuracy = 4;
inline bool Fingerprint_UserCharacteristics_Location::_internal_has_accuracy() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Fingerprint_UserCharacteristics_Location::has_accuracy() const {
  return _internal_has_accuracy();
}
inline void Fingerprint_UserCharacteristics_Location::clear_accuracy() {
  accuracy_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline double Fingerprint_UserCharacteristics_Location::_internal_accuracy() const {
  return accuracy_;
}
inline double Fingerprint_UserCharacteristics_Location::accuracy() const {
  // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.UserCharacteristics.Location.accuracy)
  return _internal_accuracy();
}
inline void Fingerprint_UserCharacteristics_Location::_internal_set_accuracy(double value) {
  _has_bits_[0] |= 0x00000008u;
  accuracy_ = value;
}
inline void Fingerprint_UserCharacteristics_Location::set_accuracy(double value) {
  _internal_set_accuracy(value);
  // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.UserCharacteristics.Location.accuracy)
}

// optional int64 time_in_ms = 5;
inline bool Fingerprint_UserCharacteristics_Location::_internal_has_time_in_ms() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool Fingerprint_UserCharacteristics_Location::has_time_in_ms() const {
  return _internal_has_time_in_ms();
}
inline void Fingerprint_UserCharacteristics_Location::clear_time_in_ms() {
  time_in_ms_ = int64_t{0};
  _has_bits_[0] &= ~0x00000010u;
}
inline int64_t Fingerprint_UserCharacteristics_Location::_internal_time_in_ms() const {
  return time_in_ms_;
}
inline int64_t Fingerprint_UserCharacteristics_Location::time_in_ms() const {
  // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.UserCharacteristics.Location.time_in_ms)
  return _internal_time_in_ms();
}
inline void Fingerprint_UserCharacteristics_Location::_internal_set_time_in_ms(int64_t value) {
  _has_bits_[0] |= 0x00000010u;
  time_in_ms_ = value;
}
inline void Fingerprint_UserCharacteristics_Location::set_time_in_ms(int64_t value) {
  _internal_set_time_in_ms(value);
  // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.UserCharacteristics.Location.time_in_ms)
}

// -------------------------------------------------------------------

// Fingerprint_UserCharacteristics

// optional float force = 1;
inline bool Fingerprint_UserCharacteristics::_internal_has_force() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Fingerprint_UserCharacteristics::has_force() const {
  return _internal_has_force();
}
inline void Fingerprint_UserCharacteristics::clear_force() {
  force_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline float Fingerprint_UserCharacteristics::_internal_force() const {
  return force_;
}
inline float Fingerprint_UserCharacteristics::force() const {
  // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.UserCharacteristics.force)
  return _internal_force();
}
inline void Fingerprint_UserCharacteristics::_internal_set_force(float value) {
  _has_bits_[0] |= 0x00000008u;
  force_ = value;
}
inline void Fingerprint_UserCharacteristics::set_force(float value) {
  _internal_set_force(value);
  // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.UserCharacteristics.force)
}

// optional float touch_width = 2;
inline bool Fingerprint_UserCharacteristics::_internal_has_touch_width() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool Fingerprint_UserCharacteristics::has_touch_width() const {
  return _internal_has_touch_width();
}
inline void Fingerprint_UserCharacteristics::clear_touch_width() {
  touch_width_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline float Fingerprint_UserCharacteristics::_internal_touch_width() const {
  return touch_width_;
}
inline float Fingerprint_UserCharacteristics::touch_width() const {
  // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.UserCharacteristics.touch_width)
  return _internal_touch_width();
}
inline void Fingerprint_UserCharacteristics::_internal_set_touch_width(float value) {
  _has_bits_[0] |= 0x00000010u;
  touch_width_ = value;
}
inline void Fingerprint_UserCharacteristics::set_touch_width(float value) {
  _internal_set_touch_width(value);
  // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.UserCharacteristics.touch_width)
}

// optional float touch_height = 3;
inline bool Fingerprint_UserCharacteristics::_internal_has_touch_height() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool Fingerprint_UserCharacteristics::has_touch_height() const {
  return _internal_has_touch_height();
}
inline void Fingerprint_UserCharacteristics::clear_touch_height() {
  touch_height_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline float Fingerprint_UserCharacteristics::_internal_touch_height() const {
  return touch_height_;
}
inline float Fingerprint_UserCharacteristics::touch_height() const {
  // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.UserCharacteristics.touch_height)
  return _internal_touch_height();
}
inline void Fingerprint_UserCharacteristics::_internal_set_touch_height(float value) {
  _has_bits_[0] |= 0x00000020u;
  touch_height_ = value;
}
inline void Fingerprint_UserCharacteristics::set_touch_height(float value) {
  _internal_set_touch_height(value);
  // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.UserCharacteristics.touch_height)
}

// optional int32 touch_rotation = 4;
inline bool Fingerprint_UserCharacteristics::_internal_has_touch_rotation() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool Fingerprint_UserCharacteristics::has_touch_rotation() const {
  return _internal_has_touch_rotation();
}
inline void Fingerprint_UserCharacteristics::clear_touch_rotation() {
  touch_rotation_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline int32_t Fingerprint_UserCharacteristics::_internal_touch_rotation() const {
  return touch_rotation_;
}
inline int32_t Fingerprint_UserCharacteristics::touch_rotation() const {
  // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.UserCharacteristics.touch_rotation)
  return _internal_touch_rotation();
}
inline void Fingerprint_UserCharacteristics::_internal_set_touch_rotation(int32_t value) {
  _has_bits_[0] |= 0x00000040u;
  touch_rotation_ = value;
}
inline void Fingerprint_UserCharacteristics::set_touch_rotation(int32_t value) {
  _internal_set_touch_rotation(value);
  // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.UserCharacteristics.touch_rotation)
}

// optional .autofill.risk.Fingerprint.UserCharacteristics.Vector device_orientation = 5;
inline bool Fingerprint_UserCharacteristics::_internal_has_device_orientation() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || device_orientation_ != nullptr);
  return value;
}
inline bool Fingerprint_UserCharacteristics::has_device_orientation() const {
  return _internal_has_device_orientation();
}
inline void Fingerprint_UserCharacteristics::clear_device_orientation() {
  if (device_orientation_ != nullptr) device_orientation_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::autofill::risk::Fingerprint_UserCharacteristics_Vector& Fingerprint_UserCharacteristics::_internal_device_orientation() const {
  const ::autofill::risk::Fingerprint_UserCharacteristics_Vector* p = device_orientation_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill::risk::Fingerprint_UserCharacteristics_Vector&>(
      ::autofill::risk::_Fingerprint_UserCharacteristics_Vector_default_instance_);
}
inline const ::autofill::risk::Fingerprint_UserCharacteristics_Vector& Fingerprint_UserCharacteristics::device_orientation() const {
  // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.UserCharacteristics.device_orientation)
  return _internal_device_orientation();
}
inline void Fingerprint_UserCharacteristics::unsafe_arena_set_allocated_device_orientation(
    ::autofill::risk::Fingerprint_UserCharacteristics_Vector* device_orientation) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(device_orientation_);
  }
  device_orientation_ = device_orientation;
  if (device_orientation) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill.risk.Fingerprint.UserCharacteristics.device_orientation)
}
inline ::autofill::risk::Fingerprint_UserCharacteristics_Vector* Fingerprint_UserCharacteristics::release_device_orientation() {
  _has_bits_[0] &= ~0x00000001u;
  ::autofill::risk::Fingerprint_UserCharacteristics_Vector* temp = device_orientation_;
  device_orientation_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill::risk::Fingerprint_UserCharacteristics_Vector* Fingerprint_UserCharacteristics::unsafe_arena_release_device_orientation() {
  // @@protoc_insertion_point(field_release:autofill.risk.Fingerprint.UserCharacteristics.device_orientation)
  _has_bits_[0] &= ~0x00000001u;
  ::autofill::risk::Fingerprint_UserCharacteristics_Vector* temp = device_orientation_;
  device_orientation_ = nullptr;
  return temp;
}
inline ::autofill::risk::Fingerprint_UserCharacteristics_Vector* Fingerprint_UserCharacteristics::_internal_mutable_device_orientation() {
  _has_bits_[0] |= 0x00000001u;
  if (device_orientation_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill::risk::Fingerprint_UserCharacteristics_Vector>(GetArenaForAllocation());
    device_orientation_ = p;
  }
  return device_orientation_;
}
inline ::autofill::risk::Fingerprint_UserCharacteristics_Vector* Fingerprint_UserCharacteristics::mutable_device_orientation() {
  ::autofill::risk::Fingerprint_UserCharacteristics_Vector* _msg = _internal_mutable_device_orientation();
  // @@protoc_insertion_point(field_mutable:autofill.risk.Fingerprint.UserCharacteristics.device_orientation)
  return _msg;
}
inline void Fingerprint_UserCharacteristics::set_allocated_device_orientation(::autofill::risk::Fingerprint_UserCharacteristics_Vector* device_orientation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete device_orientation_;
  }
  if (device_orientation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(device_orientation);
    if (message_arena != submessage_arena) {
      device_orientation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, device_orientation, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  device_orientation_ = device_orientation;
  // @@protoc_insertion_point(field_set_allocated:autofill.risk.Fingerprint.UserCharacteristics.device_orientation)
}

// optional .autofill.risk.Fingerprint.UserCharacteristics.Vector device_acceleration = 6;
inline bool Fingerprint_UserCharacteristics::_internal_has_device_acceleration() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || device_acceleration_ != nullptr);
  return value;
}
inline bool Fingerprint_UserCharacteristics::has_device_acceleration() const {
  return _internal_has_device_acceleration();
}
inline void Fingerprint_UserCharacteristics::clear_device_acceleration() {
  if (device_acceleration_ != nullptr) device_acceleration_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::autofill::risk::Fingerprint_UserCharacteristics_Vector& Fingerprint_UserCharacteristics::_internal_device_acceleration() const {
  const ::autofill::risk::Fingerprint_UserCharacteristics_Vector* p = device_acceleration_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill::risk::Fingerprint_UserCharacteristics_Vector&>(
      ::autofill::risk::_Fingerprint_UserCharacteristics_Vector_default_instance_);
}
inline const ::autofill::risk::Fingerprint_UserCharacteristics_Vector& Fingerprint_UserCharacteristics::device_acceleration() const {
  // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.UserCharacteristics.device_acceleration)
  return _internal_device_acceleration();
}
inline void Fingerprint_UserCharacteristics::unsafe_arena_set_allocated_device_acceleration(
    ::autofill::risk::Fingerprint_UserCharacteristics_Vector* device_acceleration) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(device_acceleration_);
  }
  device_acceleration_ = device_acceleration;
  if (device_acceleration) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill.risk.Fingerprint.UserCharacteristics.device_acceleration)
}
inline ::autofill::risk::Fingerprint_UserCharacteristics_Vector* Fingerprint_UserCharacteristics::release_device_acceleration() {
  _has_bits_[0] &= ~0x00000002u;
  ::autofill::risk::Fingerprint_UserCharacteristics_Vector* temp = device_acceleration_;
  device_acceleration_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill::risk::Fingerprint_UserCharacteristics_Vector* Fingerprint_UserCharacteristics::unsafe_arena_release_device_acceleration() {
  // @@protoc_insertion_point(field_release:autofill.risk.Fingerprint.UserCharacteristics.device_acceleration)
  _has_bits_[0] &= ~0x00000002u;
  ::autofill::risk::Fingerprint_UserCharacteristics_Vector* temp = device_acceleration_;
  device_acceleration_ = nullptr;
  return temp;
}
inline ::autofill::risk::Fingerprint_UserCharacteristics_Vector* Fingerprint_UserCharacteristics::_internal_mutable_device_acceleration() {
  _has_bits_[0] |= 0x00000002u;
  if (device_acceleration_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill::risk::Fingerprint_UserCharacteristics_Vector>(GetArenaForAllocation());
    device_acceleration_ = p;
  }
  return device_acceleration_;
}
inline ::autofill::risk::Fingerprint_UserCharacteristics_Vector* Fingerprint_UserCharacteristics::mutable_device_acceleration() {
  ::autofill::risk::Fingerprint_UserCharacteristics_Vector* _msg = _internal_mutable_device_acceleration();
  // @@protoc_insertion_point(field_mutable:autofill.risk.Fingerprint.UserCharacteristics.device_acceleration)
  return _msg;
}
inline void Fingerprint_UserCharacteristics::set_allocated_device_acceleration(::autofill::risk::Fingerprint_UserCharacteristics_Vector* device_acceleration) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete device_acceleration_;
  }
  if (device_acceleration) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(device_acceleration);
    if (message_arena != submessage_arena) {
      device_acceleration = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, device_acceleration, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  device_acceleration_ = device_acceleration;
  // @@protoc_insertion_point(field_set_allocated:autofill.risk.Fingerprint.UserCharacteristics.device_acceleration)
}

// optional .autofill.risk.Fingerprint.UserCharacteristics.Location location = 7;
inline bool Fingerprint_UserCharacteristics::_internal_has_location() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || location_ != nullptr);
  return value;
}
inline bool Fingerprint_UserCharacteristics::has_location() const {
  return _internal_has_location();
}
inline void Fingerprint_UserCharacteristics::clear_location() {
  if (location_ != nullptr) location_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::autofill::risk::Fingerprint_UserCharacteristics_Location& Fingerprint_UserCharacteristics::_internal_location() const {
  const ::autofill::risk::Fingerprint_UserCharacteristics_Location* p = location_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill::risk::Fingerprint_UserCharacteristics_Location&>(
      ::autofill::risk::_Fingerprint_UserCharacteristics_Location_default_instance_);
}
inline const ::autofill::risk::Fingerprint_UserCharacteristics_Location& Fingerprint_UserCharacteristics::location() const {
  // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.UserCharacteristics.location)
  return _internal_location();
}
inline void Fingerprint_UserCharacteristics::unsafe_arena_set_allocated_location(
    ::autofill::risk::Fingerprint_UserCharacteristics_Location* location) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(location_);
  }
  location_ = location;
  if (location) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill.risk.Fingerprint.UserCharacteristics.location)
}
inline ::autofill::risk::Fingerprint_UserCharacteristics_Location* Fingerprint_UserCharacteristics::release_location() {
  _has_bits_[0] &= ~0x00000004u;
  ::autofill::risk::Fingerprint_UserCharacteristics_Location* temp = location_;
  location_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill::risk::Fingerprint_UserCharacteristics_Location* Fingerprint_UserCharacteristics::unsafe_arena_release_location() {
  // @@protoc_insertion_point(field_release:autofill.risk.Fingerprint.UserCharacteristics.location)
  _has_bits_[0] &= ~0x00000004u;
  ::autofill::risk::Fingerprint_UserCharacteristics_Location* temp = location_;
  location_ = nullptr;
  return temp;
}
inline ::autofill::risk::Fingerprint_UserCharacteristics_Location* Fingerprint_UserCharacteristics::_internal_mutable_location() {
  _has_bits_[0] |= 0x00000004u;
  if (location_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill::risk::Fingerprint_UserCharacteristics_Location>(GetArenaForAllocation());
    location_ = p;
  }
  return location_;
}
inline ::autofill::risk::Fingerprint_UserCharacteristics_Location* Fingerprint_UserCharacteristics::mutable_location() {
  ::autofill::risk::Fingerprint_UserCharacteristics_Location* _msg = _internal_mutable_location();
  // @@protoc_insertion_point(field_mutable:autofill.risk.Fingerprint.UserCharacteristics.location)
  return _msg;
}
inline void Fingerprint_UserCharacteristics::set_allocated_location(::autofill::risk::Fingerprint_UserCharacteristics_Location* location) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete location_;
  }
  if (location) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(location);
    if (message_arena != submessage_arena) {
      location = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, location, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  location_ = location;
  // @@protoc_insertion_point(field_set_allocated:autofill.risk.Fingerprint.UserCharacteristics.location)
}

// -------------------------------------------------------------------

// Fingerprint_Metadata

// optional int64 timestamp_ms = 1;
inline bool Fingerprint_Metadata::_internal_has_timestamp_ms() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Fingerprint_Metadata::has_timestamp_ms() const {
  return _internal_has_timestamp_ms();
}
inline void Fingerprint_Metadata::clear_timestamp_ms() {
  timestamp_ms_ = int64_t{0};
  _has_bits_[0] &= ~0x00000001u;
}
inline int64_t Fingerprint_Metadata::_internal_timestamp_ms() const {
  return timestamp_ms_;
}
inline int64_t Fingerprint_Metadata::timestamp_ms() const {
  // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.Metadata.timestamp_ms)
  return _internal_timestamp_ms();
}
inline void Fingerprint_Metadata::_internal_set_timestamp_ms(int64_t value) {
  _has_bits_[0] |= 0x00000001u;
  timestamp_ms_ = value;
}
inline void Fingerprint_Metadata::set_timestamp_ms(int64_t value) {
  _internal_set_timestamp_ms(value);
  // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.Metadata.timestamp_ms)
}

// optional uint64 obfuscated_gaia_id = 2;
inline bool Fingerprint_Metadata::_internal_has_obfuscated_gaia_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Fingerprint_Metadata::has_obfuscated_gaia_id() const {
  return _internal_has_obfuscated_gaia_id();
}
inline void Fingerprint_Metadata::clear_obfuscated_gaia_id() {
  obfuscated_gaia_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000002u;
}
inline uint64_t Fingerprint_Metadata::_internal_obfuscated_gaia_id() const {
  return obfuscated_gaia_id_;
}
inline uint64_t Fingerprint_Metadata::obfuscated_gaia_id() const {
  // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.Metadata.obfuscated_gaia_id)
  return _internal_obfuscated_gaia_id();
}
inline void Fingerprint_Metadata::_internal_set_obfuscated_gaia_id(uint64_t value) {
  _has_bits_[0] |= 0x00000002u;
  obfuscated_gaia_id_ = value;
}
inline void Fingerprint_Metadata::set_obfuscated_gaia_id(uint64_t value) {
  _internal_set_obfuscated_gaia_id(value);
  // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.Metadata.obfuscated_gaia_id)
}

// optional int32 fingerprinter_version = 3;
inline bool Fingerprint_Metadata::_internal_has_fingerprinter_version() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Fingerprint_Metadata::has_fingerprinter_version() const {
  return _internal_has_fingerprinter_version();
}
inline void Fingerprint_Metadata::clear_fingerprinter_version() {
  fingerprinter_version_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline int32_t Fingerprint_Metadata::_internal_fingerprinter_version() const {
  return fingerprinter_version_;
}
inline int32_t Fingerprint_Metadata::fingerprinter_version() const {
  // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.Metadata.fingerprinter_version)
  return _internal_fingerprinter_version();
}
inline void Fingerprint_Metadata::_internal_set_fingerprinter_version(int32_t value) {
  _has_bits_[0] |= 0x00000004u;
  fingerprinter_version_ = value;
}
inline void Fingerprint_Metadata::set_fingerprinter_version(int32_t value) {
  _internal_set_fingerprinter_version(value);
  // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.Metadata.fingerprinter_version)
}

// -------------------------------------------------------------------

// Fingerprint

// optional .autofill.risk.Fingerprint.MachineCharacteristics machine_characteristics = 1;
inline bool Fingerprint::_internal_has_machine_characteristics() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || machine_characteristics_ != nullptr);
  return value;
}
inline bool Fingerprint::has_machine_characteristics() const {
  return _internal_has_machine_characteristics();
}
inline void Fingerprint::clear_machine_characteristics() {
  if (machine_characteristics_ != nullptr) machine_characteristics_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::autofill::risk::Fingerprint_MachineCharacteristics& Fingerprint::_internal_machine_characteristics() const {
  const ::autofill::risk::Fingerprint_MachineCharacteristics* p = machine_characteristics_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill::risk::Fingerprint_MachineCharacteristics&>(
      ::autofill::risk::_Fingerprint_MachineCharacteristics_default_instance_);
}
inline const ::autofill::risk::Fingerprint_MachineCharacteristics& Fingerprint::machine_characteristics() const {
  // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.machine_characteristics)
  return _internal_machine_characteristics();
}
inline void Fingerprint::unsafe_arena_set_allocated_machine_characteristics(
    ::autofill::risk::Fingerprint_MachineCharacteristics* machine_characteristics) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(machine_characteristics_);
  }
  machine_characteristics_ = machine_characteristics;
  if (machine_characteristics) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill.risk.Fingerprint.machine_characteristics)
}
inline ::autofill::risk::Fingerprint_MachineCharacteristics* Fingerprint::release_machine_characteristics() {
  _has_bits_[0] &= ~0x00000001u;
  ::autofill::risk::Fingerprint_MachineCharacteristics* temp = machine_characteristics_;
  machine_characteristics_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill::risk::Fingerprint_MachineCharacteristics* Fingerprint::unsafe_arena_release_machine_characteristics() {
  // @@protoc_insertion_point(field_release:autofill.risk.Fingerprint.machine_characteristics)
  _has_bits_[0] &= ~0x00000001u;
  ::autofill::risk::Fingerprint_MachineCharacteristics* temp = machine_characteristics_;
  machine_characteristics_ = nullptr;
  return temp;
}
inline ::autofill::risk::Fingerprint_MachineCharacteristics* Fingerprint::_internal_mutable_machine_characteristics() {
  _has_bits_[0] |= 0x00000001u;
  if (machine_characteristics_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill::risk::Fingerprint_MachineCharacteristics>(GetArenaForAllocation());
    machine_characteristics_ = p;
  }
  return machine_characteristics_;
}
inline ::autofill::risk::Fingerprint_MachineCharacteristics* Fingerprint::mutable_machine_characteristics() {
  ::autofill::risk::Fingerprint_MachineCharacteristics* _msg = _internal_mutable_machine_characteristics();
  // @@protoc_insertion_point(field_mutable:autofill.risk.Fingerprint.machine_characteristics)
  return _msg;
}
inline void Fingerprint::set_allocated_machine_characteristics(::autofill::risk::Fingerprint_MachineCharacteristics* machine_characteristics) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete machine_characteristics_;
  }
  if (machine_characteristics) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(machine_characteristics);
    if (message_arena != submessage_arena) {
      machine_characteristics = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, machine_characteristics, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  machine_characteristics_ = machine_characteristics;
  // @@protoc_insertion_point(field_set_allocated:autofill.risk.Fingerprint.machine_characteristics)
}

// optional .autofill.risk.Fingerprint.Performance performance = 2;
inline bool Fingerprint::_internal_has_performance() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || performance_ != nullptr);
  return value;
}
inline bool Fingerprint::has_performance() const {
  return _internal_has_performance();
}
inline void Fingerprint::clear_performance() {
  if (performance_ != nullptr) performance_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::autofill::risk::Fingerprint_Performance& Fingerprint::_internal_performance() const {
  const ::autofill::risk::Fingerprint_Performance* p = performance_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill::risk::Fingerprint_Performance&>(
      ::autofill::risk::_Fingerprint_Performance_default_instance_);
}
inline const ::autofill::risk::Fingerprint_Performance& Fingerprint::performance() const {
  // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.performance)
  return _internal_performance();
}
inline void Fingerprint::unsafe_arena_set_allocated_performance(
    ::autofill::risk::Fingerprint_Performance* performance) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(performance_);
  }
  performance_ = performance;
  if (performance) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill.risk.Fingerprint.performance)
}
inline ::autofill::risk::Fingerprint_Performance* Fingerprint::release_performance() {
  _has_bits_[0] &= ~0x00000002u;
  ::autofill::risk::Fingerprint_Performance* temp = performance_;
  performance_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill::risk::Fingerprint_Performance* Fingerprint::unsafe_arena_release_performance() {
  // @@protoc_insertion_point(field_release:autofill.risk.Fingerprint.performance)
  _has_bits_[0] &= ~0x00000002u;
  ::autofill::risk::Fingerprint_Performance* temp = performance_;
  performance_ = nullptr;
  return temp;
}
inline ::autofill::risk::Fingerprint_Performance* Fingerprint::_internal_mutable_performance() {
  _has_bits_[0] |= 0x00000002u;
  if (performance_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill::risk::Fingerprint_Performance>(GetArenaForAllocation());
    performance_ = p;
  }
  return performance_;
}
inline ::autofill::risk::Fingerprint_Performance* Fingerprint::mutable_performance() {
  ::autofill::risk::Fingerprint_Performance* _msg = _internal_mutable_performance();
  // @@protoc_insertion_point(field_mutable:autofill.risk.Fingerprint.performance)
  return _msg;
}
inline void Fingerprint::set_allocated_performance(::autofill::risk::Fingerprint_Performance* performance) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete performance_;
  }
  if (performance) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(performance);
    if (message_arena != submessage_arena) {
      performance = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, performance, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  performance_ = performance;
  // @@protoc_insertion_point(field_set_allocated:autofill.risk.Fingerprint.performance)
}

// optional .autofill.risk.Fingerprint.UserCharacteristics user_characteristics = 3;
inline bool Fingerprint::_internal_has_user_characteristics() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || user_characteristics_ != nullptr);
  return value;
}
inline bool Fingerprint::has_user_characteristics() const {
  return _internal_has_user_characteristics();
}
inline void Fingerprint::clear_user_characteristics() {
  if (user_characteristics_ != nullptr) user_characteristics_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::autofill::risk::Fingerprint_UserCharacteristics& Fingerprint::_internal_user_characteristics() const {
  const ::autofill::risk::Fingerprint_UserCharacteristics* p = user_characteristics_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill::risk::Fingerprint_UserCharacteristics&>(
      ::autofill::risk::_Fingerprint_UserCharacteristics_default_instance_);
}
inline const ::autofill::risk::Fingerprint_UserCharacteristics& Fingerprint::user_characteristics() const {
  // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.user_characteristics)
  return _internal_user_characteristics();
}
inline void Fingerprint::unsafe_arena_set_allocated_user_characteristics(
    ::autofill::risk::Fingerprint_UserCharacteristics* user_characteristics) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(user_characteristics_);
  }
  user_characteristics_ = user_characteristics;
  if (user_characteristics) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill.risk.Fingerprint.user_characteristics)
}
inline ::autofill::risk::Fingerprint_UserCharacteristics* Fingerprint::release_user_characteristics() {
  _has_bits_[0] &= ~0x00000004u;
  ::autofill::risk::Fingerprint_UserCharacteristics* temp = user_characteristics_;
  user_characteristics_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill::risk::Fingerprint_UserCharacteristics* Fingerprint::unsafe_arena_release_user_characteristics() {
  // @@protoc_insertion_point(field_release:autofill.risk.Fingerprint.user_characteristics)
  _has_bits_[0] &= ~0x00000004u;
  ::autofill::risk::Fingerprint_UserCharacteristics* temp = user_characteristics_;
  user_characteristics_ = nullptr;
  return temp;
}
inline ::autofill::risk::Fingerprint_UserCharacteristics* Fingerprint::_internal_mutable_user_characteristics() {
  _has_bits_[0] |= 0x00000004u;
  if (user_characteristics_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill::risk::Fingerprint_UserCharacteristics>(GetArenaForAllocation());
    user_characteristics_ = p;
  }
  return user_characteristics_;
}
inline ::autofill::risk::Fingerprint_UserCharacteristics* Fingerprint::mutable_user_characteristics() {
  ::autofill::risk::Fingerprint_UserCharacteristics* _msg = _internal_mutable_user_characteristics();
  // @@protoc_insertion_point(field_mutable:autofill.risk.Fingerprint.user_characteristics)
  return _msg;
}
inline void Fingerprint::set_allocated_user_characteristics(::autofill::risk::Fingerprint_UserCharacteristics* user_characteristics) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete user_characteristics_;
  }
  if (user_characteristics) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(user_characteristics);
    if (message_arena != submessage_arena) {
      user_characteristics = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, user_characteristics, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  user_characteristics_ = user_characteristics;
  // @@protoc_insertion_point(field_set_allocated:autofill.risk.Fingerprint.user_characteristics)
}

// optional .autofill.risk.Fingerprint.TransientState transient_state = 4;
inline bool Fingerprint::_internal_has_transient_state() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || transient_state_ != nullptr);
  return value;
}
inline bool Fingerprint::has_transient_state() const {
  return _internal_has_transient_state();
}
inline void Fingerprint::clear_transient_state() {
  if (transient_state_ != nullptr) transient_state_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::autofill::risk::Fingerprint_TransientState& Fingerprint::_internal_transient_state() const {
  const ::autofill::risk::Fingerprint_TransientState* p = transient_state_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill::risk::Fingerprint_TransientState&>(
      ::autofill::risk::_Fingerprint_TransientState_default_instance_);
}
inline const ::autofill::risk::Fingerprint_TransientState& Fingerprint::transient_state() const {
  // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.transient_state)
  return _internal_transient_state();
}
inline void Fingerprint::unsafe_arena_set_allocated_transient_state(
    ::autofill::risk::Fingerprint_TransientState* transient_state) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(transient_state_);
  }
  transient_state_ = transient_state;
  if (transient_state) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill.risk.Fingerprint.transient_state)
}
inline ::autofill::risk::Fingerprint_TransientState* Fingerprint::release_transient_state() {
  _has_bits_[0] &= ~0x00000008u;
  ::autofill::risk::Fingerprint_TransientState* temp = transient_state_;
  transient_state_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill::risk::Fingerprint_TransientState* Fingerprint::unsafe_arena_release_transient_state() {
  // @@protoc_insertion_point(field_release:autofill.risk.Fingerprint.transient_state)
  _has_bits_[0] &= ~0x00000008u;
  ::autofill::risk::Fingerprint_TransientState* temp = transient_state_;
  transient_state_ = nullptr;
  return temp;
}
inline ::autofill::risk::Fingerprint_TransientState* Fingerprint::_internal_mutable_transient_state() {
  _has_bits_[0] |= 0x00000008u;
  if (transient_state_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill::risk::Fingerprint_TransientState>(GetArenaForAllocation());
    transient_state_ = p;
  }
  return transient_state_;
}
inline ::autofill::risk::Fingerprint_TransientState* Fingerprint::mutable_transient_state() {
  ::autofill::risk::Fingerprint_TransientState* _msg = _internal_mutable_transient_state();
  // @@protoc_insertion_point(field_mutable:autofill.risk.Fingerprint.transient_state)
  return _msg;
}
inline void Fingerprint::set_allocated_transient_state(::autofill::risk::Fingerprint_TransientState* transient_state) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete transient_state_;
  }
  if (transient_state) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(transient_state);
    if (message_arena != submessage_arena) {
      transient_state = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, transient_state, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  transient_state_ = transient_state;
  // @@protoc_insertion_point(field_set_allocated:autofill.risk.Fingerprint.transient_state)
}

// optional .autofill.risk.Fingerprint.Metadata metadata = 5;
inline bool Fingerprint::_internal_has_metadata() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || metadata_ != nullptr);
  return value;
}
inline bool Fingerprint::has_metadata() const {
  return _internal_has_metadata();
}
inline void Fingerprint::clear_metadata() {
  if (metadata_ != nullptr) metadata_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::autofill::risk::Fingerprint_Metadata& Fingerprint::_internal_metadata() const {
  const ::autofill::risk::Fingerprint_Metadata* p = metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::autofill::risk::Fingerprint_Metadata&>(
      ::autofill::risk::_Fingerprint_Metadata_default_instance_);
}
inline const ::autofill::risk::Fingerprint_Metadata& Fingerprint::metadata() const {
  // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.metadata)
  return _internal_metadata();
}
inline void Fingerprint::unsafe_arena_set_allocated_metadata(
    ::autofill::risk::Fingerprint_Metadata* metadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata_);
  }
  metadata_ = metadata;
  if (metadata) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill.risk.Fingerprint.metadata)
}
inline ::autofill::risk::Fingerprint_Metadata* Fingerprint::release_metadata() {
  _has_bits_[0] &= ~0x00000010u;
  ::autofill::risk::Fingerprint_Metadata* temp = metadata_;
  metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::autofill::risk::Fingerprint_Metadata* Fingerprint::unsafe_arena_release_metadata() {
  // @@protoc_insertion_point(field_release:autofill.risk.Fingerprint.metadata)
  _has_bits_[0] &= ~0x00000010u;
  ::autofill::risk::Fingerprint_Metadata* temp = metadata_;
  metadata_ = nullptr;
  return temp;
}
inline ::autofill::risk::Fingerprint_Metadata* Fingerprint::_internal_mutable_metadata() {
  _has_bits_[0] |= 0x00000010u;
  if (metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::autofill::risk::Fingerprint_Metadata>(GetArenaForAllocation());
    metadata_ = p;
  }
  return metadata_;
}
inline ::autofill::risk::Fingerprint_Metadata* Fingerprint::mutable_metadata() {
  ::autofill::risk::Fingerprint_Metadata* _msg = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:autofill.risk.Fingerprint.metadata)
  return _msg;
}
inline void Fingerprint::set_allocated_metadata(::autofill::risk::Fingerprint_Metadata* metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete metadata_;
  }
  if (metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(metadata);
    if (message_arena != submessage_arena) {
      metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, metadata, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  metadata_ = metadata;
  // @@protoc_insertion_point(field_set_allocated:autofill.risk.Fingerprint.metadata)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace risk
}  // namespace autofill

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::autofill::risk::Fingerprint_MachineCharacteristics_BrowserFeature> : ::std::true_type {};

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_fingerprint_2eproto
