// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_CSD_SAFE_BROWSING_FLAT_VISUALFEATURES__H_
#define FLATBUFFERS_GENERATED_CSD_SAFE_BROWSING_FLAT_VISUALFEATURES__H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 2 &&
              FLATBUFFERS_VERSION_MINOR == 0 &&
              FLATBUFFERS_VERSION_REVISION == 6,
             "Non-compatible flatbuffers version included");

namespace safe_browsing {
namespace flat {

struct VisualFeatures;
struct VisualFeaturesBuilder;

namespace VisualFeatures_ {

struct ColorHistogramBin;
struct ColorHistogramBinBuilder;

}  // namespace VisualFeatures_

struct VisualFeatures FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef VisualFeaturesBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct VisualFeaturesBuilder {
  typedef VisualFeatures Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit VisualFeaturesBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<VisualFeatures> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<VisualFeatures>(end);
    return o;
  }
};

inline flatbuffers::Offset<VisualFeatures> CreateVisualFeatures(
    flatbuffers::FlatBufferBuilder &_fbb) {
  VisualFeaturesBuilder builder_(_fbb);
  return builder_.Finish();
}

namespace VisualFeatures_ {

struct ColorHistogramBin FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ColorHistogramBinBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CENTROID_X = 4,
    VT_CENTROID_Y = 6,
    VT_QUANTIZED_R = 8,
    VT_QUANTIZED_G = 10,
    VT_QUANTIZED_B = 12,
    VT_WEIGHT = 14
  };
  float centroid_x() const {
    return GetField<float>(VT_CENTROID_X, 0.0f);
  }
  bool mutate_centroid_x(float _centroid_x = 0.0f) {
    return SetField<float>(VT_CENTROID_X, _centroid_x, 0.0f);
  }
  float centroid_y() const {
    return GetField<float>(VT_CENTROID_Y, 0.0f);
  }
  bool mutate_centroid_y(float _centroid_y = 0.0f) {
    return SetField<float>(VT_CENTROID_Y, _centroid_y, 0.0f);
  }
  int32_t quantized_r() const {
    return GetField<int32_t>(VT_QUANTIZED_R, 0);
  }
  bool mutate_quantized_r(int32_t _quantized_r = 0) {
    return SetField<int32_t>(VT_QUANTIZED_R, _quantized_r, 0);
  }
  int32_t quantized_g() const {
    return GetField<int32_t>(VT_QUANTIZED_G, 0);
  }
  bool mutate_quantized_g(int32_t _quantized_g = 0) {
    return SetField<int32_t>(VT_QUANTIZED_G, _quantized_g, 0);
  }
  int32_t quantized_b() const {
    return GetField<int32_t>(VT_QUANTIZED_B, 0);
  }
  bool mutate_quantized_b(int32_t _quantized_b = 0) {
    return SetField<int32_t>(VT_QUANTIZED_B, _quantized_b, 0);
  }
  float weight() const {
    return GetField<float>(VT_WEIGHT, 0.0f);
  }
  bool mutate_weight(float _weight = 0.0f) {
    return SetField<float>(VT_WEIGHT, _weight, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_CENTROID_X, 4) &&
           VerifyField<float>(verifier, VT_CENTROID_Y, 4) &&
           VerifyField<int32_t>(verifier, VT_QUANTIZED_R, 4) &&
           VerifyField<int32_t>(verifier, VT_QUANTIZED_G, 4) &&
           VerifyField<int32_t>(verifier, VT_QUANTIZED_B, 4) &&
           VerifyField<float>(verifier, VT_WEIGHT, 4) &&
           verifier.EndTable();
  }
};

struct ColorHistogramBinBuilder {
  typedef ColorHistogramBin Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_centroid_x(float centroid_x) {
    fbb_.AddElement<float>(ColorHistogramBin::VT_CENTROID_X, centroid_x, 0.0f);
  }
  void add_centroid_y(float centroid_y) {
    fbb_.AddElement<float>(ColorHistogramBin::VT_CENTROID_Y, centroid_y, 0.0f);
  }
  void add_quantized_r(int32_t quantized_r) {
    fbb_.AddElement<int32_t>(ColorHistogramBin::VT_QUANTIZED_R, quantized_r, 0);
  }
  void add_quantized_g(int32_t quantized_g) {
    fbb_.AddElement<int32_t>(ColorHistogramBin::VT_QUANTIZED_G, quantized_g, 0);
  }
  void add_quantized_b(int32_t quantized_b) {
    fbb_.AddElement<int32_t>(ColorHistogramBin::VT_QUANTIZED_B, quantized_b, 0);
  }
  void add_weight(float weight) {
    fbb_.AddElement<float>(ColorHistogramBin::VT_WEIGHT, weight, 0.0f);
  }
  explicit ColorHistogramBinBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ColorHistogramBin> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ColorHistogramBin>(end);
    return o;
  }
};

inline flatbuffers::Offset<ColorHistogramBin> CreateColorHistogramBin(
    flatbuffers::FlatBufferBuilder &_fbb,
    float centroid_x = 0.0f,
    float centroid_y = 0.0f,
    int32_t quantized_r = 0,
    int32_t quantized_g = 0,
    int32_t quantized_b = 0,
    float weight = 0.0f) {
  ColorHistogramBinBuilder builder_(_fbb);
  builder_.add_weight(weight);
  builder_.add_quantized_b(quantized_b);
  builder_.add_quantized_g(quantized_g);
  builder_.add_quantized_r(quantized_r);
  builder_.add_centroid_y(centroid_y);
  builder_.add_centroid_x(centroid_x);
  return builder_.Finish();
}

}  // namespace VisualFeatures_

namespace VisualFeatures_ {

}  // namespace VisualFeatures_
}  // namespace flat
}  // namespace safe_browsing

#endif  // FLATBUFFERS_GENERATED_CSD_SAFE_BROWSING_FLAT_VISUALFEATURES__H_
