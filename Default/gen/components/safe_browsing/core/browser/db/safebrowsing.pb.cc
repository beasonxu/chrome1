// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: safebrowsing.proto

#include "safebrowsing.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace safe_browsing {
PROTOBUF_CONSTEXPR ThreatInfo::ThreatInfo(
    ::_pbi::ConstantInitialized)
  : threat_types_()
  , platform_types_()
  , threat_entries_()
  , threat_entry_types_(){}
struct ThreatInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ThreatInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ThreatInfoDefaultTypeInternal() {}
  union {
    ThreatInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ThreatInfoDefaultTypeInternal _ThreatInfo_default_instance_;
PROTOBUF_CONSTEXPR ThreatMatch::ThreatMatch(
    ::_pbi::ConstantInitialized)
  : threat_(nullptr)
  , threat_entry_metadata_(nullptr)
  , cache_duration_(nullptr)
  , threat_type_(0)

  , platform_type_(0)

  , threat_entry_type_(0)
{}
struct ThreatMatchDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ThreatMatchDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ThreatMatchDefaultTypeInternal() {}
  union {
    ThreatMatch _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ThreatMatchDefaultTypeInternal _ThreatMatch_default_instance_;
PROTOBUF_CONSTEXPR FindThreatMatchesRequest::FindThreatMatchesRequest(
    ::_pbi::ConstantInitialized)
  : client_(nullptr)
  , threat_info_(nullptr){}
struct FindThreatMatchesRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FindThreatMatchesRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FindThreatMatchesRequestDefaultTypeInternal() {}
  union {
    FindThreatMatchesRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FindThreatMatchesRequestDefaultTypeInternal _FindThreatMatchesRequest_default_instance_;
PROTOBUF_CONSTEXPR FindThreatMatchesResponse::FindThreatMatchesResponse(
    ::_pbi::ConstantInitialized)
  : matches_(){}
struct FindThreatMatchesResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FindThreatMatchesResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FindThreatMatchesResponseDefaultTypeInternal() {}
  union {
    FindThreatMatchesResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FindThreatMatchesResponseDefaultTypeInternal _FindThreatMatchesResponse_default_instance_;
PROTOBUF_CONSTEXPR FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints(
    ::_pbi::ConstantInitialized)
  : supported_compressions_()
  , region_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , max_update_entries_(0)
  , max_database_entries_(0){}
struct FetchThreatListUpdatesRequest_ListUpdateRequest_ConstraintsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FetchThreatListUpdatesRequest_ListUpdateRequest_ConstraintsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FetchThreatListUpdatesRequest_ListUpdateRequest_ConstraintsDefaultTypeInternal() {}
  union {
    FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FetchThreatListUpdatesRequest_ListUpdateRequest_ConstraintsDefaultTypeInternal _FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints_default_instance_;
PROTOBUF_CONSTEXPR FetchThreatListUpdatesRequest_ListUpdateRequest::FetchThreatListUpdatesRequest_ListUpdateRequest(
    ::_pbi::ConstantInitialized)
  : state_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , constraints_(nullptr)
  , threat_type_(0)

  , platform_type_(0)

  , threat_entry_type_(0)
{}
struct FetchThreatListUpdatesRequest_ListUpdateRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FetchThreatListUpdatesRequest_ListUpdateRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FetchThreatListUpdatesRequest_ListUpdateRequestDefaultTypeInternal() {}
  union {
    FetchThreatListUpdatesRequest_ListUpdateRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FetchThreatListUpdatesRequest_ListUpdateRequestDefaultTypeInternal _FetchThreatListUpdatesRequest_ListUpdateRequest_default_instance_;
PROTOBUF_CONSTEXPR FetchThreatListUpdatesRequest::FetchThreatListUpdatesRequest(
    ::_pbi::ConstantInitialized)
  : list_update_requests_()
  , client_(nullptr)
  , chrome_client_info_(nullptr){}
struct FetchThreatListUpdatesRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FetchThreatListUpdatesRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FetchThreatListUpdatesRequestDefaultTypeInternal() {}
  union {
    FetchThreatListUpdatesRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FetchThreatListUpdatesRequestDefaultTypeInternal _FetchThreatListUpdatesRequest_default_instance_;
PROTOBUF_CONSTEXPR FetchThreatListUpdatesResponse_ListUpdateResponse::FetchThreatListUpdatesResponse_ListUpdateResponse(
    ::_pbi::ConstantInitialized)
  : additions_()
  , removals_()
  , new_client_state_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , checksum_(nullptr)
  , threat_type_(0)

  , threat_entry_type_(0)

  , platform_type_(0)

  , response_type_(0)
{}
struct FetchThreatListUpdatesResponse_ListUpdateResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FetchThreatListUpdatesResponse_ListUpdateResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FetchThreatListUpdatesResponse_ListUpdateResponseDefaultTypeInternal() {}
  union {
    FetchThreatListUpdatesResponse_ListUpdateResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FetchThreatListUpdatesResponse_ListUpdateResponseDefaultTypeInternal _FetchThreatListUpdatesResponse_ListUpdateResponse_default_instance_;
PROTOBUF_CONSTEXPR FetchThreatListUpdatesResponse::FetchThreatListUpdatesResponse(
    ::_pbi::ConstantInitialized)
  : list_update_responses_()
  , minimum_wait_duration_(nullptr){}
struct FetchThreatListUpdatesResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FetchThreatListUpdatesResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FetchThreatListUpdatesResponseDefaultTypeInternal() {}
  union {
    FetchThreatListUpdatesResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FetchThreatListUpdatesResponseDefaultTypeInternal _FetchThreatListUpdatesResponse_default_instance_;
PROTOBUF_CONSTEXPR FindFullHashesRequest::FindFullHashesRequest(
    ::_pbi::ConstantInitialized)
  : client_states_()
  , client_(nullptr)
  , threat_info_(nullptr){}
struct FindFullHashesRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FindFullHashesRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FindFullHashesRequestDefaultTypeInternal() {}
  union {
    FindFullHashesRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FindFullHashesRequestDefaultTypeInternal _FindFullHashesRequest_default_instance_;
PROTOBUF_CONSTEXPR FindFullHashesResponse::FindFullHashesResponse(
    ::_pbi::ConstantInitialized)
  : matches_()
  , minimum_wait_duration_(nullptr)
  , negative_cache_duration_(nullptr){}
struct FindFullHashesResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FindFullHashesResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FindFullHashesResponseDefaultTypeInternal() {}
  union {
    FindFullHashesResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FindFullHashesResponseDefaultTypeInternal _FindFullHashesResponse_default_instance_;
PROTOBUF_CONSTEXPR ThreatHit_ThreatSource::ThreatHit_ThreatSource(
    ::_pbi::ConstantInitialized)
  : url_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , remote_ip_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , referrer_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , type_(0)
{}
struct ThreatHit_ThreatSourceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ThreatHit_ThreatSourceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ThreatHit_ThreatSourceDefaultTypeInternal() {}
  union {
    ThreatHit_ThreatSource _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ThreatHit_ThreatSourceDefaultTypeInternal _ThreatHit_ThreatSource_default_instance_;
PROTOBUF_CONSTEXPR ThreatHit::ThreatHit(
    ::_pbi::ConstantInitialized)
  : resources_()
  , entry_(nullptr)
  , threat_type_(0)

  , platform_type_(0)
{}
struct ThreatHitDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ThreatHitDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ThreatHitDefaultTypeInternal() {}
  union {
    ThreatHit _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ThreatHitDefaultTypeInternal _ThreatHit_default_instance_;
PROTOBUF_CONSTEXPR ClientInfo::ClientInfo(
    ::_pbi::ConstantInitialized)
  : client_id_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , client_version_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}){}
struct ClientInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ClientInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ClientInfoDefaultTypeInternal() {}
  union {
    ClientInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClientInfoDefaultTypeInternal _ClientInfo_default_instance_;
PROTOBUF_CONSTEXPR ChromeClientInfo::ChromeClientInfo(
    ::_pbi::ConstantInitialized)
  : reporting_population_(0)
{}
struct ChromeClientInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ChromeClientInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ChromeClientInfoDefaultTypeInternal() {}
  union {
    ChromeClientInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ChromeClientInfoDefaultTypeInternal _ChromeClientInfo_default_instance_;
PROTOBUF_CONSTEXPR Checksum::Checksum(
    ::_pbi::ConstantInitialized)
  : sha256_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}){}
struct ChecksumDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ChecksumDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ChecksumDefaultTypeInternal() {}
  union {
    Checksum _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ChecksumDefaultTypeInternal _Checksum_default_instance_;
PROTOBUF_CONSTEXPR ThreatEntry::ThreatEntry(
    ::_pbi::ConstantInitialized)
  : hash_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , url_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}){}
struct ThreatEntryDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ThreatEntryDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ThreatEntryDefaultTypeInternal() {}
  union {
    ThreatEntry _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ThreatEntryDefaultTypeInternal _ThreatEntry_default_instance_;
PROTOBUF_CONSTEXPR ThreatEntrySet::ThreatEntrySet(
    ::_pbi::ConstantInitialized)
  : raw_hashes_(nullptr)
  , raw_indices_(nullptr)
  , rice_hashes_(nullptr)
  , rice_indices_(nullptr)
  , compression_type_(0)
{}
struct ThreatEntrySetDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ThreatEntrySetDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ThreatEntrySetDefaultTypeInternal() {}
  union {
    ThreatEntrySet _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ThreatEntrySetDefaultTypeInternal _ThreatEntrySet_default_instance_;
PROTOBUF_CONSTEXPR RawIndices::RawIndices(
    ::_pbi::ConstantInitialized)
  : indices_(){}
struct RawIndicesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RawIndicesDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RawIndicesDefaultTypeInternal() {}
  union {
    RawIndices _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RawIndicesDefaultTypeInternal _RawIndices_default_instance_;
PROTOBUF_CONSTEXPR RawHashes::RawHashes(
    ::_pbi::ConstantInitialized)
  : raw_hashes_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , prefix_size_(0){}
struct RawHashesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RawHashesDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RawHashesDefaultTypeInternal() {}
  union {
    RawHashes _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RawHashesDefaultTypeInternal _RawHashes_default_instance_;
PROTOBUF_CONSTEXPR RiceDeltaEncoding::RiceDeltaEncoding(
    ::_pbi::ConstantInitialized)
  : encoded_data_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , first_value_(int64_t{0})
  , rice_parameter_(0)
  , num_entries_(0){}
struct RiceDeltaEncodingDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RiceDeltaEncodingDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RiceDeltaEncodingDefaultTypeInternal() {}
  union {
    RiceDeltaEncoding _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RiceDeltaEncodingDefaultTypeInternal _RiceDeltaEncoding_default_instance_;
PROTOBUF_CONSTEXPR ThreatEntryMetadata_MetadataEntry::ThreatEntryMetadata_MetadataEntry(
    ::_pbi::ConstantInitialized)
  : key_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , value_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}){}
struct ThreatEntryMetadata_MetadataEntryDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ThreatEntryMetadata_MetadataEntryDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ThreatEntryMetadata_MetadataEntryDefaultTypeInternal() {}
  union {
    ThreatEntryMetadata_MetadataEntry _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ThreatEntryMetadata_MetadataEntryDefaultTypeInternal _ThreatEntryMetadata_MetadataEntry_default_instance_;
PROTOBUF_CONSTEXPR ThreatEntryMetadata::ThreatEntryMetadata(
    ::_pbi::ConstantInitialized)
  : entries_(){}
struct ThreatEntryMetadataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ThreatEntryMetadataDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ThreatEntryMetadataDefaultTypeInternal() {}
  union {
    ThreatEntryMetadata _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ThreatEntryMetadataDefaultTypeInternal _ThreatEntryMetadata_default_instance_;
PROTOBUF_CONSTEXPR ThreatListDescriptor::ThreatListDescriptor(
    ::_pbi::ConstantInitialized)
  : threat_type_(0)

  , platform_type_(0)

  , threat_entry_type_(0)
{}
struct ThreatListDescriptorDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ThreatListDescriptorDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ThreatListDescriptorDefaultTypeInternal() {}
  union {
    ThreatListDescriptor _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ThreatListDescriptorDefaultTypeInternal _ThreatListDescriptor_default_instance_;
PROTOBUF_CONSTEXPR ListThreatListsResponse::ListThreatListsResponse(
    ::_pbi::ConstantInitialized)
  : threat_lists_(){}
struct ListThreatListsResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ListThreatListsResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ListThreatListsResponseDefaultTypeInternal() {}
  union {
    ListThreatListsResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ListThreatListsResponseDefaultTypeInternal _ListThreatListsResponse_default_instance_;
PROTOBUF_CONSTEXPR Duration::Duration(
    ::_pbi::ConstantInitialized)
  : seconds_(int64_t{0})
  , nanos_(0){}
struct DurationDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DurationDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DurationDefaultTypeInternal() {}
  union {
    Duration _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DurationDefaultTypeInternal _Duration_default_instance_;
}  // namespace safe_browsing
namespace safe_browsing {
bool FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType_strings[3] = {};

static const char FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType_names[] =
  "FULL_UPDATE"
  "PARTIAL_UPDATE"
  "RESPONSE_TYPE_UNSPECIFIED";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType_entries[] = {
  { {FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType_names + 0, 11}, 2 },
  { {FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType_names + 11, 14}, 1 },
  { {FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType_names + 25, 25}, 0 },
};

static const int FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType_entries_by_number[] = {
  2, // 0 -> RESPONSE_TYPE_UNSPECIFIED
  1, // 1 -> PARTIAL_UPDATE
  0, // 2 -> FULL_UPDATE
};

const std::string& FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType_Name(
    FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType_entries,
          FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType_entries_by_number,
          3, FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType_entries,
      FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType_strings[idx].get();
}
bool FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType FetchThreatListUpdatesResponse_ListUpdateResponse::RESPONSE_TYPE_UNSPECIFIED;
constexpr FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType FetchThreatListUpdatesResponse_ListUpdateResponse::PARTIAL_UPDATE;
constexpr FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType FetchThreatListUpdatesResponse_ListUpdateResponse::FULL_UPDATE;
constexpr FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType FetchThreatListUpdatesResponse_ListUpdateResponse::ResponseType_MIN;
constexpr FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType FetchThreatListUpdatesResponse_ListUpdateResponse::ResponseType_MAX;
constexpr int FetchThreatListUpdatesResponse_ListUpdateResponse::ResponseType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool ThreatHit_ThreatSourceType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ThreatHit_ThreatSourceType_strings[4] = {};

static const char ThreatHit_ThreatSourceType_names[] =
  "MATCHING_URL"
  "TAB_REDIRECT"
  "TAB_URL"
  "THREAT_SOURCE_TYPE_UNSPECIFIED";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ThreatHit_ThreatSourceType_entries[] = {
  { {ThreatHit_ThreatSourceType_names + 0, 12}, 1 },
  { {ThreatHit_ThreatSourceType_names + 12, 12}, 3 },
  { {ThreatHit_ThreatSourceType_names + 24, 7}, 2 },
  { {ThreatHit_ThreatSourceType_names + 31, 30}, 0 },
};

static const int ThreatHit_ThreatSourceType_entries_by_number[] = {
  3, // 0 -> THREAT_SOURCE_TYPE_UNSPECIFIED
  0, // 1 -> MATCHING_URL
  2, // 2 -> TAB_URL
  1, // 3 -> TAB_REDIRECT
};

const std::string& ThreatHit_ThreatSourceType_Name(
    ThreatHit_ThreatSourceType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ThreatHit_ThreatSourceType_entries,
          ThreatHit_ThreatSourceType_entries_by_number,
          4, ThreatHit_ThreatSourceType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ThreatHit_ThreatSourceType_entries,
      ThreatHit_ThreatSourceType_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ThreatHit_ThreatSourceType_strings[idx].get();
}
bool ThreatHit_ThreatSourceType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ThreatHit_ThreatSourceType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ThreatHit_ThreatSourceType_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<ThreatHit_ThreatSourceType>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ThreatHit_ThreatSourceType ThreatHit::THREAT_SOURCE_TYPE_UNSPECIFIED;
constexpr ThreatHit_ThreatSourceType ThreatHit::MATCHING_URL;
constexpr ThreatHit_ThreatSourceType ThreatHit::TAB_URL;
constexpr ThreatHit_ThreatSourceType ThreatHit::TAB_REDIRECT;
constexpr ThreatHit_ThreatSourceType ThreatHit::ThreatSourceType_MIN;
constexpr ThreatHit_ThreatSourceType ThreatHit::ThreatSourceType_MAX;
constexpr int ThreatHit::ThreatSourceType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool ChromeClientInfo_SafeBrowsingReportingPopulation_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ChromeClientInfo_SafeBrowsingReportingPopulation_strings[4] = {};

static const char ChromeClientInfo_SafeBrowsingReportingPopulation_names[] =
  "EXTENDED"
  "OPT_OUT"
  "SCOUT"
  "UNSPECIFIED";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ChromeClientInfo_SafeBrowsingReportingPopulation_entries[] = {
  { {ChromeClientInfo_SafeBrowsingReportingPopulation_names + 0, 8}, 2 },
  { {ChromeClientInfo_SafeBrowsingReportingPopulation_names + 8, 7}, 1 },
  { {ChromeClientInfo_SafeBrowsingReportingPopulation_names + 15, 5}, 3 },
  { {ChromeClientInfo_SafeBrowsingReportingPopulation_names + 20, 11}, 0 },
};

static const int ChromeClientInfo_SafeBrowsingReportingPopulation_entries_by_number[] = {
  3, // 0 -> UNSPECIFIED
  1, // 1 -> OPT_OUT
  0, // 2 -> EXTENDED
  2, // 3 -> SCOUT
};

const std::string& ChromeClientInfo_SafeBrowsingReportingPopulation_Name(
    ChromeClientInfo_SafeBrowsingReportingPopulation value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ChromeClientInfo_SafeBrowsingReportingPopulation_entries,
          ChromeClientInfo_SafeBrowsingReportingPopulation_entries_by_number,
          4, ChromeClientInfo_SafeBrowsingReportingPopulation_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ChromeClientInfo_SafeBrowsingReportingPopulation_entries,
      ChromeClientInfo_SafeBrowsingReportingPopulation_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ChromeClientInfo_SafeBrowsingReportingPopulation_strings[idx].get();
}
bool ChromeClientInfo_SafeBrowsingReportingPopulation_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ChromeClientInfo_SafeBrowsingReportingPopulation* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ChromeClientInfo_SafeBrowsingReportingPopulation_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<ChromeClientInfo_SafeBrowsingReportingPopulation>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ChromeClientInfo_SafeBrowsingReportingPopulation ChromeClientInfo::UNSPECIFIED;
constexpr ChromeClientInfo_SafeBrowsingReportingPopulation ChromeClientInfo::OPT_OUT;
constexpr ChromeClientInfo_SafeBrowsingReportingPopulation ChromeClientInfo::EXTENDED;
constexpr ChromeClientInfo_SafeBrowsingReportingPopulation ChromeClientInfo::SCOUT;
constexpr ChromeClientInfo_SafeBrowsingReportingPopulation ChromeClientInfo::SafeBrowsingReportingPopulation_MIN;
constexpr ChromeClientInfo_SafeBrowsingReportingPopulation ChromeClientInfo::SafeBrowsingReportingPopulation_MAX;
constexpr int ChromeClientInfo::SafeBrowsingReportingPopulation_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool ThreatType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ThreatType_strings[16] = {};

static const char ThreatType_names[] =
  "ACCURACY_TIPS"
  "API_ABUSE"
  "BILLING"
  "CLIENT_INCIDENT"
  "CSD_DOWNLOAD_WHITELIST"
  "CSD_WHITELIST"
  "HIGH_CONFIDENCE_ALLOWLIST"
  "MALICIOUS_BINARY"
  "MALWARE_THREAT"
  "POTENTIALLY_HARMFUL_APPLICATION"
  "SOCIAL_ENGINEERING"
  "SOCIAL_ENGINEERING_PUBLIC"
  "SUBRESOURCE_FILTER"
  "SUSPICIOUS"
  "THREAT_TYPE_UNSPECIFIED"
  "UNWANTED_SOFTWARE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ThreatType_entries[] = {
  { {ThreatType_names + 0, 13}, 17 },
  { {ThreatType_names + 13, 9}, 6 },
  { {ThreatType_names + 22, 7}, 15 },
  { {ThreatType_names + 29, 15}, 10 },
  { {ThreatType_names + 44, 22}, 9 },
  { {ThreatType_names + 66, 13}, 8 },
  { {ThreatType_names + 79, 25}, 16 },
  { {ThreatType_names + 104, 16}, 7 },
  { {ThreatType_names + 120, 14}, 1 },
  { {ThreatType_names + 134, 31}, 4 },
  { {ThreatType_names + 165, 18}, 5 },
  { {ThreatType_names + 183, 25}, 2 },
  { {ThreatType_names + 208, 18}, 13 },
  { {ThreatType_names + 226, 10}, 14 },
  { {ThreatType_names + 236, 23}, 0 },
  { {ThreatType_names + 259, 17}, 3 },
};

static const int ThreatType_entries_by_number[] = {
  14, // 0 -> THREAT_TYPE_UNSPECIFIED
  8, // 1 -> MALWARE_THREAT
  11, // 2 -> SOCIAL_ENGINEERING_PUBLIC
  15, // 3 -> UNWANTED_SOFTWARE
  9, // 4 -> POTENTIALLY_HARMFUL_APPLICATION
  10, // 5 -> SOCIAL_ENGINEERING
  1, // 6 -> API_ABUSE
  7, // 7 -> MALICIOUS_BINARY
  5, // 8 -> CSD_WHITELIST
  4, // 9 -> CSD_DOWNLOAD_WHITELIST
  3, // 10 -> CLIENT_INCIDENT
  12, // 13 -> SUBRESOURCE_FILTER
  13, // 14 -> SUSPICIOUS
  2, // 15 -> BILLING
  6, // 16 -> HIGH_CONFIDENCE_ALLOWLIST
  0, // 17 -> ACCURACY_TIPS
};

const std::string& ThreatType_Name(
    ThreatType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ThreatType_entries,
          ThreatType_entries_by_number,
          16, ThreatType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ThreatType_entries,
      ThreatType_entries_by_number,
      16, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ThreatType_strings[idx].get();
}
bool ThreatType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ThreatType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ThreatType_entries, 16, name, &int_value);
  if (success) {
    *value = static_cast<ThreatType>(int_value);
  }
  return success;
}
bool PlatformType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> PlatformType_strings[9] = {};

static const char PlatformType_names[] =
  "ALL_PLATFORMS"
  "ANDROID_PLATFORM"
  "ANY_PLATFORM"
  "CHROME_PLATFORM"
  "IOS_PLATFORM"
  "LINUX_PLATFORM"
  "OSX_PLATFORM"
  "PLATFORM_TYPE_UNSPECIFIED"
  "WINDOWS_PLATFORM";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry PlatformType_entries[] = {
  { {PlatformType_names + 0, 13}, 7 },
  { {PlatformType_names + 13, 16}, 3 },
  { {PlatformType_names + 29, 12}, 6 },
  { {PlatformType_names + 41, 15}, 8 },
  { {PlatformType_names + 56, 12}, 5 },
  { {PlatformType_names + 68, 14}, 2 },
  { {PlatformType_names + 82, 12}, 4 },
  { {PlatformType_names + 94, 25}, 0 },
  { {PlatformType_names + 119, 16}, 1 },
};

static const int PlatformType_entries_by_number[] = {
  7, // 0 -> PLATFORM_TYPE_UNSPECIFIED
  8, // 1 -> WINDOWS_PLATFORM
  5, // 2 -> LINUX_PLATFORM
  1, // 3 -> ANDROID_PLATFORM
  6, // 4 -> OSX_PLATFORM
  4, // 5 -> IOS_PLATFORM
  2, // 6 -> ANY_PLATFORM
  0, // 7 -> ALL_PLATFORMS
  3, // 8 -> CHROME_PLATFORM
};

const std::string& PlatformType_Name(
    PlatformType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          PlatformType_entries,
          PlatformType_entries_by_number,
          9, PlatformType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      PlatformType_entries,
      PlatformType_entries_by_number,
      9, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     PlatformType_strings[idx].get();
}
bool PlatformType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PlatformType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      PlatformType_entries, 9, name, &int_value);
  if (success) {
    *value = static_cast<PlatformType>(int_value);
  }
  return success;
}
bool CompressionType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> CompressionType_strings[3] = {};

static const char CompressionType_names[] =
  "COMPRESSION_TYPE_UNSPECIFIED"
  "RAW"
  "RICE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry CompressionType_entries[] = {
  { {CompressionType_names + 0, 28}, 0 },
  { {CompressionType_names + 28, 3}, 1 },
  { {CompressionType_names + 31, 4}, 2 },
};

static const int CompressionType_entries_by_number[] = {
  0, // 0 -> COMPRESSION_TYPE_UNSPECIFIED
  1, // 1 -> RAW
  2, // 2 -> RICE
};

const std::string& CompressionType_Name(
    CompressionType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          CompressionType_entries,
          CompressionType_entries_by_number,
          3, CompressionType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      CompressionType_entries,
      CompressionType_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     CompressionType_strings[idx].get();
}
bool CompressionType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CompressionType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      CompressionType_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<CompressionType>(int_value);
  }
  return success;
}
bool ThreatEntryType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ThreatEntryType_strings[7] = {};

static const char ThreatEntryType_names[] =
  "CERT"
  "CHROME_EXTENSION"
  "EXECUTABLE"
  "FILENAME"
  "IP_RANGE"
  "THREAT_ENTRY_TYPE_UNSPECIFIED"
  "URL";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ThreatEntryType_entries[] = {
  { {ThreatEntryType_names + 0, 4}, 6 },
  { {ThreatEntryType_names + 4, 16}, 4 },
  { {ThreatEntryType_names + 20, 10}, 2 },
  { {ThreatEntryType_names + 30, 8}, 5 },
  { {ThreatEntryType_names + 38, 8}, 3 },
  { {ThreatEntryType_names + 46, 29}, 0 },
  { {ThreatEntryType_names + 75, 3}, 1 },
};

static const int ThreatEntryType_entries_by_number[] = {
  5, // 0 -> THREAT_ENTRY_TYPE_UNSPECIFIED
  6, // 1 -> URL
  2, // 2 -> EXECUTABLE
  4, // 3 -> IP_RANGE
  1, // 4 -> CHROME_EXTENSION
  3, // 5 -> FILENAME
  0, // 6 -> CERT
};

const std::string& ThreatEntryType_Name(
    ThreatEntryType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ThreatEntryType_entries,
          ThreatEntryType_entries_by_number,
          7, ThreatEntryType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ThreatEntryType_entries,
      ThreatEntryType_entries_by_number,
      7, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ThreatEntryType_strings[idx].get();
}
bool ThreatEntryType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ThreatEntryType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ThreatEntryType_entries, 7, name, &int_value);
  if (success) {
    *value = static_cast<ThreatEntryType>(int_value);
  }
  return success;
}

// ===================================================================

class ThreatInfo::_Internal {
 public:
};

ThreatInfo::ThreatInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  threat_types_(arena),
  platform_types_(arena),
  threat_entries_(arena),
  threat_entry_types_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:safe_browsing.ThreatInfo)
}
ThreatInfo::ThreatInfo(const ThreatInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      threat_types_(from.threat_types_),
      platform_types_(from.platform_types_),
      threat_entries_(from.threat_entries_),
      threat_entry_types_(from.threat_entry_types_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:safe_browsing.ThreatInfo)
}

inline void ThreatInfo::SharedCtor() {
}

ThreatInfo::~ThreatInfo() {
  // @@protoc_insertion_point(destructor:safe_browsing.ThreatInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ThreatInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ThreatInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ThreatInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:safe_browsing.ThreatInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  threat_types_.Clear();
  platform_types_.Clear();
  threat_entries_.Clear();
  threat_entry_types_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ThreatInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .safe_browsing.ThreatType threat_types = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          ptr -= 1;
          do {
            ptr += 1;
            uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
            CHK_(ptr);
            if (PROTOBUF_PREDICT_TRUE(::safe_browsing::ThreatType_IsValid(val))) {
              _internal_add_threat_types(static_cast<::safe_browsing::ThreatType>(val));
            } else {
              ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
            }
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<8>(ptr));
        } else if (static_cast<uint8_t>(tag) == 10) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedEnumParser<std::string>(_internal_mutable_threat_types(), ptr, ctx, ::safe_browsing::ThreatType_IsValid, &_internal_metadata_, 1);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .safe_browsing.PlatformType platform_types = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          ptr -= 1;
          do {
            ptr += 1;
            uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
            CHK_(ptr);
            if (PROTOBUF_PREDICT_TRUE(::safe_browsing::PlatformType_IsValid(val))) {
              _internal_add_platform_types(static_cast<::safe_browsing::PlatformType>(val));
            } else {
              ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
            }
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<16>(ptr));
        } else if (static_cast<uint8_t>(tag) == 18) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedEnumParser<std::string>(_internal_mutable_platform_types(), ptr, ctx, ::safe_browsing::PlatformType_IsValid, &_internal_metadata_, 2);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .safe_browsing.ThreatEntry threat_entries = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_threat_entries(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .safe_browsing.ThreatEntryType threat_entry_types = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          ptr -= 1;
          do {
            ptr += 1;
            uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
            CHK_(ptr);
            if (PROTOBUF_PREDICT_TRUE(::safe_browsing::ThreatEntryType_IsValid(val))) {
              _internal_add_threat_entry_types(static_cast<::safe_browsing::ThreatEntryType>(val));
            } else {
              ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
            }
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<32>(ptr));
        } else if (static_cast<uint8_t>(tag) == 34) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedEnumParser<std::string>(_internal_mutable_threat_entry_types(), ptr, ctx, ::safe_browsing::ThreatEntryType_IsValid, &_internal_metadata_, 4);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ThreatInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ThreatInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .safe_browsing.ThreatType threat_types = 1;
  for (int i = 0, n = this->_internal_threat_types_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        1, this->_internal_threat_types(i), target);
  }

  // repeated .safe_browsing.PlatformType platform_types = 2;
  for (int i = 0, n = this->_internal_platform_types_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        2, this->_internal_platform_types(i), target);
  }

  // repeated .safe_browsing.ThreatEntry threat_entries = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_threat_entries_size()); i < n; i++) {
    const auto& repfield = this->_internal_threat_entries(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .safe_browsing.ThreatEntryType threat_entry_types = 4;
  for (int i = 0, n = this->_internal_threat_entry_types_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        4, this->_internal_threat_entry_types(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ThreatInfo)
  return target;
}

size_t ThreatInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:safe_browsing.ThreatInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .safe_browsing.ThreatType threat_types = 1;
  {
    size_t data_size = 0;
    unsigned int count = static_cast<unsigned int>(this->_internal_threat_types_size());for (unsigned int i = 0; i < count; i++) {
      data_size += ::_pbi::WireFormatLite::EnumSize(
        this->_internal_threat_types(static_cast<int>(i)));
    }
    total_size += (1UL * count) + data_size;
  }

  // repeated .safe_browsing.PlatformType platform_types = 2;
  {
    size_t data_size = 0;
    unsigned int count = static_cast<unsigned int>(this->_internal_platform_types_size());for (unsigned int i = 0; i < count; i++) {
      data_size += ::_pbi::WireFormatLite::EnumSize(
        this->_internal_platform_types(static_cast<int>(i)));
    }
    total_size += (1UL * count) + data_size;
  }

  // repeated .safe_browsing.ThreatEntry threat_entries = 3;
  total_size += 1UL * this->_internal_threat_entries_size();
  for (const auto& msg : this->threat_entries_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .safe_browsing.ThreatEntryType threat_entry_types = 4;
  {
    size_t data_size = 0;
    unsigned int count = static_cast<unsigned int>(this->_internal_threat_entry_types_size());for (unsigned int i = 0; i < count; i++) {
      data_size += ::_pbi::WireFormatLite::EnumSize(
        this->_internal_threat_entry_types(static_cast<int>(i)));
    }
    total_size += (1UL * count) + data_size;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ThreatInfo::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ThreatInfo*>(
      &from));
}

void ThreatInfo::MergeFrom(const ThreatInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ThreatInfo)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  threat_types_.MergeFrom(from.threat_types_);
  platform_types_.MergeFrom(from.platform_types_);
  threat_entries_.MergeFrom(from.threat_entries_);
  threat_entry_types_.MergeFrom(from.threat_entry_types_);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ThreatInfo::CopyFrom(const ThreatInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ThreatInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ThreatInfo::IsInitialized() const {
  return true;
}

void ThreatInfo::InternalSwap(ThreatInfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  threat_types_.InternalSwap(&other->threat_types_);
  platform_types_.InternalSwap(&other->platform_types_);
  threat_entries_.InternalSwap(&other->threat_entries_);
  threat_entry_types_.InternalSwap(&other->threat_entry_types_);
}

std::string ThreatInfo::GetTypeName() const {
  return "safe_browsing.ThreatInfo";
}


// ===================================================================

class ThreatMatch::_Internal {
 public:
  using HasBits = decltype(std::declval<ThreatMatch>()._has_bits_);
  static void set_has_threat_type(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_platform_type(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_threat_entry_type(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static const ::safe_browsing::ThreatEntry& threat(const ThreatMatch* msg);
  static void set_has_threat(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::safe_browsing::ThreatEntryMetadata& threat_entry_metadata(const ThreatMatch* msg);
  static void set_has_threat_entry_metadata(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::safe_browsing::Duration& cache_duration(const ThreatMatch* msg);
  static void set_has_cache_duration(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::safe_browsing::ThreatEntry&
ThreatMatch::_Internal::threat(const ThreatMatch* msg) {
  return *msg->threat_;
}
const ::safe_browsing::ThreatEntryMetadata&
ThreatMatch::_Internal::threat_entry_metadata(const ThreatMatch* msg) {
  return *msg->threat_entry_metadata_;
}
const ::safe_browsing::Duration&
ThreatMatch::_Internal::cache_duration(const ThreatMatch* msg) {
  return *msg->cache_duration_;
}
ThreatMatch::ThreatMatch(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:safe_browsing.ThreatMatch)
}
ThreatMatch::ThreatMatch(const ThreatMatch& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_threat()) {
    threat_ = new ::safe_browsing::ThreatEntry(*from.threat_);
  } else {
    threat_ = nullptr;
  }
  if (from._internal_has_threat_entry_metadata()) {
    threat_entry_metadata_ = new ::safe_browsing::ThreatEntryMetadata(*from.threat_entry_metadata_);
  } else {
    threat_entry_metadata_ = nullptr;
  }
  if (from._internal_has_cache_duration()) {
    cache_duration_ = new ::safe_browsing::Duration(*from.cache_duration_);
  } else {
    cache_duration_ = nullptr;
  }
  ::memcpy(&threat_type_, &from.threat_type_,
    static_cast<size_t>(reinterpret_cast<char*>(&threat_entry_type_) -
    reinterpret_cast<char*>(&threat_type_)) + sizeof(threat_entry_type_));
  // @@protoc_insertion_point(copy_constructor:safe_browsing.ThreatMatch)
}

inline void ThreatMatch::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&threat_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&threat_entry_type_) -
    reinterpret_cast<char*>(&threat_)) + sizeof(threat_entry_type_));
}

ThreatMatch::~ThreatMatch() {
  // @@protoc_insertion_point(destructor:safe_browsing.ThreatMatch)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ThreatMatch::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete threat_;
  if (this != internal_default_instance()) delete threat_entry_metadata_;
  if (this != internal_default_instance()) delete cache_duration_;
}

void ThreatMatch::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ThreatMatch::Clear() {
// @@protoc_insertion_point(message_clear_start:safe_browsing.ThreatMatch)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(threat_ != nullptr);
      threat_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(threat_entry_metadata_ != nullptr);
      threat_entry_metadata_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(cache_duration_ != nullptr);
      cache_duration_->Clear();
    }
  }
  if (cached_has_bits & 0x00000038u) {
    ::memset(&threat_type_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&threat_entry_type_) -
        reinterpret_cast<char*>(&threat_type_)) + sizeof(threat_entry_type_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ThreatMatch::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .safe_browsing.ThreatType threat_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::safe_browsing::ThreatType_IsValid(val))) {
            _internal_set_threat_type(static_cast<::safe_browsing::ThreatType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .safe_browsing.PlatformType platform_type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::safe_browsing::PlatformType_IsValid(val))) {
            _internal_set_platform_type(static_cast<::safe_browsing::PlatformType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .safe_browsing.ThreatEntry threat = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_threat(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .safe_browsing.ThreatEntryMetadata threat_entry_metadata = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_threat_entry_metadata(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .safe_browsing.Duration cache_duration = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_cache_duration(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .safe_browsing.ThreatEntryType threat_entry_type = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::safe_browsing::ThreatEntryType_IsValid(val))) {
            _internal_set_threat_entry_type(static_cast<::safe_browsing::ThreatEntryType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(6, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ThreatMatch::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ThreatMatch)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .safe_browsing.ThreatType threat_type = 1;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_threat_type(), target);
  }

  // optional .safe_browsing.PlatformType platform_type = 2;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_platform_type(), target);
  }

  // optional .safe_browsing.ThreatEntry threat = 3;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::threat(this),
        _Internal::threat(this).GetCachedSize(), target, stream);
  }

  // optional .safe_browsing.ThreatEntryMetadata threat_entry_metadata = 4;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::threat_entry_metadata(this),
        _Internal::threat_entry_metadata(this).GetCachedSize(), target, stream);
  }

  // optional .safe_browsing.Duration cache_duration = 5;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::cache_duration(this),
        _Internal::cache_duration(this).GetCachedSize(), target, stream);
  }

  // optional .safe_browsing.ThreatEntryType threat_entry_type = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      6, this->_internal_threat_entry_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ThreatMatch)
  return target;
}

size_t ThreatMatch::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:safe_browsing.ThreatMatch)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional .safe_browsing.ThreatEntry threat = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *threat_);
    }

    // optional .safe_browsing.ThreatEntryMetadata threat_entry_metadata = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *threat_entry_metadata_);
    }

    // optional .safe_browsing.Duration cache_duration = 5;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *cache_duration_);
    }

    // optional .safe_browsing.ThreatType threat_type = 1;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_threat_type());
    }

    // optional .safe_browsing.PlatformType platform_type = 2;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_platform_type());
    }

    // optional .safe_browsing.ThreatEntryType threat_entry_type = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_threat_entry_type());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ThreatMatch::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ThreatMatch*>(
      &from));
}

void ThreatMatch::MergeFrom(const ThreatMatch& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ThreatMatch)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_threat()->::safe_browsing::ThreatEntry::MergeFrom(from._internal_threat());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_threat_entry_metadata()->::safe_browsing::ThreatEntryMetadata::MergeFrom(from._internal_threat_entry_metadata());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_cache_duration()->::safe_browsing::Duration::MergeFrom(from._internal_cache_duration());
    }
    if (cached_has_bits & 0x00000008u) {
      threat_type_ = from.threat_type_;
    }
    if (cached_has_bits & 0x00000010u) {
      platform_type_ = from.platform_type_;
    }
    if (cached_has_bits & 0x00000020u) {
      threat_entry_type_ = from.threat_entry_type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ThreatMatch::CopyFrom(const ThreatMatch& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ThreatMatch)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ThreatMatch::IsInitialized() const {
  return true;
}

void ThreatMatch::InternalSwap(ThreatMatch* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ThreatMatch, threat_entry_type_)
      + sizeof(ThreatMatch::threat_entry_type_)
      - PROTOBUF_FIELD_OFFSET(ThreatMatch, threat_)>(
          reinterpret_cast<char*>(&threat_),
          reinterpret_cast<char*>(&other->threat_));
}

std::string ThreatMatch::GetTypeName() const {
  return "safe_browsing.ThreatMatch";
}


// ===================================================================

class FindThreatMatchesRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<FindThreatMatchesRequest>()._has_bits_);
  static const ::safe_browsing::ClientInfo& client(const FindThreatMatchesRequest* msg);
  static void set_has_client(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::safe_browsing::ThreatInfo& threat_info(const FindThreatMatchesRequest* msg);
  static void set_has_threat_info(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::safe_browsing::ClientInfo&
FindThreatMatchesRequest::_Internal::client(const FindThreatMatchesRequest* msg) {
  return *msg->client_;
}
const ::safe_browsing::ThreatInfo&
FindThreatMatchesRequest::_Internal::threat_info(const FindThreatMatchesRequest* msg) {
  return *msg->threat_info_;
}
FindThreatMatchesRequest::FindThreatMatchesRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:safe_browsing.FindThreatMatchesRequest)
}
FindThreatMatchesRequest::FindThreatMatchesRequest(const FindThreatMatchesRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_client()) {
    client_ = new ::safe_browsing::ClientInfo(*from.client_);
  } else {
    client_ = nullptr;
  }
  if (from._internal_has_threat_info()) {
    threat_info_ = new ::safe_browsing::ThreatInfo(*from.threat_info_);
  } else {
    threat_info_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:safe_browsing.FindThreatMatchesRequest)
}

inline void FindThreatMatchesRequest::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&client_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&threat_info_) -
    reinterpret_cast<char*>(&client_)) + sizeof(threat_info_));
}

FindThreatMatchesRequest::~FindThreatMatchesRequest() {
  // @@protoc_insertion_point(destructor:safe_browsing.FindThreatMatchesRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void FindThreatMatchesRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete client_;
  if (this != internal_default_instance()) delete threat_info_;
}

void FindThreatMatchesRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void FindThreatMatchesRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:safe_browsing.FindThreatMatchesRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(client_ != nullptr);
      client_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(threat_info_ != nullptr);
      threat_info_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* FindThreatMatchesRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .safe_browsing.ClientInfo client = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_client(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .safe_browsing.ThreatInfo threat_info = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_threat_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FindThreatMatchesRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.FindThreatMatchesRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .safe_browsing.ClientInfo client = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::client(this),
        _Internal::client(this).GetCachedSize(), target, stream);
  }

  // optional .safe_browsing.ThreatInfo threat_info = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::threat_info(this),
        _Internal::threat_info(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.FindThreatMatchesRequest)
  return target;
}

size_t FindThreatMatchesRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:safe_browsing.FindThreatMatchesRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .safe_browsing.ClientInfo client = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *client_);
    }

    // optional .safe_browsing.ThreatInfo threat_info = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *threat_info_);
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void FindThreatMatchesRequest::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const FindThreatMatchesRequest*>(
      &from));
}

void FindThreatMatchesRequest::MergeFrom(const FindThreatMatchesRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.FindThreatMatchesRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_client()->::safe_browsing::ClientInfo::MergeFrom(from._internal_client());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_threat_info()->::safe_browsing::ThreatInfo::MergeFrom(from._internal_threat_info());
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void FindThreatMatchesRequest::CopyFrom(const FindThreatMatchesRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.FindThreatMatchesRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FindThreatMatchesRequest::IsInitialized() const {
  return true;
}

void FindThreatMatchesRequest::InternalSwap(FindThreatMatchesRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(FindThreatMatchesRequest, threat_info_)
      + sizeof(FindThreatMatchesRequest::threat_info_)
      - PROTOBUF_FIELD_OFFSET(FindThreatMatchesRequest, client_)>(
          reinterpret_cast<char*>(&client_),
          reinterpret_cast<char*>(&other->client_));
}

std::string FindThreatMatchesRequest::GetTypeName() const {
  return "safe_browsing.FindThreatMatchesRequest";
}


// ===================================================================

class FindThreatMatchesResponse::_Internal {
 public:
};

FindThreatMatchesResponse::FindThreatMatchesResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  matches_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:safe_browsing.FindThreatMatchesResponse)
}
FindThreatMatchesResponse::FindThreatMatchesResponse(const FindThreatMatchesResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      matches_(from.matches_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:safe_browsing.FindThreatMatchesResponse)
}

inline void FindThreatMatchesResponse::SharedCtor() {
}

FindThreatMatchesResponse::~FindThreatMatchesResponse() {
  // @@protoc_insertion_point(destructor:safe_browsing.FindThreatMatchesResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void FindThreatMatchesResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void FindThreatMatchesResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void FindThreatMatchesResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:safe_browsing.FindThreatMatchesResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  matches_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* FindThreatMatchesResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .safe_browsing.ThreatMatch matches = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_matches(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FindThreatMatchesResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.FindThreatMatchesResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .safe_browsing.ThreatMatch matches = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_matches_size()); i < n; i++) {
    const auto& repfield = this->_internal_matches(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.FindThreatMatchesResponse)
  return target;
}

size_t FindThreatMatchesResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:safe_browsing.FindThreatMatchesResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .safe_browsing.ThreatMatch matches = 1;
  total_size += 1UL * this->_internal_matches_size();
  for (const auto& msg : this->matches_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void FindThreatMatchesResponse::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const FindThreatMatchesResponse*>(
      &from));
}

void FindThreatMatchesResponse::MergeFrom(const FindThreatMatchesResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.FindThreatMatchesResponse)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  matches_.MergeFrom(from.matches_);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void FindThreatMatchesResponse::CopyFrom(const FindThreatMatchesResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.FindThreatMatchesResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FindThreatMatchesResponse::IsInitialized() const {
  return true;
}

void FindThreatMatchesResponse::InternalSwap(FindThreatMatchesResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  matches_.InternalSwap(&other->matches_);
}

std::string FindThreatMatchesResponse::GetTypeName() const {
  return "safe_browsing.FindThreatMatchesResponse";
}


// ===================================================================

class FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::_Internal {
 public:
  using HasBits = decltype(std::declval<FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints>()._has_bits_);
  static void set_has_max_update_entries(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_max_database_entries(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_region(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  supported_compressions_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints)
}
FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints(const FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      supported_compressions_(from.supported_compressions_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  region_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    region_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_region()) {
    region_.Set(from._internal_region(), 
      GetArenaForAllocation());
  }
  ::memcpy(&max_update_entries_, &from.max_update_entries_,
    static_cast<size_t>(reinterpret_cast<char*>(&max_database_entries_) -
    reinterpret_cast<char*>(&max_update_entries_)) + sizeof(max_database_entries_));
  // @@protoc_insertion_point(copy_constructor:safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints)
}

inline void FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::SharedCtor() {
region_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  region_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&max_update_entries_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&max_database_entries_) -
    reinterpret_cast<char*>(&max_update_entries_)) + sizeof(max_database_entries_));
}

FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::~FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints() {
  // @@protoc_insertion_point(destructor:safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  region_.Destroy();
}

void FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::Clear() {
// @@protoc_insertion_point(message_clear_start:safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  supported_compressions_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    region_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&max_update_entries_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&max_database_entries_) -
        reinterpret_cast<char*>(&max_update_entries_)) + sizeof(max_database_entries_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 max_update_entries = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_max_update_entries(&has_bits);
          max_update_entries_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 max_database_entries = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_max_database_entries(&has_bits);
          max_database_entries_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string region = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_region();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .safe_browsing.CompressionType supported_compressions = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          ptr -= 1;
          do {
            ptr += 1;
            uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
            CHK_(ptr);
            if (PROTOBUF_PREDICT_TRUE(::safe_browsing::CompressionType_IsValid(val))) {
              _internal_add_supported_compressions(static_cast<::safe_browsing::CompressionType>(val));
            } else {
              ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
            }
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<32>(ptr));
        } else if (static_cast<uint8_t>(tag) == 34) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedEnumParser<std::string>(_internal_mutable_supported_compressions(), ptr, ctx, ::safe_browsing::CompressionType_IsValid, &_internal_metadata_, 4);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 max_update_entries = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_max_update_entries(), target);
  }

  // optional int32 max_database_entries = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_max_database_entries(), target);
  }

  // optional string region = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_region(), target);
  }

  // repeated .safe_browsing.CompressionType supported_compressions = 4;
  for (int i = 0, n = this->_internal_supported_compressions_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        4, this->_internal_supported_compressions(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints)
  return target;
}

size_t FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .safe_browsing.CompressionType supported_compressions = 4;
  {
    size_t data_size = 0;
    unsigned int count = static_cast<unsigned int>(this->_internal_supported_compressions_size());for (unsigned int i = 0; i < count; i++) {
      data_size += ::_pbi::WireFormatLite::EnumSize(
        this->_internal_supported_compressions(static_cast<int>(i)));
    }
    total_size += (1UL * count) + data_size;
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string region = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_region());
    }

    // optional int32 max_update_entries = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_max_update_entries());
    }

    // optional int32 max_database_entries = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_max_database_entries());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints*>(
      &from));
}

void FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::MergeFrom(const FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  supported_compressions_.MergeFrom(from.supported_compressions_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_region(from._internal_region());
    }
    if (cached_has_bits & 0x00000002u) {
      max_update_entries_ = from.max_update_entries_;
    }
    if (cached_has_bits & 0x00000004u) {
      max_database_entries_ = from.max_database_entries_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::CopyFrom(const FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::IsInitialized() const {
  return true;
}

void FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::InternalSwap(FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  supported_compressions_.InternalSwap(&other->supported_compressions_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &region_, lhs_arena,
      &other->region_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints, max_database_entries_)
      + sizeof(FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::max_database_entries_)
      - PROTOBUF_FIELD_OFFSET(FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints, max_update_entries_)>(
          reinterpret_cast<char*>(&max_update_entries_),
          reinterpret_cast<char*>(&other->max_update_entries_));
}

std::string FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::GetTypeName() const {
  return "safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints";
}


// ===================================================================

class FetchThreatListUpdatesRequest_ListUpdateRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<FetchThreatListUpdatesRequest_ListUpdateRequest>()._has_bits_);
  static void set_has_threat_type(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_platform_type(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_threat_entry_type(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_state(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::safe_browsing::FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints& constraints(const FetchThreatListUpdatesRequest_ListUpdateRequest* msg);
  static void set_has_constraints(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::safe_browsing::FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints&
FetchThreatListUpdatesRequest_ListUpdateRequest::_Internal::constraints(const FetchThreatListUpdatesRequest_ListUpdateRequest* msg) {
  return *msg->constraints_;
}
FetchThreatListUpdatesRequest_ListUpdateRequest::FetchThreatListUpdatesRequest_ListUpdateRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest)
}
FetchThreatListUpdatesRequest_ListUpdateRequest::FetchThreatListUpdatesRequest_ListUpdateRequest(const FetchThreatListUpdatesRequest_ListUpdateRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  state_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    state_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_state()) {
    state_.Set(from._internal_state(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_constraints()) {
    constraints_ = new ::safe_browsing::FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints(*from.constraints_);
  } else {
    constraints_ = nullptr;
  }
  ::memcpy(&threat_type_, &from.threat_type_,
    static_cast<size_t>(reinterpret_cast<char*>(&threat_entry_type_) -
    reinterpret_cast<char*>(&threat_type_)) + sizeof(threat_entry_type_));
  // @@protoc_insertion_point(copy_constructor:safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest)
}

inline void FetchThreatListUpdatesRequest_ListUpdateRequest::SharedCtor() {
state_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  state_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&constraints_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&threat_entry_type_) -
    reinterpret_cast<char*>(&constraints_)) + sizeof(threat_entry_type_));
}

FetchThreatListUpdatesRequest_ListUpdateRequest::~FetchThreatListUpdatesRequest_ListUpdateRequest() {
  // @@protoc_insertion_point(destructor:safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void FetchThreatListUpdatesRequest_ListUpdateRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  state_.Destroy();
  if (this != internal_default_instance()) delete constraints_;
}

void FetchThreatListUpdatesRequest_ListUpdateRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void FetchThreatListUpdatesRequest_ListUpdateRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      state_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(constraints_ != nullptr);
      constraints_->Clear();
    }
  }
  if (cached_has_bits & 0x0000001cu) {
    ::memset(&threat_type_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&threat_entry_type_) -
        reinterpret_cast<char*>(&threat_type_)) + sizeof(threat_entry_type_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* FetchThreatListUpdatesRequest_ListUpdateRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .safe_browsing.ThreatType threat_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::safe_browsing::ThreatType_IsValid(val))) {
            _internal_set_threat_type(static_cast<::safe_browsing::ThreatType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .safe_browsing.PlatformType platform_type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::safe_browsing::PlatformType_IsValid(val))) {
            _internal_set_platform_type(static_cast<::safe_browsing::PlatformType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional bytes state = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_state();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints constraints = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_constraints(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .safe_browsing.ThreatEntryType threat_entry_type = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::safe_browsing::ThreatEntryType_IsValid(val))) {
            _internal_set_threat_entry_type(static_cast<::safe_browsing::ThreatEntryType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(5, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FetchThreatListUpdatesRequest_ListUpdateRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .safe_browsing.ThreatType threat_type = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_threat_type(), target);
  }

  // optional .safe_browsing.PlatformType platform_type = 2;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_platform_type(), target);
  }

  // optional bytes state = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_state(), target);
  }

  // optional .safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints constraints = 4;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::constraints(this),
        _Internal::constraints(this).GetCachedSize(), target, stream);
  }

  // optional .safe_browsing.ThreatEntryType threat_entry_type = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      5, this->_internal_threat_entry_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest)
  return target;
}

size_t FetchThreatListUpdatesRequest_ListUpdateRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional bytes state = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_state());
    }

    // optional .safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints constraints = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *constraints_);
    }

    // optional .safe_browsing.ThreatType threat_type = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_threat_type());
    }

    // optional .safe_browsing.PlatformType platform_type = 2;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_platform_type());
    }

    // optional .safe_browsing.ThreatEntryType threat_entry_type = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_threat_entry_type());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void FetchThreatListUpdatesRequest_ListUpdateRequest::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const FetchThreatListUpdatesRequest_ListUpdateRequest*>(
      &from));
}

void FetchThreatListUpdatesRequest_ListUpdateRequest::MergeFrom(const FetchThreatListUpdatesRequest_ListUpdateRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_state(from._internal_state());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_constraints()->::safe_browsing::FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::MergeFrom(from._internal_constraints());
    }
    if (cached_has_bits & 0x00000004u) {
      threat_type_ = from.threat_type_;
    }
    if (cached_has_bits & 0x00000008u) {
      platform_type_ = from.platform_type_;
    }
    if (cached_has_bits & 0x00000010u) {
      threat_entry_type_ = from.threat_entry_type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void FetchThreatListUpdatesRequest_ListUpdateRequest::CopyFrom(const FetchThreatListUpdatesRequest_ListUpdateRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FetchThreatListUpdatesRequest_ListUpdateRequest::IsInitialized() const {
  return true;
}

void FetchThreatListUpdatesRequest_ListUpdateRequest::InternalSwap(FetchThreatListUpdatesRequest_ListUpdateRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &state_, lhs_arena,
      &other->state_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(FetchThreatListUpdatesRequest_ListUpdateRequest, threat_entry_type_)
      + sizeof(FetchThreatListUpdatesRequest_ListUpdateRequest::threat_entry_type_)
      - PROTOBUF_FIELD_OFFSET(FetchThreatListUpdatesRequest_ListUpdateRequest, constraints_)>(
          reinterpret_cast<char*>(&constraints_),
          reinterpret_cast<char*>(&other->constraints_));
}

std::string FetchThreatListUpdatesRequest_ListUpdateRequest::GetTypeName() const {
  return "safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest";
}


// ===================================================================

class FetchThreatListUpdatesRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<FetchThreatListUpdatesRequest>()._has_bits_);
  static const ::safe_browsing::ClientInfo& client(const FetchThreatListUpdatesRequest* msg);
  static void set_has_client(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::safe_browsing::ChromeClientInfo& chrome_client_info(const FetchThreatListUpdatesRequest* msg);
  static void set_has_chrome_client_info(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::safe_browsing::ClientInfo&
FetchThreatListUpdatesRequest::_Internal::client(const FetchThreatListUpdatesRequest* msg) {
  return *msg->client_;
}
const ::safe_browsing::ChromeClientInfo&
FetchThreatListUpdatesRequest::_Internal::chrome_client_info(const FetchThreatListUpdatesRequest* msg) {
  return *msg->chrome_client_info_;
}
FetchThreatListUpdatesRequest::FetchThreatListUpdatesRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  list_update_requests_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:safe_browsing.FetchThreatListUpdatesRequest)
}
FetchThreatListUpdatesRequest::FetchThreatListUpdatesRequest(const FetchThreatListUpdatesRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      list_update_requests_(from.list_update_requests_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_client()) {
    client_ = new ::safe_browsing::ClientInfo(*from.client_);
  } else {
    client_ = nullptr;
  }
  if (from._internal_has_chrome_client_info()) {
    chrome_client_info_ = new ::safe_browsing::ChromeClientInfo(*from.chrome_client_info_);
  } else {
    chrome_client_info_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:safe_browsing.FetchThreatListUpdatesRequest)
}

inline void FetchThreatListUpdatesRequest::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&client_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&chrome_client_info_) -
    reinterpret_cast<char*>(&client_)) + sizeof(chrome_client_info_));
}

FetchThreatListUpdatesRequest::~FetchThreatListUpdatesRequest() {
  // @@protoc_insertion_point(destructor:safe_browsing.FetchThreatListUpdatesRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void FetchThreatListUpdatesRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete client_;
  if (this != internal_default_instance()) delete chrome_client_info_;
}

void FetchThreatListUpdatesRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void FetchThreatListUpdatesRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:safe_browsing.FetchThreatListUpdatesRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  list_update_requests_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(client_ != nullptr);
      client_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(chrome_client_info_ != nullptr);
      chrome_client_info_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* FetchThreatListUpdatesRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .safe_browsing.ClientInfo client = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_client(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest list_update_requests = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_list_update_requests(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .safe_browsing.ChromeClientInfo chrome_client_info = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_chrome_client_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FetchThreatListUpdatesRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.FetchThreatListUpdatesRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .safe_browsing.ClientInfo client = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::client(this),
        _Internal::client(this).GetCachedSize(), target, stream);
  }

  // repeated .safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest list_update_requests = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_list_update_requests_size()); i < n; i++) {
    const auto& repfield = this->_internal_list_update_requests(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional .safe_browsing.ChromeClientInfo chrome_client_info = 4;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::chrome_client_info(this),
        _Internal::chrome_client_info(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.FetchThreatListUpdatesRequest)
  return target;
}

size_t FetchThreatListUpdatesRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:safe_browsing.FetchThreatListUpdatesRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .safe_browsing.FetchThreatListUpdatesRequest.ListUpdateRequest list_update_requests = 3;
  total_size += 1UL * this->_internal_list_update_requests_size();
  for (const auto& msg : this->list_update_requests_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .safe_browsing.ClientInfo client = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *client_);
    }

    // optional .safe_browsing.ChromeClientInfo chrome_client_info = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *chrome_client_info_);
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void FetchThreatListUpdatesRequest::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const FetchThreatListUpdatesRequest*>(
      &from));
}

void FetchThreatListUpdatesRequest::MergeFrom(const FetchThreatListUpdatesRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.FetchThreatListUpdatesRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  list_update_requests_.MergeFrom(from.list_update_requests_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_client()->::safe_browsing::ClientInfo::MergeFrom(from._internal_client());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_chrome_client_info()->::safe_browsing::ChromeClientInfo::MergeFrom(from._internal_chrome_client_info());
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void FetchThreatListUpdatesRequest::CopyFrom(const FetchThreatListUpdatesRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.FetchThreatListUpdatesRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FetchThreatListUpdatesRequest::IsInitialized() const {
  return true;
}

void FetchThreatListUpdatesRequest::InternalSwap(FetchThreatListUpdatesRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  list_update_requests_.InternalSwap(&other->list_update_requests_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(FetchThreatListUpdatesRequest, chrome_client_info_)
      + sizeof(FetchThreatListUpdatesRequest::chrome_client_info_)
      - PROTOBUF_FIELD_OFFSET(FetchThreatListUpdatesRequest, client_)>(
          reinterpret_cast<char*>(&client_),
          reinterpret_cast<char*>(&other->client_));
}

std::string FetchThreatListUpdatesRequest::GetTypeName() const {
  return "safe_browsing.FetchThreatListUpdatesRequest";
}


// ===================================================================

class FetchThreatListUpdatesResponse_ListUpdateResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<FetchThreatListUpdatesResponse_ListUpdateResponse>()._has_bits_);
  static void set_has_threat_type(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_threat_entry_type(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_platform_type(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_response_type(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_new_client_state(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::safe_browsing::Checksum& checksum(const FetchThreatListUpdatesResponse_ListUpdateResponse* msg);
  static void set_has_checksum(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::safe_browsing::Checksum&
FetchThreatListUpdatesResponse_ListUpdateResponse::_Internal::checksum(const FetchThreatListUpdatesResponse_ListUpdateResponse* msg) {
  return *msg->checksum_;
}
FetchThreatListUpdatesResponse_ListUpdateResponse::FetchThreatListUpdatesResponse_ListUpdateResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  additions_(arena),
  removals_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:safe_browsing.FetchThreatListUpdatesResponse.ListUpdateResponse)
}
FetchThreatListUpdatesResponse_ListUpdateResponse::FetchThreatListUpdatesResponse_ListUpdateResponse(const FetchThreatListUpdatesResponse_ListUpdateResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      additions_(from.additions_),
      removals_(from.removals_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  new_client_state_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    new_client_state_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_new_client_state()) {
    new_client_state_.Set(from._internal_new_client_state(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_checksum()) {
    checksum_ = new ::safe_browsing::Checksum(*from.checksum_);
  } else {
    checksum_ = nullptr;
  }
  ::memcpy(&threat_type_, &from.threat_type_,
    static_cast<size_t>(reinterpret_cast<char*>(&response_type_) -
    reinterpret_cast<char*>(&threat_type_)) + sizeof(response_type_));
  // @@protoc_insertion_point(copy_constructor:safe_browsing.FetchThreatListUpdatesResponse.ListUpdateResponse)
}

inline void FetchThreatListUpdatesResponse_ListUpdateResponse::SharedCtor() {
new_client_state_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  new_client_state_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&checksum_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&response_type_) -
    reinterpret_cast<char*>(&checksum_)) + sizeof(response_type_));
}

FetchThreatListUpdatesResponse_ListUpdateResponse::~FetchThreatListUpdatesResponse_ListUpdateResponse() {
  // @@protoc_insertion_point(destructor:safe_browsing.FetchThreatListUpdatesResponse.ListUpdateResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void FetchThreatListUpdatesResponse_ListUpdateResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  new_client_state_.Destroy();
  if (this != internal_default_instance()) delete checksum_;
}

void FetchThreatListUpdatesResponse_ListUpdateResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void FetchThreatListUpdatesResponse_ListUpdateResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:safe_browsing.FetchThreatListUpdatesResponse.ListUpdateResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  additions_.Clear();
  removals_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      new_client_state_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(checksum_ != nullptr);
      checksum_->Clear();
    }
  }
  if (cached_has_bits & 0x0000003cu) {
    ::memset(&threat_type_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&response_type_) -
        reinterpret_cast<char*>(&threat_type_)) + sizeof(response_type_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* FetchThreatListUpdatesResponse_ListUpdateResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .safe_browsing.ThreatType threat_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::safe_browsing::ThreatType_IsValid(val))) {
            _internal_set_threat_type(static_cast<::safe_browsing::ThreatType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .safe_browsing.ThreatEntryType threat_entry_type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::safe_browsing::ThreatEntryType_IsValid(val))) {
            _internal_set_threat_entry_type(static_cast<::safe_browsing::ThreatEntryType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .safe_browsing.PlatformType platform_type = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::safe_browsing::PlatformType_IsValid(val))) {
            _internal_set_platform_type(static_cast<::safe_browsing::PlatformType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .safe_browsing.FetchThreatListUpdatesResponse.ListUpdateResponse.ResponseType response_type = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::safe_browsing::FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType_IsValid(val))) {
            _internal_set_response_type(static_cast<::safe_browsing::FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // repeated .safe_browsing.ThreatEntrySet additions = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_additions(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .safe_browsing.ThreatEntrySet removals = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_removals(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional bytes new_client_state = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_new_client_state();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .safe_browsing.Checksum checksum = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_checksum(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FetchThreatListUpdatesResponse_ListUpdateResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.FetchThreatListUpdatesResponse.ListUpdateResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .safe_browsing.ThreatType threat_type = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_threat_type(), target);
  }

  // optional .safe_browsing.ThreatEntryType threat_entry_type = 2;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_threat_entry_type(), target);
  }

  // optional .safe_browsing.PlatformType platform_type = 3;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_platform_type(), target);
  }

  // optional .safe_browsing.FetchThreatListUpdatesResponse.ListUpdateResponse.ResponseType response_type = 4;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      4, this->_internal_response_type(), target);
  }

  // repeated .safe_browsing.ThreatEntrySet additions = 5;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_additions_size()); i < n; i++) {
    const auto& repfield = this->_internal_additions(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(5, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .safe_browsing.ThreatEntrySet removals = 6;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_removals_size()); i < n; i++) {
    const auto& repfield = this->_internal_removals(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(6, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional bytes new_client_state = 7;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        7, this->_internal_new_client_state(), target);
  }

  // optional .safe_browsing.Checksum checksum = 8;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, _Internal::checksum(this),
        _Internal::checksum(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.FetchThreatListUpdatesResponse.ListUpdateResponse)
  return target;
}

size_t FetchThreatListUpdatesResponse_ListUpdateResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:safe_browsing.FetchThreatListUpdatesResponse.ListUpdateResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .safe_browsing.ThreatEntrySet additions = 5;
  total_size += 1UL * this->_internal_additions_size();
  for (const auto& msg : this->additions_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .safe_browsing.ThreatEntrySet removals = 6;
  total_size += 1UL * this->_internal_removals_size();
  for (const auto& msg : this->removals_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional bytes new_client_state = 7;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_new_client_state());
    }

    // optional .safe_browsing.Checksum checksum = 8;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *checksum_);
    }

    // optional .safe_browsing.ThreatType threat_type = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_threat_type());
    }

    // optional .safe_browsing.ThreatEntryType threat_entry_type = 2;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_threat_entry_type());
    }

    // optional .safe_browsing.PlatformType platform_type = 3;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_platform_type());
    }

    // optional .safe_browsing.FetchThreatListUpdatesResponse.ListUpdateResponse.ResponseType response_type = 4;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_response_type());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void FetchThreatListUpdatesResponse_ListUpdateResponse::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const FetchThreatListUpdatesResponse_ListUpdateResponse*>(
      &from));
}

void FetchThreatListUpdatesResponse_ListUpdateResponse::MergeFrom(const FetchThreatListUpdatesResponse_ListUpdateResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.FetchThreatListUpdatesResponse.ListUpdateResponse)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  additions_.MergeFrom(from.additions_);
  removals_.MergeFrom(from.removals_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_new_client_state(from._internal_new_client_state());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_checksum()->::safe_browsing::Checksum::MergeFrom(from._internal_checksum());
    }
    if (cached_has_bits & 0x00000004u) {
      threat_type_ = from.threat_type_;
    }
    if (cached_has_bits & 0x00000008u) {
      threat_entry_type_ = from.threat_entry_type_;
    }
    if (cached_has_bits & 0x00000010u) {
      platform_type_ = from.platform_type_;
    }
    if (cached_has_bits & 0x00000020u) {
      response_type_ = from.response_type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void FetchThreatListUpdatesResponse_ListUpdateResponse::CopyFrom(const FetchThreatListUpdatesResponse_ListUpdateResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.FetchThreatListUpdatesResponse.ListUpdateResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FetchThreatListUpdatesResponse_ListUpdateResponse::IsInitialized() const {
  return true;
}

void FetchThreatListUpdatesResponse_ListUpdateResponse::InternalSwap(FetchThreatListUpdatesResponse_ListUpdateResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  additions_.InternalSwap(&other->additions_);
  removals_.InternalSwap(&other->removals_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &new_client_state_, lhs_arena,
      &other->new_client_state_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(FetchThreatListUpdatesResponse_ListUpdateResponse, response_type_)
      + sizeof(FetchThreatListUpdatesResponse_ListUpdateResponse::response_type_)
      - PROTOBUF_FIELD_OFFSET(FetchThreatListUpdatesResponse_ListUpdateResponse, checksum_)>(
          reinterpret_cast<char*>(&checksum_),
          reinterpret_cast<char*>(&other->checksum_));
}

std::string FetchThreatListUpdatesResponse_ListUpdateResponse::GetTypeName() const {
  return "safe_browsing.FetchThreatListUpdatesResponse.ListUpdateResponse";
}


// ===================================================================

class FetchThreatListUpdatesResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<FetchThreatListUpdatesResponse>()._has_bits_);
  static const ::safe_browsing::Duration& minimum_wait_duration(const FetchThreatListUpdatesResponse* msg);
  static void set_has_minimum_wait_duration(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::safe_browsing::Duration&
FetchThreatListUpdatesResponse::_Internal::minimum_wait_duration(const FetchThreatListUpdatesResponse* msg) {
  return *msg->minimum_wait_duration_;
}
FetchThreatListUpdatesResponse::FetchThreatListUpdatesResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  list_update_responses_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:safe_browsing.FetchThreatListUpdatesResponse)
}
FetchThreatListUpdatesResponse::FetchThreatListUpdatesResponse(const FetchThreatListUpdatesResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      list_update_responses_(from.list_update_responses_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_minimum_wait_duration()) {
    minimum_wait_duration_ = new ::safe_browsing::Duration(*from.minimum_wait_duration_);
  } else {
    minimum_wait_duration_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:safe_browsing.FetchThreatListUpdatesResponse)
}

inline void FetchThreatListUpdatesResponse::SharedCtor() {
minimum_wait_duration_ = nullptr;
}

FetchThreatListUpdatesResponse::~FetchThreatListUpdatesResponse() {
  // @@protoc_insertion_point(destructor:safe_browsing.FetchThreatListUpdatesResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void FetchThreatListUpdatesResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete minimum_wait_duration_;
}

void FetchThreatListUpdatesResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void FetchThreatListUpdatesResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:safe_browsing.FetchThreatListUpdatesResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  list_update_responses_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(minimum_wait_duration_ != nullptr);
    minimum_wait_duration_->Clear();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* FetchThreatListUpdatesResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .safe_browsing.FetchThreatListUpdatesResponse.ListUpdateResponse list_update_responses = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_list_update_responses(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .safe_browsing.Duration minimum_wait_duration = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_minimum_wait_duration(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FetchThreatListUpdatesResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.FetchThreatListUpdatesResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .safe_browsing.FetchThreatListUpdatesResponse.ListUpdateResponse list_update_responses = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_list_update_responses_size()); i < n; i++) {
    const auto& repfield = this->_internal_list_update_responses(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  cached_has_bits = _has_bits_[0];
  // optional .safe_browsing.Duration minimum_wait_duration = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::minimum_wait_duration(this),
        _Internal::minimum_wait_duration(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.FetchThreatListUpdatesResponse)
  return target;
}

size_t FetchThreatListUpdatesResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:safe_browsing.FetchThreatListUpdatesResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .safe_browsing.FetchThreatListUpdatesResponse.ListUpdateResponse list_update_responses = 1;
  total_size += 1UL * this->_internal_list_update_responses_size();
  for (const auto& msg : this->list_update_responses_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional .safe_browsing.Duration minimum_wait_duration = 2;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *minimum_wait_duration_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void FetchThreatListUpdatesResponse::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const FetchThreatListUpdatesResponse*>(
      &from));
}

void FetchThreatListUpdatesResponse::MergeFrom(const FetchThreatListUpdatesResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.FetchThreatListUpdatesResponse)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  list_update_responses_.MergeFrom(from.list_update_responses_);
  if (from._internal_has_minimum_wait_duration()) {
    _internal_mutable_minimum_wait_duration()->::safe_browsing::Duration::MergeFrom(from._internal_minimum_wait_duration());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void FetchThreatListUpdatesResponse::CopyFrom(const FetchThreatListUpdatesResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.FetchThreatListUpdatesResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FetchThreatListUpdatesResponse::IsInitialized() const {
  return true;
}

void FetchThreatListUpdatesResponse::InternalSwap(FetchThreatListUpdatesResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  list_update_responses_.InternalSwap(&other->list_update_responses_);
  swap(minimum_wait_duration_, other->minimum_wait_duration_);
}

std::string FetchThreatListUpdatesResponse::GetTypeName() const {
  return "safe_browsing.FetchThreatListUpdatesResponse";
}


// ===================================================================

class FindFullHashesRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<FindFullHashesRequest>()._has_bits_);
  static const ::safe_browsing::ClientInfo& client(const FindFullHashesRequest* msg);
  static void set_has_client(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::safe_browsing::ThreatInfo& threat_info(const FindFullHashesRequest* msg);
  static void set_has_threat_info(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::safe_browsing::ClientInfo&
FindFullHashesRequest::_Internal::client(const FindFullHashesRequest* msg) {
  return *msg->client_;
}
const ::safe_browsing::ThreatInfo&
FindFullHashesRequest::_Internal::threat_info(const FindFullHashesRequest* msg) {
  return *msg->threat_info_;
}
FindFullHashesRequest::FindFullHashesRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  client_states_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:safe_browsing.FindFullHashesRequest)
}
FindFullHashesRequest::FindFullHashesRequest(const FindFullHashesRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      client_states_(from.client_states_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_client()) {
    client_ = new ::safe_browsing::ClientInfo(*from.client_);
  } else {
    client_ = nullptr;
  }
  if (from._internal_has_threat_info()) {
    threat_info_ = new ::safe_browsing::ThreatInfo(*from.threat_info_);
  } else {
    threat_info_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:safe_browsing.FindFullHashesRequest)
}

inline void FindFullHashesRequest::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&client_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&threat_info_) -
    reinterpret_cast<char*>(&client_)) + sizeof(threat_info_));
}

FindFullHashesRequest::~FindFullHashesRequest() {
  // @@protoc_insertion_point(destructor:safe_browsing.FindFullHashesRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void FindFullHashesRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete client_;
  if (this != internal_default_instance()) delete threat_info_;
}

void FindFullHashesRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void FindFullHashesRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:safe_browsing.FindFullHashesRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  client_states_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(client_ != nullptr);
      client_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(threat_info_ != nullptr);
      threat_info_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* FindFullHashesRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .safe_browsing.ClientInfo client = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_client(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated bytes client_states = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_client_states();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .safe_browsing.ThreatInfo threat_info = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_threat_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FindFullHashesRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.FindFullHashesRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .safe_browsing.ClientInfo client = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::client(this),
        _Internal::client(this).GetCachedSize(), target, stream);
  }

  // repeated bytes client_states = 2;
  for (int i = 0, n = this->_internal_client_states_size(); i < n; i++) {
    const auto& s = this->_internal_client_states(i);
    target = stream->WriteBytes(2, s, target);
  }

  // optional .safe_browsing.ThreatInfo threat_info = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::threat_info(this),
        _Internal::threat_info(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.FindFullHashesRequest)
  return target;
}

size_t FindFullHashesRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:safe_browsing.FindFullHashesRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated bytes client_states = 2;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(client_states_.size());
  for (int i = 0, n = client_states_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
      client_states_.Get(i));
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .safe_browsing.ClientInfo client = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *client_);
    }

    // optional .safe_browsing.ThreatInfo threat_info = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *threat_info_);
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void FindFullHashesRequest::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const FindFullHashesRequest*>(
      &from));
}

void FindFullHashesRequest::MergeFrom(const FindFullHashesRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.FindFullHashesRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  client_states_.MergeFrom(from.client_states_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_client()->::safe_browsing::ClientInfo::MergeFrom(from._internal_client());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_threat_info()->::safe_browsing::ThreatInfo::MergeFrom(from._internal_threat_info());
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void FindFullHashesRequest::CopyFrom(const FindFullHashesRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.FindFullHashesRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FindFullHashesRequest::IsInitialized() const {
  return true;
}

void FindFullHashesRequest::InternalSwap(FindFullHashesRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  client_states_.InternalSwap(&other->client_states_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(FindFullHashesRequest, threat_info_)
      + sizeof(FindFullHashesRequest::threat_info_)
      - PROTOBUF_FIELD_OFFSET(FindFullHashesRequest, client_)>(
          reinterpret_cast<char*>(&client_),
          reinterpret_cast<char*>(&other->client_));
}

std::string FindFullHashesRequest::GetTypeName() const {
  return "safe_browsing.FindFullHashesRequest";
}


// ===================================================================

class FindFullHashesResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<FindFullHashesResponse>()._has_bits_);
  static const ::safe_browsing::Duration& minimum_wait_duration(const FindFullHashesResponse* msg);
  static void set_has_minimum_wait_duration(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::safe_browsing::Duration& negative_cache_duration(const FindFullHashesResponse* msg);
  static void set_has_negative_cache_duration(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::safe_browsing::Duration&
FindFullHashesResponse::_Internal::minimum_wait_duration(const FindFullHashesResponse* msg) {
  return *msg->minimum_wait_duration_;
}
const ::safe_browsing::Duration&
FindFullHashesResponse::_Internal::negative_cache_duration(const FindFullHashesResponse* msg) {
  return *msg->negative_cache_duration_;
}
FindFullHashesResponse::FindFullHashesResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  matches_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:safe_browsing.FindFullHashesResponse)
}
FindFullHashesResponse::FindFullHashesResponse(const FindFullHashesResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      matches_(from.matches_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_minimum_wait_duration()) {
    minimum_wait_duration_ = new ::safe_browsing::Duration(*from.minimum_wait_duration_);
  } else {
    minimum_wait_duration_ = nullptr;
  }
  if (from._internal_has_negative_cache_duration()) {
    negative_cache_duration_ = new ::safe_browsing::Duration(*from.negative_cache_duration_);
  } else {
    negative_cache_duration_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:safe_browsing.FindFullHashesResponse)
}

inline void FindFullHashesResponse::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&minimum_wait_duration_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&negative_cache_duration_) -
    reinterpret_cast<char*>(&minimum_wait_duration_)) + sizeof(negative_cache_duration_));
}

FindFullHashesResponse::~FindFullHashesResponse() {
  // @@protoc_insertion_point(destructor:safe_browsing.FindFullHashesResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void FindFullHashesResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete minimum_wait_duration_;
  if (this != internal_default_instance()) delete negative_cache_duration_;
}

void FindFullHashesResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void FindFullHashesResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:safe_browsing.FindFullHashesResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  matches_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(minimum_wait_duration_ != nullptr);
      minimum_wait_duration_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(negative_cache_duration_ != nullptr);
      negative_cache_duration_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* FindFullHashesResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .safe_browsing.ThreatMatch matches = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_matches(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .safe_browsing.Duration minimum_wait_duration = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_minimum_wait_duration(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .safe_browsing.Duration negative_cache_duration = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_negative_cache_duration(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FindFullHashesResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.FindFullHashesResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .safe_browsing.ThreatMatch matches = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_matches_size()); i < n; i++) {
    const auto& repfield = this->_internal_matches(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  cached_has_bits = _has_bits_[0];
  // optional .safe_browsing.Duration minimum_wait_duration = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::minimum_wait_duration(this),
        _Internal::minimum_wait_duration(this).GetCachedSize(), target, stream);
  }

  // optional .safe_browsing.Duration negative_cache_duration = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::negative_cache_duration(this),
        _Internal::negative_cache_duration(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.FindFullHashesResponse)
  return target;
}

size_t FindFullHashesResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:safe_browsing.FindFullHashesResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .safe_browsing.ThreatMatch matches = 1;
  total_size += 1UL * this->_internal_matches_size();
  for (const auto& msg : this->matches_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .safe_browsing.Duration minimum_wait_duration = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *minimum_wait_duration_);
    }

    // optional .safe_browsing.Duration negative_cache_duration = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *negative_cache_duration_);
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void FindFullHashesResponse::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const FindFullHashesResponse*>(
      &from));
}

void FindFullHashesResponse::MergeFrom(const FindFullHashesResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.FindFullHashesResponse)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  matches_.MergeFrom(from.matches_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_minimum_wait_duration()->::safe_browsing::Duration::MergeFrom(from._internal_minimum_wait_duration());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_negative_cache_duration()->::safe_browsing::Duration::MergeFrom(from._internal_negative_cache_duration());
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void FindFullHashesResponse::CopyFrom(const FindFullHashesResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.FindFullHashesResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FindFullHashesResponse::IsInitialized() const {
  return true;
}

void FindFullHashesResponse::InternalSwap(FindFullHashesResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  matches_.InternalSwap(&other->matches_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(FindFullHashesResponse, negative_cache_duration_)
      + sizeof(FindFullHashesResponse::negative_cache_duration_)
      - PROTOBUF_FIELD_OFFSET(FindFullHashesResponse, minimum_wait_duration_)>(
          reinterpret_cast<char*>(&minimum_wait_duration_),
          reinterpret_cast<char*>(&other->minimum_wait_duration_));
}

std::string FindFullHashesResponse::GetTypeName() const {
  return "safe_browsing.FindFullHashesResponse";
}


// ===================================================================

class ThreatHit_ThreatSource::_Internal {
 public:
  using HasBits = decltype(std::declval<ThreatHit_ThreatSource>()._has_bits_);
  static void set_has_url(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_remote_ip(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_referrer(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

ThreatHit_ThreatSource::ThreatHit_ThreatSource(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:safe_browsing.ThreatHit.ThreatSource)
}
ThreatHit_ThreatSource::ThreatHit_ThreatSource(const ThreatHit_ThreatSource& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_url()) {
    url_.Set(from._internal_url(), 
      GetArenaForAllocation());
  }
  remote_ip_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    remote_ip_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_remote_ip()) {
    remote_ip_.Set(from._internal_remote_ip(), 
      GetArenaForAllocation());
  }
  referrer_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    referrer_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_referrer()) {
    referrer_.Set(from._internal_referrer(), 
      GetArenaForAllocation());
  }
  type_ = from.type_;
  // @@protoc_insertion_point(copy_constructor:safe_browsing.ThreatHit.ThreatSource)
}

inline void ThreatHit_ThreatSource::SharedCtor() {
url_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  url_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
remote_ip_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  remote_ip_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
referrer_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  referrer_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
type_ = 0;
}

ThreatHit_ThreatSource::~ThreatHit_ThreatSource() {
  // @@protoc_insertion_point(destructor:safe_browsing.ThreatHit.ThreatSource)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ThreatHit_ThreatSource::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  url_.Destroy();
  remote_ip_.Destroy();
  referrer_.Destroy();
}

void ThreatHit_ThreatSource::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ThreatHit_ThreatSource::Clear() {
// @@protoc_insertion_point(message_clear_start:safe_browsing.ThreatHit.ThreatSource)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      url_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      remote_ip_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      referrer_.ClearNonDefaultToEmpty();
    }
  }
  type_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ThreatHit_ThreatSource::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string url = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_url();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .safe_browsing.ThreatHit.ThreatSourceType type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::safe_browsing::ThreatHit_ThreatSourceType_IsValid(val))) {
            _internal_set_type(static_cast<::safe_browsing::ThreatHit_ThreatSourceType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional string remote_ip = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_remote_ip();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string referrer = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_referrer();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ThreatHit_ThreatSource::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ThreatHit.ThreatSource)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string url = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_url(), target);
  }

  // optional .safe_browsing.ThreatHit.ThreatSourceType type = 2;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_type(), target);
  }

  // optional string remote_ip = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_remote_ip(), target);
  }

  // optional string referrer = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_referrer(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ThreatHit.ThreatSource)
  return target;
}

size_t ThreatHit_ThreatSource::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:safe_browsing.ThreatHit.ThreatSource)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string url = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_url());
    }

    // optional string remote_ip = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_remote_ip());
    }

    // optional string referrer = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_referrer());
    }

    // optional .safe_browsing.ThreatHit.ThreatSourceType type = 2;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ThreatHit_ThreatSource::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ThreatHit_ThreatSource*>(
      &from));
}

void ThreatHit_ThreatSource::MergeFrom(const ThreatHit_ThreatSource& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ThreatHit.ThreatSource)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_url(from._internal_url());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_remote_ip(from._internal_remote_ip());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_referrer(from._internal_referrer());
    }
    if (cached_has_bits & 0x00000008u) {
      type_ = from.type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ThreatHit_ThreatSource::CopyFrom(const ThreatHit_ThreatSource& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ThreatHit.ThreatSource)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ThreatHit_ThreatSource::IsInitialized() const {
  return true;
}

void ThreatHit_ThreatSource::InternalSwap(ThreatHit_ThreatSource* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &url_, lhs_arena,
      &other->url_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &remote_ip_, lhs_arena,
      &other->remote_ip_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &referrer_, lhs_arena,
      &other->referrer_, rhs_arena
  );
  swap(type_, other->type_);
}

std::string ThreatHit_ThreatSource::GetTypeName() const {
  return "safe_browsing.ThreatHit.ThreatSource";
}


// ===================================================================

class ThreatHit::_Internal {
 public:
  using HasBits = decltype(std::declval<ThreatHit>()._has_bits_);
  static void set_has_threat_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_platform_type(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::safe_browsing::ThreatEntry& entry(const ThreatHit* msg);
  static void set_has_entry(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::safe_browsing::ThreatEntry&
ThreatHit::_Internal::entry(const ThreatHit* msg) {
  return *msg->entry_;
}
ThreatHit::ThreatHit(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  resources_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:safe_browsing.ThreatHit)
}
ThreatHit::ThreatHit(const ThreatHit& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      resources_(from.resources_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_entry()) {
    entry_ = new ::safe_browsing::ThreatEntry(*from.entry_);
  } else {
    entry_ = nullptr;
  }
  ::memcpy(&threat_type_, &from.threat_type_,
    static_cast<size_t>(reinterpret_cast<char*>(&platform_type_) -
    reinterpret_cast<char*>(&threat_type_)) + sizeof(platform_type_));
  // @@protoc_insertion_point(copy_constructor:safe_browsing.ThreatHit)
}

inline void ThreatHit::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&entry_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&platform_type_) -
    reinterpret_cast<char*>(&entry_)) + sizeof(platform_type_));
}

ThreatHit::~ThreatHit() {
  // @@protoc_insertion_point(destructor:safe_browsing.ThreatHit)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ThreatHit::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete entry_;
}

void ThreatHit::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ThreatHit::Clear() {
// @@protoc_insertion_point(message_clear_start:safe_browsing.ThreatHit)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  resources_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(entry_ != nullptr);
    entry_->Clear();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&threat_type_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&platform_type_) -
        reinterpret_cast<char*>(&threat_type_)) + sizeof(platform_type_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ThreatHit::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .safe_browsing.ThreatType threat_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::safe_browsing::ThreatType_IsValid(val))) {
            _internal_set_threat_type(static_cast<::safe_browsing::ThreatType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .safe_browsing.PlatformType platform_type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::safe_browsing::PlatformType_IsValid(val))) {
            _internal_set_platform_type(static_cast<::safe_browsing::PlatformType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .safe_browsing.ThreatEntry entry = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_entry(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .safe_browsing.ThreatHit.ThreatSource resources = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_resources(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ThreatHit::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ThreatHit)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .safe_browsing.ThreatType threat_type = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_threat_type(), target);
  }

  // optional .safe_browsing.PlatformType platform_type = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_platform_type(), target);
  }

  // optional .safe_browsing.ThreatEntry entry = 3;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::entry(this),
        _Internal::entry(this).GetCachedSize(), target, stream);
  }

  // repeated .safe_browsing.ThreatHit.ThreatSource resources = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_resources_size()); i < n; i++) {
    const auto& repfield = this->_internal_resources(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ThreatHit)
  return target;
}

size_t ThreatHit::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:safe_browsing.ThreatHit)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .safe_browsing.ThreatHit.ThreatSource resources = 4;
  total_size += 1UL * this->_internal_resources_size();
  for (const auto& msg : this->resources_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .safe_browsing.ThreatEntry entry = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *entry_);
    }

    // optional .safe_browsing.ThreatType threat_type = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_threat_type());
    }

    // optional .safe_browsing.PlatformType platform_type = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_platform_type());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ThreatHit::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ThreatHit*>(
      &from));
}

void ThreatHit::MergeFrom(const ThreatHit& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ThreatHit)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  resources_.MergeFrom(from.resources_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_entry()->::safe_browsing::ThreatEntry::MergeFrom(from._internal_entry());
    }
    if (cached_has_bits & 0x00000002u) {
      threat_type_ = from.threat_type_;
    }
    if (cached_has_bits & 0x00000004u) {
      platform_type_ = from.platform_type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ThreatHit::CopyFrom(const ThreatHit& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ThreatHit)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ThreatHit::IsInitialized() const {
  return true;
}

void ThreatHit::InternalSwap(ThreatHit* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  resources_.InternalSwap(&other->resources_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ThreatHit, platform_type_)
      + sizeof(ThreatHit::platform_type_)
      - PROTOBUF_FIELD_OFFSET(ThreatHit, entry_)>(
          reinterpret_cast<char*>(&entry_),
          reinterpret_cast<char*>(&other->entry_));
}

std::string ThreatHit::GetTypeName() const {
  return "safe_browsing.ThreatHit";
}


// ===================================================================

class ClientInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<ClientInfo>()._has_bits_);
  static void set_has_client_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_client_version(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

ClientInfo::ClientInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:safe_browsing.ClientInfo)
}
ClientInfo::ClientInfo(const ClientInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  client_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    client_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_client_id()) {
    client_id_.Set(from._internal_client_id(), 
      GetArenaForAllocation());
  }
  client_version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    client_version_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_client_version()) {
    client_version_.Set(from._internal_client_version(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:safe_browsing.ClientInfo)
}

inline void ClientInfo::SharedCtor() {
client_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  client_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
client_version_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  client_version_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ClientInfo::~ClientInfo() {
  // @@protoc_insertion_point(destructor:safe_browsing.ClientInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ClientInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  client_id_.Destroy();
  client_version_.Destroy();
}

void ClientInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ClientInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:safe_browsing.ClientInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      client_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      client_version_.ClearNonDefaultToEmpty();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ClientInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string client_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_client_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string client_version = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_client_version();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ClientInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ClientInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string client_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_client_id(), target);
  }

  // optional string client_version = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_client_version(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ClientInfo)
  return target;
}

size_t ClientInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:safe_browsing.ClientInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string client_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_client_id());
    }

    // optional string client_version = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_client_version());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ClientInfo::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ClientInfo*>(
      &from));
}

void ClientInfo::MergeFrom(const ClientInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ClientInfo)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_client_id(from._internal_client_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_client_version(from._internal_client_version());
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClientInfo::CopyFrom(const ClientInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ClientInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClientInfo::IsInitialized() const {
  return true;
}

void ClientInfo::InternalSwap(ClientInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &client_id_, lhs_arena,
      &other->client_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &client_version_, lhs_arena,
      &other->client_version_, rhs_arena
  );
}

std::string ClientInfo::GetTypeName() const {
  return "safe_browsing.ClientInfo";
}


// ===================================================================

class ChromeClientInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<ChromeClientInfo>()._has_bits_);
  static void set_has_reporting_population(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

ChromeClientInfo::ChromeClientInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:safe_browsing.ChromeClientInfo)
}
ChromeClientInfo::ChromeClientInfo(const ChromeClientInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  reporting_population_ = from.reporting_population_;
  // @@protoc_insertion_point(copy_constructor:safe_browsing.ChromeClientInfo)
}

inline void ChromeClientInfo::SharedCtor() {
reporting_population_ = 0;
}

ChromeClientInfo::~ChromeClientInfo() {
  // @@protoc_insertion_point(destructor:safe_browsing.ChromeClientInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ChromeClientInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ChromeClientInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ChromeClientInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:safe_browsing.ChromeClientInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  reporting_population_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ChromeClientInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .safe_browsing.ChromeClientInfo.SafeBrowsingReportingPopulation reporting_population = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::safe_browsing::ChromeClientInfo_SafeBrowsingReportingPopulation_IsValid(val))) {
            _internal_set_reporting_population(static_cast<::safe_browsing::ChromeClientInfo_SafeBrowsingReportingPopulation>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ChromeClientInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ChromeClientInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .safe_browsing.ChromeClientInfo.SafeBrowsingReportingPopulation reporting_population = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_reporting_population(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ChromeClientInfo)
  return target;
}

size_t ChromeClientInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:safe_browsing.ChromeClientInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .safe_browsing.ChromeClientInfo.SafeBrowsingReportingPopulation reporting_population = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_reporting_population());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ChromeClientInfo::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ChromeClientInfo*>(
      &from));
}

void ChromeClientInfo::MergeFrom(const ChromeClientInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ChromeClientInfo)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_reporting_population()) {
    _internal_set_reporting_population(from._internal_reporting_population());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ChromeClientInfo::CopyFrom(const ChromeClientInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ChromeClientInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ChromeClientInfo::IsInitialized() const {
  return true;
}

void ChromeClientInfo::InternalSwap(ChromeClientInfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(reporting_population_, other->reporting_population_);
}

std::string ChromeClientInfo::GetTypeName() const {
  return "safe_browsing.ChromeClientInfo";
}


// ===================================================================

class Checksum::_Internal {
 public:
  using HasBits = decltype(std::declval<Checksum>()._has_bits_);
  static void set_has_sha256(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

Checksum::Checksum(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:safe_browsing.Checksum)
}
Checksum::Checksum(const Checksum& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  sha256_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    sha256_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_sha256()) {
    sha256_.Set(from._internal_sha256(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:safe_browsing.Checksum)
}

inline void Checksum::SharedCtor() {
sha256_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  sha256_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Checksum::~Checksum() {
  // @@protoc_insertion_point(destructor:safe_browsing.Checksum)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Checksum::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  sha256_.Destroy();
}

void Checksum::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Checksum::Clear() {
// @@protoc_insertion_point(message_clear_start:safe_browsing.Checksum)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    sha256_.ClearNonDefaultToEmpty();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Checksum::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes sha256 = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_sha256();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Checksum::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.Checksum)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bytes sha256 = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_sha256(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.Checksum)
  return target;
}

size_t Checksum::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:safe_browsing.Checksum)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bytes sha256 = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_sha256());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Checksum::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Checksum*>(
      &from));
}

void Checksum::MergeFrom(const Checksum& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.Checksum)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_sha256()) {
    _internal_set_sha256(from._internal_sha256());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Checksum::CopyFrom(const Checksum& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.Checksum)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Checksum::IsInitialized() const {
  return true;
}

void Checksum::InternalSwap(Checksum* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &sha256_, lhs_arena,
      &other->sha256_, rhs_arena
  );
}

std::string Checksum::GetTypeName() const {
  return "safe_browsing.Checksum";
}


// ===================================================================

class ThreatEntry::_Internal {
 public:
  using HasBits = decltype(std::declval<ThreatEntry>()._has_bits_);
  static void set_has_hash(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_url(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

ThreatEntry::ThreatEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:safe_browsing.ThreatEntry)
}
ThreatEntry::ThreatEntry(const ThreatEntry& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  hash_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    hash_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_hash()) {
    hash_.Set(from._internal_hash(), 
      GetArenaForAllocation());
  }
  url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_url()) {
    url_.Set(from._internal_url(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:safe_browsing.ThreatEntry)
}

inline void ThreatEntry::SharedCtor() {
hash_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  hash_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
url_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  url_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ThreatEntry::~ThreatEntry() {
  // @@protoc_insertion_point(destructor:safe_browsing.ThreatEntry)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ThreatEntry::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  hash_.Destroy();
  url_.Destroy();
}

void ThreatEntry::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ThreatEntry::Clear() {
// @@protoc_insertion_point(message_clear_start:safe_browsing.ThreatEntry)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      hash_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      url_.ClearNonDefaultToEmpty();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ThreatEntry::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes hash = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_hash();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string url = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_url();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ThreatEntry::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ThreatEntry)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bytes hash = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_hash(), target);
  }

  // optional string url = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_url(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ThreatEntry)
  return target;
}

size_t ThreatEntry::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:safe_browsing.ThreatEntry)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional bytes hash = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_hash());
    }

    // optional string url = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_url());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ThreatEntry::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ThreatEntry*>(
      &from));
}

void ThreatEntry::MergeFrom(const ThreatEntry& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ThreatEntry)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_hash(from._internal_hash());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_url(from._internal_url());
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ThreatEntry::CopyFrom(const ThreatEntry& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ThreatEntry)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ThreatEntry::IsInitialized() const {
  return true;
}

void ThreatEntry::InternalSwap(ThreatEntry* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &hash_, lhs_arena,
      &other->hash_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &url_, lhs_arena,
      &other->url_, rhs_arena
  );
}

std::string ThreatEntry::GetTypeName() const {
  return "safe_browsing.ThreatEntry";
}


// ===================================================================

class ThreatEntrySet::_Internal {
 public:
  using HasBits = decltype(std::declval<ThreatEntrySet>()._has_bits_);
  static void set_has_compression_type(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::safe_browsing::RawHashes& raw_hashes(const ThreatEntrySet* msg);
  static void set_has_raw_hashes(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::safe_browsing::RawIndices& raw_indices(const ThreatEntrySet* msg);
  static void set_has_raw_indices(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::safe_browsing::RiceDeltaEncoding& rice_hashes(const ThreatEntrySet* msg);
  static void set_has_rice_hashes(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::safe_browsing::RiceDeltaEncoding& rice_indices(const ThreatEntrySet* msg);
  static void set_has_rice_indices(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::safe_browsing::RawHashes&
ThreatEntrySet::_Internal::raw_hashes(const ThreatEntrySet* msg) {
  return *msg->raw_hashes_;
}
const ::safe_browsing::RawIndices&
ThreatEntrySet::_Internal::raw_indices(const ThreatEntrySet* msg) {
  return *msg->raw_indices_;
}
const ::safe_browsing::RiceDeltaEncoding&
ThreatEntrySet::_Internal::rice_hashes(const ThreatEntrySet* msg) {
  return *msg->rice_hashes_;
}
const ::safe_browsing::RiceDeltaEncoding&
ThreatEntrySet::_Internal::rice_indices(const ThreatEntrySet* msg) {
  return *msg->rice_indices_;
}
ThreatEntrySet::ThreatEntrySet(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:safe_browsing.ThreatEntrySet)
}
ThreatEntrySet::ThreatEntrySet(const ThreatEntrySet& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_raw_hashes()) {
    raw_hashes_ = new ::safe_browsing::RawHashes(*from.raw_hashes_);
  } else {
    raw_hashes_ = nullptr;
  }
  if (from._internal_has_raw_indices()) {
    raw_indices_ = new ::safe_browsing::RawIndices(*from.raw_indices_);
  } else {
    raw_indices_ = nullptr;
  }
  if (from._internal_has_rice_hashes()) {
    rice_hashes_ = new ::safe_browsing::RiceDeltaEncoding(*from.rice_hashes_);
  } else {
    rice_hashes_ = nullptr;
  }
  if (from._internal_has_rice_indices()) {
    rice_indices_ = new ::safe_browsing::RiceDeltaEncoding(*from.rice_indices_);
  } else {
    rice_indices_ = nullptr;
  }
  compression_type_ = from.compression_type_;
  // @@protoc_insertion_point(copy_constructor:safe_browsing.ThreatEntrySet)
}

inline void ThreatEntrySet::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&raw_hashes_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&compression_type_) -
    reinterpret_cast<char*>(&raw_hashes_)) + sizeof(compression_type_));
}

ThreatEntrySet::~ThreatEntrySet() {
  // @@protoc_insertion_point(destructor:safe_browsing.ThreatEntrySet)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ThreatEntrySet::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete raw_hashes_;
  if (this != internal_default_instance()) delete raw_indices_;
  if (this != internal_default_instance()) delete rice_hashes_;
  if (this != internal_default_instance()) delete rice_indices_;
}

void ThreatEntrySet::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ThreatEntrySet::Clear() {
// @@protoc_insertion_point(message_clear_start:safe_browsing.ThreatEntrySet)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(raw_hashes_ != nullptr);
      raw_hashes_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(raw_indices_ != nullptr);
      raw_indices_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(rice_hashes_ != nullptr);
      rice_hashes_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(rice_indices_ != nullptr);
      rice_indices_->Clear();
    }
  }
  compression_type_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ThreatEntrySet::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .safe_browsing.CompressionType compression_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::safe_browsing::CompressionType_IsValid(val))) {
            _internal_set_compression_type(static_cast<::safe_browsing::CompressionType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .safe_browsing.RawHashes raw_hashes = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_raw_hashes(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .safe_browsing.RawIndices raw_indices = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_raw_indices(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .safe_browsing.RiceDeltaEncoding rice_hashes = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_rice_hashes(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .safe_browsing.RiceDeltaEncoding rice_indices = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_rice_indices(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ThreatEntrySet::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ThreatEntrySet)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .safe_browsing.CompressionType compression_type = 1;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_compression_type(), target);
  }

  // optional .safe_browsing.RawHashes raw_hashes = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::raw_hashes(this),
        _Internal::raw_hashes(this).GetCachedSize(), target, stream);
  }

  // optional .safe_browsing.RawIndices raw_indices = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::raw_indices(this),
        _Internal::raw_indices(this).GetCachedSize(), target, stream);
  }

  // optional .safe_browsing.RiceDeltaEncoding rice_hashes = 4;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::rice_hashes(this),
        _Internal::rice_hashes(this).GetCachedSize(), target, stream);
  }

  // optional .safe_browsing.RiceDeltaEncoding rice_indices = 5;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::rice_indices(this),
        _Internal::rice_indices(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ThreatEntrySet)
  return target;
}

size_t ThreatEntrySet::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:safe_browsing.ThreatEntrySet)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional .safe_browsing.RawHashes raw_hashes = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *raw_hashes_);
    }

    // optional .safe_browsing.RawIndices raw_indices = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *raw_indices_);
    }

    // optional .safe_browsing.RiceDeltaEncoding rice_hashes = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *rice_hashes_);
    }

    // optional .safe_browsing.RiceDeltaEncoding rice_indices = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *rice_indices_);
    }

    // optional .safe_browsing.CompressionType compression_type = 1;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_compression_type());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ThreatEntrySet::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ThreatEntrySet*>(
      &from));
}

void ThreatEntrySet::MergeFrom(const ThreatEntrySet& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ThreatEntrySet)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_raw_hashes()->::safe_browsing::RawHashes::MergeFrom(from._internal_raw_hashes());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_raw_indices()->::safe_browsing::RawIndices::MergeFrom(from._internal_raw_indices());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_rice_hashes()->::safe_browsing::RiceDeltaEncoding::MergeFrom(from._internal_rice_hashes());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_mutable_rice_indices()->::safe_browsing::RiceDeltaEncoding::MergeFrom(from._internal_rice_indices());
    }
    if (cached_has_bits & 0x00000010u) {
      compression_type_ = from.compression_type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ThreatEntrySet::CopyFrom(const ThreatEntrySet& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ThreatEntrySet)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ThreatEntrySet::IsInitialized() const {
  return true;
}

void ThreatEntrySet::InternalSwap(ThreatEntrySet* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ThreatEntrySet, compression_type_)
      + sizeof(ThreatEntrySet::compression_type_)
      - PROTOBUF_FIELD_OFFSET(ThreatEntrySet, raw_hashes_)>(
          reinterpret_cast<char*>(&raw_hashes_),
          reinterpret_cast<char*>(&other->raw_hashes_));
}

std::string ThreatEntrySet::GetTypeName() const {
  return "safe_browsing.ThreatEntrySet";
}


// ===================================================================

class RawIndices::_Internal {
 public:
};

RawIndices::RawIndices(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  indices_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:safe_browsing.RawIndices)
}
RawIndices::RawIndices(const RawIndices& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      indices_(from.indices_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:safe_browsing.RawIndices)
}

inline void RawIndices::SharedCtor() {
}

RawIndices::~RawIndices() {
  // @@protoc_insertion_point(destructor:safe_browsing.RawIndices)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RawIndices::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void RawIndices::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void RawIndices::Clear() {
// @@protoc_insertion_point(message_clear_start:safe_browsing.RawIndices)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  indices_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* RawIndices::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated int32 indices = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_indices(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<8>(ptr));
        } else if (static_cast<uint8_t>(tag) == 10) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_indices(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RawIndices::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.RawIndices)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated int32 indices = 1;
  for (int i = 0, n = this->_internal_indices_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_indices(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.RawIndices)
  return target;
}

size_t RawIndices::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:safe_browsing.RawIndices)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int32 indices = 1;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int32Size(this->indices_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_indices_size());
    total_size += data_size;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void RawIndices::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const RawIndices*>(
      &from));
}

void RawIndices::MergeFrom(const RawIndices& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.RawIndices)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  indices_.MergeFrom(from.indices_);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void RawIndices::CopyFrom(const RawIndices& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.RawIndices)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RawIndices::IsInitialized() const {
  return true;
}

void RawIndices::InternalSwap(RawIndices* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  indices_.InternalSwap(&other->indices_);
}

std::string RawIndices::GetTypeName() const {
  return "safe_browsing.RawIndices";
}


// ===================================================================

class RawHashes::_Internal {
 public:
  using HasBits = decltype(std::declval<RawHashes>()._has_bits_);
  static void set_has_prefix_size(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_raw_hashes(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

RawHashes::RawHashes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:safe_browsing.RawHashes)
}
RawHashes::RawHashes(const RawHashes& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  raw_hashes_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    raw_hashes_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_raw_hashes()) {
    raw_hashes_.Set(from._internal_raw_hashes(), 
      GetArenaForAllocation());
  }
  prefix_size_ = from.prefix_size_;
  // @@protoc_insertion_point(copy_constructor:safe_browsing.RawHashes)
}

inline void RawHashes::SharedCtor() {
raw_hashes_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  raw_hashes_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
prefix_size_ = 0;
}

RawHashes::~RawHashes() {
  // @@protoc_insertion_point(destructor:safe_browsing.RawHashes)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RawHashes::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  raw_hashes_.Destroy();
}

void RawHashes::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void RawHashes::Clear() {
// @@protoc_insertion_point(message_clear_start:safe_browsing.RawHashes)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    raw_hashes_.ClearNonDefaultToEmpty();
  }
  prefix_size_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* RawHashes::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 prefix_size = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_prefix_size(&has_bits);
          prefix_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes raw_hashes = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_raw_hashes();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RawHashes::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.RawHashes)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 prefix_size = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_prefix_size(), target);
  }

  // optional bytes raw_hashes = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_raw_hashes(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.RawHashes)
  return target;
}

size_t RawHashes::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:safe_browsing.RawHashes)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional bytes raw_hashes = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_raw_hashes());
    }

    // optional int32 prefix_size = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_prefix_size());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void RawHashes::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const RawHashes*>(
      &from));
}

void RawHashes::MergeFrom(const RawHashes& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.RawHashes)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_raw_hashes(from._internal_raw_hashes());
    }
    if (cached_has_bits & 0x00000002u) {
      prefix_size_ = from.prefix_size_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void RawHashes::CopyFrom(const RawHashes& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.RawHashes)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RawHashes::IsInitialized() const {
  return true;
}

void RawHashes::InternalSwap(RawHashes* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &raw_hashes_, lhs_arena,
      &other->raw_hashes_, rhs_arena
  );
  swap(prefix_size_, other->prefix_size_);
}

std::string RawHashes::GetTypeName() const {
  return "safe_browsing.RawHashes";
}


// ===================================================================

class RiceDeltaEncoding::_Internal {
 public:
  using HasBits = decltype(std::declval<RiceDeltaEncoding>()._has_bits_);
  static void set_has_first_value(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_rice_parameter(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_num_entries(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_encoded_data(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

RiceDeltaEncoding::RiceDeltaEncoding(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:safe_browsing.RiceDeltaEncoding)
}
RiceDeltaEncoding::RiceDeltaEncoding(const RiceDeltaEncoding& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  encoded_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    encoded_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_encoded_data()) {
    encoded_data_.Set(from._internal_encoded_data(), 
      GetArenaForAllocation());
  }
  ::memcpy(&first_value_, &from.first_value_,
    static_cast<size_t>(reinterpret_cast<char*>(&num_entries_) -
    reinterpret_cast<char*>(&first_value_)) + sizeof(num_entries_));
  // @@protoc_insertion_point(copy_constructor:safe_browsing.RiceDeltaEncoding)
}

inline void RiceDeltaEncoding::SharedCtor() {
encoded_data_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  encoded_data_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&first_value_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&num_entries_) -
    reinterpret_cast<char*>(&first_value_)) + sizeof(num_entries_));
}

RiceDeltaEncoding::~RiceDeltaEncoding() {
  // @@protoc_insertion_point(destructor:safe_browsing.RiceDeltaEncoding)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RiceDeltaEncoding::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  encoded_data_.Destroy();
}

void RiceDeltaEncoding::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void RiceDeltaEncoding::Clear() {
// @@protoc_insertion_point(message_clear_start:safe_browsing.RiceDeltaEncoding)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    encoded_data_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&first_value_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&num_entries_) -
        reinterpret_cast<char*>(&first_value_)) + sizeof(num_entries_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* RiceDeltaEncoding::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 first_value = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_first_value(&has_bits);
          first_value_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 rice_parameter = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_rice_parameter(&has_bits);
          rice_parameter_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 num_entries = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_num_entries(&has_bits);
          num_entries_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes encoded_data = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_encoded_data();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RiceDeltaEncoding::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.RiceDeltaEncoding)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int64 first_value = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_first_value(), target);
  }

  // optional int32 rice_parameter = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_rice_parameter(), target);
  }

  // optional int32 num_entries = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_num_entries(), target);
  }

  // optional bytes encoded_data = 4;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        4, this->_internal_encoded_data(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.RiceDeltaEncoding)
  return target;
}

size_t RiceDeltaEncoding::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:safe_browsing.RiceDeltaEncoding)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional bytes encoded_data = 4;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_encoded_data());
    }

    // optional int64 first_value = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_first_value());
    }

    // optional int32 rice_parameter = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_rice_parameter());
    }

    // optional int32 num_entries = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_num_entries());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void RiceDeltaEncoding::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const RiceDeltaEncoding*>(
      &from));
}

void RiceDeltaEncoding::MergeFrom(const RiceDeltaEncoding& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.RiceDeltaEncoding)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_encoded_data(from._internal_encoded_data());
    }
    if (cached_has_bits & 0x00000002u) {
      first_value_ = from.first_value_;
    }
    if (cached_has_bits & 0x00000004u) {
      rice_parameter_ = from.rice_parameter_;
    }
    if (cached_has_bits & 0x00000008u) {
      num_entries_ = from.num_entries_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void RiceDeltaEncoding::CopyFrom(const RiceDeltaEncoding& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.RiceDeltaEncoding)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RiceDeltaEncoding::IsInitialized() const {
  return true;
}

void RiceDeltaEncoding::InternalSwap(RiceDeltaEncoding* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &encoded_data_, lhs_arena,
      &other->encoded_data_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RiceDeltaEncoding, num_entries_)
      + sizeof(RiceDeltaEncoding::num_entries_)
      - PROTOBUF_FIELD_OFFSET(RiceDeltaEncoding, first_value_)>(
          reinterpret_cast<char*>(&first_value_),
          reinterpret_cast<char*>(&other->first_value_));
}

std::string RiceDeltaEncoding::GetTypeName() const {
  return "safe_browsing.RiceDeltaEncoding";
}


// ===================================================================

class ThreatEntryMetadata_MetadataEntry::_Internal {
 public:
  using HasBits = decltype(std::declval<ThreatEntryMetadata_MetadataEntry>()._has_bits_);
  static void set_has_key(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_value(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

ThreatEntryMetadata_MetadataEntry::ThreatEntryMetadata_MetadataEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:safe_browsing.ThreatEntryMetadata.MetadataEntry)
}
ThreatEntryMetadata_MetadataEntry::ThreatEntryMetadata_MetadataEntry(const ThreatEntryMetadata_MetadataEntry& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_key()) {
    key_.Set(from._internal_key(), 
      GetArenaForAllocation());
  }
  value_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    value_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_value()) {
    value_.Set(from._internal_value(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:safe_browsing.ThreatEntryMetadata.MetadataEntry)
}

inline void ThreatEntryMetadata_MetadataEntry::SharedCtor() {
key_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  key_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
value_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  value_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ThreatEntryMetadata_MetadataEntry::~ThreatEntryMetadata_MetadataEntry() {
  // @@protoc_insertion_point(destructor:safe_browsing.ThreatEntryMetadata.MetadataEntry)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ThreatEntryMetadata_MetadataEntry::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  key_.Destroy();
  value_.Destroy();
}

void ThreatEntryMetadata_MetadataEntry::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ThreatEntryMetadata_MetadataEntry::Clear() {
// @@protoc_insertion_point(message_clear_start:safe_browsing.ThreatEntryMetadata.MetadataEntry)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      key_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      value_.ClearNonDefaultToEmpty();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ThreatEntryMetadata_MetadataEntry::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes key = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_key();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes value = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_value();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ThreatEntryMetadata_MetadataEntry::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ThreatEntryMetadata.MetadataEntry)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bytes key = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_key(), target);
  }

  // optional bytes value = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_value(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ThreatEntryMetadata.MetadataEntry)
  return target;
}

size_t ThreatEntryMetadata_MetadataEntry::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:safe_browsing.ThreatEntryMetadata.MetadataEntry)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional bytes key = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_key());
    }

    // optional bytes value = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_value());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ThreatEntryMetadata_MetadataEntry::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ThreatEntryMetadata_MetadataEntry*>(
      &from));
}

void ThreatEntryMetadata_MetadataEntry::MergeFrom(const ThreatEntryMetadata_MetadataEntry& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ThreatEntryMetadata.MetadataEntry)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_key(from._internal_key());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_value(from._internal_value());
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ThreatEntryMetadata_MetadataEntry::CopyFrom(const ThreatEntryMetadata_MetadataEntry& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ThreatEntryMetadata.MetadataEntry)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ThreatEntryMetadata_MetadataEntry::IsInitialized() const {
  return true;
}

void ThreatEntryMetadata_MetadataEntry::InternalSwap(ThreatEntryMetadata_MetadataEntry* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &key_, lhs_arena,
      &other->key_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &value_, lhs_arena,
      &other->value_, rhs_arena
  );
}

std::string ThreatEntryMetadata_MetadataEntry::GetTypeName() const {
  return "safe_browsing.ThreatEntryMetadata.MetadataEntry";
}


// ===================================================================

class ThreatEntryMetadata::_Internal {
 public:
};

ThreatEntryMetadata::ThreatEntryMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  entries_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:safe_browsing.ThreatEntryMetadata)
}
ThreatEntryMetadata::ThreatEntryMetadata(const ThreatEntryMetadata& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      entries_(from.entries_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:safe_browsing.ThreatEntryMetadata)
}

inline void ThreatEntryMetadata::SharedCtor() {
}

ThreatEntryMetadata::~ThreatEntryMetadata() {
  // @@protoc_insertion_point(destructor:safe_browsing.ThreatEntryMetadata)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ThreatEntryMetadata::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ThreatEntryMetadata::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ThreatEntryMetadata::Clear() {
// @@protoc_insertion_point(message_clear_start:safe_browsing.ThreatEntryMetadata)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  entries_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ThreatEntryMetadata::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .safe_browsing.ThreatEntryMetadata.MetadataEntry entries = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_entries(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ThreatEntryMetadata::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ThreatEntryMetadata)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .safe_browsing.ThreatEntryMetadata.MetadataEntry entries = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_entries_size()); i < n; i++) {
    const auto& repfield = this->_internal_entries(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ThreatEntryMetadata)
  return target;
}

size_t ThreatEntryMetadata::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:safe_browsing.ThreatEntryMetadata)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .safe_browsing.ThreatEntryMetadata.MetadataEntry entries = 1;
  total_size += 1UL * this->_internal_entries_size();
  for (const auto& msg : this->entries_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ThreatEntryMetadata::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ThreatEntryMetadata*>(
      &from));
}

void ThreatEntryMetadata::MergeFrom(const ThreatEntryMetadata& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ThreatEntryMetadata)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  entries_.MergeFrom(from.entries_);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ThreatEntryMetadata::CopyFrom(const ThreatEntryMetadata& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ThreatEntryMetadata)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ThreatEntryMetadata::IsInitialized() const {
  return true;
}

void ThreatEntryMetadata::InternalSwap(ThreatEntryMetadata* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  entries_.InternalSwap(&other->entries_);
}

std::string ThreatEntryMetadata::GetTypeName() const {
  return "safe_browsing.ThreatEntryMetadata";
}


// ===================================================================

class ThreatListDescriptor::_Internal {
 public:
  using HasBits = decltype(std::declval<ThreatListDescriptor>()._has_bits_);
  static void set_has_threat_type(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_platform_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_threat_entry_type(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

ThreatListDescriptor::ThreatListDescriptor(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:safe_browsing.ThreatListDescriptor)
}
ThreatListDescriptor::ThreatListDescriptor(const ThreatListDescriptor& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&threat_type_, &from.threat_type_,
    static_cast<size_t>(reinterpret_cast<char*>(&threat_entry_type_) -
    reinterpret_cast<char*>(&threat_type_)) + sizeof(threat_entry_type_));
  // @@protoc_insertion_point(copy_constructor:safe_browsing.ThreatListDescriptor)
}

inline void ThreatListDescriptor::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&threat_type_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&threat_entry_type_) -
    reinterpret_cast<char*>(&threat_type_)) + sizeof(threat_entry_type_));
}

ThreatListDescriptor::~ThreatListDescriptor() {
  // @@protoc_insertion_point(destructor:safe_browsing.ThreatListDescriptor)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ThreatListDescriptor::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ThreatListDescriptor::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ThreatListDescriptor::Clear() {
// @@protoc_insertion_point(message_clear_start:safe_browsing.ThreatListDescriptor)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&threat_type_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&threat_entry_type_) -
        reinterpret_cast<char*>(&threat_type_)) + sizeof(threat_entry_type_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ThreatListDescriptor::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .safe_browsing.ThreatType threat_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::safe_browsing::ThreatType_IsValid(val))) {
            _internal_set_threat_type(static_cast<::safe_browsing::ThreatType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .safe_browsing.PlatformType platform_type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::safe_browsing::PlatformType_IsValid(val))) {
            _internal_set_platform_type(static_cast<::safe_browsing::PlatformType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .safe_browsing.ThreatEntryType threat_entry_type = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::safe_browsing::ThreatEntryType_IsValid(val))) {
            _internal_set_threat_entry_type(static_cast<::safe_browsing::ThreatEntryType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ThreatListDescriptor::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ThreatListDescriptor)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .safe_browsing.ThreatType threat_type = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_threat_type(), target);
  }

  // optional .safe_browsing.PlatformType platform_type = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_platform_type(), target);
  }

  // optional .safe_browsing.ThreatEntryType threat_entry_type = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_threat_entry_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ThreatListDescriptor)
  return target;
}

size_t ThreatListDescriptor::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:safe_browsing.ThreatListDescriptor)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .safe_browsing.ThreatType threat_type = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_threat_type());
    }

    // optional .safe_browsing.PlatformType platform_type = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_platform_type());
    }

    // optional .safe_browsing.ThreatEntryType threat_entry_type = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_threat_entry_type());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ThreatListDescriptor::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ThreatListDescriptor*>(
      &from));
}

void ThreatListDescriptor::MergeFrom(const ThreatListDescriptor& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ThreatListDescriptor)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      threat_type_ = from.threat_type_;
    }
    if (cached_has_bits & 0x00000002u) {
      platform_type_ = from.platform_type_;
    }
    if (cached_has_bits & 0x00000004u) {
      threat_entry_type_ = from.threat_entry_type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ThreatListDescriptor::CopyFrom(const ThreatListDescriptor& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ThreatListDescriptor)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ThreatListDescriptor::IsInitialized() const {
  return true;
}

void ThreatListDescriptor::InternalSwap(ThreatListDescriptor* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ThreatListDescriptor, threat_entry_type_)
      + sizeof(ThreatListDescriptor::threat_entry_type_)
      - PROTOBUF_FIELD_OFFSET(ThreatListDescriptor, threat_type_)>(
          reinterpret_cast<char*>(&threat_type_),
          reinterpret_cast<char*>(&other->threat_type_));
}

std::string ThreatListDescriptor::GetTypeName() const {
  return "safe_browsing.ThreatListDescriptor";
}


// ===================================================================

class ListThreatListsResponse::_Internal {
 public:
};

ListThreatListsResponse::ListThreatListsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  threat_lists_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:safe_browsing.ListThreatListsResponse)
}
ListThreatListsResponse::ListThreatListsResponse(const ListThreatListsResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      threat_lists_(from.threat_lists_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:safe_browsing.ListThreatListsResponse)
}

inline void ListThreatListsResponse::SharedCtor() {
}

ListThreatListsResponse::~ListThreatListsResponse() {
  // @@protoc_insertion_point(destructor:safe_browsing.ListThreatListsResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ListThreatListsResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ListThreatListsResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ListThreatListsResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:safe_browsing.ListThreatListsResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  threat_lists_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ListThreatListsResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .safe_browsing.ThreatListDescriptor threat_lists = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_threat_lists(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ListThreatListsResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ListThreatListsResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .safe_browsing.ThreatListDescriptor threat_lists = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_threat_lists_size()); i < n; i++) {
    const auto& repfield = this->_internal_threat_lists(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ListThreatListsResponse)
  return target;
}

size_t ListThreatListsResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:safe_browsing.ListThreatListsResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .safe_browsing.ThreatListDescriptor threat_lists = 1;
  total_size += 1UL * this->_internal_threat_lists_size();
  for (const auto& msg : this->threat_lists_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ListThreatListsResponse::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ListThreatListsResponse*>(
      &from));
}

void ListThreatListsResponse::MergeFrom(const ListThreatListsResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ListThreatListsResponse)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  threat_lists_.MergeFrom(from.threat_lists_);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ListThreatListsResponse::CopyFrom(const ListThreatListsResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ListThreatListsResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ListThreatListsResponse::IsInitialized() const {
  return true;
}

void ListThreatListsResponse::InternalSwap(ListThreatListsResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  threat_lists_.InternalSwap(&other->threat_lists_);
}

std::string ListThreatListsResponse::GetTypeName() const {
  return "safe_browsing.ListThreatListsResponse";
}


// ===================================================================

class Duration::_Internal {
 public:
  using HasBits = decltype(std::declval<Duration>()._has_bits_);
  static void set_has_seconds(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_nanos(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

Duration::Duration(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:safe_browsing.Duration)
}
Duration::Duration(const Duration& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&seconds_, &from.seconds_,
    static_cast<size_t>(reinterpret_cast<char*>(&nanos_) -
    reinterpret_cast<char*>(&seconds_)) + sizeof(nanos_));
  // @@protoc_insertion_point(copy_constructor:safe_browsing.Duration)
}

inline void Duration::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&seconds_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&nanos_) -
    reinterpret_cast<char*>(&seconds_)) + sizeof(nanos_));
}

Duration::~Duration() {
  // @@protoc_insertion_point(destructor:safe_browsing.Duration)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Duration::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Duration::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Duration::Clear() {
// @@protoc_insertion_point(message_clear_start:safe_browsing.Duration)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&seconds_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&nanos_) -
        reinterpret_cast<char*>(&seconds_)) + sizeof(nanos_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Duration::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 seconds = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_seconds(&has_bits);
          seconds_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 nanos = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_nanos(&has_bits);
          nanos_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Duration::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.Duration)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int64 seconds = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_seconds(), target);
  }

  // optional int32 nanos = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_nanos(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.Duration)
  return target;
}

size_t Duration::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:safe_browsing.Duration)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional int64 seconds = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_seconds());
    }

    // optional int32 nanos = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_nanos());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Duration::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Duration*>(
      &from));
}

void Duration::MergeFrom(const Duration& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.Duration)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      seconds_ = from.seconds_;
    }
    if (cached_has_bits & 0x00000002u) {
      nanos_ = from.nanos_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Duration::CopyFrom(const Duration& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.Duration)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Duration::IsInitialized() const {
  return true;
}

void Duration::InternalSwap(Duration* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Duration, nanos_)
      + sizeof(Duration::nanos_)
      - PROTOBUF_FIELD_OFFSET(Duration, seconds_)>(
          reinterpret_cast<char*>(&seconds_),
          reinterpret_cast<char*>(&other->seconds_));
}

std::string Duration::GetTypeName() const {
  return "safe_browsing.Duration";
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace safe_browsing
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::safe_browsing::ThreatInfo*
Arena::CreateMaybeMessage< ::safe_browsing::ThreatInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::safe_browsing::ThreatInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::safe_browsing::ThreatMatch*
Arena::CreateMaybeMessage< ::safe_browsing::ThreatMatch >(Arena* arena) {
  return Arena::CreateMessageInternal< ::safe_browsing::ThreatMatch >(arena);
}
template<> PROTOBUF_NOINLINE ::safe_browsing::FindThreatMatchesRequest*
Arena::CreateMaybeMessage< ::safe_browsing::FindThreatMatchesRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::safe_browsing::FindThreatMatchesRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::safe_browsing::FindThreatMatchesResponse*
Arena::CreateMaybeMessage< ::safe_browsing::FindThreatMatchesResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::safe_browsing::FindThreatMatchesResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::safe_browsing::FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints*
Arena::CreateMaybeMessage< ::safe_browsing::FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints >(Arena* arena) {
  return Arena::CreateMessageInternal< ::safe_browsing::FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints >(arena);
}
template<> PROTOBUF_NOINLINE ::safe_browsing::FetchThreatListUpdatesRequest_ListUpdateRequest*
Arena::CreateMaybeMessage< ::safe_browsing::FetchThreatListUpdatesRequest_ListUpdateRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::safe_browsing::FetchThreatListUpdatesRequest_ListUpdateRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::safe_browsing::FetchThreatListUpdatesRequest*
Arena::CreateMaybeMessage< ::safe_browsing::FetchThreatListUpdatesRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::safe_browsing::FetchThreatListUpdatesRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::safe_browsing::FetchThreatListUpdatesResponse_ListUpdateResponse*
Arena::CreateMaybeMessage< ::safe_browsing::FetchThreatListUpdatesResponse_ListUpdateResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::safe_browsing::FetchThreatListUpdatesResponse_ListUpdateResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::safe_browsing::FetchThreatListUpdatesResponse*
Arena::CreateMaybeMessage< ::safe_browsing::FetchThreatListUpdatesResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::safe_browsing::FetchThreatListUpdatesResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::safe_browsing::FindFullHashesRequest*
Arena::CreateMaybeMessage< ::safe_browsing::FindFullHashesRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::safe_browsing::FindFullHashesRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::safe_browsing::FindFullHashesResponse*
Arena::CreateMaybeMessage< ::safe_browsing::FindFullHashesResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::safe_browsing::FindFullHashesResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::safe_browsing::ThreatHit_ThreatSource*
Arena::CreateMaybeMessage< ::safe_browsing::ThreatHit_ThreatSource >(Arena* arena) {
  return Arena::CreateMessageInternal< ::safe_browsing::ThreatHit_ThreatSource >(arena);
}
template<> PROTOBUF_NOINLINE ::safe_browsing::ThreatHit*
Arena::CreateMaybeMessage< ::safe_browsing::ThreatHit >(Arena* arena) {
  return Arena::CreateMessageInternal< ::safe_browsing::ThreatHit >(arena);
}
template<> PROTOBUF_NOINLINE ::safe_browsing::ClientInfo*
Arena::CreateMaybeMessage< ::safe_browsing::ClientInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::safe_browsing::ClientInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::safe_browsing::ChromeClientInfo*
Arena::CreateMaybeMessage< ::safe_browsing::ChromeClientInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::safe_browsing::ChromeClientInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::safe_browsing::Checksum*
Arena::CreateMaybeMessage< ::safe_browsing::Checksum >(Arena* arena) {
  return Arena::CreateMessageInternal< ::safe_browsing::Checksum >(arena);
}
template<> PROTOBUF_NOINLINE ::safe_browsing::ThreatEntry*
Arena::CreateMaybeMessage< ::safe_browsing::ThreatEntry >(Arena* arena) {
  return Arena::CreateMessageInternal< ::safe_browsing::ThreatEntry >(arena);
}
template<> PROTOBUF_NOINLINE ::safe_browsing::ThreatEntrySet*
Arena::CreateMaybeMessage< ::safe_browsing::ThreatEntrySet >(Arena* arena) {
  return Arena::CreateMessageInternal< ::safe_browsing::ThreatEntrySet >(arena);
}
template<> PROTOBUF_NOINLINE ::safe_browsing::RawIndices*
Arena::CreateMaybeMessage< ::safe_browsing::RawIndices >(Arena* arena) {
  return Arena::CreateMessageInternal< ::safe_browsing::RawIndices >(arena);
}
template<> PROTOBUF_NOINLINE ::safe_browsing::RawHashes*
Arena::CreateMaybeMessage< ::safe_browsing::RawHashes >(Arena* arena) {
  return Arena::CreateMessageInternal< ::safe_browsing::RawHashes >(arena);
}
template<> PROTOBUF_NOINLINE ::safe_browsing::RiceDeltaEncoding*
Arena::CreateMaybeMessage< ::safe_browsing::RiceDeltaEncoding >(Arena* arena) {
  return Arena::CreateMessageInternal< ::safe_browsing::RiceDeltaEncoding >(arena);
}
template<> PROTOBUF_NOINLINE ::safe_browsing::ThreatEntryMetadata_MetadataEntry*
Arena::CreateMaybeMessage< ::safe_browsing::ThreatEntryMetadata_MetadataEntry >(Arena* arena) {
  return Arena::CreateMessageInternal< ::safe_browsing::ThreatEntryMetadata_MetadataEntry >(arena);
}
template<> PROTOBUF_NOINLINE ::safe_browsing::ThreatEntryMetadata*
Arena::CreateMaybeMessage< ::safe_browsing::ThreatEntryMetadata >(Arena* arena) {
  return Arena::CreateMessageInternal< ::safe_browsing::ThreatEntryMetadata >(arena);
}
template<> PROTOBUF_NOINLINE ::safe_browsing::ThreatListDescriptor*
Arena::CreateMaybeMessage< ::safe_browsing::ThreatListDescriptor >(Arena* arena) {
  return Arena::CreateMessageInternal< ::safe_browsing::ThreatListDescriptor >(arena);
}
template<> PROTOBUF_NOINLINE ::safe_browsing::ListThreatListsResponse*
Arena::CreateMaybeMessage< ::safe_browsing::ListThreatListsResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::safe_browsing::ListThreatListsResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::safe_browsing::Duration*
Arena::CreateMaybeMessage< ::safe_browsing::Duration >(Arena* arena) {
  return Arena::CreateMessageInternal< ::safe_browsing::Duration >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
