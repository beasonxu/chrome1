// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: components/reporting/proto/synced/interface.proto

#include "components/reporting/proto/synced/interface.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace reporting {
PROTOBUF_CONSTEXPR EnqueueRecordRequest::EnqueueRecordRequest(
    ::_pbi::ConstantInitialized)
  : record_(nullptr)
  , priority_(0)
{}
struct EnqueueRecordRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EnqueueRecordRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~EnqueueRecordRequestDefaultTypeInternal() {}
  union {
    EnqueueRecordRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EnqueueRecordRequestDefaultTypeInternal _EnqueueRecordRequest_default_instance_;
PROTOBUF_CONSTEXPR EnqueueRecordResponse::EnqueueRecordResponse(
    ::_pbi::ConstantInitialized)
  : status_(nullptr){}
struct EnqueueRecordResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EnqueueRecordResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~EnqueueRecordResponseDefaultTypeInternal() {}
  union {
    EnqueueRecordResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EnqueueRecordResponseDefaultTypeInternal _EnqueueRecordResponse_default_instance_;
PROTOBUF_CONSTEXPR FlushPriorityRequest::FlushPriorityRequest(
    ::_pbi::ConstantInitialized)
  : priority_(5)
{}
struct FlushPriorityRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FlushPriorityRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FlushPriorityRequestDefaultTypeInternal() {}
  union {
    FlushPriorityRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FlushPriorityRequestDefaultTypeInternal _FlushPriorityRequest_default_instance_;
PROTOBUF_CONSTEXPR FlushPriorityResponse::FlushPriorityResponse(
    ::_pbi::ConstantInitialized)
  : status_(nullptr){}
struct FlushPriorityResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FlushPriorityResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FlushPriorityResponseDefaultTypeInternal() {}
  union {
    FlushPriorityResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FlushPriorityResponseDefaultTypeInternal _FlushPriorityResponse_default_instance_;
PROTOBUF_CONSTEXPR UploadEncryptedRecordRequest::UploadEncryptedRecordRequest(
    ::_pbi::ConstantInitialized)
  : encrypted_record_()
  , remaining_storage_capacity_(uint64_t{0u})
  , new_events_rate_(uint64_t{0u})
  , need_encryption_keys_(false){}
struct UploadEncryptedRecordRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UploadEncryptedRecordRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~UploadEncryptedRecordRequestDefaultTypeInternal() {}
  union {
    UploadEncryptedRecordRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UploadEncryptedRecordRequestDefaultTypeInternal _UploadEncryptedRecordRequest_default_instance_;
PROTOBUF_CONSTEXPR UploadEncryptedRecordResponse::UploadEncryptedRecordResponse(
    ::_pbi::ConstantInitialized)
  : status_(nullptr){}
struct UploadEncryptedRecordResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UploadEncryptedRecordResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~UploadEncryptedRecordResponseDefaultTypeInternal() {}
  union {
    UploadEncryptedRecordResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UploadEncryptedRecordResponseDefaultTypeInternal _UploadEncryptedRecordResponse_default_instance_;
PROTOBUF_CONSTEXPR ConfirmRecordUploadRequest::ConfirmRecordUploadRequest(
    ::_pbi::ConstantInitialized)
  : sequence_information_(nullptr)
  , force_confirm_(false){}
struct ConfirmRecordUploadRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ConfirmRecordUploadRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ConfirmRecordUploadRequestDefaultTypeInternal() {}
  union {
    ConfirmRecordUploadRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ConfirmRecordUploadRequestDefaultTypeInternal _ConfirmRecordUploadRequest_default_instance_;
PROTOBUF_CONSTEXPR ConfirmRecordUploadResponse::ConfirmRecordUploadResponse(
    ::_pbi::ConstantInitialized)
  : status_(nullptr){}
struct ConfirmRecordUploadResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ConfirmRecordUploadResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ConfirmRecordUploadResponseDefaultTypeInternal() {}
  union {
    ConfirmRecordUploadResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ConfirmRecordUploadResponseDefaultTypeInternal _ConfirmRecordUploadResponse_default_instance_;
PROTOBUF_CONSTEXPR UpdateEncryptionKeyRequest::UpdateEncryptionKeyRequest(
    ::_pbi::ConstantInitialized)
  : signed_encryption_info_(nullptr){}
struct UpdateEncryptionKeyRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UpdateEncryptionKeyRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~UpdateEncryptionKeyRequestDefaultTypeInternal() {}
  union {
    UpdateEncryptionKeyRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UpdateEncryptionKeyRequestDefaultTypeInternal _UpdateEncryptionKeyRequest_default_instance_;
PROTOBUF_CONSTEXPR UpdateEncryptionKeyResponse::UpdateEncryptionKeyResponse(
    ::_pbi::ConstantInitialized)
  : status_(nullptr){}
struct UpdateEncryptionKeyResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UpdateEncryptionKeyResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~UpdateEncryptionKeyResponseDefaultTypeInternal() {}
  union {
    UpdateEncryptionKeyResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UpdateEncryptionKeyResponseDefaultTypeInternal _UpdateEncryptionKeyResponse_default_instance_;
}  // namespace reporting
namespace reporting {

// ===================================================================

class EnqueueRecordRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<EnqueueRecordRequest>()._has_bits_);
  static const ::reporting::Record& record(const EnqueueRecordRequest* msg);
  static void set_has_record(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_priority(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::reporting::Record&
EnqueueRecordRequest::_Internal::record(const EnqueueRecordRequest* msg) {
  return *msg->record_;
}
void EnqueueRecordRequest::clear_record() {
  if (record_ != nullptr) record_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
EnqueueRecordRequest::EnqueueRecordRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:reporting.EnqueueRecordRequest)
}
EnqueueRecordRequest::EnqueueRecordRequest(const EnqueueRecordRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_record()) {
    record_ = new ::reporting::Record(*from.record_);
  } else {
    record_ = nullptr;
  }
  priority_ = from.priority_;
  // @@protoc_insertion_point(copy_constructor:reporting.EnqueueRecordRequest)
}

inline void EnqueueRecordRequest::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&record_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&priority_) -
    reinterpret_cast<char*>(&record_)) + sizeof(priority_));
}

EnqueueRecordRequest::~EnqueueRecordRequest() {
  // @@protoc_insertion_point(destructor:reporting.EnqueueRecordRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void EnqueueRecordRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete record_;
}

void EnqueueRecordRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void EnqueueRecordRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:reporting.EnqueueRecordRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(record_ != nullptr);
    record_->Clear();
  }
  priority_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* EnqueueRecordRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .reporting.Record record = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_record(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .reporting.Priority priority = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::reporting::Priority_IsValid(val))) {
            _internal_set_priority(static_cast<::reporting::Priority>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* EnqueueRecordRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:reporting.EnqueueRecordRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .reporting.Record record = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::record(this),
        _Internal::record(this).GetCachedSize(), target, stream);
  }

  // optional .reporting.Priority priority = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_priority(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:reporting.EnqueueRecordRequest)
  return target;
}

size_t EnqueueRecordRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:reporting.EnqueueRecordRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .reporting.Record record = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *record_);
    }

    // optional .reporting.Priority priority = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_priority());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void EnqueueRecordRequest::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const EnqueueRecordRequest*>(
      &from));
}

void EnqueueRecordRequest::MergeFrom(const EnqueueRecordRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:reporting.EnqueueRecordRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_record()->::reporting::Record::MergeFrom(from._internal_record());
    }
    if (cached_has_bits & 0x00000002u) {
      priority_ = from.priority_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void EnqueueRecordRequest::CopyFrom(const EnqueueRecordRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:reporting.EnqueueRecordRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EnqueueRecordRequest::IsInitialized() const {
  return true;
}

void EnqueueRecordRequest::InternalSwap(EnqueueRecordRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(EnqueueRecordRequest, priority_)
      + sizeof(EnqueueRecordRequest::priority_)
      - PROTOBUF_FIELD_OFFSET(EnqueueRecordRequest, record_)>(
          reinterpret_cast<char*>(&record_),
          reinterpret_cast<char*>(&other->record_));
}

std::string EnqueueRecordRequest::GetTypeName() const {
  return "reporting.EnqueueRecordRequest";
}


// ===================================================================

class EnqueueRecordResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<EnqueueRecordResponse>()._has_bits_);
  static const ::reporting::StatusProto& status(const EnqueueRecordResponse* msg);
  static void set_has_status(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::reporting::StatusProto&
EnqueueRecordResponse::_Internal::status(const EnqueueRecordResponse* msg) {
  return *msg->status_;
}
void EnqueueRecordResponse::clear_status() {
  if (status_ != nullptr) status_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
EnqueueRecordResponse::EnqueueRecordResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:reporting.EnqueueRecordResponse)
}
EnqueueRecordResponse::EnqueueRecordResponse(const EnqueueRecordResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_status()) {
    status_ = new ::reporting::StatusProto(*from.status_);
  } else {
    status_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:reporting.EnqueueRecordResponse)
}

inline void EnqueueRecordResponse::SharedCtor() {
status_ = nullptr;
}

EnqueueRecordResponse::~EnqueueRecordResponse() {
  // @@protoc_insertion_point(destructor:reporting.EnqueueRecordResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void EnqueueRecordResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete status_;
}

void EnqueueRecordResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void EnqueueRecordResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:reporting.EnqueueRecordResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(status_ != nullptr);
    status_->Clear();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* EnqueueRecordResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .reporting.StatusProto status = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_status(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* EnqueueRecordResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:reporting.EnqueueRecordResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .reporting.StatusProto status = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::status(this),
        _Internal::status(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:reporting.EnqueueRecordResponse)
  return target;
}

size_t EnqueueRecordResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:reporting.EnqueueRecordResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .reporting.StatusProto status = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *status_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void EnqueueRecordResponse::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const EnqueueRecordResponse*>(
      &from));
}

void EnqueueRecordResponse::MergeFrom(const EnqueueRecordResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:reporting.EnqueueRecordResponse)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_status()) {
    _internal_mutable_status()->::reporting::StatusProto::MergeFrom(from._internal_status());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void EnqueueRecordResponse::CopyFrom(const EnqueueRecordResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:reporting.EnqueueRecordResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EnqueueRecordResponse::IsInitialized() const {
  return true;
}

void EnqueueRecordResponse::InternalSwap(EnqueueRecordResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(status_, other->status_);
}

std::string EnqueueRecordResponse::GetTypeName() const {
  return "reporting.EnqueueRecordResponse";
}


// ===================================================================

class FlushPriorityRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<FlushPriorityRequest>()._has_bits_);
  static void set_has_priority(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

FlushPriorityRequest::FlushPriorityRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:reporting.FlushPriorityRequest)
}
FlushPriorityRequest::FlushPriorityRequest(const FlushPriorityRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  priority_ = from.priority_;
  // @@protoc_insertion_point(copy_constructor:reporting.FlushPriorityRequest)
}

inline void FlushPriorityRequest::SharedCtor() {
priority_ = 5;
}

FlushPriorityRequest::~FlushPriorityRequest() {
  // @@protoc_insertion_point(destructor:reporting.FlushPriorityRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void FlushPriorityRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void FlushPriorityRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void FlushPriorityRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:reporting.FlushPriorityRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  priority_ = 5;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* FlushPriorityRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .reporting.Priority priority = 1 [default = MANUAL_BATCH];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::reporting::Priority_IsValid(val))) {
            _internal_set_priority(static_cast<::reporting::Priority>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FlushPriorityRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:reporting.FlushPriorityRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .reporting.Priority priority = 1 [default = MANUAL_BATCH];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_priority(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:reporting.FlushPriorityRequest)
  return target;
}

size_t FlushPriorityRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:reporting.FlushPriorityRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .reporting.Priority priority = 1 [default = MANUAL_BATCH];
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_priority());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void FlushPriorityRequest::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const FlushPriorityRequest*>(
      &from));
}

void FlushPriorityRequest::MergeFrom(const FlushPriorityRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:reporting.FlushPriorityRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_priority()) {
    _internal_set_priority(from._internal_priority());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void FlushPriorityRequest::CopyFrom(const FlushPriorityRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:reporting.FlushPriorityRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FlushPriorityRequest::IsInitialized() const {
  return true;
}

void FlushPriorityRequest::InternalSwap(FlushPriorityRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(priority_, other->priority_);
}

std::string FlushPriorityRequest::GetTypeName() const {
  return "reporting.FlushPriorityRequest";
}


// ===================================================================

class FlushPriorityResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<FlushPriorityResponse>()._has_bits_);
  static const ::reporting::StatusProto& status(const FlushPriorityResponse* msg);
  static void set_has_status(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::reporting::StatusProto&
FlushPriorityResponse::_Internal::status(const FlushPriorityResponse* msg) {
  return *msg->status_;
}
void FlushPriorityResponse::clear_status() {
  if (status_ != nullptr) status_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
FlushPriorityResponse::FlushPriorityResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:reporting.FlushPriorityResponse)
}
FlushPriorityResponse::FlushPriorityResponse(const FlushPriorityResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_status()) {
    status_ = new ::reporting::StatusProto(*from.status_);
  } else {
    status_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:reporting.FlushPriorityResponse)
}

inline void FlushPriorityResponse::SharedCtor() {
status_ = nullptr;
}

FlushPriorityResponse::~FlushPriorityResponse() {
  // @@protoc_insertion_point(destructor:reporting.FlushPriorityResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void FlushPriorityResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete status_;
}

void FlushPriorityResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void FlushPriorityResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:reporting.FlushPriorityResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(status_ != nullptr);
    status_->Clear();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* FlushPriorityResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .reporting.StatusProto status = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_status(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FlushPriorityResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:reporting.FlushPriorityResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .reporting.StatusProto status = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::status(this),
        _Internal::status(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:reporting.FlushPriorityResponse)
  return target;
}

size_t FlushPriorityResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:reporting.FlushPriorityResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .reporting.StatusProto status = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *status_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void FlushPriorityResponse::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const FlushPriorityResponse*>(
      &from));
}

void FlushPriorityResponse::MergeFrom(const FlushPriorityResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:reporting.FlushPriorityResponse)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_status()) {
    _internal_mutable_status()->::reporting::StatusProto::MergeFrom(from._internal_status());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void FlushPriorityResponse::CopyFrom(const FlushPriorityResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:reporting.FlushPriorityResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FlushPriorityResponse::IsInitialized() const {
  return true;
}

void FlushPriorityResponse::InternalSwap(FlushPriorityResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(status_, other->status_);
}

std::string FlushPriorityResponse::GetTypeName() const {
  return "reporting.FlushPriorityResponse";
}


// ===================================================================

class UploadEncryptedRecordRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<UploadEncryptedRecordRequest>()._has_bits_);
  static void set_has_need_encryption_keys(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_remaining_storage_capacity(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_new_events_rate(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

void UploadEncryptedRecordRequest::clear_encrypted_record() {
  encrypted_record_.Clear();
}
UploadEncryptedRecordRequest::UploadEncryptedRecordRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  encrypted_record_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:reporting.UploadEncryptedRecordRequest)
}
UploadEncryptedRecordRequest::UploadEncryptedRecordRequest(const UploadEncryptedRecordRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      encrypted_record_(from.encrypted_record_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&remaining_storage_capacity_, &from.remaining_storage_capacity_,
    static_cast<size_t>(reinterpret_cast<char*>(&need_encryption_keys_) -
    reinterpret_cast<char*>(&remaining_storage_capacity_)) + sizeof(need_encryption_keys_));
  // @@protoc_insertion_point(copy_constructor:reporting.UploadEncryptedRecordRequest)
}

inline void UploadEncryptedRecordRequest::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&remaining_storage_capacity_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&need_encryption_keys_) -
    reinterpret_cast<char*>(&remaining_storage_capacity_)) + sizeof(need_encryption_keys_));
}

UploadEncryptedRecordRequest::~UploadEncryptedRecordRequest() {
  // @@protoc_insertion_point(destructor:reporting.UploadEncryptedRecordRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void UploadEncryptedRecordRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void UploadEncryptedRecordRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void UploadEncryptedRecordRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:reporting.UploadEncryptedRecordRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  encrypted_record_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&remaining_storage_capacity_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&need_encryption_keys_) -
        reinterpret_cast<char*>(&remaining_storage_capacity_)) + sizeof(need_encryption_keys_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* UploadEncryptedRecordRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .reporting.EncryptedRecord encrypted_record = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_encrypted_record(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional bool need_encryption_keys = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_need_encryption_keys(&has_bits);
          need_encryption_keys_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 remaining_storage_capacity = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_remaining_storage_capacity(&has_bits);
          remaining_storage_capacity_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 new_events_rate = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_new_events_rate(&has_bits);
          new_events_rate_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UploadEncryptedRecordRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:reporting.UploadEncryptedRecordRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .reporting.EncryptedRecord encrypted_record = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_encrypted_record_size()); i < n; i++) {
    const auto& repfield = this->_internal_encrypted_record(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  cached_has_bits = _has_bits_[0];
  // optional bool need_encryption_keys = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_need_encryption_keys(), target);
  }

  // optional uint64 remaining_storage_capacity = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_remaining_storage_capacity(), target);
  }

  // optional uint64 new_events_rate = 4;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(4, this->_internal_new_events_rate(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:reporting.UploadEncryptedRecordRequest)
  return target;
}

size_t UploadEncryptedRecordRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:reporting.UploadEncryptedRecordRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .reporting.EncryptedRecord encrypted_record = 1;
  total_size += 1UL * this->_internal_encrypted_record_size();
  for (const auto& msg : this->encrypted_record_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint64 remaining_storage_capacity = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_remaining_storage_capacity());
    }

    // optional uint64 new_events_rate = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_new_events_rate());
    }

    // optional bool need_encryption_keys = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void UploadEncryptedRecordRequest::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const UploadEncryptedRecordRequest*>(
      &from));
}

void UploadEncryptedRecordRequest::MergeFrom(const UploadEncryptedRecordRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:reporting.UploadEncryptedRecordRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  encrypted_record_.MergeFrom(from.encrypted_record_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      remaining_storage_capacity_ = from.remaining_storage_capacity_;
    }
    if (cached_has_bits & 0x00000002u) {
      new_events_rate_ = from.new_events_rate_;
    }
    if (cached_has_bits & 0x00000004u) {
      need_encryption_keys_ = from.need_encryption_keys_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void UploadEncryptedRecordRequest::CopyFrom(const UploadEncryptedRecordRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:reporting.UploadEncryptedRecordRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UploadEncryptedRecordRequest::IsInitialized() const {
  return true;
}

void UploadEncryptedRecordRequest::InternalSwap(UploadEncryptedRecordRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  encrypted_record_.InternalSwap(&other->encrypted_record_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(UploadEncryptedRecordRequest, need_encryption_keys_)
      + sizeof(UploadEncryptedRecordRequest::need_encryption_keys_)
      - PROTOBUF_FIELD_OFFSET(UploadEncryptedRecordRequest, remaining_storage_capacity_)>(
          reinterpret_cast<char*>(&remaining_storage_capacity_),
          reinterpret_cast<char*>(&other->remaining_storage_capacity_));
}

std::string UploadEncryptedRecordRequest::GetTypeName() const {
  return "reporting.UploadEncryptedRecordRequest";
}


// ===================================================================

class UploadEncryptedRecordResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<UploadEncryptedRecordResponse>()._has_bits_);
  static const ::reporting::StatusProto& status(const UploadEncryptedRecordResponse* msg);
  static void set_has_status(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::reporting::StatusProto&
UploadEncryptedRecordResponse::_Internal::status(const UploadEncryptedRecordResponse* msg) {
  return *msg->status_;
}
void UploadEncryptedRecordResponse::clear_status() {
  if (status_ != nullptr) status_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
UploadEncryptedRecordResponse::UploadEncryptedRecordResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:reporting.UploadEncryptedRecordResponse)
}
UploadEncryptedRecordResponse::UploadEncryptedRecordResponse(const UploadEncryptedRecordResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_status()) {
    status_ = new ::reporting::StatusProto(*from.status_);
  } else {
    status_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:reporting.UploadEncryptedRecordResponse)
}

inline void UploadEncryptedRecordResponse::SharedCtor() {
status_ = nullptr;
}

UploadEncryptedRecordResponse::~UploadEncryptedRecordResponse() {
  // @@protoc_insertion_point(destructor:reporting.UploadEncryptedRecordResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void UploadEncryptedRecordResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete status_;
}

void UploadEncryptedRecordResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void UploadEncryptedRecordResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:reporting.UploadEncryptedRecordResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(status_ != nullptr);
    status_->Clear();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* UploadEncryptedRecordResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .reporting.StatusProto status = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_status(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UploadEncryptedRecordResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:reporting.UploadEncryptedRecordResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .reporting.StatusProto status = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::status(this),
        _Internal::status(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:reporting.UploadEncryptedRecordResponse)
  return target;
}

size_t UploadEncryptedRecordResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:reporting.UploadEncryptedRecordResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .reporting.StatusProto status = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *status_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void UploadEncryptedRecordResponse::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const UploadEncryptedRecordResponse*>(
      &from));
}

void UploadEncryptedRecordResponse::MergeFrom(const UploadEncryptedRecordResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:reporting.UploadEncryptedRecordResponse)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_status()) {
    _internal_mutable_status()->::reporting::StatusProto::MergeFrom(from._internal_status());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void UploadEncryptedRecordResponse::CopyFrom(const UploadEncryptedRecordResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:reporting.UploadEncryptedRecordResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UploadEncryptedRecordResponse::IsInitialized() const {
  return true;
}

void UploadEncryptedRecordResponse::InternalSwap(UploadEncryptedRecordResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(status_, other->status_);
}

std::string UploadEncryptedRecordResponse::GetTypeName() const {
  return "reporting.UploadEncryptedRecordResponse";
}


// ===================================================================

class ConfirmRecordUploadRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<ConfirmRecordUploadRequest>()._has_bits_);
  static const ::reporting::SequenceInformation& sequence_information(const ConfirmRecordUploadRequest* msg);
  static void set_has_sequence_information(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_force_confirm(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::reporting::SequenceInformation&
ConfirmRecordUploadRequest::_Internal::sequence_information(const ConfirmRecordUploadRequest* msg) {
  return *msg->sequence_information_;
}
void ConfirmRecordUploadRequest::clear_sequence_information() {
  if (sequence_information_ != nullptr) sequence_information_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
ConfirmRecordUploadRequest::ConfirmRecordUploadRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:reporting.ConfirmRecordUploadRequest)
}
ConfirmRecordUploadRequest::ConfirmRecordUploadRequest(const ConfirmRecordUploadRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_sequence_information()) {
    sequence_information_ = new ::reporting::SequenceInformation(*from.sequence_information_);
  } else {
    sequence_information_ = nullptr;
  }
  force_confirm_ = from.force_confirm_;
  // @@protoc_insertion_point(copy_constructor:reporting.ConfirmRecordUploadRequest)
}

inline void ConfirmRecordUploadRequest::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&sequence_information_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&force_confirm_) -
    reinterpret_cast<char*>(&sequence_information_)) + sizeof(force_confirm_));
}

ConfirmRecordUploadRequest::~ConfirmRecordUploadRequest() {
  // @@protoc_insertion_point(destructor:reporting.ConfirmRecordUploadRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ConfirmRecordUploadRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete sequence_information_;
}

void ConfirmRecordUploadRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ConfirmRecordUploadRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:reporting.ConfirmRecordUploadRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(sequence_information_ != nullptr);
    sequence_information_->Clear();
  }
  force_confirm_ = false;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ConfirmRecordUploadRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .reporting.SequenceInformation sequence_information = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_sequence_information(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool force_confirm = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_force_confirm(&has_bits);
          force_confirm_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ConfirmRecordUploadRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:reporting.ConfirmRecordUploadRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .reporting.SequenceInformation sequence_information = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::sequence_information(this),
        _Internal::sequence_information(this).GetCachedSize(), target, stream);
  }

  // optional bool force_confirm = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_force_confirm(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:reporting.ConfirmRecordUploadRequest)
  return target;
}

size_t ConfirmRecordUploadRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:reporting.ConfirmRecordUploadRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .reporting.SequenceInformation sequence_information = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *sequence_information_);
    }

    // optional bool force_confirm = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ConfirmRecordUploadRequest::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ConfirmRecordUploadRequest*>(
      &from));
}

void ConfirmRecordUploadRequest::MergeFrom(const ConfirmRecordUploadRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:reporting.ConfirmRecordUploadRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_sequence_information()->::reporting::SequenceInformation::MergeFrom(from._internal_sequence_information());
    }
    if (cached_has_bits & 0x00000002u) {
      force_confirm_ = from.force_confirm_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ConfirmRecordUploadRequest::CopyFrom(const ConfirmRecordUploadRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:reporting.ConfirmRecordUploadRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ConfirmRecordUploadRequest::IsInitialized() const {
  return true;
}

void ConfirmRecordUploadRequest::InternalSwap(ConfirmRecordUploadRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ConfirmRecordUploadRequest, force_confirm_)
      + sizeof(ConfirmRecordUploadRequest::force_confirm_)
      - PROTOBUF_FIELD_OFFSET(ConfirmRecordUploadRequest, sequence_information_)>(
          reinterpret_cast<char*>(&sequence_information_),
          reinterpret_cast<char*>(&other->sequence_information_));
}

std::string ConfirmRecordUploadRequest::GetTypeName() const {
  return "reporting.ConfirmRecordUploadRequest";
}


// ===================================================================

class ConfirmRecordUploadResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<ConfirmRecordUploadResponse>()._has_bits_);
  static const ::reporting::StatusProto& status(const ConfirmRecordUploadResponse* msg);
  static void set_has_status(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::reporting::StatusProto&
ConfirmRecordUploadResponse::_Internal::status(const ConfirmRecordUploadResponse* msg) {
  return *msg->status_;
}
void ConfirmRecordUploadResponse::clear_status() {
  if (status_ != nullptr) status_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
ConfirmRecordUploadResponse::ConfirmRecordUploadResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:reporting.ConfirmRecordUploadResponse)
}
ConfirmRecordUploadResponse::ConfirmRecordUploadResponse(const ConfirmRecordUploadResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_status()) {
    status_ = new ::reporting::StatusProto(*from.status_);
  } else {
    status_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:reporting.ConfirmRecordUploadResponse)
}

inline void ConfirmRecordUploadResponse::SharedCtor() {
status_ = nullptr;
}

ConfirmRecordUploadResponse::~ConfirmRecordUploadResponse() {
  // @@protoc_insertion_point(destructor:reporting.ConfirmRecordUploadResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ConfirmRecordUploadResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete status_;
}

void ConfirmRecordUploadResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ConfirmRecordUploadResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:reporting.ConfirmRecordUploadResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(status_ != nullptr);
    status_->Clear();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ConfirmRecordUploadResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .reporting.StatusProto status = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_status(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ConfirmRecordUploadResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:reporting.ConfirmRecordUploadResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .reporting.StatusProto status = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::status(this),
        _Internal::status(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:reporting.ConfirmRecordUploadResponse)
  return target;
}

size_t ConfirmRecordUploadResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:reporting.ConfirmRecordUploadResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .reporting.StatusProto status = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *status_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ConfirmRecordUploadResponse::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ConfirmRecordUploadResponse*>(
      &from));
}

void ConfirmRecordUploadResponse::MergeFrom(const ConfirmRecordUploadResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:reporting.ConfirmRecordUploadResponse)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_status()) {
    _internal_mutable_status()->::reporting::StatusProto::MergeFrom(from._internal_status());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ConfirmRecordUploadResponse::CopyFrom(const ConfirmRecordUploadResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:reporting.ConfirmRecordUploadResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ConfirmRecordUploadResponse::IsInitialized() const {
  return true;
}

void ConfirmRecordUploadResponse::InternalSwap(ConfirmRecordUploadResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(status_, other->status_);
}

std::string ConfirmRecordUploadResponse::GetTypeName() const {
  return "reporting.ConfirmRecordUploadResponse";
}


// ===================================================================

class UpdateEncryptionKeyRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<UpdateEncryptionKeyRequest>()._has_bits_);
  static const ::reporting::SignedEncryptionInfo& signed_encryption_info(const UpdateEncryptionKeyRequest* msg);
  static void set_has_signed_encryption_info(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::reporting::SignedEncryptionInfo&
UpdateEncryptionKeyRequest::_Internal::signed_encryption_info(const UpdateEncryptionKeyRequest* msg) {
  return *msg->signed_encryption_info_;
}
void UpdateEncryptionKeyRequest::clear_signed_encryption_info() {
  if (signed_encryption_info_ != nullptr) signed_encryption_info_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
UpdateEncryptionKeyRequest::UpdateEncryptionKeyRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:reporting.UpdateEncryptionKeyRequest)
}
UpdateEncryptionKeyRequest::UpdateEncryptionKeyRequest(const UpdateEncryptionKeyRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_signed_encryption_info()) {
    signed_encryption_info_ = new ::reporting::SignedEncryptionInfo(*from.signed_encryption_info_);
  } else {
    signed_encryption_info_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:reporting.UpdateEncryptionKeyRequest)
}

inline void UpdateEncryptionKeyRequest::SharedCtor() {
signed_encryption_info_ = nullptr;
}

UpdateEncryptionKeyRequest::~UpdateEncryptionKeyRequest() {
  // @@protoc_insertion_point(destructor:reporting.UpdateEncryptionKeyRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void UpdateEncryptionKeyRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete signed_encryption_info_;
}

void UpdateEncryptionKeyRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void UpdateEncryptionKeyRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:reporting.UpdateEncryptionKeyRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(signed_encryption_info_ != nullptr);
    signed_encryption_info_->Clear();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* UpdateEncryptionKeyRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .reporting.SignedEncryptionInfo signed_encryption_info = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_signed_encryption_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UpdateEncryptionKeyRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:reporting.UpdateEncryptionKeyRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .reporting.SignedEncryptionInfo signed_encryption_info = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::signed_encryption_info(this),
        _Internal::signed_encryption_info(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:reporting.UpdateEncryptionKeyRequest)
  return target;
}

size_t UpdateEncryptionKeyRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:reporting.UpdateEncryptionKeyRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .reporting.SignedEncryptionInfo signed_encryption_info = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *signed_encryption_info_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void UpdateEncryptionKeyRequest::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const UpdateEncryptionKeyRequest*>(
      &from));
}

void UpdateEncryptionKeyRequest::MergeFrom(const UpdateEncryptionKeyRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:reporting.UpdateEncryptionKeyRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_signed_encryption_info()) {
    _internal_mutable_signed_encryption_info()->::reporting::SignedEncryptionInfo::MergeFrom(from._internal_signed_encryption_info());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void UpdateEncryptionKeyRequest::CopyFrom(const UpdateEncryptionKeyRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:reporting.UpdateEncryptionKeyRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UpdateEncryptionKeyRequest::IsInitialized() const {
  return true;
}

void UpdateEncryptionKeyRequest::InternalSwap(UpdateEncryptionKeyRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(signed_encryption_info_, other->signed_encryption_info_);
}

std::string UpdateEncryptionKeyRequest::GetTypeName() const {
  return "reporting.UpdateEncryptionKeyRequest";
}


// ===================================================================

class UpdateEncryptionKeyResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<UpdateEncryptionKeyResponse>()._has_bits_);
  static const ::reporting::StatusProto& status(const UpdateEncryptionKeyResponse* msg);
  static void set_has_status(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::reporting::StatusProto&
UpdateEncryptionKeyResponse::_Internal::status(const UpdateEncryptionKeyResponse* msg) {
  return *msg->status_;
}
void UpdateEncryptionKeyResponse::clear_status() {
  if (status_ != nullptr) status_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
UpdateEncryptionKeyResponse::UpdateEncryptionKeyResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:reporting.UpdateEncryptionKeyResponse)
}
UpdateEncryptionKeyResponse::UpdateEncryptionKeyResponse(const UpdateEncryptionKeyResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_status()) {
    status_ = new ::reporting::StatusProto(*from.status_);
  } else {
    status_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:reporting.UpdateEncryptionKeyResponse)
}

inline void UpdateEncryptionKeyResponse::SharedCtor() {
status_ = nullptr;
}

UpdateEncryptionKeyResponse::~UpdateEncryptionKeyResponse() {
  // @@protoc_insertion_point(destructor:reporting.UpdateEncryptionKeyResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void UpdateEncryptionKeyResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete status_;
}

void UpdateEncryptionKeyResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void UpdateEncryptionKeyResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:reporting.UpdateEncryptionKeyResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(status_ != nullptr);
    status_->Clear();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* UpdateEncryptionKeyResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .reporting.StatusProto status = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_status(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UpdateEncryptionKeyResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:reporting.UpdateEncryptionKeyResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .reporting.StatusProto status = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::status(this),
        _Internal::status(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:reporting.UpdateEncryptionKeyResponse)
  return target;
}

size_t UpdateEncryptionKeyResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:reporting.UpdateEncryptionKeyResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .reporting.StatusProto status = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *status_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void UpdateEncryptionKeyResponse::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const UpdateEncryptionKeyResponse*>(
      &from));
}

void UpdateEncryptionKeyResponse::MergeFrom(const UpdateEncryptionKeyResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:reporting.UpdateEncryptionKeyResponse)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_status()) {
    _internal_mutable_status()->::reporting::StatusProto::MergeFrom(from._internal_status());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void UpdateEncryptionKeyResponse::CopyFrom(const UpdateEncryptionKeyResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:reporting.UpdateEncryptionKeyResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UpdateEncryptionKeyResponse::IsInitialized() const {
  return true;
}

void UpdateEncryptionKeyResponse::InternalSwap(UpdateEncryptionKeyResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(status_, other->status_);
}

std::string UpdateEncryptionKeyResponse::GetTypeName() const {
  return "reporting.UpdateEncryptionKeyResponse";
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace reporting
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::reporting::EnqueueRecordRequest*
Arena::CreateMaybeMessage< ::reporting::EnqueueRecordRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::reporting::EnqueueRecordRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::reporting::EnqueueRecordResponse*
Arena::CreateMaybeMessage< ::reporting::EnqueueRecordResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::reporting::EnqueueRecordResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::reporting::FlushPriorityRequest*
Arena::CreateMaybeMessage< ::reporting::FlushPriorityRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::reporting::FlushPriorityRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::reporting::FlushPriorityResponse*
Arena::CreateMaybeMessage< ::reporting::FlushPriorityResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::reporting::FlushPriorityResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::reporting::UploadEncryptedRecordRequest*
Arena::CreateMaybeMessage< ::reporting::UploadEncryptedRecordRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::reporting::UploadEncryptedRecordRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::reporting::UploadEncryptedRecordResponse*
Arena::CreateMaybeMessage< ::reporting::UploadEncryptedRecordResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::reporting::UploadEncryptedRecordResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::reporting::ConfirmRecordUploadRequest*
Arena::CreateMaybeMessage< ::reporting::ConfirmRecordUploadRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::reporting::ConfirmRecordUploadRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::reporting::ConfirmRecordUploadResponse*
Arena::CreateMaybeMessage< ::reporting::ConfirmRecordUploadResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::reporting::ConfirmRecordUploadResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::reporting::UpdateEncryptionKeyRequest*
Arena::CreateMaybeMessage< ::reporting::UpdateEncryptionKeyRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::reporting::UpdateEncryptionKeyRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::reporting::UpdateEncryptionKeyResponse*
Arena::CreateMaybeMessage< ::reporting::UpdateEncryptionKeyResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::reporting::UpdateEncryptionKeyResponse >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
