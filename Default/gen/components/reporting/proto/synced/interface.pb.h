// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: components/reporting/proto/synced/interface.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_components_2freporting_2fproto_2fsynced_2finterface_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_components_2freporting_2fproto_2fsynced_2finterface_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3020000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3020000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include "components/reporting/proto/synced/record_constants.pb.h"
#include "components/reporting/proto/synced/record.pb.h"
#include "components/reporting/util/status.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_components_2freporting_2fproto_2fsynced_2finterface_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_components_2freporting_2fproto_2fsynced_2finterface_2eproto {
  static const uint32_t offsets[];
};
namespace reporting {
class ConfirmRecordUploadRequest;
struct ConfirmRecordUploadRequestDefaultTypeInternal;
extern ConfirmRecordUploadRequestDefaultTypeInternal _ConfirmRecordUploadRequest_default_instance_;
class ConfirmRecordUploadResponse;
struct ConfirmRecordUploadResponseDefaultTypeInternal;
extern ConfirmRecordUploadResponseDefaultTypeInternal _ConfirmRecordUploadResponse_default_instance_;
class EnqueueRecordRequest;
struct EnqueueRecordRequestDefaultTypeInternal;
extern EnqueueRecordRequestDefaultTypeInternal _EnqueueRecordRequest_default_instance_;
class EnqueueRecordResponse;
struct EnqueueRecordResponseDefaultTypeInternal;
extern EnqueueRecordResponseDefaultTypeInternal _EnqueueRecordResponse_default_instance_;
class FlushPriorityRequest;
struct FlushPriorityRequestDefaultTypeInternal;
extern FlushPriorityRequestDefaultTypeInternal _FlushPriorityRequest_default_instance_;
class FlushPriorityResponse;
struct FlushPriorityResponseDefaultTypeInternal;
extern FlushPriorityResponseDefaultTypeInternal _FlushPriorityResponse_default_instance_;
class UpdateEncryptionKeyRequest;
struct UpdateEncryptionKeyRequestDefaultTypeInternal;
extern UpdateEncryptionKeyRequestDefaultTypeInternal _UpdateEncryptionKeyRequest_default_instance_;
class UpdateEncryptionKeyResponse;
struct UpdateEncryptionKeyResponseDefaultTypeInternal;
extern UpdateEncryptionKeyResponseDefaultTypeInternal _UpdateEncryptionKeyResponse_default_instance_;
class UploadEncryptedRecordRequest;
struct UploadEncryptedRecordRequestDefaultTypeInternal;
extern UploadEncryptedRecordRequestDefaultTypeInternal _UploadEncryptedRecordRequest_default_instance_;
class UploadEncryptedRecordResponse;
struct UploadEncryptedRecordResponseDefaultTypeInternal;
extern UploadEncryptedRecordResponseDefaultTypeInternal _UploadEncryptedRecordResponse_default_instance_;
}  // namespace reporting
PROTOBUF_NAMESPACE_OPEN
template<> ::reporting::ConfirmRecordUploadRequest* Arena::CreateMaybeMessage<::reporting::ConfirmRecordUploadRequest>(Arena*);
template<> ::reporting::ConfirmRecordUploadResponse* Arena::CreateMaybeMessage<::reporting::ConfirmRecordUploadResponse>(Arena*);
template<> ::reporting::EnqueueRecordRequest* Arena::CreateMaybeMessage<::reporting::EnqueueRecordRequest>(Arena*);
template<> ::reporting::EnqueueRecordResponse* Arena::CreateMaybeMessage<::reporting::EnqueueRecordResponse>(Arena*);
template<> ::reporting::FlushPriorityRequest* Arena::CreateMaybeMessage<::reporting::FlushPriorityRequest>(Arena*);
template<> ::reporting::FlushPriorityResponse* Arena::CreateMaybeMessage<::reporting::FlushPriorityResponse>(Arena*);
template<> ::reporting::UpdateEncryptionKeyRequest* Arena::CreateMaybeMessage<::reporting::UpdateEncryptionKeyRequest>(Arena*);
template<> ::reporting::UpdateEncryptionKeyResponse* Arena::CreateMaybeMessage<::reporting::UpdateEncryptionKeyResponse>(Arena*);
template<> ::reporting::UploadEncryptedRecordRequest* Arena::CreateMaybeMessage<::reporting::UploadEncryptedRecordRequest>(Arena*);
template<> ::reporting::UploadEncryptedRecordResponse* Arena::CreateMaybeMessage<::reporting::UploadEncryptedRecordResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace reporting {

// ===================================================================

class EnqueueRecordRequest final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:reporting.EnqueueRecordRequest) */ {
 public:
  inline EnqueueRecordRequest() : EnqueueRecordRequest(nullptr) {}
  ~EnqueueRecordRequest() override;
  explicit PROTOBUF_CONSTEXPR EnqueueRecordRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EnqueueRecordRequest(const EnqueueRecordRequest& from);
  EnqueueRecordRequest(EnqueueRecordRequest&& from) noexcept
    : EnqueueRecordRequest() {
    *this = ::std::move(from);
  }

  inline EnqueueRecordRequest& operator=(const EnqueueRecordRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline EnqueueRecordRequest& operator=(EnqueueRecordRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const EnqueueRecordRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const EnqueueRecordRequest* internal_default_instance() {
    return reinterpret_cast<const EnqueueRecordRequest*>(
               &_EnqueueRecordRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(EnqueueRecordRequest& a, EnqueueRecordRequest& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(EnqueueRecordRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EnqueueRecordRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EnqueueRecordRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EnqueueRecordRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const EnqueueRecordRequest& from);
  void MergeFrom(const EnqueueRecordRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(EnqueueRecordRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "reporting.EnqueueRecordRequest";
  }
  protected:
  explicit EnqueueRecordRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRecordFieldNumber = 1,
    kPriorityFieldNumber = 2,
  };
  // optional .reporting.Record record = 1;
  bool has_record() const;
  private:
  bool _internal_has_record() const;
  public:
  void clear_record();
  const ::reporting::Record& record() const;
  PROTOBUF_NODISCARD ::reporting::Record* release_record();
  ::reporting::Record* mutable_record();
  void set_allocated_record(::reporting::Record* record);
  private:
  const ::reporting::Record& _internal_record() const;
  ::reporting::Record* _internal_mutable_record();
  public:
  void unsafe_arena_set_allocated_record(
      ::reporting::Record* record);
  ::reporting::Record* unsafe_arena_release_record();

  // optional .reporting.Priority priority = 2;
  bool has_priority() const;
  private:
  bool _internal_has_priority() const;
  public:
  void clear_priority();
  ::reporting::Priority priority() const;
  void set_priority(::reporting::Priority value);
  private:
  ::reporting::Priority _internal_priority() const;
  void _internal_set_priority(::reporting::Priority value);
  public:

  // @@protoc_insertion_point(class_scope:reporting.EnqueueRecordRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::reporting::Record* record_;
  int priority_;
  friend struct ::TableStruct_components_2freporting_2fproto_2fsynced_2finterface_2eproto;
};
// -------------------------------------------------------------------

class EnqueueRecordResponse final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:reporting.EnqueueRecordResponse) */ {
 public:
  inline EnqueueRecordResponse() : EnqueueRecordResponse(nullptr) {}
  ~EnqueueRecordResponse() override;
  explicit PROTOBUF_CONSTEXPR EnqueueRecordResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EnqueueRecordResponse(const EnqueueRecordResponse& from);
  EnqueueRecordResponse(EnqueueRecordResponse&& from) noexcept
    : EnqueueRecordResponse() {
    *this = ::std::move(from);
  }

  inline EnqueueRecordResponse& operator=(const EnqueueRecordResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline EnqueueRecordResponse& operator=(EnqueueRecordResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const EnqueueRecordResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const EnqueueRecordResponse* internal_default_instance() {
    return reinterpret_cast<const EnqueueRecordResponse*>(
               &_EnqueueRecordResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(EnqueueRecordResponse& a, EnqueueRecordResponse& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(EnqueueRecordResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EnqueueRecordResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EnqueueRecordResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EnqueueRecordResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const EnqueueRecordResponse& from);
  void MergeFrom(const EnqueueRecordResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(EnqueueRecordResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "reporting.EnqueueRecordResponse";
  }
  protected:
  explicit EnqueueRecordResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
  };
  // optional .reporting.StatusProto status = 1;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::reporting::StatusProto& status() const;
  PROTOBUF_NODISCARD ::reporting::StatusProto* release_status();
  ::reporting::StatusProto* mutable_status();
  void set_allocated_status(::reporting::StatusProto* status);
  private:
  const ::reporting::StatusProto& _internal_status() const;
  ::reporting::StatusProto* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::reporting::StatusProto* status);
  ::reporting::StatusProto* unsafe_arena_release_status();

  // @@protoc_insertion_point(class_scope:reporting.EnqueueRecordResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::reporting::StatusProto* status_;
  friend struct ::TableStruct_components_2freporting_2fproto_2fsynced_2finterface_2eproto;
};
// -------------------------------------------------------------------

class FlushPriorityRequest final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:reporting.FlushPriorityRequest) */ {
 public:
  inline FlushPriorityRequest() : FlushPriorityRequest(nullptr) {}
  ~FlushPriorityRequest() override;
  explicit PROTOBUF_CONSTEXPR FlushPriorityRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FlushPriorityRequest(const FlushPriorityRequest& from);
  FlushPriorityRequest(FlushPriorityRequest&& from) noexcept
    : FlushPriorityRequest() {
    *this = ::std::move(from);
  }

  inline FlushPriorityRequest& operator=(const FlushPriorityRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline FlushPriorityRequest& operator=(FlushPriorityRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const FlushPriorityRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const FlushPriorityRequest* internal_default_instance() {
    return reinterpret_cast<const FlushPriorityRequest*>(
               &_FlushPriorityRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(FlushPriorityRequest& a, FlushPriorityRequest& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(FlushPriorityRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FlushPriorityRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FlushPriorityRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FlushPriorityRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const FlushPriorityRequest& from);
  void MergeFrom(const FlushPriorityRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(FlushPriorityRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "reporting.FlushPriorityRequest";
  }
  protected:
  explicit FlushPriorityRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPriorityFieldNumber = 1,
  };
  // optional .reporting.Priority priority = 1 [default = MANUAL_BATCH];
  bool has_priority() const;
  private:
  bool _internal_has_priority() const;
  public:
  void clear_priority();
  ::reporting::Priority priority() const;
  void set_priority(::reporting::Priority value);
  private:
  ::reporting::Priority _internal_priority() const;
  void _internal_set_priority(::reporting::Priority value);
  public:

  // @@protoc_insertion_point(class_scope:reporting.FlushPriorityRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int priority_;
  friend struct ::TableStruct_components_2freporting_2fproto_2fsynced_2finterface_2eproto;
};
// -------------------------------------------------------------------

class FlushPriorityResponse final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:reporting.FlushPriorityResponse) */ {
 public:
  inline FlushPriorityResponse() : FlushPriorityResponse(nullptr) {}
  ~FlushPriorityResponse() override;
  explicit PROTOBUF_CONSTEXPR FlushPriorityResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FlushPriorityResponse(const FlushPriorityResponse& from);
  FlushPriorityResponse(FlushPriorityResponse&& from) noexcept
    : FlushPriorityResponse() {
    *this = ::std::move(from);
  }

  inline FlushPriorityResponse& operator=(const FlushPriorityResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline FlushPriorityResponse& operator=(FlushPriorityResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const FlushPriorityResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const FlushPriorityResponse* internal_default_instance() {
    return reinterpret_cast<const FlushPriorityResponse*>(
               &_FlushPriorityResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(FlushPriorityResponse& a, FlushPriorityResponse& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(FlushPriorityResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FlushPriorityResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FlushPriorityResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FlushPriorityResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const FlushPriorityResponse& from);
  void MergeFrom(const FlushPriorityResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(FlushPriorityResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "reporting.FlushPriorityResponse";
  }
  protected:
  explicit FlushPriorityResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
  };
  // optional .reporting.StatusProto status = 1;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::reporting::StatusProto& status() const;
  PROTOBUF_NODISCARD ::reporting::StatusProto* release_status();
  ::reporting::StatusProto* mutable_status();
  void set_allocated_status(::reporting::StatusProto* status);
  private:
  const ::reporting::StatusProto& _internal_status() const;
  ::reporting::StatusProto* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::reporting::StatusProto* status);
  ::reporting::StatusProto* unsafe_arena_release_status();

  // @@protoc_insertion_point(class_scope:reporting.FlushPriorityResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::reporting::StatusProto* status_;
  friend struct ::TableStruct_components_2freporting_2fproto_2fsynced_2finterface_2eproto;
};
// -------------------------------------------------------------------

class UploadEncryptedRecordRequest final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:reporting.UploadEncryptedRecordRequest) */ {
 public:
  inline UploadEncryptedRecordRequest() : UploadEncryptedRecordRequest(nullptr) {}
  ~UploadEncryptedRecordRequest() override;
  explicit PROTOBUF_CONSTEXPR UploadEncryptedRecordRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UploadEncryptedRecordRequest(const UploadEncryptedRecordRequest& from);
  UploadEncryptedRecordRequest(UploadEncryptedRecordRequest&& from) noexcept
    : UploadEncryptedRecordRequest() {
    *this = ::std::move(from);
  }

  inline UploadEncryptedRecordRequest& operator=(const UploadEncryptedRecordRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UploadEncryptedRecordRequest& operator=(UploadEncryptedRecordRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const UploadEncryptedRecordRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UploadEncryptedRecordRequest* internal_default_instance() {
    return reinterpret_cast<const UploadEncryptedRecordRequest*>(
               &_UploadEncryptedRecordRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(UploadEncryptedRecordRequest& a, UploadEncryptedRecordRequest& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(UploadEncryptedRecordRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UploadEncryptedRecordRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UploadEncryptedRecordRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UploadEncryptedRecordRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const UploadEncryptedRecordRequest& from);
  void MergeFrom(const UploadEncryptedRecordRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(UploadEncryptedRecordRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "reporting.UploadEncryptedRecordRequest";
  }
  protected:
  explicit UploadEncryptedRecordRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEncryptedRecordFieldNumber = 1,
    kRemainingStorageCapacityFieldNumber = 3,
    kNewEventsRateFieldNumber = 4,
    kNeedEncryptionKeysFieldNumber = 2,
  };
  // repeated .reporting.EncryptedRecord encrypted_record = 1;
  int encrypted_record_size() const;
  private:
  int _internal_encrypted_record_size() const;
  public:
  void clear_encrypted_record();
  ::reporting::EncryptedRecord* mutable_encrypted_record(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::reporting::EncryptedRecord >*
      mutable_encrypted_record();
  private:
  const ::reporting::EncryptedRecord& _internal_encrypted_record(int index) const;
  ::reporting::EncryptedRecord* _internal_add_encrypted_record();
  public:
  const ::reporting::EncryptedRecord& encrypted_record(int index) const;
  ::reporting::EncryptedRecord* add_encrypted_record();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::reporting::EncryptedRecord >&
      encrypted_record() const;

  // optional uint64 remaining_storage_capacity = 3;
  bool has_remaining_storage_capacity() const;
  private:
  bool _internal_has_remaining_storage_capacity() const;
  public:
  void clear_remaining_storage_capacity();
  uint64_t remaining_storage_capacity() const;
  void set_remaining_storage_capacity(uint64_t value);
  private:
  uint64_t _internal_remaining_storage_capacity() const;
  void _internal_set_remaining_storage_capacity(uint64_t value);
  public:

  // optional uint64 new_events_rate = 4;
  bool has_new_events_rate() const;
  private:
  bool _internal_has_new_events_rate() const;
  public:
  void clear_new_events_rate();
  uint64_t new_events_rate() const;
  void set_new_events_rate(uint64_t value);
  private:
  uint64_t _internal_new_events_rate() const;
  void _internal_set_new_events_rate(uint64_t value);
  public:

  // optional bool need_encryption_keys = 2;
  bool has_need_encryption_keys() const;
  private:
  bool _internal_has_need_encryption_keys() const;
  public:
  void clear_need_encryption_keys();
  bool need_encryption_keys() const;
  void set_need_encryption_keys(bool value);
  private:
  bool _internal_need_encryption_keys() const;
  void _internal_set_need_encryption_keys(bool value);
  public:

  // @@protoc_insertion_point(class_scope:reporting.UploadEncryptedRecordRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::reporting::EncryptedRecord > encrypted_record_;
  uint64_t remaining_storage_capacity_;
  uint64_t new_events_rate_;
  bool need_encryption_keys_;
  friend struct ::TableStruct_components_2freporting_2fproto_2fsynced_2finterface_2eproto;
};
// -------------------------------------------------------------------

class UploadEncryptedRecordResponse final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:reporting.UploadEncryptedRecordResponse) */ {
 public:
  inline UploadEncryptedRecordResponse() : UploadEncryptedRecordResponse(nullptr) {}
  ~UploadEncryptedRecordResponse() override;
  explicit PROTOBUF_CONSTEXPR UploadEncryptedRecordResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UploadEncryptedRecordResponse(const UploadEncryptedRecordResponse& from);
  UploadEncryptedRecordResponse(UploadEncryptedRecordResponse&& from) noexcept
    : UploadEncryptedRecordResponse() {
    *this = ::std::move(from);
  }

  inline UploadEncryptedRecordResponse& operator=(const UploadEncryptedRecordResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UploadEncryptedRecordResponse& operator=(UploadEncryptedRecordResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const UploadEncryptedRecordResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const UploadEncryptedRecordResponse* internal_default_instance() {
    return reinterpret_cast<const UploadEncryptedRecordResponse*>(
               &_UploadEncryptedRecordResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(UploadEncryptedRecordResponse& a, UploadEncryptedRecordResponse& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(UploadEncryptedRecordResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UploadEncryptedRecordResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UploadEncryptedRecordResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UploadEncryptedRecordResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const UploadEncryptedRecordResponse& from);
  void MergeFrom(const UploadEncryptedRecordResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(UploadEncryptedRecordResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "reporting.UploadEncryptedRecordResponse";
  }
  protected:
  explicit UploadEncryptedRecordResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
  };
  // optional .reporting.StatusProto status = 1;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::reporting::StatusProto& status() const;
  PROTOBUF_NODISCARD ::reporting::StatusProto* release_status();
  ::reporting::StatusProto* mutable_status();
  void set_allocated_status(::reporting::StatusProto* status);
  private:
  const ::reporting::StatusProto& _internal_status() const;
  ::reporting::StatusProto* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::reporting::StatusProto* status);
  ::reporting::StatusProto* unsafe_arena_release_status();

  // @@protoc_insertion_point(class_scope:reporting.UploadEncryptedRecordResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::reporting::StatusProto* status_;
  friend struct ::TableStruct_components_2freporting_2fproto_2fsynced_2finterface_2eproto;
};
// -------------------------------------------------------------------

class ConfirmRecordUploadRequest final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:reporting.ConfirmRecordUploadRequest) */ {
 public:
  inline ConfirmRecordUploadRequest() : ConfirmRecordUploadRequest(nullptr) {}
  ~ConfirmRecordUploadRequest() override;
  explicit PROTOBUF_CONSTEXPR ConfirmRecordUploadRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConfirmRecordUploadRequest(const ConfirmRecordUploadRequest& from);
  ConfirmRecordUploadRequest(ConfirmRecordUploadRequest&& from) noexcept
    : ConfirmRecordUploadRequest() {
    *this = ::std::move(from);
  }

  inline ConfirmRecordUploadRequest& operator=(const ConfirmRecordUploadRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConfirmRecordUploadRequest& operator=(ConfirmRecordUploadRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ConfirmRecordUploadRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConfirmRecordUploadRequest* internal_default_instance() {
    return reinterpret_cast<const ConfirmRecordUploadRequest*>(
               &_ConfirmRecordUploadRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(ConfirmRecordUploadRequest& a, ConfirmRecordUploadRequest& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(ConfirmRecordUploadRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConfirmRecordUploadRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConfirmRecordUploadRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConfirmRecordUploadRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ConfirmRecordUploadRequest& from);
  void MergeFrom(const ConfirmRecordUploadRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ConfirmRecordUploadRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "reporting.ConfirmRecordUploadRequest";
  }
  protected:
  explicit ConfirmRecordUploadRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSequenceInformationFieldNumber = 1,
    kForceConfirmFieldNumber = 2,
  };
  // optional .reporting.SequenceInformation sequence_information = 1;
  bool has_sequence_information() const;
  private:
  bool _internal_has_sequence_information() const;
  public:
  void clear_sequence_information();
  const ::reporting::SequenceInformation& sequence_information() const;
  PROTOBUF_NODISCARD ::reporting::SequenceInformation* release_sequence_information();
  ::reporting::SequenceInformation* mutable_sequence_information();
  void set_allocated_sequence_information(::reporting::SequenceInformation* sequence_information);
  private:
  const ::reporting::SequenceInformation& _internal_sequence_information() const;
  ::reporting::SequenceInformation* _internal_mutable_sequence_information();
  public:
  void unsafe_arena_set_allocated_sequence_information(
      ::reporting::SequenceInformation* sequence_information);
  ::reporting::SequenceInformation* unsafe_arena_release_sequence_information();

  // optional bool force_confirm = 2;
  bool has_force_confirm() const;
  private:
  bool _internal_has_force_confirm() const;
  public:
  void clear_force_confirm();
  bool force_confirm() const;
  void set_force_confirm(bool value);
  private:
  bool _internal_force_confirm() const;
  void _internal_set_force_confirm(bool value);
  public:

  // @@protoc_insertion_point(class_scope:reporting.ConfirmRecordUploadRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::reporting::SequenceInformation* sequence_information_;
  bool force_confirm_;
  friend struct ::TableStruct_components_2freporting_2fproto_2fsynced_2finterface_2eproto;
};
// -------------------------------------------------------------------

class ConfirmRecordUploadResponse final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:reporting.ConfirmRecordUploadResponse) */ {
 public:
  inline ConfirmRecordUploadResponse() : ConfirmRecordUploadResponse(nullptr) {}
  ~ConfirmRecordUploadResponse() override;
  explicit PROTOBUF_CONSTEXPR ConfirmRecordUploadResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConfirmRecordUploadResponse(const ConfirmRecordUploadResponse& from);
  ConfirmRecordUploadResponse(ConfirmRecordUploadResponse&& from) noexcept
    : ConfirmRecordUploadResponse() {
    *this = ::std::move(from);
  }

  inline ConfirmRecordUploadResponse& operator=(const ConfirmRecordUploadResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConfirmRecordUploadResponse& operator=(ConfirmRecordUploadResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ConfirmRecordUploadResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConfirmRecordUploadResponse* internal_default_instance() {
    return reinterpret_cast<const ConfirmRecordUploadResponse*>(
               &_ConfirmRecordUploadResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(ConfirmRecordUploadResponse& a, ConfirmRecordUploadResponse& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(ConfirmRecordUploadResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConfirmRecordUploadResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConfirmRecordUploadResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConfirmRecordUploadResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ConfirmRecordUploadResponse& from);
  void MergeFrom(const ConfirmRecordUploadResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ConfirmRecordUploadResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "reporting.ConfirmRecordUploadResponse";
  }
  protected:
  explicit ConfirmRecordUploadResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
  };
  // optional .reporting.StatusProto status = 1;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::reporting::StatusProto& status() const;
  PROTOBUF_NODISCARD ::reporting::StatusProto* release_status();
  ::reporting::StatusProto* mutable_status();
  void set_allocated_status(::reporting::StatusProto* status);
  private:
  const ::reporting::StatusProto& _internal_status() const;
  ::reporting::StatusProto* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::reporting::StatusProto* status);
  ::reporting::StatusProto* unsafe_arena_release_status();

  // @@protoc_insertion_point(class_scope:reporting.ConfirmRecordUploadResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::reporting::StatusProto* status_;
  friend struct ::TableStruct_components_2freporting_2fproto_2fsynced_2finterface_2eproto;
};
// -------------------------------------------------------------------

class UpdateEncryptionKeyRequest final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:reporting.UpdateEncryptionKeyRequest) */ {
 public:
  inline UpdateEncryptionKeyRequest() : UpdateEncryptionKeyRequest(nullptr) {}
  ~UpdateEncryptionKeyRequest() override;
  explicit PROTOBUF_CONSTEXPR UpdateEncryptionKeyRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateEncryptionKeyRequest(const UpdateEncryptionKeyRequest& from);
  UpdateEncryptionKeyRequest(UpdateEncryptionKeyRequest&& from) noexcept
    : UpdateEncryptionKeyRequest() {
    *this = ::std::move(from);
  }

  inline UpdateEncryptionKeyRequest& operator=(const UpdateEncryptionKeyRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateEncryptionKeyRequest& operator=(UpdateEncryptionKeyRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const UpdateEncryptionKeyRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateEncryptionKeyRequest* internal_default_instance() {
    return reinterpret_cast<const UpdateEncryptionKeyRequest*>(
               &_UpdateEncryptionKeyRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(UpdateEncryptionKeyRequest& a, UpdateEncryptionKeyRequest& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(UpdateEncryptionKeyRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateEncryptionKeyRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateEncryptionKeyRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateEncryptionKeyRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const UpdateEncryptionKeyRequest& from);
  void MergeFrom(const UpdateEncryptionKeyRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(UpdateEncryptionKeyRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "reporting.UpdateEncryptionKeyRequest";
  }
  protected:
  explicit UpdateEncryptionKeyRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSignedEncryptionInfoFieldNumber = 1,
  };
  // optional .reporting.SignedEncryptionInfo signed_encryption_info = 1;
  bool has_signed_encryption_info() const;
  private:
  bool _internal_has_signed_encryption_info() const;
  public:
  void clear_signed_encryption_info();
  const ::reporting::SignedEncryptionInfo& signed_encryption_info() const;
  PROTOBUF_NODISCARD ::reporting::SignedEncryptionInfo* release_signed_encryption_info();
  ::reporting::SignedEncryptionInfo* mutable_signed_encryption_info();
  void set_allocated_signed_encryption_info(::reporting::SignedEncryptionInfo* signed_encryption_info);
  private:
  const ::reporting::SignedEncryptionInfo& _internal_signed_encryption_info() const;
  ::reporting::SignedEncryptionInfo* _internal_mutable_signed_encryption_info();
  public:
  void unsafe_arena_set_allocated_signed_encryption_info(
      ::reporting::SignedEncryptionInfo* signed_encryption_info);
  ::reporting::SignedEncryptionInfo* unsafe_arena_release_signed_encryption_info();

  // @@protoc_insertion_point(class_scope:reporting.UpdateEncryptionKeyRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::reporting::SignedEncryptionInfo* signed_encryption_info_;
  friend struct ::TableStruct_components_2freporting_2fproto_2fsynced_2finterface_2eproto;
};
// -------------------------------------------------------------------

class UpdateEncryptionKeyResponse final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:reporting.UpdateEncryptionKeyResponse) */ {
 public:
  inline UpdateEncryptionKeyResponse() : UpdateEncryptionKeyResponse(nullptr) {}
  ~UpdateEncryptionKeyResponse() override;
  explicit PROTOBUF_CONSTEXPR UpdateEncryptionKeyResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateEncryptionKeyResponse(const UpdateEncryptionKeyResponse& from);
  UpdateEncryptionKeyResponse(UpdateEncryptionKeyResponse&& from) noexcept
    : UpdateEncryptionKeyResponse() {
    *this = ::std::move(from);
  }

  inline UpdateEncryptionKeyResponse& operator=(const UpdateEncryptionKeyResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateEncryptionKeyResponse& operator=(UpdateEncryptionKeyResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const UpdateEncryptionKeyResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateEncryptionKeyResponse* internal_default_instance() {
    return reinterpret_cast<const UpdateEncryptionKeyResponse*>(
               &_UpdateEncryptionKeyResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(UpdateEncryptionKeyResponse& a, UpdateEncryptionKeyResponse& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(UpdateEncryptionKeyResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateEncryptionKeyResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateEncryptionKeyResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateEncryptionKeyResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const UpdateEncryptionKeyResponse& from);
  void MergeFrom(const UpdateEncryptionKeyResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(UpdateEncryptionKeyResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "reporting.UpdateEncryptionKeyResponse";
  }
  protected:
  explicit UpdateEncryptionKeyResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
  };
  // optional .reporting.StatusProto status = 1;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::reporting::StatusProto& status() const;
  PROTOBUF_NODISCARD ::reporting::StatusProto* release_status();
  ::reporting::StatusProto* mutable_status();
  void set_allocated_status(::reporting::StatusProto* status);
  private:
  const ::reporting::StatusProto& _internal_status() const;
  ::reporting::StatusProto* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::reporting::StatusProto* status);
  ::reporting::StatusProto* unsafe_arena_release_status();

  // @@protoc_insertion_point(class_scope:reporting.UpdateEncryptionKeyResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::reporting::StatusProto* status_;
  friend struct ::TableStruct_components_2freporting_2fproto_2fsynced_2finterface_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// EnqueueRecordRequest

// optional .reporting.Record record = 1;
inline bool EnqueueRecordRequest::_internal_has_record() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || record_ != nullptr);
  return value;
}
inline bool EnqueueRecordRequest::has_record() const {
  return _internal_has_record();
}
inline const ::reporting::Record& EnqueueRecordRequest::_internal_record() const {
  const ::reporting::Record* p = record_;
  return p != nullptr ? *p : reinterpret_cast<const ::reporting::Record&>(
      ::reporting::_Record_default_instance_);
}
inline const ::reporting::Record& EnqueueRecordRequest::record() const {
  // @@protoc_insertion_point(field_get:reporting.EnqueueRecordRequest.record)
  return _internal_record();
}
inline void EnqueueRecordRequest::unsafe_arena_set_allocated_record(
    ::reporting::Record* record) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(record_);
  }
  record_ = record;
  if (record) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:reporting.EnqueueRecordRequest.record)
}
inline ::reporting::Record* EnqueueRecordRequest::release_record() {
  _has_bits_[0] &= ~0x00000001u;
  ::reporting::Record* temp = record_;
  record_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::reporting::Record* EnqueueRecordRequest::unsafe_arena_release_record() {
  // @@protoc_insertion_point(field_release:reporting.EnqueueRecordRequest.record)
  _has_bits_[0] &= ~0x00000001u;
  ::reporting::Record* temp = record_;
  record_ = nullptr;
  return temp;
}
inline ::reporting::Record* EnqueueRecordRequest::_internal_mutable_record() {
  _has_bits_[0] |= 0x00000001u;
  if (record_ == nullptr) {
    auto* p = CreateMaybeMessage<::reporting::Record>(GetArenaForAllocation());
    record_ = p;
  }
  return record_;
}
inline ::reporting::Record* EnqueueRecordRequest::mutable_record() {
  ::reporting::Record* _msg = _internal_mutable_record();
  // @@protoc_insertion_point(field_mutable:reporting.EnqueueRecordRequest.record)
  return _msg;
}
inline void EnqueueRecordRequest::set_allocated_record(::reporting::Record* record) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(record_);
  }
  if (record) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(record));
    if (message_arena != submessage_arena) {
      record = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, record, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  record_ = record;
  // @@protoc_insertion_point(field_set_allocated:reporting.EnqueueRecordRequest.record)
}

// optional .reporting.Priority priority = 2;
inline bool EnqueueRecordRequest::_internal_has_priority() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool EnqueueRecordRequest::has_priority() const {
  return _internal_has_priority();
}
inline void EnqueueRecordRequest::clear_priority() {
  priority_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::reporting::Priority EnqueueRecordRequest::_internal_priority() const {
  return static_cast< ::reporting::Priority >(priority_);
}
inline ::reporting::Priority EnqueueRecordRequest::priority() const {
  // @@protoc_insertion_point(field_get:reporting.EnqueueRecordRequest.priority)
  return _internal_priority();
}
inline void EnqueueRecordRequest::_internal_set_priority(::reporting::Priority value) {
  assert(::reporting::Priority_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  priority_ = value;
}
inline void EnqueueRecordRequest::set_priority(::reporting::Priority value) {
  _internal_set_priority(value);
  // @@protoc_insertion_point(field_set:reporting.EnqueueRecordRequest.priority)
}

// -------------------------------------------------------------------

// EnqueueRecordResponse

// optional .reporting.StatusProto status = 1;
inline bool EnqueueRecordResponse::_internal_has_status() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || status_ != nullptr);
  return value;
}
inline bool EnqueueRecordResponse::has_status() const {
  return _internal_has_status();
}
inline const ::reporting::StatusProto& EnqueueRecordResponse::_internal_status() const {
  const ::reporting::StatusProto* p = status_;
  return p != nullptr ? *p : reinterpret_cast<const ::reporting::StatusProto&>(
      ::reporting::_StatusProto_default_instance_);
}
inline const ::reporting::StatusProto& EnqueueRecordResponse::status() const {
  // @@protoc_insertion_point(field_get:reporting.EnqueueRecordResponse.status)
  return _internal_status();
}
inline void EnqueueRecordResponse::unsafe_arena_set_allocated_status(
    ::reporting::StatusProto* status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status_);
  }
  status_ = status;
  if (status) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:reporting.EnqueueRecordResponse.status)
}
inline ::reporting::StatusProto* EnqueueRecordResponse::release_status() {
  _has_bits_[0] &= ~0x00000001u;
  ::reporting::StatusProto* temp = status_;
  status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::reporting::StatusProto* EnqueueRecordResponse::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:reporting.EnqueueRecordResponse.status)
  _has_bits_[0] &= ~0x00000001u;
  ::reporting::StatusProto* temp = status_;
  status_ = nullptr;
  return temp;
}
inline ::reporting::StatusProto* EnqueueRecordResponse::_internal_mutable_status() {
  _has_bits_[0] |= 0x00000001u;
  if (status_ == nullptr) {
    auto* p = CreateMaybeMessage<::reporting::StatusProto>(GetArenaForAllocation());
    status_ = p;
  }
  return status_;
}
inline ::reporting::StatusProto* EnqueueRecordResponse::mutable_status() {
  ::reporting::StatusProto* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:reporting.EnqueueRecordResponse.status)
  return _msg;
}
inline void EnqueueRecordResponse::set_allocated_status(::reporting::StatusProto* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(status_);
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status));
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  status_ = status;
  // @@protoc_insertion_point(field_set_allocated:reporting.EnqueueRecordResponse.status)
}

// -------------------------------------------------------------------

// FlushPriorityRequest

// optional .reporting.Priority priority = 1 [default = MANUAL_BATCH];
inline bool FlushPriorityRequest::_internal_has_priority() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool FlushPriorityRequest::has_priority() const {
  return _internal_has_priority();
}
inline void FlushPriorityRequest::clear_priority() {
  priority_ = 5;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::reporting::Priority FlushPriorityRequest::_internal_priority() const {
  return static_cast< ::reporting::Priority >(priority_);
}
inline ::reporting::Priority FlushPriorityRequest::priority() const {
  // @@protoc_insertion_point(field_get:reporting.FlushPriorityRequest.priority)
  return _internal_priority();
}
inline void FlushPriorityRequest::_internal_set_priority(::reporting::Priority value) {
  assert(::reporting::Priority_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  priority_ = value;
}
inline void FlushPriorityRequest::set_priority(::reporting::Priority value) {
  _internal_set_priority(value);
  // @@protoc_insertion_point(field_set:reporting.FlushPriorityRequest.priority)
}

// -------------------------------------------------------------------

// FlushPriorityResponse

// optional .reporting.StatusProto status = 1;
inline bool FlushPriorityResponse::_internal_has_status() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || status_ != nullptr);
  return value;
}
inline bool FlushPriorityResponse::has_status() const {
  return _internal_has_status();
}
inline const ::reporting::StatusProto& FlushPriorityResponse::_internal_status() const {
  const ::reporting::StatusProto* p = status_;
  return p != nullptr ? *p : reinterpret_cast<const ::reporting::StatusProto&>(
      ::reporting::_StatusProto_default_instance_);
}
inline const ::reporting::StatusProto& FlushPriorityResponse::status() const {
  // @@protoc_insertion_point(field_get:reporting.FlushPriorityResponse.status)
  return _internal_status();
}
inline void FlushPriorityResponse::unsafe_arena_set_allocated_status(
    ::reporting::StatusProto* status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status_);
  }
  status_ = status;
  if (status) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:reporting.FlushPriorityResponse.status)
}
inline ::reporting::StatusProto* FlushPriorityResponse::release_status() {
  _has_bits_[0] &= ~0x00000001u;
  ::reporting::StatusProto* temp = status_;
  status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::reporting::StatusProto* FlushPriorityResponse::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:reporting.FlushPriorityResponse.status)
  _has_bits_[0] &= ~0x00000001u;
  ::reporting::StatusProto* temp = status_;
  status_ = nullptr;
  return temp;
}
inline ::reporting::StatusProto* FlushPriorityResponse::_internal_mutable_status() {
  _has_bits_[0] |= 0x00000001u;
  if (status_ == nullptr) {
    auto* p = CreateMaybeMessage<::reporting::StatusProto>(GetArenaForAllocation());
    status_ = p;
  }
  return status_;
}
inline ::reporting::StatusProto* FlushPriorityResponse::mutable_status() {
  ::reporting::StatusProto* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:reporting.FlushPriorityResponse.status)
  return _msg;
}
inline void FlushPriorityResponse::set_allocated_status(::reporting::StatusProto* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(status_);
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status));
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  status_ = status;
  // @@protoc_insertion_point(field_set_allocated:reporting.FlushPriorityResponse.status)
}

// -------------------------------------------------------------------

// UploadEncryptedRecordRequest

// repeated .reporting.EncryptedRecord encrypted_record = 1;
inline int UploadEncryptedRecordRequest::_internal_encrypted_record_size() const {
  return encrypted_record_.size();
}
inline int UploadEncryptedRecordRequest::encrypted_record_size() const {
  return _internal_encrypted_record_size();
}
inline ::reporting::EncryptedRecord* UploadEncryptedRecordRequest::mutable_encrypted_record(int index) {
  // @@protoc_insertion_point(field_mutable:reporting.UploadEncryptedRecordRequest.encrypted_record)
  return encrypted_record_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::reporting::EncryptedRecord >*
UploadEncryptedRecordRequest::mutable_encrypted_record() {
  // @@protoc_insertion_point(field_mutable_list:reporting.UploadEncryptedRecordRequest.encrypted_record)
  return &encrypted_record_;
}
inline const ::reporting::EncryptedRecord& UploadEncryptedRecordRequest::_internal_encrypted_record(int index) const {
  return encrypted_record_.Get(index);
}
inline const ::reporting::EncryptedRecord& UploadEncryptedRecordRequest::encrypted_record(int index) const {
  // @@protoc_insertion_point(field_get:reporting.UploadEncryptedRecordRequest.encrypted_record)
  return _internal_encrypted_record(index);
}
inline ::reporting::EncryptedRecord* UploadEncryptedRecordRequest::_internal_add_encrypted_record() {
  return encrypted_record_.Add();
}
inline ::reporting::EncryptedRecord* UploadEncryptedRecordRequest::add_encrypted_record() {
  ::reporting::EncryptedRecord* _add = _internal_add_encrypted_record();
  // @@protoc_insertion_point(field_add:reporting.UploadEncryptedRecordRequest.encrypted_record)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::reporting::EncryptedRecord >&
UploadEncryptedRecordRequest::encrypted_record() const {
  // @@protoc_insertion_point(field_list:reporting.UploadEncryptedRecordRequest.encrypted_record)
  return encrypted_record_;
}

// optional bool need_encryption_keys = 2;
inline bool UploadEncryptedRecordRequest::_internal_has_need_encryption_keys() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool UploadEncryptedRecordRequest::has_need_encryption_keys() const {
  return _internal_has_need_encryption_keys();
}
inline void UploadEncryptedRecordRequest::clear_need_encryption_keys() {
  need_encryption_keys_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool UploadEncryptedRecordRequest::_internal_need_encryption_keys() const {
  return need_encryption_keys_;
}
inline bool UploadEncryptedRecordRequest::need_encryption_keys() const {
  // @@protoc_insertion_point(field_get:reporting.UploadEncryptedRecordRequest.need_encryption_keys)
  return _internal_need_encryption_keys();
}
inline void UploadEncryptedRecordRequest::_internal_set_need_encryption_keys(bool value) {
  _has_bits_[0] |= 0x00000004u;
  need_encryption_keys_ = value;
}
inline void UploadEncryptedRecordRequest::set_need_encryption_keys(bool value) {
  _internal_set_need_encryption_keys(value);
  // @@protoc_insertion_point(field_set:reporting.UploadEncryptedRecordRequest.need_encryption_keys)
}

// optional uint64 remaining_storage_capacity = 3;
inline bool UploadEncryptedRecordRequest::_internal_has_remaining_storage_capacity() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool UploadEncryptedRecordRequest::has_remaining_storage_capacity() const {
  return _internal_has_remaining_storage_capacity();
}
inline void UploadEncryptedRecordRequest::clear_remaining_storage_capacity() {
  remaining_storage_capacity_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000001u;
}
inline uint64_t UploadEncryptedRecordRequest::_internal_remaining_storage_capacity() const {
  return remaining_storage_capacity_;
}
inline uint64_t UploadEncryptedRecordRequest::remaining_storage_capacity() const {
  // @@protoc_insertion_point(field_get:reporting.UploadEncryptedRecordRequest.remaining_storage_capacity)
  return _internal_remaining_storage_capacity();
}
inline void UploadEncryptedRecordRequest::_internal_set_remaining_storage_capacity(uint64_t value) {
  _has_bits_[0] |= 0x00000001u;
  remaining_storage_capacity_ = value;
}
inline void UploadEncryptedRecordRequest::set_remaining_storage_capacity(uint64_t value) {
  _internal_set_remaining_storage_capacity(value);
  // @@protoc_insertion_point(field_set:reporting.UploadEncryptedRecordRequest.remaining_storage_capacity)
}

// optional uint64 new_events_rate = 4;
inline bool UploadEncryptedRecordRequest::_internal_has_new_events_rate() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool UploadEncryptedRecordRequest::has_new_events_rate() const {
  return _internal_has_new_events_rate();
}
inline void UploadEncryptedRecordRequest::clear_new_events_rate() {
  new_events_rate_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000002u;
}
inline uint64_t UploadEncryptedRecordRequest::_internal_new_events_rate() const {
  return new_events_rate_;
}
inline uint64_t UploadEncryptedRecordRequest::new_events_rate() const {
  // @@protoc_insertion_point(field_get:reporting.UploadEncryptedRecordRequest.new_events_rate)
  return _internal_new_events_rate();
}
inline void UploadEncryptedRecordRequest::_internal_set_new_events_rate(uint64_t value) {
  _has_bits_[0] |= 0x00000002u;
  new_events_rate_ = value;
}
inline void UploadEncryptedRecordRequest::set_new_events_rate(uint64_t value) {
  _internal_set_new_events_rate(value);
  // @@protoc_insertion_point(field_set:reporting.UploadEncryptedRecordRequest.new_events_rate)
}

// -------------------------------------------------------------------

// UploadEncryptedRecordResponse

// optional .reporting.StatusProto status = 1;
inline bool UploadEncryptedRecordResponse::_internal_has_status() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || status_ != nullptr);
  return value;
}
inline bool UploadEncryptedRecordResponse::has_status() const {
  return _internal_has_status();
}
inline const ::reporting::StatusProto& UploadEncryptedRecordResponse::_internal_status() const {
  const ::reporting::StatusProto* p = status_;
  return p != nullptr ? *p : reinterpret_cast<const ::reporting::StatusProto&>(
      ::reporting::_StatusProto_default_instance_);
}
inline const ::reporting::StatusProto& UploadEncryptedRecordResponse::status() const {
  // @@protoc_insertion_point(field_get:reporting.UploadEncryptedRecordResponse.status)
  return _internal_status();
}
inline void UploadEncryptedRecordResponse::unsafe_arena_set_allocated_status(
    ::reporting::StatusProto* status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status_);
  }
  status_ = status;
  if (status) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:reporting.UploadEncryptedRecordResponse.status)
}
inline ::reporting::StatusProto* UploadEncryptedRecordResponse::release_status() {
  _has_bits_[0] &= ~0x00000001u;
  ::reporting::StatusProto* temp = status_;
  status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::reporting::StatusProto* UploadEncryptedRecordResponse::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:reporting.UploadEncryptedRecordResponse.status)
  _has_bits_[0] &= ~0x00000001u;
  ::reporting::StatusProto* temp = status_;
  status_ = nullptr;
  return temp;
}
inline ::reporting::StatusProto* UploadEncryptedRecordResponse::_internal_mutable_status() {
  _has_bits_[0] |= 0x00000001u;
  if (status_ == nullptr) {
    auto* p = CreateMaybeMessage<::reporting::StatusProto>(GetArenaForAllocation());
    status_ = p;
  }
  return status_;
}
inline ::reporting::StatusProto* UploadEncryptedRecordResponse::mutable_status() {
  ::reporting::StatusProto* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:reporting.UploadEncryptedRecordResponse.status)
  return _msg;
}
inline void UploadEncryptedRecordResponse::set_allocated_status(::reporting::StatusProto* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(status_);
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status));
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  status_ = status;
  // @@protoc_insertion_point(field_set_allocated:reporting.UploadEncryptedRecordResponse.status)
}

// -------------------------------------------------------------------

// ConfirmRecordUploadRequest

// optional .reporting.SequenceInformation sequence_information = 1;
inline bool ConfirmRecordUploadRequest::_internal_has_sequence_information() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || sequence_information_ != nullptr);
  return value;
}
inline bool ConfirmRecordUploadRequest::has_sequence_information() const {
  return _internal_has_sequence_information();
}
inline const ::reporting::SequenceInformation& ConfirmRecordUploadRequest::_internal_sequence_information() const {
  const ::reporting::SequenceInformation* p = sequence_information_;
  return p != nullptr ? *p : reinterpret_cast<const ::reporting::SequenceInformation&>(
      ::reporting::_SequenceInformation_default_instance_);
}
inline const ::reporting::SequenceInformation& ConfirmRecordUploadRequest::sequence_information() const {
  // @@protoc_insertion_point(field_get:reporting.ConfirmRecordUploadRequest.sequence_information)
  return _internal_sequence_information();
}
inline void ConfirmRecordUploadRequest::unsafe_arena_set_allocated_sequence_information(
    ::reporting::SequenceInformation* sequence_information) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(sequence_information_);
  }
  sequence_information_ = sequence_information;
  if (sequence_information) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:reporting.ConfirmRecordUploadRequest.sequence_information)
}
inline ::reporting::SequenceInformation* ConfirmRecordUploadRequest::release_sequence_information() {
  _has_bits_[0] &= ~0x00000001u;
  ::reporting::SequenceInformation* temp = sequence_information_;
  sequence_information_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::reporting::SequenceInformation* ConfirmRecordUploadRequest::unsafe_arena_release_sequence_information() {
  // @@protoc_insertion_point(field_release:reporting.ConfirmRecordUploadRequest.sequence_information)
  _has_bits_[0] &= ~0x00000001u;
  ::reporting::SequenceInformation* temp = sequence_information_;
  sequence_information_ = nullptr;
  return temp;
}
inline ::reporting::SequenceInformation* ConfirmRecordUploadRequest::_internal_mutable_sequence_information() {
  _has_bits_[0] |= 0x00000001u;
  if (sequence_information_ == nullptr) {
    auto* p = CreateMaybeMessage<::reporting::SequenceInformation>(GetArenaForAllocation());
    sequence_information_ = p;
  }
  return sequence_information_;
}
inline ::reporting::SequenceInformation* ConfirmRecordUploadRequest::mutable_sequence_information() {
  ::reporting::SequenceInformation* _msg = _internal_mutable_sequence_information();
  // @@protoc_insertion_point(field_mutable:reporting.ConfirmRecordUploadRequest.sequence_information)
  return _msg;
}
inline void ConfirmRecordUploadRequest::set_allocated_sequence_information(::reporting::SequenceInformation* sequence_information) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(sequence_information_);
  }
  if (sequence_information) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(sequence_information));
    if (message_arena != submessage_arena) {
      sequence_information = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sequence_information, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  sequence_information_ = sequence_information;
  // @@protoc_insertion_point(field_set_allocated:reporting.ConfirmRecordUploadRequest.sequence_information)
}

// optional bool force_confirm = 2;
inline bool ConfirmRecordUploadRequest::_internal_has_force_confirm() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ConfirmRecordUploadRequest::has_force_confirm() const {
  return _internal_has_force_confirm();
}
inline void ConfirmRecordUploadRequest::clear_force_confirm() {
  force_confirm_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool ConfirmRecordUploadRequest::_internal_force_confirm() const {
  return force_confirm_;
}
inline bool ConfirmRecordUploadRequest::force_confirm() const {
  // @@protoc_insertion_point(field_get:reporting.ConfirmRecordUploadRequest.force_confirm)
  return _internal_force_confirm();
}
inline void ConfirmRecordUploadRequest::_internal_set_force_confirm(bool value) {
  _has_bits_[0] |= 0x00000002u;
  force_confirm_ = value;
}
inline void ConfirmRecordUploadRequest::set_force_confirm(bool value) {
  _internal_set_force_confirm(value);
  // @@protoc_insertion_point(field_set:reporting.ConfirmRecordUploadRequest.force_confirm)
}

// -------------------------------------------------------------------

// ConfirmRecordUploadResponse

// optional .reporting.StatusProto status = 1;
inline bool ConfirmRecordUploadResponse::_internal_has_status() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || status_ != nullptr);
  return value;
}
inline bool ConfirmRecordUploadResponse::has_status() const {
  return _internal_has_status();
}
inline const ::reporting::StatusProto& ConfirmRecordUploadResponse::_internal_status() const {
  const ::reporting::StatusProto* p = status_;
  return p != nullptr ? *p : reinterpret_cast<const ::reporting::StatusProto&>(
      ::reporting::_StatusProto_default_instance_);
}
inline const ::reporting::StatusProto& ConfirmRecordUploadResponse::status() const {
  // @@protoc_insertion_point(field_get:reporting.ConfirmRecordUploadResponse.status)
  return _internal_status();
}
inline void ConfirmRecordUploadResponse::unsafe_arena_set_allocated_status(
    ::reporting::StatusProto* status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status_);
  }
  status_ = status;
  if (status) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:reporting.ConfirmRecordUploadResponse.status)
}
inline ::reporting::StatusProto* ConfirmRecordUploadResponse::release_status() {
  _has_bits_[0] &= ~0x00000001u;
  ::reporting::StatusProto* temp = status_;
  status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::reporting::StatusProto* ConfirmRecordUploadResponse::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:reporting.ConfirmRecordUploadResponse.status)
  _has_bits_[0] &= ~0x00000001u;
  ::reporting::StatusProto* temp = status_;
  status_ = nullptr;
  return temp;
}
inline ::reporting::StatusProto* ConfirmRecordUploadResponse::_internal_mutable_status() {
  _has_bits_[0] |= 0x00000001u;
  if (status_ == nullptr) {
    auto* p = CreateMaybeMessage<::reporting::StatusProto>(GetArenaForAllocation());
    status_ = p;
  }
  return status_;
}
inline ::reporting::StatusProto* ConfirmRecordUploadResponse::mutable_status() {
  ::reporting::StatusProto* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:reporting.ConfirmRecordUploadResponse.status)
  return _msg;
}
inline void ConfirmRecordUploadResponse::set_allocated_status(::reporting::StatusProto* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(status_);
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status));
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  status_ = status;
  // @@protoc_insertion_point(field_set_allocated:reporting.ConfirmRecordUploadResponse.status)
}

// -------------------------------------------------------------------

// UpdateEncryptionKeyRequest

// optional .reporting.SignedEncryptionInfo signed_encryption_info = 1;
inline bool UpdateEncryptionKeyRequest::_internal_has_signed_encryption_info() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || signed_encryption_info_ != nullptr);
  return value;
}
inline bool UpdateEncryptionKeyRequest::has_signed_encryption_info() const {
  return _internal_has_signed_encryption_info();
}
inline const ::reporting::SignedEncryptionInfo& UpdateEncryptionKeyRequest::_internal_signed_encryption_info() const {
  const ::reporting::SignedEncryptionInfo* p = signed_encryption_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::reporting::SignedEncryptionInfo&>(
      ::reporting::_SignedEncryptionInfo_default_instance_);
}
inline const ::reporting::SignedEncryptionInfo& UpdateEncryptionKeyRequest::signed_encryption_info() const {
  // @@protoc_insertion_point(field_get:reporting.UpdateEncryptionKeyRequest.signed_encryption_info)
  return _internal_signed_encryption_info();
}
inline void UpdateEncryptionKeyRequest::unsafe_arena_set_allocated_signed_encryption_info(
    ::reporting::SignedEncryptionInfo* signed_encryption_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(signed_encryption_info_);
  }
  signed_encryption_info_ = signed_encryption_info;
  if (signed_encryption_info) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:reporting.UpdateEncryptionKeyRequest.signed_encryption_info)
}
inline ::reporting::SignedEncryptionInfo* UpdateEncryptionKeyRequest::release_signed_encryption_info() {
  _has_bits_[0] &= ~0x00000001u;
  ::reporting::SignedEncryptionInfo* temp = signed_encryption_info_;
  signed_encryption_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::reporting::SignedEncryptionInfo* UpdateEncryptionKeyRequest::unsafe_arena_release_signed_encryption_info() {
  // @@protoc_insertion_point(field_release:reporting.UpdateEncryptionKeyRequest.signed_encryption_info)
  _has_bits_[0] &= ~0x00000001u;
  ::reporting::SignedEncryptionInfo* temp = signed_encryption_info_;
  signed_encryption_info_ = nullptr;
  return temp;
}
inline ::reporting::SignedEncryptionInfo* UpdateEncryptionKeyRequest::_internal_mutable_signed_encryption_info() {
  _has_bits_[0] |= 0x00000001u;
  if (signed_encryption_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::reporting::SignedEncryptionInfo>(GetArenaForAllocation());
    signed_encryption_info_ = p;
  }
  return signed_encryption_info_;
}
inline ::reporting::SignedEncryptionInfo* UpdateEncryptionKeyRequest::mutable_signed_encryption_info() {
  ::reporting::SignedEncryptionInfo* _msg = _internal_mutable_signed_encryption_info();
  // @@protoc_insertion_point(field_mutable:reporting.UpdateEncryptionKeyRequest.signed_encryption_info)
  return _msg;
}
inline void UpdateEncryptionKeyRequest::set_allocated_signed_encryption_info(::reporting::SignedEncryptionInfo* signed_encryption_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(signed_encryption_info_);
  }
  if (signed_encryption_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(signed_encryption_info));
    if (message_arena != submessage_arena) {
      signed_encryption_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, signed_encryption_info, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  signed_encryption_info_ = signed_encryption_info;
  // @@protoc_insertion_point(field_set_allocated:reporting.UpdateEncryptionKeyRequest.signed_encryption_info)
}

// -------------------------------------------------------------------

// UpdateEncryptionKeyResponse

// optional .reporting.StatusProto status = 1;
inline bool UpdateEncryptionKeyResponse::_internal_has_status() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || status_ != nullptr);
  return value;
}
inline bool UpdateEncryptionKeyResponse::has_status() const {
  return _internal_has_status();
}
inline const ::reporting::StatusProto& UpdateEncryptionKeyResponse::_internal_status() const {
  const ::reporting::StatusProto* p = status_;
  return p != nullptr ? *p : reinterpret_cast<const ::reporting::StatusProto&>(
      ::reporting::_StatusProto_default_instance_);
}
inline const ::reporting::StatusProto& UpdateEncryptionKeyResponse::status() const {
  // @@protoc_insertion_point(field_get:reporting.UpdateEncryptionKeyResponse.status)
  return _internal_status();
}
inline void UpdateEncryptionKeyResponse::unsafe_arena_set_allocated_status(
    ::reporting::StatusProto* status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status_);
  }
  status_ = status;
  if (status) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:reporting.UpdateEncryptionKeyResponse.status)
}
inline ::reporting::StatusProto* UpdateEncryptionKeyResponse::release_status() {
  _has_bits_[0] &= ~0x00000001u;
  ::reporting::StatusProto* temp = status_;
  status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::reporting::StatusProto* UpdateEncryptionKeyResponse::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:reporting.UpdateEncryptionKeyResponse.status)
  _has_bits_[0] &= ~0x00000001u;
  ::reporting::StatusProto* temp = status_;
  status_ = nullptr;
  return temp;
}
inline ::reporting::StatusProto* UpdateEncryptionKeyResponse::_internal_mutable_status() {
  _has_bits_[0] |= 0x00000001u;
  if (status_ == nullptr) {
    auto* p = CreateMaybeMessage<::reporting::StatusProto>(GetArenaForAllocation());
    status_ = p;
  }
  return status_;
}
inline ::reporting::StatusProto* UpdateEncryptionKeyResponse::mutable_status() {
  ::reporting::StatusProto* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:reporting.UpdateEncryptionKeyResponse.status)
  return _msg;
}
inline void UpdateEncryptionKeyResponse::set_allocated_status(::reporting::StatusProto* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(status_);
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status));
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  status_ = status;
  // @@protoc_insertion_point(field_set_allocated:reporting.UpdateEncryptionKeyResponse.status)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace reporting

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_components_2freporting_2fproto_2fsynced_2finterface_2eproto
