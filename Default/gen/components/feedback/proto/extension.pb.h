// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: extension.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_extension_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_extension_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3020000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3020000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include "common.pb.h"
#include "chrome.pb.h"
#include "dom.pb.h"
#include "math.pb.h"
#include "web.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_extension_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_extension_2eproto {
  static const uint32_t offsets[];
};
namespace userfeedback {
class ExtensionErrors;
struct ExtensionErrorsDefaultTypeInternal;
extern ExtensionErrorsDefaultTypeInternal _ExtensionErrors_default_instance_;
class ExtensionPageRequestParams;
struct ExtensionPageRequestParamsDefaultTypeInternal;
extern ExtensionPageRequestParamsDefaultTypeInternal _ExtensionPageRequestParams_default_instance_;
class ExtensionSubmit;
struct ExtensionSubmitDefaultTypeInternal;
extern ExtensionSubmitDefaultTypeInternal _ExtensionSubmit_default_instance_;
class PostedScreenshot;
struct PostedScreenshotDefaultTypeInternal;
extern PostedScreenshotDefaultTypeInternal _PostedScreenshot_default_instance_;
class SuggestQuery;
struct SuggestQueryDefaultTypeInternal;
extern SuggestQueryDefaultTypeInternal _SuggestQuery_default_instance_;
}  // namespace userfeedback
PROTOBUF_NAMESPACE_OPEN
template<> ::userfeedback::ExtensionErrors* Arena::CreateMaybeMessage<::userfeedback::ExtensionErrors>(Arena*);
template<> ::userfeedback::ExtensionPageRequestParams* Arena::CreateMaybeMessage<::userfeedback::ExtensionPageRequestParams>(Arena*);
template<> ::userfeedback::ExtensionSubmit* Arena::CreateMaybeMessage<::userfeedback::ExtensionSubmit>(Arena*);
template<> ::userfeedback::PostedScreenshot* Arena::CreateMaybeMessage<::userfeedback::PostedScreenshot>(Arena*);
template<> ::userfeedback::SuggestQuery* Arena::CreateMaybeMessage<::userfeedback::SuggestQuery>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace userfeedback {

// ===================================================================

class ExtensionPageRequestParams final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:userfeedback.ExtensionPageRequestParams) */ {
 public:
  inline ExtensionPageRequestParams() : ExtensionPageRequestParams(nullptr) {}
  ~ExtensionPageRequestParams() override;
  explicit PROTOBUF_CONSTEXPR ExtensionPageRequestParams(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ExtensionPageRequestParams(const ExtensionPageRequestParams& from);
  ExtensionPageRequestParams(ExtensionPageRequestParams&& from) noexcept
    : ExtensionPageRequestParams() {
    *this = ::std::move(from);
  }

  inline ExtensionPageRequestParams& operator=(const ExtensionPageRequestParams& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExtensionPageRequestParams& operator=(ExtensionPageRequestParams&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ExtensionPageRequestParams& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExtensionPageRequestParams* internal_default_instance() {
    return reinterpret_cast<const ExtensionPageRequestParams*>(
               &_ExtensionPageRequestParams_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(ExtensionPageRequestParams& a, ExtensionPageRequestParams& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(ExtensionPageRequestParams* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExtensionPageRequestParams* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExtensionPageRequestParams* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ExtensionPageRequestParams>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ExtensionPageRequestParams& from);
  void MergeFrom(const ExtensionPageRequestParams& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ExtensionPageRequestParams* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "userfeedback.ExtensionPageRequestParams";
  }
  protected:
  explicit ExtensionPageRequestParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUrlFieldNumber = 2,
    kExtensionDetailsFieldNumber = 1,
  };
  // required string url = 2;
  bool has_url() const;
  private:
  bool _internal_has_url() const;
  public:
  void clear_url();
  const std::string& url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_url();
  PROTOBUF_NODISCARD std::string* release_url();
  void set_allocated_url(std::string* url);
  private:
  const std::string& _internal_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_url(const std::string& value);
  std::string* _internal_mutable_url();
  public:

  // required .userfeedback.ExtensionDetails extension_details = 1;
  bool has_extension_details() const;
  private:
  bool _internal_has_extension_details() const;
  public:
  void clear_extension_details();
  const ::userfeedback::ExtensionDetails& extension_details() const;
  PROTOBUF_NODISCARD ::userfeedback::ExtensionDetails* release_extension_details();
  ::userfeedback::ExtensionDetails* mutable_extension_details();
  void set_allocated_extension_details(::userfeedback::ExtensionDetails* extension_details);
  private:
  const ::userfeedback::ExtensionDetails& _internal_extension_details() const;
  ::userfeedback::ExtensionDetails* _internal_mutable_extension_details();
  public:
  void unsafe_arena_set_allocated_extension_details(
      ::userfeedback::ExtensionDetails* extension_details);
  ::userfeedback::ExtensionDetails* unsafe_arena_release_extension_details();

  // @@protoc_insertion_point(class_scope:userfeedback.ExtensionPageRequestParams)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr url_;
  ::userfeedback::ExtensionDetails* extension_details_;
  friend struct ::TableStruct_extension_2eproto;
};
// -------------------------------------------------------------------

class PostedScreenshot final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:userfeedback.PostedScreenshot) */ {
 public:
  inline PostedScreenshot() : PostedScreenshot(nullptr) {}
  ~PostedScreenshot() override;
  explicit PROTOBUF_CONSTEXPR PostedScreenshot(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PostedScreenshot(const PostedScreenshot& from);
  PostedScreenshot(PostedScreenshot&& from) noexcept
    : PostedScreenshot() {
    *this = ::std::move(from);
  }

  inline PostedScreenshot& operator=(const PostedScreenshot& from) {
    CopyFrom(from);
    return *this;
  }
  inline PostedScreenshot& operator=(PostedScreenshot&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const PostedScreenshot& default_instance() {
    return *internal_default_instance();
  }
  static inline const PostedScreenshot* internal_default_instance() {
    return reinterpret_cast<const PostedScreenshot*>(
               &_PostedScreenshot_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(PostedScreenshot& a, PostedScreenshot& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(PostedScreenshot* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PostedScreenshot* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PostedScreenshot* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PostedScreenshot>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const PostedScreenshot& from);
  void MergeFrom(const PostedScreenshot& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PostedScreenshot* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "userfeedback.PostedScreenshot";
  }
  protected:
  explicit PostedScreenshot(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMimeTypeFieldNumber = 1,
    kBase64ContentFieldNumber = 3,
    kBinaryContentFieldNumber = 4,
    kDimensionsFieldNumber = 2,
  };
  // required string mime_type = 1;
  bool has_mime_type() const;
  private:
  bool _internal_has_mime_type() const;
  public:
  void clear_mime_type();
  const std::string& mime_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mime_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mime_type();
  PROTOBUF_NODISCARD std::string* release_mime_type();
  void set_allocated_mime_type(std::string* mime_type);
  private:
  const std::string& _internal_mime_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mime_type(const std::string& value);
  std::string* _internal_mutable_mime_type();
  public:

  // optional string base64_content = 3;
  bool has_base64_content() const;
  private:
  bool _internal_has_base64_content() const;
  public:
  void clear_base64_content();
  const std::string& base64_content() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_base64_content(ArgT0&& arg0, ArgT... args);
  std::string* mutable_base64_content();
  PROTOBUF_NODISCARD std::string* release_base64_content();
  void set_allocated_base64_content(std::string* base64_content);
  private:
  const std::string& _internal_base64_content() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_base64_content(const std::string& value);
  std::string* _internal_mutable_base64_content();
  public:

  // optional bytes binary_content = 4;
  bool has_binary_content() const;
  private:
  bool _internal_has_binary_content() const;
  public:
  void clear_binary_content();
  const std::string& binary_content() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_binary_content(ArgT0&& arg0, ArgT... args);
  std::string* mutable_binary_content();
  PROTOBUF_NODISCARD std::string* release_binary_content();
  void set_allocated_binary_content(std::string* binary_content);
  private:
  const std::string& _internal_binary_content() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_binary_content(const std::string& value);
  std::string* _internal_mutable_binary_content();
  public:

  // required .userfeedback.Dimensions dimensions = 2;
  bool has_dimensions() const;
  private:
  bool _internal_has_dimensions() const;
  public:
  void clear_dimensions();
  const ::userfeedback::Dimensions& dimensions() const;
  PROTOBUF_NODISCARD ::userfeedback::Dimensions* release_dimensions();
  ::userfeedback::Dimensions* mutable_dimensions();
  void set_allocated_dimensions(::userfeedback::Dimensions* dimensions);
  private:
  const ::userfeedback::Dimensions& _internal_dimensions() const;
  ::userfeedback::Dimensions* _internal_mutable_dimensions();
  public:
  void unsafe_arena_set_allocated_dimensions(
      ::userfeedback::Dimensions* dimensions);
  ::userfeedback::Dimensions* unsafe_arena_release_dimensions();

  // @@protoc_insertion_point(class_scope:userfeedback.PostedScreenshot)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mime_type_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr base64_content_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr binary_content_;
  ::userfeedback::Dimensions* dimensions_;
  friend struct ::TableStruct_extension_2eproto;
};
// -------------------------------------------------------------------

class ExtensionErrors final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:userfeedback.ExtensionErrors) */ {
 public:
  inline ExtensionErrors() : ExtensionErrors(nullptr) {}
  ~ExtensionErrors() override;
  explicit PROTOBUF_CONSTEXPR ExtensionErrors(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ExtensionErrors(const ExtensionErrors& from);
  ExtensionErrors(ExtensionErrors&& from) noexcept
    : ExtensionErrors() {
    *this = ::std::move(from);
  }

  inline ExtensionErrors& operator=(const ExtensionErrors& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExtensionErrors& operator=(ExtensionErrors&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ExtensionErrors& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExtensionErrors* internal_default_instance() {
    return reinterpret_cast<const ExtensionErrors*>(
               &_ExtensionErrors_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ExtensionErrors& a, ExtensionErrors& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(ExtensionErrors* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExtensionErrors* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExtensionErrors* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ExtensionErrors>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ExtensionErrors& from);
  void MergeFrom(const ExtensionErrors& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ExtensionErrors* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "userfeedback.ExtensionErrors";
  }
  protected:
  explicit ExtensionErrors(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorsFieldNumber = 2,
    kNumberOfAttemptsFieldNumber = 1,
  };
  // required string errors = 2;
  bool has_errors() const;
  private:
  bool _internal_has_errors() const;
  public:
  void clear_errors();
  const std::string& errors() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_errors(ArgT0&& arg0, ArgT... args);
  std::string* mutable_errors();
  PROTOBUF_NODISCARD std::string* release_errors();
  void set_allocated_errors(std::string* errors);
  private:
  const std::string& _internal_errors() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_errors(const std::string& value);
  std::string* _internal_mutable_errors();
  public:

  // required int32 number_of_attempts = 1;
  bool has_number_of_attempts() const;
  private:
  bool _internal_has_number_of_attempts() const;
  public:
  void clear_number_of_attempts();
  int32_t number_of_attempts() const;
  void set_number_of_attempts(int32_t value);
  private:
  int32_t _internal_number_of_attempts() const;
  void _internal_set_number_of_attempts(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:userfeedback.ExtensionErrors)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr errors_;
  int32_t number_of_attempts_;
  friend struct ::TableStruct_extension_2eproto;
};
// -------------------------------------------------------------------

class ExtensionSubmit final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:userfeedback.ExtensionSubmit) */ {
 public:
  inline ExtensionSubmit() : ExtensionSubmit(nullptr) {}
  ~ExtensionSubmit() override;
  explicit PROTOBUF_CONSTEXPR ExtensionSubmit(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ExtensionSubmit(const ExtensionSubmit& from);
  ExtensionSubmit(ExtensionSubmit&& from) noexcept
    : ExtensionSubmit() {
    *this = ::std::move(from);
  }

  inline ExtensionSubmit& operator=(const ExtensionSubmit& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExtensionSubmit& operator=(ExtensionSubmit&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ExtensionSubmit& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExtensionSubmit* internal_default_instance() {
    return reinterpret_cast<const ExtensionSubmit*>(
               &_ExtensionSubmit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ExtensionSubmit& a, ExtensionSubmit& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(ExtensionSubmit* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExtensionSubmit* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExtensionSubmit* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ExtensionSubmit>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ExtensionSubmit& from);
  void MergeFrom(const ExtensionSubmit& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ExtensionSubmit* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "userfeedback.ExtensionSubmit";
  }
  protected:
  explicit ExtensionSubmit(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProductSpecificBinaryDataFieldNumber = 15,
    kCategoryTagFieldNumber = 16,
    kBucketFieldNumber = 18,
    kCommonDataFieldNumber = 1,
    kWebDataFieldNumber = 2,
    kScreenshotFieldNumber = 4,
    kChromeDataFieldNumber = 14,
    kTypeIdFieldNumber = 3,
    kProductIdFieldNumber = 17,
  };
  // repeated .userfeedback.ProductSpecificBinaryData product_specific_binary_data = 15;
  int product_specific_binary_data_size() const;
  private:
  int _internal_product_specific_binary_data_size() const;
  public:
  void clear_product_specific_binary_data();
  ::userfeedback::ProductSpecificBinaryData* mutable_product_specific_binary_data(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::userfeedback::ProductSpecificBinaryData >*
      mutable_product_specific_binary_data();
  private:
  const ::userfeedback::ProductSpecificBinaryData& _internal_product_specific_binary_data(int index) const;
  ::userfeedback::ProductSpecificBinaryData* _internal_add_product_specific_binary_data();
  public:
  const ::userfeedback::ProductSpecificBinaryData& product_specific_binary_data(int index) const;
  ::userfeedback::ProductSpecificBinaryData* add_product_specific_binary_data();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::userfeedback::ProductSpecificBinaryData >&
      product_specific_binary_data() const;

  // optional string category_tag = 16;
  bool has_category_tag() const;
  private:
  bool _internal_has_category_tag() const;
  public:
  void clear_category_tag();
  const std::string& category_tag() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_category_tag(ArgT0&& arg0, ArgT... args);
  std::string* mutable_category_tag();
  PROTOBUF_NODISCARD std::string* release_category_tag();
  void set_allocated_category_tag(std::string* category_tag);
  private:
  const std::string& _internal_category_tag() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_category_tag(const std::string& value);
  std::string* _internal_mutable_category_tag();
  public:

  // optional string bucket = 18;
  bool has_bucket() const;
  private:
  bool _internal_has_bucket() const;
  public:
  void clear_bucket();
  const std::string& bucket() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_bucket(ArgT0&& arg0, ArgT... args);
  std::string* mutable_bucket();
  PROTOBUF_NODISCARD std::string* release_bucket();
  void set_allocated_bucket(std::string* bucket);
  private:
  const std::string& _internal_bucket() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_bucket(const std::string& value);
  std::string* _internal_mutable_bucket();
  public:

  // required .userfeedback.CommonData common_data = 1;
  bool has_common_data() const;
  private:
  bool _internal_has_common_data() const;
  public:
  void clear_common_data();
  const ::userfeedback::CommonData& common_data() const;
  PROTOBUF_NODISCARD ::userfeedback::CommonData* release_common_data();
  ::userfeedback::CommonData* mutable_common_data();
  void set_allocated_common_data(::userfeedback::CommonData* common_data);
  private:
  const ::userfeedback::CommonData& _internal_common_data() const;
  ::userfeedback::CommonData* _internal_mutable_common_data();
  public:
  void unsafe_arena_set_allocated_common_data(
      ::userfeedback::CommonData* common_data);
  ::userfeedback::CommonData* unsafe_arena_release_common_data();

  // required .userfeedback.WebData web_data = 2;
  bool has_web_data() const;
  private:
  bool _internal_has_web_data() const;
  public:
  void clear_web_data();
  const ::userfeedback::WebData& web_data() const;
  PROTOBUF_NODISCARD ::userfeedback::WebData* release_web_data();
  ::userfeedback::WebData* mutable_web_data();
  void set_allocated_web_data(::userfeedback::WebData* web_data);
  private:
  const ::userfeedback::WebData& _internal_web_data() const;
  ::userfeedback::WebData* _internal_mutable_web_data();
  public:
  void unsafe_arena_set_allocated_web_data(
      ::userfeedback::WebData* web_data);
  ::userfeedback::WebData* unsafe_arena_release_web_data();

  // optional .userfeedback.PostedScreenshot screenshot = 4;
  bool has_screenshot() const;
  private:
  bool _internal_has_screenshot() const;
  public:
  void clear_screenshot();
  const ::userfeedback::PostedScreenshot& screenshot() const;
  PROTOBUF_NODISCARD ::userfeedback::PostedScreenshot* release_screenshot();
  ::userfeedback::PostedScreenshot* mutable_screenshot();
  void set_allocated_screenshot(::userfeedback::PostedScreenshot* screenshot);
  private:
  const ::userfeedback::PostedScreenshot& _internal_screenshot() const;
  ::userfeedback::PostedScreenshot* _internal_mutable_screenshot();
  public:
  void unsafe_arena_set_allocated_screenshot(
      ::userfeedback::PostedScreenshot* screenshot);
  ::userfeedback::PostedScreenshot* unsafe_arena_release_screenshot();

  // optional .userfeedback.ChromeData chrome_data = 14;
  bool has_chrome_data() const;
  private:
  bool _internal_has_chrome_data() const;
  public:
  void clear_chrome_data();
  const ::userfeedback::ChromeData& chrome_data() const;
  PROTOBUF_NODISCARD ::userfeedback::ChromeData* release_chrome_data();
  ::userfeedback::ChromeData* mutable_chrome_data();
  void set_allocated_chrome_data(::userfeedback::ChromeData* chrome_data);
  private:
  const ::userfeedback::ChromeData& _internal_chrome_data() const;
  ::userfeedback::ChromeData* _internal_mutable_chrome_data();
  public:
  void unsafe_arena_set_allocated_chrome_data(
      ::userfeedback::ChromeData* chrome_data);
  ::userfeedback::ChromeData* unsafe_arena_release_chrome_data();

  // required int32 type_id = 3;
  bool has_type_id() const;
  private:
  bool _internal_has_type_id() const;
  public:
  void clear_type_id();
  int32_t type_id() const;
  void set_type_id(int32_t value);
  private:
  int32_t _internal_type_id() const;
  void _internal_set_type_id(int32_t value);
  public:

  // optional int32 product_id = 17;
  bool has_product_id() const;
  private:
  bool _internal_has_product_id() const;
  public:
  void clear_product_id();
  int32_t product_id() const;
  void set_product_id(int32_t value);
  private:
  int32_t _internal_product_id() const;
  void _internal_set_product_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:userfeedback.ExtensionSubmit)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::userfeedback::ProductSpecificBinaryData > product_specific_binary_data_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr category_tag_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr bucket_;
  ::userfeedback::CommonData* common_data_;
  ::userfeedback::WebData* web_data_;
  ::userfeedback::PostedScreenshot* screenshot_;
  ::userfeedback::ChromeData* chrome_data_;
  int32_t type_id_;
  int32_t product_id_;
  friend struct ::TableStruct_extension_2eproto;
};
// -------------------------------------------------------------------

class SuggestQuery final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:userfeedback.SuggestQuery) */ {
 public:
  inline SuggestQuery() : SuggestQuery(nullptr) {}
  ~SuggestQuery() override;
  explicit PROTOBUF_CONSTEXPR SuggestQuery(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SuggestQuery(const SuggestQuery& from);
  SuggestQuery(SuggestQuery&& from) noexcept
    : SuggestQuery() {
    *this = ::std::move(from);
  }

  inline SuggestQuery& operator=(const SuggestQuery& from) {
    CopyFrom(from);
    return *this;
  }
  inline SuggestQuery& operator=(SuggestQuery&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const SuggestQuery& default_instance() {
    return *internal_default_instance();
  }
  static inline const SuggestQuery* internal_default_instance() {
    return reinterpret_cast<const SuggestQuery*>(
               &_SuggestQuery_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(SuggestQuery& a, SuggestQuery& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(SuggestQuery* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SuggestQuery* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SuggestQuery* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SuggestQuery>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const SuggestQuery& from);
  void MergeFrom(const SuggestQuery& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SuggestQuery* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "userfeedback.SuggestQuery";
  }
  protected:
  explicit SuggestQuery(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCommonDataFieldNumber = 1,
    kWebDataFieldNumber = 2,
    kHtmlDocumentStructureFieldNumber = 4,
    kChromeDataFieldNumber = 5,
    kTypeIdFieldNumber = 3,
  };
  // required .userfeedback.CommonData common_data = 1;
  bool has_common_data() const;
  private:
  bool _internal_has_common_data() const;
  public:
  void clear_common_data();
  const ::userfeedback::CommonData& common_data() const;
  PROTOBUF_NODISCARD ::userfeedback::CommonData* release_common_data();
  ::userfeedback::CommonData* mutable_common_data();
  void set_allocated_common_data(::userfeedback::CommonData* common_data);
  private:
  const ::userfeedback::CommonData& _internal_common_data() const;
  ::userfeedback::CommonData* _internal_mutable_common_data();
  public:
  void unsafe_arena_set_allocated_common_data(
      ::userfeedback::CommonData* common_data);
  ::userfeedback::CommonData* unsafe_arena_release_common_data();

  // required .userfeedback.WebData web_data = 2;
  bool has_web_data() const;
  private:
  bool _internal_has_web_data() const;
  public:
  void clear_web_data();
  const ::userfeedback::WebData& web_data() const;
  PROTOBUF_NODISCARD ::userfeedback::WebData* release_web_data();
  ::userfeedback::WebData* mutable_web_data();
  void set_allocated_web_data(::userfeedback::WebData* web_data);
  private:
  const ::userfeedback::WebData& _internal_web_data() const;
  ::userfeedback::WebData* _internal_mutable_web_data();
  public:
  void unsafe_arena_set_allocated_web_data(
      ::userfeedback::WebData* web_data);
  ::userfeedback::WebData* unsafe_arena_release_web_data();

  // optional .userfeedback.HtmlDocument html_document_structure = 4;
  bool has_html_document_structure() const;
  private:
  bool _internal_has_html_document_structure() const;
  public:
  void clear_html_document_structure();
  const ::userfeedback::HtmlDocument& html_document_structure() const;
  PROTOBUF_NODISCARD ::userfeedback::HtmlDocument* release_html_document_structure();
  ::userfeedback::HtmlDocument* mutable_html_document_structure();
  void set_allocated_html_document_structure(::userfeedback::HtmlDocument* html_document_structure);
  private:
  const ::userfeedback::HtmlDocument& _internal_html_document_structure() const;
  ::userfeedback::HtmlDocument* _internal_mutable_html_document_structure();
  public:
  void unsafe_arena_set_allocated_html_document_structure(
      ::userfeedback::HtmlDocument* html_document_structure);
  ::userfeedback::HtmlDocument* unsafe_arena_release_html_document_structure();

  // optional .userfeedback.ChromeData chrome_data = 5;
  bool has_chrome_data() const;
  private:
  bool _internal_has_chrome_data() const;
  public:
  void clear_chrome_data();
  const ::userfeedback::ChromeData& chrome_data() const;
  PROTOBUF_NODISCARD ::userfeedback::ChromeData* release_chrome_data();
  ::userfeedback::ChromeData* mutable_chrome_data();
  void set_allocated_chrome_data(::userfeedback::ChromeData* chrome_data);
  private:
  const ::userfeedback::ChromeData& _internal_chrome_data() const;
  ::userfeedback::ChromeData* _internal_mutable_chrome_data();
  public:
  void unsafe_arena_set_allocated_chrome_data(
      ::userfeedback::ChromeData* chrome_data);
  ::userfeedback::ChromeData* unsafe_arena_release_chrome_data();

  // required int32 type_id = 3;
  bool has_type_id() const;
  private:
  bool _internal_has_type_id() const;
  public:
  void clear_type_id();
  int32_t type_id() const;
  void set_type_id(int32_t value);
  private:
  int32_t _internal_type_id() const;
  void _internal_set_type_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:userfeedback.SuggestQuery)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::userfeedback::CommonData* common_data_;
  ::userfeedback::WebData* web_data_;
  ::userfeedback::HtmlDocument* html_document_structure_;
  ::userfeedback::ChromeData* chrome_data_;
  int32_t type_id_;
  friend struct ::TableStruct_extension_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ExtensionPageRequestParams

// required .userfeedback.ExtensionDetails extension_details = 1;
inline bool ExtensionPageRequestParams::_internal_has_extension_details() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || extension_details_ != nullptr);
  return value;
}
inline bool ExtensionPageRequestParams::has_extension_details() const {
  return _internal_has_extension_details();
}
inline const ::userfeedback::ExtensionDetails& ExtensionPageRequestParams::_internal_extension_details() const {
  const ::userfeedback::ExtensionDetails* p = extension_details_;
  return p != nullptr ? *p : reinterpret_cast<const ::userfeedback::ExtensionDetails&>(
      ::userfeedback::_ExtensionDetails_default_instance_);
}
inline const ::userfeedback::ExtensionDetails& ExtensionPageRequestParams::extension_details() const {
  // @@protoc_insertion_point(field_get:userfeedback.ExtensionPageRequestParams.extension_details)
  return _internal_extension_details();
}
inline void ExtensionPageRequestParams::unsafe_arena_set_allocated_extension_details(
    ::userfeedback::ExtensionDetails* extension_details) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(extension_details_);
  }
  extension_details_ = extension_details;
  if (extension_details) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:userfeedback.ExtensionPageRequestParams.extension_details)
}
inline ::userfeedback::ExtensionDetails* ExtensionPageRequestParams::release_extension_details() {
  _has_bits_[0] &= ~0x00000002u;
  ::userfeedback::ExtensionDetails* temp = extension_details_;
  extension_details_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::userfeedback::ExtensionDetails* ExtensionPageRequestParams::unsafe_arena_release_extension_details() {
  // @@protoc_insertion_point(field_release:userfeedback.ExtensionPageRequestParams.extension_details)
  _has_bits_[0] &= ~0x00000002u;
  ::userfeedback::ExtensionDetails* temp = extension_details_;
  extension_details_ = nullptr;
  return temp;
}
inline ::userfeedback::ExtensionDetails* ExtensionPageRequestParams::_internal_mutable_extension_details() {
  _has_bits_[0] |= 0x00000002u;
  if (extension_details_ == nullptr) {
    auto* p = CreateMaybeMessage<::userfeedback::ExtensionDetails>(GetArenaForAllocation());
    extension_details_ = p;
  }
  return extension_details_;
}
inline ::userfeedback::ExtensionDetails* ExtensionPageRequestParams::mutable_extension_details() {
  ::userfeedback::ExtensionDetails* _msg = _internal_mutable_extension_details();
  // @@protoc_insertion_point(field_mutable:userfeedback.ExtensionPageRequestParams.extension_details)
  return _msg;
}
inline void ExtensionPageRequestParams::set_allocated_extension_details(::userfeedback::ExtensionDetails* extension_details) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(extension_details_);
  }
  if (extension_details) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(extension_details));
    if (message_arena != submessage_arena) {
      extension_details = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, extension_details, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  extension_details_ = extension_details;
  // @@protoc_insertion_point(field_set_allocated:userfeedback.ExtensionPageRequestParams.extension_details)
}

// required string url = 2;
inline bool ExtensionPageRequestParams::_internal_has_url() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ExtensionPageRequestParams::has_url() const {
  return _internal_has_url();
}
inline void ExtensionPageRequestParams::clear_url() {
  url_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ExtensionPageRequestParams::url() const {
  // @@protoc_insertion_point(field_get:userfeedback.ExtensionPageRequestParams.url)
  return _internal_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ExtensionPageRequestParams::set_url(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:userfeedback.ExtensionPageRequestParams.url)
}
inline std::string* ExtensionPageRequestParams::mutable_url() {
  std::string* _s = _internal_mutable_url();
  // @@protoc_insertion_point(field_mutable:userfeedback.ExtensionPageRequestParams.url)
  return _s;
}
inline const std::string& ExtensionPageRequestParams::_internal_url() const {
  return url_.Get();
}
inline void ExtensionPageRequestParams::_internal_set_url(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  url_.Set(value, GetArenaForAllocation());
}
inline std::string* ExtensionPageRequestParams::_internal_mutable_url() {
  _has_bits_[0] |= 0x00000001u;
  return url_.Mutable(GetArenaForAllocation());
}
inline std::string* ExtensionPageRequestParams::release_url() {
  // @@protoc_insertion_point(field_release:userfeedback.ExtensionPageRequestParams.url)
  if (!_internal_has_url()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = url_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (url_.IsDefault()) {
    url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ExtensionPageRequestParams::set_allocated_url(std::string* url) {
  if (url != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  url_.SetAllocated(url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (url_.IsDefault()) {
    url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:userfeedback.ExtensionPageRequestParams.url)
}

// -------------------------------------------------------------------

// PostedScreenshot

// required string mime_type = 1;
inline bool PostedScreenshot::_internal_has_mime_type() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PostedScreenshot::has_mime_type() const {
  return _internal_has_mime_type();
}
inline void PostedScreenshot::clear_mime_type() {
  mime_type_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PostedScreenshot::mime_type() const {
  // @@protoc_insertion_point(field_get:userfeedback.PostedScreenshot.mime_type)
  return _internal_mime_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PostedScreenshot::set_mime_type(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 mime_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:userfeedback.PostedScreenshot.mime_type)
}
inline std::string* PostedScreenshot::mutable_mime_type() {
  std::string* _s = _internal_mutable_mime_type();
  // @@protoc_insertion_point(field_mutable:userfeedback.PostedScreenshot.mime_type)
  return _s;
}
inline const std::string& PostedScreenshot::_internal_mime_type() const {
  return mime_type_.Get();
}
inline void PostedScreenshot::_internal_set_mime_type(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  mime_type_.Set(value, GetArenaForAllocation());
}
inline std::string* PostedScreenshot::_internal_mutable_mime_type() {
  _has_bits_[0] |= 0x00000001u;
  return mime_type_.Mutable(GetArenaForAllocation());
}
inline std::string* PostedScreenshot::release_mime_type() {
  // @@protoc_insertion_point(field_release:userfeedback.PostedScreenshot.mime_type)
  if (!_internal_has_mime_type()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = mime_type_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (mime_type_.IsDefault()) {
    mime_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PostedScreenshot::set_allocated_mime_type(std::string* mime_type) {
  if (mime_type != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  mime_type_.SetAllocated(mime_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (mime_type_.IsDefault()) {
    mime_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:userfeedback.PostedScreenshot.mime_type)
}

// required .userfeedback.Dimensions dimensions = 2;
inline bool PostedScreenshot::_internal_has_dimensions() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || dimensions_ != nullptr);
  return value;
}
inline bool PostedScreenshot::has_dimensions() const {
  return _internal_has_dimensions();
}
inline const ::userfeedback::Dimensions& PostedScreenshot::_internal_dimensions() const {
  const ::userfeedback::Dimensions* p = dimensions_;
  return p != nullptr ? *p : reinterpret_cast<const ::userfeedback::Dimensions&>(
      ::userfeedback::_Dimensions_default_instance_);
}
inline const ::userfeedback::Dimensions& PostedScreenshot::dimensions() const {
  // @@protoc_insertion_point(field_get:userfeedback.PostedScreenshot.dimensions)
  return _internal_dimensions();
}
inline void PostedScreenshot::unsafe_arena_set_allocated_dimensions(
    ::userfeedback::Dimensions* dimensions) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(dimensions_);
  }
  dimensions_ = dimensions;
  if (dimensions) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:userfeedback.PostedScreenshot.dimensions)
}
inline ::userfeedback::Dimensions* PostedScreenshot::release_dimensions() {
  _has_bits_[0] &= ~0x00000008u;
  ::userfeedback::Dimensions* temp = dimensions_;
  dimensions_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::userfeedback::Dimensions* PostedScreenshot::unsafe_arena_release_dimensions() {
  // @@protoc_insertion_point(field_release:userfeedback.PostedScreenshot.dimensions)
  _has_bits_[0] &= ~0x00000008u;
  ::userfeedback::Dimensions* temp = dimensions_;
  dimensions_ = nullptr;
  return temp;
}
inline ::userfeedback::Dimensions* PostedScreenshot::_internal_mutable_dimensions() {
  _has_bits_[0] |= 0x00000008u;
  if (dimensions_ == nullptr) {
    auto* p = CreateMaybeMessage<::userfeedback::Dimensions>(GetArenaForAllocation());
    dimensions_ = p;
  }
  return dimensions_;
}
inline ::userfeedback::Dimensions* PostedScreenshot::mutable_dimensions() {
  ::userfeedback::Dimensions* _msg = _internal_mutable_dimensions();
  // @@protoc_insertion_point(field_mutable:userfeedback.PostedScreenshot.dimensions)
  return _msg;
}
inline void PostedScreenshot::set_allocated_dimensions(::userfeedback::Dimensions* dimensions) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(dimensions_);
  }
  if (dimensions) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(dimensions));
    if (message_arena != submessage_arena) {
      dimensions = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, dimensions, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  dimensions_ = dimensions;
  // @@protoc_insertion_point(field_set_allocated:userfeedback.PostedScreenshot.dimensions)
}

// optional string base64_content = 3;
inline bool PostedScreenshot::_internal_has_base64_content() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool PostedScreenshot::has_base64_content() const {
  return _internal_has_base64_content();
}
inline void PostedScreenshot::clear_base64_content() {
  base64_content_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& PostedScreenshot::base64_content() const {
  // @@protoc_insertion_point(field_get:userfeedback.PostedScreenshot.base64_content)
  return _internal_base64_content();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PostedScreenshot::set_base64_content(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 base64_content_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:userfeedback.PostedScreenshot.base64_content)
}
inline std::string* PostedScreenshot::mutable_base64_content() {
  std::string* _s = _internal_mutable_base64_content();
  // @@protoc_insertion_point(field_mutable:userfeedback.PostedScreenshot.base64_content)
  return _s;
}
inline const std::string& PostedScreenshot::_internal_base64_content() const {
  return base64_content_.Get();
}
inline void PostedScreenshot::_internal_set_base64_content(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  base64_content_.Set(value, GetArenaForAllocation());
}
inline std::string* PostedScreenshot::_internal_mutable_base64_content() {
  _has_bits_[0] |= 0x00000002u;
  return base64_content_.Mutable(GetArenaForAllocation());
}
inline std::string* PostedScreenshot::release_base64_content() {
  // @@protoc_insertion_point(field_release:userfeedback.PostedScreenshot.base64_content)
  if (!_internal_has_base64_content()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = base64_content_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (base64_content_.IsDefault()) {
    base64_content_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PostedScreenshot::set_allocated_base64_content(std::string* base64_content) {
  if (base64_content != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  base64_content_.SetAllocated(base64_content, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (base64_content_.IsDefault()) {
    base64_content_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:userfeedback.PostedScreenshot.base64_content)
}

// optional bytes binary_content = 4;
inline bool PostedScreenshot::_internal_has_binary_content() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool PostedScreenshot::has_binary_content() const {
  return _internal_has_binary_content();
}
inline void PostedScreenshot::clear_binary_content() {
  binary_content_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& PostedScreenshot::binary_content() const {
  // @@protoc_insertion_point(field_get:userfeedback.PostedScreenshot.binary_content)
  return _internal_binary_content();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PostedScreenshot::set_binary_content(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 binary_content_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:userfeedback.PostedScreenshot.binary_content)
}
inline std::string* PostedScreenshot::mutable_binary_content() {
  std::string* _s = _internal_mutable_binary_content();
  // @@protoc_insertion_point(field_mutable:userfeedback.PostedScreenshot.binary_content)
  return _s;
}
inline const std::string& PostedScreenshot::_internal_binary_content() const {
  return binary_content_.Get();
}
inline void PostedScreenshot::_internal_set_binary_content(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  binary_content_.Set(value, GetArenaForAllocation());
}
inline std::string* PostedScreenshot::_internal_mutable_binary_content() {
  _has_bits_[0] |= 0x00000004u;
  return binary_content_.Mutable(GetArenaForAllocation());
}
inline std::string* PostedScreenshot::release_binary_content() {
  // @@protoc_insertion_point(field_release:userfeedback.PostedScreenshot.binary_content)
  if (!_internal_has_binary_content()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = binary_content_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (binary_content_.IsDefault()) {
    binary_content_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PostedScreenshot::set_allocated_binary_content(std::string* binary_content) {
  if (binary_content != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  binary_content_.SetAllocated(binary_content, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (binary_content_.IsDefault()) {
    binary_content_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:userfeedback.PostedScreenshot.binary_content)
}

// -------------------------------------------------------------------

// ExtensionErrors

// required int32 number_of_attempts = 1;
inline bool ExtensionErrors::_internal_has_number_of_attempts() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ExtensionErrors::has_number_of_attempts() const {
  return _internal_has_number_of_attempts();
}
inline void ExtensionErrors::clear_number_of_attempts() {
  number_of_attempts_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline int32_t ExtensionErrors::_internal_number_of_attempts() const {
  return number_of_attempts_;
}
inline int32_t ExtensionErrors::number_of_attempts() const {
  // @@protoc_insertion_point(field_get:userfeedback.ExtensionErrors.number_of_attempts)
  return _internal_number_of_attempts();
}
inline void ExtensionErrors::_internal_set_number_of_attempts(int32_t value) {
  _has_bits_[0] |= 0x00000002u;
  number_of_attempts_ = value;
}
inline void ExtensionErrors::set_number_of_attempts(int32_t value) {
  _internal_set_number_of_attempts(value);
  // @@protoc_insertion_point(field_set:userfeedback.ExtensionErrors.number_of_attempts)
}

// required string errors = 2;
inline bool ExtensionErrors::_internal_has_errors() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ExtensionErrors::has_errors() const {
  return _internal_has_errors();
}
inline void ExtensionErrors::clear_errors() {
  errors_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ExtensionErrors::errors() const {
  // @@protoc_insertion_point(field_get:userfeedback.ExtensionErrors.errors)
  return _internal_errors();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ExtensionErrors::set_errors(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 errors_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:userfeedback.ExtensionErrors.errors)
}
inline std::string* ExtensionErrors::mutable_errors() {
  std::string* _s = _internal_mutable_errors();
  // @@protoc_insertion_point(field_mutable:userfeedback.ExtensionErrors.errors)
  return _s;
}
inline const std::string& ExtensionErrors::_internal_errors() const {
  return errors_.Get();
}
inline void ExtensionErrors::_internal_set_errors(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  errors_.Set(value, GetArenaForAllocation());
}
inline std::string* ExtensionErrors::_internal_mutable_errors() {
  _has_bits_[0] |= 0x00000001u;
  return errors_.Mutable(GetArenaForAllocation());
}
inline std::string* ExtensionErrors::release_errors() {
  // @@protoc_insertion_point(field_release:userfeedback.ExtensionErrors.errors)
  if (!_internal_has_errors()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = errors_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (errors_.IsDefault()) {
    errors_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ExtensionErrors::set_allocated_errors(std::string* errors) {
  if (errors != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  errors_.SetAllocated(errors, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (errors_.IsDefault()) {
    errors_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:userfeedback.ExtensionErrors.errors)
}

// -------------------------------------------------------------------

// ExtensionSubmit

// required .userfeedback.CommonData common_data = 1;
inline bool ExtensionSubmit::_internal_has_common_data() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || common_data_ != nullptr);
  return value;
}
inline bool ExtensionSubmit::has_common_data() const {
  return _internal_has_common_data();
}
inline const ::userfeedback::CommonData& ExtensionSubmit::_internal_common_data() const {
  const ::userfeedback::CommonData* p = common_data_;
  return p != nullptr ? *p : reinterpret_cast<const ::userfeedback::CommonData&>(
      ::userfeedback::_CommonData_default_instance_);
}
inline const ::userfeedback::CommonData& ExtensionSubmit::common_data() const {
  // @@protoc_insertion_point(field_get:userfeedback.ExtensionSubmit.common_data)
  return _internal_common_data();
}
inline void ExtensionSubmit::unsafe_arena_set_allocated_common_data(
    ::userfeedback::CommonData* common_data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(common_data_);
  }
  common_data_ = common_data;
  if (common_data) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:userfeedback.ExtensionSubmit.common_data)
}
inline ::userfeedback::CommonData* ExtensionSubmit::release_common_data() {
  _has_bits_[0] &= ~0x00000004u;
  ::userfeedback::CommonData* temp = common_data_;
  common_data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::userfeedback::CommonData* ExtensionSubmit::unsafe_arena_release_common_data() {
  // @@protoc_insertion_point(field_release:userfeedback.ExtensionSubmit.common_data)
  _has_bits_[0] &= ~0x00000004u;
  ::userfeedback::CommonData* temp = common_data_;
  common_data_ = nullptr;
  return temp;
}
inline ::userfeedback::CommonData* ExtensionSubmit::_internal_mutable_common_data() {
  _has_bits_[0] |= 0x00000004u;
  if (common_data_ == nullptr) {
    auto* p = CreateMaybeMessage<::userfeedback::CommonData>(GetArenaForAllocation());
    common_data_ = p;
  }
  return common_data_;
}
inline ::userfeedback::CommonData* ExtensionSubmit::mutable_common_data() {
  ::userfeedback::CommonData* _msg = _internal_mutable_common_data();
  // @@protoc_insertion_point(field_mutable:userfeedback.ExtensionSubmit.common_data)
  return _msg;
}
inline void ExtensionSubmit::set_allocated_common_data(::userfeedback::CommonData* common_data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(common_data_);
  }
  if (common_data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(common_data));
    if (message_arena != submessage_arena) {
      common_data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, common_data, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  common_data_ = common_data;
  // @@protoc_insertion_point(field_set_allocated:userfeedback.ExtensionSubmit.common_data)
}

// required .userfeedback.WebData web_data = 2;
inline bool ExtensionSubmit::_internal_has_web_data() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || web_data_ != nullptr);
  return value;
}
inline bool ExtensionSubmit::has_web_data() const {
  return _internal_has_web_data();
}
inline const ::userfeedback::WebData& ExtensionSubmit::_internal_web_data() const {
  const ::userfeedback::WebData* p = web_data_;
  return p != nullptr ? *p : reinterpret_cast<const ::userfeedback::WebData&>(
      ::userfeedback::_WebData_default_instance_);
}
inline const ::userfeedback::WebData& ExtensionSubmit::web_data() const {
  // @@protoc_insertion_point(field_get:userfeedback.ExtensionSubmit.web_data)
  return _internal_web_data();
}
inline void ExtensionSubmit::unsafe_arena_set_allocated_web_data(
    ::userfeedback::WebData* web_data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(web_data_);
  }
  web_data_ = web_data;
  if (web_data) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:userfeedback.ExtensionSubmit.web_data)
}
inline ::userfeedback::WebData* ExtensionSubmit::release_web_data() {
  _has_bits_[0] &= ~0x00000008u;
  ::userfeedback::WebData* temp = web_data_;
  web_data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::userfeedback::WebData* ExtensionSubmit::unsafe_arena_release_web_data() {
  // @@protoc_insertion_point(field_release:userfeedback.ExtensionSubmit.web_data)
  _has_bits_[0] &= ~0x00000008u;
  ::userfeedback::WebData* temp = web_data_;
  web_data_ = nullptr;
  return temp;
}
inline ::userfeedback::WebData* ExtensionSubmit::_internal_mutable_web_data() {
  _has_bits_[0] |= 0x00000008u;
  if (web_data_ == nullptr) {
    auto* p = CreateMaybeMessage<::userfeedback::WebData>(GetArenaForAllocation());
    web_data_ = p;
  }
  return web_data_;
}
inline ::userfeedback::WebData* ExtensionSubmit::mutable_web_data() {
  ::userfeedback::WebData* _msg = _internal_mutable_web_data();
  // @@protoc_insertion_point(field_mutable:userfeedback.ExtensionSubmit.web_data)
  return _msg;
}
inline void ExtensionSubmit::set_allocated_web_data(::userfeedback::WebData* web_data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(web_data_);
  }
  if (web_data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(web_data));
    if (message_arena != submessage_arena) {
      web_data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, web_data, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  web_data_ = web_data;
  // @@protoc_insertion_point(field_set_allocated:userfeedback.ExtensionSubmit.web_data)
}

// required int32 type_id = 3;
inline bool ExtensionSubmit::_internal_has_type_id() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool ExtensionSubmit::has_type_id() const {
  return _internal_has_type_id();
}
inline void ExtensionSubmit::clear_type_id() {
  type_id_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline int32_t ExtensionSubmit::_internal_type_id() const {
  return type_id_;
}
inline int32_t ExtensionSubmit::type_id() const {
  // @@protoc_insertion_point(field_get:userfeedback.ExtensionSubmit.type_id)
  return _internal_type_id();
}
inline void ExtensionSubmit::_internal_set_type_id(int32_t value) {
  _has_bits_[0] |= 0x00000040u;
  type_id_ = value;
}
inline void ExtensionSubmit::set_type_id(int32_t value) {
  _internal_set_type_id(value);
  // @@protoc_insertion_point(field_set:userfeedback.ExtensionSubmit.type_id)
}

// optional .userfeedback.PostedScreenshot screenshot = 4;
inline bool ExtensionSubmit::_internal_has_screenshot() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || screenshot_ != nullptr);
  return value;
}
inline bool ExtensionSubmit::has_screenshot() const {
  return _internal_has_screenshot();
}
inline void ExtensionSubmit::clear_screenshot() {
  if (screenshot_ != nullptr) screenshot_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::userfeedback::PostedScreenshot& ExtensionSubmit::_internal_screenshot() const {
  const ::userfeedback::PostedScreenshot* p = screenshot_;
  return p != nullptr ? *p : reinterpret_cast<const ::userfeedback::PostedScreenshot&>(
      ::userfeedback::_PostedScreenshot_default_instance_);
}
inline const ::userfeedback::PostedScreenshot& ExtensionSubmit::screenshot() const {
  // @@protoc_insertion_point(field_get:userfeedback.ExtensionSubmit.screenshot)
  return _internal_screenshot();
}
inline void ExtensionSubmit::unsafe_arena_set_allocated_screenshot(
    ::userfeedback::PostedScreenshot* screenshot) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(screenshot_);
  }
  screenshot_ = screenshot;
  if (screenshot) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:userfeedback.ExtensionSubmit.screenshot)
}
inline ::userfeedback::PostedScreenshot* ExtensionSubmit::release_screenshot() {
  _has_bits_[0] &= ~0x00000010u;
  ::userfeedback::PostedScreenshot* temp = screenshot_;
  screenshot_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::userfeedback::PostedScreenshot* ExtensionSubmit::unsafe_arena_release_screenshot() {
  // @@protoc_insertion_point(field_release:userfeedback.ExtensionSubmit.screenshot)
  _has_bits_[0] &= ~0x00000010u;
  ::userfeedback::PostedScreenshot* temp = screenshot_;
  screenshot_ = nullptr;
  return temp;
}
inline ::userfeedback::PostedScreenshot* ExtensionSubmit::_internal_mutable_screenshot() {
  _has_bits_[0] |= 0x00000010u;
  if (screenshot_ == nullptr) {
    auto* p = CreateMaybeMessage<::userfeedback::PostedScreenshot>(GetArenaForAllocation());
    screenshot_ = p;
  }
  return screenshot_;
}
inline ::userfeedback::PostedScreenshot* ExtensionSubmit::mutable_screenshot() {
  ::userfeedback::PostedScreenshot* _msg = _internal_mutable_screenshot();
  // @@protoc_insertion_point(field_mutable:userfeedback.ExtensionSubmit.screenshot)
  return _msg;
}
inline void ExtensionSubmit::set_allocated_screenshot(::userfeedback::PostedScreenshot* screenshot) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete screenshot_;
  }
  if (screenshot) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(screenshot);
    if (message_arena != submessage_arena) {
      screenshot = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, screenshot, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  screenshot_ = screenshot;
  // @@protoc_insertion_point(field_set_allocated:userfeedback.ExtensionSubmit.screenshot)
}

// optional .userfeedback.ChromeData chrome_data = 14;
inline bool ExtensionSubmit::_internal_has_chrome_data() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || chrome_data_ != nullptr);
  return value;
}
inline bool ExtensionSubmit::has_chrome_data() const {
  return _internal_has_chrome_data();
}
inline const ::userfeedback::ChromeData& ExtensionSubmit::_internal_chrome_data() const {
  const ::userfeedback::ChromeData* p = chrome_data_;
  return p != nullptr ? *p : reinterpret_cast<const ::userfeedback::ChromeData&>(
      ::userfeedback::_ChromeData_default_instance_);
}
inline const ::userfeedback::ChromeData& ExtensionSubmit::chrome_data() const {
  // @@protoc_insertion_point(field_get:userfeedback.ExtensionSubmit.chrome_data)
  return _internal_chrome_data();
}
inline void ExtensionSubmit::unsafe_arena_set_allocated_chrome_data(
    ::userfeedback::ChromeData* chrome_data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(chrome_data_);
  }
  chrome_data_ = chrome_data;
  if (chrome_data) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:userfeedback.ExtensionSubmit.chrome_data)
}
inline ::userfeedback::ChromeData* ExtensionSubmit::release_chrome_data() {
  _has_bits_[0] &= ~0x00000020u;
  ::userfeedback::ChromeData* temp = chrome_data_;
  chrome_data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::userfeedback::ChromeData* ExtensionSubmit::unsafe_arena_release_chrome_data() {
  // @@protoc_insertion_point(field_release:userfeedback.ExtensionSubmit.chrome_data)
  _has_bits_[0] &= ~0x00000020u;
  ::userfeedback::ChromeData* temp = chrome_data_;
  chrome_data_ = nullptr;
  return temp;
}
inline ::userfeedback::ChromeData* ExtensionSubmit::_internal_mutable_chrome_data() {
  _has_bits_[0] |= 0x00000020u;
  if (chrome_data_ == nullptr) {
    auto* p = CreateMaybeMessage<::userfeedback::ChromeData>(GetArenaForAllocation());
    chrome_data_ = p;
  }
  return chrome_data_;
}
inline ::userfeedback::ChromeData* ExtensionSubmit::mutable_chrome_data() {
  ::userfeedback::ChromeData* _msg = _internal_mutable_chrome_data();
  // @@protoc_insertion_point(field_mutable:userfeedback.ExtensionSubmit.chrome_data)
  return _msg;
}
inline void ExtensionSubmit::set_allocated_chrome_data(::userfeedback::ChromeData* chrome_data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(chrome_data_);
  }
  if (chrome_data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(chrome_data));
    if (message_arena != submessage_arena) {
      chrome_data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, chrome_data, submessage_arena);
    }
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  chrome_data_ = chrome_data;
  // @@protoc_insertion_point(field_set_allocated:userfeedback.ExtensionSubmit.chrome_data)
}

// repeated .userfeedback.ProductSpecificBinaryData product_specific_binary_data = 15;
inline int ExtensionSubmit::_internal_product_specific_binary_data_size() const {
  return product_specific_binary_data_.size();
}
inline int ExtensionSubmit::product_specific_binary_data_size() const {
  return _internal_product_specific_binary_data_size();
}
inline ::userfeedback::ProductSpecificBinaryData* ExtensionSubmit::mutable_product_specific_binary_data(int index) {
  // @@protoc_insertion_point(field_mutable:userfeedback.ExtensionSubmit.product_specific_binary_data)
  return product_specific_binary_data_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::userfeedback::ProductSpecificBinaryData >*
ExtensionSubmit::mutable_product_specific_binary_data() {
  // @@protoc_insertion_point(field_mutable_list:userfeedback.ExtensionSubmit.product_specific_binary_data)
  return &product_specific_binary_data_;
}
inline const ::userfeedback::ProductSpecificBinaryData& ExtensionSubmit::_internal_product_specific_binary_data(int index) const {
  return product_specific_binary_data_.Get(index);
}
inline const ::userfeedback::ProductSpecificBinaryData& ExtensionSubmit::product_specific_binary_data(int index) const {
  // @@protoc_insertion_point(field_get:userfeedback.ExtensionSubmit.product_specific_binary_data)
  return _internal_product_specific_binary_data(index);
}
inline ::userfeedback::ProductSpecificBinaryData* ExtensionSubmit::_internal_add_product_specific_binary_data() {
  return product_specific_binary_data_.Add();
}
inline ::userfeedback::ProductSpecificBinaryData* ExtensionSubmit::add_product_specific_binary_data() {
  ::userfeedback::ProductSpecificBinaryData* _add = _internal_add_product_specific_binary_data();
  // @@protoc_insertion_point(field_add:userfeedback.ExtensionSubmit.product_specific_binary_data)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::userfeedback::ProductSpecificBinaryData >&
ExtensionSubmit::product_specific_binary_data() const {
  // @@protoc_insertion_point(field_list:userfeedback.ExtensionSubmit.product_specific_binary_data)
  return product_specific_binary_data_;
}

// optional string category_tag = 16;
inline bool ExtensionSubmit::_internal_has_category_tag() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ExtensionSubmit::has_category_tag() const {
  return _internal_has_category_tag();
}
inline void ExtensionSubmit::clear_category_tag() {
  category_tag_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ExtensionSubmit::category_tag() const {
  // @@protoc_insertion_point(field_get:userfeedback.ExtensionSubmit.category_tag)
  return _internal_category_tag();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ExtensionSubmit::set_category_tag(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 category_tag_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:userfeedback.ExtensionSubmit.category_tag)
}
inline std::string* ExtensionSubmit::mutable_category_tag() {
  std::string* _s = _internal_mutable_category_tag();
  // @@protoc_insertion_point(field_mutable:userfeedback.ExtensionSubmit.category_tag)
  return _s;
}
inline const std::string& ExtensionSubmit::_internal_category_tag() const {
  return category_tag_.Get();
}
inline void ExtensionSubmit::_internal_set_category_tag(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  category_tag_.Set(value, GetArenaForAllocation());
}
inline std::string* ExtensionSubmit::_internal_mutable_category_tag() {
  _has_bits_[0] |= 0x00000001u;
  return category_tag_.Mutable(GetArenaForAllocation());
}
inline std::string* ExtensionSubmit::release_category_tag() {
  // @@protoc_insertion_point(field_release:userfeedback.ExtensionSubmit.category_tag)
  if (!_internal_has_category_tag()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = category_tag_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (category_tag_.IsDefault()) {
    category_tag_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ExtensionSubmit::set_allocated_category_tag(std::string* category_tag) {
  if (category_tag != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  category_tag_.SetAllocated(category_tag, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (category_tag_.IsDefault()) {
    category_tag_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:userfeedback.ExtensionSubmit.category_tag)
}

// optional int32 product_id = 17;
inline bool ExtensionSubmit::_internal_has_product_id() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool ExtensionSubmit::has_product_id() const {
  return _internal_has_product_id();
}
inline void ExtensionSubmit::clear_product_id() {
  product_id_ = 0;
  _has_bits_[0] &= ~0x00000080u;
}
inline int32_t ExtensionSubmit::_internal_product_id() const {
  return product_id_;
}
inline int32_t ExtensionSubmit::product_id() const {
  // @@protoc_insertion_point(field_get:userfeedback.ExtensionSubmit.product_id)
  return _internal_product_id();
}
inline void ExtensionSubmit::_internal_set_product_id(int32_t value) {
  _has_bits_[0] |= 0x00000080u;
  product_id_ = value;
}
inline void ExtensionSubmit::set_product_id(int32_t value) {
  _internal_set_product_id(value);
  // @@protoc_insertion_point(field_set:userfeedback.ExtensionSubmit.product_id)
}

// optional string bucket = 18;
inline bool ExtensionSubmit::_internal_has_bucket() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ExtensionSubmit::has_bucket() const {
  return _internal_has_bucket();
}
inline void ExtensionSubmit::clear_bucket() {
  bucket_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ExtensionSubmit::bucket() const {
  // @@protoc_insertion_point(field_get:userfeedback.ExtensionSubmit.bucket)
  return _internal_bucket();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ExtensionSubmit::set_bucket(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 bucket_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:userfeedback.ExtensionSubmit.bucket)
}
inline std::string* ExtensionSubmit::mutable_bucket() {
  std::string* _s = _internal_mutable_bucket();
  // @@protoc_insertion_point(field_mutable:userfeedback.ExtensionSubmit.bucket)
  return _s;
}
inline const std::string& ExtensionSubmit::_internal_bucket() const {
  return bucket_.Get();
}
inline void ExtensionSubmit::_internal_set_bucket(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  bucket_.Set(value, GetArenaForAllocation());
}
inline std::string* ExtensionSubmit::_internal_mutable_bucket() {
  _has_bits_[0] |= 0x00000002u;
  return bucket_.Mutable(GetArenaForAllocation());
}
inline std::string* ExtensionSubmit::release_bucket() {
  // @@protoc_insertion_point(field_release:userfeedback.ExtensionSubmit.bucket)
  if (!_internal_has_bucket()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = bucket_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (bucket_.IsDefault()) {
    bucket_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ExtensionSubmit::set_allocated_bucket(std::string* bucket) {
  if (bucket != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  bucket_.SetAllocated(bucket, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (bucket_.IsDefault()) {
    bucket_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:userfeedback.ExtensionSubmit.bucket)
}

// -------------------------------------------------------------------

// SuggestQuery

// required .userfeedback.CommonData common_data = 1;
inline bool SuggestQuery::_internal_has_common_data() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || common_data_ != nullptr);
  return value;
}
inline bool SuggestQuery::has_common_data() const {
  return _internal_has_common_data();
}
inline const ::userfeedback::CommonData& SuggestQuery::_internal_common_data() const {
  const ::userfeedback::CommonData* p = common_data_;
  return p != nullptr ? *p : reinterpret_cast<const ::userfeedback::CommonData&>(
      ::userfeedback::_CommonData_default_instance_);
}
inline const ::userfeedback::CommonData& SuggestQuery::common_data() const {
  // @@protoc_insertion_point(field_get:userfeedback.SuggestQuery.common_data)
  return _internal_common_data();
}
inline void SuggestQuery::unsafe_arena_set_allocated_common_data(
    ::userfeedback::CommonData* common_data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(common_data_);
  }
  common_data_ = common_data;
  if (common_data) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:userfeedback.SuggestQuery.common_data)
}
inline ::userfeedback::CommonData* SuggestQuery::release_common_data() {
  _has_bits_[0] &= ~0x00000001u;
  ::userfeedback::CommonData* temp = common_data_;
  common_data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::userfeedback::CommonData* SuggestQuery::unsafe_arena_release_common_data() {
  // @@protoc_insertion_point(field_release:userfeedback.SuggestQuery.common_data)
  _has_bits_[0] &= ~0x00000001u;
  ::userfeedback::CommonData* temp = common_data_;
  common_data_ = nullptr;
  return temp;
}
inline ::userfeedback::CommonData* SuggestQuery::_internal_mutable_common_data() {
  _has_bits_[0] |= 0x00000001u;
  if (common_data_ == nullptr) {
    auto* p = CreateMaybeMessage<::userfeedback::CommonData>(GetArenaForAllocation());
    common_data_ = p;
  }
  return common_data_;
}
inline ::userfeedback::CommonData* SuggestQuery::mutable_common_data() {
  ::userfeedback::CommonData* _msg = _internal_mutable_common_data();
  // @@protoc_insertion_point(field_mutable:userfeedback.SuggestQuery.common_data)
  return _msg;
}
inline void SuggestQuery::set_allocated_common_data(::userfeedback::CommonData* common_data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(common_data_);
  }
  if (common_data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(common_data));
    if (message_arena != submessage_arena) {
      common_data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, common_data, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  common_data_ = common_data;
  // @@protoc_insertion_point(field_set_allocated:userfeedback.SuggestQuery.common_data)
}

// required .userfeedback.WebData web_data = 2;
inline bool SuggestQuery::_internal_has_web_data() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || web_data_ != nullptr);
  return value;
}
inline bool SuggestQuery::has_web_data() const {
  return _internal_has_web_data();
}
inline const ::userfeedback::WebData& SuggestQuery::_internal_web_data() const {
  const ::userfeedback::WebData* p = web_data_;
  return p != nullptr ? *p : reinterpret_cast<const ::userfeedback::WebData&>(
      ::userfeedback::_WebData_default_instance_);
}
inline const ::userfeedback::WebData& SuggestQuery::web_data() const {
  // @@protoc_insertion_point(field_get:userfeedback.SuggestQuery.web_data)
  return _internal_web_data();
}
inline void SuggestQuery::unsafe_arena_set_allocated_web_data(
    ::userfeedback::WebData* web_data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(web_data_);
  }
  web_data_ = web_data;
  if (web_data) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:userfeedback.SuggestQuery.web_data)
}
inline ::userfeedback::WebData* SuggestQuery::release_web_data() {
  _has_bits_[0] &= ~0x00000002u;
  ::userfeedback::WebData* temp = web_data_;
  web_data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::userfeedback::WebData* SuggestQuery::unsafe_arena_release_web_data() {
  // @@protoc_insertion_point(field_release:userfeedback.SuggestQuery.web_data)
  _has_bits_[0] &= ~0x00000002u;
  ::userfeedback::WebData* temp = web_data_;
  web_data_ = nullptr;
  return temp;
}
inline ::userfeedback::WebData* SuggestQuery::_internal_mutable_web_data() {
  _has_bits_[0] |= 0x00000002u;
  if (web_data_ == nullptr) {
    auto* p = CreateMaybeMessage<::userfeedback::WebData>(GetArenaForAllocation());
    web_data_ = p;
  }
  return web_data_;
}
inline ::userfeedback::WebData* SuggestQuery::mutable_web_data() {
  ::userfeedback::WebData* _msg = _internal_mutable_web_data();
  // @@protoc_insertion_point(field_mutable:userfeedback.SuggestQuery.web_data)
  return _msg;
}
inline void SuggestQuery::set_allocated_web_data(::userfeedback::WebData* web_data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(web_data_);
  }
  if (web_data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(web_data));
    if (message_arena != submessage_arena) {
      web_data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, web_data, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  web_data_ = web_data;
  // @@protoc_insertion_point(field_set_allocated:userfeedback.SuggestQuery.web_data)
}

// required int32 type_id = 3;
inline bool SuggestQuery::_internal_has_type_id() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool SuggestQuery::has_type_id() const {
  return _internal_has_type_id();
}
inline void SuggestQuery::clear_type_id() {
  type_id_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline int32_t SuggestQuery::_internal_type_id() const {
  return type_id_;
}
inline int32_t SuggestQuery::type_id() const {
  // @@protoc_insertion_point(field_get:userfeedback.SuggestQuery.type_id)
  return _internal_type_id();
}
inline void SuggestQuery::_internal_set_type_id(int32_t value) {
  _has_bits_[0] |= 0x00000010u;
  type_id_ = value;
}
inline void SuggestQuery::set_type_id(int32_t value) {
  _internal_set_type_id(value);
  // @@protoc_insertion_point(field_set:userfeedback.SuggestQuery.type_id)
}

// optional .userfeedback.HtmlDocument html_document_structure = 4;
inline bool SuggestQuery::_internal_has_html_document_structure() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || html_document_structure_ != nullptr);
  return value;
}
inline bool SuggestQuery::has_html_document_structure() const {
  return _internal_has_html_document_structure();
}
inline const ::userfeedback::HtmlDocument& SuggestQuery::_internal_html_document_structure() const {
  const ::userfeedback::HtmlDocument* p = html_document_structure_;
  return p != nullptr ? *p : reinterpret_cast<const ::userfeedback::HtmlDocument&>(
      ::userfeedback::_HtmlDocument_default_instance_);
}
inline const ::userfeedback::HtmlDocument& SuggestQuery::html_document_structure() const {
  // @@protoc_insertion_point(field_get:userfeedback.SuggestQuery.html_document_structure)
  return _internal_html_document_structure();
}
inline void SuggestQuery::unsafe_arena_set_allocated_html_document_structure(
    ::userfeedback::HtmlDocument* html_document_structure) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(html_document_structure_);
  }
  html_document_structure_ = html_document_structure;
  if (html_document_structure) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:userfeedback.SuggestQuery.html_document_structure)
}
inline ::userfeedback::HtmlDocument* SuggestQuery::release_html_document_structure() {
  _has_bits_[0] &= ~0x00000004u;
  ::userfeedback::HtmlDocument* temp = html_document_structure_;
  html_document_structure_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::userfeedback::HtmlDocument* SuggestQuery::unsafe_arena_release_html_document_structure() {
  // @@protoc_insertion_point(field_release:userfeedback.SuggestQuery.html_document_structure)
  _has_bits_[0] &= ~0x00000004u;
  ::userfeedback::HtmlDocument* temp = html_document_structure_;
  html_document_structure_ = nullptr;
  return temp;
}
inline ::userfeedback::HtmlDocument* SuggestQuery::_internal_mutable_html_document_structure() {
  _has_bits_[0] |= 0x00000004u;
  if (html_document_structure_ == nullptr) {
    auto* p = CreateMaybeMessage<::userfeedback::HtmlDocument>(GetArenaForAllocation());
    html_document_structure_ = p;
  }
  return html_document_structure_;
}
inline ::userfeedback::HtmlDocument* SuggestQuery::mutable_html_document_structure() {
  ::userfeedback::HtmlDocument* _msg = _internal_mutable_html_document_structure();
  // @@protoc_insertion_point(field_mutable:userfeedback.SuggestQuery.html_document_structure)
  return _msg;
}
inline void SuggestQuery::set_allocated_html_document_structure(::userfeedback::HtmlDocument* html_document_structure) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(html_document_structure_);
  }
  if (html_document_structure) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(html_document_structure));
    if (message_arena != submessage_arena) {
      html_document_structure = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, html_document_structure, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  html_document_structure_ = html_document_structure;
  // @@protoc_insertion_point(field_set_allocated:userfeedback.SuggestQuery.html_document_structure)
}

// optional .userfeedback.ChromeData chrome_data = 5;
inline bool SuggestQuery::_internal_has_chrome_data() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || chrome_data_ != nullptr);
  return value;
}
inline bool SuggestQuery::has_chrome_data() const {
  return _internal_has_chrome_data();
}
inline const ::userfeedback::ChromeData& SuggestQuery::_internal_chrome_data() const {
  const ::userfeedback::ChromeData* p = chrome_data_;
  return p != nullptr ? *p : reinterpret_cast<const ::userfeedback::ChromeData&>(
      ::userfeedback::_ChromeData_default_instance_);
}
inline const ::userfeedback::ChromeData& SuggestQuery::chrome_data() const {
  // @@protoc_insertion_point(field_get:userfeedback.SuggestQuery.chrome_data)
  return _internal_chrome_data();
}
inline void SuggestQuery::unsafe_arena_set_allocated_chrome_data(
    ::userfeedback::ChromeData* chrome_data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(chrome_data_);
  }
  chrome_data_ = chrome_data;
  if (chrome_data) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:userfeedback.SuggestQuery.chrome_data)
}
inline ::userfeedback::ChromeData* SuggestQuery::release_chrome_data() {
  _has_bits_[0] &= ~0x00000008u;
  ::userfeedback::ChromeData* temp = chrome_data_;
  chrome_data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::userfeedback::ChromeData* SuggestQuery::unsafe_arena_release_chrome_data() {
  // @@protoc_insertion_point(field_release:userfeedback.SuggestQuery.chrome_data)
  _has_bits_[0] &= ~0x00000008u;
  ::userfeedback::ChromeData* temp = chrome_data_;
  chrome_data_ = nullptr;
  return temp;
}
inline ::userfeedback::ChromeData* SuggestQuery::_internal_mutable_chrome_data() {
  _has_bits_[0] |= 0x00000008u;
  if (chrome_data_ == nullptr) {
    auto* p = CreateMaybeMessage<::userfeedback::ChromeData>(GetArenaForAllocation());
    chrome_data_ = p;
  }
  return chrome_data_;
}
inline ::userfeedback::ChromeData* SuggestQuery::mutable_chrome_data() {
  ::userfeedback::ChromeData* _msg = _internal_mutable_chrome_data();
  // @@protoc_insertion_point(field_mutable:userfeedback.SuggestQuery.chrome_data)
  return _msg;
}
inline void SuggestQuery::set_allocated_chrome_data(::userfeedback::ChromeData* chrome_data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(chrome_data_);
  }
  if (chrome_data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(chrome_data));
    if (message_arena != submessage_arena) {
      chrome_data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, chrome_data, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  chrome_data_ = chrome_data;
  // @@protoc_insertion_point(field_set_allocated:userfeedback.SuggestQuery.chrome_data)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace userfeedback

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_extension_2eproto
