// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: video_tutorials.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_video_5ftutorials_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_video_5ftutorials_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3020000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3020000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_video_5ftutorials_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_video_5ftutorials_2eproto {
  static const uint32_t offsets[];
};
namespace video_tutorials {
namespace proto {
class VideoTutorial;
struct VideoTutorialDefaultTypeInternal;
extern VideoTutorialDefaultTypeInternal _VideoTutorial_default_instance_;
class VideoTutorialGroup;
struct VideoTutorialGroupDefaultTypeInternal;
extern VideoTutorialGroupDefaultTypeInternal _VideoTutorialGroup_default_instance_;
class VideoTutorialGroups;
struct VideoTutorialGroupsDefaultTypeInternal;
extern VideoTutorialGroupsDefaultTypeInternal _VideoTutorialGroups_default_instance_;
}  // namespace proto
}  // namespace video_tutorials
PROTOBUF_NAMESPACE_OPEN
template<> ::video_tutorials::proto::VideoTutorial* Arena::CreateMaybeMessage<::video_tutorials::proto::VideoTutorial>(Arena*);
template<> ::video_tutorials::proto::VideoTutorialGroup* Arena::CreateMaybeMessage<::video_tutorials::proto::VideoTutorialGroup>(Arena*);
template<> ::video_tutorials::proto::VideoTutorialGroups* Arena::CreateMaybeMessage<::video_tutorials::proto::VideoTutorialGroups>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace video_tutorials {
namespace proto {

enum FeatureType : int {
  INVALID = 0,
  SUMMARY = 1,
  CHROME_INTRO = 2,
  DOWNLOAD = 3,
  SEARCH = 4,
  VOICE_SEARCH = 5,
  TEST = 9999999,
  FeatureType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  FeatureType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool FeatureType_IsValid(int value);
constexpr FeatureType FeatureType_MIN = INVALID;
constexpr FeatureType FeatureType_MAX = TEST;
constexpr int FeatureType_ARRAYSIZE = FeatureType_MAX + 1;

const std::string& FeatureType_Name(FeatureType value);
template<typename T>
inline const std::string& FeatureType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, FeatureType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function FeatureType_Name.");
  return FeatureType_Name(static_cast<FeatureType>(enum_t_value));
}
bool FeatureType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, FeatureType* value);
// ===================================================================

class VideoTutorialGroup final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:video_tutorials.proto.VideoTutorialGroup) */ {
 public:
  inline VideoTutorialGroup() : VideoTutorialGroup(nullptr) {}
  ~VideoTutorialGroup() override;
  explicit PROTOBUF_CONSTEXPR VideoTutorialGroup(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VideoTutorialGroup(const VideoTutorialGroup& from);
  VideoTutorialGroup(VideoTutorialGroup&& from) noexcept
    : VideoTutorialGroup() {
    *this = ::std::move(from);
  }

  inline VideoTutorialGroup& operator=(const VideoTutorialGroup& from) {
    CopyFrom(from);
    return *this;
  }
  inline VideoTutorialGroup& operator=(VideoTutorialGroup&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const VideoTutorialGroup& default_instance() {
    return *internal_default_instance();
  }
  static inline const VideoTutorialGroup* internal_default_instance() {
    return reinterpret_cast<const VideoTutorialGroup*>(
               &_VideoTutorialGroup_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(VideoTutorialGroup& a, VideoTutorialGroup& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(VideoTutorialGroup* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VideoTutorialGroup* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VideoTutorialGroup* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VideoTutorialGroup>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const VideoTutorialGroup& from);
  void MergeFrom(const VideoTutorialGroup& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(VideoTutorialGroup* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "video_tutorials.proto.VideoTutorialGroup";
  }
  protected:
  explicit VideoTutorialGroup(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTutorialsFieldNumber = 2,
    kLanguageFieldNumber = 1,
  };
  // repeated .video_tutorials.proto.VideoTutorial tutorials = 2;
  int tutorials_size() const;
  private:
  int _internal_tutorials_size() const;
  public:
  void clear_tutorials();
  ::video_tutorials::proto::VideoTutorial* mutable_tutorials(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::video_tutorials::proto::VideoTutorial >*
      mutable_tutorials();
  private:
  const ::video_tutorials::proto::VideoTutorial& _internal_tutorials(int index) const;
  ::video_tutorials::proto::VideoTutorial* _internal_add_tutorials();
  public:
  const ::video_tutorials::proto::VideoTutorial& tutorials(int index) const;
  ::video_tutorials::proto::VideoTutorial* add_tutorials();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::video_tutorials::proto::VideoTutorial >&
      tutorials() const;

  // string language = 1;
  void clear_language();
  const std::string& language() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_language(ArgT0&& arg0, ArgT... args);
  std::string* mutable_language();
  PROTOBUF_NODISCARD std::string* release_language();
  void set_allocated_language(std::string* language);
  private:
  const std::string& _internal_language() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_language(const std::string& value);
  std::string* _internal_mutable_language();
  public:

  // @@protoc_insertion_point(class_scope:video_tutorials.proto.VideoTutorialGroup)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::video_tutorials::proto::VideoTutorial > tutorials_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr language_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_video_5ftutorials_2eproto;
};
// -------------------------------------------------------------------

class VideoTutorial final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:video_tutorials.proto.VideoTutorial) */ {
 public:
  inline VideoTutorial() : VideoTutorial(nullptr) {}
  ~VideoTutorial() override;
  explicit PROTOBUF_CONSTEXPR VideoTutorial(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VideoTutorial(const VideoTutorial& from);
  VideoTutorial(VideoTutorial&& from) noexcept
    : VideoTutorial() {
    *this = ::std::move(from);
  }

  inline VideoTutorial& operator=(const VideoTutorial& from) {
    CopyFrom(from);
    return *this;
  }
  inline VideoTutorial& operator=(VideoTutorial&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const VideoTutorial& default_instance() {
    return *internal_default_instance();
  }
  static inline const VideoTutorial* internal_default_instance() {
    return reinterpret_cast<const VideoTutorial*>(
               &_VideoTutorial_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(VideoTutorial& a, VideoTutorial& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(VideoTutorial* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VideoTutorial* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VideoTutorial* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VideoTutorial>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const VideoTutorial& from);
  void MergeFrom(const VideoTutorial& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(VideoTutorial* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "video_tutorials.proto.VideoTutorial";
  }
  protected:
  explicit VideoTutorial(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTitleFieldNumber = 2,
    kVideoUrlFieldNumber = 3,
    kShareUrlFieldNumber = 4,
    kPosterUrlFieldNumber = 5,
    kCaptionUrlFieldNumber = 6,
    kAnimatedGifUrlFieldNumber = 8,
    kThumbnailUrlFieldNumber = 9,
    kVideoLengthFieldNumber = 7,
    kFeatureFieldNumber = 1,
  };
  // string title = 2;
  void clear_title();
  const std::string& title() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_title(ArgT0&& arg0, ArgT... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* title);
  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(const std::string& value);
  std::string* _internal_mutable_title();
  public:

  // string video_url = 3;
  void clear_video_url();
  const std::string& video_url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_video_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_video_url();
  PROTOBUF_NODISCARD std::string* release_video_url();
  void set_allocated_video_url(std::string* video_url);
  private:
  const std::string& _internal_video_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_video_url(const std::string& value);
  std::string* _internal_mutable_video_url();
  public:

  // string share_url = 4;
  void clear_share_url();
  const std::string& share_url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_share_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_share_url();
  PROTOBUF_NODISCARD std::string* release_share_url();
  void set_allocated_share_url(std::string* share_url);
  private:
  const std::string& _internal_share_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_share_url(const std::string& value);
  std::string* _internal_mutable_share_url();
  public:

  // string poster_url = 5;
  void clear_poster_url();
  const std::string& poster_url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_poster_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_poster_url();
  PROTOBUF_NODISCARD std::string* release_poster_url();
  void set_allocated_poster_url(std::string* poster_url);
  private:
  const std::string& _internal_poster_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_poster_url(const std::string& value);
  std::string* _internal_mutable_poster_url();
  public:

  // string caption_url = 6;
  void clear_caption_url();
  const std::string& caption_url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_caption_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_caption_url();
  PROTOBUF_NODISCARD std::string* release_caption_url();
  void set_allocated_caption_url(std::string* caption_url);
  private:
  const std::string& _internal_caption_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_caption_url(const std::string& value);
  std::string* _internal_mutable_caption_url();
  public:

  // string animated_gif_url = 8;
  void clear_animated_gif_url();
  const std::string& animated_gif_url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_animated_gif_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_animated_gif_url();
  PROTOBUF_NODISCARD std::string* release_animated_gif_url();
  void set_allocated_animated_gif_url(std::string* animated_gif_url);
  private:
  const std::string& _internal_animated_gif_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_animated_gif_url(const std::string& value);
  std::string* _internal_mutable_animated_gif_url();
  public:

  // string thumbnail_url = 9;
  void clear_thumbnail_url();
  const std::string& thumbnail_url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_thumbnail_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_thumbnail_url();
  PROTOBUF_NODISCARD std::string* release_thumbnail_url();
  void set_allocated_thumbnail_url(std::string* thumbnail_url);
  private:
  const std::string& _internal_thumbnail_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_thumbnail_url(const std::string& value);
  std::string* _internal_mutable_thumbnail_url();
  public:

  // int64 video_length = 7;
  void clear_video_length();
  int64_t video_length() const;
  void set_video_length(int64_t value);
  private:
  int64_t _internal_video_length() const;
  void _internal_set_video_length(int64_t value);
  public:

  // .video_tutorials.proto.FeatureType feature = 1;
  void clear_feature();
  ::video_tutorials::proto::FeatureType feature() const;
  void set_feature(::video_tutorials::proto::FeatureType value);
  private:
  ::video_tutorials::proto::FeatureType _internal_feature() const;
  void _internal_set_feature(::video_tutorials::proto::FeatureType value);
  public:

  // @@protoc_insertion_point(class_scope:video_tutorials.proto.VideoTutorial)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr video_url_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr share_url_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr poster_url_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr caption_url_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr animated_gif_url_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr thumbnail_url_;
  int64_t video_length_;
  int feature_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_video_5ftutorials_2eproto;
};
// -------------------------------------------------------------------

class VideoTutorialGroups final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:video_tutorials.proto.VideoTutorialGroups) */ {
 public:
  inline VideoTutorialGroups() : VideoTutorialGroups(nullptr) {}
  ~VideoTutorialGroups() override;
  explicit PROTOBUF_CONSTEXPR VideoTutorialGroups(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VideoTutorialGroups(const VideoTutorialGroups& from);
  VideoTutorialGroups(VideoTutorialGroups&& from) noexcept
    : VideoTutorialGroups() {
    *this = ::std::move(from);
  }

  inline VideoTutorialGroups& operator=(const VideoTutorialGroups& from) {
    CopyFrom(from);
    return *this;
  }
  inline VideoTutorialGroups& operator=(VideoTutorialGroups&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const VideoTutorialGroups& default_instance() {
    return *internal_default_instance();
  }
  static inline const VideoTutorialGroups* internal_default_instance() {
    return reinterpret_cast<const VideoTutorialGroups*>(
               &_VideoTutorialGroups_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(VideoTutorialGroups& a, VideoTutorialGroups& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(VideoTutorialGroups* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VideoTutorialGroups* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VideoTutorialGroups* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VideoTutorialGroups>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const VideoTutorialGroups& from);
  void MergeFrom(const VideoTutorialGroups& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(VideoTutorialGroups* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "video_tutorials.proto.VideoTutorialGroups";
  }
  protected:
  explicit VideoTutorialGroups(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTutorialGroupsFieldNumber = 1,
    kTextLocaleFieldNumber = 2,
    kPreferredLocaleFieldNumber = 3,
  };
  // repeated .video_tutorials.proto.VideoTutorialGroup tutorial_groups = 1;
  int tutorial_groups_size() const;
  private:
  int _internal_tutorial_groups_size() const;
  public:
  void clear_tutorial_groups();
  ::video_tutorials::proto::VideoTutorialGroup* mutable_tutorial_groups(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::video_tutorials::proto::VideoTutorialGroup >*
      mutable_tutorial_groups();
  private:
  const ::video_tutorials::proto::VideoTutorialGroup& _internal_tutorial_groups(int index) const;
  ::video_tutorials::proto::VideoTutorialGroup* _internal_add_tutorial_groups();
  public:
  const ::video_tutorials::proto::VideoTutorialGroup& tutorial_groups(int index) const;
  ::video_tutorials::proto::VideoTutorialGroup* add_tutorial_groups();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::video_tutorials::proto::VideoTutorialGroup >&
      tutorial_groups() const;

  // string text_locale = 2;
  void clear_text_locale();
  const std::string& text_locale() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_text_locale(ArgT0&& arg0, ArgT... args);
  std::string* mutable_text_locale();
  PROTOBUF_NODISCARD std::string* release_text_locale();
  void set_allocated_text_locale(std::string* text_locale);
  private:
  const std::string& _internal_text_locale() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_text_locale(const std::string& value);
  std::string* _internal_mutable_text_locale();
  public:

  // string preferred_locale = 3;
  void clear_preferred_locale();
  const std::string& preferred_locale() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_preferred_locale(ArgT0&& arg0, ArgT... args);
  std::string* mutable_preferred_locale();
  PROTOBUF_NODISCARD std::string* release_preferred_locale();
  void set_allocated_preferred_locale(std::string* preferred_locale);
  private:
  const std::string& _internal_preferred_locale() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_preferred_locale(const std::string& value);
  std::string* _internal_mutable_preferred_locale();
  public:

  // @@protoc_insertion_point(class_scope:video_tutorials.proto.VideoTutorialGroups)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::video_tutorials::proto::VideoTutorialGroup > tutorial_groups_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_locale_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr preferred_locale_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_video_5ftutorials_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// VideoTutorialGroup

// string language = 1;
inline void VideoTutorialGroup::clear_language() {
  language_.ClearToEmpty();
}
inline const std::string& VideoTutorialGroup::language() const {
  // @@protoc_insertion_point(field_get:video_tutorials.proto.VideoTutorialGroup.language)
  return _internal_language();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VideoTutorialGroup::set_language(ArgT0&& arg0, ArgT... args) {
 
 language_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:video_tutorials.proto.VideoTutorialGroup.language)
}
inline std::string* VideoTutorialGroup::mutable_language() {
  std::string* _s = _internal_mutable_language();
  // @@protoc_insertion_point(field_mutable:video_tutorials.proto.VideoTutorialGroup.language)
  return _s;
}
inline const std::string& VideoTutorialGroup::_internal_language() const {
  return language_.Get();
}
inline void VideoTutorialGroup::_internal_set_language(const std::string& value) {
  
  language_.Set(value, GetArenaForAllocation());
}
inline std::string* VideoTutorialGroup::_internal_mutable_language() {
  
  return language_.Mutable(GetArenaForAllocation());
}
inline std::string* VideoTutorialGroup::release_language() {
  // @@protoc_insertion_point(field_release:video_tutorials.proto.VideoTutorialGroup.language)
  return language_.Release();
}
inline void VideoTutorialGroup::set_allocated_language(std::string* language) {
  if (language != nullptr) {
    
  } else {
    
  }
  language_.SetAllocated(language, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (language_.IsDefault()) {
    language_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:video_tutorials.proto.VideoTutorialGroup.language)
}

// repeated .video_tutorials.proto.VideoTutorial tutorials = 2;
inline int VideoTutorialGroup::_internal_tutorials_size() const {
  return tutorials_.size();
}
inline int VideoTutorialGroup::tutorials_size() const {
  return _internal_tutorials_size();
}
inline void VideoTutorialGroup::clear_tutorials() {
  tutorials_.Clear();
}
inline ::video_tutorials::proto::VideoTutorial* VideoTutorialGroup::mutable_tutorials(int index) {
  // @@protoc_insertion_point(field_mutable:video_tutorials.proto.VideoTutorialGroup.tutorials)
  return tutorials_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::video_tutorials::proto::VideoTutorial >*
VideoTutorialGroup::mutable_tutorials() {
  // @@protoc_insertion_point(field_mutable_list:video_tutorials.proto.VideoTutorialGroup.tutorials)
  return &tutorials_;
}
inline const ::video_tutorials::proto::VideoTutorial& VideoTutorialGroup::_internal_tutorials(int index) const {
  return tutorials_.Get(index);
}
inline const ::video_tutorials::proto::VideoTutorial& VideoTutorialGroup::tutorials(int index) const {
  // @@protoc_insertion_point(field_get:video_tutorials.proto.VideoTutorialGroup.tutorials)
  return _internal_tutorials(index);
}
inline ::video_tutorials::proto::VideoTutorial* VideoTutorialGroup::_internal_add_tutorials() {
  return tutorials_.Add();
}
inline ::video_tutorials::proto::VideoTutorial* VideoTutorialGroup::add_tutorials() {
  ::video_tutorials::proto::VideoTutorial* _add = _internal_add_tutorials();
  // @@protoc_insertion_point(field_add:video_tutorials.proto.VideoTutorialGroup.tutorials)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::video_tutorials::proto::VideoTutorial >&
VideoTutorialGroup::tutorials() const {
  // @@protoc_insertion_point(field_list:video_tutorials.proto.VideoTutorialGroup.tutorials)
  return tutorials_;
}

// -------------------------------------------------------------------

// VideoTutorial

// .video_tutorials.proto.FeatureType feature = 1;
inline void VideoTutorial::clear_feature() {
  feature_ = 0;
}
inline ::video_tutorials::proto::FeatureType VideoTutorial::_internal_feature() const {
  return static_cast< ::video_tutorials::proto::FeatureType >(feature_);
}
inline ::video_tutorials::proto::FeatureType VideoTutorial::feature() const {
  // @@protoc_insertion_point(field_get:video_tutorials.proto.VideoTutorial.feature)
  return _internal_feature();
}
inline void VideoTutorial::_internal_set_feature(::video_tutorials::proto::FeatureType value) {
  
  feature_ = value;
}
inline void VideoTutorial::set_feature(::video_tutorials::proto::FeatureType value) {
  _internal_set_feature(value);
  // @@protoc_insertion_point(field_set:video_tutorials.proto.VideoTutorial.feature)
}

// string title = 2;
inline void VideoTutorial::clear_title() {
  title_.ClearToEmpty();
}
inline const std::string& VideoTutorial::title() const {
  // @@protoc_insertion_point(field_get:video_tutorials.proto.VideoTutorial.title)
  return _internal_title();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VideoTutorial::set_title(ArgT0&& arg0, ArgT... args) {
 
 title_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:video_tutorials.proto.VideoTutorial.title)
}
inline std::string* VideoTutorial::mutable_title() {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:video_tutorials.proto.VideoTutorial.title)
  return _s;
}
inline const std::string& VideoTutorial::_internal_title() const {
  return title_.Get();
}
inline void VideoTutorial::_internal_set_title(const std::string& value) {
  
  title_.Set(value, GetArenaForAllocation());
}
inline std::string* VideoTutorial::_internal_mutable_title() {
  
  return title_.Mutable(GetArenaForAllocation());
}
inline std::string* VideoTutorial::release_title() {
  // @@protoc_insertion_point(field_release:video_tutorials.proto.VideoTutorial.title)
  return title_.Release();
}
inline void VideoTutorial::set_allocated_title(std::string* title) {
  if (title != nullptr) {
    
  } else {
    
  }
  title_.SetAllocated(title, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (title_.IsDefault()) {
    title_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:video_tutorials.proto.VideoTutorial.title)
}

// string video_url = 3;
inline void VideoTutorial::clear_video_url() {
  video_url_.ClearToEmpty();
}
inline const std::string& VideoTutorial::video_url() const {
  // @@protoc_insertion_point(field_get:video_tutorials.proto.VideoTutorial.video_url)
  return _internal_video_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VideoTutorial::set_video_url(ArgT0&& arg0, ArgT... args) {
 
 video_url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:video_tutorials.proto.VideoTutorial.video_url)
}
inline std::string* VideoTutorial::mutable_video_url() {
  std::string* _s = _internal_mutable_video_url();
  // @@protoc_insertion_point(field_mutable:video_tutorials.proto.VideoTutorial.video_url)
  return _s;
}
inline const std::string& VideoTutorial::_internal_video_url() const {
  return video_url_.Get();
}
inline void VideoTutorial::_internal_set_video_url(const std::string& value) {
  
  video_url_.Set(value, GetArenaForAllocation());
}
inline std::string* VideoTutorial::_internal_mutable_video_url() {
  
  return video_url_.Mutable(GetArenaForAllocation());
}
inline std::string* VideoTutorial::release_video_url() {
  // @@protoc_insertion_point(field_release:video_tutorials.proto.VideoTutorial.video_url)
  return video_url_.Release();
}
inline void VideoTutorial::set_allocated_video_url(std::string* video_url) {
  if (video_url != nullptr) {
    
  } else {
    
  }
  video_url_.SetAllocated(video_url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (video_url_.IsDefault()) {
    video_url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:video_tutorials.proto.VideoTutorial.video_url)
}

// string share_url = 4;
inline void VideoTutorial::clear_share_url() {
  share_url_.ClearToEmpty();
}
inline const std::string& VideoTutorial::share_url() const {
  // @@protoc_insertion_point(field_get:video_tutorials.proto.VideoTutorial.share_url)
  return _internal_share_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VideoTutorial::set_share_url(ArgT0&& arg0, ArgT... args) {
 
 share_url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:video_tutorials.proto.VideoTutorial.share_url)
}
inline std::string* VideoTutorial::mutable_share_url() {
  std::string* _s = _internal_mutable_share_url();
  // @@protoc_insertion_point(field_mutable:video_tutorials.proto.VideoTutorial.share_url)
  return _s;
}
inline const std::string& VideoTutorial::_internal_share_url() const {
  return share_url_.Get();
}
inline void VideoTutorial::_internal_set_share_url(const std::string& value) {
  
  share_url_.Set(value, GetArenaForAllocation());
}
inline std::string* VideoTutorial::_internal_mutable_share_url() {
  
  return share_url_.Mutable(GetArenaForAllocation());
}
inline std::string* VideoTutorial::release_share_url() {
  // @@protoc_insertion_point(field_release:video_tutorials.proto.VideoTutorial.share_url)
  return share_url_.Release();
}
inline void VideoTutorial::set_allocated_share_url(std::string* share_url) {
  if (share_url != nullptr) {
    
  } else {
    
  }
  share_url_.SetAllocated(share_url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (share_url_.IsDefault()) {
    share_url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:video_tutorials.proto.VideoTutorial.share_url)
}

// string poster_url = 5;
inline void VideoTutorial::clear_poster_url() {
  poster_url_.ClearToEmpty();
}
inline const std::string& VideoTutorial::poster_url() const {
  // @@protoc_insertion_point(field_get:video_tutorials.proto.VideoTutorial.poster_url)
  return _internal_poster_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VideoTutorial::set_poster_url(ArgT0&& arg0, ArgT... args) {
 
 poster_url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:video_tutorials.proto.VideoTutorial.poster_url)
}
inline std::string* VideoTutorial::mutable_poster_url() {
  std::string* _s = _internal_mutable_poster_url();
  // @@protoc_insertion_point(field_mutable:video_tutorials.proto.VideoTutorial.poster_url)
  return _s;
}
inline const std::string& VideoTutorial::_internal_poster_url() const {
  return poster_url_.Get();
}
inline void VideoTutorial::_internal_set_poster_url(const std::string& value) {
  
  poster_url_.Set(value, GetArenaForAllocation());
}
inline std::string* VideoTutorial::_internal_mutable_poster_url() {
  
  return poster_url_.Mutable(GetArenaForAllocation());
}
inline std::string* VideoTutorial::release_poster_url() {
  // @@protoc_insertion_point(field_release:video_tutorials.proto.VideoTutorial.poster_url)
  return poster_url_.Release();
}
inline void VideoTutorial::set_allocated_poster_url(std::string* poster_url) {
  if (poster_url != nullptr) {
    
  } else {
    
  }
  poster_url_.SetAllocated(poster_url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (poster_url_.IsDefault()) {
    poster_url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:video_tutorials.proto.VideoTutorial.poster_url)
}

// string caption_url = 6;
inline void VideoTutorial::clear_caption_url() {
  caption_url_.ClearToEmpty();
}
inline const std::string& VideoTutorial::caption_url() const {
  // @@protoc_insertion_point(field_get:video_tutorials.proto.VideoTutorial.caption_url)
  return _internal_caption_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VideoTutorial::set_caption_url(ArgT0&& arg0, ArgT... args) {
 
 caption_url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:video_tutorials.proto.VideoTutorial.caption_url)
}
inline std::string* VideoTutorial::mutable_caption_url() {
  std::string* _s = _internal_mutable_caption_url();
  // @@protoc_insertion_point(field_mutable:video_tutorials.proto.VideoTutorial.caption_url)
  return _s;
}
inline const std::string& VideoTutorial::_internal_caption_url() const {
  return caption_url_.Get();
}
inline void VideoTutorial::_internal_set_caption_url(const std::string& value) {
  
  caption_url_.Set(value, GetArenaForAllocation());
}
inline std::string* VideoTutorial::_internal_mutable_caption_url() {
  
  return caption_url_.Mutable(GetArenaForAllocation());
}
inline std::string* VideoTutorial::release_caption_url() {
  // @@protoc_insertion_point(field_release:video_tutorials.proto.VideoTutorial.caption_url)
  return caption_url_.Release();
}
inline void VideoTutorial::set_allocated_caption_url(std::string* caption_url) {
  if (caption_url != nullptr) {
    
  } else {
    
  }
  caption_url_.SetAllocated(caption_url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (caption_url_.IsDefault()) {
    caption_url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:video_tutorials.proto.VideoTutorial.caption_url)
}

// int64 video_length = 7;
inline void VideoTutorial::clear_video_length() {
  video_length_ = int64_t{0};
}
inline int64_t VideoTutorial::_internal_video_length() const {
  return video_length_;
}
inline int64_t VideoTutorial::video_length() const {
  // @@protoc_insertion_point(field_get:video_tutorials.proto.VideoTutorial.video_length)
  return _internal_video_length();
}
inline void VideoTutorial::_internal_set_video_length(int64_t value) {
  
  video_length_ = value;
}
inline void VideoTutorial::set_video_length(int64_t value) {
  _internal_set_video_length(value);
  // @@protoc_insertion_point(field_set:video_tutorials.proto.VideoTutorial.video_length)
}

// string animated_gif_url = 8;
inline void VideoTutorial::clear_animated_gif_url() {
  animated_gif_url_.ClearToEmpty();
}
inline const std::string& VideoTutorial::animated_gif_url() const {
  // @@protoc_insertion_point(field_get:video_tutorials.proto.VideoTutorial.animated_gif_url)
  return _internal_animated_gif_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VideoTutorial::set_animated_gif_url(ArgT0&& arg0, ArgT... args) {
 
 animated_gif_url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:video_tutorials.proto.VideoTutorial.animated_gif_url)
}
inline std::string* VideoTutorial::mutable_animated_gif_url() {
  std::string* _s = _internal_mutable_animated_gif_url();
  // @@protoc_insertion_point(field_mutable:video_tutorials.proto.VideoTutorial.animated_gif_url)
  return _s;
}
inline const std::string& VideoTutorial::_internal_animated_gif_url() const {
  return animated_gif_url_.Get();
}
inline void VideoTutorial::_internal_set_animated_gif_url(const std::string& value) {
  
  animated_gif_url_.Set(value, GetArenaForAllocation());
}
inline std::string* VideoTutorial::_internal_mutable_animated_gif_url() {
  
  return animated_gif_url_.Mutable(GetArenaForAllocation());
}
inline std::string* VideoTutorial::release_animated_gif_url() {
  // @@protoc_insertion_point(field_release:video_tutorials.proto.VideoTutorial.animated_gif_url)
  return animated_gif_url_.Release();
}
inline void VideoTutorial::set_allocated_animated_gif_url(std::string* animated_gif_url) {
  if (animated_gif_url != nullptr) {
    
  } else {
    
  }
  animated_gif_url_.SetAllocated(animated_gif_url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (animated_gif_url_.IsDefault()) {
    animated_gif_url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:video_tutorials.proto.VideoTutorial.animated_gif_url)
}

// string thumbnail_url = 9;
inline void VideoTutorial::clear_thumbnail_url() {
  thumbnail_url_.ClearToEmpty();
}
inline const std::string& VideoTutorial::thumbnail_url() const {
  // @@protoc_insertion_point(field_get:video_tutorials.proto.VideoTutorial.thumbnail_url)
  return _internal_thumbnail_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VideoTutorial::set_thumbnail_url(ArgT0&& arg0, ArgT... args) {
 
 thumbnail_url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:video_tutorials.proto.VideoTutorial.thumbnail_url)
}
inline std::string* VideoTutorial::mutable_thumbnail_url() {
  std::string* _s = _internal_mutable_thumbnail_url();
  // @@protoc_insertion_point(field_mutable:video_tutorials.proto.VideoTutorial.thumbnail_url)
  return _s;
}
inline const std::string& VideoTutorial::_internal_thumbnail_url() const {
  return thumbnail_url_.Get();
}
inline void VideoTutorial::_internal_set_thumbnail_url(const std::string& value) {
  
  thumbnail_url_.Set(value, GetArenaForAllocation());
}
inline std::string* VideoTutorial::_internal_mutable_thumbnail_url() {
  
  return thumbnail_url_.Mutable(GetArenaForAllocation());
}
inline std::string* VideoTutorial::release_thumbnail_url() {
  // @@protoc_insertion_point(field_release:video_tutorials.proto.VideoTutorial.thumbnail_url)
  return thumbnail_url_.Release();
}
inline void VideoTutorial::set_allocated_thumbnail_url(std::string* thumbnail_url) {
  if (thumbnail_url != nullptr) {
    
  } else {
    
  }
  thumbnail_url_.SetAllocated(thumbnail_url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (thumbnail_url_.IsDefault()) {
    thumbnail_url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:video_tutorials.proto.VideoTutorial.thumbnail_url)
}

// -------------------------------------------------------------------

// VideoTutorialGroups

// repeated .video_tutorials.proto.VideoTutorialGroup tutorial_groups = 1;
inline int VideoTutorialGroups::_internal_tutorial_groups_size() const {
  return tutorial_groups_.size();
}
inline int VideoTutorialGroups::tutorial_groups_size() const {
  return _internal_tutorial_groups_size();
}
inline void VideoTutorialGroups::clear_tutorial_groups() {
  tutorial_groups_.Clear();
}
inline ::video_tutorials::proto::VideoTutorialGroup* VideoTutorialGroups::mutable_tutorial_groups(int index) {
  // @@protoc_insertion_point(field_mutable:video_tutorials.proto.VideoTutorialGroups.tutorial_groups)
  return tutorial_groups_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::video_tutorials::proto::VideoTutorialGroup >*
VideoTutorialGroups::mutable_tutorial_groups() {
  // @@protoc_insertion_point(field_mutable_list:video_tutorials.proto.VideoTutorialGroups.tutorial_groups)
  return &tutorial_groups_;
}
inline const ::video_tutorials::proto::VideoTutorialGroup& VideoTutorialGroups::_internal_tutorial_groups(int index) const {
  return tutorial_groups_.Get(index);
}
inline const ::video_tutorials::proto::VideoTutorialGroup& VideoTutorialGroups::tutorial_groups(int index) const {
  // @@protoc_insertion_point(field_get:video_tutorials.proto.VideoTutorialGroups.tutorial_groups)
  return _internal_tutorial_groups(index);
}
inline ::video_tutorials::proto::VideoTutorialGroup* VideoTutorialGroups::_internal_add_tutorial_groups() {
  return tutorial_groups_.Add();
}
inline ::video_tutorials::proto::VideoTutorialGroup* VideoTutorialGroups::add_tutorial_groups() {
  ::video_tutorials::proto::VideoTutorialGroup* _add = _internal_add_tutorial_groups();
  // @@protoc_insertion_point(field_add:video_tutorials.proto.VideoTutorialGroups.tutorial_groups)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::video_tutorials::proto::VideoTutorialGroup >&
VideoTutorialGroups::tutorial_groups() const {
  // @@protoc_insertion_point(field_list:video_tutorials.proto.VideoTutorialGroups.tutorial_groups)
  return tutorial_groups_;
}

// string text_locale = 2;
inline void VideoTutorialGroups::clear_text_locale() {
  text_locale_.ClearToEmpty();
}
inline const std::string& VideoTutorialGroups::text_locale() const {
  // @@protoc_insertion_point(field_get:video_tutorials.proto.VideoTutorialGroups.text_locale)
  return _internal_text_locale();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VideoTutorialGroups::set_text_locale(ArgT0&& arg0, ArgT... args) {
 
 text_locale_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:video_tutorials.proto.VideoTutorialGroups.text_locale)
}
inline std::string* VideoTutorialGroups::mutable_text_locale() {
  std::string* _s = _internal_mutable_text_locale();
  // @@protoc_insertion_point(field_mutable:video_tutorials.proto.VideoTutorialGroups.text_locale)
  return _s;
}
inline const std::string& VideoTutorialGroups::_internal_text_locale() const {
  return text_locale_.Get();
}
inline void VideoTutorialGroups::_internal_set_text_locale(const std::string& value) {
  
  text_locale_.Set(value, GetArenaForAllocation());
}
inline std::string* VideoTutorialGroups::_internal_mutable_text_locale() {
  
  return text_locale_.Mutable(GetArenaForAllocation());
}
inline std::string* VideoTutorialGroups::release_text_locale() {
  // @@protoc_insertion_point(field_release:video_tutorials.proto.VideoTutorialGroups.text_locale)
  return text_locale_.Release();
}
inline void VideoTutorialGroups::set_allocated_text_locale(std::string* text_locale) {
  if (text_locale != nullptr) {
    
  } else {
    
  }
  text_locale_.SetAllocated(text_locale, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (text_locale_.IsDefault()) {
    text_locale_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:video_tutorials.proto.VideoTutorialGroups.text_locale)
}

// string preferred_locale = 3;
inline void VideoTutorialGroups::clear_preferred_locale() {
  preferred_locale_.ClearToEmpty();
}
inline const std::string& VideoTutorialGroups::preferred_locale() const {
  // @@protoc_insertion_point(field_get:video_tutorials.proto.VideoTutorialGroups.preferred_locale)
  return _internal_preferred_locale();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VideoTutorialGroups::set_preferred_locale(ArgT0&& arg0, ArgT... args) {
 
 preferred_locale_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:video_tutorials.proto.VideoTutorialGroups.preferred_locale)
}
inline std::string* VideoTutorialGroups::mutable_preferred_locale() {
  std::string* _s = _internal_mutable_preferred_locale();
  // @@protoc_insertion_point(field_mutable:video_tutorials.proto.VideoTutorialGroups.preferred_locale)
  return _s;
}
inline const std::string& VideoTutorialGroups::_internal_preferred_locale() const {
  return preferred_locale_.Get();
}
inline void VideoTutorialGroups::_internal_set_preferred_locale(const std::string& value) {
  
  preferred_locale_.Set(value, GetArenaForAllocation());
}
inline std::string* VideoTutorialGroups::_internal_mutable_preferred_locale() {
  
  return preferred_locale_.Mutable(GetArenaForAllocation());
}
inline std::string* VideoTutorialGroups::release_preferred_locale() {
  // @@protoc_insertion_point(field_release:video_tutorials.proto.VideoTutorialGroups.preferred_locale)
  return preferred_locale_.Release();
}
inline void VideoTutorialGroups::set_allocated_preferred_locale(std::string* preferred_locale) {
  if (preferred_locale != nullptr) {
    
  } else {
    
  }
  preferred_locale_.SetAllocated(preferred_locale, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (preferred_locale_.IsDefault()) {
    preferred_locale_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:video_tutorials.proto.VideoTutorialGroups.preferred_locale)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto
}  // namespace video_tutorials

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::video_tutorials::proto::FeatureType> : ::std::true_type {};

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_video_5ftutorials_2eproto
