// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: sharing_message.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_sharing_5fmessage_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_sharing_5fmessage_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3020000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3020000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
#include "click_to_call_message.pb.h"
#include "optimization_guide_push_notification.pb.h"
#include "peer_connection_messages.pb.h"
#include "remote_copy_message.pb.h"
#include "shared_clipboard_message.pb.h"
#include "sms_fetch_message_test_proto3_optional.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_sharing_5fmessage_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_sharing_5fmessage_2eproto {
  static const uint32_t offsets[];
};
namespace chrome_browser_sharing {
class AckMessage;
struct AckMessageDefaultTypeInternal;
extern AckMessageDefaultTypeInternal _AckMessage_default_instance_;
class DiscoveryRequest;
struct DiscoveryRequestDefaultTypeInternal;
extern DiscoveryRequestDefaultTypeInternal _DiscoveryRequest_default_instance_;
class DiscoveryResponse;
struct DiscoveryResponseDefaultTypeInternal;
extern DiscoveryResponseDefaultTypeInternal _DiscoveryResponse_default_instance_;
class FCMChannelConfiguration;
struct FCMChannelConfigurationDefaultTypeInternal;
extern FCMChannelConfigurationDefaultTypeInternal _FCMChannelConfiguration_default_instance_;
class PingMessage;
struct PingMessageDefaultTypeInternal;
extern PingMessageDefaultTypeInternal _PingMessage_default_instance_;
class ResponseMessage;
struct ResponseMessageDefaultTypeInternal;
extern ResponseMessageDefaultTypeInternal _ResponseMessage_default_instance_;
class ServerChannelConfiguration;
struct ServerChannelConfigurationDefaultTypeInternal;
extern ServerChannelConfigurationDefaultTypeInternal _ServerChannelConfiguration_default_instance_;
class SharingMessage;
struct SharingMessageDefaultTypeInternal;
extern SharingMessageDefaultTypeInternal _SharingMessage_default_instance_;
class WebRtcMessage;
struct WebRtcMessageDefaultTypeInternal;
extern WebRtcMessageDefaultTypeInternal _WebRtcMessage_default_instance_;
class WebRtcSignalingMessage;
struct WebRtcSignalingMessageDefaultTypeInternal;
extern WebRtcSignalingMessageDefaultTypeInternal _WebRtcSignalingMessage_default_instance_;
}  // namespace chrome_browser_sharing
PROTOBUF_NAMESPACE_OPEN
template<> ::chrome_browser_sharing::AckMessage* Arena::CreateMaybeMessage<::chrome_browser_sharing::AckMessage>(Arena*);
template<> ::chrome_browser_sharing::DiscoveryRequest* Arena::CreateMaybeMessage<::chrome_browser_sharing::DiscoveryRequest>(Arena*);
template<> ::chrome_browser_sharing::DiscoveryResponse* Arena::CreateMaybeMessage<::chrome_browser_sharing::DiscoveryResponse>(Arena*);
template<> ::chrome_browser_sharing::FCMChannelConfiguration* Arena::CreateMaybeMessage<::chrome_browser_sharing::FCMChannelConfiguration>(Arena*);
template<> ::chrome_browser_sharing::PingMessage* Arena::CreateMaybeMessage<::chrome_browser_sharing::PingMessage>(Arena*);
template<> ::chrome_browser_sharing::ResponseMessage* Arena::CreateMaybeMessage<::chrome_browser_sharing::ResponseMessage>(Arena*);
template<> ::chrome_browser_sharing::ServerChannelConfiguration* Arena::CreateMaybeMessage<::chrome_browser_sharing::ServerChannelConfiguration>(Arena*);
template<> ::chrome_browser_sharing::SharingMessage* Arena::CreateMaybeMessage<::chrome_browser_sharing::SharingMessage>(Arena*);
template<> ::chrome_browser_sharing::WebRtcMessage* Arena::CreateMaybeMessage<::chrome_browser_sharing::WebRtcMessage>(Arena*);
template<> ::chrome_browser_sharing::WebRtcSignalingMessage* Arena::CreateMaybeMessage<::chrome_browser_sharing::WebRtcSignalingMessage>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace chrome_browser_sharing {

enum MessageType : int {
  UNKNOWN_MESSAGE = 0,
  PING_MESSAGE = 1,
  ACK_MESSAGE = 2,
  CLICK_TO_CALL_MESSAGE = 3,
  SHARED_CLIPBOARD_MESSAGE = 4,
  SMS_FETCH_REQUEST = 5,
  REMOTE_COPY_MESSAGE = 6,
  PEER_CONNECTION_OFFER_MESSAGE = 7,
  PEER_CONNECTION_ICE_CANDIDATES_MESSAGE = 8,
  DISCOVERY_REQUEST = 9,
  WEB_RTC_SIGNALING_FRAME = 10,
  OPTIMIZATION_GUIDE_PUSH_NOTIFICATION = 11,
  MessageType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  MessageType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool MessageType_IsValid(int value);
constexpr MessageType MessageType_MIN = UNKNOWN_MESSAGE;
constexpr MessageType MessageType_MAX = OPTIMIZATION_GUIDE_PUSH_NOTIFICATION;
constexpr int MessageType_ARRAYSIZE = MessageType_MAX + 1;

const std::string& MessageType_Name(MessageType value);
template<typename T>
inline const std::string& MessageType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MessageType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MessageType_Name.");
  return MessageType_Name(static_cast<MessageType>(enum_t_value));
}
bool MessageType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MessageType* value);
// ===================================================================

class SharingMessage final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:chrome_browser_sharing.SharingMessage) */ {
 public:
  inline SharingMessage() : SharingMessage(nullptr) {}
  ~SharingMessage() override;
  explicit PROTOBUF_CONSTEXPR SharingMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SharingMessage(const SharingMessage& from);
  SharingMessage(SharingMessage&& from) noexcept
    : SharingMessage() {
    *this = ::std::move(from);
  }

  inline SharingMessage& operator=(const SharingMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline SharingMessage& operator=(SharingMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const SharingMessage& default_instance() {
    return *internal_default_instance();
  }
  enum PayloadCase {
    kPingMessage = 2,
    kAckMessage = 3,
    kClickToCallMessage = 4,
    kSharedClipboardMessage = 5,
    kSmsFetchRequest = 8,
    kRemoteCopyMessage = 9,
    kPeerConnectionOfferMessage = 10,
    kPeerConnectionIceCandidatesMessage = 11,
    kDiscoveryRequest = 13,
    kWebRtcSignalingFrame = 14,
    kOptimizationGuidePushNotification = 16,
    PAYLOAD_NOT_SET = 0,
  };

  enum AckChannelConfigurationCase {
    kFcmChannelConfiguration = 6,
    kServerChannelConfiguration = 12,
    ACK_CHANNEL_CONFIGURATION_NOT_SET = 0,
  };

  static inline const SharingMessage* internal_default_instance() {
    return reinterpret_cast<const SharingMessage*>(
               &_SharingMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(SharingMessage& a, SharingMessage& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(SharingMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SharingMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SharingMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SharingMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const SharingMessage& from);
  void MergeFrom(const SharingMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SharingMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chrome_browser_sharing.SharingMessage";
  }
  protected:
  explicit SharingMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSenderGuidFieldNumber = 1,
    kSenderDeviceNameFieldNumber = 7,
    kMessageIdFieldNumber = 15,
    kPingMessageFieldNumber = 2,
    kAckMessageFieldNumber = 3,
    kClickToCallMessageFieldNumber = 4,
    kSharedClipboardMessageFieldNumber = 5,
    kSmsFetchRequestFieldNumber = 8,
    kRemoteCopyMessageFieldNumber = 9,
    kPeerConnectionOfferMessageFieldNumber = 10,
    kPeerConnectionIceCandidatesMessageFieldNumber = 11,
    kDiscoveryRequestFieldNumber = 13,
    kWebRtcSignalingFrameFieldNumber = 14,
    kOptimizationGuidePushNotificationFieldNumber = 16,
    kFcmChannelConfigurationFieldNumber = 6,
    kServerChannelConfigurationFieldNumber = 12,
  };
  // string sender_guid = 1;
  void clear_sender_guid();
  const std::string& sender_guid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sender_guid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sender_guid();
  PROTOBUF_NODISCARD std::string* release_sender_guid();
  void set_allocated_sender_guid(std::string* sender_guid);
  private:
  const std::string& _internal_sender_guid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sender_guid(const std::string& value);
  std::string* _internal_mutable_sender_guid();
  public:

  // string sender_device_name = 7;
  void clear_sender_device_name();
  const std::string& sender_device_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sender_device_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sender_device_name();
  PROTOBUF_NODISCARD std::string* release_sender_device_name();
  void set_allocated_sender_device_name(std::string* sender_device_name);
  private:
  const std::string& _internal_sender_device_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sender_device_name(const std::string& value);
  std::string* _internal_mutable_sender_device_name();
  public:

  // string message_id = 15;
  void clear_message_id();
  const std::string& message_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message_id();
  PROTOBUF_NODISCARD std::string* release_message_id();
  void set_allocated_message_id(std::string* message_id);
  private:
  const std::string& _internal_message_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message_id(const std::string& value);
  std::string* _internal_mutable_message_id();
  public:

  // .chrome_browser_sharing.PingMessage ping_message = 2;
  bool has_ping_message() const;
  private:
  bool _internal_has_ping_message() const;
  public:
  void clear_ping_message();
  const ::chrome_browser_sharing::PingMessage& ping_message() const;
  PROTOBUF_NODISCARD ::chrome_browser_sharing::PingMessage* release_ping_message();
  ::chrome_browser_sharing::PingMessage* mutable_ping_message();
  void set_allocated_ping_message(::chrome_browser_sharing::PingMessage* ping_message);
  private:
  const ::chrome_browser_sharing::PingMessage& _internal_ping_message() const;
  ::chrome_browser_sharing::PingMessage* _internal_mutable_ping_message();
  public:
  void unsafe_arena_set_allocated_ping_message(
      ::chrome_browser_sharing::PingMessage* ping_message);
  ::chrome_browser_sharing::PingMessage* unsafe_arena_release_ping_message();

  // .chrome_browser_sharing.AckMessage ack_message = 3;
  bool has_ack_message() const;
  private:
  bool _internal_has_ack_message() const;
  public:
  void clear_ack_message();
  const ::chrome_browser_sharing::AckMessage& ack_message() const;
  PROTOBUF_NODISCARD ::chrome_browser_sharing::AckMessage* release_ack_message();
  ::chrome_browser_sharing::AckMessage* mutable_ack_message();
  void set_allocated_ack_message(::chrome_browser_sharing::AckMessage* ack_message);
  private:
  const ::chrome_browser_sharing::AckMessage& _internal_ack_message() const;
  ::chrome_browser_sharing::AckMessage* _internal_mutable_ack_message();
  public:
  void unsafe_arena_set_allocated_ack_message(
      ::chrome_browser_sharing::AckMessage* ack_message);
  ::chrome_browser_sharing::AckMessage* unsafe_arena_release_ack_message();

  // .chrome_browser_sharing.ClickToCallMessage click_to_call_message = 4;
  bool has_click_to_call_message() const;
  private:
  bool _internal_has_click_to_call_message() const;
  public:
  void clear_click_to_call_message();
  const ::chrome_browser_sharing::ClickToCallMessage& click_to_call_message() const;
  PROTOBUF_NODISCARD ::chrome_browser_sharing::ClickToCallMessage* release_click_to_call_message();
  ::chrome_browser_sharing::ClickToCallMessage* mutable_click_to_call_message();
  void set_allocated_click_to_call_message(::chrome_browser_sharing::ClickToCallMessage* click_to_call_message);
  private:
  const ::chrome_browser_sharing::ClickToCallMessage& _internal_click_to_call_message() const;
  ::chrome_browser_sharing::ClickToCallMessage* _internal_mutable_click_to_call_message();
  public:
  void unsafe_arena_set_allocated_click_to_call_message(
      ::chrome_browser_sharing::ClickToCallMessage* click_to_call_message);
  ::chrome_browser_sharing::ClickToCallMessage* unsafe_arena_release_click_to_call_message();

  // .chrome_browser_sharing.SharedClipboardMessage shared_clipboard_message = 5;
  bool has_shared_clipboard_message() const;
  private:
  bool _internal_has_shared_clipboard_message() const;
  public:
  void clear_shared_clipboard_message();
  const ::chrome_browser_sharing::SharedClipboardMessage& shared_clipboard_message() const;
  PROTOBUF_NODISCARD ::chrome_browser_sharing::SharedClipboardMessage* release_shared_clipboard_message();
  ::chrome_browser_sharing::SharedClipboardMessage* mutable_shared_clipboard_message();
  void set_allocated_shared_clipboard_message(::chrome_browser_sharing::SharedClipboardMessage* shared_clipboard_message);
  private:
  const ::chrome_browser_sharing::SharedClipboardMessage& _internal_shared_clipboard_message() const;
  ::chrome_browser_sharing::SharedClipboardMessage* _internal_mutable_shared_clipboard_message();
  public:
  void unsafe_arena_set_allocated_shared_clipboard_message(
      ::chrome_browser_sharing::SharedClipboardMessage* shared_clipboard_message);
  ::chrome_browser_sharing::SharedClipboardMessage* unsafe_arena_release_shared_clipboard_message();

  // .chrome_browser_sharing.SmsFetchRequest sms_fetch_request = 8;
  bool has_sms_fetch_request() const;
  private:
  bool _internal_has_sms_fetch_request() const;
  public:
  void clear_sms_fetch_request();
  const ::chrome_browser_sharing::SmsFetchRequest& sms_fetch_request() const;
  PROTOBUF_NODISCARD ::chrome_browser_sharing::SmsFetchRequest* release_sms_fetch_request();
  ::chrome_browser_sharing::SmsFetchRequest* mutable_sms_fetch_request();
  void set_allocated_sms_fetch_request(::chrome_browser_sharing::SmsFetchRequest* sms_fetch_request);
  private:
  const ::chrome_browser_sharing::SmsFetchRequest& _internal_sms_fetch_request() const;
  ::chrome_browser_sharing::SmsFetchRequest* _internal_mutable_sms_fetch_request();
  public:
  void unsafe_arena_set_allocated_sms_fetch_request(
      ::chrome_browser_sharing::SmsFetchRequest* sms_fetch_request);
  ::chrome_browser_sharing::SmsFetchRequest* unsafe_arena_release_sms_fetch_request();

  // .chrome_browser_sharing.RemoteCopyMessage remote_copy_message = 9;
  bool has_remote_copy_message() const;
  private:
  bool _internal_has_remote_copy_message() const;
  public:
  void clear_remote_copy_message();
  const ::chrome_browser_sharing::RemoteCopyMessage& remote_copy_message() const;
  PROTOBUF_NODISCARD ::chrome_browser_sharing::RemoteCopyMessage* release_remote_copy_message();
  ::chrome_browser_sharing::RemoteCopyMessage* mutable_remote_copy_message();
  void set_allocated_remote_copy_message(::chrome_browser_sharing::RemoteCopyMessage* remote_copy_message);
  private:
  const ::chrome_browser_sharing::RemoteCopyMessage& _internal_remote_copy_message() const;
  ::chrome_browser_sharing::RemoteCopyMessage* _internal_mutable_remote_copy_message();
  public:
  void unsafe_arena_set_allocated_remote_copy_message(
      ::chrome_browser_sharing::RemoteCopyMessage* remote_copy_message);
  ::chrome_browser_sharing::RemoteCopyMessage* unsafe_arena_release_remote_copy_message();

  // .chrome_browser_sharing.PeerConnectionOfferMessage peer_connection_offer_message = 10;
  bool has_peer_connection_offer_message() const;
  private:
  bool _internal_has_peer_connection_offer_message() const;
  public:
  void clear_peer_connection_offer_message();
  const ::chrome_browser_sharing::PeerConnectionOfferMessage& peer_connection_offer_message() const;
  PROTOBUF_NODISCARD ::chrome_browser_sharing::PeerConnectionOfferMessage* release_peer_connection_offer_message();
  ::chrome_browser_sharing::PeerConnectionOfferMessage* mutable_peer_connection_offer_message();
  void set_allocated_peer_connection_offer_message(::chrome_browser_sharing::PeerConnectionOfferMessage* peer_connection_offer_message);
  private:
  const ::chrome_browser_sharing::PeerConnectionOfferMessage& _internal_peer_connection_offer_message() const;
  ::chrome_browser_sharing::PeerConnectionOfferMessage* _internal_mutable_peer_connection_offer_message();
  public:
  void unsafe_arena_set_allocated_peer_connection_offer_message(
      ::chrome_browser_sharing::PeerConnectionOfferMessage* peer_connection_offer_message);
  ::chrome_browser_sharing::PeerConnectionOfferMessage* unsafe_arena_release_peer_connection_offer_message();

  // .chrome_browser_sharing.PeerConnectionIceCandidatesMessage peer_connection_ice_candidates_message = 11;
  bool has_peer_connection_ice_candidates_message() const;
  private:
  bool _internal_has_peer_connection_ice_candidates_message() const;
  public:
  void clear_peer_connection_ice_candidates_message();
  const ::chrome_browser_sharing::PeerConnectionIceCandidatesMessage& peer_connection_ice_candidates_message() const;
  PROTOBUF_NODISCARD ::chrome_browser_sharing::PeerConnectionIceCandidatesMessage* release_peer_connection_ice_candidates_message();
  ::chrome_browser_sharing::PeerConnectionIceCandidatesMessage* mutable_peer_connection_ice_candidates_message();
  void set_allocated_peer_connection_ice_candidates_message(::chrome_browser_sharing::PeerConnectionIceCandidatesMessage* peer_connection_ice_candidates_message);
  private:
  const ::chrome_browser_sharing::PeerConnectionIceCandidatesMessage& _internal_peer_connection_ice_candidates_message() const;
  ::chrome_browser_sharing::PeerConnectionIceCandidatesMessage* _internal_mutable_peer_connection_ice_candidates_message();
  public:
  void unsafe_arena_set_allocated_peer_connection_ice_candidates_message(
      ::chrome_browser_sharing::PeerConnectionIceCandidatesMessage* peer_connection_ice_candidates_message);
  ::chrome_browser_sharing::PeerConnectionIceCandidatesMessage* unsafe_arena_release_peer_connection_ice_candidates_message();

  // .chrome_browser_sharing.DiscoveryRequest discovery_request = 13;
  bool has_discovery_request() const;
  private:
  bool _internal_has_discovery_request() const;
  public:
  void clear_discovery_request();
  const ::chrome_browser_sharing::DiscoveryRequest& discovery_request() const;
  PROTOBUF_NODISCARD ::chrome_browser_sharing::DiscoveryRequest* release_discovery_request();
  ::chrome_browser_sharing::DiscoveryRequest* mutable_discovery_request();
  void set_allocated_discovery_request(::chrome_browser_sharing::DiscoveryRequest* discovery_request);
  private:
  const ::chrome_browser_sharing::DiscoveryRequest& _internal_discovery_request() const;
  ::chrome_browser_sharing::DiscoveryRequest* _internal_mutable_discovery_request();
  public:
  void unsafe_arena_set_allocated_discovery_request(
      ::chrome_browser_sharing::DiscoveryRequest* discovery_request);
  ::chrome_browser_sharing::DiscoveryRequest* unsafe_arena_release_discovery_request();

  // .chrome_browser_sharing.WebRtcSignalingMessage web_rtc_signaling_frame = 14;
  bool has_web_rtc_signaling_frame() const;
  private:
  bool _internal_has_web_rtc_signaling_frame() const;
  public:
  void clear_web_rtc_signaling_frame();
  const ::chrome_browser_sharing::WebRtcSignalingMessage& web_rtc_signaling_frame() const;
  PROTOBUF_NODISCARD ::chrome_browser_sharing::WebRtcSignalingMessage* release_web_rtc_signaling_frame();
  ::chrome_browser_sharing::WebRtcSignalingMessage* mutable_web_rtc_signaling_frame();
  void set_allocated_web_rtc_signaling_frame(::chrome_browser_sharing::WebRtcSignalingMessage* web_rtc_signaling_frame);
  private:
  const ::chrome_browser_sharing::WebRtcSignalingMessage& _internal_web_rtc_signaling_frame() const;
  ::chrome_browser_sharing::WebRtcSignalingMessage* _internal_mutable_web_rtc_signaling_frame();
  public:
  void unsafe_arena_set_allocated_web_rtc_signaling_frame(
      ::chrome_browser_sharing::WebRtcSignalingMessage* web_rtc_signaling_frame);
  ::chrome_browser_sharing::WebRtcSignalingMessage* unsafe_arena_release_web_rtc_signaling_frame();

  // .chrome_browser_sharing.OptimizationGuidePushNotification optimization_guide_push_notification = 16;
  bool has_optimization_guide_push_notification() const;
  private:
  bool _internal_has_optimization_guide_push_notification() const;
  public:
  void clear_optimization_guide_push_notification();
  const ::chrome_browser_sharing::OptimizationGuidePushNotification& optimization_guide_push_notification() const;
  PROTOBUF_NODISCARD ::chrome_browser_sharing::OptimizationGuidePushNotification* release_optimization_guide_push_notification();
  ::chrome_browser_sharing::OptimizationGuidePushNotification* mutable_optimization_guide_push_notification();
  void set_allocated_optimization_guide_push_notification(::chrome_browser_sharing::OptimizationGuidePushNotification* optimization_guide_push_notification);
  private:
  const ::chrome_browser_sharing::OptimizationGuidePushNotification& _internal_optimization_guide_push_notification() const;
  ::chrome_browser_sharing::OptimizationGuidePushNotification* _internal_mutable_optimization_guide_push_notification();
  public:
  void unsafe_arena_set_allocated_optimization_guide_push_notification(
      ::chrome_browser_sharing::OptimizationGuidePushNotification* optimization_guide_push_notification);
  ::chrome_browser_sharing::OptimizationGuidePushNotification* unsafe_arena_release_optimization_guide_push_notification();

  // .chrome_browser_sharing.FCMChannelConfiguration fcm_channel_configuration = 6;
  bool has_fcm_channel_configuration() const;
  private:
  bool _internal_has_fcm_channel_configuration() const;
  public:
  void clear_fcm_channel_configuration();
  const ::chrome_browser_sharing::FCMChannelConfiguration& fcm_channel_configuration() const;
  PROTOBUF_NODISCARD ::chrome_browser_sharing::FCMChannelConfiguration* release_fcm_channel_configuration();
  ::chrome_browser_sharing::FCMChannelConfiguration* mutable_fcm_channel_configuration();
  void set_allocated_fcm_channel_configuration(::chrome_browser_sharing::FCMChannelConfiguration* fcm_channel_configuration);
  private:
  const ::chrome_browser_sharing::FCMChannelConfiguration& _internal_fcm_channel_configuration() const;
  ::chrome_browser_sharing::FCMChannelConfiguration* _internal_mutable_fcm_channel_configuration();
  public:
  void unsafe_arena_set_allocated_fcm_channel_configuration(
      ::chrome_browser_sharing::FCMChannelConfiguration* fcm_channel_configuration);
  ::chrome_browser_sharing::FCMChannelConfiguration* unsafe_arena_release_fcm_channel_configuration();

  // .chrome_browser_sharing.ServerChannelConfiguration server_channel_configuration = 12;
  bool has_server_channel_configuration() const;
  private:
  bool _internal_has_server_channel_configuration() const;
  public:
  void clear_server_channel_configuration();
  const ::chrome_browser_sharing::ServerChannelConfiguration& server_channel_configuration() const;
  PROTOBUF_NODISCARD ::chrome_browser_sharing::ServerChannelConfiguration* release_server_channel_configuration();
  ::chrome_browser_sharing::ServerChannelConfiguration* mutable_server_channel_configuration();
  void set_allocated_server_channel_configuration(::chrome_browser_sharing::ServerChannelConfiguration* server_channel_configuration);
  private:
  const ::chrome_browser_sharing::ServerChannelConfiguration& _internal_server_channel_configuration() const;
  ::chrome_browser_sharing::ServerChannelConfiguration* _internal_mutable_server_channel_configuration();
  public:
  void unsafe_arena_set_allocated_server_channel_configuration(
      ::chrome_browser_sharing::ServerChannelConfiguration* server_channel_configuration);
  ::chrome_browser_sharing::ServerChannelConfiguration* unsafe_arena_release_server_channel_configuration();

  void clear_payload();
  PayloadCase payload_case() const;
  void clear_ack_channel_configuration();
  AckChannelConfigurationCase ack_channel_configuration_case() const;
  // @@protoc_insertion_point(class_scope:chrome_browser_sharing.SharingMessage)
 private:
  class _Internal;
  void set_has_ping_message();
  void set_has_ack_message();
  void set_has_click_to_call_message();
  void set_has_shared_clipboard_message();
  void set_has_sms_fetch_request();
  void set_has_remote_copy_message();
  void set_has_peer_connection_offer_message();
  void set_has_peer_connection_ice_candidates_message();
  void set_has_discovery_request();
  void set_has_web_rtc_signaling_frame();
  void set_has_optimization_guide_push_notification();
  void set_has_fcm_channel_configuration();
  void set_has_server_channel_configuration();

  inline bool has_payload() const;
  inline void clear_has_payload();

  inline bool has_ack_channel_configuration() const;
  inline void clear_has_ack_channel_configuration();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sender_guid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sender_device_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_id_;
  union PayloadUnion {
    constexpr PayloadUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::chrome_browser_sharing::PingMessage* ping_message_;
    ::chrome_browser_sharing::AckMessage* ack_message_;
    ::chrome_browser_sharing::ClickToCallMessage* click_to_call_message_;
    ::chrome_browser_sharing::SharedClipboardMessage* shared_clipboard_message_;
    ::chrome_browser_sharing::SmsFetchRequest* sms_fetch_request_;
    ::chrome_browser_sharing::RemoteCopyMessage* remote_copy_message_;
    ::chrome_browser_sharing::PeerConnectionOfferMessage* peer_connection_offer_message_;
    ::chrome_browser_sharing::PeerConnectionIceCandidatesMessage* peer_connection_ice_candidates_message_;
    ::chrome_browser_sharing::DiscoveryRequest* discovery_request_;
    ::chrome_browser_sharing::WebRtcSignalingMessage* web_rtc_signaling_frame_;
    ::chrome_browser_sharing::OptimizationGuidePushNotification* optimization_guide_push_notification_;
  } payload_;
  union AckChannelConfigurationUnion {
    constexpr AckChannelConfigurationUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::chrome_browser_sharing::FCMChannelConfiguration* fcm_channel_configuration_;
    ::chrome_browser_sharing::ServerChannelConfiguration* server_channel_configuration_;
  } ack_channel_configuration_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[2];

  friend struct ::TableStruct_sharing_5fmessage_2eproto;
};
// -------------------------------------------------------------------

class PingMessage final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:chrome_browser_sharing.PingMessage) */ {
 public:
  inline PingMessage() : PingMessage(nullptr) {}
  ~PingMessage() override;
  explicit PROTOBUF_CONSTEXPR PingMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PingMessage(const PingMessage& from);
  PingMessage(PingMessage&& from) noexcept
    : PingMessage() {
    *this = ::std::move(from);
  }

  inline PingMessage& operator=(const PingMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline PingMessage& operator=(PingMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const PingMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const PingMessage* internal_default_instance() {
    return reinterpret_cast<const PingMessage*>(
               &_PingMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(PingMessage& a, PingMessage& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(PingMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PingMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PingMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PingMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const PingMessage& from);
  void MergeFrom(const PingMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PingMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chrome_browser_sharing.PingMessage";
  }
  protected:
  explicit PingMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:chrome_browser_sharing.PingMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sharing_5fmessage_2eproto;
};
// -------------------------------------------------------------------

class AckMessage final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:chrome_browser_sharing.AckMessage) */ {
 public:
  inline AckMessage() : AckMessage(nullptr) {}
  ~AckMessage() override;
  explicit PROTOBUF_CONSTEXPR AckMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AckMessage(const AckMessage& from);
  AckMessage(AckMessage&& from) noexcept
    : AckMessage() {
    *this = ::std::move(from);
  }

  inline AckMessage& operator=(const AckMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline AckMessage& operator=(AckMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const AckMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const AckMessage* internal_default_instance() {
    return reinterpret_cast<const AckMessage*>(
               &_AckMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(AckMessage& a, AckMessage& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(AckMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AckMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AckMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AckMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const AckMessage& from);
  void MergeFrom(const AckMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AckMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chrome_browser_sharing.AckMessage";
  }
  protected:
  explicit AckMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOriginalMessageIdFieldNumber = 1,
    kResponseMessageFieldNumber = 3,
  };
  // string original_message_id = 1;
  void clear_original_message_id();
  const std::string& original_message_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_original_message_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_original_message_id();
  PROTOBUF_NODISCARD std::string* release_original_message_id();
  void set_allocated_original_message_id(std::string* original_message_id);
  private:
  const std::string& _internal_original_message_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_original_message_id(const std::string& value);
  std::string* _internal_mutable_original_message_id();
  public:

  // .chrome_browser_sharing.ResponseMessage response_message = 3;
  bool has_response_message() const;
  private:
  bool _internal_has_response_message() const;
  public:
  void clear_response_message();
  const ::chrome_browser_sharing::ResponseMessage& response_message() const;
  PROTOBUF_NODISCARD ::chrome_browser_sharing::ResponseMessage* release_response_message();
  ::chrome_browser_sharing::ResponseMessage* mutable_response_message();
  void set_allocated_response_message(::chrome_browser_sharing::ResponseMessage* response_message);
  private:
  const ::chrome_browser_sharing::ResponseMessage& _internal_response_message() const;
  ::chrome_browser_sharing::ResponseMessage* _internal_mutable_response_message();
  public:
  void unsafe_arena_set_allocated_response_message(
      ::chrome_browser_sharing::ResponseMessage* response_message);
  ::chrome_browser_sharing::ResponseMessage* unsafe_arena_release_response_message();

  // @@protoc_insertion_point(class_scope:chrome_browser_sharing.AckMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr original_message_id_;
  ::chrome_browser_sharing::ResponseMessage* response_message_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sharing_5fmessage_2eproto;
};
// -------------------------------------------------------------------

class ResponseMessage final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:chrome_browser_sharing.ResponseMessage) */ {
 public:
  inline ResponseMessage() : ResponseMessage(nullptr) {}
  ~ResponseMessage() override;
  explicit PROTOBUF_CONSTEXPR ResponseMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResponseMessage(const ResponseMessage& from);
  ResponseMessage(ResponseMessage&& from) noexcept
    : ResponseMessage() {
    *this = ::std::move(from);
  }

  inline ResponseMessage& operator=(const ResponseMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResponseMessage& operator=(ResponseMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ResponseMessage& default_instance() {
    return *internal_default_instance();
  }
  enum PayloadCase {
    kSmsFetchResponse = 1,
    kPeerConnectionAnswerMessageResponse = 2,
    kDiscoveryResponse = 3,
    PAYLOAD_NOT_SET = 0,
  };

  static inline const ResponseMessage* internal_default_instance() {
    return reinterpret_cast<const ResponseMessage*>(
               &_ResponseMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ResponseMessage& a, ResponseMessage& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(ResponseMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResponseMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResponseMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResponseMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ResponseMessage& from);
  void MergeFrom(const ResponseMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ResponseMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chrome_browser_sharing.ResponseMessage";
  }
  protected:
  explicit ResponseMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSmsFetchResponseFieldNumber = 1,
    kPeerConnectionAnswerMessageResponseFieldNumber = 2,
    kDiscoveryResponseFieldNumber = 3,
  };
  // .chrome_browser_sharing.SmsFetchResponse sms_fetch_response = 1;
  bool has_sms_fetch_response() const;
  private:
  bool _internal_has_sms_fetch_response() const;
  public:
  void clear_sms_fetch_response();
  const ::chrome_browser_sharing::SmsFetchResponse& sms_fetch_response() const;
  PROTOBUF_NODISCARD ::chrome_browser_sharing::SmsFetchResponse* release_sms_fetch_response();
  ::chrome_browser_sharing::SmsFetchResponse* mutable_sms_fetch_response();
  void set_allocated_sms_fetch_response(::chrome_browser_sharing::SmsFetchResponse* sms_fetch_response);
  private:
  const ::chrome_browser_sharing::SmsFetchResponse& _internal_sms_fetch_response() const;
  ::chrome_browser_sharing::SmsFetchResponse* _internal_mutable_sms_fetch_response();
  public:
  void unsafe_arena_set_allocated_sms_fetch_response(
      ::chrome_browser_sharing::SmsFetchResponse* sms_fetch_response);
  ::chrome_browser_sharing::SmsFetchResponse* unsafe_arena_release_sms_fetch_response();

  // .chrome_browser_sharing.PeerConnectionAnswerMessage peer_connection_answer_message_response = 2;
  bool has_peer_connection_answer_message_response() const;
  private:
  bool _internal_has_peer_connection_answer_message_response() const;
  public:
  void clear_peer_connection_answer_message_response();
  const ::chrome_browser_sharing::PeerConnectionAnswerMessage& peer_connection_answer_message_response() const;
  PROTOBUF_NODISCARD ::chrome_browser_sharing::PeerConnectionAnswerMessage* release_peer_connection_answer_message_response();
  ::chrome_browser_sharing::PeerConnectionAnswerMessage* mutable_peer_connection_answer_message_response();
  void set_allocated_peer_connection_answer_message_response(::chrome_browser_sharing::PeerConnectionAnswerMessage* peer_connection_answer_message_response);
  private:
  const ::chrome_browser_sharing::PeerConnectionAnswerMessage& _internal_peer_connection_answer_message_response() const;
  ::chrome_browser_sharing::PeerConnectionAnswerMessage* _internal_mutable_peer_connection_answer_message_response();
  public:
  void unsafe_arena_set_allocated_peer_connection_answer_message_response(
      ::chrome_browser_sharing::PeerConnectionAnswerMessage* peer_connection_answer_message_response);
  ::chrome_browser_sharing::PeerConnectionAnswerMessage* unsafe_arena_release_peer_connection_answer_message_response();

  // .chrome_browser_sharing.DiscoveryResponse discovery_response = 3;
  bool has_discovery_response() const;
  private:
  bool _internal_has_discovery_response() const;
  public:
  void clear_discovery_response();
  const ::chrome_browser_sharing::DiscoveryResponse& discovery_response() const;
  PROTOBUF_NODISCARD ::chrome_browser_sharing::DiscoveryResponse* release_discovery_response();
  ::chrome_browser_sharing::DiscoveryResponse* mutable_discovery_response();
  void set_allocated_discovery_response(::chrome_browser_sharing::DiscoveryResponse* discovery_response);
  private:
  const ::chrome_browser_sharing::DiscoveryResponse& _internal_discovery_response() const;
  ::chrome_browser_sharing::DiscoveryResponse* _internal_mutable_discovery_response();
  public:
  void unsafe_arena_set_allocated_discovery_response(
      ::chrome_browser_sharing::DiscoveryResponse* discovery_response);
  ::chrome_browser_sharing::DiscoveryResponse* unsafe_arena_release_discovery_response();

  void clear_payload();
  PayloadCase payload_case() const;
  // @@protoc_insertion_point(class_scope:chrome_browser_sharing.ResponseMessage)
 private:
  class _Internal;
  void set_has_sms_fetch_response();
  void set_has_peer_connection_answer_message_response();
  void set_has_discovery_response();

  inline bool has_payload() const;
  inline void clear_has_payload();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union PayloadUnion {
    constexpr PayloadUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::chrome_browser_sharing::SmsFetchResponse* sms_fetch_response_;
    ::chrome_browser_sharing::PeerConnectionAnswerMessage* peer_connection_answer_message_response_;
    ::chrome_browser_sharing::DiscoveryResponse* discovery_response_;
  } payload_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_sharing_5fmessage_2eproto;
};
// -------------------------------------------------------------------

class FCMChannelConfiguration final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:chrome_browser_sharing.FCMChannelConfiguration) */ {
 public:
  inline FCMChannelConfiguration() : FCMChannelConfiguration(nullptr) {}
  ~FCMChannelConfiguration() override;
  explicit PROTOBUF_CONSTEXPR FCMChannelConfiguration(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FCMChannelConfiguration(const FCMChannelConfiguration& from);
  FCMChannelConfiguration(FCMChannelConfiguration&& from) noexcept
    : FCMChannelConfiguration() {
    *this = ::std::move(from);
  }

  inline FCMChannelConfiguration& operator=(const FCMChannelConfiguration& from) {
    CopyFrom(from);
    return *this;
  }
  inline FCMChannelConfiguration& operator=(FCMChannelConfiguration&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const FCMChannelConfiguration& default_instance() {
    return *internal_default_instance();
  }
  static inline const FCMChannelConfiguration* internal_default_instance() {
    return reinterpret_cast<const FCMChannelConfiguration*>(
               &_FCMChannelConfiguration_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(FCMChannelConfiguration& a, FCMChannelConfiguration& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(FCMChannelConfiguration* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FCMChannelConfiguration* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FCMChannelConfiguration* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FCMChannelConfiguration>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const FCMChannelConfiguration& from);
  void MergeFrom(const FCMChannelConfiguration& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(FCMChannelConfiguration* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chrome_browser_sharing.FCMChannelConfiguration";
  }
  protected:
  explicit FCMChannelConfiguration(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVapidFcmTokenFieldNumber = 1,
    kVapidP256DhFieldNumber = 2,
    kVapidAuthSecretFieldNumber = 3,
    kSenderIdFcmTokenFieldNumber = 4,
    kSenderIdP256DhFieldNumber = 5,
    kSenderIdAuthSecretFieldNumber = 6,
  };
  // string vapid_fcm_token = 1;
  void clear_vapid_fcm_token();
  const std::string& vapid_fcm_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_vapid_fcm_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_vapid_fcm_token();
  PROTOBUF_NODISCARD std::string* release_vapid_fcm_token();
  void set_allocated_vapid_fcm_token(std::string* vapid_fcm_token);
  private:
  const std::string& _internal_vapid_fcm_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_vapid_fcm_token(const std::string& value);
  std::string* _internal_mutable_vapid_fcm_token();
  public:

  // bytes vapid_p256dh = 2;
  void clear_vapid_p256dh();
  const std::string& vapid_p256dh() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_vapid_p256dh(ArgT0&& arg0, ArgT... args);
  std::string* mutable_vapid_p256dh();
  PROTOBUF_NODISCARD std::string* release_vapid_p256dh();
  void set_allocated_vapid_p256dh(std::string* vapid_p256dh);
  private:
  const std::string& _internal_vapid_p256dh() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_vapid_p256dh(const std::string& value);
  std::string* _internal_mutable_vapid_p256dh();
  public:

  // bytes vapid_auth_secret = 3;
  void clear_vapid_auth_secret();
  const std::string& vapid_auth_secret() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_vapid_auth_secret(ArgT0&& arg0, ArgT... args);
  std::string* mutable_vapid_auth_secret();
  PROTOBUF_NODISCARD std::string* release_vapid_auth_secret();
  void set_allocated_vapid_auth_secret(std::string* vapid_auth_secret);
  private:
  const std::string& _internal_vapid_auth_secret() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_vapid_auth_secret(const std::string& value);
  std::string* _internal_mutable_vapid_auth_secret();
  public:

  // string sender_id_fcm_token = 4;
  void clear_sender_id_fcm_token();
  const std::string& sender_id_fcm_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sender_id_fcm_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sender_id_fcm_token();
  PROTOBUF_NODISCARD std::string* release_sender_id_fcm_token();
  void set_allocated_sender_id_fcm_token(std::string* sender_id_fcm_token);
  private:
  const std::string& _internal_sender_id_fcm_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sender_id_fcm_token(const std::string& value);
  std::string* _internal_mutable_sender_id_fcm_token();
  public:

  // bytes sender_id_p256dh = 5;
  void clear_sender_id_p256dh();
  const std::string& sender_id_p256dh() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sender_id_p256dh(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sender_id_p256dh();
  PROTOBUF_NODISCARD std::string* release_sender_id_p256dh();
  void set_allocated_sender_id_p256dh(std::string* sender_id_p256dh);
  private:
  const std::string& _internal_sender_id_p256dh() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sender_id_p256dh(const std::string& value);
  std::string* _internal_mutable_sender_id_p256dh();
  public:

  // bytes sender_id_auth_secret = 6;
  void clear_sender_id_auth_secret();
  const std::string& sender_id_auth_secret() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sender_id_auth_secret(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sender_id_auth_secret();
  PROTOBUF_NODISCARD std::string* release_sender_id_auth_secret();
  void set_allocated_sender_id_auth_secret(std::string* sender_id_auth_secret);
  private:
  const std::string& _internal_sender_id_auth_secret() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sender_id_auth_secret(const std::string& value);
  std::string* _internal_mutable_sender_id_auth_secret();
  public:

  // @@protoc_insertion_point(class_scope:chrome_browser_sharing.FCMChannelConfiguration)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr vapid_fcm_token_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr vapid_p256dh_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr vapid_auth_secret_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sender_id_fcm_token_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sender_id_p256dh_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sender_id_auth_secret_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sharing_5fmessage_2eproto;
};
// -------------------------------------------------------------------

class ServerChannelConfiguration final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:chrome_browser_sharing.ServerChannelConfiguration) */ {
 public:
  inline ServerChannelConfiguration() : ServerChannelConfiguration(nullptr) {}
  ~ServerChannelConfiguration() override;
  explicit PROTOBUF_CONSTEXPR ServerChannelConfiguration(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ServerChannelConfiguration(const ServerChannelConfiguration& from);
  ServerChannelConfiguration(ServerChannelConfiguration&& from) noexcept
    : ServerChannelConfiguration() {
    *this = ::std::move(from);
  }

  inline ServerChannelConfiguration& operator=(const ServerChannelConfiguration& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServerChannelConfiguration& operator=(ServerChannelConfiguration&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ServerChannelConfiguration& default_instance() {
    return *internal_default_instance();
  }
  static inline const ServerChannelConfiguration* internal_default_instance() {
    return reinterpret_cast<const ServerChannelConfiguration*>(
               &_ServerChannelConfiguration_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ServerChannelConfiguration& a, ServerChannelConfiguration& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(ServerChannelConfiguration* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ServerChannelConfiguration* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ServerChannelConfiguration* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ServerChannelConfiguration>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ServerChannelConfiguration& from);
  void MergeFrom(const ServerChannelConfiguration& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ServerChannelConfiguration* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chrome_browser_sharing.ServerChannelConfiguration";
  }
  protected:
  explicit ServerChannelConfiguration(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConfigurationFieldNumber = 3,
    kP256DhFieldNumber = 4,
    kAuthSecretFieldNumber = 5,
  };
  // bytes configuration = 3;
  void clear_configuration();
  const std::string& configuration() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_configuration(ArgT0&& arg0, ArgT... args);
  std::string* mutable_configuration();
  PROTOBUF_NODISCARD std::string* release_configuration();
  void set_allocated_configuration(std::string* configuration);
  private:
  const std::string& _internal_configuration() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_configuration(const std::string& value);
  std::string* _internal_mutable_configuration();
  public:

  // bytes p256dh = 4;
  void clear_p256dh();
  const std::string& p256dh() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_p256dh(ArgT0&& arg0, ArgT... args);
  std::string* mutable_p256dh();
  PROTOBUF_NODISCARD std::string* release_p256dh();
  void set_allocated_p256dh(std::string* p256dh);
  private:
  const std::string& _internal_p256dh() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_p256dh(const std::string& value);
  std::string* _internal_mutable_p256dh();
  public:

  // bytes auth_secret = 5;
  void clear_auth_secret();
  const std::string& auth_secret() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_auth_secret(ArgT0&& arg0, ArgT... args);
  std::string* mutable_auth_secret();
  PROTOBUF_NODISCARD std::string* release_auth_secret();
  void set_allocated_auth_secret(std::string* auth_secret);
  private:
  const std::string& _internal_auth_secret() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_auth_secret(const std::string& value);
  std::string* _internal_mutable_auth_secret();
  public:

  // @@protoc_insertion_point(class_scope:chrome_browser_sharing.ServerChannelConfiguration)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr configuration_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr p256dh_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr auth_secret_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sharing_5fmessage_2eproto;
};
// -------------------------------------------------------------------

class DiscoveryRequest final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:chrome_browser_sharing.DiscoveryRequest) */ {
 public:
  inline DiscoveryRequest() : DiscoveryRequest(nullptr) {}
  ~DiscoveryRequest() override;
  explicit PROTOBUF_CONSTEXPR DiscoveryRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DiscoveryRequest(const DiscoveryRequest& from);
  DiscoveryRequest(DiscoveryRequest&& from) noexcept
    : DiscoveryRequest() {
    *this = ::std::move(from);
  }

  inline DiscoveryRequest& operator=(const DiscoveryRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DiscoveryRequest& operator=(DiscoveryRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const DiscoveryRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DiscoveryRequest* internal_default_instance() {
    return reinterpret_cast<const DiscoveryRequest*>(
               &_DiscoveryRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(DiscoveryRequest& a, DiscoveryRequest& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(DiscoveryRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DiscoveryRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DiscoveryRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DiscoveryRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DiscoveryRequest& from);
  void MergeFrom(const DiscoveryRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DiscoveryRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chrome_browser_sharing.DiscoveryRequest";
  }
  protected:
  explicit DiscoveryRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServiceIdFieldNumber = 1,
  };
  // string service_id = 1;
  void clear_service_id();
  const std::string& service_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_service_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_service_id();
  PROTOBUF_NODISCARD std::string* release_service_id();
  void set_allocated_service_id(std::string* service_id);
  private:
  const std::string& _internal_service_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_service_id(const std::string& value);
  std::string* _internal_mutable_service_id();
  public:

  // @@protoc_insertion_point(class_scope:chrome_browser_sharing.DiscoveryRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr service_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sharing_5fmessage_2eproto;
};
// -------------------------------------------------------------------

class DiscoveryResponse final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:chrome_browser_sharing.DiscoveryResponse) */ {
 public:
  inline DiscoveryResponse() : DiscoveryResponse(nullptr) {}
  ~DiscoveryResponse() override;
  explicit PROTOBUF_CONSTEXPR DiscoveryResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DiscoveryResponse(const DiscoveryResponse& from);
  DiscoveryResponse(DiscoveryResponse&& from) noexcept
    : DiscoveryResponse() {
    *this = ::std::move(from);
  }

  inline DiscoveryResponse& operator=(const DiscoveryResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DiscoveryResponse& operator=(DiscoveryResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const DiscoveryResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DiscoveryResponse* internal_default_instance() {
    return reinterpret_cast<const DiscoveryResponse*>(
               &_DiscoveryResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(DiscoveryResponse& a, DiscoveryResponse& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(DiscoveryResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DiscoveryResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DiscoveryResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DiscoveryResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DiscoveryResponse& from);
  void MergeFrom(const DiscoveryResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DiscoveryResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chrome_browser_sharing.DiscoveryResponse";
  }
  protected:
  explicit DiscoveryResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServiceIdFieldNumber = 1,
    kEndpointIdFieldNumber = 2,
    kEndpointInfoFieldNumber = 3,
  };
  // string service_id = 1;
  void clear_service_id();
  const std::string& service_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_service_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_service_id();
  PROTOBUF_NODISCARD std::string* release_service_id();
  void set_allocated_service_id(std::string* service_id);
  private:
  const std::string& _internal_service_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_service_id(const std::string& value);
  std::string* _internal_mutable_service_id();
  public:

  // string endpoint_id = 2;
  void clear_endpoint_id();
  const std::string& endpoint_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_endpoint_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_endpoint_id();
  PROTOBUF_NODISCARD std::string* release_endpoint_id();
  void set_allocated_endpoint_id(std::string* endpoint_id);
  private:
  const std::string& _internal_endpoint_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_endpoint_id(const std::string& value);
  std::string* _internal_mutable_endpoint_id();
  public:

  // bytes endpoint_info = 3;
  void clear_endpoint_info();
  const std::string& endpoint_info() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_endpoint_info(ArgT0&& arg0, ArgT... args);
  std::string* mutable_endpoint_info();
  PROTOBUF_NODISCARD std::string* release_endpoint_info();
  void set_allocated_endpoint_info(std::string* endpoint_info);
  private:
  const std::string& _internal_endpoint_info() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_endpoint_info(const std::string& value);
  std::string* _internal_mutable_endpoint_info();
  public:

  // @@protoc_insertion_point(class_scope:chrome_browser_sharing.DiscoveryResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr service_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr endpoint_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr endpoint_info_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sharing_5fmessage_2eproto;
};
// -------------------------------------------------------------------

class WebRtcSignalingMessage final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:chrome_browser_sharing.WebRtcSignalingMessage) */ {
 public:
  inline WebRtcSignalingMessage() : WebRtcSignalingMessage(nullptr) {}
  ~WebRtcSignalingMessage() override;
  explicit PROTOBUF_CONSTEXPR WebRtcSignalingMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WebRtcSignalingMessage(const WebRtcSignalingMessage& from);
  WebRtcSignalingMessage(WebRtcSignalingMessage&& from) noexcept
    : WebRtcSignalingMessage() {
    *this = ::std::move(from);
  }

  inline WebRtcSignalingMessage& operator=(const WebRtcSignalingMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline WebRtcSignalingMessage& operator=(WebRtcSignalingMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const WebRtcSignalingMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const WebRtcSignalingMessage* internal_default_instance() {
    return reinterpret_cast<const WebRtcSignalingMessage*>(
               &_WebRtcSignalingMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(WebRtcSignalingMessage& a, WebRtcSignalingMessage& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(WebRtcSignalingMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WebRtcSignalingMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WebRtcSignalingMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WebRtcSignalingMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const WebRtcSignalingMessage& from);
  void MergeFrom(const WebRtcSignalingMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(WebRtcSignalingMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chrome_browser_sharing.WebRtcSignalingMessage";
  }
  protected:
  explicit WebRtcSignalingMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWebRtcSignalingFrameFieldNumber = 1,
  };
  // bytes web_rtc_signaling_frame = 1;
  void clear_web_rtc_signaling_frame();
  const std::string& web_rtc_signaling_frame() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_web_rtc_signaling_frame(ArgT0&& arg0, ArgT... args);
  std::string* mutable_web_rtc_signaling_frame();
  PROTOBUF_NODISCARD std::string* release_web_rtc_signaling_frame();
  void set_allocated_web_rtc_signaling_frame(std::string* web_rtc_signaling_frame);
  private:
  const std::string& _internal_web_rtc_signaling_frame() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_web_rtc_signaling_frame(const std::string& value);
  std::string* _internal_mutable_web_rtc_signaling_frame();
  public:

  // @@protoc_insertion_point(class_scope:chrome_browser_sharing.WebRtcSignalingMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr web_rtc_signaling_frame_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sharing_5fmessage_2eproto;
};
// -------------------------------------------------------------------

class WebRtcMessage final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:chrome_browser_sharing.WebRtcMessage) */ {
 public:
  inline WebRtcMessage() : WebRtcMessage(nullptr) {}
  ~WebRtcMessage() override;
  explicit PROTOBUF_CONSTEXPR WebRtcMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WebRtcMessage(const WebRtcMessage& from);
  WebRtcMessage(WebRtcMessage&& from) noexcept
    : WebRtcMessage() {
    *this = ::std::move(from);
  }

  inline WebRtcMessage& operator=(const WebRtcMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline WebRtcMessage& operator=(WebRtcMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const WebRtcMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const WebRtcMessage* internal_default_instance() {
    return reinterpret_cast<const WebRtcMessage*>(
               &_WebRtcMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(WebRtcMessage& a, WebRtcMessage& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(WebRtcMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WebRtcMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WebRtcMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WebRtcMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const WebRtcMessage& from);
  void MergeFrom(const WebRtcMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(WebRtcMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chrome_browser_sharing.WebRtcMessage";
  }
  protected:
  explicit WebRtcMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageGuidFieldNumber = 1,
    kMessageFieldNumber = 2,
  };
  // string message_guid = 1;
  void clear_message_guid();
  const std::string& message_guid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message_guid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message_guid();
  PROTOBUF_NODISCARD std::string* release_message_guid();
  void set_allocated_message_guid(std::string* message_guid);
  private:
  const std::string& _internal_message_guid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message_guid(const std::string& value);
  std::string* _internal_mutable_message_guid();
  public:

  // .chrome_browser_sharing.SharingMessage message = 2;
  bool has_message() const;
  private:
  bool _internal_has_message() const;
  public:
  void clear_message();
  const ::chrome_browser_sharing::SharingMessage& message() const;
  PROTOBUF_NODISCARD ::chrome_browser_sharing::SharingMessage* release_message();
  ::chrome_browser_sharing::SharingMessage* mutable_message();
  void set_allocated_message(::chrome_browser_sharing::SharingMessage* message);
  private:
  const ::chrome_browser_sharing::SharingMessage& _internal_message() const;
  ::chrome_browser_sharing::SharingMessage* _internal_mutable_message();
  public:
  void unsafe_arena_set_allocated_message(
      ::chrome_browser_sharing::SharingMessage* message);
  ::chrome_browser_sharing::SharingMessage* unsafe_arena_release_message();

  // @@protoc_insertion_point(class_scope:chrome_browser_sharing.WebRtcMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_guid_;
  ::chrome_browser_sharing::SharingMessage* message_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sharing_5fmessage_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// SharingMessage

// string sender_guid = 1;
inline void SharingMessage::clear_sender_guid() {
  sender_guid_.ClearToEmpty();
}
inline const std::string& SharingMessage::sender_guid() const {
  // @@protoc_insertion_point(field_get:chrome_browser_sharing.SharingMessage.sender_guid)
  return _internal_sender_guid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SharingMessage::set_sender_guid(ArgT0&& arg0, ArgT... args) {
 
 sender_guid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chrome_browser_sharing.SharingMessage.sender_guid)
}
inline std::string* SharingMessage::mutable_sender_guid() {
  std::string* _s = _internal_mutable_sender_guid();
  // @@protoc_insertion_point(field_mutable:chrome_browser_sharing.SharingMessage.sender_guid)
  return _s;
}
inline const std::string& SharingMessage::_internal_sender_guid() const {
  return sender_guid_.Get();
}
inline void SharingMessage::_internal_set_sender_guid(const std::string& value) {
  
  sender_guid_.Set(value, GetArenaForAllocation());
}
inline std::string* SharingMessage::_internal_mutable_sender_guid() {
  
  return sender_guid_.Mutable(GetArenaForAllocation());
}
inline std::string* SharingMessage::release_sender_guid() {
  // @@protoc_insertion_point(field_release:chrome_browser_sharing.SharingMessage.sender_guid)
  return sender_guid_.Release();
}
inline void SharingMessage::set_allocated_sender_guid(std::string* sender_guid) {
  if (sender_guid != nullptr) {
    
  } else {
    
  }
  sender_guid_.SetAllocated(sender_guid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (sender_guid_.IsDefault()) {
    sender_guid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chrome_browser_sharing.SharingMessage.sender_guid)
}

// .chrome_browser_sharing.PingMessage ping_message = 2;
inline bool SharingMessage::_internal_has_ping_message() const {
  return payload_case() == kPingMessage;
}
inline bool SharingMessage::has_ping_message() const {
  return _internal_has_ping_message();
}
inline void SharingMessage::set_has_ping_message() {
  _oneof_case_[0] = kPingMessage;
}
inline void SharingMessage::clear_ping_message() {
  if (_internal_has_ping_message()) {
    if (GetArenaForAllocation() == nullptr) {
      delete payload_.ping_message_;
    }
    clear_has_payload();
  }
}
inline ::chrome_browser_sharing::PingMessage* SharingMessage::release_ping_message() {
  // @@protoc_insertion_point(field_release:chrome_browser_sharing.SharingMessage.ping_message)
  if (_internal_has_ping_message()) {
    clear_has_payload();
    ::chrome_browser_sharing::PingMessage* temp = payload_.ping_message_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.ping_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::chrome_browser_sharing::PingMessage& SharingMessage::_internal_ping_message() const {
  return _internal_has_ping_message()
      ? *payload_.ping_message_
      : reinterpret_cast< ::chrome_browser_sharing::PingMessage&>(::chrome_browser_sharing::_PingMessage_default_instance_);
}
inline const ::chrome_browser_sharing::PingMessage& SharingMessage::ping_message() const {
  // @@protoc_insertion_point(field_get:chrome_browser_sharing.SharingMessage.ping_message)
  return _internal_ping_message();
}
inline ::chrome_browser_sharing::PingMessage* SharingMessage::unsafe_arena_release_ping_message() {
  // @@protoc_insertion_point(field_unsafe_arena_release:chrome_browser_sharing.SharingMessage.ping_message)
  if (_internal_has_ping_message()) {
    clear_has_payload();
    ::chrome_browser_sharing::PingMessage* temp = payload_.ping_message_;
    payload_.ping_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SharingMessage::unsafe_arena_set_allocated_ping_message(::chrome_browser_sharing::PingMessage* ping_message) {
  clear_payload();
  if (ping_message) {
    set_has_ping_message();
    payload_.ping_message_ = ping_message;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:chrome_browser_sharing.SharingMessage.ping_message)
}
inline ::chrome_browser_sharing::PingMessage* SharingMessage::_internal_mutable_ping_message() {
  if (!_internal_has_ping_message()) {
    clear_payload();
    set_has_ping_message();
    payload_.ping_message_ = CreateMaybeMessage< ::chrome_browser_sharing::PingMessage >(GetArenaForAllocation());
  }
  return payload_.ping_message_;
}
inline ::chrome_browser_sharing::PingMessage* SharingMessage::mutable_ping_message() {
  ::chrome_browser_sharing::PingMessage* _msg = _internal_mutable_ping_message();
  // @@protoc_insertion_point(field_mutable:chrome_browser_sharing.SharingMessage.ping_message)
  return _msg;
}

// .chrome_browser_sharing.AckMessage ack_message = 3;
inline bool SharingMessage::_internal_has_ack_message() const {
  return payload_case() == kAckMessage;
}
inline bool SharingMessage::has_ack_message() const {
  return _internal_has_ack_message();
}
inline void SharingMessage::set_has_ack_message() {
  _oneof_case_[0] = kAckMessage;
}
inline void SharingMessage::clear_ack_message() {
  if (_internal_has_ack_message()) {
    if (GetArenaForAllocation() == nullptr) {
      delete payload_.ack_message_;
    }
    clear_has_payload();
  }
}
inline ::chrome_browser_sharing::AckMessage* SharingMessage::release_ack_message() {
  // @@protoc_insertion_point(field_release:chrome_browser_sharing.SharingMessage.ack_message)
  if (_internal_has_ack_message()) {
    clear_has_payload();
    ::chrome_browser_sharing::AckMessage* temp = payload_.ack_message_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.ack_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::chrome_browser_sharing::AckMessage& SharingMessage::_internal_ack_message() const {
  return _internal_has_ack_message()
      ? *payload_.ack_message_
      : reinterpret_cast< ::chrome_browser_sharing::AckMessage&>(::chrome_browser_sharing::_AckMessage_default_instance_);
}
inline const ::chrome_browser_sharing::AckMessage& SharingMessage::ack_message() const {
  // @@protoc_insertion_point(field_get:chrome_browser_sharing.SharingMessage.ack_message)
  return _internal_ack_message();
}
inline ::chrome_browser_sharing::AckMessage* SharingMessage::unsafe_arena_release_ack_message() {
  // @@protoc_insertion_point(field_unsafe_arena_release:chrome_browser_sharing.SharingMessage.ack_message)
  if (_internal_has_ack_message()) {
    clear_has_payload();
    ::chrome_browser_sharing::AckMessage* temp = payload_.ack_message_;
    payload_.ack_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SharingMessage::unsafe_arena_set_allocated_ack_message(::chrome_browser_sharing::AckMessage* ack_message) {
  clear_payload();
  if (ack_message) {
    set_has_ack_message();
    payload_.ack_message_ = ack_message;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:chrome_browser_sharing.SharingMessage.ack_message)
}
inline ::chrome_browser_sharing::AckMessage* SharingMessage::_internal_mutable_ack_message() {
  if (!_internal_has_ack_message()) {
    clear_payload();
    set_has_ack_message();
    payload_.ack_message_ = CreateMaybeMessage< ::chrome_browser_sharing::AckMessage >(GetArenaForAllocation());
  }
  return payload_.ack_message_;
}
inline ::chrome_browser_sharing::AckMessage* SharingMessage::mutable_ack_message() {
  ::chrome_browser_sharing::AckMessage* _msg = _internal_mutable_ack_message();
  // @@protoc_insertion_point(field_mutable:chrome_browser_sharing.SharingMessage.ack_message)
  return _msg;
}

// .chrome_browser_sharing.ClickToCallMessage click_to_call_message = 4;
inline bool SharingMessage::_internal_has_click_to_call_message() const {
  return payload_case() == kClickToCallMessage;
}
inline bool SharingMessage::has_click_to_call_message() const {
  return _internal_has_click_to_call_message();
}
inline void SharingMessage::set_has_click_to_call_message() {
  _oneof_case_[0] = kClickToCallMessage;
}
inline ::chrome_browser_sharing::ClickToCallMessage* SharingMessage::release_click_to_call_message() {
  // @@protoc_insertion_point(field_release:chrome_browser_sharing.SharingMessage.click_to_call_message)
  if (_internal_has_click_to_call_message()) {
    clear_has_payload();
    ::chrome_browser_sharing::ClickToCallMessage* temp = payload_.click_to_call_message_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.click_to_call_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::chrome_browser_sharing::ClickToCallMessage& SharingMessage::_internal_click_to_call_message() const {
  return _internal_has_click_to_call_message()
      ? *payload_.click_to_call_message_
      : reinterpret_cast< ::chrome_browser_sharing::ClickToCallMessage&>(::chrome_browser_sharing::_ClickToCallMessage_default_instance_);
}
inline const ::chrome_browser_sharing::ClickToCallMessage& SharingMessage::click_to_call_message() const {
  // @@protoc_insertion_point(field_get:chrome_browser_sharing.SharingMessage.click_to_call_message)
  return _internal_click_to_call_message();
}
inline ::chrome_browser_sharing::ClickToCallMessage* SharingMessage::unsafe_arena_release_click_to_call_message() {
  // @@protoc_insertion_point(field_unsafe_arena_release:chrome_browser_sharing.SharingMessage.click_to_call_message)
  if (_internal_has_click_to_call_message()) {
    clear_has_payload();
    ::chrome_browser_sharing::ClickToCallMessage* temp = payload_.click_to_call_message_;
    payload_.click_to_call_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SharingMessage::unsafe_arena_set_allocated_click_to_call_message(::chrome_browser_sharing::ClickToCallMessage* click_to_call_message) {
  clear_payload();
  if (click_to_call_message) {
    set_has_click_to_call_message();
    payload_.click_to_call_message_ = click_to_call_message;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:chrome_browser_sharing.SharingMessage.click_to_call_message)
}
inline ::chrome_browser_sharing::ClickToCallMessage* SharingMessage::_internal_mutable_click_to_call_message() {
  if (!_internal_has_click_to_call_message()) {
    clear_payload();
    set_has_click_to_call_message();
    payload_.click_to_call_message_ = CreateMaybeMessage< ::chrome_browser_sharing::ClickToCallMessage >(GetArenaForAllocation());
  }
  return payload_.click_to_call_message_;
}
inline ::chrome_browser_sharing::ClickToCallMessage* SharingMessage::mutable_click_to_call_message() {
  ::chrome_browser_sharing::ClickToCallMessage* _msg = _internal_mutable_click_to_call_message();
  // @@protoc_insertion_point(field_mutable:chrome_browser_sharing.SharingMessage.click_to_call_message)
  return _msg;
}

// .chrome_browser_sharing.SharedClipboardMessage shared_clipboard_message = 5;
inline bool SharingMessage::_internal_has_shared_clipboard_message() const {
  return payload_case() == kSharedClipboardMessage;
}
inline bool SharingMessage::has_shared_clipboard_message() const {
  return _internal_has_shared_clipboard_message();
}
inline void SharingMessage::set_has_shared_clipboard_message() {
  _oneof_case_[0] = kSharedClipboardMessage;
}
inline ::chrome_browser_sharing::SharedClipboardMessage* SharingMessage::release_shared_clipboard_message() {
  // @@protoc_insertion_point(field_release:chrome_browser_sharing.SharingMessage.shared_clipboard_message)
  if (_internal_has_shared_clipboard_message()) {
    clear_has_payload();
    ::chrome_browser_sharing::SharedClipboardMessage* temp = payload_.shared_clipboard_message_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.shared_clipboard_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::chrome_browser_sharing::SharedClipboardMessage& SharingMessage::_internal_shared_clipboard_message() const {
  return _internal_has_shared_clipboard_message()
      ? *payload_.shared_clipboard_message_
      : reinterpret_cast< ::chrome_browser_sharing::SharedClipboardMessage&>(::chrome_browser_sharing::_SharedClipboardMessage_default_instance_);
}
inline const ::chrome_browser_sharing::SharedClipboardMessage& SharingMessage::shared_clipboard_message() const {
  // @@protoc_insertion_point(field_get:chrome_browser_sharing.SharingMessage.shared_clipboard_message)
  return _internal_shared_clipboard_message();
}
inline ::chrome_browser_sharing::SharedClipboardMessage* SharingMessage::unsafe_arena_release_shared_clipboard_message() {
  // @@protoc_insertion_point(field_unsafe_arena_release:chrome_browser_sharing.SharingMessage.shared_clipboard_message)
  if (_internal_has_shared_clipboard_message()) {
    clear_has_payload();
    ::chrome_browser_sharing::SharedClipboardMessage* temp = payload_.shared_clipboard_message_;
    payload_.shared_clipboard_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SharingMessage::unsafe_arena_set_allocated_shared_clipboard_message(::chrome_browser_sharing::SharedClipboardMessage* shared_clipboard_message) {
  clear_payload();
  if (shared_clipboard_message) {
    set_has_shared_clipboard_message();
    payload_.shared_clipboard_message_ = shared_clipboard_message;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:chrome_browser_sharing.SharingMessage.shared_clipboard_message)
}
inline ::chrome_browser_sharing::SharedClipboardMessage* SharingMessage::_internal_mutable_shared_clipboard_message() {
  if (!_internal_has_shared_clipboard_message()) {
    clear_payload();
    set_has_shared_clipboard_message();
    payload_.shared_clipboard_message_ = CreateMaybeMessage< ::chrome_browser_sharing::SharedClipboardMessage >(GetArenaForAllocation());
  }
  return payload_.shared_clipboard_message_;
}
inline ::chrome_browser_sharing::SharedClipboardMessage* SharingMessage::mutable_shared_clipboard_message() {
  ::chrome_browser_sharing::SharedClipboardMessage* _msg = _internal_mutable_shared_clipboard_message();
  // @@protoc_insertion_point(field_mutable:chrome_browser_sharing.SharingMessage.shared_clipboard_message)
  return _msg;
}

// .chrome_browser_sharing.SmsFetchRequest sms_fetch_request = 8;
inline bool SharingMessage::_internal_has_sms_fetch_request() const {
  return payload_case() == kSmsFetchRequest;
}
inline bool SharingMessage::has_sms_fetch_request() const {
  return _internal_has_sms_fetch_request();
}
inline void SharingMessage::set_has_sms_fetch_request() {
  _oneof_case_[0] = kSmsFetchRequest;
}
inline ::chrome_browser_sharing::SmsFetchRequest* SharingMessage::release_sms_fetch_request() {
  // @@protoc_insertion_point(field_release:chrome_browser_sharing.SharingMessage.sms_fetch_request)
  if (_internal_has_sms_fetch_request()) {
    clear_has_payload();
    ::chrome_browser_sharing::SmsFetchRequest* temp = payload_.sms_fetch_request_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.sms_fetch_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::chrome_browser_sharing::SmsFetchRequest& SharingMessage::_internal_sms_fetch_request() const {
  return _internal_has_sms_fetch_request()
      ? *payload_.sms_fetch_request_
      : reinterpret_cast< ::chrome_browser_sharing::SmsFetchRequest&>(::chrome_browser_sharing::_SmsFetchRequest_default_instance_);
}
inline const ::chrome_browser_sharing::SmsFetchRequest& SharingMessage::sms_fetch_request() const {
  // @@protoc_insertion_point(field_get:chrome_browser_sharing.SharingMessage.sms_fetch_request)
  return _internal_sms_fetch_request();
}
inline ::chrome_browser_sharing::SmsFetchRequest* SharingMessage::unsafe_arena_release_sms_fetch_request() {
  // @@protoc_insertion_point(field_unsafe_arena_release:chrome_browser_sharing.SharingMessage.sms_fetch_request)
  if (_internal_has_sms_fetch_request()) {
    clear_has_payload();
    ::chrome_browser_sharing::SmsFetchRequest* temp = payload_.sms_fetch_request_;
    payload_.sms_fetch_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SharingMessage::unsafe_arena_set_allocated_sms_fetch_request(::chrome_browser_sharing::SmsFetchRequest* sms_fetch_request) {
  clear_payload();
  if (sms_fetch_request) {
    set_has_sms_fetch_request();
    payload_.sms_fetch_request_ = sms_fetch_request;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:chrome_browser_sharing.SharingMessage.sms_fetch_request)
}
inline ::chrome_browser_sharing::SmsFetchRequest* SharingMessage::_internal_mutable_sms_fetch_request() {
  if (!_internal_has_sms_fetch_request()) {
    clear_payload();
    set_has_sms_fetch_request();
    payload_.sms_fetch_request_ = CreateMaybeMessage< ::chrome_browser_sharing::SmsFetchRequest >(GetArenaForAllocation());
  }
  return payload_.sms_fetch_request_;
}
inline ::chrome_browser_sharing::SmsFetchRequest* SharingMessage::mutable_sms_fetch_request() {
  ::chrome_browser_sharing::SmsFetchRequest* _msg = _internal_mutable_sms_fetch_request();
  // @@protoc_insertion_point(field_mutable:chrome_browser_sharing.SharingMessage.sms_fetch_request)
  return _msg;
}

// .chrome_browser_sharing.RemoteCopyMessage remote_copy_message = 9;
inline bool SharingMessage::_internal_has_remote_copy_message() const {
  return payload_case() == kRemoteCopyMessage;
}
inline bool SharingMessage::has_remote_copy_message() const {
  return _internal_has_remote_copy_message();
}
inline void SharingMessage::set_has_remote_copy_message() {
  _oneof_case_[0] = kRemoteCopyMessage;
}
inline ::chrome_browser_sharing::RemoteCopyMessage* SharingMessage::release_remote_copy_message() {
  // @@protoc_insertion_point(field_release:chrome_browser_sharing.SharingMessage.remote_copy_message)
  if (_internal_has_remote_copy_message()) {
    clear_has_payload();
    ::chrome_browser_sharing::RemoteCopyMessage* temp = payload_.remote_copy_message_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.remote_copy_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::chrome_browser_sharing::RemoteCopyMessage& SharingMessage::_internal_remote_copy_message() const {
  return _internal_has_remote_copy_message()
      ? *payload_.remote_copy_message_
      : reinterpret_cast< ::chrome_browser_sharing::RemoteCopyMessage&>(::chrome_browser_sharing::_RemoteCopyMessage_default_instance_);
}
inline const ::chrome_browser_sharing::RemoteCopyMessage& SharingMessage::remote_copy_message() const {
  // @@protoc_insertion_point(field_get:chrome_browser_sharing.SharingMessage.remote_copy_message)
  return _internal_remote_copy_message();
}
inline ::chrome_browser_sharing::RemoteCopyMessage* SharingMessage::unsafe_arena_release_remote_copy_message() {
  // @@protoc_insertion_point(field_unsafe_arena_release:chrome_browser_sharing.SharingMessage.remote_copy_message)
  if (_internal_has_remote_copy_message()) {
    clear_has_payload();
    ::chrome_browser_sharing::RemoteCopyMessage* temp = payload_.remote_copy_message_;
    payload_.remote_copy_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SharingMessage::unsafe_arena_set_allocated_remote_copy_message(::chrome_browser_sharing::RemoteCopyMessage* remote_copy_message) {
  clear_payload();
  if (remote_copy_message) {
    set_has_remote_copy_message();
    payload_.remote_copy_message_ = remote_copy_message;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:chrome_browser_sharing.SharingMessage.remote_copy_message)
}
inline ::chrome_browser_sharing::RemoteCopyMessage* SharingMessage::_internal_mutable_remote_copy_message() {
  if (!_internal_has_remote_copy_message()) {
    clear_payload();
    set_has_remote_copy_message();
    payload_.remote_copy_message_ = CreateMaybeMessage< ::chrome_browser_sharing::RemoteCopyMessage >(GetArenaForAllocation());
  }
  return payload_.remote_copy_message_;
}
inline ::chrome_browser_sharing::RemoteCopyMessage* SharingMessage::mutable_remote_copy_message() {
  ::chrome_browser_sharing::RemoteCopyMessage* _msg = _internal_mutable_remote_copy_message();
  // @@protoc_insertion_point(field_mutable:chrome_browser_sharing.SharingMessage.remote_copy_message)
  return _msg;
}

// .chrome_browser_sharing.PeerConnectionOfferMessage peer_connection_offer_message = 10;
inline bool SharingMessage::_internal_has_peer_connection_offer_message() const {
  return payload_case() == kPeerConnectionOfferMessage;
}
inline bool SharingMessage::has_peer_connection_offer_message() const {
  return _internal_has_peer_connection_offer_message();
}
inline void SharingMessage::set_has_peer_connection_offer_message() {
  _oneof_case_[0] = kPeerConnectionOfferMessage;
}
inline ::chrome_browser_sharing::PeerConnectionOfferMessage* SharingMessage::release_peer_connection_offer_message() {
  // @@protoc_insertion_point(field_release:chrome_browser_sharing.SharingMessage.peer_connection_offer_message)
  if (_internal_has_peer_connection_offer_message()) {
    clear_has_payload();
    ::chrome_browser_sharing::PeerConnectionOfferMessage* temp = payload_.peer_connection_offer_message_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.peer_connection_offer_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::chrome_browser_sharing::PeerConnectionOfferMessage& SharingMessage::_internal_peer_connection_offer_message() const {
  return _internal_has_peer_connection_offer_message()
      ? *payload_.peer_connection_offer_message_
      : reinterpret_cast< ::chrome_browser_sharing::PeerConnectionOfferMessage&>(::chrome_browser_sharing::_PeerConnectionOfferMessage_default_instance_);
}
inline const ::chrome_browser_sharing::PeerConnectionOfferMessage& SharingMessage::peer_connection_offer_message() const {
  // @@protoc_insertion_point(field_get:chrome_browser_sharing.SharingMessage.peer_connection_offer_message)
  return _internal_peer_connection_offer_message();
}
inline ::chrome_browser_sharing::PeerConnectionOfferMessage* SharingMessage::unsafe_arena_release_peer_connection_offer_message() {
  // @@protoc_insertion_point(field_unsafe_arena_release:chrome_browser_sharing.SharingMessage.peer_connection_offer_message)
  if (_internal_has_peer_connection_offer_message()) {
    clear_has_payload();
    ::chrome_browser_sharing::PeerConnectionOfferMessage* temp = payload_.peer_connection_offer_message_;
    payload_.peer_connection_offer_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SharingMessage::unsafe_arena_set_allocated_peer_connection_offer_message(::chrome_browser_sharing::PeerConnectionOfferMessage* peer_connection_offer_message) {
  clear_payload();
  if (peer_connection_offer_message) {
    set_has_peer_connection_offer_message();
    payload_.peer_connection_offer_message_ = peer_connection_offer_message;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:chrome_browser_sharing.SharingMessage.peer_connection_offer_message)
}
inline ::chrome_browser_sharing::PeerConnectionOfferMessage* SharingMessage::_internal_mutable_peer_connection_offer_message() {
  if (!_internal_has_peer_connection_offer_message()) {
    clear_payload();
    set_has_peer_connection_offer_message();
    payload_.peer_connection_offer_message_ = CreateMaybeMessage< ::chrome_browser_sharing::PeerConnectionOfferMessage >(GetArenaForAllocation());
  }
  return payload_.peer_connection_offer_message_;
}
inline ::chrome_browser_sharing::PeerConnectionOfferMessage* SharingMessage::mutable_peer_connection_offer_message() {
  ::chrome_browser_sharing::PeerConnectionOfferMessage* _msg = _internal_mutable_peer_connection_offer_message();
  // @@protoc_insertion_point(field_mutable:chrome_browser_sharing.SharingMessage.peer_connection_offer_message)
  return _msg;
}

// .chrome_browser_sharing.PeerConnectionIceCandidatesMessage peer_connection_ice_candidates_message = 11;
inline bool SharingMessage::_internal_has_peer_connection_ice_candidates_message() const {
  return payload_case() == kPeerConnectionIceCandidatesMessage;
}
inline bool SharingMessage::has_peer_connection_ice_candidates_message() const {
  return _internal_has_peer_connection_ice_candidates_message();
}
inline void SharingMessage::set_has_peer_connection_ice_candidates_message() {
  _oneof_case_[0] = kPeerConnectionIceCandidatesMessage;
}
inline ::chrome_browser_sharing::PeerConnectionIceCandidatesMessage* SharingMessage::release_peer_connection_ice_candidates_message() {
  // @@protoc_insertion_point(field_release:chrome_browser_sharing.SharingMessage.peer_connection_ice_candidates_message)
  if (_internal_has_peer_connection_ice_candidates_message()) {
    clear_has_payload();
    ::chrome_browser_sharing::PeerConnectionIceCandidatesMessage* temp = payload_.peer_connection_ice_candidates_message_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.peer_connection_ice_candidates_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::chrome_browser_sharing::PeerConnectionIceCandidatesMessage& SharingMessage::_internal_peer_connection_ice_candidates_message() const {
  return _internal_has_peer_connection_ice_candidates_message()
      ? *payload_.peer_connection_ice_candidates_message_
      : reinterpret_cast< ::chrome_browser_sharing::PeerConnectionIceCandidatesMessage&>(::chrome_browser_sharing::_PeerConnectionIceCandidatesMessage_default_instance_);
}
inline const ::chrome_browser_sharing::PeerConnectionIceCandidatesMessage& SharingMessage::peer_connection_ice_candidates_message() const {
  // @@protoc_insertion_point(field_get:chrome_browser_sharing.SharingMessage.peer_connection_ice_candidates_message)
  return _internal_peer_connection_ice_candidates_message();
}
inline ::chrome_browser_sharing::PeerConnectionIceCandidatesMessage* SharingMessage::unsafe_arena_release_peer_connection_ice_candidates_message() {
  // @@protoc_insertion_point(field_unsafe_arena_release:chrome_browser_sharing.SharingMessage.peer_connection_ice_candidates_message)
  if (_internal_has_peer_connection_ice_candidates_message()) {
    clear_has_payload();
    ::chrome_browser_sharing::PeerConnectionIceCandidatesMessage* temp = payload_.peer_connection_ice_candidates_message_;
    payload_.peer_connection_ice_candidates_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SharingMessage::unsafe_arena_set_allocated_peer_connection_ice_candidates_message(::chrome_browser_sharing::PeerConnectionIceCandidatesMessage* peer_connection_ice_candidates_message) {
  clear_payload();
  if (peer_connection_ice_candidates_message) {
    set_has_peer_connection_ice_candidates_message();
    payload_.peer_connection_ice_candidates_message_ = peer_connection_ice_candidates_message;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:chrome_browser_sharing.SharingMessage.peer_connection_ice_candidates_message)
}
inline ::chrome_browser_sharing::PeerConnectionIceCandidatesMessage* SharingMessage::_internal_mutable_peer_connection_ice_candidates_message() {
  if (!_internal_has_peer_connection_ice_candidates_message()) {
    clear_payload();
    set_has_peer_connection_ice_candidates_message();
    payload_.peer_connection_ice_candidates_message_ = CreateMaybeMessage< ::chrome_browser_sharing::PeerConnectionIceCandidatesMessage >(GetArenaForAllocation());
  }
  return payload_.peer_connection_ice_candidates_message_;
}
inline ::chrome_browser_sharing::PeerConnectionIceCandidatesMessage* SharingMessage::mutable_peer_connection_ice_candidates_message() {
  ::chrome_browser_sharing::PeerConnectionIceCandidatesMessage* _msg = _internal_mutable_peer_connection_ice_candidates_message();
  // @@protoc_insertion_point(field_mutable:chrome_browser_sharing.SharingMessage.peer_connection_ice_candidates_message)
  return _msg;
}

// .chrome_browser_sharing.DiscoveryRequest discovery_request = 13;
inline bool SharingMessage::_internal_has_discovery_request() const {
  return payload_case() == kDiscoveryRequest;
}
inline bool SharingMessage::has_discovery_request() const {
  return _internal_has_discovery_request();
}
inline void SharingMessage::set_has_discovery_request() {
  _oneof_case_[0] = kDiscoveryRequest;
}
inline void SharingMessage::clear_discovery_request() {
  if (_internal_has_discovery_request()) {
    if (GetArenaForAllocation() == nullptr) {
      delete payload_.discovery_request_;
    }
    clear_has_payload();
  }
}
inline ::chrome_browser_sharing::DiscoveryRequest* SharingMessage::release_discovery_request() {
  // @@protoc_insertion_point(field_release:chrome_browser_sharing.SharingMessage.discovery_request)
  if (_internal_has_discovery_request()) {
    clear_has_payload();
    ::chrome_browser_sharing::DiscoveryRequest* temp = payload_.discovery_request_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.discovery_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::chrome_browser_sharing::DiscoveryRequest& SharingMessage::_internal_discovery_request() const {
  return _internal_has_discovery_request()
      ? *payload_.discovery_request_
      : reinterpret_cast< ::chrome_browser_sharing::DiscoveryRequest&>(::chrome_browser_sharing::_DiscoveryRequest_default_instance_);
}
inline const ::chrome_browser_sharing::DiscoveryRequest& SharingMessage::discovery_request() const {
  // @@protoc_insertion_point(field_get:chrome_browser_sharing.SharingMessage.discovery_request)
  return _internal_discovery_request();
}
inline ::chrome_browser_sharing::DiscoveryRequest* SharingMessage::unsafe_arena_release_discovery_request() {
  // @@protoc_insertion_point(field_unsafe_arena_release:chrome_browser_sharing.SharingMessage.discovery_request)
  if (_internal_has_discovery_request()) {
    clear_has_payload();
    ::chrome_browser_sharing::DiscoveryRequest* temp = payload_.discovery_request_;
    payload_.discovery_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SharingMessage::unsafe_arena_set_allocated_discovery_request(::chrome_browser_sharing::DiscoveryRequest* discovery_request) {
  clear_payload();
  if (discovery_request) {
    set_has_discovery_request();
    payload_.discovery_request_ = discovery_request;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:chrome_browser_sharing.SharingMessage.discovery_request)
}
inline ::chrome_browser_sharing::DiscoveryRequest* SharingMessage::_internal_mutable_discovery_request() {
  if (!_internal_has_discovery_request()) {
    clear_payload();
    set_has_discovery_request();
    payload_.discovery_request_ = CreateMaybeMessage< ::chrome_browser_sharing::DiscoveryRequest >(GetArenaForAllocation());
  }
  return payload_.discovery_request_;
}
inline ::chrome_browser_sharing::DiscoveryRequest* SharingMessage::mutable_discovery_request() {
  ::chrome_browser_sharing::DiscoveryRequest* _msg = _internal_mutable_discovery_request();
  // @@protoc_insertion_point(field_mutable:chrome_browser_sharing.SharingMessage.discovery_request)
  return _msg;
}

// .chrome_browser_sharing.WebRtcSignalingMessage web_rtc_signaling_frame = 14;
inline bool SharingMessage::_internal_has_web_rtc_signaling_frame() const {
  return payload_case() == kWebRtcSignalingFrame;
}
inline bool SharingMessage::has_web_rtc_signaling_frame() const {
  return _internal_has_web_rtc_signaling_frame();
}
inline void SharingMessage::set_has_web_rtc_signaling_frame() {
  _oneof_case_[0] = kWebRtcSignalingFrame;
}
inline void SharingMessage::clear_web_rtc_signaling_frame() {
  if (_internal_has_web_rtc_signaling_frame()) {
    if (GetArenaForAllocation() == nullptr) {
      delete payload_.web_rtc_signaling_frame_;
    }
    clear_has_payload();
  }
}
inline ::chrome_browser_sharing::WebRtcSignalingMessage* SharingMessage::release_web_rtc_signaling_frame() {
  // @@protoc_insertion_point(field_release:chrome_browser_sharing.SharingMessage.web_rtc_signaling_frame)
  if (_internal_has_web_rtc_signaling_frame()) {
    clear_has_payload();
    ::chrome_browser_sharing::WebRtcSignalingMessage* temp = payload_.web_rtc_signaling_frame_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.web_rtc_signaling_frame_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::chrome_browser_sharing::WebRtcSignalingMessage& SharingMessage::_internal_web_rtc_signaling_frame() const {
  return _internal_has_web_rtc_signaling_frame()
      ? *payload_.web_rtc_signaling_frame_
      : reinterpret_cast< ::chrome_browser_sharing::WebRtcSignalingMessage&>(::chrome_browser_sharing::_WebRtcSignalingMessage_default_instance_);
}
inline const ::chrome_browser_sharing::WebRtcSignalingMessage& SharingMessage::web_rtc_signaling_frame() const {
  // @@protoc_insertion_point(field_get:chrome_browser_sharing.SharingMessage.web_rtc_signaling_frame)
  return _internal_web_rtc_signaling_frame();
}
inline ::chrome_browser_sharing::WebRtcSignalingMessage* SharingMessage::unsafe_arena_release_web_rtc_signaling_frame() {
  // @@protoc_insertion_point(field_unsafe_arena_release:chrome_browser_sharing.SharingMessage.web_rtc_signaling_frame)
  if (_internal_has_web_rtc_signaling_frame()) {
    clear_has_payload();
    ::chrome_browser_sharing::WebRtcSignalingMessage* temp = payload_.web_rtc_signaling_frame_;
    payload_.web_rtc_signaling_frame_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SharingMessage::unsafe_arena_set_allocated_web_rtc_signaling_frame(::chrome_browser_sharing::WebRtcSignalingMessage* web_rtc_signaling_frame) {
  clear_payload();
  if (web_rtc_signaling_frame) {
    set_has_web_rtc_signaling_frame();
    payload_.web_rtc_signaling_frame_ = web_rtc_signaling_frame;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:chrome_browser_sharing.SharingMessage.web_rtc_signaling_frame)
}
inline ::chrome_browser_sharing::WebRtcSignalingMessage* SharingMessage::_internal_mutable_web_rtc_signaling_frame() {
  if (!_internal_has_web_rtc_signaling_frame()) {
    clear_payload();
    set_has_web_rtc_signaling_frame();
    payload_.web_rtc_signaling_frame_ = CreateMaybeMessage< ::chrome_browser_sharing::WebRtcSignalingMessage >(GetArenaForAllocation());
  }
  return payload_.web_rtc_signaling_frame_;
}
inline ::chrome_browser_sharing::WebRtcSignalingMessage* SharingMessage::mutable_web_rtc_signaling_frame() {
  ::chrome_browser_sharing::WebRtcSignalingMessage* _msg = _internal_mutable_web_rtc_signaling_frame();
  // @@protoc_insertion_point(field_mutable:chrome_browser_sharing.SharingMessage.web_rtc_signaling_frame)
  return _msg;
}

// .chrome_browser_sharing.OptimizationGuidePushNotification optimization_guide_push_notification = 16;
inline bool SharingMessage::_internal_has_optimization_guide_push_notification() const {
  return payload_case() == kOptimizationGuidePushNotification;
}
inline bool SharingMessage::has_optimization_guide_push_notification() const {
  return _internal_has_optimization_guide_push_notification();
}
inline void SharingMessage::set_has_optimization_guide_push_notification() {
  _oneof_case_[0] = kOptimizationGuidePushNotification;
}
inline ::chrome_browser_sharing::OptimizationGuidePushNotification* SharingMessage::release_optimization_guide_push_notification() {
  // @@protoc_insertion_point(field_release:chrome_browser_sharing.SharingMessage.optimization_guide_push_notification)
  if (_internal_has_optimization_guide_push_notification()) {
    clear_has_payload();
    ::chrome_browser_sharing::OptimizationGuidePushNotification* temp = payload_.optimization_guide_push_notification_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.optimization_guide_push_notification_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::chrome_browser_sharing::OptimizationGuidePushNotification& SharingMessage::_internal_optimization_guide_push_notification() const {
  return _internal_has_optimization_guide_push_notification()
      ? *payload_.optimization_guide_push_notification_
      : reinterpret_cast< ::chrome_browser_sharing::OptimizationGuidePushNotification&>(::chrome_browser_sharing::_OptimizationGuidePushNotification_default_instance_);
}
inline const ::chrome_browser_sharing::OptimizationGuidePushNotification& SharingMessage::optimization_guide_push_notification() const {
  // @@protoc_insertion_point(field_get:chrome_browser_sharing.SharingMessage.optimization_guide_push_notification)
  return _internal_optimization_guide_push_notification();
}
inline ::chrome_browser_sharing::OptimizationGuidePushNotification* SharingMessage::unsafe_arena_release_optimization_guide_push_notification() {
  // @@protoc_insertion_point(field_unsafe_arena_release:chrome_browser_sharing.SharingMessage.optimization_guide_push_notification)
  if (_internal_has_optimization_guide_push_notification()) {
    clear_has_payload();
    ::chrome_browser_sharing::OptimizationGuidePushNotification* temp = payload_.optimization_guide_push_notification_;
    payload_.optimization_guide_push_notification_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SharingMessage::unsafe_arena_set_allocated_optimization_guide_push_notification(::chrome_browser_sharing::OptimizationGuidePushNotification* optimization_guide_push_notification) {
  clear_payload();
  if (optimization_guide_push_notification) {
    set_has_optimization_guide_push_notification();
    payload_.optimization_guide_push_notification_ = optimization_guide_push_notification;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:chrome_browser_sharing.SharingMessage.optimization_guide_push_notification)
}
inline ::chrome_browser_sharing::OptimizationGuidePushNotification* SharingMessage::_internal_mutable_optimization_guide_push_notification() {
  if (!_internal_has_optimization_guide_push_notification()) {
    clear_payload();
    set_has_optimization_guide_push_notification();
    payload_.optimization_guide_push_notification_ = CreateMaybeMessage< ::chrome_browser_sharing::OptimizationGuidePushNotification >(GetArenaForAllocation());
  }
  return payload_.optimization_guide_push_notification_;
}
inline ::chrome_browser_sharing::OptimizationGuidePushNotification* SharingMessage::mutable_optimization_guide_push_notification() {
  ::chrome_browser_sharing::OptimizationGuidePushNotification* _msg = _internal_mutable_optimization_guide_push_notification();
  // @@protoc_insertion_point(field_mutable:chrome_browser_sharing.SharingMessage.optimization_guide_push_notification)
  return _msg;
}

// .chrome_browser_sharing.FCMChannelConfiguration fcm_channel_configuration = 6;
inline bool SharingMessage::_internal_has_fcm_channel_configuration() const {
  return ack_channel_configuration_case() == kFcmChannelConfiguration;
}
inline bool SharingMessage::has_fcm_channel_configuration() const {
  return _internal_has_fcm_channel_configuration();
}
inline void SharingMessage::set_has_fcm_channel_configuration() {
  _oneof_case_[1] = kFcmChannelConfiguration;
}
inline void SharingMessage::clear_fcm_channel_configuration() {
  if (_internal_has_fcm_channel_configuration()) {
    if (GetArenaForAllocation() == nullptr) {
      delete ack_channel_configuration_.fcm_channel_configuration_;
    }
    clear_has_ack_channel_configuration();
  }
}
inline ::chrome_browser_sharing::FCMChannelConfiguration* SharingMessage::release_fcm_channel_configuration() {
  // @@protoc_insertion_point(field_release:chrome_browser_sharing.SharingMessage.fcm_channel_configuration)
  if (_internal_has_fcm_channel_configuration()) {
    clear_has_ack_channel_configuration();
    ::chrome_browser_sharing::FCMChannelConfiguration* temp = ack_channel_configuration_.fcm_channel_configuration_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    ack_channel_configuration_.fcm_channel_configuration_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::chrome_browser_sharing::FCMChannelConfiguration& SharingMessage::_internal_fcm_channel_configuration() const {
  return _internal_has_fcm_channel_configuration()
      ? *ack_channel_configuration_.fcm_channel_configuration_
      : reinterpret_cast< ::chrome_browser_sharing::FCMChannelConfiguration&>(::chrome_browser_sharing::_FCMChannelConfiguration_default_instance_);
}
inline const ::chrome_browser_sharing::FCMChannelConfiguration& SharingMessage::fcm_channel_configuration() const {
  // @@protoc_insertion_point(field_get:chrome_browser_sharing.SharingMessage.fcm_channel_configuration)
  return _internal_fcm_channel_configuration();
}
inline ::chrome_browser_sharing::FCMChannelConfiguration* SharingMessage::unsafe_arena_release_fcm_channel_configuration() {
  // @@protoc_insertion_point(field_unsafe_arena_release:chrome_browser_sharing.SharingMessage.fcm_channel_configuration)
  if (_internal_has_fcm_channel_configuration()) {
    clear_has_ack_channel_configuration();
    ::chrome_browser_sharing::FCMChannelConfiguration* temp = ack_channel_configuration_.fcm_channel_configuration_;
    ack_channel_configuration_.fcm_channel_configuration_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SharingMessage::unsafe_arena_set_allocated_fcm_channel_configuration(::chrome_browser_sharing::FCMChannelConfiguration* fcm_channel_configuration) {
  clear_ack_channel_configuration();
  if (fcm_channel_configuration) {
    set_has_fcm_channel_configuration();
    ack_channel_configuration_.fcm_channel_configuration_ = fcm_channel_configuration;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:chrome_browser_sharing.SharingMessage.fcm_channel_configuration)
}
inline ::chrome_browser_sharing::FCMChannelConfiguration* SharingMessage::_internal_mutable_fcm_channel_configuration() {
  if (!_internal_has_fcm_channel_configuration()) {
    clear_ack_channel_configuration();
    set_has_fcm_channel_configuration();
    ack_channel_configuration_.fcm_channel_configuration_ = CreateMaybeMessage< ::chrome_browser_sharing::FCMChannelConfiguration >(GetArenaForAllocation());
  }
  return ack_channel_configuration_.fcm_channel_configuration_;
}
inline ::chrome_browser_sharing::FCMChannelConfiguration* SharingMessage::mutable_fcm_channel_configuration() {
  ::chrome_browser_sharing::FCMChannelConfiguration* _msg = _internal_mutable_fcm_channel_configuration();
  // @@protoc_insertion_point(field_mutable:chrome_browser_sharing.SharingMessage.fcm_channel_configuration)
  return _msg;
}

// .chrome_browser_sharing.ServerChannelConfiguration server_channel_configuration = 12;
inline bool SharingMessage::_internal_has_server_channel_configuration() const {
  return ack_channel_configuration_case() == kServerChannelConfiguration;
}
inline bool SharingMessage::has_server_channel_configuration() const {
  return _internal_has_server_channel_configuration();
}
inline void SharingMessage::set_has_server_channel_configuration() {
  _oneof_case_[1] = kServerChannelConfiguration;
}
inline void SharingMessage::clear_server_channel_configuration() {
  if (_internal_has_server_channel_configuration()) {
    if (GetArenaForAllocation() == nullptr) {
      delete ack_channel_configuration_.server_channel_configuration_;
    }
    clear_has_ack_channel_configuration();
  }
}
inline ::chrome_browser_sharing::ServerChannelConfiguration* SharingMessage::release_server_channel_configuration() {
  // @@protoc_insertion_point(field_release:chrome_browser_sharing.SharingMessage.server_channel_configuration)
  if (_internal_has_server_channel_configuration()) {
    clear_has_ack_channel_configuration();
    ::chrome_browser_sharing::ServerChannelConfiguration* temp = ack_channel_configuration_.server_channel_configuration_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    ack_channel_configuration_.server_channel_configuration_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::chrome_browser_sharing::ServerChannelConfiguration& SharingMessage::_internal_server_channel_configuration() const {
  return _internal_has_server_channel_configuration()
      ? *ack_channel_configuration_.server_channel_configuration_
      : reinterpret_cast< ::chrome_browser_sharing::ServerChannelConfiguration&>(::chrome_browser_sharing::_ServerChannelConfiguration_default_instance_);
}
inline const ::chrome_browser_sharing::ServerChannelConfiguration& SharingMessage::server_channel_configuration() const {
  // @@protoc_insertion_point(field_get:chrome_browser_sharing.SharingMessage.server_channel_configuration)
  return _internal_server_channel_configuration();
}
inline ::chrome_browser_sharing::ServerChannelConfiguration* SharingMessage::unsafe_arena_release_server_channel_configuration() {
  // @@protoc_insertion_point(field_unsafe_arena_release:chrome_browser_sharing.SharingMessage.server_channel_configuration)
  if (_internal_has_server_channel_configuration()) {
    clear_has_ack_channel_configuration();
    ::chrome_browser_sharing::ServerChannelConfiguration* temp = ack_channel_configuration_.server_channel_configuration_;
    ack_channel_configuration_.server_channel_configuration_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SharingMessage::unsafe_arena_set_allocated_server_channel_configuration(::chrome_browser_sharing::ServerChannelConfiguration* server_channel_configuration) {
  clear_ack_channel_configuration();
  if (server_channel_configuration) {
    set_has_server_channel_configuration();
    ack_channel_configuration_.server_channel_configuration_ = server_channel_configuration;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:chrome_browser_sharing.SharingMessage.server_channel_configuration)
}
inline ::chrome_browser_sharing::ServerChannelConfiguration* SharingMessage::_internal_mutable_server_channel_configuration() {
  if (!_internal_has_server_channel_configuration()) {
    clear_ack_channel_configuration();
    set_has_server_channel_configuration();
    ack_channel_configuration_.server_channel_configuration_ = CreateMaybeMessage< ::chrome_browser_sharing::ServerChannelConfiguration >(GetArenaForAllocation());
  }
  return ack_channel_configuration_.server_channel_configuration_;
}
inline ::chrome_browser_sharing::ServerChannelConfiguration* SharingMessage::mutable_server_channel_configuration() {
  ::chrome_browser_sharing::ServerChannelConfiguration* _msg = _internal_mutable_server_channel_configuration();
  // @@protoc_insertion_point(field_mutable:chrome_browser_sharing.SharingMessage.server_channel_configuration)
  return _msg;
}

// string sender_device_name = 7;
inline void SharingMessage::clear_sender_device_name() {
  sender_device_name_.ClearToEmpty();
}
inline const std::string& SharingMessage::sender_device_name() const {
  // @@protoc_insertion_point(field_get:chrome_browser_sharing.SharingMessage.sender_device_name)
  return _internal_sender_device_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SharingMessage::set_sender_device_name(ArgT0&& arg0, ArgT... args) {
 
 sender_device_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chrome_browser_sharing.SharingMessage.sender_device_name)
}
inline std::string* SharingMessage::mutable_sender_device_name() {
  std::string* _s = _internal_mutable_sender_device_name();
  // @@protoc_insertion_point(field_mutable:chrome_browser_sharing.SharingMessage.sender_device_name)
  return _s;
}
inline const std::string& SharingMessage::_internal_sender_device_name() const {
  return sender_device_name_.Get();
}
inline void SharingMessage::_internal_set_sender_device_name(const std::string& value) {
  
  sender_device_name_.Set(value, GetArenaForAllocation());
}
inline std::string* SharingMessage::_internal_mutable_sender_device_name() {
  
  return sender_device_name_.Mutable(GetArenaForAllocation());
}
inline std::string* SharingMessage::release_sender_device_name() {
  // @@protoc_insertion_point(field_release:chrome_browser_sharing.SharingMessage.sender_device_name)
  return sender_device_name_.Release();
}
inline void SharingMessage::set_allocated_sender_device_name(std::string* sender_device_name) {
  if (sender_device_name != nullptr) {
    
  } else {
    
  }
  sender_device_name_.SetAllocated(sender_device_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (sender_device_name_.IsDefault()) {
    sender_device_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chrome_browser_sharing.SharingMessage.sender_device_name)
}

// string message_id = 15;
inline void SharingMessage::clear_message_id() {
  message_id_.ClearToEmpty();
}
inline const std::string& SharingMessage::message_id() const {
  // @@protoc_insertion_point(field_get:chrome_browser_sharing.SharingMessage.message_id)
  return _internal_message_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SharingMessage::set_message_id(ArgT0&& arg0, ArgT... args) {
 
 message_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chrome_browser_sharing.SharingMessage.message_id)
}
inline std::string* SharingMessage::mutable_message_id() {
  std::string* _s = _internal_mutable_message_id();
  // @@protoc_insertion_point(field_mutable:chrome_browser_sharing.SharingMessage.message_id)
  return _s;
}
inline const std::string& SharingMessage::_internal_message_id() const {
  return message_id_.Get();
}
inline void SharingMessage::_internal_set_message_id(const std::string& value) {
  
  message_id_.Set(value, GetArenaForAllocation());
}
inline std::string* SharingMessage::_internal_mutable_message_id() {
  
  return message_id_.Mutable(GetArenaForAllocation());
}
inline std::string* SharingMessage::release_message_id() {
  // @@protoc_insertion_point(field_release:chrome_browser_sharing.SharingMessage.message_id)
  return message_id_.Release();
}
inline void SharingMessage::set_allocated_message_id(std::string* message_id) {
  if (message_id != nullptr) {
    
  } else {
    
  }
  message_id_.SetAllocated(message_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (message_id_.IsDefault()) {
    message_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chrome_browser_sharing.SharingMessage.message_id)
}

inline bool SharingMessage::has_payload() const {
  return payload_case() != PAYLOAD_NOT_SET;
}
inline void SharingMessage::clear_has_payload() {
  _oneof_case_[0] = PAYLOAD_NOT_SET;
}
inline bool SharingMessage::has_ack_channel_configuration() const {
  return ack_channel_configuration_case() != ACK_CHANNEL_CONFIGURATION_NOT_SET;
}
inline void SharingMessage::clear_has_ack_channel_configuration() {
  _oneof_case_[1] = ACK_CHANNEL_CONFIGURATION_NOT_SET;
}
inline SharingMessage::PayloadCase SharingMessage::payload_case() const {
  return SharingMessage::PayloadCase(_oneof_case_[0]);
}
inline SharingMessage::AckChannelConfigurationCase SharingMessage::ack_channel_configuration_case() const {
  return SharingMessage::AckChannelConfigurationCase(_oneof_case_[1]);
}
// -------------------------------------------------------------------

// PingMessage

// -------------------------------------------------------------------

// AckMessage

// string original_message_id = 1;
inline void AckMessage::clear_original_message_id() {
  original_message_id_.ClearToEmpty();
}
inline const std::string& AckMessage::original_message_id() const {
  // @@protoc_insertion_point(field_get:chrome_browser_sharing.AckMessage.original_message_id)
  return _internal_original_message_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AckMessage::set_original_message_id(ArgT0&& arg0, ArgT... args) {
 
 original_message_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chrome_browser_sharing.AckMessage.original_message_id)
}
inline std::string* AckMessage::mutable_original_message_id() {
  std::string* _s = _internal_mutable_original_message_id();
  // @@protoc_insertion_point(field_mutable:chrome_browser_sharing.AckMessage.original_message_id)
  return _s;
}
inline const std::string& AckMessage::_internal_original_message_id() const {
  return original_message_id_.Get();
}
inline void AckMessage::_internal_set_original_message_id(const std::string& value) {
  
  original_message_id_.Set(value, GetArenaForAllocation());
}
inline std::string* AckMessage::_internal_mutable_original_message_id() {
  
  return original_message_id_.Mutable(GetArenaForAllocation());
}
inline std::string* AckMessage::release_original_message_id() {
  // @@protoc_insertion_point(field_release:chrome_browser_sharing.AckMessage.original_message_id)
  return original_message_id_.Release();
}
inline void AckMessage::set_allocated_original_message_id(std::string* original_message_id) {
  if (original_message_id != nullptr) {
    
  } else {
    
  }
  original_message_id_.SetAllocated(original_message_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (original_message_id_.IsDefault()) {
    original_message_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chrome_browser_sharing.AckMessage.original_message_id)
}

// .chrome_browser_sharing.ResponseMessage response_message = 3;
inline bool AckMessage::_internal_has_response_message() const {
  return this != internal_default_instance() && response_message_ != nullptr;
}
inline bool AckMessage::has_response_message() const {
  return _internal_has_response_message();
}
inline void AckMessage::clear_response_message() {
  if (GetArenaForAllocation() == nullptr && response_message_ != nullptr) {
    delete response_message_;
  }
  response_message_ = nullptr;
}
inline const ::chrome_browser_sharing::ResponseMessage& AckMessage::_internal_response_message() const {
  const ::chrome_browser_sharing::ResponseMessage* p = response_message_;
  return p != nullptr ? *p : reinterpret_cast<const ::chrome_browser_sharing::ResponseMessage&>(
      ::chrome_browser_sharing::_ResponseMessage_default_instance_);
}
inline const ::chrome_browser_sharing::ResponseMessage& AckMessage::response_message() const {
  // @@protoc_insertion_point(field_get:chrome_browser_sharing.AckMessage.response_message)
  return _internal_response_message();
}
inline void AckMessage::unsafe_arena_set_allocated_response_message(
    ::chrome_browser_sharing::ResponseMessage* response_message) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(response_message_);
  }
  response_message_ = response_message;
  if (response_message) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:chrome_browser_sharing.AckMessage.response_message)
}
inline ::chrome_browser_sharing::ResponseMessage* AckMessage::release_response_message() {
  
  ::chrome_browser_sharing::ResponseMessage* temp = response_message_;
  response_message_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::chrome_browser_sharing::ResponseMessage* AckMessage::unsafe_arena_release_response_message() {
  // @@protoc_insertion_point(field_release:chrome_browser_sharing.AckMessage.response_message)
  
  ::chrome_browser_sharing::ResponseMessage* temp = response_message_;
  response_message_ = nullptr;
  return temp;
}
inline ::chrome_browser_sharing::ResponseMessage* AckMessage::_internal_mutable_response_message() {
  
  if (response_message_ == nullptr) {
    auto* p = CreateMaybeMessage<::chrome_browser_sharing::ResponseMessage>(GetArenaForAllocation());
    response_message_ = p;
  }
  return response_message_;
}
inline ::chrome_browser_sharing::ResponseMessage* AckMessage::mutable_response_message() {
  ::chrome_browser_sharing::ResponseMessage* _msg = _internal_mutable_response_message();
  // @@protoc_insertion_point(field_mutable:chrome_browser_sharing.AckMessage.response_message)
  return _msg;
}
inline void AckMessage::set_allocated_response_message(::chrome_browser_sharing::ResponseMessage* response_message) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete response_message_;
  }
  if (response_message) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(response_message);
    if (message_arena != submessage_arena) {
      response_message = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response_message, submessage_arena);
    }
    
  } else {
    
  }
  response_message_ = response_message;
  // @@protoc_insertion_point(field_set_allocated:chrome_browser_sharing.AckMessage.response_message)
}

// -------------------------------------------------------------------

// ResponseMessage

// .chrome_browser_sharing.SmsFetchResponse sms_fetch_response = 1;
inline bool ResponseMessage::_internal_has_sms_fetch_response() const {
  return payload_case() == kSmsFetchResponse;
}
inline bool ResponseMessage::has_sms_fetch_response() const {
  return _internal_has_sms_fetch_response();
}
inline void ResponseMessage::set_has_sms_fetch_response() {
  _oneof_case_[0] = kSmsFetchResponse;
}
inline ::chrome_browser_sharing::SmsFetchResponse* ResponseMessage::release_sms_fetch_response() {
  // @@protoc_insertion_point(field_release:chrome_browser_sharing.ResponseMessage.sms_fetch_response)
  if (_internal_has_sms_fetch_response()) {
    clear_has_payload();
    ::chrome_browser_sharing::SmsFetchResponse* temp = payload_.sms_fetch_response_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.sms_fetch_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::chrome_browser_sharing::SmsFetchResponse& ResponseMessage::_internal_sms_fetch_response() const {
  return _internal_has_sms_fetch_response()
      ? *payload_.sms_fetch_response_
      : reinterpret_cast< ::chrome_browser_sharing::SmsFetchResponse&>(::chrome_browser_sharing::_SmsFetchResponse_default_instance_);
}
inline const ::chrome_browser_sharing::SmsFetchResponse& ResponseMessage::sms_fetch_response() const {
  // @@protoc_insertion_point(field_get:chrome_browser_sharing.ResponseMessage.sms_fetch_response)
  return _internal_sms_fetch_response();
}
inline ::chrome_browser_sharing::SmsFetchResponse* ResponseMessage::unsafe_arena_release_sms_fetch_response() {
  // @@protoc_insertion_point(field_unsafe_arena_release:chrome_browser_sharing.ResponseMessage.sms_fetch_response)
  if (_internal_has_sms_fetch_response()) {
    clear_has_payload();
    ::chrome_browser_sharing::SmsFetchResponse* temp = payload_.sms_fetch_response_;
    payload_.sms_fetch_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ResponseMessage::unsafe_arena_set_allocated_sms_fetch_response(::chrome_browser_sharing::SmsFetchResponse* sms_fetch_response) {
  clear_payload();
  if (sms_fetch_response) {
    set_has_sms_fetch_response();
    payload_.sms_fetch_response_ = sms_fetch_response;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:chrome_browser_sharing.ResponseMessage.sms_fetch_response)
}
inline ::chrome_browser_sharing::SmsFetchResponse* ResponseMessage::_internal_mutable_sms_fetch_response() {
  if (!_internal_has_sms_fetch_response()) {
    clear_payload();
    set_has_sms_fetch_response();
    payload_.sms_fetch_response_ = CreateMaybeMessage< ::chrome_browser_sharing::SmsFetchResponse >(GetArenaForAllocation());
  }
  return payload_.sms_fetch_response_;
}
inline ::chrome_browser_sharing::SmsFetchResponse* ResponseMessage::mutable_sms_fetch_response() {
  ::chrome_browser_sharing::SmsFetchResponse* _msg = _internal_mutable_sms_fetch_response();
  // @@protoc_insertion_point(field_mutable:chrome_browser_sharing.ResponseMessage.sms_fetch_response)
  return _msg;
}

// .chrome_browser_sharing.PeerConnectionAnswerMessage peer_connection_answer_message_response = 2;
inline bool ResponseMessage::_internal_has_peer_connection_answer_message_response() const {
  return payload_case() == kPeerConnectionAnswerMessageResponse;
}
inline bool ResponseMessage::has_peer_connection_answer_message_response() const {
  return _internal_has_peer_connection_answer_message_response();
}
inline void ResponseMessage::set_has_peer_connection_answer_message_response() {
  _oneof_case_[0] = kPeerConnectionAnswerMessageResponse;
}
inline ::chrome_browser_sharing::PeerConnectionAnswerMessage* ResponseMessage::release_peer_connection_answer_message_response() {
  // @@protoc_insertion_point(field_release:chrome_browser_sharing.ResponseMessage.peer_connection_answer_message_response)
  if (_internal_has_peer_connection_answer_message_response()) {
    clear_has_payload();
    ::chrome_browser_sharing::PeerConnectionAnswerMessage* temp = payload_.peer_connection_answer_message_response_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.peer_connection_answer_message_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::chrome_browser_sharing::PeerConnectionAnswerMessage& ResponseMessage::_internal_peer_connection_answer_message_response() const {
  return _internal_has_peer_connection_answer_message_response()
      ? *payload_.peer_connection_answer_message_response_
      : reinterpret_cast< ::chrome_browser_sharing::PeerConnectionAnswerMessage&>(::chrome_browser_sharing::_PeerConnectionAnswerMessage_default_instance_);
}
inline const ::chrome_browser_sharing::PeerConnectionAnswerMessage& ResponseMessage::peer_connection_answer_message_response() const {
  // @@protoc_insertion_point(field_get:chrome_browser_sharing.ResponseMessage.peer_connection_answer_message_response)
  return _internal_peer_connection_answer_message_response();
}
inline ::chrome_browser_sharing::PeerConnectionAnswerMessage* ResponseMessage::unsafe_arena_release_peer_connection_answer_message_response() {
  // @@protoc_insertion_point(field_unsafe_arena_release:chrome_browser_sharing.ResponseMessage.peer_connection_answer_message_response)
  if (_internal_has_peer_connection_answer_message_response()) {
    clear_has_payload();
    ::chrome_browser_sharing::PeerConnectionAnswerMessage* temp = payload_.peer_connection_answer_message_response_;
    payload_.peer_connection_answer_message_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ResponseMessage::unsafe_arena_set_allocated_peer_connection_answer_message_response(::chrome_browser_sharing::PeerConnectionAnswerMessage* peer_connection_answer_message_response) {
  clear_payload();
  if (peer_connection_answer_message_response) {
    set_has_peer_connection_answer_message_response();
    payload_.peer_connection_answer_message_response_ = peer_connection_answer_message_response;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:chrome_browser_sharing.ResponseMessage.peer_connection_answer_message_response)
}
inline ::chrome_browser_sharing::PeerConnectionAnswerMessage* ResponseMessage::_internal_mutable_peer_connection_answer_message_response() {
  if (!_internal_has_peer_connection_answer_message_response()) {
    clear_payload();
    set_has_peer_connection_answer_message_response();
    payload_.peer_connection_answer_message_response_ = CreateMaybeMessage< ::chrome_browser_sharing::PeerConnectionAnswerMessage >(GetArenaForAllocation());
  }
  return payload_.peer_connection_answer_message_response_;
}
inline ::chrome_browser_sharing::PeerConnectionAnswerMessage* ResponseMessage::mutable_peer_connection_answer_message_response() {
  ::chrome_browser_sharing::PeerConnectionAnswerMessage* _msg = _internal_mutable_peer_connection_answer_message_response();
  // @@protoc_insertion_point(field_mutable:chrome_browser_sharing.ResponseMessage.peer_connection_answer_message_response)
  return _msg;
}

// .chrome_browser_sharing.DiscoveryResponse discovery_response = 3;
inline bool ResponseMessage::_internal_has_discovery_response() const {
  return payload_case() == kDiscoveryResponse;
}
inline bool ResponseMessage::has_discovery_response() const {
  return _internal_has_discovery_response();
}
inline void ResponseMessage::set_has_discovery_response() {
  _oneof_case_[0] = kDiscoveryResponse;
}
inline void ResponseMessage::clear_discovery_response() {
  if (_internal_has_discovery_response()) {
    if (GetArenaForAllocation() == nullptr) {
      delete payload_.discovery_response_;
    }
    clear_has_payload();
  }
}
inline ::chrome_browser_sharing::DiscoveryResponse* ResponseMessage::release_discovery_response() {
  // @@protoc_insertion_point(field_release:chrome_browser_sharing.ResponseMessage.discovery_response)
  if (_internal_has_discovery_response()) {
    clear_has_payload();
    ::chrome_browser_sharing::DiscoveryResponse* temp = payload_.discovery_response_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.discovery_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::chrome_browser_sharing::DiscoveryResponse& ResponseMessage::_internal_discovery_response() const {
  return _internal_has_discovery_response()
      ? *payload_.discovery_response_
      : reinterpret_cast< ::chrome_browser_sharing::DiscoveryResponse&>(::chrome_browser_sharing::_DiscoveryResponse_default_instance_);
}
inline const ::chrome_browser_sharing::DiscoveryResponse& ResponseMessage::discovery_response() const {
  // @@protoc_insertion_point(field_get:chrome_browser_sharing.ResponseMessage.discovery_response)
  return _internal_discovery_response();
}
inline ::chrome_browser_sharing::DiscoveryResponse* ResponseMessage::unsafe_arena_release_discovery_response() {
  // @@protoc_insertion_point(field_unsafe_arena_release:chrome_browser_sharing.ResponseMessage.discovery_response)
  if (_internal_has_discovery_response()) {
    clear_has_payload();
    ::chrome_browser_sharing::DiscoveryResponse* temp = payload_.discovery_response_;
    payload_.discovery_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ResponseMessage::unsafe_arena_set_allocated_discovery_response(::chrome_browser_sharing::DiscoveryResponse* discovery_response) {
  clear_payload();
  if (discovery_response) {
    set_has_discovery_response();
    payload_.discovery_response_ = discovery_response;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:chrome_browser_sharing.ResponseMessage.discovery_response)
}
inline ::chrome_browser_sharing::DiscoveryResponse* ResponseMessage::_internal_mutable_discovery_response() {
  if (!_internal_has_discovery_response()) {
    clear_payload();
    set_has_discovery_response();
    payload_.discovery_response_ = CreateMaybeMessage< ::chrome_browser_sharing::DiscoveryResponse >(GetArenaForAllocation());
  }
  return payload_.discovery_response_;
}
inline ::chrome_browser_sharing::DiscoveryResponse* ResponseMessage::mutable_discovery_response() {
  ::chrome_browser_sharing::DiscoveryResponse* _msg = _internal_mutable_discovery_response();
  // @@protoc_insertion_point(field_mutable:chrome_browser_sharing.ResponseMessage.discovery_response)
  return _msg;
}

inline bool ResponseMessage::has_payload() const {
  return payload_case() != PAYLOAD_NOT_SET;
}
inline void ResponseMessage::clear_has_payload() {
  _oneof_case_[0] = PAYLOAD_NOT_SET;
}
inline ResponseMessage::PayloadCase ResponseMessage::payload_case() const {
  return ResponseMessage::PayloadCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// FCMChannelConfiguration

// string vapid_fcm_token = 1;
inline void FCMChannelConfiguration::clear_vapid_fcm_token() {
  vapid_fcm_token_.ClearToEmpty();
}
inline const std::string& FCMChannelConfiguration::vapid_fcm_token() const {
  // @@protoc_insertion_point(field_get:chrome_browser_sharing.FCMChannelConfiguration.vapid_fcm_token)
  return _internal_vapid_fcm_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FCMChannelConfiguration::set_vapid_fcm_token(ArgT0&& arg0, ArgT... args) {
 
 vapid_fcm_token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chrome_browser_sharing.FCMChannelConfiguration.vapid_fcm_token)
}
inline std::string* FCMChannelConfiguration::mutable_vapid_fcm_token() {
  std::string* _s = _internal_mutable_vapid_fcm_token();
  // @@protoc_insertion_point(field_mutable:chrome_browser_sharing.FCMChannelConfiguration.vapid_fcm_token)
  return _s;
}
inline const std::string& FCMChannelConfiguration::_internal_vapid_fcm_token() const {
  return vapid_fcm_token_.Get();
}
inline void FCMChannelConfiguration::_internal_set_vapid_fcm_token(const std::string& value) {
  
  vapid_fcm_token_.Set(value, GetArenaForAllocation());
}
inline std::string* FCMChannelConfiguration::_internal_mutable_vapid_fcm_token() {
  
  return vapid_fcm_token_.Mutable(GetArenaForAllocation());
}
inline std::string* FCMChannelConfiguration::release_vapid_fcm_token() {
  // @@protoc_insertion_point(field_release:chrome_browser_sharing.FCMChannelConfiguration.vapid_fcm_token)
  return vapid_fcm_token_.Release();
}
inline void FCMChannelConfiguration::set_allocated_vapid_fcm_token(std::string* vapid_fcm_token) {
  if (vapid_fcm_token != nullptr) {
    
  } else {
    
  }
  vapid_fcm_token_.SetAllocated(vapid_fcm_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (vapid_fcm_token_.IsDefault()) {
    vapid_fcm_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chrome_browser_sharing.FCMChannelConfiguration.vapid_fcm_token)
}

// bytes vapid_p256dh = 2;
inline void FCMChannelConfiguration::clear_vapid_p256dh() {
  vapid_p256dh_.ClearToEmpty();
}
inline const std::string& FCMChannelConfiguration::vapid_p256dh() const {
  // @@protoc_insertion_point(field_get:chrome_browser_sharing.FCMChannelConfiguration.vapid_p256dh)
  return _internal_vapid_p256dh();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FCMChannelConfiguration::set_vapid_p256dh(ArgT0&& arg0, ArgT... args) {
 
 vapid_p256dh_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chrome_browser_sharing.FCMChannelConfiguration.vapid_p256dh)
}
inline std::string* FCMChannelConfiguration::mutable_vapid_p256dh() {
  std::string* _s = _internal_mutable_vapid_p256dh();
  // @@protoc_insertion_point(field_mutable:chrome_browser_sharing.FCMChannelConfiguration.vapid_p256dh)
  return _s;
}
inline const std::string& FCMChannelConfiguration::_internal_vapid_p256dh() const {
  return vapid_p256dh_.Get();
}
inline void FCMChannelConfiguration::_internal_set_vapid_p256dh(const std::string& value) {
  
  vapid_p256dh_.Set(value, GetArenaForAllocation());
}
inline std::string* FCMChannelConfiguration::_internal_mutable_vapid_p256dh() {
  
  return vapid_p256dh_.Mutable(GetArenaForAllocation());
}
inline std::string* FCMChannelConfiguration::release_vapid_p256dh() {
  // @@protoc_insertion_point(field_release:chrome_browser_sharing.FCMChannelConfiguration.vapid_p256dh)
  return vapid_p256dh_.Release();
}
inline void FCMChannelConfiguration::set_allocated_vapid_p256dh(std::string* vapid_p256dh) {
  if (vapid_p256dh != nullptr) {
    
  } else {
    
  }
  vapid_p256dh_.SetAllocated(vapid_p256dh, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (vapid_p256dh_.IsDefault()) {
    vapid_p256dh_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chrome_browser_sharing.FCMChannelConfiguration.vapid_p256dh)
}

// bytes vapid_auth_secret = 3;
inline void FCMChannelConfiguration::clear_vapid_auth_secret() {
  vapid_auth_secret_.ClearToEmpty();
}
inline const std::string& FCMChannelConfiguration::vapid_auth_secret() const {
  // @@protoc_insertion_point(field_get:chrome_browser_sharing.FCMChannelConfiguration.vapid_auth_secret)
  return _internal_vapid_auth_secret();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FCMChannelConfiguration::set_vapid_auth_secret(ArgT0&& arg0, ArgT... args) {
 
 vapid_auth_secret_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chrome_browser_sharing.FCMChannelConfiguration.vapid_auth_secret)
}
inline std::string* FCMChannelConfiguration::mutable_vapid_auth_secret() {
  std::string* _s = _internal_mutable_vapid_auth_secret();
  // @@protoc_insertion_point(field_mutable:chrome_browser_sharing.FCMChannelConfiguration.vapid_auth_secret)
  return _s;
}
inline const std::string& FCMChannelConfiguration::_internal_vapid_auth_secret() const {
  return vapid_auth_secret_.Get();
}
inline void FCMChannelConfiguration::_internal_set_vapid_auth_secret(const std::string& value) {
  
  vapid_auth_secret_.Set(value, GetArenaForAllocation());
}
inline std::string* FCMChannelConfiguration::_internal_mutable_vapid_auth_secret() {
  
  return vapid_auth_secret_.Mutable(GetArenaForAllocation());
}
inline std::string* FCMChannelConfiguration::release_vapid_auth_secret() {
  // @@protoc_insertion_point(field_release:chrome_browser_sharing.FCMChannelConfiguration.vapid_auth_secret)
  return vapid_auth_secret_.Release();
}
inline void FCMChannelConfiguration::set_allocated_vapid_auth_secret(std::string* vapid_auth_secret) {
  if (vapid_auth_secret != nullptr) {
    
  } else {
    
  }
  vapid_auth_secret_.SetAllocated(vapid_auth_secret, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (vapid_auth_secret_.IsDefault()) {
    vapid_auth_secret_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chrome_browser_sharing.FCMChannelConfiguration.vapid_auth_secret)
}

// string sender_id_fcm_token = 4;
inline void FCMChannelConfiguration::clear_sender_id_fcm_token() {
  sender_id_fcm_token_.ClearToEmpty();
}
inline const std::string& FCMChannelConfiguration::sender_id_fcm_token() const {
  // @@protoc_insertion_point(field_get:chrome_browser_sharing.FCMChannelConfiguration.sender_id_fcm_token)
  return _internal_sender_id_fcm_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FCMChannelConfiguration::set_sender_id_fcm_token(ArgT0&& arg0, ArgT... args) {
 
 sender_id_fcm_token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chrome_browser_sharing.FCMChannelConfiguration.sender_id_fcm_token)
}
inline std::string* FCMChannelConfiguration::mutable_sender_id_fcm_token() {
  std::string* _s = _internal_mutable_sender_id_fcm_token();
  // @@protoc_insertion_point(field_mutable:chrome_browser_sharing.FCMChannelConfiguration.sender_id_fcm_token)
  return _s;
}
inline const std::string& FCMChannelConfiguration::_internal_sender_id_fcm_token() const {
  return sender_id_fcm_token_.Get();
}
inline void FCMChannelConfiguration::_internal_set_sender_id_fcm_token(const std::string& value) {
  
  sender_id_fcm_token_.Set(value, GetArenaForAllocation());
}
inline std::string* FCMChannelConfiguration::_internal_mutable_sender_id_fcm_token() {
  
  return sender_id_fcm_token_.Mutable(GetArenaForAllocation());
}
inline std::string* FCMChannelConfiguration::release_sender_id_fcm_token() {
  // @@protoc_insertion_point(field_release:chrome_browser_sharing.FCMChannelConfiguration.sender_id_fcm_token)
  return sender_id_fcm_token_.Release();
}
inline void FCMChannelConfiguration::set_allocated_sender_id_fcm_token(std::string* sender_id_fcm_token) {
  if (sender_id_fcm_token != nullptr) {
    
  } else {
    
  }
  sender_id_fcm_token_.SetAllocated(sender_id_fcm_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (sender_id_fcm_token_.IsDefault()) {
    sender_id_fcm_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chrome_browser_sharing.FCMChannelConfiguration.sender_id_fcm_token)
}

// bytes sender_id_p256dh = 5;
inline void FCMChannelConfiguration::clear_sender_id_p256dh() {
  sender_id_p256dh_.ClearToEmpty();
}
inline const std::string& FCMChannelConfiguration::sender_id_p256dh() const {
  // @@protoc_insertion_point(field_get:chrome_browser_sharing.FCMChannelConfiguration.sender_id_p256dh)
  return _internal_sender_id_p256dh();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FCMChannelConfiguration::set_sender_id_p256dh(ArgT0&& arg0, ArgT... args) {
 
 sender_id_p256dh_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chrome_browser_sharing.FCMChannelConfiguration.sender_id_p256dh)
}
inline std::string* FCMChannelConfiguration::mutable_sender_id_p256dh() {
  std::string* _s = _internal_mutable_sender_id_p256dh();
  // @@protoc_insertion_point(field_mutable:chrome_browser_sharing.FCMChannelConfiguration.sender_id_p256dh)
  return _s;
}
inline const std::string& FCMChannelConfiguration::_internal_sender_id_p256dh() const {
  return sender_id_p256dh_.Get();
}
inline void FCMChannelConfiguration::_internal_set_sender_id_p256dh(const std::string& value) {
  
  sender_id_p256dh_.Set(value, GetArenaForAllocation());
}
inline std::string* FCMChannelConfiguration::_internal_mutable_sender_id_p256dh() {
  
  return sender_id_p256dh_.Mutable(GetArenaForAllocation());
}
inline std::string* FCMChannelConfiguration::release_sender_id_p256dh() {
  // @@protoc_insertion_point(field_release:chrome_browser_sharing.FCMChannelConfiguration.sender_id_p256dh)
  return sender_id_p256dh_.Release();
}
inline void FCMChannelConfiguration::set_allocated_sender_id_p256dh(std::string* sender_id_p256dh) {
  if (sender_id_p256dh != nullptr) {
    
  } else {
    
  }
  sender_id_p256dh_.SetAllocated(sender_id_p256dh, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (sender_id_p256dh_.IsDefault()) {
    sender_id_p256dh_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chrome_browser_sharing.FCMChannelConfiguration.sender_id_p256dh)
}

// bytes sender_id_auth_secret = 6;
inline void FCMChannelConfiguration::clear_sender_id_auth_secret() {
  sender_id_auth_secret_.ClearToEmpty();
}
inline const std::string& FCMChannelConfiguration::sender_id_auth_secret() const {
  // @@protoc_insertion_point(field_get:chrome_browser_sharing.FCMChannelConfiguration.sender_id_auth_secret)
  return _internal_sender_id_auth_secret();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FCMChannelConfiguration::set_sender_id_auth_secret(ArgT0&& arg0, ArgT... args) {
 
 sender_id_auth_secret_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chrome_browser_sharing.FCMChannelConfiguration.sender_id_auth_secret)
}
inline std::string* FCMChannelConfiguration::mutable_sender_id_auth_secret() {
  std::string* _s = _internal_mutable_sender_id_auth_secret();
  // @@protoc_insertion_point(field_mutable:chrome_browser_sharing.FCMChannelConfiguration.sender_id_auth_secret)
  return _s;
}
inline const std::string& FCMChannelConfiguration::_internal_sender_id_auth_secret() const {
  return sender_id_auth_secret_.Get();
}
inline void FCMChannelConfiguration::_internal_set_sender_id_auth_secret(const std::string& value) {
  
  sender_id_auth_secret_.Set(value, GetArenaForAllocation());
}
inline std::string* FCMChannelConfiguration::_internal_mutable_sender_id_auth_secret() {
  
  return sender_id_auth_secret_.Mutable(GetArenaForAllocation());
}
inline std::string* FCMChannelConfiguration::release_sender_id_auth_secret() {
  // @@protoc_insertion_point(field_release:chrome_browser_sharing.FCMChannelConfiguration.sender_id_auth_secret)
  return sender_id_auth_secret_.Release();
}
inline void FCMChannelConfiguration::set_allocated_sender_id_auth_secret(std::string* sender_id_auth_secret) {
  if (sender_id_auth_secret != nullptr) {
    
  } else {
    
  }
  sender_id_auth_secret_.SetAllocated(sender_id_auth_secret, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (sender_id_auth_secret_.IsDefault()) {
    sender_id_auth_secret_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chrome_browser_sharing.FCMChannelConfiguration.sender_id_auth_secret)
}

// -------------------------------------------------------------------

// ServerChannelConfiguration

// bytes configuration = 3;
inline void ServerChannelConfiguration::clear_configuration() {
  configuration_.ClearToEmpty();
}
inline const std::string& ServerChannelConfiguration::configuration() const {
  // @@protoc_insertion_point(field_get:chrome_browser_sharing.ServerChannelConfiguration.configuration)
  return _internal_configuration();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ServerChannelConfiguration::set_configuration(ArgT0&& arg0, ArgT... args) {
 
 configuration_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chrome_browser_sharing.ServerChannelConfiguration.configuration)
}
inline std::string* ServerChannelConfiguration::mutable_configuration() {
  std::string* _s = _internal_mutable_configuration();
  // @@protoc_insertion_point(field_mutable:chrome_browser_sharing.ServerChannelConfiguration.configuration)
  return _s;
}
inline const std::string& ServerChannelConfiguration::_internal_configuration() const {
  return configuration_.Get();
}
inline void ServerChannelConfiguration::_internal_set_configuration(const std::string& value) {
  
  configuration_.Set(value, GetArenaForAllocation());
}
inline std::string* ServerChannelConfiguration::_internal_mutable_configuration() {
  
  return configuration_.Mutable(GetArenaForAllocation());
}
inline std::string* ServerChannelConfiguration::release_configuration() {
  // @@protoc_insertion_point(field_release:chrome_browser_sharing.ServerChannelConfiguration.configuration)
  return configuration_.Release();
}
inline void ServerChannelConfiguration::set_allocated_configuration(std::string* configuration) {
  if (configuration != nullptr) {
    
  } else {
    
  }
  configuration_.SetAllocated(configuration, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (configuration_.IsDefault()) {
    configuration_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chrome_browser_sharing.ServerChannelConfiguration.configuration)
}

// bytes p256dh = 4;
inline void ServerChannelConfiguration::clear_p256dh() {
  p256dh_.ClearToEmpty();
}
inline const std::string& ServerChannelConfiguration::p256dh() const {
  // @@protoc_insertion_point(field_get:chrome_browser_sharing.ServerChannelConfiguration.p256dh)
  return _internal_p256dh();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ServerChannelConfiguration::set_p256dh(ArgT0&& arg0, ArgT... args) {
 
 p256dh_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chrome_browser_sharing.ServerChannelConfiguration.p256dh)
}
inline std::string* ServerChannelConfiguration::mutable_p256dh() {
  std::string* _s = _internal_mutable_p256dh();
  // @@protoc_insertion_point(field_mutable:chrome_browser_sharing.ServerChannelConfiguration.p256dh)
  return _s;
}
inline const std::string& ServerChannelConfiguration::_internal_p256dh() const {
  return p256dh_.Get();
}
inline void ServerChannelConfiguration::_internal_set_p256dh(const std::string& value) {
  
  p256dh_.Set(value, GetArenaForAllocation());
}
inline std::string* ServerChannelConfiguration::_internal_mutable_p256dh() {
  
  return p256dh_.Mutable(GetArenaForAllocation());
}
inline std::string* ServerChannelConfiguration::release_p256dh() {
  // @@protoc_insertion_point(field_release:chrome_browser_sharing.ServerChannelConfiguration.p256dh)
  return p256dh_.Release();
}
inline void ServerChannelConfiguration::set_allocated_p256dh(std::string* p256dh) {
  if (p256dh != nullptr) {
    
  } else {
    
  }
  p256dh_.SetAllocated(p256dh, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (p256dh_.IsDefault()) {
    p256dh_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chrome_browser_sharing.ServerChannelConfiguration.p256dh)
}

// bytes auth_secret = 5;
inline void ServerChannelConfiguration::clear_auth_secret() {
  auth_secret_.ClearToEmpty();
}
inline const std::string& ServerChannelConfiguration::auth_secret() const {
  // @@protoc_insertion_point(field_get:chrome_browser_sharing.ServerChannelConfiguration.auth_secret)
  return _internal_auth_secret();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ServerChannelConfiguration::set_auth_secret(ArgT0&& arg0, ArgT... args) {
 
 auth_secret_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chrome_browser_sharing.ServerChannelConfiguration.auth_secret)
}
inline std::string* ServerChannelConfiguration::mutable_auth_secret() {
  std::string* _s = _internal_mutable_auth_secret();
  // @@protoc_insertion_point(field_mutable:chrome_browser_sharing.ServerChannelConfiguration.auth_secret)
  return _s;
}
inline const std::string& ServerChannelConfiguration::_internal_auth_secret() const {
  return auth_secret_.Get();
}
inline void ServerChannelConfiguration::_internal_set_auth_secret(const std::string& value) {
  
  auth_secret_.Set(value, GetArenaForAllocation());
}
inline std::string* ServerChannelConfiguration::_internal_mutable_auth_secret() {
  
  return auth_secret_.Mutable(GetArenaForAllocation());
}
inline std::string* ServerChannelConfiguration::release_auth_secret() {
  // @@protoc_insertion_point(field_release:chrome_browser_sharing.ServerChannelConfiguration.auth_secret)
  return auth_secret_.Release();
}
inline void ServerChannelConfiguration::set_allocated_auth_secret(std::string* auth_secret) {
  if (auth_secret != nullptr) {
    
  } else {
    
  }
  auth_secret_.SetAllocated(auth_secret, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (auth_secret_.IsDefault()) {
    auth_secret_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chrome_browser_sharing.ServerChannelConfiguration.auth_secret)
}

// -------------------------------------------------------------------

// DiscoveryRequest

// string service_id = 1;
inline void DiscoveryRequest::clear_service_id() {
  service_id_.ClearToEmpty();
}
inline const std::string& DiscoveryRequest::service_id() const {
  // @@protoc_insertion_point(field_get:chrome_browser_sharing.DiscoveryRequest.service_id)
  return _internal_service_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DiscoveryRequest::set_service_id(ArgT0&& arg0, ArgT... args) {
 
 service_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chrome_browser_sharing.DiscoveryRequest.service_id)
}
inline std::string* DiscoveryRequest::mutable_service_id() {
  std::string* _s = _internal_mutable_service_id();
  // @@protoc_insertion_point(field_mutable:chrome_browser_sharing.DiscoveryRequest.service_id)
  return _s;
}
inline const std::string& DiscoveryRequest::_internal_service_id() const {
  return service_id_.Get();
}
inline void DiscoveryRequest::_internal_set_service_id(const std::string& value) {
  
  service_id_.Set(value, GetArenaForAllocation());
}
inline std::string* DiscoveryRequest::_internal_mutable_service_id() {
  
  return service_id_.Mutable(GetArenaForAllocation());
}
inline std::string* DiscoveryRequest::release_service_id() {
  // @@protoc_insertion_point(field_release:chrome_browser_sharing.DiscoveryRequest.service_id)
  return service_id_.Release();
}
inline void DiscoveryRequest::set_allocated_service_id(std::string* service_id) {
  if (service_id != nullptr) {
    
  } else {
    
  }
  service_id_.SetAllocated(service_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (service_id_.IsDefault()) {
    service_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chrome_browser_sharing.DiscoveryRequest.service_id)
}

// -------------------------------------------------------------------

// DiscoveryResponse

// string service_id = 1;
inline void DiscoveryResponse::clear_service_id() {
  service_id_.ClearToEmpty();
}
inline const std::string& DiscoveryResponse::service_id() const {
  // @@protoc_insertion_point(field_get:chrome_browser_sharing.DiscoveryResponse.service_id)
  return _internal_service_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DiscoveryResponse::set_service_id(ArgT0&& arg0, ArgT... args) {
 
 service_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chrome_browser_sharing.DiscoveryResponse.service_id)
}
inline std::string* DiscoveryResponse::mutable_service_id() {
  std::string* _s = _internal_mutable_service_id();
  // @@protoc_insertion_point(field_mutable:chrome_browser_sharing.DiscoveryResponse.service_id)
  return _s;
}
inline const std::string& DiscoveryResponse::_internal_service_id() const {
  return service_id_.Get();
}
inline void DiscoveryResponse::_internal_set_service_id(const std::string& value) {
  
  service_id_.Set(value, GetArenaForAllocation());
}
inline std::string* DiscoveryResponse::_internal_mutable_service_id() {
  
  return service_id_.Mutable(GetArenaForAllocation());
}
inline std::string* DiscoveryResponse::release_service_id() {
  // @@protoc_insertion_point(field_release:chrome_browser_sharing.DiscoveryResponse.service_id)
  return service_id_.Release();
}
inline void DiscoveryResponse::set_allocated_service_id(std::string* service_id) {
  if (service_id != nullptr) {
    
  } else {
    
  }
  service_id_.SetAllocated(service_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (service_id_.IsDefault()) {
    service_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chrome_browser_sharing.DiscoveryResponse.service_id)
}

// string endpoint_id = 2;
inline void DiscoveryResponse::clear_endpoint_id() {
  endpoint_id_.ClearToEmpty();
}
inline const std::string& DiscoveryResponse::endpoint_id() const {
  // @@protoc_insertion_point(field_get:chrome_browser_sharing.DiscoveryResponse.endpoint_id)
  return _internal_endpoint_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DiscoveryResponse::set_endpoint_id(ArgT0&& arg0, ArgT... args) {
 
 endpoint_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chrome_browser_sharing.DiscoveryResponse.endpoint_id)
}
inline std::string* DiscoveryResponse::mutable_endpoint_id() {
  std::string* _s = _internal_mutable_endpoint_id();
  // @@protoc_insertion_point(field_mutable:chrome_browser_sharing.DiscoveryResponse.endpoint_id)
  return _s;
}
inline const std::string& DiscoveryResponse::_internal_endpoint_id() const {
  return endpoint_id_.Get();
}
inline void DiscoveryResponse::_internal_set_endpoint_id(const std::string& value) {
  
  endpoint_id_.Set(value, GetArenaForAllocation());
}
inline std::string* DiscoveryResponse::_internal_mutable_endpoint_id() {
  
  return endpoint_id_.Mutable(GetArenaForAllocation());
}
inline std::string* DiscoveryResponse::release_endpoint_id() {
  // @@protoc_insertion_point(field_release:chrome_browser_sharing.DiscoveryResponse.endpoint_id)
  return endpoint_id_.Release();
}
inline void DiscoveryResponse::set_allocated_endpoint_id(std::string* endpoint_id) {
  if (endpoint_id != nullptr) {
    
  } else {
    
  }
  endpoint_id_.SetAllocated(endpoint_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (endpoint_id_.IsDefault()) {
    endpoint_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chrome_browser_sharing.DiscoveryResponse.endpoint_id)
}

// bytes endpoint_info = 3;
inline void DiscoveryResponse::clear_endpoint_info() {
  endpoint_info_.ClearToEmpty();
}
inline const std::string& DiscoveryResponse::endpoint_info() const {
  // @@protoc_insertion_point(field_get:chrome_browser_sharing.DiscoveryResponse.endpoint_info)
  return _internal_endpoint_info();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DiscoveryResponse::set_endpoint_info(ArgT0&& arg0, ArgT... args) {
 
 endpoint_info_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chrome_browser_sharing.DiscoveryResponse.endpoint_info)
}
inline std::string* DiscoveryResponse::mutable_endpoint_info() {
  std::string* _s = _internal_mutable_endpoint_info();
  // @@protoc_insertion_point(field_mutable:chrome_browser_sharing.DiscoveryResponse.endpoint_info)
  return _s;
}
inline const std::string& DiscoveryResponse::_internal_endpoint_info() const {
  return endpoint_info_.Get();
}
inline void DiscoveryResponse::_internal_set_endpoint_info(const std::string& value) {
  
  endpoint_info_.Set(value, GetArenaForAllocation());
}
inline std::string* DiscoveryResponse::_internal_mutable_endpoint_info() {
  
  return endpoint_info_.Mutable(GetArenaForAllocation());
}
inline std::string* DiscoveryResponse::release_endpoint_info() {
  // @@protoc_insertion_point(field_release:chrome_browser_sharing.DiscoveryResponse.endpoint_info)
  return endpoint_info_.Release();
}
inline void DiscoveryResponse::set_allocated_endpoint_info(std::string* endpoint_info) {
  if (endpoint_info != nullptr) {
    
  } else {
    
  }
  endpoint_info_.SetAllocated(endpoint_info, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (endpoint_info_.IsDefault()) {
    endpoint_info_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chrome_browser_sharing.DiscoveryResponse.endpoint_info)
}

// -------------------------------------------------------------------

// WebRtcSignalingMessage

// bytes web_rtc_signaling_frame = 1;
inline void WebRtcSignalingMessage::clear_web_rtc_signaling_frame() {
  web_rtc_signaling_frame_.ClearToEmpty();
}
inline const std::string& WebRtcSignalingMessage::web_rtc_signaling_frame() const {
  // @@protoc_insertion_point(field_get:chrome_browser_sharing.WebRtcSignalingMessage.web_rtc_signaling_frame)
  return _internal_web_rtc_signaling_frame();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WebRtcSignalingMessage::set_web_rtc_signaling_frame(ArgT0&& arg0, ArgT... args) {
 
 web_rtc_signaling_frame_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chrome_browser_sharing.WebRtcSignalingMessage.web_rtc_signaling_frame)
}
inline std::string* WebRtcSignalingMessage::mutable_web_rtc_signaling_frame() {
  std::string* _s = _internal_mutable_web_rtc_signaling_frame();
  // @@protoc_insertion_point(field_mutable:chrome_browser_sharing.WebRtcSignalingMessage.web_rtc_signaling_frame)
  return _s;
}
inline const std::string& WebRtcSignalingMessage::_internal_web_rtc_signaling_frame() const {
  return web_rtc_signaling_frame_.Get();
}
inline void WebRtcSignalingMessage::_internal_set_web_rtc_signaling_frame(const std::string& value) {
  
  web_rtc_signaling_frame_.Set(value, GetArenaForAllocation());
}
inline std::string* WebRtcSignalingMessage::_internal_mutable_web_rtc_signaling_frame() {
  
  return web_rtc_signaling_frame_.Mutable(GetArenaForAllocation());
}
inline std::string* WebRtcSignalingMessage::release_web_rtc_signaling_frame() {
  // @@protoc_insertion_point(field_release:chrome_browser_sharing.WebRtcSignalingMessage.web_rtc_signaling_frame)
  return web_rtc_signaling_frame_.Release();
}
inline void WebRtcSignalingMessage::set_allocated_web_rtc_signaling_frame(std::string* web_rtc_signaling_frame) {
  if (web_rtc_signaling_frame != nullptr) {
    
  } else {
    
  }
  web_rtc_signaling_frame_.SetAllocated(web_rtc_signaling_frame, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (web_rtc_signaling_frame_.IsDefault()) {
    web_rtc_signaling_frame_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chrome_browser_sharing.WebRtcSignalingMessage.web_rtc_signaling_frame)
}

// -------------------------------------------------------------------

// WebRtcMessage

// string message_guid = 1;
inline void WebRtcMessage::clear_message_guid() {
  message_guid_.ClearToEmpty();
}
inline const std::string& WebRtcMessage::message_guid() const {
  // @@protoc_insertion_point(field_get:chrome_browser_sharing.WebRtcMessage.message_guid)
  return _internal_message_guid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WebRtcMessage::set_message_guid(ArgT0&& arg0, ArgT... args) {
 
 message_guid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chrome_browser_sharing.WebRtcMessage.message_guid)
}
inline std::string* WebRtcMessage::mutable_message_guid() {
  std::string* _s = _internal_mutable_message_guid();
  // @@protoc_insertion_point(field_mutable:chrome_browser_sharing.WebRtcMessage.message_guid)
  return _s;
}
inline const std::string& WebRtcMessage::_internal_message_guid() const {
  return message_guid_.Get();
}
inline void WebRtcMessage::_internal_set_message_guid(const std::string& value) {
  
  message_guid_.Set(value, GetArenaForAllocation());
}
inline std::string* WebRtcMessage::_internal_mutable_message_guid() {
  
  return message_guid_.Mutable(GetArenaForAllocation());
}
inline std::string* WebRtcMessage::release_message_guid() {
  // @@protoc_insertion_point(field_release:chrome_browser_sharing.WebRtcMessage.message_guid)
  return message_guid_.Release();
}
inline void WebRtcMessage::set_allocated_message_guid(std::string* message_guid) {
  if (message_guid != nullptr) {
    
  } else {
    
  }
  message_guid_.SetAllocated(message_guid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (message_guid_.IsDefault()) {
    message_guid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chrome_browser_sharing.WebRtcMessage.message_guid)
}

// .chrome_browser_sharing.SharingMessage message = 2;
inline bool WebRtcMessage::_internal_has_message() const {
  return this != internal_default_instance() && message_ != nullptr;
}
inline bool WebRtcMessage::has_message() const {
  return _internal_has_message();
}
inline void WebRtcMessage::clear_message() {
  if (GetArenaForAllocation() == nullptr && message_ != nullptr) {
    delete message_;
  }
  message_ = nullptr;
}
inline const ::chrome_browser_sharing::SharingMessage& WebRtcMessage::_internal_message() const {
  const ::chrome_browser_sharing::SharingMessage* p = message_;
  return p != nullptr ? *p : reinterpret_cast<const ::chrome_browser_sharing::SharingMessage&>(
      ::chrome_browser_sharing::_SharingMessage_default_instance_);
}
inline const ::chrome_browser_sharing::SharingMessage& WebRtcMessage::message() const {
  // @@protoc_insertion_point(field_get:chrome_browser_sharing.WebRtcMessage.message)
  return _internal_message();
}
inline void WebRtcMessage::unsafe_arena_set_allocated_message(
    ::chrome_browser_sharing::SharingMessage* message) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(message_);
  }
  message_ = message;
  if (message) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:chrome_browser_sharing.WebRtcMessage.message)
}
inline ::chrome_browser_sharing::SharingMessage* WebRtcMessage::release_message() {
  
  ::chrome_browser_sharing::SharingMessage* temp = message_;
  message_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::chrome_browser_sharing::SharingMessage* WebRtcMessage::unsafe_arena_release_message() {
  // @@protoc_insertion_point(field_release:chrome_browser_sharing.WebRtcMessage.message)
  
  ::chrome_browser_sharing::SharingMessage* temp = message_;
  message_ = nullptr;
  return temp;
}
inline ::chrome_browser_sharing::SharingMessage* WebRtcMessage::_internal_mutable_message() {
  
  if (message_ == nullptr) {
    auto* p = CreateMaybeMessage<::chrome_browser_sharing::SharingMessage>(GetArenaForAllocation());
    message_ = p;
  }
  return message_;
}
inline ::chrome_browser_sharing::SharingMessage* WebRtcMessage::mutable_message() {
  ::chrome_browser_sharing::SharingMessage* _msg = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:chrome_browser_sharing.WebRtcMessage.message)
  return _msg;
}
inline void WebRtcMessage::set_allocated_message(::chrome_browser_sharing::SharingMessage* message) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete message_;
  }
  if (message) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(message);
    if (message_arena != submessage_arena) {
      message = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, message, submessage_arena);
    }
    
  } else {
    
  }
  message_ = message;
  // @@protoc_insertion_point(field_set_allocated:chrome_browser_sharing.WebRtcMessage.message)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace chrome_browser_sharing

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::chrome_browser_sharing::MessageType> : ::std::true_type {};

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_sharing_5fmessage_2eproto
