// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: catalog.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_catalog_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_catalog_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3020000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3020000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_catalog_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_catalog_2eproto {
  static const uint32_t offsets[];
};
namespace explore_sites {
class Catalog;
struct CatalogDefaultTypeInternal;
extern CatalogDefaultTypeInternal _Catalog_default_instance_;
class Category;
struct CategoryDefaultTypeInternal;
extern CategoryDefaultTypeInternal _Category_default_instance_;
class GetCatalogRequest;
struct GetCatalogRequestDefaultTypeInternal;
extern GetCatalogRequestDefaultTypeInternal _GetCatalogRequest_default_instance_;
class GetCatalogResponse;
struct GetCatalogResponseDefaultTypeInternal;
extern GetCatalogResponseDefaultTypeInternal _GetCatalogResponse_default_instance_;
class Site;
struct SiteDefaultTypeInternal;
extern SiteDefaultTypeInternal _Site_default_instance_;
}  // namespace explore_sites
PROTOBUF_NAMESPACE_OPEN
template<> ::explore_sites::Catalog* Arena::CreateMaybeMessage<::explore_sites::Catalog>(Arena*);
template<> ::explore_sites::Category* Arena::CreateMaybeMessage<::explore_sites::Category>(Arena*);
template<> ::explore_sites::GetCatalogRequest* Arena::CreateMaybeMessage<::explore_sites::GetCatalogRequest>(Arena*);
template<> ::explore_sites::GetCatalogResponse* Arena::CreateMaybeMessage<::explore_sites::GetCatalogResponse>(Arena*);
template<> ::explore_sites::Site* Arena::CreateMaybeMessage<::explore_sites::Site>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace explore_sites {

enum Category_CategoryType : int {
  Category_CategoryType_DEFAULT = 0,
  Category_CategoryType_SOCIAL = 1,
  Category_CategoryType_ENTERTAINMENT = 2,
  Category_CategoryType_SPORT = 3,
  Category_CategoryType_NEWS = 4,
  Category_CategoryType_SHOPPING = 5,
  Category_CategoryType_REFERENCE = 6,
  Category_CategoryType_BANKING = 7,
  Category_CategoryType_GOVERNMENT = 8,
  Category_CategoryType_TRAVEL = 9,
  Category_CategoryType_EDUCATION = 10,
  Category_CategoryType_JOBS = 11,
  Category_CategoryType_APPS_GAMES = 12,
  Category_CategoryType_FAVORITE = 13,
  Category_CategoryType_GOOGLE = 14,
  Category_CategoryType_FOOD = 15,
  Category_CategoryType_HEALTH = 16,
  Category_CategoryType_BOOKS = 17,
  Category_CategoryType_TECHNOLOGY = 18,
  Category_CategoryType_SCIENCE = 19,
  Category_CategoryType_Category_CategoryType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Category_CategoryType_Category_CategoryType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Category_CategoryType_IsValid(int value);
constexpr Category_CategoryType Category_CategoryType_CategoryType_MIN = Category_CategoryType_DEFAULT;
constexpr Category_CategoryType Category_CategoryType_CategoryType_MAX = Category_CategoryType_SCIENCE;
constexpr int Category_CategoryType_CategoryType_ARRAYSIZE = Category_CategoryType_CategoryType_MAX + 1;

const std::string& Category_CategoryType_Name(Category_CategoryType value);
template<typename T>
inline const std::string& Category_CategoryType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Category_CategoryType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Category_CategoryType_Name.");
  return Category_CategoryType_Name(static_cast<Category_CategoryType>(enum_t_value));
}
bool Category_CategoryType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Category_CategoryType* value);
// ===================================================================

class Catalog final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:explore_sites.Catalog) */ {
 public:
  inline Catalog() : Catalog(nullptr) {}
  ~Catalog() override;
  explicit PROTOBUF_CONSTEXPR Catalog(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Catalog(const Catalog& from);
  Catalog(Catalog&& from) noexcept
    : Catalog() {
    *this = ::std::move(from);
  }

  inline Catalog& operator=(const Catalog& from) {
    CopyFrom(from);
    return *this;
  }
  inline Catalog& operator=(Catalog&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const Catalog& default_instance() {
    return *internal_default_instance();
  }
  static inline const Catalog* internal_default_instance() {
    return reinterpret_cast<const Catalog*>(
               &_Catalog_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Catalog& a, Catalog& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(Catalog* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Catalog* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Catalog* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Catalog>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Catalog& from);
  void MergeFrom(const Catalog& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Catalog* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "explore_sites.Catalog";
  }
  protected:
  explicit Catalog(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCategoriesFieldNumber = 1,
  };
  // repeated .explore_sites.Category categories = 1;
  int categories_size() const;
  private:
  int _internal_categories_size() const;
  public:
  void clear_categories();
  ::explore_sites::Category* mutable_categories(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::explore_sites::Category >*
      mutable_categories();
  private:
  const ::explore_sites::Category& _internal_categories(int index) const;
  ::explore_sites::Category* _internal_add_categories();
  public:
  const ::explore_sites::Category& categories(int index) const;
  ::explore_sites::Category* add_categories();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::explore_sites::Category >&
      categories() const;

  // @@protoc_insertion_point(class_scope:explore_sites.Catalog)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::explore_sites::Category > categories_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_catalog_2eproto;
};
// -------------------------------------------------------------------

class Category final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:explore_sites.Category) */ {
 public:
  inline Category() : Category(nullptr) {}
  ~Category() override;
  explicit PROTOBUF_CONSTEXPR Category(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Category(const Category& from);
  Category(Category&& from) noexcept
    : Category() {
    *this = ::std::move(from);
  }

  inline Category& operator=(const Category& from) {
    CopyFrom(from);
    return *this;
  }
  inline Category& operator=(Category&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const Category& default_instance() {
    return *internal_default_instance();
  }
  static inline const Category* internal_default_instance() {
    return reinterpret_cast<const Category*>(
               &_Category_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Category& a, Category& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(Category* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Category* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Category* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Category>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Category& from);
  void MergeFrom(const Category& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Category* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "explore_sites.Category";
  }
  protected:
  explicit Category(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef Category_CategoryType CategoryType;
  static constexpr CategoryType DEFAULT =
    Category_CategoryType_DEFAULT;
  static constexpr CategoryType SOCIAL =
    Category_CategoryType_SOCIAL;
  static constexpr CategoryType ENTERTAINMENT =
    Category_CategoryType_ENTERTAINMENT;
  static constexpr CategoryType SPORT =
    Category_CategoryType_SPORT;
  static constexpr CategoryType NEWS =
    Category_CategoryType_NEWS;
  static constexpr CategoryType SHOPPING =
    Category_CategoryType_SHOPPING;
  static constexpr CategoryType REFERENCE =
    Category_CategoryType_REFERENCE;
  static constexpr CategoryType BANKING =
    Category_CategoryType_BANKING;
  static constexpr CategoryType GOVERNMENT =
    Category_CategoryType_GOVERNMENT;
  static constexpr CategoryType TRAVEL =
    Category_CategoryType_TRAVEL;
  static constexpr CategoryType EDUCATION =
    Category_CategoryType_EDUCATION;
  static constexpr CategoryType JOBS =
    Category_CategoryType_JOBS;
  static constexpr CategoryType APPS_GAMES =
    Category_CategoryType_APPS_GAMES;
  static constexpr CategoryType FAVORITE =
    Category_CategoryType_FAVORITE;
  static constexpr CategoryType GOOGLE =
    Category_CategoryType_GOOGLE;
  static constexpr CategoryType FOOD =
    Category_CategoryType_FOOD;
  static constexpr CategoryType HEALTH =
    Category_CategoryType_HEALTH;
  static constexpr CategoryType BOOKS =
    Category_CategoryType_BOOKS;
  static constexpr CategoryType TECHNOLOGY =
    Category_CategoryType_TECHNOLOGY;
  static constexpr CategoryType SCIENCE =
    Category_CategoryType_SCIENCE;
  static inline bool CategoryType_IsValid(int value) {
    return Category_CategoryType_IsValid(value);
  }
  static constexpr CategoryType CategoryType_MIN =
    Category_CategoryType_CategoryType_MIN;
  static constexpr CategoryType CategoryType_MAX =
    Category_CategoryType_CategoryType_MAX;
  static constexpr int CategoryType_ARRAYSIZE =
    Category_CategoryType_CategoryType_ARRAYSIZE;
  template<typename T>
  static inline const std::string& CategoryType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, CategoryType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function CategoryType_Name.");
    return Category_CategoryType_Name(enum_t_value);
  }
  static inline bool CategoryType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      CategoryType* value) {
    return Category_CategoryType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kSitesFieldNumber = 4,
    kLocalizedTitleFieldNumber = 2,
    kIconFieldNumber = 3,
    kTypeFieldNumber = 1,
  };
  // repeated .explore_sites.Site sites = 4;
  int sites_size() const;
  private:
  int _internal_sites_size() const;
  public:
  void clear_sites();
  ::explore_sites::Site* mutable_sites(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::explore_sites::Site >*
      mutable_sites();
  private:
  const ::explore_sites::Site& _internal_sites(int index) const;
  ::explore_sites::Site* _internal_add_sites();
  public:
  const ::explore_sites::Site& sites(int index) const;
  ::explore_sites::Site* add_sites();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::explore_sites::Site >&
      sites() const;

  // string localized_title = 2;
  void clear_localized_title();
  const std::string& localized_title() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_localized_title(ArgT0&& arg0, ArgT... args);
  std::string* mutable_localized_title();
  PROTOBUF_NODISCARD std::string* release_localized_title();
  void set_allocated_localized_title(std::string* localized_title);
  private:
  const std::string& _internal_localized_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_localized_title(const std::string& value);
  std::string* _internal_mutable_localized_title();
  public:

  // bytes icon = 3;
  void clear_icon();
  const std::string& icon() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_icon(ArgT0&& arg0, ArgT... args);
  std::string* mutable_icon();
  PROTOBUF_NODISCARD std::string* release_icon();
  void set_allocated_icon(std::string* icon);
  private:
  const std::string& _internal_icon() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_icon(const std::string& value);
  std::string* _internal_mutable_icon();
  public:

  // .explore_sites.Category.CategoryType type = 1;
  void clear_type();
  ::explore_sites::Category_CategoryType type() const;
  void set_type(::explore_sites::Category_CategoryType value);
  private:
  ::explore_sites::Category_CategoryType _internal_type() const;
  void _internal_set_type(::explore_sites::Category_CategoryType value);
  public:

  // @@protoc_insertion_point(class_scope:explore_sites.Category)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::explore_sites::Site > sites_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr localized_title_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr icon_;
  int type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_catalog_2eproto;
};
// -------------------------------------------------------------------

class Site final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:explore_sites.Site) */ {
 public:
  inline Site() : Site(nullptr) {}
  ~Site() override;
  explicit PROTOBUF_CONSTEXPR Site(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Site(const Site& from);
  Site(Site&& from) noexcept
    : Site() {
    *this = ::std::move(from);
  }

  inline Site& operator=(const Site& from) {
    CopyFrom(from);
    return *this;
  }
  inline Site& operator=(Site&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const Site& default_instance() {
    return *internal_default_instance();
  }
  static inline const Site* internal_default_instance() {
    return reinterpret_cast<const Site*>(
               &_Site_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Site& a, Site& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(Site* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Site* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Site* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Site>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Site& from);
  void MergeFrom(const Site& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Site* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "explore_sites.Site";
  }
  protected:
  explicit Site(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSiteUrlFieldNumber = 1,
    kIconFieldNumber = 2,
    kTitleFieldNumber = 3,
  };
  // string site_url = 1;
  void clear_site_url();
  const std::string& site_url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_site_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_site_url();
  PROTOBUF_NODISCARD std::string* release_site_url();
  void set_allocated_site_url(std::string* site_url);
  private:
  const std::string& _internal_site_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_site_url(const std::string& value);
  std::string* _internal_mutable_site_url();
  public:

  // bytes icon = 2;
  void clear_icon();
  const std::string& icon() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_icon(ArgT0&& arg0, ArgT... args);
  std::string* mutable_icon();
  PROTOBUF_NODISCARD std::string* release_icon();
  void set_allocated_icon(std::string* icon);
  private:
  const std::string& _internal_icon() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_icon(const std::string& value);
  std::string* _internal_mutable_icon();
  public:

  // string title = 3;
  void clear_title();
  const std::string& title() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_title(ArgT0&& arg0, ArgT... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* title);
  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(const std::string& value);
  std::string* _internal_mutable_title();
  public:

  // @@protoc_insertion_point(class_scope:explore_sites.Site)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr site_url_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr icon_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_catalog_2eproto;
};
// -------------------------------------------------------------------

class GetCatalogRequest final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:explore_sites.GetCatalogRequest) */ {
 public:
  inline GetCatalogRequest() : GetCatalogRequest(nullptr) {}
  ~GetCatalogRequest() override;
  explicit PROTOBUF_CONSTEXPR GetCatalogRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetCatalogRequest(const GetCatalogRequest& from);
  GetCatalogRequest(GetCatalogRequest&& from) noexcept
    : GetCatalogRequest() {
    *this = ::std::move(from);
  }

  inline GetCatalogRequest& operator=(const GetCatalogRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetCatalogRequest& operator=(GetCatalogRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const GetCatalogRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetCatalogRequest* internal_default_instance() {
    return reinterpret_cast<const GetCatalogRequest*>(
               &_GetCatalogRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(GetCatalogRequest& a, GetCatalogRequest& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(GetCatalogRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetCatalogRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetCatalogRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetCatalogRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const GetCatalogRequest& from);
  void MergeFrom(const GetCatalogRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GetCatalogRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "explore_sites.GetCatalogRequest";
  }
  protected:
  explicit GetCatalogRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCountryCodeFieldNumber = 2,
    kVersionTokenFieldNumber = 3,
  };
  // string country_code = 2;
  void clear_country_code();
  const std::string& country_code() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_country_code(ArgT0&& arg0, ArgT... args);
  std::string* mutable_country_code();
  PROTOBUF_NODISCARD std::string* release_country_code();
  void set_allocated_country_code(std::string* country_code);
  private:
  const std::string& _internal_country_code() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_country_code(const std::string& value);
  std::string* _internal_mutable_country_code();
  public:

  // string version_token = 3;
  void clear_version_token();
  const std::string& version_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version_token();
  PROTOBUF_NODISCARD std::string* release_version_token();
  void set_allocated_version_token(std::string* version_token);
  private:
  const std::string& _internal_version_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version_token(const std::string& value);
  std::string* _internal_mutable_version_token();
  public:

  // @@protoc_insertion_point(class_scope:explore_sites.GetCatalogRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr country_code_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_token_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_catalog_2eproto;
};
// -------------------------------------------------------------------

class GetCatalogResponse final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:explore_sites.GetCatalogResponse) */ {
 public:
  inline GetCatalogResponse() : GetCatalogResponse(nullptr) {}
  ~GetCatalogResponse() override;
  explicit PROTOBUF_CONSTEXPR GetCatalogResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetCatalogResponse(const GetCatalogResponse& from);
  GetCatalogResponse(GetCatalogResponse&& from) noexcept
    : GetCatalogResponse() {
    *this = ::std::move(from);
  }

  inline GetCatalogResponse& operator=(const GetCatalogResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetCatalogResponse& operator=(GetCatalogResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const GetCatalogResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetCatalogResponse* internal_default_instance() {
    return reinterpret_cast<const GetCatalogResponse*>(
               &_GetCatalogResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(GetCatalogResponse& a, GetCatalogResponse& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(GetCatalogResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetCatalogResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetCatalogResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetCatalogResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const GetCatalogResponse& from);
  void MergeFrom(const GetCatalogResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GetCatalogResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "explore_sites.GetCatalogResponse";
  }
  protected:
  explicit GetCatalogResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCountryCodeFieldNumber = 3,
    kVersionTokenFieldNumber = 4,
    kCatalogFieldNumber = 1,
  };
  // string country_code = 3;
  void clear_country_code();
  const std::string& country_code() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_country_code(ArgT0&& arg0, ArgT... args);
  std::string* mutable_country_code();
  PROTOBUF_NODISCARD std::string* release_country_code();
  void set_allocated_country_code(std::string* country_code);
  private:
  const std::string& _internal_country_code() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_country_code(const std::string& value);
  std::string* _internal_mutable_country_code();
  public:

  // string version_token = 4;
  void clear_version_token();
  const std::string& version_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version_token();
  PROTOBUF_NODISCARD std::string* release_version_token();
  void set_allocated_version_token(std::string* version_token);
  private:
  const std::string& _internal_version_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version_token(const std::string& value);
  std::string* _internal_mutable_version_token();
  public:

  // .explore_sites.Catalog catalog = 1;
  bool has_catalog() const;
  private:
  bool _internal_has_catalog() const;
  public:
  void clear_catalog();
  const ::explore_sites::Catalog& catalog() const;
  PROTOBUF_NODISCARD ::explore_sites::Catalog* release_catalog();
  ::explore_sites::Catalog* mutable_catalog();
  void set_allocated_catalog(::explore_sites::Catalog* catalog);
  private:
  const ::explore_sites::Catalog& _internal_catalog() const;
  ::explore_sites::Catalog* _internal_mutable_catalog();
  public:
  void unsafe_arena_set_allocated_catalog(
      ::explore_sites::Catalog* catalog);
  ::explore_sites::Catalog* unsafe_arena_release_catalog();

  // @@protoc_insertion_point(class_scope:explore_sites.GetCatalogResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr country_code_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_token_;
  ::explore_sites::Catalog* catalog_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_catalog_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Catalog

// repeated .explore_sites.Category categories = 1;
inline int Catalog::_internal_categories_size() const {
  return categories_.size();
}
inline int Catalog::categories_size() const {
  return _internal_categories_size();
}
inline void Catalog::clear_categories() {
  categories_.Clear();
}
inline ::explore_sites::Category* Catalog::mutable_categories(int index) {
  // @@protoc_insertion_point(field_mutable:explore_sites.Catalog.categories)
  return categories_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::explore_sites::Category >*
Catalog::mutable_categories() {
  // @@protoc_insertion_point(field_mutable_list:explore_sites.Catalog.categories)
  return &categories_;
}
inline const ::explore_sites::Category& Catalog::_internal_categories(int index) const {
  return categories_.Get(index);
}
inline const ::explore_sites::Category& Catalog::categories(int index) const {
  // @@protoc_insertion_point(field_get:explore_sites.Catalog.categories)
  return _internal_categories(index);
}
inline ::explore_sites::Category* Catalog::_internal_add_categories() {
  return categories_.Add();
}
inline ::explore_sites::Category* Catalog::add_categories() {
  ::explore_sites::Category* _add = _internal_add_categories();
  // @@protoc_insertion_point(field_add:explore_sites.Catalog.categories)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::explore_sites::Category >&
Catalog::categories() const {
  // @@protoc_insertion_point(field_list:explore_sites.Catalog.categories)
  return categories_;
}

// -------------------------------------------------------------------

// Category

// .explore_sites.Category.CategoryType type = 1;
inline void Category::clear_type() {
  type_ = 0;
}
inline ::explore_sites::Category_CategoryType Category::_internal_type() const {
  return static_cast< ::explore_sites::Category_CategoryType >(type_);
}
inline ::explore_sites::Category_CategoryType Category::type() const {
  // @@protoc_insertion_point(field_get:explore_sites.Category.type)
  return _internal_type();
}
inline void Category::_internal_set_type(::explore_sites::Category_CategoryType value) {
  
  type_ = value;
}
inline void Category::set_type(::explore_sites::Category_CategoryType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:explore_sites.Category.type)
}

// string localized_title = 2;
inline void Category::clear_localized_title() {
  localized_title_.ClearToEmpty();
}
inline const std::string& Category::localized_title() const {
  // @@protoc_insertion_point(field_get:explore_sites.Category.localized_title)
  return _internal_localized_title();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Category::set_localized_title(ArgT0&& arg0, ArgT... args) {
 
 localized_title_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:explore_sites.Category.localized_title)
}
inline std::string* Category::mutable_localized_title() {
  std::string* _s = _internal_mutable_localized_title();
  // @@protoc_insertion_point(field_mutable:explore_sites.Category.localized_title)
  return _s;
}
inline const std::string& Category::_internal_localized_title() const {
  return localized_title_.Get();
}
inline void Category::_internal_set_localized_title(const std::string& value) {
  
  localized_title_.Set(value, GetArenaForAllocation());
}
inline std::string* Category::_internal_mutable_localized_title() {
  
  return localized_title_.Mutable(GetArenaForAllocation());
}
inline std::string* Category::release_localized_title() {
  // @@protoc_insertion_point(field_release:explore_sites.Category.localized_title)
  return localized_title_.Release();
}
inline void Category::set_allocated_localized_title(std::string* localized_title) {
  if (localized_title != nullptr) {
    
  } else {
    
  }
  localized_title_.SetAllocated(localized_title, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (localized_title_.IsDefault()) {
    localized_title_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:explore_sites.Category.localized_title)
}

// bytes icon = 3;
inline void Category::clear_icon() {
  icon_.ClearToEmpty();
}
inline const std::string& Category::icon() const {
  // @@protoc_insertion_point(field_get:explore_sites.Category.icon)
  return _internal_icon();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Category::set_icon(ArgT0&& arg0, ArgT... args) {
 
 icon_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:explore_sites.Category.icon)
}
inline std::string* Category::mutable_icon() {
  std::string* _s = _internal_mutable_icon();
  // @@protoc_insertion_point(field_mutable:explore_sites.Category.icon)
  return _s;
}
inline const std::string& Category::_internal_icon() const {
  return icon_.Get();
}
inline void Category::_internal_set_icon(const std::string& value) {
  
  icon_.Set(value, GetArenaForAllocation());
}
inline std::string* Category::_internal_mutable_icon() {
  
  return icon_.Mutable(GetArenaForAllocation());
}
inline std::string* Category::release_icon() {
  // @@protoc_insertion_point(field_release:explore_sites.Category.icon)
  return icon_.Release();
}
inline void Category::set_allocated_icon(std::string* icon) {
  if (icon != nullptr) {
    
  } else {
    
  }
  icon_.SetAllocated(icon, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (icon_.IsDefault()) {
    icon_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:explore_sites.Category.icon)
}

// repeated .explore_sites.Site sites = 4;
inline int Category::_internal_sites_size() const {
  return sites_.size();
}
inline int Category::sites_size() const {
  return _internal_sites_size();
}
inline void Category::clear_sites() {
  sites_.Clear();
}
inline ::explore_sites::Site* Category::mutable_sites(int index) {
  // @@protoc_insertion_point(field_mutable:explore_sites.Category.sites)
  return sites_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::explore_sites::Site >*
Category::mutable_sites() {
  // @@protoc_insertion_point(field_mutable_list:explore_sites.Category.sites)
  return &sites_;
}
inline const ::explore_sites::Site& Category::_internal_sites(int index) const {
  return sites_.Get(index);
}
inline const ::explore_sites::Site& Category::sites(int index) const {
  // @@protoc_insertion_point(field_get:explore_sites.Category.sites)
  return _internal_sites(index);
}
inline ::explore_sites::Site* Category::_internal_add_sites() {
  return sites_.Add();
}
inline ::explore_sites::Site* Category::add_sites() {
  ::explore_sites::Site* _add = _internal_add_sites();
  // @@protoc_insertion_point(field_add:explore_sites.Category.sites)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::explore_sites::Site >&
Category::sites() const {
  // @@protoc_insertion_point(field_list:explore_sites.Category.sites)
  return sites_;
}

// -------------------------------------------------------------------

// Site

// string site_url = 1;
inline void Site::clear_site_url() {
  site_url_.ClearToEmpty();
}
inline const std::string& Site::site_url() const {
  // @@protoc_insertion_point(field_get:explore_sites.Site.site_url)
  return _internal_site_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Site::set_site_url(ArgT0&& arg0, ArgT... args) {
 
 site_url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:explore_sites.Site.site_url)
}
inline std::string* Site::mutable_site_url() {
  std::string* _s = _internal_mutable_site_url();
  // @@protoc_insertion_point(field_mutable:explore_sites.Site.site_url)
  return _s;
}
inline const std::string& Site::_internal_site_url() const {
  return site_url_.Get();
}
inline void Site::_internal_set_site_url(const std::string& value) {
  
  site_url_.Set(value, GetArenaForAllocation());
}
inline std::string* Site::_internal_mutable_site_url() {
  
  return site_url_.Mutable(GetArenaForAllocation());
}
inline std::string* Site::release_site_url() {
  // @@protoc_insertion_point(field_release:explore_sites.Site.site_url)
  return site_url_.Release();
}
inline void Site::set_allocated_site_url(std::string* site_url) {
  if (site_url != nullptr) {
    
  } else {
    
  }
  site_url_.SetAllocated(site_url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (site_url_.IsDefault()) {
    site_url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:explore_sites.Site.site_url)
}

// bytes icon = 2;
inline void Site::clear_icon() {
  icon_.ClearToEmpty();
}
inline const std::string& Site::icon() const {
  // @@protoc_insertion_point(field_get:explore_sites.Site.icon)
  return _internal_icon();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Site::set_icon(ArgT0&& arg0, ArgT... args) {
 
 icon_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:explore_sites.Site.icon)
}
inline std::string* Site::mutable_icon() {
  std::string* _s = _internal_mutable_icon();
  // @@protoc_insertion_point(field_mutable:explore_sites.Site.icon)
  return _s;
}
inline const std::string& Site::_internal_icon() const {
  return icon_.Get();
}
inline void Site::_internal_set_icon(const std::string& value) {
  
  icon_.Set(value, GetArenaForAllocation());
}
inline std::string* Site::_internal_mutable_icon() {
  
  return icon_.Mutable(GetArenaForAllocation());
}
inline std::string* Site::release_icon() {
  // @@protoc_insertion_point(field_release:explore_sites.Site.icon)
  return icon_.Release();
}
inline void Site::set_allocated_icon(std::string* icon) {
  if (icon != nullptr) {
    
  } else {
    
  }
  icon_.SetAllocated(icon, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (icon_.IsDefault()) {
    icon_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:explore_sites.Site.icon)
}

// string title = 3;
inline void Site::clear_title() {
  title_.ClearToEmpty();
}
inline const std::string& Site::title() const {
  // @@protoc_insertion_point(field_get:explore_sites.Site.title)
  return _internal_title();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Site::set_title(ArgT0&& arg0, ArgT... args) {
 
 title_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:explore_sites.Site.title)
}
inline std::string* Site::mutable_title() {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:explore_sites.Site.title)
  return _s;
}
inline const std::string& Site::_internal_title() const {
  return title_.Get();
}
inline void Site::_internal_set_title(const std::string& value) {
  
  title_.Set(value, GetArenaForAllocation());
}
inline std::string* Site::_internal_mutable_title() {
  
  return title_.Mutable(GetArenaForAllocation());
}
inline std::string* Site::release_title() {
  // @@protoc_insertion_point(field_release:explore_sites.Site.title)
  return title_.Release();
}
inline void Site::set_allocated_title(std::string* title) {
  if (title != nullptr) {
    
  } else {
    
  }
  title_.SetAllocated(title, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (title_.IsDefault()) {
    title_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:explore_sites.Site.title)
}

// -------------------------------------------------------------------

// GetCatalogRequest

// string country_code = 2;
inline void GetCatalogRequest::clear_country_code() {
  country_code_.ClearToEmpty();
}
inline const std::string& GetCatalogRequest::country_code() const {
  // @@protoc_insertion_point(field_get:explore_sites.GetCatalogRequest.country_code)
  return _internal_country_code();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetCatalogRequest::set_country_code(ArgT0&& arg0, ArgT... args) {
 
 country_code_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:explore_sites.GetCatalogRequest.country_code)
}
inline std::string* GetCatalogRequest::mutable_country_code() {
  std::string* _s = _internal_mutable_country_code();
  // @@protoc_insertion_point(field_mutable:explore_sites.GetCatalogRequest.country_code)
  return _s;
}
inline const std::string& GetCatalogRequest::_internal_country_code() const {
  return country_code_.Get();
}
inline void GetCatalogRequest::_internal_set_country_code(const std::string& value) {
  
  country_code_.Set(value, GetArenaForAllocation());
}
inline std::string* GetCatalogRequest::_internal_mutable_country_code() {
  
  return country_code_.Mutable(GetArenaForAllocation());
}
inline std::string* GetCatalogRequest::release_country_code() {
  // @@protoc_insertion_point(field_release:explore_sites.GetCatalogRequest.country_code)
  return country_code_.Release();
}
inline void GetCatalogRequest::set_allocated_country_code(std::string* country_code) {
  if (country_code != nullptr) {
    
  } else {
    
  }
  country_code_.SetAllocated(country_code, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (country_code_.IsDefault()) {
    country_code_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:explore_sites.GetCatalogRequest.country_code)
}

// string version_token = 3;
inline void GetCatalogRequest::clear_version_token() {
  version_token_.ClearToEmpty();
}
inline const std::string& GetCatalogRequest::version_token() const {
  // @@protoc_insertion_point(field_get:explore_sites.GetCatalogRequest.version_token)
  return _internal_version_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetCatalogRequest::set_version_token(ArgT0&& arg0, ArgT... args) {
 
 version_token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:explore_sites.GetCatalogRequest.version_token)
}
inline std::string* GetCatalogRequest::mutable_version_token() {
  std::string* _s = _internal_mutable_version_token();
  // @@protoc_insertion_point(field_mutable:explore_sites.GetCatalogRequest.version_token)
  return _s;
}
inline const std::string& GetCatalogRequest::_internal_version_token() const {
  return version_token_.Get();
}
inline void GetCatalogRequest::_internal_set_version_token(const std::string& value) {
  
  version_token_.Set(value, GetArenaForAllocation());
}
inline std::string* GetCatalogRequest::_internal_mutable_version_token() {
  
  return version_token_.Mutable(GetArenaForAllocation());
}
inline std::string* GetCatalogRequest::release_version_token() {
  // @@protoc_insertion_point(field_release:explore_sites.GetCatalogRequest.version_token)
  return version_token_.Release();
}
inline void GetCatalogRequest::set_allocated_version_token(std::string* version_token) {
  if (version_token != nullptr) {
    
  } else {
    
  }
  version_token_.SetAllocated(version_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (version_token_.IsDefault()) {
    version_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:explore_sites.GetCatalogRequest.version_token)
}

// -------------------------------------------------------------------

// GetCatalogResponse

// .explore_sites.Catalog catalog = 1;
inline bool GetCatalogResponse::_internal_has_catalog() const {
  return this != internal_default_instance() && catalog_ != nullptr;
}
inline bool GetCatalogResponse::has_catalog() const {
  return _internal_has_catalog();
}
inline void GetCatalogResponse::clear_catalog() {
  if (GetArenaForAllocation() == nullptr && catalog_ != nullptr) {
    delete catalog_;
  }
  catalog_ = nullptr;
}
inline const ::explore_sites::Catalog& GetCatalogResponse::_internal_catalog() const {
  const ::explore_sites::Catalog* p = catalog_;
  return p != nullptr ? *p : reinterpret_cast<const ::explore_sites::Catalog&>(
      ::explore_sites::_Catalog_default_instance_);
}
inline const ::explore_sites::Catalog& GetCatalogResponse::catalog() const {
  // @@protoc_insertion_point(field_get:explore_sites.GetCatalogResponse.catalog)
  return _internal_catalog();
}
inline void GetCatalogResponse::unsafe_arena_set_allocated_catalog(
    ::explore_sites::Catalog* catalog) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(catalog_);
  }
  catalog_ = catalog;
  if (catalog) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:explore_sites.GetCatalogResponse.catalog)
}
inline ::explore_sites::Catalog* GetCatalogResponse::release_catalog() {
  
  ::explore_sites::Catalog* temp = catalog_;
  catalog_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::explore_sites::Catalog* GetCatalogResponse::unsafe_arena_release_catalog() {
  // @@protoc_insertion_point(field_release:explore_sites.GetCatalogResponse.catalog)
  
  ::explore_sites::Catalog* temp = catalog_;
  catalog_ = nullptr;
  return temp;
}
inline ::explore_sites::Catalog* GetCatalogResponse::_internal_mutable_catalog() {
  
  if (catalog_ == nullptr) {
    auto* p = CreateMaybeMessage<::explore_sites::Catalog>(GetArenaForAllocation());
    catalog_ = p;
  }
  return catalog_;
}
inline ::explore_sites::Catalog* GetCatalogResponse::mutable_catalog() {
  ::explore_sites::Catalog* _msg = _internal_mutable_catalog();
  // @@protoc_insertion_point(field_mutable:explore_sites.GetCatalogResponse.catalog)
  return _msg;
}
inline void GetCatalogResponse::set_allocated_catalog(::explore_sites::Catalog* catalog) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete catalog_;
  }
  if (catalog) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(catalog);
    if (message_arena != submessage_arena) {
      catalog = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, catalog, submessage_arena);
    }
    
  } else {
    
  }
  catalog_ = catalog;
  // @@protoc_insertion_point(field_set_allocated:explore_sites.GetCatalogResponse.catalog)
}

// string country_code = 3;
inline void GetCatalogResponse::clear_country_code() {
  country_code_.ClearToEmpty();
}
inline const std::string& GetCatalogResponse::country_code() const {
  // @@protoc_insertion_point(field_get:explore_sites.GetCatalogResponse.country_code)
  return _internal_country_code();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetCatalogResponse::set_country_code(ArgT0&& arg0, ArgT... args) {
 
 country_code_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:explore_sites.GetCatalogResponse.country_code)
}
inline std::string* GetCatalogResponse::mutable_country_code() {
  std::string* _s = _internal_mutable_country_code();
  // @@protoc_insertion_point(field_mutable:explore_sites.GetCatalogResponse.country_code)
  return _s;
}
inline const std::string& GetCatalogResponse::_internal_country_code() const {
  return country_code_.Get();
}
inline void GetCatalogResponse::_internal_set_country_code(const std::string& value) {
  
  country_code_.Set(value, GetArenaForAllocation());
}
inline std::string* GetCatalogResponse::_internal_mutable_country_code() {
  
  return country_code_.Mutable(GetArenaForAllocation());
}
inline std::string* GetCatalogResponse::release_country_code() {
  // @@protoc_insertion_point(field_release:explore_sites.GetCatalogResponse.country_code)
  return country_code_.Release();
}
inline void GetCatalogResponse::set_allocated_country_code(std::string* country_code) {
  if (country_code != nullptr) {
    
  } else {
    
  }
  country_code_.SetAllocated(country_code, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (country_code_.IsDefault()) {
    country_code_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:explore_sites.GetCatalogResponse.country_code)
}

// string version_token = 4;
inline void GetCatalogResponse::clear_version_token() {
  version_token_.ClearToEmpty();
}
inline const std::string& GetCatalogResponse::version_token() const {
  // @@protoc_insertion_point(field_get:explore_sites.GetCatalogResponse.version_token)
  return _internal_version_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetCatalogResponse::set_version_token(ArgT0&& arg0, ArgT... args) {
 
 version_token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:explore_sites.GetCatalogResponse.version_token)
}
inline std::string* GetCatalogResponse::mutable_version_token() {
  std::string* _s = _internal_mutable_version_token();
  // @@protoc_insertion_point(field_mutable:explore_sites.GetCatalogResponse.version_token)
  return _s;
}
inline const std::string& GetCatalogResponse::_internal_version_token() const {
  return version_token_.Get();
}
inline void GetCatalogResponse::_internal_set_version_token(const std::string& value) {
  
  version_token_.Set(value, GetArenaForAllocation());
}
inline std::string* GetCatalogResponse::_internal_mutable_version_token() {
  
  return version_token_.Mutable(GetArenaForAllocation());
}
inline std::string* GetCatalogResponse::release_version_token() {
  // @@protoc_insertion_point(field_release:explore_sites.GetCatalogResponse.version_token)
  return version_token_.Release();
}
inline void GetCatalogResponse::set_allocated_version_token(std::string* version_token) {
  if (version_token != nullptr) {
    
  } else {
    
  }
  version_token_.SetAllocated(version_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (version_token_.IsDefault()) {
    version_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:explore_sites.GetCatalogResponse.version_token)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace explore_sites

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::explore_sites::Category_CategoryType> : ::std::true_type {};

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_catalog_2eproto
