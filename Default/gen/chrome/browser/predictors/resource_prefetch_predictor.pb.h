// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: resource_prefetch_predictor.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_resource_5fprefetch_5fpredictor_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_resource_5fprefetch_5fpredictor_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3020000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3020000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_resource_5fprefetch_5fpredictor_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_resource_5fprefetch_5fpredictor_2eproto {
  static const uint32_t offsets[];
};
namespace predictors {
class OriginData;
struct OriginDataDefaultTypeInternal;
extern OriginDataDefaultTypeInternal _OriginData_default_instance_;
class OriginStat;
struct OriginStatDefaultTypeInternal;
extern OriginStatDefaultTypeInternal _OriginStat_default_instance_;
class RedirectData;
struct RedirectDataDefaultTypeInternal;
extern RedirectDataDefaultTypeInternal _RedirectData_default_instance_;
class RedirectStat;
struct RedirectStatDefaultTypeInternal;
extern RedirectStatDefaultTypeInternal _RedirectStat_default_instance_;
}  // namespace predictors
PROTOBUF_NAMESPACE_OPEN
template<> ::predictors::OriginData* Arena::CreateMaybeMessage<::predictors::OriginData>(Arena*);
template<> ::predictors::OriginStat* Arena::CreateMaybeMessage<::predictors::OriginStat>(Arena*);
template<> ::predictors::RedirectData* Arena::CreateMaybeMessage<::predictors::RedirectData>(Arena*);
template<> ::predictors::RedirectStat* Arena::CreateMaybeMessage<::predictors::RedirectStat>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace predictors {

// ===================================================================

class RedirectStat final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:predictors.RedirectStat) */ {
 public:
  inline RedirectStat() : RedirectStat(nullptr) {}
  ~RedirectStat() override;
  explicit PROTOBUF_CONSTEXPR RedirectStat(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RedirectStat(const RedirectStat& from);
  RedirectStat(RedirectStat&& from) noexcept
    : RedirectStat() {
    *this = ::std::move(from);
  }

  inline RedirectStat& operator=(const RedirectStat& from) {
    CopyFrom(from);
    return *this;
  }
  inline RedirectStat& operator=(RedirectStat&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const RedirectStat& default_instance() {
    return *internal_default_instance();
  }
  static inline const RedirectStat* internal_default_instance() {
    return reinterpret_cast<const RedirectStat*>(
               &_RedirectStat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(RedirectStat& a, RedirectStat& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(RedirectStat* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RedirectStat* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RedirectStat* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RedirectStat>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const RedirectStat& from);
  void MergeFrom(const RedirectStat& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RedirectStat* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "predictors.RedirectStat";
  }
  protected:
  explicit RedirectStat(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUrlFieldNumber = 1,
    kUrlSchemeFieldNumber = 5,
    kNumberOfHitsFieldNumber = 2,
    kNumberOfMissesFieldNumber = 3,
    kConsecutiveMissesFieldNumber = 4,
    kUrlPortFieldNumber = 6,
  };
  // optional string url = 1;
  bool has_url() const;
  private:
  bool _internal_has_url() const;
  public:
  void clear_url();
  const std::string& url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_url();
  PROTOBUF_NODISCARD std::string* release_url();
  void set_allocated_url(std::string* url);
  private:
  const std::string& _internal_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_url(const std::string& value);
  std::string* _internal_mutable_url();
  public:

  // optional string url_scheme = 5;
  bool has_url_scheme() const;
  private:
  bool _internal_has_url_scheme() const;
  public:
  void clear_url_scheme();
  const std::string& url_scheme() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_url_scheme(ArgT0&& arg0, ArgT... args);
  std::string* mutable_url_scheme();
  PROTOBUF_NODISCARD std::string* release_url_scheme();
  void set_allocated_url_scheme(std::string* url_scheme);
  private:
  const std::string& _internal_url_scheme() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_url_scheme(const std::string& value);
  std::string* _internal_mutable_url_scheme();
  public:

  // optional uint32 number_of_hits = 2;
  bool has_number_of_hits() const;
  private:
  bool _internal_has_number_of_hits() const;
  public:
  void clear_number_of_hits();
  uint32_t number_of_hits() const;
  void set_number_of_hits(uint32_t value);
  private:
  uint32_t _internal_number_of_hits() const;
  void _internal_set_number_of_hits(uint32_t value);
  public:

  // optional uint32 number_of_misses = 3;
  bool has_number_of_misses() const;
  private:
  bool _internal_has_number_of_misses() const;
  public:
  void clear_number_of_misses();
  uint32_t number_of_misses() const;
  void set_number_of_misses(uint32_t value);
  private:
  uint32_t _internal_number_of_misses() const;
  void _internal_set_number_of_misses(uint32_t value);
  public:

  // optional uint32 consecutive_misses = 4;
  bool has_consecutive_misses() const;
  private:
  bool _internal_has_consecutive_misses() const;
  public:
  void clear_consecutive_misses();
  uint32_t consecutive_misses() const;
  void set_consecutive_misses(uint32_t value);
  private:
  uint32_t _internal_consecutive_misses() const;
  void _internal_set_consecutive_misses(uint32_t value);
  public:

  // optional int32 url_port = 6;
  bool has_url_port() const;
  private:
  bool _internal_has_url_port() const;
  public:
  void clear_url_port();
  int32_t url_port() const;
  void set_url_port(int32_t value);
  private:
  int32_t _internal_url_port() const;
  void _internal_set_url_port(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:predictors.RedirectStat)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr url_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr url_scheme_;
  uint32_t number_of_hits_;
  uint32_t number_of_misses_;
  uint32_t consecutive_misses_;
  int32_t url_port_;
  friend struct ::TableStruct_resource_5fprefetch_5fpredictor_2eproto;
};
// -------------------------------------------------------------------

class RedirectData final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:predictors.RedirectData) */ {
 public:
  inline RedirectData() : RedirectData(nullptr) {}
  ~RedirectData() override;
  explicit PROTOBUF_CONSTEXPR RedirectData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RedirectData(const RedirectData& from);
  RedirectData(RedirectData&& from) noexcept
    : RedirectData() {
    *this = ::std::move(from);
  }

  inline RedirectData& operator=(const RedirectData& from) {
    CopyFrom(from);
    return *this;
  }
  inline RedirectData& operator=(RedirectData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const RedirectData& default_instance() {
    return *internal_default_instance();
  }
  static inline const RedirectData* internal_default_instance() {
    return reinterpret_cast<const RedirectData*>(
               &_RedirectData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(RedirectData& a, RedirectData& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(RedirectData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RedirectData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RedirectData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RedirectData>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const RedirectData& from);
  void MergeFrom(const RedirectData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RedirectData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "predictors.RedirectData";
  }
  protected:
  explicit RedirectData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRedirectEndpointsFieldNumber = 3,
    kPrimaryKeyFieldNumber = 1,
    kLastVisitTimeFieldNumber = 2,
  };
  // repeated .predictors.RedirectStat redirect_endpoints = 3;
  int redirect_endpoints_size() const;
  private:
  int _internal_redirect_endpoints_size() const;
  public:
  void clear_redirect_endpoints();
  ::predictors::RedirectStat* mutable_redirect_endpoints(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::predictors::RedirectStat >*
      mutable_redirect_endpoints();
  private:
  const ::predictors::RedirectStat& _internal_redirect_endpoints(int index) const;
  ::predictors::RedirectStat* _internal_add_redirect_endpoints();
  public:
  const ::predictors::RedirectStat& redirect_endpoints(int index) const;
  ::predictors::RedirectStat* add_redirect_endpoints();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::predictors::RedirectStat >&
      redirect_endpoints() const;

  // optional string primary_key = 1;
  bool has_primary_key() const;
  private:
  bool _internal_has_primary_key() const;
  public:
  void clear_primary_key();
  const std::string& primary_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_primary_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_primary_key();
  PROTOBUF_NODISCARD std::string* release_primary_key();
  void set_allocated_primary_key(std::string* primary_key);
  private:
  const std::string& _internal_primary_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_primary_key(const std::string& value);
  std::string* _internal_mutable_primary_key();
  public:

  // optional uint64 last_visit_time = 2;
  bool has_last_visit_time() const;
  private:
  bool _internal_has_last_visit_time() const;
  public:
  void clear_last_visit_time();
  uint64_t last_visit_time() const;
  void set_last_visit_time(uint64_t value);
  private:
  uint64_t _internal_last_visit_time() const;
  void _internal_set_last_visit_time(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:predictors.RedirectData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::predictors::RedirectStat > redirect_endpoints_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr primary_key_;
  uint64_t last_visit_time_;
  friend struct ::TableStruct_resource_5fprefetch_5fpredictor_2eproto;
};
// -------------------------------------------------------------------

class OriginStat final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:predictors.OriginStat) */ {
 public:
  inline OriginStat() : OriginStat(nullptr) {}
  ~OriginStat() override;
  explicit PROTOBUF_CONSTEXPR OriginStat(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OriginStat(const OriginStat& from);
  OriginStat(OriginStat&& from) noexcept
    : OriginStat() {
    *this = ::std::move(from);
  }

  inline OriginStat& operator=(const OriginStat& from) {
    CopyFrom(from);
    return *this;
  }
  inline OriginStat& operator=(OriginStat&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const OriginStat& default_instance() {
    return *internal_default_instance();
  }
  static inline const OriginStat* internal_default_instance() {
    return reinterpret_cast<const OriginStat*>(
               &_OriginStat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(OriginStat& a, OriginStat& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(OriginStat* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OriginStat* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OriginStat* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OriginStat>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const OriginStat& from);
  void MergeFrom(const OriginStat& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(OriginStat* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "predictors.OriginStat";
  }
  protected:
  explicit OriginStat(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOriginFieldNumber = 1,
    kNumberOfHitsFieldNumber = 2,
    kNumberOfMissesFieldNumber = 3,
    kAveragePositionFieldNumber = 5,
    kConsecutiveMissesFieldNumber = 4,
    kAlwaysAccessNetworkFieldNumber = 6,
    kAccessedNetworkFieldNumber = 7,
  };
  // optional string origin = 1;
  bool has_origin() const;
  private:
  bool _internal_has_origin() const;
  public:
  void clear_origin();
  const std::string& origin() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_origin(ArgT0&& arg0, ArgT... args);
  std::string* mutable_origin();
  PROTOBUF_NODISCARD std::string* release_origin();
  void set_allocated_origin(std::string* origin);
  private:
  const std::string& _internal_origin() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_origin(const std::string& value);
  std::string* _internal_mutable_origin();
  public:

  // optional uint32 number_of_hits = 2;
  bool has_number_of_hits() const;
  private:
  bool _internal_has_number_of_hits() const;
  public:
  void clear_number_of_hits();
  uint32_t number_of_hits() const;
  void set_number_of_hits(uint32_t value);
  private:
  uint32_t _internal_number_of_hits() const;
  void _internal_set_number_of_hits(uint32_t value);
  public:

  // optional uint32 number_of_misses = 3;
  bool has_number_of_misses() const;
  private:
  bool _internal_has_number_of_misses() const;
  public:
  void clear_number_of_misses();
  uint32_t number_of_misses() const;
  void set_number_of_misses(uint32_t value);
  private:
  uint32_t _internal_number_of_misses() const;
  void _internal_set_number_of_misses(uint32_t value);
  public:

  // optional double average_position = 5;
  bool has_average_position() const;
  private:
  bool _internal_has_average_position() const;
  public:
  void clear_average_position();
  double average_position() const;
  void set_average_position(double value);
  private:
  double _internal_average_position() const;
  void _internal_set_average_position(double value);
  public:

  // optional uint32 consecutive_misses = 4;
  bool has_consecutive_misses() const;
  private:
  bool _internal_has_consecutive_misses() const;
  public:
  void clear_consecutive_misses();
  uint32_t consecutive_misses() const;
  void set_consecutive_misses(uint32_t value);
  private:
  uint32_t _internal_consecutive_misses() const;
  void _internal_set_consecutive_misses(uint32_t value);
  public:

  // optional bool always_access_network = 6;
  bool has_always_access_network() const;
  private:
  bool _internal_has_always_access_network() const;
  public:
  void clear_always_access_network();
  bool always_access_network() const;
  void set_always_access_network(bool value);
  private:
  bool _internal_always_access_network() const;
  void _internal_set_always_access_network(bool value);
  public:

  // optional bool accessed_network = 7;
  bool has_accessed_network() const;
  private:
  bool _internal_has_accessed_network() const;
  public:
  void clear_accessed_network();
  bool accessed_network() const;
  void set_accessed_network(bool value);
  private:
  bool _internal_accessed_network() const;
  void _internal_set_accessed_network(bool value);
  public:

  // @@protoc_insertion_point(class_scope:predictors.OriginStat)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr origin_;
  uint32_t number_of_hits_;
  uint32_t number_of_misses_;
  double average_position_;
  uint32_t consecutive_misses_;
  bool always_access_network_;
  bool accessed_network_;
  friend struct ::TableStruct_resource_5fprefetch_5fpredictor_2eproto;
};
// -------------------------------------------------------------------

class OriginData final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:predictors.OriginData) */ {
 public:
  inline OriginData() : OriginData(nullptr) {}
  ~OriginData() override;
  explicit PROTOBUF_CONSTEXPR OriginData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OriginData(const OriginData& from);
  OriginData(OriginData&& from) noexcept
    : OriginData() {
    *this = ::std::move(from);
  }

  inline OriginData& operator=(const OriginData& from) {
    CopyFrom(from);
    return *this;
  }
  inline OriginData& operator=(OriginData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const OriginData& default_instance() {
    return *internal_default_instance();
  }
  static inline const OriginData* internal_default_instance() {
    return reinterpret_cast<const OriginData*>(
               &_OriginData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(OriginData& a, OriginData& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(OriginData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OriginData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OriginData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OriginData>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const OriginData& from);
  void MergeFrom(const OriginData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(OriginData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "predictors.OriginData";
  }
  protected:
  explicit OriginData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOriginsFieldNumber = 3,
    kHostFieldNumber = 1,
    kLastVisitTimeFieldNumber = 2,
  };
  // repeated .predictors.OriginStat origins = 3;
  int origins_size() const;
  private:
  int _internal_origins_size() const;
  public:
  void clear_origins();
  ::predictors::OriginStat* mutable_origins(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::predictors::OriginStat >*
      mutable_origins();
  private:
  const ::predictors::OriginStat& _internal_origins(int index) const;
  ::predictors::OriginStat* _internal_add_origins();
  public:
  const ::predictors::OriginStat& origins(int index) const;
  ::predictors::OriginStat* add_origins();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::predictors::OriginStat >&
      origins() const;

  // optional string host = 1;
  bool has_host() const;
  private:
  bool _internal_has_host() const;
  public:
  void clear_host();
  const std::string& host() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_host(ArgT0&& arg0, ArgT... args);
  std::string* mutable_host();
  PROTOBUF_NODISCARD std::string* release_host();
  void set_allocated_host(std::string* host);
  private:
  const std::string& _internal_host() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_host(const std::string& value);
  std::string* _internal_mutable_host();
  public:

  // optional uint64 last_visit_time = 2;
  bool has_last_visit_time() const;
  private:
  bool _internal_has_last_visit_time() const;
  public:
  void clear_last_visit_time();
  uint64_t last_visit_time() const;
  void set_last_visit_time(uint64_t value);
  private:
  uint64_t _internal_last_visit_time() const;
  void _internal_set_last_visit_time(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:predictors.OriginData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::predictors::OriginStat > origins_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr host_;
  uint64_t last_visit_time_;
  friend struct ::TableStruct_resource_5fprefetch_5fpredictor_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// RedirectStat

// optional string url = 1;
inline bool RedirectStat::_internal_has_url() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RedirectStat::has_url() const {
  return _internal_has_url();
}
inline void RedirectStat::clear_url() {
  url_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RedirectStat::url() const {
  // @@protoc_insertion_point(field_get:predictors.RedirectStat.url)
  return _internal_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RedirectStat::set_url(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:predictors.RedirectStat.url)
}
inline std::string* RedirectStat::mutable_url() {
  std::string* _s = _internal_mutable_url();
  // @@protoc_insertion_point(field_mutable:predictors.RedirectStat.url)
  return _s;
}
inline const std::string& RedirectStat::_internal_url() const {
  return url_.Get();
}
inline void RedirectStat::_internal_set_url(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  url_.Set(value, GetArenaForAllocation());
}
inline std::string* RedirectStat::_internal_mutable_url() {
  _has_bits_[0] |= 0x00000001u;
  return url_.Mutable(GetArenaForAllocation());
}
inline std::string* RedirectStat::release_url() {
  // @@protoc_insertion_point(field_release:predictors.RedirectStat.url)
  if (!_internal_has_url()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = url_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (url_.IsDefault()) {
    url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void RedirectStat::set_allocated_url(std::string* url) {
  if (url != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  url_.SetAllocated(url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (url_.IsDefault()) {
    url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:predictors.RedirectStat.url)
}

// optional uint32 number_of_hits = 2;
inline bool RedirectStat::_internal_has_number_of_hits() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool RedirectStat::has_number_of_hits() const {
  return _internal_has_number_of_hits();
}
inline void RedirectStat::clear_number_of_hits() {
  number_of_hits_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline uint32_t RedirectStat::_internal_number_of_hits() const {
  return number_of_hits_;
}
inline uint32_t RedirectStat::number_of_hits() const {
  // @@protoc_insertion_point(field_get:predictors.RedirectStat.number_of_hits)
  return _internal_number_of_hits();
}
inline void RedirectStat::_internal_set_number_of_hits(uint32_t value) {
  _has_bits_[0] |= 0x00000004u;
  number_of_hits_ = value;
}
inline void RedirectStat::set_number_of_hits(uint32_t value) {
  _internal_set_number_of_hits(value);
  // @@protoc_insertion_point(field_set:predictors.RedirectStat.number_of_hits)
}

// optional uint32 number_of_misses = 3;
inline bool RedirectStat::_internal_has_number_of_misses() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool RedirectStat::has_number_of_misses() const {
  return _internal_has_number_of_misses();
}
inline void RedirectStat::clear_number_of_misses() {
  number_of_misses_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline uint32_t RedirectStat::_internal_number_of_misses() const {
  return number_of_misses_;
}
inline uint32_t RedirectStat::number_of_misses() const {
  // @@protoc_insertion_point(field_get:predictors.RedirectStat.number_of_misses)
  return _internal_number_of_misses();
}
inline void RedirectStat::_internal_set_number_of_misses(uint32_t value) {
  _has_bits_[0] |= 0x00000008u;
  number_of_misses_ = value;
}
inline void RedirectStat::set_number_of_misses(uint32_t value) {
  _internal_set_number_of_misses(value);
  // @@protoc_insertion_point(field_set:predictors.RedirectStat.number_of_misses)
}

// optional uint32 consecutive_misses = 4;
inline bool RedirectStat::_internal_has_consecutive_misses() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool RedirectStat::has_consecutive_misses() const {
  return _internal_has_consecutive_misses();
}
inline void RedirectStat::clear_consecutive_misses() {
  consecutive_misses_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline uint32_t RedirectStat::_internal_consecutive_misses() const {
  return consecutive_misses_;
}
inline uint32_t RedirectStat::consecutive_misses() const {
  // @@protoc_insertion_point(field_get:predictors.RedirectStat.consecutive_misses)
  return _internal_consecutive_misses();
}
inline void RedirectStat::_internal_set_consecutive_misses(uint32_t value) {
  _has_bits_[0] |= 0x00000010u;
  consecutive_misses_ = value;
}
inline void RedirectStat::set_consecutive_misses(uint32_t value) {
  _internal_set_consecutive_misses(value);
  // @@protoc_insertion_point(field_set:predictors.RedirectStat.consecutive_misses)
}

// optional string url_scheme = 5;
inline bool RedirectStat::_internal_has_url_scheme() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool RedirectStat::has_url_scheme() const {
  return _internal_has_url_scheme();
}
inline void RedirectStat::clear_url_scheme() {
  url_scheme_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& RedirectStat::url_scheme() const {
  // @@protoc_insertion_point(field_get:predictors.RedirectStat.url_scheme)
  return _internal_url_scheme();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RedirectStat::set_url_scheme(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 url_scheme_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:predictors.RedirectStat.url_scheme)
}
inline std::string* RedirectStat::mutable_url_scheme() {
  std::string* _s = _internal_mutable_url_scheme();
  // @@protoc_insertion_point(field_mutable:predictors.RedirectStat.url_scheme)
  return _s;
}
inline const std::string& RedirectStat::_internal_url_scheme() const {
  return url_scheme_.Get();
}
inline void RedirectStat::_internal_set_url_scheme(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  url_scheme_.Set(value, GetArenaForAllocation());
}
inline std::string* RedirectStat::_internal_mutable_url_scheme() {
  _has_bits_[0] |= 0x00000002u;
  return url_scheme_.Mutable(GetArenaForAllocation());
}
inline std::string* RedirectStat::release_url_scheme() {
  // @@protoc_insertion_point(field_release:predictors.RedirectStat.url_scheme)
  if (!_internal_has_url_scheme()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = url_scheme_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (url_scheme_.IsDefault()) {
    url_scheme_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void RedirectStat::set_allocated_url_scheme(std::string* url_scheme) {
  if (url_scheme != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  url_scheme_.SetAllocated(url_scheme, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (url_scheme_.IsDefault()) {
    url_scheme_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:predictors.RedirectStat.url_scheme)
}

// optional int32 url_port = 6;
inline bool RedirectStat::_internal_has_url_port() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool RedirectStat::has_url_port() const {
  return _internal_has_url_port();
}
inline void RedirectStat::clear_url_port() {
  url_port_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline int32_t RedirectStat::_internal_url_port() const {
  return url_port_;
}
inline int32_t RedirectStat::url_port() const {
  // @@protoc_insertion_point(field_get:predictors.RedirectStat.url_port)
  return _internal_url_port();
}
inline void RedirectStat::_internal_set_url_port(int32_t value) {
  _has_bits_[0] |= 0x00000020u;
  url_port_ = value;
}
inline void RedirectStat::set_url_port(int32_t value) {
  _internal_set_url_port(value);
  // @@protoc_insertion_point(field_set:predictors.RedirectStat.url_port)
}

// -------------------------------------------------------------------

// RedirectData

// optional string primary_key = 1;
inline bool RedirectData::_internal_has_primary_key() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RedirectData::has_primary_key() const {
  return _internal_has_primary_key();
}
inline void RedirectData::clear_primary_key() {
  primary_key_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RedirectData::primary_key() const {
  // @@protoc_insertion_point(field_get:predictors.RedirectData.primary_key)
  return _internal_primary_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RedirectData::set_primary_key(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 primary_key_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:predictors.RedirectData.primary_key)
}
inline std::string* RedirectData::mutable_primary_key() {
  std::string* _s = _internal_mutable_primary_key();
  // @@protoc_insertion_point(field_mutable:predictors.RedirectData.primary_key)
  return _s;
}
inline const std::string& RedirectData::_internal_primary_key() const {
  return primary_key_.Get();
}
inline void RedirectData::_internal_set_primary_key(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  primary_key_.Set(value, GetArenaForAllocation());
}
inline std::string* RedirectData::_internal_mutable_primary_key() {
  _has_bits_[0] |= 0x00000001u;
  return primary_key_.Mutable(GetArenaForAllocation());
}
inline std::string* RedirectData::release_primary_key() {
  // @@protoc_insertion_point(field_release:predictors.RedirectData.primary_key)
  if (!_internal_has_primary_key()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = primary_key_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (primary_key_.IsDefault()) {
    primary_key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void RedirectData::set_allocated_primary_key(std::string* primary_key) {
  if (primary_key != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  primary_key_.SetAllocated(primary_key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (primary_key_.IsDefault()) {
    primary_key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:predictors.RedirectData.primary_key)
}

// optional uint64 last_visit_time = 2;
inline bool RedirectData::_internal_has_last_visit_time() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool RedirectData::has_last_visit_time() const {
  return _internal_has_last_visit_time();
}
inline void RedirectData::clear_last_visit_time() {
  last_visit_time_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000002u;
}
inline uint64_t RedirectData::_internal_last_visit_time() const {
  return last_visit_time_;
}
inline uint64_t RedirectData::last_visit_time() const {
  // @@protoc_insertion_point(field_get:predictors.RedirectData.last_visit_time)
  return _internal_last_visit_time();
}
inline void RedirectData::_internal_set_last_visit_time(uint64_t value) {
  _has_bits_[0] |= 0x00000002u;
  last_visit_time_ = value;
}
inline void RedirectData::set_last_visit_time(uint64_t value) {
  _internal_set_last_visit_time(value);
  // @@protoc_insertion_point(field_set:predictors.RedirectData.last_visit_time)
}

// repeated .predictors.RedirectStat redirect_endpoints = 3;
inline int RedirectData::_internal_redirect_endpoints_size() const {
  return redirect_endpoints_.size();
}
inline int RedirectData::redirect_endpoints_size() const {
  return _internal_redirect_endpoints_size();
}
inline void RedirectData::clear_redirect_endpoints() {
  redirect_endpoints_.Clear();
}
inline ::predictors::RedirectStat* RedirectData::mutable_redirect_endpoints(int index) {
  // @@protoc_insertion_point(field_mutable:predictors.RedirectData.redirect_endpoints)
  return redirect_endpoints_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::predictors::RedirectStat >*
RedirectData::mutable_redirect_endpoints() {
  // @@protoc_insertion_point(field_mutable_list:predictors.RedirectData.redirect_endpoints)
  return &redirect_endpoints_;
}
inline const ::predictors::RedirectStat& RedirectData::_internal_redirect_endpoints(int index) const {
  return redirect_endpoints_.Get(index);
}
inline const ::predictors::RedirectStat& RedirectData::redirect_endpoints(int index) const {
  // @@protoc_insertion_point(field_get:predictors.RedirectData.redirect_endpoints)
  return _internal_redirect_endpoints(index);
}
inline ::predictors::RedirectStat* RedirectData::_internal_add_redirect_endpoints() {
  return redirect_endpoints_.Add();
}
inline ::predictors::RedirectStat* RedirectData::add_redirect_endpoints() {
  ::predictors::RedirectStat* _add = _internal_add_redirect_endpoints();
  // @@protoc_insertion_point(field_add:predictors.RedirectData.redirect_endpoints)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::predictors::RedirectStat >&
RedirectData::redirect_endpoints() const {
  // @@protoc_insertion_point(field_list:predictors.RedirectData.redirect_endpoints)
  return redirect_endpoints_;
}

// -------------------------------------------------------------------

// OriginStat

// optional string origin = 1;
inline bool OriginStat::_internal_has_origin() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool OriginStat::has_origin() const {
  return _internal_has_origin();
}
inline void OriginStat::clear_origin() {
  origin_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& OriginStat::origin() const {
  // @@protoc_insertion_point(field_get:predictors.OriginStat.origin)
  return _internal_origin();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OriginStat::set_origin(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 origin_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:predictors.OriginStat.origin)
}
inline std::string* OriginStat::mutable_origin() {
  std::string* _s = _internal_mutable_origin();
  // @@protoc_insertion_point(field_mutable:predictors.OriginStat.origin)
  return _s;
}
inline const std::string& OriginStat::_internal_origin() const {
  return origin_.Get();
}
inline void OriginStat::_internal_set_origin(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  origin_.Set(value, GetArenaForAllocation());
}
inline std::string* OriginStat::_internal_mutable_origin() {
  _has_bits_[0] |= 0x00000001u;
  return origin_.Mutable(GetArenaForAllocation());
}
inline std::string* OriginStat::release_origin() {
  // @@protoc_insertion_point(field_release:predictors.OriginStat.origin)
  if (!_internal_has_origin()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = origin_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (origin_.IsDefault()) {
    origin_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void OriginStat::set_allocated_origin(std::string* origin) {
  if (origin != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  origin_.SetAllocated(origin, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (origin_.IsDefault()) {
    origin_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:predictors.OriginStat.origin)
}

// optional uint32 number_of_hits = 2;
inline bool OriginStat::_internal_has_number_of_hits() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool OriginStat::has_number_of_hits() const {
  return _internal_has_number_of_hits();
}
inline void OriginStat::clear_number_of_hits() {
  number_of_hits_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline uint32_t OriginStat::_internal_number_of_hits() const {
  return number_of_hits_;
}
inline uint32_t OriginStat::number_of_hits() const {
  // @@protoc_insertion_point(field_get:predictors.OriginStat.number_of_hits)
  return _internal_number_of_hits();
}
inline void OriginStat::_internal_set_number_of_hits(uint32_t value) {
  _has_bits_[0] |= 0x00000002u;
  number_of_hits_ = value;
}
inline void OriginStat::set_number_of_hits(uint32_t value) {
  _internal_set_number_of_hits(value);
  // @@protoc_insertion_point(field_set:predictors.OriginStat.number_of_hits)
}

// optional uint32 number_of_misses = 3;
inline bool OriginStat::_internal_has_number_of_misses() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool OriginStat::has_number_of_misses() const {
  return _internal_has_number_of_misses();
}
inline void OriginStat::clear_number_of_misses() {
  number_of_misses_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline uint32_t OriginStat::_internal_number_of_misses() const {
  return number_of_misses_;
}
inline uint32_t OriginStat::number_of_misses() const {
  // @@protoc_insertion_point(field_get:predictors.OriginStat.number_of_misses)
  return _internal_number_of_misses();
}
inline void OriginStat::_internal_set_number_of_misses(uint32_t value) {
  _has_bits_[0] |= 0x00000004u;
  number_of_misses_ = value;
}
inline void OriginStat::set_number_of_misses(uint32_t value) {
  _internal_set_number_of_misses(value);
  // @@protoc_insertion_point(field_set:predictors.OriginStat.number_of_misses)
}

// optional uint32 consecutive_misses = 4;
inline bool OriginStat::_internal_has_consecutive_misses() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool OriginStat::has_consecutive_misses() const {
  return _internal_has_consecutive_misses();
}
inline void OriginStat::clear_consecutive_misses() {
  consecutive_misses_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline uint32_t OriginStat::_internal_consecutive_misses() const {
  return consecutive_misses_;
}
inline uint32_t OriginStat::consecutive_misses() const {
  // @@protoc_insertion_point(field_get:predictors.OriginStat.consecutive_misses)
  return _internal_consecutive_misses();
}
inline void OriginStat::_internal_set_consecutive_misses(uint32_t value) {
  _has_bits_[0] |= 0x00000010u;
  consecutive_misses_ = value;
}
inline void OriginStat::set_consecutive_misses(uint32_t value) {
  _internal_set_consecutive_misses(value);
  // @@protoc_insertion_point(field_set:predictors.OriginStat.consecutive_misses)
}

// optional double average_position = 5;
inline bool OriginStat::_internal_has_average_position() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool OriginStat::has_average_position() const {
  return _internal_has_average_position();
}
inline void OriginStat::clear_average_position() {
  average_position_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline double OriginStat::_internal_average_position() const {
  return average_position_;
}
inline double OriginStat::average_position() const {
  // @@protoc_insertion_point(field_get:predictors.OriginStat.average_position)
  return _internal_average_position();
}
inline void OriginStat::_internal_set_average_position(double value) {
  _has_bits_[0] |= 0x00000008u;
  average_position_ = value;
}
inline void OriginStat::set_average_position(double value) {
  _internal_set_average_position(value);
  // @@protoc_insertion_point(field_set:predictors.OriginStat.average_position)
}

// optional bool always_access_network = 6;
inline bool OriginStat::_internal_has_always_access_network() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool OriginStat::has_always_access_network() const {
  return _internal_has_always_access_network();
}
inline void OriginStat::clear_always_access_network() {
  always_access_network_ = false;
  _has_bits_[0] &= ~0x00000020u;
}
inline bool OriginStat::_internal_always_access_network() const {
  return always_access_network_;
}
inline bool OriginStat::always_access_network() const {
  // @@protoc_insertion_point(field_get:predictors.OriginStat.always_access_network)
  return _internal_always_access_network();
}
inline void OriginStat::_internal_set_always_access_network(bool value) {
  _has_bits_[0] |= 0x00000020u;
  always_access_network_ = value;
}
inline void OriginStat::set_always_access_network(bool value) {
  _internal_set_always_access_network(value);
  // @@protoc_insertion_point(field_set:predictors.OriginStat.always_access_network)
}

// optional bool accessed_network = 7;
inline bool OriginStat::_internal_has_accessed_network() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool OriginStat::has_accessed_network() const {
  return _internal_has_accessed_network();
}
inline void OriginStat::clear_accessed_network() {
  accessed_network_ = false;
  _has_bits_[0] &= ~0x00000040u;
}
inline bool OriginStat::_internal_accessed_network() const {
  return accessed_network_;
}
inline bool OriginStat::accessed_network() const {
  // @@protoc_insertion_point(field_get:predictors.OriginStat.accessed_network)
  return _internal_accessed_network();
}
inline void OriginStat::_internal_set_accessed_network(bool value) {
  _has_bits_[0] |= 0x00000040u;
  accessed_network_ = value;
}
inline void OriginStat::set_accessed_network(bool value) {
  _internal_set_accessed_network(value);
  // @@protoc_insertion_point(field_set:predictors.OriginStat.accessed_network)
}

// -------------------------------------------------------------------

// OriginData

// optional string host = 1;
inline bool OriginData::_internal_has_host() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool OriginData::has_host() const {
  return _internal_has_host();
}
inline void OriginData::clear_host() {
  host_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& OriginData::host() const {
  // @@protoc_insertion_point(field_get:predictors.OriginData.host)
  return _internal_host();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OriginData::set_host(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 host_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:predictors.OriginData.host)
}
inline std::string* OriginData::mutable_host() {
  std::string* _s = _internal_mutable_host();
  // @@protoc_insertion_point(field_mutable:predictors.OriginData.host)
  return _s;
}
inline const std::string& OriginData::_internal_host() const {
  return host_.Get();
}
inline void OriginData::_internal_set_host(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  host_.Set(value, GetArenaForAllocation());
}
inline std::string* OriginData::_internal_mutable_host() {
  _has_bits_[0] |= 0x00000001u;
  return host_.Mutable(GetArenaForAllocation());
}
inline std::string* OriginData::release_host() {
  // @@protoc_insertion_point(field_release:predictors.OriginData.host)
  if (!_internal_has_host()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = host_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (host_.IsDefault()) {
    host_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void OriginData::set_allocated_host(std::string* host) {
  if (host != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  host_.SetAllocated(host, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (host_.IsDefault()) {
    host_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:predictors.OriginData.host)
}

// optional uint64 last_visit_time = 2;
inline bool OriginData::_internal_has_last_visit_time() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool OriginData::has_last_visit_time() const {
  return _internal_has_last_visit_time();
}
inline void OriginData::clear_last_visit_time() {
  last_visit_time_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000002u;
}
inline uint64_t OriginData::_internal_last_visit_time() const {
  return last_visit_time_;
}
inline uint64_t OriginData::last_visit_time() const {
  // @@protoc_insertion_point(field_get:predictors.OriginData.last_visit_time)
  return _internal_last_visit_time();
}
inline void OriginData::_internal_set_last_visit_time(uint64_t value) {
  _has_bits_[0] |= 0x00000002u;
  last_visit_time_ = value;
}
inline void OriginData::set_last_visit_time(uint64_t value) {
  _internal_set_last_visit_time(value);
  // @@protoc_insertion_point(field_set:predictors.OriginData.last_visit_time)
}

// repeated .predictors.OriginStat origins = 3;
inline int OriginData::_internal_origins_size() const {
  return origins_.size();
}
inline int OriginData::origins_size() const {
  return _internal_origins_size();
}
inline void OriginData::clear_origins() {
  origins_.Clear();
}
inline ::predictors::OriginStat* OriginData::mutable_origins(int index) {
  // @@protoc_insertion_point(field_mutable:predictors.OriginData.origins)
  return origins_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::predictors::OriginStat >*
OriginData::mutable_origins() {
  // @@protoc_insertion_point(field_mutable_list:predictors.OriginData.origins)
  return &origins_;
}
inline const ::predictors::OriginStat& OriginData::_internal_origins(int index) const {
  return origins_.Get(index);
}
inline const ::predictors::OriginStat& OriginData::origins(int index) const {
  // @@protoc_insertion_point(field_get:predictors.OriginData.origins)
  return _internal_origins(index);
}
inline ::predictors::OriginStat* OriginData::_internal_add_origins() {
  return origins_.Add();
}
inline ::predictors::OriginStat* OriginData::add_origins() {
  ::predictors::OriginStat* _add = _internal_add_origins();
  // @@protoc_insertion_point(field_add:predictors.OriginData.origins)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::predictors::OriginStat >&
OriginData::origins() const {
  // @@protoc_insertion_point(field_list:predictors.OriginData.origins)
  return origins_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace predictors

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_resource_5fprefetch_5fpredictor_2eproto
