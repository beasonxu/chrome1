// chrome/common/chrome_render_frame.mojom-test-utils.h is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2019 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef CHROME_COMMON_CHROME_RENDER_FRAME_MOJOM_TEST_UTILS_H_
#define CHROME_COMMON_CHROME_RENDER_FRAME_MOJOM_TEST_UTILS_H_

#include "chrome/common/chrome_render_frame.mojom.h"


namespace chrome {
namespace mojom {


class  ChromeRenderFrameInterceptorForTesting : public ChromeRenderFrame {
  virtual ChromeRenderFrame* GetForwardingInterface() = 0;
  void SetWindowFeatures(::blink::mojom::WindowFeaturesPtr window_features) override;
  void RequestReloadImageForContextNode() override;
  void RequestImageForContextNode(int32_t image_min_area_pixels, const ::gfx::Size& image_max_size_pixels, ImageFormat image_format, RequestImageForContextNodeCallback callback) override;
  void ExecuteWebUIJavaScript(const ::std::u16string& javascript) override;
  void SetCCTClientHeader(const std::string& header) override;
  void GetMediaFeedURL(GetMediaFeedURLCallback callback) override;
  void LoadBlockedPlugins(const std::string& identifier) override;
};
class  ChromeRenderFrameAsyncWaiter {
 public:
  explicit ChromeRenderFrameAsyncWaiter(ChromeRenderFrame* proxy);

  ChromeRenderFrameAsyncWaiter(const ChromeRenderFrameAsyncWaiter&) = delete;
  ChromeRenderFrameAsyncWaiter& operator=(const ChromeRenderFrameAsyncWaiter&) = delete;

  ~ChromeRenderFrameAsyncWaiter();
  void RequestImageForContextNode(
      int32_t image_min_area_pixels, const ::gfx::Size& image_max_size_pixels, ImageFormat image_format, std::vector<uint8_t>* out_image_data, ::gfx::Size* out_original_size, std::string* out_encoded_extension);
  void GetMediaFeedURL(
      absl::optional<::GURL>* out_url);

 private:
  ChromeRenderFrame* const proxy_;
};




}  // namespace mojom
}  // namespace chrome

#endif  // CHROME_COMMON_CHROME_RENDER_FRAME_MOJOM_TEST_UTILS_H_