// device/gamepad/public/mojom/gamepad.mojom-shared.h is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2016 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef DEVICE_GAMEPAD_PUBLIC_MOJOM_GAMEPAD_MOJOM_SHARED_H_
#define DEVICE_GAMEPAD_PUBLIC_MOJOM_GAMEPAD_MOJOM_SHARED_H_

#include <stdint.h>

#include <functional>
#include <iosfwd>
#include <type_traits>
#include <utility>
#include "mojo/public/cpp/bindings/array_data_view.h"
#include "mojo/public/cpp/bindings/enum_traits.h"
#include "mojo/public/cpp/bindings/interface_data_view.h"
#include "mojo/public/cpp/bindings/lib/bindings_internal.h"
#include "mojo/public/cpp/bindings/lib/serialization.h"
#include "mojo/public/cpp/bindings/map_data_view.h"
#include "mojo/public/cpp/bindings/string_data_view.h"

#include "third_party/perfetto/include/perfetto/tracing/traced_value_forward.h"

#include "device/gamepad/public/mojom/gamepad.mojom-shared-internal.h"
#include "mojo/public/mojom/base/shared_memory.mojom-shared.h"
#include "mojo/public/cpp/bindings/lib/interface_serialization.h"


#include "base/component_export.h"




namespace device {
namespace mojom {
class GamepadQuaternionDataView;

class GamepadVectorDataView;

class GamepadButtonDataView;

class ButtonChangeDataView;

class AxisChangeDataView;

class GamepadChangesDataView;

class GamepadPoseDataView;

class GamepadHapticActuatorDataView;

class GamepadDataView;

class GamepadEffectParametersDataView;



}  // namespace mojom
}  // namespace device

namespace mojo {
namespace internal {

template <>
struct MojomTypeTraits<::device::mojom::GamepadQuaternionDataView> {
  using Data = ::device::mojom::internal::GamepadQuaternion_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::device::mojom::GamepadVectorDataView> {
  using Data = ::device::mojom::internal::GamepadVector_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::device::mojom::GamepadButtonDataView> {
  using Data = ::device::mojom::internal::GamepadButton_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::device::mojom::ButtonChangeDataView> {
  using Data = ::device::mojom::internal::ButtonChange_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::device::mojom::AxisChangeDataView> {
  using Data = ::device::mojom::internal::AxisChange_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::device::mojom::GamepadChangesDataView> {
  using Data = ::device::mojom::internal::GamepadChanges_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::device::mojom::GamepadPoseDataView> {
  using Data = ::device::mojom::internal::GamepadPose_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::device::mojom::GamepadHapticActuatorDataView> {
  using Data = ::device::mojom::internal::GamepadHapticActuator_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::device::mojom::GamepadDataView> {
  using Data = ::device::mojom::internal::Gamepad_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::device::mojom::GamepadEffectParametersDataView> {
  using Data = ::device::mojom::internal::GamepadEffectParameters_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

}  // namespace internal
}  // namespace mojo


namespace device {
namespace mojom {


enum class GamepadMapping : int32_t {
  
  GamepadMappingNone = 0,
  
  GamepadMappingStandard = 1,
  
  GamepadMappingXRStandard = 2,
  kMinValue = 0,
  kMaxValue = 2,
};

COMPONENT_EXPORT(GAMEPAD_MOJOM_SHARED) std::ostream& operator<<(std::ostream& os, GamepadMapping value);
inline bool IsKnownEnumValue(GamepadMapping value) {
  return internal::GamepadMapping_Data::IsKnownValue(
      static_cast<int32_t>(value));
}


enum class GamepadHand : int32_t {
  
  GamepadHandNone = 0,
  
  GamepadHandLeft = 1,
  
  GamepadHandRight = 2,
  kMinValue = 0,
  kMaxValue = 2,
};

COMPONENT_EXPORT(GAMEPAD_MOJOM_SHARED) std::ostream& operator<<(std::ostream& os, GamepadHand value);
inline bool IsKnownEnumValue(GamepadHand value) {
  return internal::GamepadHand_Data::IsKnownValue(
      static_cast<int32_t>(value));
}


enum class GamepadHapticActuatorType : int32_t {
  
  GamepadHapticActuatorTypeVibration = 0,
  
  GamepadHapticActuatorTypeDualRumble = 1,
  
  GamepadHapticActuatorTypeTriggerRumble = 2,
  kMinValue = 0,
  kMaxValue = 2,
};

COMPONENT_EXPORT(GAMEPAD_MOJOM_SHARED) std::ostream& operator<<(std::ostream& os, GamepadHapticActuatorType value);
inline bool IsKnownEnumValue(GamepadHapticActuatorType value) {
  return internal::GamepadHapticActuatorType_Data::IsKnownValue(
      static_cast<int32_t>(value));
}


enum class GamepadHapticEffectType : int32_t {
  
  GamepadHapticEffectTypeDualRumble = 0,
  
  GamepadHapticEffectTypeTriggerRumble = 1,
  kMinValue = 0,
  kMaxValue = 1,
};

COMPONENT_EXPORT(GAMEPAD_MOJOM_SHARED) std::ostream& operator<<(std::ostream& os, GamepadHapticEffectType value);
inline bool IsKnownEnumValue(GamepadHapticEffectType value) {
  return internal::GamepadHapticEffectType_Data::IsKnownValue(
      static_cast<int32_t>(value));
}


enum class GamepadHapticsResult : int32_t {
  
  GamepadHapticsResultError = 0,
  
  GamepadHapticsResultComplete = 1,
  
  GamepadHapticsResultPreempted = 2,
  
  GamepadHapticsResultInvalidParameter = 3,
  
  GamepadHapticsResultNotSupported = 4,
  kMinValue = 0,
  kMaxValue = 4,
};

COMPONENT_EXPORT(GAMEPAD_MOJOM_SHARED) std::ostream& operator<<(std::ostream& os, GamepadHapticsResult value);
inline bool IsKnownEnumValue(GamepadHapticsResult value) {
  return internal::GamepadHapticsResult_Data::IsKnownValue(
      static_cast<int32_t>(value));
}
// Interface base classes. They are used for type safety check.
class GamepadObserverInterfaceBase {};

using GamepadObserverPtrDataView =
    mojo::InterfacePtrDataView<GamepadObserverInterfaceBase>;
using GamepadObserverRequestDataView =
    mojo::InterfaceRequestDataView<GamepadObserverInterfaceBase>;
using GamepadObserverAssociatedPtrInfoDataView =
    mojo::AssociatedInterfacePtrInfoDataView<GamepadObserverInterfaceBase>;
using GamepadObserverAssociatedRequestDataView =
    mojo::AssociatedInterfaceRequestDataView<GamepadObserverInterfaceBase>;
class GamepadMonitorInterfaceBase {};

using GamepadMonitorPtrDataView =
    mojo::InterfacePtrDataView<GamepadMonitorInterfaceBase>;
using GamepadMonitorRequestDataView =
    mojo::InterfaceRequestDataView<GamepadMonitorInterfaceBase>;
using GamepadMonitorAssociatedPtrInfoDataView =
    mojo::AssociatedInterfacePtrInfoDataView<GamepadMonitorInterfaceBase>;
using GamepadMonitorAssociatedRequestDataView =
    mojo::AssociatedInterfaceRequestDataView<GamepadMonitorInterfaceBase>;
class GamepadHapticsManagerInterfaceBase {};

using GamepadHapticsManagerPtrDataView =
    mojo::InterfacePtrDataView<GamepadHapticsManagerInterfaceBase>;
using GamepadHapticsManagerRequestDataView =
    mojo::InterfaceRequestDataView<GamepadHapticsManagerInterfaceBase>;
using GamepadHapticsManagerAssociatedPtrInfoDataView =
    mojo::AssociatedInterfacePtrInfoDataView<GamepadHapticsManagerInterfaceBase>;
using GamepadHapticsManagerAssociatedRequestDataView =
    mojo::AssociatedInterfaceRequestDataView<GamepadHapticsManagerInterfaceBase>;


class GamepadQuaternionDataView {
 public:
  GamepadQuaternionDataView() = default;

  GamepadQuaternionDataView(
      internal::GamepadQuaternion_Data* data,
      mojo::Message* message)
      : data_(data) {}

  bool is_null() const { return !data_; }
  float x() const {
    return data_->x;
  }
  float y() const {
    return data_->y;
  }
  float z() const {
    return data_->z;
  }
  float w() const {
    return data_->w;
  }
 private:
  internal::GamepadQuaternion_Data* data_ = nullptr;
};



class GamepadVectorDataView {
 public:
  GamepadVectorDataView() = default;

  GamepadVectorDataView(
      internal::GamepadVector_Data* data,
      mojo::Message* message)
      : data_(data) {}

  bool is_null() const { return !data_; }
  float x() const {
    return data_->x;
  }
  float y() const {
    return data_->y;
  }
  float z() const {
    return data_->z;
  }
 private:
  internal::GamepadVector_Data* data_ = nullptr;
};



class GamepadButtonDataView {
 public:
  GamepadButtonDataView() = default;

  GamepadButtonDataView(
      internal::GamepadButton_Data* data,
      mojo::Message* message)
      : data_(data) {}

  bool is_null() const { return !data_; }
  bool pressed() const {
    return data_->pressed;
  }
  bool touched() const {
    return data_->touched;
  }
  double value() const {
    return data_->value;
  }
 private:
  internal::GamepadButton_Data* data_ = nullptr;
};



class ButtonChangeDataView {
 public:
  ButtonChangeDataView() = default;

  ButtonChangeDataView(
      internal::ButtonChange_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  uint32_t button_index() const {
    return data_->button_index;
  }
  bool button_down() const {
    return data_->button_down;
  }
  bool button_up() const {
    return data_->button_up;
  }
  bool value_changed() const {
    return data_->value_changed;
  }
  inline void GetButtonSnapshotDataView(
      GamepadButtonDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadButtonSnapshot(UserType* output) {
    
    auto* pointer = data_->button_snapshot.Get();
    return mojo::internal::Deserialize<::device::mojom::GamepadButtonDataView>(
        pointer, output, message_);
  }
 private:
  internal::ButtonChange_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class AxisChangeDataView {
 public:
  AxisChangeDataView() = default;

  AxisChangeDataView(
      internal::AxisChange_Data* data,
      mojo::Message* message)
      : data_(data) {}

  bool is_null() const { return !data_; }
  uint32_t axis_index() const {
    return data_->axis_index;
  }
  double axis_snapshot() const {
    return data_->axis_snapshot;
  }
 private:
  internal::AxisChange_Data* data_ = nullptr;
};



class GamepadChangesDataView {
 public:
  GamepadChangesDataView() = default;

  GamepadChangesDataView(
      internal::GamepadChanges_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  uint32_t gamepad_index() const {
    return data_->gamepad_index;
  }
  inline void GetButtonChangesDataView(
      mojo::ArrayDataView<ButtonChangeDataView>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadButtonChanges(UserType* output) {
    
    auto* pointer = data_->button_changes.Get();
    return mojo::internal::Deserialize<mojo::ArrayDataView<::device::mojom::ButtonChangeDataView>>(
        pointer, output, message_);
  }
  inline void GetAxisChangesDataView(
      mojo::ArrayDataView<AxisChangeDataView>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadAxisChanges(UserType* output) {
    
    auto* pointer = data_->axis_changes.Get();
    return mojo::internal::Deserialize<mojo::ArrayDataView<::device::mojom::AxisChangeDataView>>(
        pointer, output, message_);
  }
  int64_t timestamp() const {
    return data_->timestamp;
  }
 private:
  internal::GamepadChanges_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class GamepadPoseDataView {
 public:
  GamepadPoseDataView() = default;

  GamepadPoseDataView(
      internal::GamepadPose_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  inline void GetOrientationDataView(
      GamepadQuaternionDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadOrientation(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::device::mojom::GamepadQuaternionDataView, UserType>(),
    "Attempting to read the optional `orientation` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadOrientation` instead "
    "of `ReadOrientation if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->orientation.Get();
    return mojo::internal::Deserialize<::device::mojom::GamepadQuaternionDataView>(
        pointer, output, message_);
  }
  inline void GetPositionDataView(
      GamepadVectorDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadPosition(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::device::mojom::GamepadVectorDataView, UserType>(),
    "Attempting to read the optional `position` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadPosition` instead "
    "of `ReadPosition if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->position.Get();
    return mojo::internal::Deserialize<::device::mojom::GamepadVectorDataView>(
        pointer, output, message_);
  }
  inline void GetAngularVelocityDataView(
      GamepadVectorDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadAngularVelocity(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::device::mojom::GamepadVectorDataView, UserType>(),
    "Attempting to read the optional `angular_velocity` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadAngularVelocity` instead "
    "of `ReadAngularVelocity if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->angular_velocity.Get();
    return mojo::internal::Deserialize<::device::mojom::GamepadVectorDataView>(
        pointer, output, message_);
  }
  inline void GetLinearVelocityDataView(
      GamepadVectorDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadLinearVelocity(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::device::mojom::GamepadVectorDataView, UserType>(),
    "Attempting to read the optional `linear_velocity` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadLinearVelocity` instead "
    "of `ReadLinearVelocity if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->linear_velocity.Get();
    return mojo::internal::Deserialize<::device::mojom::GamepadVectorDataView>(
        pointer, output, message_);
  }
  inline void GetAngularAccelerationDataView(
      GamepadVectorDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadAngularAcceleration(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::device::mojom::GamepadVectorDataView, UserType>(),
    "Attempting to read the optional `angular_acceleration` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadAngularAcceleration` instead "
    "of `ReadAngularAcceleration if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->angular_acceleration.Get();
    return mojo::internal::Deserialize<::device::mojom::GamepadVectorDataView>(
        pointer, output, message_);
  }
  inline void GetLinearAccelerationDataView(
      GamepadVectorDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadLinearAcceleration(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::device::mojom::GamepadVectorDataView, UserType>(),
    "Attempting to read the optional `linear_acceleration` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadLinearAcceleration` instead "
    "of `ReadLinearAcceleration if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->linear_acceleration.Get();
    return mojo::internal::Deserialize<::device::mojom::GamepadVectorDataView>(
        pointer, output, message_);
  }
 private:
  internal::GamepadPose_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class GamepadHapticActuatorDataView {
 public:
  GamepadHapticActuatorDataView() = default;

  GamepadHapticActuatorDataView(
      internal::GamepadHapticActuator_Data* data,
      mojo::Message* message)
      : data_(data) {}

  bool is_null() const { return !data_; }
  template <typename UserType>
  [[nodiscard]] bool ReadType(UserType* output) const {
    auto data_value = data_->type;
    return mojo::internal::Deserialize<::device::mojom::GamepadHapticActuatorType>(
        data_value, output);
  }
  GamepadHapticActuatorType type() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::device::mojom::GamepadHapticActuatorType>(data_->type));
  }
 private:
  internal::GamepadHapticActuator_Data* data_ = nullptr;
};



class GamepadDataView {
 public:
  GamepadDataView() = default;

  GamepadDataView(
      internal::Gamepad_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  bool connected() const {
    return data_->connected;
  }
  inline void GetIdDataView(
      mojo::ArrayDataView<uint16_t>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadId(UserType* output) {
    
    auto* pointer = data_->id.Get();
    return mojo::internal::Deserialize<mojo::ArrayDataView<uint16_t>>(
        pointer, output, message_);
  }
  int64_t timestamp() const {
    return data_->timestamp;
  }
  inline void GetAxesDataView(
      mojo::ArrayDataView<double>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadAxes(UserType* output) {
    
    auto* pointer = data_->axes.Get();
    return mojo::internal::Deserialize<mojo::ArrayDataView<double>>(
        pointer, output, message_);
  }
  inline void GetButtonsDataView(
      mojo::ArrayDataView<GamepadButtonDataView>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadButtons(UserType* output) {
    
    auto* pointer = data_->buttons.Get();
    return mojo::internal::Deserialize<mojo::ArrayDataView<::device::mojom::GamepadButtonDataView>>(
        pointer, output, message_);
  }
  inline void GetVibrationActuatorDataView(
      GamepadHapticActuatorDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadVibrationActuator(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::device::mojom::GamepadHapticActuatorDataView, UserType>(),
    "Attempting to read the optional `vibration_actuator` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadVibrationActuator` instead "
    "of `ReadVibrationActuator if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->vibration_actuator.Get();
    return mojo::internal::Deserialize<::device::mojom::GamepadHapticActuatorDataView>(
        pointer, output, message_);
  }
  template <typename UserType>
  [[nodiscard]] bool ReadMapping(UserType* output) const {
    auto data_value = data_->mapping;
    return mojo::internal::Deserialize<::device::mojom::GamepadMapping>(
        data_value, output);
  }
  GamepadMapping mapping() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::device::mojom::GamepadMapping>(data_->mapping));
  }
  inline void GetPoseDataView(
      GamepadPoseDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadPose(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::device::mojom::GamepadPoseDataView, UserType>(),
    "Attempting to read the optional `pose` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadPose` instead "
    "of `ReadPose if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->pose.Get();
    return mojo::internal::Deserialize<::device::mojom::GamepadPoseDataView>(
        pointer, output, message_);
  }
  template <typename UserType>
  [[nodiscard]] bool ReadHand(UserType* output) const {
    auto data_value = data_->hand;
    return mojo::internal::Deserialize<::device::mojom::GamepadHand>(
        data_value, output);
  }
  GamepadHand hand() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::device::mojom::GamepadHand>(data_->hand));
  }
  uint32_t display_id() const {
    return data_->display_id;
  }
 private:
  internal::Gamepad_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class GamepadEffectParametersDataView {
 public:
  GamepadEffectParametersDataView() = default;

  GamepadEffectParametersDataView(
      internal::GamepadEffectParameters_Data* data,
      mojo::Message* message)
      : data_(data) {}

  bool is_null() const { return !data_; }
  double duration() const {
    return data_->duration;
  }
  double start_delay() const {
    return data_->start_delay;
  }
  double strong_magnitude() const {
    return data_->strong_magnitude;
  }
  double weak_magnitude() const {
    return data_->weak_magnitude;
  }
  double left_trigger() const {
    return data_->left_trigger;
  }
  double right_trigger() const {
    return data_->right_trigger;
  }
 private:
  internal::GamepadEffectParameters_Data* data_ = nullptr;
};



}  // namespace mojom
}  // namespace device

namespace std {

template <>
struct hash<::device::mojom::GamepadMapping>
    : public mojo::internal::EnumHashImpl<::device::mojom::GamepadMapping> {};

template <>
struct hash<::device::mojom::GamepadHand>
    : public mojo::internal::EnumHashImpl<::device::mojom::GamepadHand> {};

template <>
struct hash<::device::mojom::GamepadHapticActuatorType>
    : public mojo::internal::EnumHashImpl<::device::mojom::GamepadHapticActuatorType> {};

template <>
struct hash<::device::mojom::GamepadHapticEffectType>
    : public mojo::internal::EnumHashImpl<::device::mojom::GamepadHapticEffectType> {};

template <>
struct hash<::device::mojom::GamepadHapticsResult>
    : public mojo::internal::EnumHashImpl<::device::mojom::GamepadHapticsResult> {};

}  // namespace std

namespace mojo {


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::device::mojom::GamepadMapping, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::device::mojom::GamepadMapping, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::device::mojom::GamepadMapping>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::device::mojom::GamepadHand, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::device::mojom::GamepadHand, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::device::mojom::GamepadHand>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::device::mojom::GamepadHapticActuatorType, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::device::mojom::GamepadHapticActuatorType, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::device::mojom::GamepadHapticActuatorType>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::device::mojom::GamepadHapticEffectType, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::device::mojom::GamepadHapticEffectType, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::device::mojom::GamepadHapticEffectType>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::device::mojom::GamepadHapticsResult, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::device::mojom::GamepadHapticsResult, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::device::mojom::GamepadHapticsResult>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::device::mojom::GamepadQuaternionDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::device::mojom::GamepadQuaternionDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::device::mojom::internal::GamepadQuaternion_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    fragment->x = Traits::x(input);
    fragment->y = Traits::y(input);
    fragment->z = Traits::z(input);
    fragment->w = Traits::w(input);
  }

  static bool Deserialize(::device::mojom::internal::GamepadQuaternion_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::device::mojom::GamepadQuaternionDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::device::mojom::GamepadVectorDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::device::mojom::GamepadVectorDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::device::mojom::internal::GamepadVector_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    fragment->x = Traits::x(input);
    fragment->y = Traits::y(input);
    fragment->z = Traits::z(input);
  }

  static bool Deserialize(::device::mojom::internal::GamepadVector_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::device::mojom::GamepadVectorDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::device::mojom::GamepadButtonDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::device::mojom::GamepadButtonDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::device::mojom::internal::GamepadButton_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    fragment->pressed = Traits::pressed(input);
    fragment->touched = Traits::touched(input);
    fragment->value = Traits::value(input);
  }

  static bool Deserialize(::device::mojom::internal::GamepadButton_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::device::mojom::GamepadButtonDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::device::mojom::ButtonChangeDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::device::mojom::ButtonChangeDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::device::mojom::internal::ButtonChange_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    fragment->button_index = Traits::button_index(input);
    fragment->button_down = Traits::button_down(input);
    fragment->button_up = Traits::button_up(input);
    fragment->value_changed = Traits::value_changed(input);
    decltype(Traits::button_snapshot(input)) in_button_snapshot = Traits::button_snapshot(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->button_snapshot)::BaseType> button_snapshot_fragment(
            fragment.message());
    mojo::internal::Serialize<::device::mojom::GamepadButtonDataView>(
        in_button_snapshot, button_snapshot_fragment);
    fragment->button_snapshot.Set(
        button_snapshot_fragment.is_null() ? nullptr : button_snapshot_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->button_snapshot.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null button_snapshot in ButtonChange struct");
  }

  static bool Deserialize(::device::mojom::internal::ButtonChange_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::device::mojom::ButtonChangeDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::device::mojom::AxisChangeDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::device::mojom::AxisChangeDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::device::mojom::internal::AxisChange_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    fragment->axis_index = Traits::axis_index(input);
    fragment->axis_snapshot = Traits::axis_snapshot(input);
  }

  static bool Deserialize(::device::mojom::internal::AxisChange_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::device::mojom::AxisChangeDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::device::mojom::GamepadChangesDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::device::mojom::GamepadChangesDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::device::mojom::internal::GamepadChanges_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    fragment->gamepad_index = Traits::gamepad_index(input);
    decltype(Traits::button_changes(input)) in_button_changes = Traits::button_changes(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->button_changes)::BaseType>
        button_changes_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams button_changes_validate_params(
        0, false, nullptr);
    mojo::internal::Serialize<mojo::ArrayDataView<::device::mojom::ButtonChangeDataView>>(
        in_button_changes, button_changes_fragment, &button_changes_validate_params);
    fragment->button_changes.Set(
        button_changes_fragment.is_null() ? nullptr : button_changes_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->button_changes.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null button_changes in GamepadChanges struct");
    decltype(Traits::axis_changes(input)) in_axis_changes = Traits::axis_changes(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->axis_changes)::BaseType>
        axis_changes_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams axis_changes_validate_params(
        0, false, nullptr);
    mojo::internal::Serialize<mojo::ArrayDataView<::device::mojom::AxisChangeDataView>>(
        in_axis_changes, axis_changes_fragment, &axis_changes_validate_params);
    fragment->axis_changes.Set(
        axis_changes_fragment.is_null() ? nullptr : axis_changes_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->axis_changes.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null axis_changes in GamepadChanges struct");
    fragment->timestamp = Traits::timestamp(input);
  }

  static bool Deserialize(::device::mojom::internal::GamepadChanges_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::device::mojom::GamepadChangesDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::device::mojom::GamepadPoseDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::device::mojom::GamepadPoseDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::device::mojom::internal::GamepadPose_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    decltype(Traits::orientation(input)) in_orientation = Traits::orientation(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->orientation)::BaseType> orientation_fragment(
            fragment.message());
    mojo::internal::Serialize<::device::mojom::GamepadQuaternionDataView>(
        in_orientation, orientation_fragment);
    fragment->orientation.Set(
        orientation_fragment.is_null() ? nullptr : orientation_fragment.data());
    decltype(Traits::position(input)) in_position = Traits::position(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->position)::BaseType> position_fragment(
            fragment.message());
    mojo::internal::Serialize<::device::mojom::GamepadVectorDataView>(
        in_position, position_fragment);
    fragment->position.Set(
        position_fragment.is_null() ? nullptr : position_fragment.data());
    decltype(Traits::angular_velocity(input)) in_angular_velocity = Traits::angular_velocity(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->angular_velocity)::BaseType> angular_velocity_fragment(
            fragment.message());
    mojo::internal::Serialize<::device::mojom::GamepadVectorDataView>(
        in_angular_velocity, angular_velocity_fragment);
    fragment->angular_velocity.Set(
        angular_velocity_fragment.is_null() ? nullptr : angular_velocity_fragment.data());
    decltype(Traits::linear_velocity(input)) in_linear_velocity = Traits::linear_velocity(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->linear_velocity)::BaseType> linear_velocity_fragment(
            fragment.message());
    mojo::internal::Serialize<::device::mojom::GamepadVectorDataView>(
        in_linear_velocity, linear_velocity_fragment);
    fragment->linear_velocity.Set(
        linear_velocity_fragment.is_null() ? nullptr : linear_velocity_fragment.data());
    decltype(Traits::angular_acceleration(input)) in_angular_acceleration = Traits::angular_acceleration(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->angular_acceleration)::BaseType> angular_acceleration_fragment(
            fragment.message());
    mojo::internal::Serialize<::device::mojom::GamepadVectorDataView>(
        in_angular_acceleration, angular_acceleration_fragment);
    fragment->angular_acceleration.Set(
        angular_acceleration_fragment.is_null() ? nullptr : angular_acceleration_fragment.data());
    decltype(Traits::linear_acceleration(input)) in_linear_acceleration = Traits::linear_acceleration(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->linear_acceleration)::BaseType> linear_acceleration_fragment(
            fragment.message());
    mojo::internal::Serialize<::device::mojom::GamepadVectorDataView>(
        in_linear_acceleration, linear_acceleration_fragment);
    fragment->linear_acceleration.Set(
        linear_acceleration_fragment.is_null() ? nullptr : linear_acceleration_fragment.data());
  }

  static bool Deserialize(::device::mojom::internal::GamepadPose_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::device::mojom::GamepadPoseDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::device::mojom::GamepadHapticActuatorDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::device::mojom::GamepadHapticActuatorDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::device::mojom::internal::GamepadHapticActuator_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    mojo::internal::Serialize<::device::mojom::GamepadHapticActuatorType>(
        Traits::type(input), &fragment->type);
  }

  static bool Deserialize(::device::mojom::internal::GamepadHapticActuator_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::device::mojom::GamepadHapticActuatorDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::device::mojom::GamepadDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::device::mojom::GamepadDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::device::mojom::internal::Gamepad_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    fragment->connected = Traits::connected(input);
    decltype(Traits::id(input)) in_id = Traits::id(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->id)::BaseType>
        id_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams id_validate_params(
        0, false, nullptr);
    mojo::internal::Serialize<mojo::ArrayDataView<uint16_t>>(
        in_id, id_fragment, &id_validate_params);
    fragment->id.Set(
        id_fragment.is_null() ? nullptr : id_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->id.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null id in Gamepad struct");
    fragment->timestamp = Traits::timestamp(input);
    decltype(Traits::axes(input)) in_axes = Traits::axes(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->axes)::BaseType>
        axes_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams axes_validate_params(
        0, false, nullptr);
    mojo::internal::Serialize<mojo::ArrayDataView<double>>(
        in_axes, axes_fragment, &axes_validate_params);
    fragment->axes.Set(
        axes_fragment.is_null() ? nullptr : axes_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->axes.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null axes in Gamepad struct");
    decltype(Traits::buttons(input)) in_buttons = Traits::buttons(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->buttons)::BaseType>
        buttons_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams buttons_validate_params(
        0, false, nullptr);
    mojo::internal::Serialize<mojo::ArrayDataView<::device::mojom::GamepadButtonDataView>>(
        in_buttons, buttons_fragment, &buttons_validate_params);
    fragment->buttons.Set(
        buttons_fragment.is_null() ? nullptr : buttons_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->buttons.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null buttons in Gamepad struct");
    decltype(Traits::vibration_actuator(input)) in_vibration_actuator = Traits::vibration_actuator(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->vibration_actuator)::BaseType> vibration_actuator_fragment(
            fragment.message());
    mojo::internal::Serialize<::device::mojom::GamepadHapticActuatorDataView>(
        in_vibration_actuator, vibration_actuator_fragment);
    fragment->vibration_actuator.Set(
        vibration_actuator_fragment.is_null() ? nullptr : vibration_actuator_fragment.data());
    mojo::internal::Serialize<::device::mojom::GamepadMapping>(
        Traits::mapping(input), &fragment->mapping);
    decltype(Traits::pose(input)) in_pose = Traits::pose(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->pose)::BaseType> pose_fragment(
            fragment.message());
    mojo::internal::Serialize<::device::mojom::GamepadPoseDataView>(
        in_pose, pose_fragment);
    fragment->pose.Set(
        pose_fragment.is_null() ? nullptr : pose_fragment.data());
    mojo::internal::Serialize<::device::mojom::GamepadHand>(
        Traits::hand(input), &fragment->hand);
    fragment->display_id = Traits::display_id(input);
  }

  static bool Deserialize(::device::mojom::internal::Gamepad_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::device::mojom::GamepadDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::device::mojom::GamepadEffectParametersDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::device::mojom::GamepadEffectParametersDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::device::mojom::internal::GamepadEffectParameters_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    fragment->duration = Traits::duration(input);
    fragment->start_delay = Traits::start_delay(input);
    fragment->strong_magnitude = Traits::strong_magnitude(input);
    fragment->weak_magnitude = Traits::weak_magnitude(input);
    fragment->left_trigger = Traits::left_trigger(input);
    fragment->right_trigger = Traits::right_trigger(input);
  }

  static bool Deserialize(::device::mojom::internal::GamepadEffectParameters_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::device::mojom::GamepadEffectParametersDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal

}  // namespace mojo


namespace device {
namespace mojom {







inline void ButtonChangeDataView::GetButtonSnapshotDataView(
    GamepadButtonDataView* output) {
  auto pointer = data_->button_snapshot.Get();
  *output = GamepadButtonDataView(pointer, message_);
}




inline void GamepadChangesDataView::GetButtonChangesDataView(
    mojo::ArrayDataView<ButtonChangeDataView>* output) {
  auto pointer = data_->button_changes.Get();
  *output = mojo::ArrayDataView<ButtonChangeDataView>(pointer, message_);
}
inline void GamepadChangesDataView::GetAxisChangesDataView(
    mojo::ArrayDataView<AxisChangeDataView>* output) {
  auto pointer = data_->axis_changes.Get();
  *output = mojo::ArrayDataView<AxisChangeDataView>(pointer, message_);
}


inline void GamepadPoseDataView::GetOrientationDataView(
    GamepadQuaternionDataView* output) {
  auto pointer = data_->orientation.Get();
  *output = GamepadQuaternionDataView(pointer, message_);
}
inline void GamepadPoseDataView::GetPositionDataView(
    GamepadVectorDataView* output) {
  auto pointer = data_->position.Get();
  *output = GamepadVectorDataView(pointer, message_);
}
inline void GamepadPoseDataView::GetAngularVelocityDataView(
    GamepadVectorDataView* output) {
  auto pointer = data_->angular_velocity.Get();
  *output = GamepadVectorDataView(pointer, message_);
}
inline void GamepadPoseDataView::GetLinearVelocityDataView(
    GamepadVectorDataView* output) {
  auto pointer = data_->linear_velocity.Get();
  *output = GamepadVectorDataView(pointer, message_);
}
inline void GamepadPoseDataView::GetAngularAccelerationDataView(
    GamepadVectorDataView* output) {
  auto pointer = data_->angular_acceleration.Get();
  *output = GamepadVectorDataView(pointer, message_);
}
inline void GamepadPoseDataView::GetLinearAccelerationDataView(
    GamepadVectorDataView* output) {
  auto pointer = data_->linear_acceleration.Get();
  *output = GamepadVectorDataView(pointer, message_);
}




inline void GamepadDataView::GetIdDataView(
    mojo::ArrayDataView<uint16_t>* output) {
  auto pointer = data_->id.Get();
  *output = mojo::ArrayDataView<uint16_t>(pointer, message_);
}
inline void GamepadDataView::GetAxesDataView(
    mojo::ArrayDataView<double>* output) {
  auto pointer = data_->axes.Get();
  *output = mojo::ArrayDataView<double>(pointer, message_);
}
inline void GamepadDataView::GetButtonsDataView(
    mojo::ArrayDataView<GamepadButtonDataView>* output) {
  auto pointer = data_->buttons.Get();
  *output = mojo::ArrayDataView<GamepadButtonDataView>(pointer, message_);
}
inline void GamepadDataView::GetVibrationActuatorDataView(
    GamepadHapticActuatorDataView* output) {
  auto pointer = data_->vibration_actuator.Get();
  *output = GamepadHapticActuatorDataView(pointer, message_);
}
inline void GamepadDataView::GetPoseDataView(
    GamepadPoseDataView* output) {
  auto pointer = data_->pose.Get();
  *output = GamepadPoseDataView(pointer, message_);
}





}  // namespace mojom
}  // namespace device

// Declare TraceFormatTraits for enums, which should be defined in ::perfetto
// namespace.

namespace perfetto {

template <>
struct COMPONENT_EXPORT(GAMEPAD_MOJOM_SHARED) TraceFormatTraits<::device::mojom::GamepadMapping> {
 static void WriteIntoTrace(perfetto::TracedValue context, ::device::mojom::GamepadMapping value);
};

} // namespace perfetto

namespace perfetto {

template <>
struct COMPONENT_EXPORT(GAMEPAD_MOJOM_SHARED) TraceFormatTraits<::device::mojom::GamepadHand> {
 static void WriteIntoTrace(perfetto::TracedValue context, ::device::mojom::GamepadHand value);
};

} // namespace perfetto

namespace perfetto {

template <>
struct COMPONENT_EXPORT(GAMEPAD_MOJOM_SHARED) TraceFormatTraits<::device::mojom::GamepadHapticActuatorType> {
 static void WriteIntoTrace(perfetto::TracedValue context, ::device::mojom::GamepadHapticActuatorType value);
};

} // namespace perfetto

namespace perfetto {

template <>
struct COMPONENT_EXPORT(GAMEPAD_MOJOM_SHARED) TraceFormatTraits<::device::mojom::GamepadHapticEffectType> {
 static void WriteIntoTrace(perfetto::TracedValue context, ::device::mojom::GamepadHapticEffectType value);
};

} // namespace perfetto

namespace perfetto {

template <>
struct COMPONENT_EXPORT(GAMEPAD_MOJOM_SHARED) TraceFormatTraits<::device::mojom::GamepadHapticsResult> {
 static void WriteIntoTrace(perfetto::TracedValue context, ::device::mojom::GamepadHapticsResult value);
};

} // namespace perfetto

#endif  // DEVICE_GAMEPAD_PUBLIC_MOJOM_GAMEPAD_MOJOM_SHARED_H_