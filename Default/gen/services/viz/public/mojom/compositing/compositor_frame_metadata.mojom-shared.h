// services/viz/public/mojom/compositing/compositor_frame_metadata.mojom-shared.h is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2016 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef SERVICES_VIZ_PUBLIC_MOJOM_COMPOSITING_COMPOSITOR_FRAME_METADATA_MOJOM_SHARED_H_
#define SERVICES_VIZ_PUBLIC_MOJOM_COMPOSITING_COMPOSITOR_FRAME_METADATA_MOJOM_SHARED_H_

#include <stdint.h>

#include <functional>
#include <iosfwd>
#include <type_traits>
#include <utility>
#include "mojo/public/cpp/bindings/array_data_view.h"
#include "mojo/public/cpp/bindings/enum_traits.h"
#include "mojo/public/cpp/bindings/interface_data_view.h"
#include "mojo/public/cpp/bindings/lib/bindings_internal.h"
#include "mojo/public/cpp/bindings/lib/serialization.h"
#include "mojo/public/cpp/bindings/map_data_view.h"
#include "mojo/public/cpp/bindings/string_data_view.h"

#include "third_party/perfetto/include/perfetto/tracing/traced_value_forward.h"

#include "services/viz/public/mojom/compositing/compositor_frame_metadata.mojom-shared-internal.h"
#include "mojo/public/mojom/base/time.mojom-shared.h"
#include "services/viz/public/mojom/compositing/begin_frame_args.mojom-shared.h"
#include "services/viz/public/mojom/compositing/compositor_frame_transition_directive.mojom-shared.h"
#include "ui/gfx/mojom/delegated_ink_metadata.mojom-shared.h"
#include "services/viz/public/mojom/compositing/frame_deadline.mojom-shared.h"
#include "services/viz/public/mojom/compositing/region_capture_bounds.mojom-shared.h"
#include "services/viz/public/mojom/compositing/selection.mojom-shared.h"
#include "services/viz/public/mojom/compositing/surface_id.mojom-shared.h"
#include "services/viz/public/mojom/compositing/surface_range.mojom-shared.h"
#include "skia/public/mojom/skcolor4f.mojom-shared.h"
#include "ui/gfx/geometry/mojom/geometry.mojom-shared.h"
#include "ui/gfx/mojom/display_color_spaces.mojom-shared.h"
#include "ui/gfx/mojom/overlay_transform.mojom-shared.h"
#include "ui/latency/mojom/latency_info.mojom-shared.h"







namespace viz {
namespace mojom {
class CompositorFrameMetadataDataView;



}  // namespace mojom
}  // namespace viz

namespace mojo {
namespace internal {

template <>
struct MojomTypeTraits<::viz::mojom::CompositorFrameMetadataDataView> {
  using Data = ::viz::mojom::internal::CompositorFrameMetadata_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

}  // namespace internal
}  // namespace mojo


namespace viz {
namespace mojom {


class CompositorFrameMetadataDataView {
 public:
  CompositorFrameMetadataDataView() = default;

  CompositorFrameMetadataDataView(
      internal::CompositorFrameMetadata_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  float device_scale_factor() const {
    return data_->device_scale_factor;
  }
  inline void GetRootScrollOffsetDataView(
      ::gfx::mojom::PointFDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadRootScrollOffset(UserType* output) {
    
    auto* pointer = data_->root_scroll_offset.Get();
    return mojo::internal::Deserialize<::gfx::mojom::PointFDataView>(
        pointer, output, message_);
  }
  float page_scale_factor() const {
    return data_->page_scale_factor;
  }
  inline void GetScrollableViewportSizeDataView(
      ::gfx::mojom::SizeFDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadScrollableViewportSize(UserType* output) {
    
    auto* pointer = data_->scrollable_viewport_size.Get();
    return mojo::internal::Deserialize<::gfx::mojom::SizeFDataView>(
        pointer, output, message_);
  }
  template <typename UserType>
  [[nodiscard]] bool ReadContentColorUsage(UserType* output) const {
    auto data_value = data_->content_color_usage;
    return mojo::internal::Deserialize<::gfx::mojom::ContentColorUsage>(
        data_value, output);
  }
  ::gfx::mojom::ContentColorUsage content_color_usage() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::gfx::mojom::ContentColorUsage>(data_->content_color_usage));
  }
  bool may_contain_video() const {
    return data_->may_contain_video;
  }
  bool may_throttle_if_undrawn_frames() const {
    return data_->may_throttle_if_undrawn_frames;
  }
  bool is_resourceless_software_draw_with_scroll_or_animation() const {
    return data_->is_resourceless_software_draw_with_scroll_or_animation;
  }
  inline void GetRootBackgroundColorDataView(
      ::skia::mojom::SkColor4fDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadRootBackgroundColor(UserType* output) {
    
    auto* pointer = data_->root_background_color.Get();
    return mojo::internal::Deserialize<::skia::mojom::SkColor4fDataView>(
        pointer, output, message_);
  }
  inline void GetLatencyInfoDataView(
      mojo::ArrayDataView<::ui::mojom::LatencyInfoDataView>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadLatencyInfo(UserType* output) {
    
    auto* pointer = data_->latency_info.Get();
    return mojo::internal::Deserialize<mojo::ArrayDataView<::ui::mojom::LatencyInfoDataView>>(
        pointer, output, message_);
  }
  inline void GetReferencedSurfacesDataView(
      mojo::ArrayDataView<::viz::mojom::SurfaceRangeDataView>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadReferencedSurfaces(UserType* output) {
    
    auto* pointer = data_->referenced_surfaces.Get();
    return mojo::internal::Deserialize<mojo::ArrayDataView<::viz::mojom::SurfaceRangeDataView>>(
        pointer, output, message_);
  }
  inline void GetDeadlineDataView(
      ::viz::mojom::FrameDeadlineDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadDeadline(UserType* output) {
    
    auto* pointer = data_->deadline.Get();
    return mojo::internal::Deserialize<::viz::mojom::FrameDeadlineDataView>(
        pointer, output, message_);
  }
  inline void GetActivationDependenciesDataView(
      mojo::ArrayDataView<::viz::mojom::SurfaceIdDataView>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadActivationDependencies(UserType* output) {
    
    auto* pointer = data_->activation_dependencies.Get();
    return mojo::internal::Deserialize<mojo::ArrayDataView<::viz::mojom::SurfaceIdDataView>>(
        pointer, output, message_);
  }
  inline void GetBeginFrameAckDataView(
      ::viz::mojom::BeginFrameAckDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadBeginFrameAck(UserType* output) {
    
    auto* pointer = data_->begin_frame_ack.Get();
    return mojo::internal::Deserialize<::viz::mojom::BeginFrameAckDataView>(
        pointer, output, message_);
  }
  uint32_t frame_token() const {
    return data_->frame_token;
  }
  bool send_frame_token_to_embedder() const {
    return data_->send_frame_token_to_embedder;
  }
  bool top_controls_visible_height_set() const {
    return data_->top_controls_visible_height_set;
  }
  float top_controls_visible_height() const {
    return data_->top_controls_visible_height;
  }
  float min_page_scale_factor() const {
    return data_->min_page_scale_factor;
  }
  inline void GetPreferredFrameIntervalDataView(
      ::mojo_base::mojom::TimeDeltaDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadPreferredFrameInterval(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::mojo_base::mojom::TimeDeltaDataView, UserType>(),
    "Attempting to read the optional `preferred_frame_interval` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadPreferredFrameInterval` instead "
    "of `ReadPreferredFrameInterval if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->preferred_frame_interval.Get();
    return mojo::internal::Deserialize<::mojo_base::mojom::TimeDeltaDataView>(
        pointer, output, message_);
  }
  template <typename UserType>
  [[nodiscard]] bool ReadDisplayTransformHint(UserType* output) const {
    auto data_value = data_->display_transform_hint;
    return mojo::internal::Deserialize<::gfx::mojom::OverlayTransform>(
        data_value, output);
  }
  ::gfx::mojom::OverlayTransform display_transform_hint() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::gfx::mojom::OverlayTransform>(data_->display_transform_hint));
  }
  inline void GetDelegatedInkMetadataDataView(
      ::gfx::mojom::DelegatedInkMetadataDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadDelegatedInkMetadata(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::gfx::mojom::DelegatedInkMetadataDataView, UserType>(),
    "Attempting to read the optional `delegated_ink_metadata` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadDelegatedInkMetadata` instead "
    "of `ReadDelegatedInkMetadata if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->delegated_ink_metadata.Get();
    return mojo::internal::Deserialize<::gfx::mojom::DelegatedInkMetadataDataView>(
        pointer, output, message_);
  }
  inline void GetTransitionDirectivesDataView(
      mojo::ArrayDataView<::viz::mojom::CompositorFrameTransitionDirectiveDataView>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadTransitionDirectives(UserType* output) {
    
    auto* pointer = data_->transition_directives.Get();
    return mojo::internal::Deserialize<mojo::ArrayDataView<::viz::mojom::CompositorFrameTransitionDirectiveDataView>>(
        pointer, output, message_);
  }
  inline void GetCaptureBoundsDataView(
      ::viz::mojom::RegionCaptureBoundsDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadCaptureBounds(UserType* output) {
    
    auto* pointer = data_->capture_bounds.Get();
    return mojo::internal::Deserialize<::viz::mojom::RegionCaptureBoundsDataView>(
        pointer, output, message_);
  }
  bool has_shared_element_resources() const {
    return data_->has_shared_element_resources;
  }
 private:
  internal::CompositorFrameMetadata_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



}  // namespace mojom
}  // namespace viz

namespace std {

}  // namespace std

namespace mojo {


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::viz::mojom::CompositorFrameMetadataDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::viz::mojom::CompositorFrameMetadataDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::viz::mojom::internal::CompositorFrameMetadata_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    fragment->device_scale_factor = Traits::device_scale_factor(input);
    decltype(Traits::root_scroll_offset(input)) in_root_scroll_offset = Traits::root_scroll_offset(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->root_scroll_offset)::BaseType> root_scroll_offset_fragment(
            fragment.message());
    mojo::internal::Serialize<::gfx::mojom::PointFDataView>(
        in_root_scroll_offset, root_scroll_offset_fragment);
    fragment->root_scroll_offset.Set(
        root_scroll_offset_fragment.is_null() ? nullptr : root_scroll_offset_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->root_scroll_offset.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null root_scroll_offset in CompositorFrameMetadata struct");
    fragment->page_scale_factor = Traits::page_scale_factor(input);
    decltype(Traits::scrollable_viewport_size(input)) in_scrollable_viewport_size = Traits::scrollable_viewport_size(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->scrollable_viewport_size)::BaseType> scrollable_viewport_size_fragment(
            fragment.message());
    mojo::internal::Serialize<::gfx::mojom::SizeFDataView>(
        in_scrollable_viewport_size, scrollable_viewport_size_fragment);
    fragment->scrollable_viewport_size.Set(
        scrollable_viewport_size_fragment.is_null() ? nullptr : scrollable_viewport_size_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->scrollable_viewport_size.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null scrollable_viewport_size in CompositorFrameMetadata struct");
    mojo::internal::Serialize<::gfx::mojom::ContentColorUsage>(
        Traits::content_color_usage(input), &fragment->content_color_usage);
    fragment->may_contain_video = Traits::may_contain_video(input);
    fragment->may_throttle_if_undrawn_frames = Traits::may_throttle_if_undrawn_frames(input);
    fragment->is_resourceless_software_draw_with_scroll_or_animation = Traits::is_resourceless_software_draw_with_scroll_or_animation(input);
    decltype(Traits::root_background_color(input)) in_root_background_color = Traits::root_background_color(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->root_background_color)::BaseType> root_background_color_fragment(
            fragment.message());
    mojo::internal::Serialize<::skia::mojom::SkColor4fDataView>(
        in_root_background_color, root_background_color_fragment);
    fragment->root_background_color.Set(
        root_background_color_fragment.is_null() ? nullptr : root_background_color_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->root_background_color.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null root_background_color in CompositorFrameMetadata struct");
    decltype(Traits::latency_info(input)) in_latency_info = Traits::latency_info(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->latency_info)::BaseType>
        latency_info_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams latency_info_validate_params(
        0, false, nullptr);
    mojo::internal::Serialize<mojo::ArrayDataView<::ui::mojom::LatencyInfoDataView>>(
        in_latency_info, latency_info_fragment, &latency_info_validate_params);
    fragment->latency_info.Set(
        latency_info_fragment.is_null() ? nullptr : latency_info_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->latency_info.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null latency_info in CompositorFrameMetadata struct");
    decltype(Traits::referenced_surfaces(input)) in_referenced_surfaces = Traits::referenced_surfaces(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->referenced_surfaces)::BaseType>
        referenced_surfaces_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams referenced_surfaces_validate_params(
        0, false, nullptr);
    mojo::internal::Serialize<mojo::ArrayDataView<::viz::mojom::SurfaceRangeDataView>>(
        in_referenced_surfaces, referenced_surfaces_fragment, &referenced_surfaces_validate_params);
    fragment->referenced_surfaces.Set(
        referenced_surfaces_fragment.is_null() ? nullptr : referenced_surfaces_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->referenced_surfaces.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null referenced_surfaces in CompositorFrameMetadata struct");
    decltype(Traits::deadline(input)) in_deadline = Traits::deadline(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->deadline)::BaseType> deadline_fragment(
            fragment.message());
    mojo::internal::Serialize<::viz::mojom::FrameDeadlineDataView>(
        in_deadline, deadline_fragment);
    fragment->deadline.Set(
        deadline_fragment.is_null() ? nullptr : deadline_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->deadline.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null deadline in CompositorFrameMetadata struct");
    decltype(Traits::activation_dependencies(input)) in_activation_dependencies = Traits::activation_dependencies(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->activation_dependencies)::BaseType>
        activation_dependencies_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams activation_dependencies_validate_params(
        0, false, nullptr);
    mojo::internal::Serialize<mojo::ArrayDataView<::viz::mojom::SurfaceIdDataView>>(
        in_activation_dependencies, activation_dependencies_fragment, &activation_dependencies_validate_params);
    fragment->activation_dependencies.Set(
        activation_dependencies_fragment.is_null() ? nullptr : activation_dependencies_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->activation_dependencies.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null activation_dependencies in CompositorFrameMetadata struct");
    decltype(Traits::begin_frame_ack(input)) in_begin_frame_ack = Traits::begin_frame_ack(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->begin_frame_ack)::BaseType> begin_frame_ack_fragment(
            fragment.message());
    mojo::internal::Serialize<::viz::mojom::BeginFrameAckDataView>(
        in_begin_frame_ack, begin_frame_ack_fragment);
    fragment->begin_frame_ack.Set(
        begin_frame_ack_fragment.is_null() ? nullptr : begin_frame_ack_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->begin_frame_ack.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null begin_frame_ack in CompositorFrameMetadata struct");
    fragment->frame_token = Traits::frame_token(input);
    fragment->send_frame_token_to_embedder = Traits::send_frame_token_to_embedder(input);
    fragment->top_controls_visible_height_set = Traits::top_controls_visible_height_set(input);
    fragment->top_controls_visible_height = Traits::top_controls_visible_height(input);
    fragment->min_page_scale_factor = Traits::min_page_scale_factor(input);
    decltype(Traits::preferred_frame_interval(input)) in_preferred_frame_interval = Traits::preferred_frame_interval(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->preferred_frame_interval)::BaseType> preferred_frame_interval_fragment(
            fragment.message());
    mojo::internal::Serialize<::mojo_base::mojom::TimeDeltaDataView>(
        in_preferred_frame_interval, preferred_frame_interval_fragment);
    fragment->preferred_frame_interval.Set(
        preferred_frame_interval_fragment.is_null() ? nullptr : preferred_frame_interval_fragment.data());
    mojo::internal::Serialize<::gfx::mojom::OverlayTransform>(
        Traits::display_transform_hint(input), &fragment->display_transform_hint);
    decltype(Traits::delegated_ink_metadata(input)) in_delegated_ink_metadata = Traits::delegated_ink_metadata(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->delegated_ink_metadata)::BaseType> delegated_ink_metadata_fragment(
            fragment.message());
    mojo::internal::Serialize<::gfx::mojom::DelegatedInkMetadataDataView>(
        in_delegated_ink_metadata, delegated_ink_metadata_fragment);
    fragment->delegated_ink_metadata.Set(
        delegated_ink_metadata_fragment.is_null() ? nullptr : delegated_ink_metadata_fragment.data());
    decltype(Traits::transition_directives(input)) in_transition_directives = Traits::transition_directives(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->transition_directives)::BaseType>
        transition_directives_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams transition_directives_validate_params(
        0, false, nullptr);
    mojo::internal::Serialize<mojo::ArrayDataView<::viz::mojom::CompositorFrameTransitionDirectiveDataView>>(
        in_transition_directives, transition_directives_fragment, &transition_directives_validate_params);
    fragment->transition_directives.Set(
        transition_directives_fragment.is_null() ? nullptr : transition_directives_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->transition_directives.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null transition_directives in CompositorFrameMetadata struct");
    decltype(Traits::capture_bounds(input)) in_capture_bounds = Traits::capture_bounds(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->capture_bounds)::BaseType> capture_bounds_fragment(
            fragment.message());
    mojo::internal::Serialize<::viz::mojom::RegionCaptureBoundsDataView>(
        in_capture_bounds, capture_bounds_fragment);
    fragment->capture_bounds.Set(
        capture_bounds_fragment.is_null() ? nullptr : capture_bounds_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->capture_bounds.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null capture_bounds in CompositorFrameMetadata struct");
    fragment->has_shared_element_resources = Traits::has_shared_element_resources(input);
  }

  static bool Deserialize(::viz::mojom::internal::CompositorFrameMetadata_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::viz::mojom::CompositorFrameMetadataDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal

}  // namespace mojo


namespace viz {
namespace mojom {

inline void CompositorFrameMetadataDataView::GetRootScrollOffsetDataView(
    ::gfx::mojom::PointFDataView* output) {
  auto pointer = data_->root_scroll_offset.Get();
  *output = ::gfx::mojom::PointFDataView(pointer, message_);
}
inline void CompositorFrameMetadataDataView::GetScrollableViewportSizeDataView(
    ::gfx::mojom::SizeFDataView* output) {
  auto pointer = data_->scrollable_viewport_size.Get();
  *output = ::gfx::mojom::SizeFDataView(pointer, message_);
}
inline void CompositorFrameMetadataDataView::GetRootBackgroundColorDataView(
    ::skia::mojom::SkColor4fDataView* output) {
  auto pointer = data_->root_background_color.Get();
  *output = ::skia::mojom::SkColor4fDataView(pointer, message_);
}
inline void CompositorFrameMetadataDataView::GetLatencyInfoDataView(
    mojo::ArrayDataView<::ui::mojom::LatencyInfoDataView>* output) {
  auto pointer = data_->latency_info.Get();
  *output = mojo::ArrayDataView<::ui::mojom::LatencyInfoDataView>(pointer, message_);
}
inline void CompositorFrameMetadataDataView::GetReferencedSurfacesDataView(
    mojo::ArrayDataView<::viz::mojom::SurfaceRangeDataView>* output) {
  auto pointer = data_->referenced_surfaces.Get();
  *output = mojo::ArrayDataView<::viz::mojom::SurfaceRangeDataView>(pointer, message_);
}
inline void CompositorFrameMetadataDataView::GetDeadlineDataView(
    ::viz::mojom::FrameDeadlineDataView* output) {
  auto pointer = data_->deadline.Get();
  *output = ::viz::mojom::FrameDeadlineDataView(pointer, message_);
}
inline void CompositorFrameMetadataDataView::GetActivationDependenciesDataView(
    mojo::ArrayDataView<::viz::mojom::SurfaceIdDataView>* output) {
  auto pointer = data_->activation_dependencies.Get();
  *output = mojo::ArrayDataView<::viz::mojom::SurfaceIdDataView>(pointer, message_);
}
inline void CompositorFrameMetadataDataView::GetBeginFrameAckDataView(
    ::viz::mojom::BeginFrameAckDataView* output) {
  auto pointer = data_->begin_frame_ack.Get();
  *output = ::viz::mojom::BeginFrameAckDataView(pointer, message_);
}
inline void CompositorFrameMetadataDataView::GetPreferredFrameIntervalDataView(
    ::mojo_base::mojom::TimeDeltaDataView* output) {
  auto pointer = data_->preferred_frame_interval.Get();
  *output = ::mojo_base::mojom::TimeDeltaDataView(pointer, message_);
}
inline void CompositorFrameMetadataDataView::GetDelegatedInkMetadataDataView(
    ::gfx::mojom::DelegatedInkMetadataDataView* output) {
  auto pointer = data_->delegated_ink_metadata.Get();
  *output = ::gfx::mojom::DelegatedInkMetadataDataView(pointer, message_);
}
inline void CompositorFrameMetadataDataView::GetTransitionDirectivesDataView(
    mojo::ArrayDataView<::viz::mojom::CompositorFrameTransitionDirectiveDataView>* output) {
  auto pointer = data_->transition_directives.Get();
  *output = mojo::ArrayDataView<::viz::mojom::CompositorFrameTransitionDirectiveDataView>(pointer, message_);
}
inline void CompositorFrameMetadataDataView::GetCaptureBoundsDataView(
    ::viz::mojom::RegionCaptureBoundsDataView* output) {
  auto pointer = data_->capture_bounds.Get();
  *output = ::viz::mojom::RegionCaptureBoundsDataView(pointer, message_);
}



}  // namespace mojom
}  // namespace viz

// Declare TraceFormatTraits for enums, which should be defined in ::perfetto
// namespace.

#endif  // SERVICES_VIZ_PUBLIC_MOJOM_COMPOSITING_COMPOSITOR_FRAME_METADATA_MOJOM_SHARED_H_