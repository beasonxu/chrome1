// services/viz/privileged/mojom/compositing/display_private.mojom.cc is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2013 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#if defined(__clang__)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-private-field"
#endif

#include "services/viz/privileged/mojom/compositing/display_private.mojom.h"

#include <math.h>
#include <stdint.h>
#include <utility>

#include "base/debug/alias.h"
#include "base/hash/md5_constexpr.h"
#include "base/run_loop.h"
#include "base/strings/string_number_conversions.h"
#include "base/trace_event/trace_event.h"
#include "base/trace_event/typed_macros.h"
#include "mojo/public/cpp/bindings/lib/generated_code_util.h"
#include "mojo/public/cpp/bindings/lib/message_internal.h"
#include "mojo/public/cpp/bindings/lib/send_message_helper.h"
#include "mojo/public/cpp/bindings/lib/proxy_to_responder.h"
#include "mojo/public/cpp/bindings/lib/serialization_util.h"
#include "mojo/public/cpp/bindings/lib/unserialized_message_context.h"
#include "mojo/public/cpp/bindings/lib/validate_params.h"
#include "mojo/public/cpp/bindings/lib/validation_errors.h"
#include "mojo/public/cpp/bindings/mojo_buildflags.h"
#include "mojo/public/interfaces/bindings/interface_control_messages.mojom.h"
#include "third_party/perfetto/include/perfetto/tracing/traced_value.h"

#include "services/viz/privileged/mojom/compositing/display_private.mojom-params-data.h"
#include "services/viz/privileged/mojom/compositing/display_private.mojom-shared-message-ids.h"

#include "services/viz/privileged/mojom/compositing/display_private.mojom-import-headers.h"
#include "services/viz/privileged/mojom/compositing/display_private.mojom-test-utils.h"


#ifndef SERVICES_VIZ_PRIVILEGED_MOJOM_COMPOSITING_DISPLAY_PRIVATE_MOJOM_JUMBO_H_
#define SERVICES_VIZ_PRIVILEGED_MOJOM_COMPOSITING_DISPLAY_PRIVATE_MOJOM_JUMBO_H_
#endif



namespace viz {
namespace mojom {
const char DisplayPrivate::Name_[] = "viz.mojom.DisplayPrivate";

DisplayPrivate::IPCStableHashFunction DisplayPrivate::MessageToMethodInfo_(mojo::Message& message) {
#if !BUILDFLAG(IS_FUCHSIA)
  switch (message.name()) {
    case internal::kDisplayPrivate_SetDisplayVisible_Name: {
      return &DisplayPrivate::SetDisplayVisible_Sym::IPCStableHash;
    }
    case internal::kDisplayPrivate_Resize_Name: {
      return &DisplayPrivate::Resize_Sym::IPCStableHash;
    }
    case internal::kDisplayPrivate_SetDisplayColorMatrix_Name: {
      return &DisplayPrivate::SetDisplayColorMatrix_Sym::IPCStableHash;
    }
    case internal::kDisplayPrivate_SetDisplayColorSpaces_Name: {
      return &DisplayPrivate::SetDisplayColorSpaces_Sym::IPCStableHash;
    }
    case internal::kDisplayPrivate_SetOutputIsSecure_Name: {
      return &DisplayPrivate::SetOutputIsSecure_Sym::IPCStableHash;
    }
    case internal::kDisplayPrivate_SetDisplayVSyncParameters_Name: {
      return &DisplayPrivate::SetDisplayVSyncParameters_Sym::IPCStableHash;
    }
    case internal::kDisplayPrivate_ForceImmediateDrawAndSwapIfPossible_Name: {
      return &DisplayPrivate::ForceImmediateDrawAndSwapIfPossible_Sym::IPCStableHash;
    }
    case internal::kDisplayPrivate_SetVSyncPaused_Name: {
      return &DisplayPrivate::SetVSyncPaused_Sym::IPCStableHash;
    }
    case internal::kDisplayPrivate_UpdateRefreshRate_Name: {
      return &DisplayPrivate::UpdateRefreshRate_Sym::IPCStableHash;
    }
    case internal::kDisplayPrivate_SetSupportedRefreshRates_Name: {
      return &DisplayPrivate::SetSupportedRefreshRates_Sym::IPCStableHash;
    }
    case internal::kDisplayPrivate_PreserveChildSurfaceControls_Name: {
      return &DisplayPrivate::PreserveChildSurfaceControls_Sym::IPCStableHash;
    }
    case internal::kDisplayPrivate_SetSwapCompletionCallbackEnabled_Name: {
      return &DisplayPrivate::SetSwapCompletionCallbackEnabled_Sym::IPCStableHash;
    }
    case internal::kDisplayPrivate_AddVSyncParameterObserver_Name: {
      return &DisplayPrivate::AddVSyncParameterObserver_Sym::IPCStableHash;
    }
    case internal::kDisplayPrivate_SetDelegatedInkPointRenderer_Name: {
      return &DisplayPrivate::SetDelegatedInkPointRenderer_Sym::IPCStableHash;
    }
    case internal::kDisplayPrivate_SetStandaloneBeginFrameObserver_Name: {
      return &DisplayPrivate::SetStandaloneBeginFrameObserver_Sym::IPCStableHash;
    }
  }
#endif  // !BUILDFLAG(IS_FUCHSIA)
  return nullptr;
}


const char* DisplayPrivate::MessageToMethodName_(mojo::Message& message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  bool is_response = message.has_flag(mojo::Message::kFlagIsResponse);
  if (!is_response) {
    switch (message.name()) {
      case internal::kDisplayPrivate_SetDisplayVisible_Name:
            return "Receive viz::mojom::DisplayPrivate::SetDisplayVisible";
      case internal::kDisplayPrivate_Resize_Name:
            return "Receive viz::mojom::DisplayPrivate::Resize";
      case internal::kDisplayPrivate_SetDisplayColorMatrix_Name:
            return "Receive viz::mojom::DisplayPrivate::SetDisplayColorMatrix";
      case internal::kDisplayPrivate_SetDisplayColorSpaces_Name:
            return "Receive viz::mojom::DisplayPrivate::SetDisplayColorSpaces";
      case internal::kDisplayPrivate_SetOutputIsSecure_Name:
            return "Receive viz::mojom::DisplayPrivate::SetOutputIsSecure";
      case internal::kDisplayPrivate_SetDisplayVSyncParameters_Name:
            return "Receive viz::mojom::DisplayPrivate::SetDisplayVSyncParameters";
      case internal::kDisplayPrivate_ForceImmediateDrawAndSwapIfPossible_Name:
            return "Receive viz::mojom::DisplayPrivate::ForceImmediateDrawAndSwapIfPossible";
      case internal::kDisplayPrivate_SetVSyncPaused_Name:
            return "Receive viz::mojom::DisplayPrivate::SetVSyncPaused";
      case internal::kDisplayPrivate_UpdateRefreshRate_Name:
            return "Receive viz::mojom::DisplayPrivate::UpdateRefreshRate";
      case internal::kDisplayPrivate_SetSupportedRefreshRates_Name:
            return "Receive viz::mojom::DisplayPrivate::SetSupportedRefreshRates";
      case internal::kDisplayPrivate_PreserveChildSurfaceControls_Name:
            return "Receive viz::mojom::DisplayPrivate::PreserveChildSurfaceControls";
      case internal::kDisplayPrivate_SetSwapCompletionCallbackEnabled_Name:
            return "Receive viz::mojom::DisplayPrivate::SetSwapCompletionCallbackEnabled";
      case internal::kDisplayPrivate_AddVSyncParameterObserver_Name:
            return "Receive viz::mojom::DisplayPrivate::AddVSyncParameterObserver";
      case internal::kDisplayPrivate_SetDelegatedInkPointRenderer_Name:
            return "Receive viz::mojom::DisplayPrivate::SetDelegatedInkPointRenderer";
      case internal::kDisplayPrivate_SetStandaloneBeginFrameObserver_Name:
            return "Receive viz::mojom::DisplayPrivate::SetStandaloneBeginFrameObserver";
    }
  } else {
    switch (message.name()) {
      case internal::kDisplayPrivate_SetDisplayVisible_Name:
            return "Receive reply viz::mojom::DisplayPrivate::SetDisplayVisible";
      case internal::kDisplayPrivate_Resize_Name:
            return "Receive reply viz::mojom::DisplayPrivate::Resize";
      case internal::kDisplayPrivate_SetDisplayColorMatrix_Name:
            return "Receive reply viz::mojom::DisplayPrivate::SetDisplayColorMatrix";
      case internal::kDisplayPrivate_SetDisplayColorSpaces_Name:
            return "Receive reply viz::mojom::DisplayPrivate::SetDisplayColorSpaces";
      case internal::kDisplayPrivate_SetOutputIsSecure_Name:
            return "Receive reply viz::mojom::DisplayPrivate::SetOutputIsSecure";
      case internal::kDisplayPrivate_SetDisplayVSyncParameters_Name:
            return "Receive reply viz::mojom::DisplayPrivate::SetDisplayVSyncParameters";
      case internal::kDisplayPrivate_ForceImmediateDrawAndSwapIfPossible_Name:
            return "Receive reply viz::mojom::DisplayPrivate::ForceImmediateDrawAndSwapIfPossible";
      case internal::kDisplayPrivate_SetVSyncPaused_Name:
            return "Receive reply viz::mojom::DisplayPrivate::SetVSyncPaused";
      case internal::kDisplayPrivate_UpdateRefreshRate_Name:
            return "Receive reply viz::mojom::DisplayPrivate::UpdateRefreshRate";
      case internal::kDisplayPrivate_SetSupportedRefreshRates_Name:
            return "Receive reply viz::mojom::DisplayPrivate::SetSupportedRefreshRates";
      case internal::kDisplayPrivate_PreserveChildSurfaceControls_Name:
            return "Receive reply viz::mojom::DisplayPrivate::PreserveChildSurfaceControls";
      case internal::kDisplayPrivate_SetSwapCompletionCallbackEnabled_Name:
            return "Receive reply viz::mojom::DisplayPrivate::SetSwapCompletionCallbackEnabled";
      case internal::kDisplayPrivate_AddVSyncParameterObserver_Name:
            return "Receive reply viz::mojom::DisplayPrivate::AddVSyncParameterObserver";
      case internal::kDisplayPrivate_SetDelegatedInkPointRenderer_Name:
            return "Receive reply viz::mojom::DisplayPrivate::SetDelegatedInkPointRenderer";
      case internal::kDisplayPrivate_SetStandaloneBeginFrameObserver_Name:
            return "Receive reply viz::mojom::DisplayPrivate::SetStandaloneBeginFrameObserver";
    }
  }
  return "Receive unknown mojo message";
#else
  bool is_response = message.has_flag(mojo::Message::kFlagIsResponse);
  if (is_response) {
    return "Receive mojo reply";
  } else {
    return "Receive mojo message";
  }
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
}

#if !BUILDFLAG(IS_FUCHSIA)
uint32_t DisplayPrivate::SetDisplayVisible_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)viz::mojom::DisplayPrivate::SetDisplayVisible");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t DisplayPrivate::Resize_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)viz::mojom::DisplayPrivate::Resize");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t DisplayPrivate::SetDisplayColorMatrix_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)viz::mojom::DisplayPrivate::SetDisplayColorMatrix");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t DisplayPrivate::SetDisplayColorSpaces_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)viz::mojom::DisplayPrivate::SetDisplayColorSpaces");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t DisplayPrivate::SetOutputIsSecure_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)viz::mojom::DisplayPrivate::SetOutputIsSecure");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t DisplayPrivate::SetDisplayVSyncParameters_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)viz::mojom::DisplayPrivate::SetDisplayVSyncParameters");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t DisplayPrivate::ForceImmediateDrawAndSwapIfPossible_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)viz::mojom::DisplayPrivate::ForceImmediateDrawAndSwapIfPossible");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t DisplayPrivate::SetVSyncPaused_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)viz::mojom::DisplayPrivate::SetVSyncPaused");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t DisplayPrivate::UpdateRefreshRate_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)viz::mojom::DisplayPrivate::UpdateRefreshRate");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t DisplayPrivate::SetSupportedRefreshRates_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)viz::mojom::DisplayPrivate::SetSupportedRefreshRates");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t DisplayPrivate::PreserveChildSurfaceControls_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)viz::mojom::DisplayPrivate::PreserveChildSurfaceControls");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t DisplayPrivate::SetSwapCompletionCallbackEnabled_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)viz::mojom::DisplayPrivate::SetSwapCompletionCallbackEnabled");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t DisplayPrivate::AddVSyncParameterObserver_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)viz::mojom::DisplayPrivate::AddVSyncParameterObserver");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t DisplayPrivate::SetDelegatedInkPointRenderer_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)viz::mojom::DisplayPrivate::SetDelegatedInkPointRenderer");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t DisplayPrivate::SetStandaloneBeginFrameObserver_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)viz::mojom::DisplayPrivate::SetStandaloneBeginFrameObserver");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
# endif // !BUILDFLAG(IS_FUCHSIA)

DisplayPrivateProxy::DisplayPrivateProxy(mojo::MessageReceiverWithResponder* receiver)
    : receiver_(receiver) {
}

void DisplayPrivateProxy::SetDisplayVisible(
    bool in_visible) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send viz::mojom::DisplayPrivate::SetDisplayVisible", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("visible"), in_visible,
                        "<value of type bool>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kDisplayPrivate_SetDisplayVisible_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::viz::mojom::internal::DisplayPrivate_SetDisplayVisible_Params_Data> params(
          message);
  params.Allocate();
  params->visible = in_visible;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(DisplayPrivate::Name_);
  message.set_method_name("SetDisplayVisible");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void DisplayPrivateProxy::Resize(
    const ::gfx::Size& in_size) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send viz::mojom::DisplayPrivate::Resize", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("size"), in_size,
                        "<value of type const ::gfx::Size&>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kDisplayPrivate_Resize_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::viz::mojom::internal::DisplayPrivate_Resize_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->size)::BaseType> size_fragment(
          params.message());
  mojo::internal::Serialize<::gfx::mojom::SizeDataView>(
      in_size, size_fragment);
  params->size.Set(
      size_fragment.is_null() ? nullptr : size_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->size.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null size in DisplayPrivate.Resize request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(DisplayPrivate::Name_);
  message.set_method_name("Resize");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void DisplayPrivateProxy::SetDisplayColorMatrix(
    const ::gfx::Transform& in_color_matrix) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send viz::mojom::DisplayPrivate::SetDisplayColorMatrix", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("color_matrix"), in_color_matrix,
                        "<value of type const ::gfx::Transform&>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kDisplayPrivate_SetDisplayColorMatrix_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::viz::mojom::internal::DisplayPrivate_SetDisplayColorMatrix_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->color_matrix)::BaseType> color_matrix_fragment(
          params.message());
  mojo::internal::Serialize<::gfx::mojom::TransformDataView>(
      in_color_matrix, color_matrix_fragment);
  params->color_matrix.Set(
      color_matrix_fragment.is_null() ? nullptr : color_matrix_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->color_matrix.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null color_matrix in DisplayPrivate.SetDisplayColorMatrix request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(DisplayPrivate::Name_);
  message.set_method_name("SetDisplayColorMatrix");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void DisplayPrivateProxy::SetDisplayColorSpaces(
    const ::gfx::DisplayColorSpaces& in_display_color_spaces) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send viz::mojom::DisplayPrivate::SetDisplayColorSpaces", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("display_color_spaces"), in_display_color_spaces,
                        "<value of type const ::gfx::DisplayColorSpaces&>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kDisplayPrivate_SetDisplayColorSpaces_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::viz::mojom::internal::DisplayPrivate_SetDisplayColorSpaces_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->display_color_spaces)::BaseType> display_color_spaces_fragment(
          params.message());
  mojo::internal::Serialize<::gfx::mojom::DisplayColorSpacesDataView>(
      in_display_color_spaces, display_color_spaces_fragment);
  params->display_color_spaces.Set(
      display_color_spaces_fragment.is_null() ? nullptr : display_color_spaces_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->display_color_spaces.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null display_color_spaces in DisplayPrivate.SetDisplayColorSpaces request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(DisplayPrivate::Name_);
  message.set_method_name("SetDisplayColorSpaces");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void DisplayPrivateProxy::SetOutputIsSecure(
    bool in_secure) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send viz::mojom::DisplayPrivate::SetOutputIsSecure", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("secure"), in_secure,
                        "<value of type bool>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kDisplayPrivate_SetOutputIsSecure_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::viz::mojom::internal::DisplayPrivate_SetOutputIsSecure_Params_Data> params(
          message);
  params.Allocate();
  params->secure = in_secure;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(DisplayPrivate::Name_);
  message.set_method_name("SetOutputIsSecure");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void DisplayPrivateProxy::SetDisplayVSyncParameters(
    ::base::TimeTicks in_timebase, ::base::TimeDelta in_interval) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send viz::mojom::DisplayPrivate::SetDisplayVSyncParameters", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("timebase"), in_timebase,
                        "<value of type ::base::TimeTicks>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("interval"), in_interval,
                        "<value of type ::base::TimeDelta>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kDisplayPrivate_SetDisplayVSyncParameters_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::viz::mojom::internal::DisplayPrivate_SetDisplayVSyncParameters_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->timebase)::BaseType> timebase_fragment(
          params.message());
  mojo::internal::Serialize<::mojo_base::mojom::TimeTicksDataView>(
      in_timebase, timebase_fragment);
  params->timebase.Set(
      timebase_fragment.is_null() ? nullptr : timebase_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->timebase.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null timebase in DisplayPrivate.SetDisplayVSyncParameters request");
  mojo::internal::MessageFragment<
      typename decltype(params->interval)::BaseType> interval_fragment(
          params.message());
  mojo::internal::Serialize<::mojo_base::mojom::TimeDeltaDataView>(
      in_interval, interval_fragment);
  params->interval.Set(
      interval_fragment.is_null() ? nullptr : interval_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->interval.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null interval in DisplayPrivate.SetDisplayVSyncParameters request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(DisplayPrivate::Name_);
  message.set_method_name("SetDisplayVSyncParameters");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void DisplayPrivateProxy::ForceImmediateDrawAndSwapIfPossible(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send viz::mojom::DisplayPrivate::ForceImmediateDrawAndSwapIfPossible");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kDisplayPrivate_ForceImmediateDrawAndSwapIfPossible_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::viz::mojom::internal::DisplayPrivate_ForceImmediateDrawAndSwapIfPossible_Params_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(DisplayPrivate::Name_);
  message.set_method_name("ForceImmediateDrawAndSwapIfPossible");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void DisplayPrivateProxy::SetVSyncPaused(
    bool in_paused) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send viz::mojom::DisplayPrivate::SetVSyncPaused", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("paused"), in_paused,
                        "<value of type bool>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kDisplayPrivate_SetVSyncPaused_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::viz::mojom::internal::DisplayPrivate_SetVSyncPaused_Params_Data> params(
          message);
  params.Allocate();
  params->paused = in_paused;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(DisplayPrivate::Name_);
  message.set_method_name("SetVSyncPaused");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void DisplayPrivateProxy::UpdateRefreshRate(
    float in_refresh_rate) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send viz::mojom::DisplayPrivate::UpdateRefreshRate", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("refresh_rate"), in_refresh_rate,
                        "<value of type float>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kDisplayPrivate_UpdateRefreshRate_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::viz::mojom::internal::DisplayPrivate_UpdateRefreshRate_Params_Data> params(
          message);
  params.Allocate();
  params->refresh_rate = in_refresh_rate;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(DisplayPrivate::Name_);
  message.set_method_name("UpdateRefreshRate");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void DisplayPrivateProxy::SetSupportedRefreshRates(
    const std::vector<float>& in_refresh_rates) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send viz::mojom::DisplayPrivate::SetSupportedRefreshRates", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("refresh_rates"), in_refresh_rates,
                        "<value of type const std::vector<float>&>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kDisplayPrivate_SetSupportedRefreshRates_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::viz::mojom::internal::DisplayPrivate_SetSupportedRefreshRates_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->refresh_rates)::BaseType>
      refresh_rates_fragment(params.message());
  const mojo::internal::ContainerValidateParams refresh_rates_validate_params(
      0, false, nullptr);
  mojo::internal::Serialize<mojo::ArrayDataView<float>>(
      in_refresh_rates, refresh_rates_fragment, &refresh_rates_validate_params);
  params->refresh_rates.Set(
      refresh_rates_fragment.is_null() ? nullptr : refresh_rates_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->refresh_rates.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null refresh_rates in DisplayPrivate.SetSupportedRefreshRates request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(DisplayPrivate::Name_);
  message.set_method_name("SetSupportedRefreshRates");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void DisplayPrivateProxy::PreserveChildSurfaceControls(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send viz::mojom::DisplayPrivate::PreserveChildSurfaceControls");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kDisplayPrivate_PreserveChildSurfaceControls_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::viz::mojom::internal::DisplayPrivate_PreserveChildSurfaceControls_Params_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(DisplayPrivate::Name_);
  message.set_method_name("PreserveChildSurfaceControls");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void DisplayPrivateProxy::SetSwapCompletionCallbackEnabled(
    bool in_enable) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send viz::mojom::DisplayPrivate::SetSwapCompletionCallbackEnabled", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("enable"), in_enable,
                        "<value of type bool>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kDisplayPrivate_SetSwapCompletionCallbackEnabled_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::viz::mojom::internal::DisplayPrivate_SetSwapCompletionCallbackEnabled_Params_Data> params(
          message);
  params.Allocate();
  params->enable = in_enable;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(DisplayPrivate::Name_);
  message.set_method_name("SetSwapCompletionCallbackEnabled");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void DisplayPrivateProxy::AddVSyncParameterObserver(
    ::mojo::PendingRemote<::viz::mojom::VSyncParameterObserver> in_observer) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send viz::mojom::DisplayPrivate::AddVSyncParameterObserver", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("observer"), in_observer,
                        "<value of type ::mojo::PendingRemote<::viz::mojom::VSyncParameterObserver>>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kDisplayPrivate_AddVSyncParameterObserver_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::viz::mojom::internal::DisplayPrivate_AddVSyncParameterObserver_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::Serialize<mojo::InterfacePtrDataView<::viz::mojom::VSyncParameterObserverInterfaceBase>>(
      in_observer, &params->observer, &params.message());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      !mojo::internal::IsHandleOrInterfaceValid(params->observer),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_INVALID_HANDLE,
      "invalid observer in DisplayPrivate.AddVSyncParameterObserver request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(DisplayPrivate::Name_);
  message.set_method_name("AddVSyncParameterObserver");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void DisplayPrivateProxy::SetDelegatedInkPointRenderer(
    ::mojo::PendingReceiver<::gfx::mojom::DelegatedInkPointRenderer> in_receiver) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send viz::mojom::DisplayPrivate::SetDelegatedInkPointRenderer", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("receiver"), in_receiver,
                        "<value of type ::mojo::PendingReceiver<::gfx::mojom::DelegatedInkPointRenderer>>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kDisplayPrivate_SetDelegatedInkPointRenderer_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::viz::mojom::internal::DisplayPrivate_SetDelegatedInkPointRenderer_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::Serialize<mojo::InterfaceRequestDataView<::gfx::mojom::DelegatedInkPointRendererInterfaceBase>>(
      in_receiver, &params->receiver, &params.message());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      !mojo::internal::IsHandleOrInterfaceValid(params->receiver),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_INVALID_HANDLE,
      "invalid receiver in DisplayPrivate.SetDelegatedInkPointRenderer request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(DisplayPrivate::Name_);
  message.set_method_name("SetDelegatedInkPointRenderer");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void DisplayPrivateProxy::SetStandaloneBeginFrameObserver(
    ::mojo::PendingRemote<::viz::mojom::BeginFrameObserver> in_observer) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send viz::mojom::DisplayPrivate::SetStandaloneBeginFrameObserver", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("observer"), in_observer,
                        "<value of type ::mojo::PendingRemote<::viz::mojom::BeginFrameObserver>>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kDisplayPrivate_SetStandaloneBeginFrameObserver_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::viz::mojom::internal::DisplayPrivate_SetStandaloneBeginFrameObserver_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::Serialize<mojo::InterfacePtrDataView<::viz::mojom::BeginFrameObserverInterfaceBase>>(
      in_observer, &params->observer, &params.message());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      !mojo::internal::IsHandleOrInterfaceValid(params->observer),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_INVALID_HANDLE,
      "invalid observer in DisplayPrivate.SetStandaloneBeginFrameObserver request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(DisplayPrivate::Name_);
  message.set_method_name("SetStandaloneBeginFrameObserver");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

// static
bool DisplayPrivateStubDispatch::Accept(
    DisplayPrivate* impl,
    mojo::Message* message) {
  switch (message->header()->name) {
    case internal::kDisplayPrivate_SetDisplayVisible_Name: {

      DCHECK(message->is_serialized());
      internal::DisplayPrivate_SetDisplayVisible_Params_Data* params =
          reinterpret_cast<internal::DisplayPrivate_SetDisplayVisible_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      bool p_visible{};
      DisplayPrivate_SetDisplayVisible_ParamsDataView input_data_view(params, message);
      
      if (success)
        p_visible = input_data_view.visible();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            DisplayPrivate::Name_, 0, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SetDisplayVisible(
std::move(p_visible));
      return true;
    }
    case internal::kDisplayPrivate_Resize_Name: {

      DCHECK(message->is_serialized());
      internal::DisplayPrivate_Resize_Params_Data* params =
          reinterpret_cast<internal::DisplayPrivate_Resize_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::gfx::Size p_size{};
      DisplayPrivate_Resize_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadSize(&p_size))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            DisplayPrivate::Name_, 1, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->Resize(
std::move(p_size));
      return true;
    }
    case internal::kDisplayPrivate_SetDisplayColorMatrix_Name: {

      DCHECK(message->is_serialized());
      internal::DisplayPrivate_SetDisplayColorMatrix_Params_Data* params =
          reinterpret_cast<internal::DisplayPrivate_SetDisplayColorMatrix_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::gfx::Transform p_color_matrix{};
      DisplayPrivate_SetDisplayColorMatrix_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadColorMatrix(&p_color_matrix))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            DisplayPrivate::Name_, 2, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SetDisplayColorMatrix(
std::move(p_color_matrix));
      return true;
    }
    case internal::kDisplayPrivate_SetDisplayColorSpaces_Name: {

      DCHECK(message->is_serialized());
      internal::DisplayPrivate_SetDisplayColorSpaces_Params_Data* params =
          reinterpret_cast<internal::DisplayPrivate_SetDisplayColorSpaces_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::gfx::DisplayColorSpaces p_display_color_spaces{};
      DisplayPrivate_SetDisplayColorSpaces_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadDisplayColorSpaces(&p_display_color_spaces))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            DisplayPrivate::Name_, 3, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SetDisplayColorSpaces(
std::move(p_display_color_spaces));
      return true;
    }
    case internal::kDisplayPrivate_SetOutputIsSecure_Name: {

      DCHECK(message->is_serialized());
      internal::DisplayPrivate_SetOutputIsSecure_Params_Data* params =
          reinterpret_cast<internal::DisplayPrivate_SetOutputIsSecure_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      bool p_secure{};
      DisplayPrivate_SetOutputIsSecure_ParamsDataView input_data_view(params, message);
      
      if (success)
        p_secure = input_data_view.secure();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            DisplayPrivate::Name_, 4, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SetOutputIsSecure(
std::move(p_secure));
      return true;
    }
    case internal::kDisplayPrivate_SetDisplayVSyncParameters_Name: {

      DCHECK(message->is_serialized());
      internal::DisplayPrivate_SetDisplayVSyncParameters_Params_Data* params =
          reinterpret_cast<internal::DisplayPrivate_SetDisplayVSyncParameters_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::base::TimeTicks p_timebase{};
      ::base::TimeDelta p_interval{};
      DisplayPrivate_SetDisplayVSyncParameters_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadTimebase(&p_timebase))
        success = false;
      if (success && !input_data_view.ReadInterval(&p_interval))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            DisplayPrivate::Name_, 5, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SetDisplayVSyncParameters(
std::move(p_timebase), 
std::move(p_interval));
      return true;
    }
    case internal::kDisplayPrivate_ForceImmediateDrawAndSwapIfPossible_Name: {

      DCHECK(message->is_serialized());
      internal::DisplayPrivate_ForceImmediateDrawAndSwapIfPossible_Params_Data* params =
          reinterpret_cast<internal::DisplayPrivate_ForceImmediateDrawAndSwapIfPossible_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      DisplayPrivate_ForceImmediateDrawAndSwapIfPossible_ParamsDataView input_data_view(params, message);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            DisplayPrivate::Name_, 6, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->ForceImmediateDrawAndSwapIfPossible();
      return true;
    }
    case internal::kDisplayPrivate_SetVSyncPaused_Name: {

      DCHECK(message->is_serialized());
      internal::DisplayPrivate_SetVSyncPaused_Params_Data* params =
          reinterpret_cast<internal::DisplayPrivate_SetVSyncPaused_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      bool p_paused{};
      DisplayPrivate_SetVSyncPaused_ParamsDataView input_data_view(params, message);
      
      if (success)
        p_paused = input_data_view.paused();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            DisplayPrivate::Name_, 7, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SetVSyncPaused(
std::move(p_paused));
      return true;
    }
    case internal::kDisplayPrivate_UpdateRefreshRate_Name: {

      DCHECK(message->is_serialized());
      internal::DisplayPrivate_UpdateRefreshRate_Params_Data* params =
          reinterpret_cast<internal::DisplayPrivate_UpdateRefreshRate_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      float p_refresh_rate{};
      DisplayPrivate_UpdateRefreshRate_ParamsDataView input_data_view(params, message);
      
      if (success)
        p_refresh_rate = input_data_view.refresh_rate();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            DisplayPrivate::Name_, 8, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->UpdateRefreshRate(
std::move(p_refresh_rate));
      return true;
    }
    case internal::kDisplayPrivate_SetSupportedRefreshRates_Name: {

      DCHECK(message->is_serialized());
      internal::DisplayPrivate_SetSupportedRefreshRates_Params_Data* params =
          reinterpret_cast<internal::DisplayPrivate_SetSupportedRefreshRates_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      std::vector<float> p_refresh_rates{};
      DisplayPrivate_SetSupportedRefreshRates_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadRefreshRates(&p_refresh_rates))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            DisplayPrivate::Name_, 9, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SetSupportedRefreshRates(
std::move(p_refresh_rates));
      return true;
    }
    case internal::kDisplayPrivate_PreserveChildSurfaceControls_Name: {

      DCHECK(message->is_serialized());
      internal::DisplayPrivate_PreserveChildSurfaceControls_Params_Data* params =
          reinterpret_cast<internal::DisplayPrivate_PreserveChildSurfaceControls_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      DisplayPrivate_PreserveChildSurfaceControls_ParamsDataView input_data_view(params, message);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            DisplayPrivate::Name_, 10, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->PreserveChildSurfaceControls();
      return true;
    }
    case internal::kDisplayPrivate_SetSwapCompletionCallbackEnabled_Name: {

      DCHECK(message->is_serialized());
      internal::DisplayPrivate_SetSwapCompletionCallbackEnabled_Params_Data* params =
          reinterpret_cast<internal::DisplayPrivate_SetSwapCompletionCallbackEnabled_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      bool p_enable{};
      DisplayPrivate_SetSwapCompletionCallbackEnabled_ParamsDataView input_data_view(params, message);
      
      if (success)
        p_enable = input_data_view.enable();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            DisplayPrivate::Name_, 11, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SetSwapCompletionCallbackEnabled(
std::move(p_enable));
      return true;
    }
    case internal::kDisplayPrivate_AddVSyncParameterObserver_Name: {

      DCHECK(message->is_serialized());
      internal::DisplayPrivate_AddVSyncParameterObserver_Params_Data* params =
          reinterpret_cast<internal::DisplayPrivate_AddVSyncParameterObserver_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::mojo::PendingRemote<::viz::mojom::VSyncParameterObserver> p_observer{};
      DisplayPrivate_AddVSyncParameterObserver_ParamsDataView input_data_view(params, message);
      
      if (success) {
        p_observer =
            input_data_view.TakeObserver<decltype(p_observer)>();
      }
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            DisplayPrivate::Name_, 12, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->AddVSyncParameterObserver(
std::move(p_observer));
      return true;
    }
    case internal::kDisplayPrivate_SetDelegatedInkPointRenderer_Name: {

      DCHECK(message->is_serialized());
      internal::DisplayPrivate_SetDelegatedInkPointRenderer_Params_Data* params =
          reinterpret_cast<internal::DisplayPrivate_SetDelegatedInkPointRenderer_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::mojo::PendingReceiver<::gfx::mojom::DelegatedInkPointRenderer> p_receiver{};
      DisplayPrivate_SetDelegatedInkPointRenderer_ParamsDataView input_data_view(params, message);
      
      if (success) {
        p_receiver =
            input_data_view.TakeReceiver<decltype(p_receiver)>();
      }
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            DisplayPrivate::Name_, 13, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SetDelegatedInkPointRenderer(
std::move(p_receiver));
      return true;
    }
    case internal::kDisplayPrivate_SetStandaloneBeginFrameObserver_Name: {

      DCHECK(message->is_serialized());
      internal::DisplayPrivate_SetStandaloneBeginFrameObserver_Params_Data* params =
          reinterpret_cast<internal::DisplayPrivate_SetStandaloneBeginFrameObserver_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::mojo::PendingRemote<::viz::mojom::BeginFrameObserver> p_observer{};
      DisplayPrivate_SetStandaloneBeginFrameObserver_ParamsDataView input_data_view(params, message);
      
      if (success) {
        p_observer =
            input_data_view.TakeObserver<decltype(p_observer)>();
      }
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            DisplayPrivate::Name_, 14, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SetStandaloneBeginFrameObserver(
std::move(p_observer));
      return true;
    }
  }
  return false;
}

// static
bool DisplayPrivateStubDispatch::AcceptWithResponder(
    DisplayPrivate* impl,
    mojo::Message* message,
    std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
  [[maybe_unused]] const bool message_is_sync =
      message->has_flag(mojo::Message::kFlagIsSync);
  [[maybe_unused]] const uint64_t request_id = message->request_id();
  switch (message->header()->name) {
    case internal::kDisplayPrivate_SetDisplayVisible_Name: {
      break;
    }
    case internal::kDisplayPrivate_Resize_Name: {
      break;
    }
    case internal::kDisplayPrivate_SetDisplayColorMatrix_Name: {
      break;
    }
    case internal::kDisplayPrivate_SetDisplayColorSpaces_Name: {
      break;
    }
    case internal::kDisplayPrivate_SetOutputIsSecure_Name: {
      break;
    }
    case internal::kDisplayPrivate_SetDisplayVSyncParameters_Name: {
      break;
    }
    case internal::kDisplayPrivate_ForceImmediateDrawAndSwapIfPossible_Name: {
      break;
    }
    case internal::kDisplayPrivate_SetVSyncPaused_Name: {
      break;
    }
    case internal::kDisplayPrivate_UpdateRefreshRate_Name: {
      break;
    }
    case internal::kDisplayPrivate_SetSupportedRefreshRates_Name: {
      break;
    }
    case internal::kDisplayPrivate_PreserveChildSurfaceControls_Name: {
      break;
    }
    case internal::kDisplayPrivate_SetSwapCompletionCallbackEnabled_Name: {
      break;
    }
    case internal::kDisplayPrivate_AddVSyncParameterObserver_Name: {
      break;
    }
    case internal::kDisplayPrivate_SetDelegatedInkPointRenderer_Name: {
      break;
    }
    case internal::kDisplayPrivate_SetStandaloneBeginFrameObserver_Name: {
      break;
    }
  }
  return false;
}


static const mojo::internal::GenericValidationInfo kDisplayPrivateValidationInfo[] = {
    {&internal::DisplayPrivate_SetDisplayVisible_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::DisplayPrivate_Resize_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::DisplayPrivate_SetDisplayColorMatrix_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::DisplayPrivate_SetDisplayColorSpaces_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::DisplayPrivate_SetOutputIsSecure_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::DisplayPrivate_SetDisplayVSyncParameters_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::DisplayPrivate_ForceImmediateDrawAndSwapIfPossible_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::DisplayPrivate_SetVSyncPaused_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::DisplayPrivate_UpdateRefreshRate_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::DisplayPrivate_SetSupportedRefreshRates_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::DisplayPrivate_PreserveChildSurfaceControls_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::DisplayPrivate_SetSwapCompletionCallbackEnabled_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::DisplayPrivate_AddVSyncParameterObserver_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::DisplayPrivate_SetDelegatedInkPointRenderer_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::DisplayPrivate_SetStandaloneBeginFrameObserver_Params_Data::Validate,
     nullptr /* no response */},
};

bool DisplayPrivateRequestValidator::Accept(mojo::Message* message) {
  const char* name = ::viz::mojom::DisplayPrivate::Name_;
  return mojo::internal::ValidateRequestGenericPacked(message, name, kDisplayPrivateValidationInfo);
}

const char DisplayClient::Name_[] = "viz.mojom.DisplayClient";

DisplayClient::IPCStableHashFunction DisplayClient::MessageToMethodInfo_(mojo::Message& message) {
#if !BUILDFLAG(IS_FUCHSIA)
  switch (message.name()) {
    case internal::kDisplayClient_DidCompleteSwapWithSize_Name: {
      return &DisplayClient::DidCompleteSwapWithSize_Sym::IPCStableHash;
    }
    case internal::kDisplayClient_OnContextCreationResult_Name: {
      return &DisplayClient::OnContextCreationResult_Sym::IPCStableHash;
    }
    case internal::kDisplayClient_SetWideColorEnabled_Name: {
      return &DisplayClient::SetWideColorEnabled_Sym::IPCStableHash;
    }
    case internal::kDisplayClient_SetPreferredRefreshRate_Name: {
      return &DisplayClient::SetPreferredRefreshRate_Sym::IPCStableHash;
    }
  }
#endif  // !BUILDFLAG(IS_FUCHSIA)
  return nullptr;
}


const char* DisplayClient::MessageToMethodName_(mojo::Message& message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  bool is_response = message.has_flag(mojo::Message::kFlagIsResponse);
  if (!is_response) {
    switch (message.name()) {
      case internal::kDisplayClient_DidCompleteSwapWithSize_Name:
            return "Receive viz::mojom::DisplayClient::DidCompleteSwapWithSize";
      case internal::kDisplayClient_OnContextCreationResult_Name:
            return "Receive viz::mojom::DisplayClient::OnContextCreationResult";
      case internal::kDisplayClient_SetWideColorEnabled_Name:
            return "Receive viz::mojom::DisplayClient::SetWideColorEnabled";
      case internal::kDisplayClient_SetPreferredRefreshRate_Name:
            return "Receive viz::mojom::DisplayClient::SetPreferredRefreshRate";
    }
  } else {
    switch (message.name()) {
      case internal::kDisplayClient_DidCompleteSwapWithSize_Name:
            return "Receive reply viz::mojom::DisplayClient::DidCompleteSwapWithSize";
      case internal::kDisplayClient_OnContextCreationResult_Name:
            return "Receive reply viz::mojom::DisplayClient::OnContextCreationResult";
      case internal::kDisplayClient_SetWideColorEnabled_Name:
            return "Receive reply viz::mojom::DisplayClient::SetWideColorEnabled";
      case internal::kDisplayClient_SetPreferredRefreshRate_Name:
            return "Receive reply viz::mojom::DisplayClient::SetPreferredRefreshRate";
    }
  }
  return "Receive unknown mojo message";
#else
  bool is_response = message.has_flag(mojo::Message::kFlagIsResponse);
  if (is_response) {
    return "Receive mojo reply";
  } else {
    return "Receive mojo message";
  }
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
}

#if !BUILDFLAG(IS_FUCHSIA)
uint32_t DisplayClient::DidCompleteSwapWithSize_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)viz::mojom::DisplayClient::DidCompleteSwapWithSize");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t DisplayClient::OnContextCreationResult_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)viz::mojom::DisplayClient::OnContextCreationResult");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t DisplayClient::SetWideColorEnabled_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)viz::mojom::DisplayClient::SetWideColorEnabled");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t DisplayClient::SetPreferredRefreshRate_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)viz::mojom::DisplayClient::SetPreferredRefreshRate");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
# endif // !BUILDFLAG(IS_FUCHSIA)

DisplayClientProxy::DisplayClientProxy(mojo::MessageReceiverWithResponder* receiver)
    : receiver_(receiver) {
}

void DisplayClientProxy::DidCompleteSwapWithSize(
    const ::gfx::Size& in_size) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send viz::mojom::DisplayClient::DidCompleteSwapWithSize", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("size"), in_size,
                        "<value of type const ::gfx::Size&>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kDisplayClient_DidCompleteSwapWithSize_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::viz::mojom::internal::DisplayClient_DidCompleteSwapWithSize_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->size)::BaseType> size_fragment(
          params.message());
  mojo::internal::Serialize<::gfx::mojom::SizeDataView>(
      in_size, size_fragment);
  params->size.Set(
      size_fragment.is_null() ? nullptr : size_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->size.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null size in DisplayClient.DidCompleteSwapWithSize request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(DisplayClient::Name_);
  message.set_method_name("DidCompleteSwapWithSize");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void DisplayClientProxy::OnContextCreationResult(
    ::gpu::ContextResult in_result) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send viz::mojom::DisplayClient::OnContextCreationResult", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("result"), in_result,
                        "<value of type ::gpu::ContextResult>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kDisplayClient_OnContextCreationResult_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::viz::mojom::internal::DisplayClient_OnContextCreationResult_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::Serialize<::gpu::mojom::ContextResult>(
      in_result, &params->result);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(DisplayClient::Name_);
  message.set_method_name("OnContextCreationResult");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void DisplayClientProxy::SetWideColorEnabled(
    bool in_enabled) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send viz::mojom::DisplayClient::SetWideColorEnabled", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("enabled"), in_enabled,
                        "<value of type bool>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kDisplayClient_SetWideColorEnabled_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::viz::mojom::internal::DisplayClient_SetWideColorEnabled_Params_Data> params(
          message);
  params.Allocate();
  params->enabled = in_enabled;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(DisplayClient::Name_);
  message.set_method_name("SetWideColorEnabled");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void DisplayClientProxy::SetPreferredRefreshRate(
    float in_refresh_rate) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send viz::mojom::DisplayClient::SetPreferredRefreshRate", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("refresh_rate"), in_refresh_rate,
                        "<value of type float>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kDisplayClient_SetPreferredRefreshRate_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::viz::mojom::internal::DisplayClient_SetPreferredRefreshRate_Params_Data> params(
          message);
  params.Allocate();
  params->refresh_rate = in_refresh_rate;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(DisplayClient::Name_);
  message.set_method_name("SetPreferredRefreshRate");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

// static
bool DisplayClientStubDispatch::Accept(
    DisplayClient* impl,
    mojo::Message* message) {
  switch (message->header()->name) {
    case internal::kDisplayClient_DidCompleteSwapWithSize_Name: {

      DCHECK(message->is_serialized());
      internal::DisplayClient_DidCompleteSwapWithSize_Params_Data* params =
          reinterpret_cast<internal::DisplayClient_DidCompleteSwapWithSize_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::gfx::Size p_size{};
      DisplayClient_DidCompleteSwapWithSize_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadSize(&p_size))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            DisplayClient::Name_, 0, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->DidCompleteSwapWithSize(
std::move(p_size));
      return true;
    }
    case internal::kDisplayClient_OnContextCreationResult_Name: {

      DCHECK(message->is_serialized());
      internal::DisplayClient_OnContextCreationResult_Params_Data* params =
          reinterpret_cast<internal::DisplayClient_OnContextCreationResult_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::gpu::ContextResult p_result{};
      DisplayClient_OnContextCreationResult_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadResult(&p_result))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            DisplayClient::Name_, 1, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->OnContextCreationResult(
std::move(p_result));
      return true;
    }
    case internal::kDisplayClient_SetWideColorEnabled_Name: {

      DCHECK(message->is_serialized());
      internal::DisplayClient_SetWideColorEnabled_Params_Data* params =
          reinterpret_cast<internal::DisplayClient_SetWideColorEnabled_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      bool p_enabled{};
      DisplayClient_SetWideColorEnabled_ParamsDataView input_data_view(params, message);
      
      if (success)
        p_enabled = input_data_view.enabled();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            DisplayClient::Name_, 2, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SetWideColorEnabled(
std::move(p_enabled));
      return true;
    }
    case internal::kDisplayClient_SetPreferredRefreshRate_Name: {

      DCHECK(message->is_serialized());
      internal::DisplayClient_SetPreferredRefreshRate_Params_Data* params =
          reinterpret_cast<internal::DisplayClient_SetPreferredRefreshRate_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      float p_refresh_rate{};
      DisplayClient_SetPreferredRefreshRate_ParamsDataView input_data_view(params, message);
      
      if (success)
        p_refresh_rate = input_data_view.refresh_rate();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            DisplayClient::Name_, 3, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SetPreferredRefreshRate(
std::move(p_refresh_rate));
      return true;
    }
  }
  return false;
}

// static
bool DisplayClientStubDispatch::AcceptWithResponder(
    DisplayClient* impl,
    mojo::Message* message,
    std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
  [[maybe_unused]] const bool message_is_sync =
      message->has_flag(mojo::Message::kFlagIsSync);
  [[maybe_unused]] const uint64_t request_id = message->request_id();
  switch (message->header()->name) {
    case internal::kDisplayClient_DidCompleteSwapWithSize_Name: {
      break;
    }
    case internal::kDisplayClient_OnContextCreationResult_Name: {
      break;
    }
    case internal::kDisplayClient_SetWideColorEnabled_Name: {
      break;
    }
    case internal::kDisplayClient_SetPreferredRefreshRate_Name: {
      break;
    }
  }
  return false;
}


static const mojo::internal::GenericValidationInfo kDisplayClientValidationInfo[] = {
    {&internal::DisplayClient_DidCompleteSwapWithSize_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::DisplayClient_OnContextCreationResult_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::DisplayClient_SetWideColorEnabled_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::DisplayClient_SetPreferredRefreshRate_Params_Data::Validate,
     nullptr /* no response */},
};

bool DisplayClientRequestValidator::Accept(mojo::Message* message) {
  const char* name = ::viz::mojom::DisplayClient::Name_;
  return mojo::internal::ValidateRequestGenericPacked(message, name, kDisplayClientValidationInfo);
}



}  // namespace mojom
}  // namespace viz


namespace mojo {

}  // namespace mojo


// Symbols declared in the -test-utils.h header are defined here instead of a
// separate .cc file to save compile time.


namespace viz {
namespace mojom {


void DisplayPrivateInterceptorForTesting::SetDisplayVisible(bool visible) {
  GetForwardingInterface()->SetDisplayVisible(std::move(visible));
}
void DisplayPrivateInterceptorForTesting::Resize(const ::gfx::Size& size) {
  GetForwardingInterface()->Resize(std::move(size));
}
void DisplayPrivateInterceptorForTesting::SetDisplayColorMatrix(const ::gfx::Transform& color_matrix) {
  GetForwardingInterface()->SetDisplayColorMatrix(std::move(color_matrix));
}
void DisplayPrivateInterceptorForTesting::SetDisplayColorSpaces(const ::gfx::DisplayColorSpaces& display_color_spaces) {
  GetForwardingInterface()->SetDisplayColorSpaces(std::move(display_color_spaces));
}
void DisplayPrivateInterceptorForTesting::SetOutputIsSecure(bool secure) {
  GetForwardingInterface()->SetOutputIsSecure(std::move(secure));
}
void DisplayPrivateInterceptorForTesting::SetDisplayVSyncParameters(::base::TimeTicks timebase, ::base::TimeDelta interval) {
  GetForwardingInterface()->SetDisplayVSyncParameters(std::move(timebase), std::move(interval));
}
void DisplayPrivateInterceptorForTesting::ForceImmediateDrawAndSwapIfPossible() {
  GetForwardingInterface()->ForceImmediateDrawAndSwapIfPossible();
}
void DisplayPrivateInterceptorForTesting::SetVSyncPaused(bool paused) {
  GetForwardingInterface()->SetVSyncPaused(std::move(paused));
}
void DisplayPrivateInterceptorForTesting::UpdateRefreshRate(float refresh_rate) {
  GetForwardingInterface()->UpdateRefreshRate(std::move(refresh_rate));
}
void DisplayPrivateInterceptorForTesting::SetSupportedRefreshRates(const std::vector<float>& refresh_rates) {
  GetForwardingInterface()->SetSupportedRefreshRates(std::move(refresh_rates));
}
void DisplayPrivateInterceptorForTesting::PreserveChildSurfaceControls() {
  GetForwardingInterface()->PreserveChildSurfaceControls();
}
void DisplayPrivateInterceptorForTesting::SetSwapCompletionCallbackEnabled(bool enable) {
  GetForwardingInterface()->SetSwapCompletionCallbackEnabled(std::move(enable));
}
void DisplayPrivateInterceptorForTesting::AddVSyncParameterObserver(::mojo::PendingRemote<::viz::mojom::VSyncParameterObserver> observer) {
  GetForwardingInterface()->AddVSyncParameterObserver(std::move(observer));
}
void DisplayPrivateInterceptorForTesting::SetDelegatedInkPointRenderer(::mojo::PendingReceiver<::gfx::mojom::DelegatedInkPointRenderer> receiver) {
  GetForwardingInterface()->SetDelegatedInkPointRenderer(std::move(receiver));
}
void DisplayPrivateInterceptorForTesting::SetStandaloneBeginFrameObserver(::mojo::PendingRemote<::viz::mojom::BeginFrameObserver> observer) {
  GetForwardingInterface()->SetStandaloneBeginFrameObserver(std::move(observer));
}
DisplayPrivateAsyncWaiter::DisplayPrivateAsyncWaiter(
    DisplayPrivate* proxy) : proxy_(proxy) {}

DisplayPrivateAsyncWaiter::~DisplayPrivateAsyncWaiter() = default;




void DisplayClientInterceptorForTesting::DidCompleteSwapWithSize(const ::gfx::Size& size) {
  GetForwardingInterface()->DidCompleteSwapWithSize(std::move(size));
}
void DisplayClientInterceptorForTesting::OnContextCreationResult(::gpu::ContextResult result) {
  GetForwardingInterface()->OnContextCreationResult(std::move(result));
}
void DisplayClientInterceptorForTesting::SetWideColorEnabled(bool enabled) {
  GetForwardingInterface()->SetWideColorEnabled(std::move(enabled));
}
void DisplayClientInterceptorForTesting::SetPreferredRefreshRate(float refresh_rate) {
  GetForwardingInterface()->SetPreferredRefreshRate(std::move(refresh_rate));
}
DisplayClientAsyncWaiter::DisplayClientAsyncWaiter(
    DisplayClient* proxy) : proxy_(proxy) {}

DisplayClientAsyncWaiter::~DisplayClientAsyncWaiter() = default;






}  // namespace mojom
}  // namespace viz


#if defined(__clang__)
#pragma clang diagnostic pop
#endif