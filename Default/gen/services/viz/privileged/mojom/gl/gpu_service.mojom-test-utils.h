// services/viz/privileged/mojom/gl/gpu_service.mojom-test-utils.h is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2019 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef SERVICES_VIZ_PRIVILEGED_MOJOM_GL_GPU_SERVICE_MOJOM_TEST_UTILS_H_
#define SERVICES_VIZ_PRIVILEGED_MOJOM_GL_GPU_SERVICE_MOJOM_TEST_UTILS_H_

#include "services/viz/privileged/mojom/gl/gpu_service.mojom.h"


namespace viz {
namespace mojom {


class  GpuServiceInterceptorForTesting : public GpuService {
  virtual GpuService* GetForwardingInterface() = 0;
  void EstablishGpuChannel(int32_t client_id, uint64_t client_tracing_id, bool is_gpu_host, bool cache_shaders_on_disk, EstablishGpuChannelCallback callback) override;
  void SetChannelClientPid(int32_t client_id, ::base::ProcessId client_pid) override;
  void CloseChannel(int32_t client_id) override;
  void CreateVideoEncodeAcceleratorProvider(::mojo::PendingReceiver<::media::mojom::VideoEncodeAcceleratorProvider> vea_provider) override;
  void CreateGpuMemoryBuffer(::gfx::GpuMemoryBufferId id, const ::gfx::Size& size, ::gfx::BufferFormat format, ::gfx::BufferUsage usage, int32_t client_id, ::gpu::SurfaceHandle surface_handle, CreateGpuMemoryBufferCallback callback) override;
  void DestroyGpuMemoryBuffer(::gfx::GpuMemoryBufferId id, int32_t client_id, const ::gpu::SyncToken& sync_token) override;
  void CopyGpuMemoryBuffer(::gfx::GpuMemoryBufferHandle buffer_handle, ::base::UnsafeSharedMemoryRegion shared_memory, CopyGpuMemoryBufferCallback callback) override;
  void GetVideoMemoryUsageStats(GetVideoMemoryUsageStatsCallback callback) override;
  void StartPeakMemoryMonitor(uint32_t sequence_num) override;
  void GetPeakMemoryUsage(uint32_t sequence_num, GetPeakMemoryUsageCallback callback) override;
  void LoadedShader(int32_t client_id, const std::string& key, const std::string& data) override;
  void WakeUpGpu() override;
  void GpuSwitched(::gl::GpuPreference active_gpu_heuristic) override;
  void DisplayAdded() override;
  void DisplayRemoved() override;
  void DisplayMetricsChanged() override;
  void DestroyAllChannels() override;
  void OnBackgroundCleanup() override;
  void OnBackgrounded() override;
  void OnForegrounded() override;
  void GetDawnInfo(GetDawnInfoCallback callback) override;
  void Crash() override;
  void Hang() override;
  void ThrowJavaException() override;
};
class  GpuServiceAsyncWaiter {
 public:
  explicit GpuServiceAsyncWaiter(GpuService* proxy);

  GpuServiceAsyncWaiter(const GpuServiceAsyncWaiter&) = delete;
  GpuServiceAsyncWaiter& operator=(const GpuServiceAsyncWaiter&) = delete;

  ~GpuServiceAsyncWaiter();
  void EstablishGpuChannel(
      int32_t client_id, uint64_t client_tracing_id, bool is_gpu_host, bool cache_shaders_on_disk, ::mojo::ScopedMessagePipeHandle* out_channel_handle, ::gpu::GPUInfo* out_gpu_info, ::gpu::GpuFeatureInfo* out_gpu_feature_info);
  void CreateGpuMemoryBuffer(
      ::gfx::GpuMemoryBufferId id, const ::gfx::Size& size, ::gfx::BufferFormat format, ::gfx::BufferUsage usage, int32_t client_id, ::gpu::SurfaceHandle surface_handle, ::gfx::GpuMemoryBufferHandle* out_buffer_handle);
  void CopyGpuMemoryBuffer(
      ::gfx::GpuMemoryBufferHandle buffer_handle, ::base::UnsafeSharedMemoryRegion shared_memory, bool* out_success);
  void GetVideoMemoryUsageStats(
      ::gpu::VideoMemoryUsageStats* out_stats);
  void GetPeakMemoryUsage(
      uint32_t sequence_num, uint64_t* out_memory_usage, base::flat_map<::gpu::GpuPeakMemoryAllocationSource, uint64_t>* out_memory_per_allocation_source);
  void GetDawnInfo(
      std::vector<std::string>* out_dawn_info_list);

 private:
  GpuService* const proxy_;
};




}  // namespace mojom
}  // namespace viz

#endif  // SERVICES_VIZ_PRIVILEGED_MOJOM_GL_GPU_SERVICE_MOJOM_TEST_UTILS_H_