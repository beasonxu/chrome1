// services/network/public/mojom/network_context.mojom-blink.h is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2013 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef SERVICES_NETWORK_PUBLIC_MOJOM_NETWORK_CONTEXT_MOJOM_BLINK_H_
#define SERVICES_NETWORK_PUBLIC_MOJOM_NETWORK_CONTEXT_MOJOM_BLINK_H_

#include <stdint.h>

#include <limits>
#include <type_traits>
#include <utility>

#include "third_party/abseil-cpp/absl/types/optional.h"
#include "mojo/public/cpp/bindings/clone_traits.h"
#include "mojo/public/cpp/bindings/equals_traits.h"
#include "mojo/public/cpp/bindings/lib/serialization.h"
#include "mojo/public/cpp/bindings/struct_ptr.h"
#include "mojo/public/cpp/bindings/struct_traits.h"
#include "mojo/public/cpp/bindings/union_traits.h"

#include "third_party/perfetto/include/perfetto/tracing/traced_value_forward.h"

#include "services/network/public/mojom/network_context.mojom-shared.h"
#include "services/network/public/mojom/network_context.mojom-blink-forward.h"
#include "mojo/public/mojom/base/big_buffer.mojom-blink-forward.h"
#include "mojo/public/mojom/base/file_path.mojom-blink.h"
#include "mojo/public/mojom/base/read_only_file.mojom-blink.h"
#include "mojo/public/mojom/base/time.mojom-blink.h"
#include "mojo/public/mojom/base/unguessable_token.mojom-blink.h"
#include "mojo/public/mojom/base/values.mojom-blink.h"
#include "sandbox/policy/mojom/context.mojom-blink-forward.h"
#include "services/network/public/mojom/address_list.mojom-blink-forward.h"
#include "services/network/public/mojom/url_loader_network_service_observer.mojom-blink-forward.h"
#include "services/network/public/mojom/cert_verifier_service.mojom-blink-forward.h"
#include "services/network/public/mojom/client_security_state.mojom-blink.h"
#include "services/network/public/mojom/cookie_access_observer.mojom-blink-forward.h"
#include "services/network/public/mojom/cookie_manager.mojom-blink.h"
#include "services/network/public/mojom/cors_origin_pattern.mojom-blink.h"
#include "services/network/public/mojom/cross_origin_embedder_policy.mojom-blink-forward.h"
#include "services/network/public/mojom/default_credentials.mojom-blink-forward.h"
#include "services/network/public/mojom/devtools_observer.mojom-blink-forward.h"
#include "services/network/public/mojom/first_party_sets_access_delegate.mojom-blink.h"
#include "services/network/public/mojom/host_resolver.mojom-blink-forward.h"
#include "services/network/public/mojom/http_cache_backend_file_operations.mojom-blink-forward.h"
#include "services/network/public/mojom/http_request_headers.mojom-blink.h"
#include "services/network/public/mojom/ip_address.mojom-blink.h"
#include "services/network/public/mojom/ip_endpoint.mojom-blink.h"
#include "services/network/public/mojom/ip_address_space.mojom-blink-forward.h"
#include "services/network/public/mojom/mdns_responder.mojom-blink-forward.h"
#include "services/network/public/mojom/mutable_network_traffic_annotation_tag.mojom-blink.h"
#include "services/network/public/mojom/net_log.mojom-blink-forward.h"
#include "services/network/public/mojom/network_isolation_key.mojom-blink-forward.h"
#include "services/network/public/mojom/isolation_info.mojom-blink.h"
#include "services/network/public/mojom/network_param.mojom-blink.h"
#include "services/network/public/mojom/parsed_headers.mojom-blink-forward.h"
#include "services/network/public/mojom/proxy_config.mojom-blink.h"
#include "services/network/public/mojom/proxy_config_with_annotation.mojom-blink.h"
#include "services/network/public/mojom/proxy_lookup_client.mojom-blink-forward.h"
#include "services/network/public/mojom/proxy_resolving_socket.mojom-blink-forward.h"
#include "services/network/public/mojom/reporting_service.mojom-blink-forward.h"
#include "services/network/public/mojom/restricted_cookie_manager.mojom-blink-forward.h"
#include "services/network/public/mojom/site_for_cookies.mojom-blink.h"
#include "services/network/public/mojom/socket_broker.mojom-blink-forward.h"
#include "services/network/public/mojom/ssl_config.mojom-blink.h"
#include "services/network/public/mojom/tcp_socket.mojom-blink-forward.h"
#include "services/network/public/mojom/transferable_directory.mojom-blink.h"
#include "services/network/public/mojom/trust_tokens.mojom-blink-forward.h"
#include "services/network/public/mojom/udp_socket.mojom-blink-forward.h"
#include "services/network/public/mojom/url_loader.mojom-blink-forward.h"
#include "services/network/public/mojom/url_loader_factory.mojom-blink-forward.h"
#include "services/network/public/mojom/url_request.mojom-blink-forward.h"
#include "services/network/public/mojom/url_response_head.mojom-blink-forward.h"
#include "services/network/public/mojom/websocket.mojom-blink-forward.h"
#include "services/network/public/mojom/web_transport.mojom-blink-forward.h"
#include "services/proxy_resolver/public/mojom/proxy_resolver.mojom-blink-forward.h"
#include "url/mojom/origin.mojom-blink.h"
#include "url/mojom/url.mojom-blink.h"
#include "services/network/public/mojom/p2p.mojom-blink-forward.h"
#include "services/network/public/mojom/p2p_trusted.mojom-blink-forward.h"

#include "mojo/public/cpp/bindings/lib/wtf_clone_equals_util.h"
#include "mojo/public/cpp/bindings/lib/wtf_hash_util.h"
#include "third_party/blink/renderer/platform/wtf/hash_functions.h"
#include "third_party/blink/renderer/platform/wtf/text/wtf_string.h"

#include "mojo/public/cpp/bindings/lib/control_message_handler.h"
#include "mojo/public/cpp/bindings/raw_ptr_impl_ref_traits.h"


#include "third_party/blink/public/platform/web_common.h"


namespace network { struct ResourceRequest; }


namespace WTF {
struct network_mojom_internal_TrustTokenRedemptionPolicy_DataHashFn {
  static unsigned GetHash(const ::network::mojom::TrustTokenRedemptionPolicy& value) {
    using utype = std::underlying_type<::network::mojom::TrustTokenRedemptionPolicy>::type;
    return DefaultHash<utype>::Hash().GetHash(static_cast<utype>(value));
  }
  static bool Equal(const ::network::mojom::TrustTokenRedemptionPolicy& left, const ::network::mojom::TrustTokenRedemptionPolicy& right) {
    return left == right;
  }
  static const bool safe_to_compare_to_empty_or_deleted = true;
};

template <>
struct HashTraits<::network::mojom::TrustTokenRedemptionPolicy>
    : public GenericHashTraits<::network::mojom::TrustTokenRedemptionPolicy> {
  static_assert(true,
                "-1000000 is a reserved enum value");
  static_assert(true,
                "-1000001 is a reserved enum value");
  static const bool kEmptyValueIsZero = false;
  static ::network::mojom::TrustTokenRedemptionPolicy EmptyValue() { return static_cast<::network::mojom::TrustTokenRedemptionPolicy>(-1000000); }
  static void ConstructDeletedValue(::network::mojom::TrustTokenRedemptionPolicy& slot, bool) {
    slot = static_cast<::network::mojom::TrustTokenRedemptionPolicy>(-1000001);
  }
  static bool IsDeletedValue(const ::network::mojom::TrustTokenRedemptionPolicy& value) {
    return value == static_cast<::network::mojom::TrustTokenRedemptionPolicy>(-1000001);
  }
};
}  // namespace WTF


namespace WTF {
struct network_mojom_internal_SCTAuditingMode_DataHashFn {
  static unsigned GetHash(const ::network::mojom::SCTAuditingMode& value) {
    using utype = std::underlying_type<::network::mojom::SCTAuditingMode>::type;
    return DefaultHash<utype>::Hash().GetHash(static_cast<utype>(value));
  }
  static bool Equal(const ::network::mojom::SCTAuditingMode& left, const ::network::mojom::SCTAuditingMode& right) {
    return left == right;
  }
  static const bool safe_to_compare_to_empty_or_deleted = true;
};

template <>
struct HashTraits<::network::mojom::SCTAuditingMode>
    : public GenericHashTraits<::network::mojom::SCTAuditingMode> {
  static_assert(true,
                "-1000000 is a reserved enum value");
  static_assert(true,
                "-1000001 is a reserved enum value");
  static const bool kEmptyValueIsZero = false;
  static ::network::mojom::SCTAuditingMode EmptyValue() { return static_cast<::network::mojom::SCTAuditingMode>(-1000000); }
  static void ConstructDeletedValue(::network::mojom::SCTAuditingMode& slot, bool) {
    slot = static_cast<::network::mojom::SCTAuditingMode>(-1000001);
  }
  static bool IsDeletedValue(const ::network::mojom::SCTAuditingMode& value) {
    return value == static_cast<::network::mojom::SCTAuditingMode>(-1000001);
  }
};
}  // namespace WTF


namespace WTF {
struct network_mojom_internal_ClearDataFilter_Type_DataHashFn {
  static unsigned GetHash(const ::network::mojom::ClearDataFilter_Type& value) {
    using utype = std::underlying_type<::network::mojom::ClearDataFilter_Type>::type;
    return DefaultHash<utype>::Hash().GetHash(static_cast<utype>(value));
  }
  static bool Equal(const ::network::mojom::ClearDataFilter_Type& left, const ::network::mojom::ClearDataFilter_Type& right) {
    return left == right;
  }
  static const bool safe_to_compare_to_empty_or_deleted = true;
};

template <>
struct HashTraits<::network::mojom::ClearDataFilter_Type>
    : public GenericHashTraits<::network::mojom::ClearDataFilter_Type> {
  static_assert(true,
                "-1000000 is a reserved enum value");
  static_assert(true,
                "-1000001 is a reserved enum value");
  static const bool kEmptyValueIsZero = false;
  static ::network::mojom::ClearDataFilter_Type EmptyValue() { return static_cast<::network::mojom::ClearDataFilter_Type>(-1000000); }
  static void ConstructDeletedValue(::network::mojom::ClearDataFilter_Type& slot, bool) {
    slot = static_cast<::network::mojom::ClearDataFilter_Type>(-1000001);
  }
  static bool IsDeletedValue(const ::network::mojom::ClearDataFilter_Type& value) {
    return value == static_cast<::network::mojom::ClearDataFilter_Type>(-1000001);
  }
};
}  // namespace WTF


namespace WTF {
struct network_mojom_internal_NetworkContext_DomainReliabilityClearMode_DataHashFn {
  static unsigned GetHash(const ::network::mojom::NetworkContext_DomainReliabilityClearMode& value) {
    using utype = std::underlying_type<::network::mojom::NetworkContext_DomainReliabilityClearMode>::type;
    return DefaultHash<utype>::Hash().GetHash(static_cast<utype>(value));
  }
  static bool Equal(const ::network::mojom::NetworkContext_DomainReliabilityClearMode& left, const ::network::mojom::NetworkContext_DomainReliabilityClearMode& right) {
    return left == right;
  }
  static const bool safe_to_compare_to_empty_or_deleted = true;
};

template <>
struct HashTraits<::network::mojom::NetworkContext_DomainReliabilityClearMode>
    : public GenericHashTraits<::network::mojom::NetworkContext_DomainReliabilityClearMode> {
  static_assert(true,
                "-1000000 is a reserved enum value");
  static_assert(true,
                "-1000001 is a reserved enum value");
  static const bool kEmptyValueIsZero = false;
  static ::network::mojom::NetworkContext_DomainReliabilityClearMode EmptyValue() { return static_cast<::network::mojom::NetworkContext_DomainReliabilityClearMode>(-1000000); }
  static void ConstructDeletedValue(::network::mojom::NetworkContext_DomainReliabilityClearMode& slot, bool) {
    slot = static_cast<::network::mojom::NetworkContext_DomainReliabilityClearMode>(-1000001);
  }
  static bool IsDeletedValue(const ::network::mojom::NetworkContext_DomainReliabilityClearMode& value) {
    return value == static_cast<::network::mojom::NetworkContext_DomainReliabilityClearMode>(-1000001);
  }
};
}  // namespace WTF


namespace network {
namespace mojom {
namespace blink {

class CustomProxyConnectionObserverProxy;

template <typename ImplRefTraits>
class CustomProxyConnectionObserverStub;

class CustomProxyConnectionObserverRequestValidator;


class BLINK_PLATFORM_EXPORT CustomProxyConnectionObserver
    : public CustomProxyConnectionObserverInterfaceBase {
 public:
  using IPCStableHashFunction = uint32_t(*)();

  static const char Name_[];
  static IPCStableHashFunction MessageToMethodInfo_(mojo::Message& message);
  static const char* MessageToMethodName_(mojo::Message& message);
  static constexpr uint32_t Version_ = 0;
  static constexpr bool PassesAssociatedKinds_ = false;
  static constexpr bool HasSyncMethods_ = false;
  static constexpr bool HasUninterruptableMethods_ = false;

  using Base_ = CustomProxyConnectionObserverInterfaceBase;
  using Proxy_ = CustomProxyConnectionObserverProxy;

  template <typename ImplRefTraits>
  using Stub_ = CustomProxyConnectionObserverStub<ImplRefTraits>;

  using RequestValidator_ = CustomProxyConnectionObserverRequestValidator;
  using ResponseValidator_ = mojo::PassThroughFilter;
  enum MethodMinVersions : uint32_t {
    kOnFallbackMinVersion = 0,
    kOnTunnelHeadersReceivedMinVersion = 0,
  };

// crbug.com/1340245 - this causes binary size bloat on Fuchsia, and we're OK
// with not having this data in traces there.
#if !BUILDFLAG(IS_FUCHSIA)
  struct OnFallback_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct OnTunnelHeadersReceived_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
#endif // !BUILDFLAG(IS_FUCHSIA)
  virtual ~CustomProxyConnectionObserver() = default;

  
  virtual void OnFallback(::proxy_resolver::mojom::blink::ProxyServerPtr bad_proxy, int32_t net_error) = 0;

  
  virtual void OnTunnelHeadersReceived(::proxy_resolver::mojom::blink::ProxyServerPtr proxy_server, ::network::mojom::blink::HttpResponseHeadersPtr response_headers) = 0;
};

class CustomProxyConfigClientProxy;

template <typename ImplRefTraits>
class CustomProxyConfigClientStub;

class CustomProxyConfigClientRequestValidator;
class CustomProxyConfigClientResponseValidator;


class BLINK_PLATFORM_EXPORT CustomProxyConfigClient
    : public CustomProxyConfigClientInterfaceBase {
 public:
  using IPCStableHashFunction = uint32_t(*)();

  static const char Name_[];
  static IPCStableHashFunction MessageToMethodInfo_(mojo::Message& message);
  static const char* MessageToMethodName_(mojo::Message& message);
  static constexpr uint32_t Version_ = 0;
  static constexpr bool PassesAssociatedKinds_ = false;
  static constexpr bool HasSyncMethods_ = false;
  static constexpr bool HasUninterruptableMethods_ = false;

  using Base_ = CustomProxyConfigClientInterfaceBase;
  using Proxy_ = CustomProxyConfigClientProxy;

  template <typename ImplRefTraits>
  using Stub_ = CustomProxyConfigClientStub<ImplRefTraits>;

  using RequestValidator_ = CustomProxyConfigClientRequestValidator;
  using ResponseValidator_ = CustomProxyConfigClientResponseValidator;
  enum MethodMinVersions : uint32_t {
    kOnCustomProxyConfigUpdatedMinVersion = 0,
    kMarkProxiesAsBadMinVersion = 0,
    kClearBadProxiesCacheMinVersion = 0,
  };

// crbug.com/1340245 - this causes binary size bloat on Fuchsia, and we're OK
// with not having this data in traces there.
#if !BUILDFLAG(IS_FUCHSIA)
  struct OnCustomProxyConfigUpdated_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct MarkProxiesAsBad_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct ClearBadProxiesCache_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
#endif // !BUILDFLAG(IS_FUCHSIA)
  virtual ~CustomProxyConfigClient() = default;


  using OnCustomProxyConfigUpdatedCallback = base::OnceCallback<void()>;
  
  virtual void OnCustomProxyConfigUpdated(CustomProxyConfigPtr proxy_config, OnCustomProxyConfigUpdatedCallback callback) = 0;


  using MarkProxiesAsBadCallback = base::OnceCallback<void()>;
  
  virtual void MarkProxiesAsBad(::base::TimeDelta bypass_duration, ::network::mojom::blink::ProxyListPtr bad_proxies, MarkProxiesAsBadCallback callback) = 0;

  
  virtual void ClearBadProxiesCache() = 0;
};

class TrustedHeaderClientProxy;

template <typename ImplRefTraits>
class TrustedHeaderClientStub;

class TrustedHeaderClientRequestValidator;
class TrustedHeaderClientResponseValidator;


class BLINK_PLATFORM_EXPORT TrustedHeaderClient
    : public TrustedHeaderClientInterfaceBase {
 public:
  using IPCStableHashFunction = uint32_t(*)();

  static const char Name_[];
  static IPCStableHashFunction MessageToMethodInfo_(mojo::Message& message);
  static const char* MessageToMethodName_(mojo::Message& message);
  static constexpr uint32_t Version_ = 0;
  static constexpr bool PassesAssociatedKinds_ = false;
  static constexpr bool HasSyncMethods_ = false;
  static constexpr bool HasUninterruptableMethods_ = false;

  using Base_ = TrustedHeaderClientInterfaceBase;
  using Proxy_ = TrustedHeaderClientProxy;

  template <typename ImplRefTraits>
  using Stub_ = TrustedHeaderClientStub<ImplRefTraits>;

  using RequestValidator_ = TrustedHeaderClientRequestValidator;
  using ResponseValidator_ = TrustedHeaderClientResponseValidator;
  enum MethodMinVersions : uint32_t {
    kOnBeforeSendHeadersMinVersion = 0,
    kOnHeadersReceivedMinVersion = 0,
  };

// crbug.com/1340245 - this causes binary size bloat on Fuchsia, and we're OK
// with not having this data in traces there.
#if !BUILDFLAG(IS_FUCHSIA)
  struct OnBeforeSendHeaders_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct OnHeadersReceived_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
#endif // !BUILDFLAG(IS_FUCHSIA)
  virtual ~TrustedHeaderClient() = default;


  using OnBeforeSendHeadersCallback = base::OnceCallback<void(int32_t, const absl::optional<::net::HttpRequestHeaders>&)>;
  
  virtual void OnBeforeSendHeaders(const ::net::HttpRequestHeaders& headers, OnBeforeSendHeadersCallback callback) = 0;


  using OnHeadersReceivedCallback = base::OnceCallback<void(int32_t, const WTF::String&, const absl::optional<::blink::KURL>&)>;
  
  virtual void OnHeadersReceived(const WTF::String& headers, const ::net::IPEndPoint& remote_endpoint, OnHeadersReceivedCallback callback) = 0;
};

class TrustedURLLoaderHeaderClientProxy;

template <typename ImplRefTraits>
class TrustedURLLoaderHeaderClientStub;

class TrustedURLLoaderHeaderClientRequestValidator;


class BLINK_PLATFORM_EXPORT TrustedURLLoaderHeaderClient
    : public TrustedURLLoaderHeaderClientInterfaceBase {
 public:
  using IPCStableHashFunction = uint32_t(*)();

  static const char Name_[];
  static IPCStableHashFunction MessageToMethodInfo_(mojo::Message& message);
  static const char* MessageToMethodName_(mojo::Message& message);
  static constexpr uint32_t Version_ = 0;
  static constexpr bool PassesAssociatedKinds_ = false;
  static constexpr bool HasSyncMethods_ = false;
  static constexpr bool HasUninterruptableMethods_ = false;

  using Base_ = TrustedURLLoaderHeaderClientInterfaceBase;
  using Proxy_ = TrustedURLLoaderHeaderClientProxy;

  template <typename ImplRefTraits>
  using Stub_ = TrustedURLLoaderHeaderClientStub<ImplRefTraits>;

  using RequestValidator_ = TrustedURLLoaderHeaderClientRequestValidator;
  using ResponseValidator_ = mojo::PassThroughFilter;
  enum MethodMinVersions : uint32_t {
    kOnLoaderCreatedMinVersion = 0,
    kOnLoaderForCorsPreflightCreatedMinVersion = 0,
  };

// crbug.com/1340245 - this causes binary size bloat on Fuchsia, and we're OK
// with not having this data in traces there.
#if !BUILDFLAG(IS_FUCHSIA)
  struct OnLoaderCreated_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct OnLoaderForCorsPreflightCreated_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
#endif // !BUILDFLAG(IS_FUCHSIA)
  virtual ~TrustedURLLoaderHeaderClient() = default;

  
  virtual void OnLoaderCreated(int32_t request_id, ::mojo::PendingReceiver<TrustedHeaderClient> header_client) = 0;

  
  virtual void OnLoaderForCorsPreflightCreated(const ::network::ResourceRequest& request, ::mojo::PendingReceiver<TrustedHeaderClient> header_client) = 0;
};

class NetworkContextClientProxy;

template <typename ImplRefTraits>
class NetworkContextClientStub;

class NetworkContextClientRequestValidator;
class NetworkContextClientResponseValidator;


class BLINK_PLATFORM_EXPORT NetworkContextClient
    : public NetworkContextClientInterfaceBase {
 public:
  using IPCStableHashFunction = uint32_t(*)();

  static const char Name_[];
  static IPCStableHashFunction MessageToMethodInfo_(mojo::Message& message);
  static const char* MessageToMethodName_(mojo::Message& message);
  static constexpr uint32_t Version_ = 0;
  static constexpr bool PassesAssociatedKinds_ = false;
  static constexpr bool HasSyncMethods_ = false;
  static constexpr bool HasUninterruptableMethods_ = false;

  using Base_ = NetworkContextClientInterfaceBase;
  using Proxy_ = NetworkContextClientProxy;

  template <typename ImplRefTraits>
  using Stub_ = NetworkContextClientStub<ImplRefTraits>;

  using RequestValidator_ = NetworkContextClientRequestValidator;
  using ResponseValidator_ = NetworkContextClientResponseValidator;
  enum MethodMinVersions : uint32_t {
    kOnFileUploadRequestedMinVersion = 0,
    kOnCanSendReportingReportsMinVersion = 0,
    kOnCanSendDomainReliabilityUploadMinVersion = 0,
    kOnGenerateHttpNegotiateAuthTokenMinVersion = 0,
    kOnTrustTokenIssuanceDivertedToSystemMinVersion = 0,
    kOnCanSendSCTAuditingReportMinVersion = 0,
    kOnNewSCTAuditingReportSentMinVersion = 0,
  };

// crbug.com/1340245 - this causes binary size bloat on Fuchsia, and we're OK
// with not having this data in traces there.
#if !BUILDFLAG(IS_FUCHSIA)
  struct OnFileUploadRequested_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct OnCanSendReportingReports_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct OnCanSendDomainReliabilityUpload_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct OnGenerateHttpNegotiateAuthToken_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct OnTrustTokenIssuanceDivertedToSystem_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct OnCanSendSCTAuditingReport_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct OnNewSCTAuditingReportSent_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
#endif // !BUILDFLAG(IS_FUCHSIA)
  virtual ~NetworkContextClient() = default;


  using OnFileUploadRequestedCallback = base::OnceCallback<void(int32_t, WTF::Vector<::base::File>)>;
  
  virtual void OnFileUploadRequested(int32_t process_id, bool async, const WTF::Vector<::base::FilePath>& file_paths, const ::blink::KURL& destination_url, OnFileUploadRequestedCallback callback) = 0;


  using OnCanSendReportingReportsCallback = base::OnceCallback<void(const WTF::Vector<::scoped_refptr<const ::blink::SecurityOrigin>>&)>;
  
  virtual void OnCanSendReportingReports(const WTF::Vector<::scoped_refptr<const ::blink::SecurityOrigin>>& origins, OnCanSendReportingReportsCallback callback) = 0;


  using OnCanSendDomainReliabilityUploadCallback = base::OnceCallback<void(bool)>;
  
  virtual void OnCanSendDomainReliabilityUpload(const ::scoped_refptr<const ::blink::SecurityOrigin>& origin, OnCanSendDomainReliabilityUploadCallback callback) = 0;


  using OnGenerateHttpNegotiateAuthTokenCallback = base::OnceCallback<void(int32_t, const WTF::String&)>;
  
  virtual void OnGenerateHttpNegotiateAuthToken(const WTF::String& server_auth_token, bool can_delegate, const WTF::String& auth_negotiate_android_account_type, const WTF::String& spn, OnGenerateHttpNegotiateAuthTokenCallback callback) = 0;


  using OnTrustTokenIssuanceDivertedToSystemCallback = base::OnceCallback<void(::network::mojom::blink::FulfillTrustTokenIssuanceAnswerPtr)>;
  
  virtual void OnTrustTokenIssuanceDivertedToSystem(::network::mojom::blink::FulfillTrustTokenIssuanceRequestPtr request, OnTrustTokenIssuanceDivertedToSystemCallback callback) = 0;


  using OnCanSendSCTAuditingReportCallback = base::OnceCallback<void(bool)>;
  
  virtual void OnCanSendSCTAuditingReport(OnCanSendSCTAuditingReportCallback callback) = 0;

  
  virtual void OnNewSCTAuditingReportSent() = 0;
};

class NetworkContextProxy;

template <typename ImplRefTraits>
class NetworkContextStub;

class NetworkContextRequestValidator;
class NetworkContextResponseValidator;


class BLINK_PLATFORM_EXPORT NetworkContext
    : public NetworkContextInterfaceBase {
 public:
  using IPCStableHashFunction = uint32_t(*)();

  static const char Name_[];
  static IPCStableHashFunction MessageToMethodInfo_(mojo::Message& message);
  static const char* MessageToMethodName_(mojo::Message& message);
  static constexpr uint32_t Version_ = 0;
  static constexpr bool PassesAssociatedKinds_ = false;
  static constexpr bool HasSyncMethods_ = true;
  static constexpr bool HasUninterruptableMethods_ = false;

  using Base_ = NetworkContextInterfaceBase;
  using Proxy_ = NetworkContextProxy;

  template <typename ImplRefTraits>
  using Stub_ = NetworkContextStub<ImplRefTraits>;

  using RequestValidator_ = NetworkContextRequestValidator;
  using ResponseValidator_ = NetworkContextResponseValidator;
  enum MethodMinVersions : uint32_t {
    kSetClientMinVersion = 0,
    kCreateURLLoaderFactoryMinVersion = 0,
    kResetURLLoaderFactoriesMinVersion = 0,
    kGetCookieManagerMinVersion = 0,
    kGetRestrictedCookieManagerMinVersion = 0,
    kGetTrustTokenQueryAnswererMinVersion = 0,
    kClearTrustTokenDataMinVersion = 0,
    kGetStoredTrustTokenCountsMinVersion = 0,
    kDeleteStoredTrustTokensMinVersion = 0,
    kSetBlockTrustTokensMinVersion = 0,
    kClearNetworkingHistoryBetweenMinVersion = 0,
    kClearHttpCacheMinVersion = 0,
    kComputeHttpCacheSizeMinVersion = 0,
    kNotifyExternalCacheHitMinVersion = 0,
    kClearHostCacheMinVersion = 0,
    kClearHttpAuthCacheMinVersion = 0,
    kClearReportingCacheReportsMinVersion = 0,
    kClearReportingCacheClientsMinVersion = 0,
    kClearNetworkErrorLoggingMinVersion = 0,
    kClearDomainReliabilityMinVersion = 0,
    kSetDocumentReportingEndpointsMinVersion = 0,
    kSendReportsAndRemoveSourceMinVersion = 0,
    kQueueReportMinVersion = 0,
    kQueueSignedExchangeReportMinVersion = 0,
    kCloseAllConnectionsMinVersion = 0,
    kCloseIdleConnectionsMinVersion = 0,
    kSetNetworkConditionsMinVersion = 0,
    kSetAcceptLanguageMinVersion = 0,
    kSetEnableReferrersMinVersion = 0,
    kSetCTPolicyMinVersion = 0,
    kAddExpectCTMinVersion = 0,
    kSetExpectCTTestReportMinVersion = 0,
    kGetExpectCTStateMinVersion = 0,
    kCreateUDPSocketMinVersion = 0,
    kCreateTCPServerSocketMinVersion = 0,
    kCreateTCPConnectedSocketMinVersion = 0,
    kCreateTCPBoundSocketMinVersion = 0,
    kCreateProxyResolvingSocketFactoryMinVersion = 0,
    kLookUpProxyForURLMinVersion = 0,
    kForceReloadProxyConfigMinVersion = 0,
    kClearBadProxiesCacheMinVersion = 0,
    kCreateWebSocketMinVersion = 0,
    kCreateWebTransportMinVersion = 0,
    kCreateNetLogExporterMinVersion = 0,
    kPreconnectSocketsMinVersion = 0,
    kCreateP2PSocketManagerMinVersion = 0,
    kCreateMdnsResponderMinVersion = 0,
    kResolveHostMinVersion = 0,
    kCreateHostResolverMinVersion = 0,
    kVerifyCertForSignedExchangeMinVersion = 0,
    kAddHSTSMinVersion = 0,
    kIsHSTSActiveForHostMinVersion = 0,
    kGetHSTSStateMinVersion = 0,
    kSetCorsOriginAccessListsForOriginMinVersion = 0,
    kDeleteDynamicDataForHostMinVersion = 0,
    kSetSplitAuthCacheByNetworkIsolationKeyMinVersion = 0,
    kSaveHttpAuthCacheProxyEntriesMinVersion = 0,
    kLoadHttpAuthCacheProxyEntriesMinVersion = 0,
    kAddAuthCacheEntryMinVersion = 0,
    kSetCorsNonWildcardRequestHeadersSupportMinVersion = 0,
    kLookupServerBasicAuthCredentialsMinVersion = 0,
    kEnableStaticKeyPinningForTestingMinVersion = 0,
    kVerifyCertificateForTestingMinVersion = 0,
    kAddDomainReliabilityContextForTestingMinVersion = 0,
    kForceDomainReliabilityUploadsForTestingMinVersion = 0,
    kSetCTLogListAlwaysTimelyForTestingMinVersion = 0,
    kSetSCTAuditingModeMinVersion = 0,
    kAddReportingApiObserverMinVersion = 0,
  };

// crbug.com/1340245 - this causes binary size bloat on Fuchsia, and we're OK
// with not having this data in traces there.
#if !BUILDFLAG(IS_FUCHSIA)
  struct SetClient_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct CreateURLLoaderFactory_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct ResetURLLoaderFactories_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct GetCookieManager_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct GetRestrictedCookieManager_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct GetTrustTokenQueryAnswerer_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct ClearTrustTokenData_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct GetStoredTrustTokenCounts_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct DeleteStoredTrustTokens_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct SetBlockTrustTokens_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct ClearNetworkingHistoryBetween_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct ClearHttpCache_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct ComputeHttpCacheSize_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct NotifyExternalCacheHit_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct ClearHostCache_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct ClearHttpAuthCache_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct ClearReportingCacheReports_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct ClearReportingCacheClients_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct ClearNetworkErrorLogging_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct ClearDomainReliability_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct SetDocumentReportingEndpoints_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct SendReportsAndRemoveSource_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct QueueReport_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct QueueSignedExchangeReport_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct CloseAllConnections_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct CloseIdleConnections_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct SetNetworkConditions_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct SetAcceptLanguage_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct SetEnableReferrers_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct SetCTPolicy_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct AddExpectCT_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct SetExpectCTTestReport_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct GetExpectCTState_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct CreateUDPSocket_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct CreateTCPServerSocket_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct CreateTCPConnectedSocket_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct CreateTCPBoundSocket_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct CreateProxyResolvingSocketFactory_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct LookUpProxyForURL_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct ForceReloadProxyConfig_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct ClearBadProxiesCache_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct CreateWebSocket_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct CreateWebTransport_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct CreateNetLogExporter_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct PreconnectSockets_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct CreateP2PSocketManager_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct CreateMdnsResponder_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct ResolveHost_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct CreateHostResolver_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct VerifyCertForSignedExchange_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct AddHSTS_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct IsHSTSActiveForHost_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct GetHSTSState_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct SetCorsOriginAccessListsForOrigin_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct DeleteDynamicDataForHost_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct SetSplitAuthCacheByNetworkIsolationKey_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct SaveHttpAuthCacheProxyEntries_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct LoadHttpAuthCacheProxyEntries_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct AddAuthCacheEntry_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct SetCorsNonWildcardRequestHeadersSupport_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct LookupServerBasicAuthCredentials_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct EnableStaticKeyPinningForTesting_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct VerifyCertificateForTesting_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct AddDomainReliabilityContextForTesting_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct ForceDomainReliabilityUploadsForTesting_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct SetCTLogListAlwaysTimelyForTesting_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct SetSCTAuditingMode_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct AddReportingApiObserver_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
#endif // !BUILDFLAG(IS_FUCHSIA)
  
  using DomainReliabilityClearMode = NetworkContext_DomainReliabilityClearMode;
  virtual ~NetworkContext() = default;

  
  virtual void SetClient(::mojo::PendingRemote<NetworkContextClient> client) = 0;

  
  virtual void CreateURLLoaderFactory(::mojo::PendingReceiver<::network::mojom::blink::URLLoaderFactory> url_loader_factory, URLLoaderFactoryParamsPtr params) = 0;

  
  virtual void ResetURLLoaderFactories() = 0;

  
  virtual void GetCookieManager(::mojo::PendingReceiver<::network::mojom::blink::CookieManager> cookie_manager) = 0;

  
  virtual void GetRestrictedCookieManager(::mojo::PendingReceiver<::network::mojom::blink::RestrictedCookieManager> restricted_cookie_manager, ::network::mojom::blink::RestrictedCookieManagerRole role, const ::scoped_refptr<const ::blink::SecurityOrigin>& origin, const ::net::IsolationInfo& isolation_info, ::mojo::PendingRemote<::network::mojom::blink::CookieAccessObserver> cookie_observer) = 0;

  
  virtual void GetTrustTokenQueryAnswerer(::mojo::PendingReceiver<::network::mojom::blink::TrustTokenQueryAnswerer> trust_token_query_answerer, const ::scoped_refptr<const ::blink::SecurityOrigin>& top_frame_origin) = 0;


  using ClearTrustTokenDataCallback = base::OnceCallback<void()>;
  
  virtual void ClearTrustTokenData(ClearDataFilterPtr filter, ClearTrustTokenDataCallback callback) = 0;


  using GetStoredTrustTokenCountsCallback = base::OnceCallback<void(WTF::Vector<::network::mojom::blink::StoredTrustTokensForIssuerPtr>)>;
  
  virtual void GetStoredTrustTokenCounts(GetStoredTrustTokenCountsCallback callback) = 0;


  using DeleteStoredTrustTokensCallback = base::OnceCallback<void(::network::mojom::blink::DeleteStoredTrustTokensStatus)>;
  
  virtual void DeleteStoredTrustTokens(const ::scoped_refptr<const ::blink::SecurityOrigin>& issuer, DeleteStoredTrustTokensCallback callback) = 0;

  
  virtual void SetBlockTrustTokens(bool block) = 0;


  using ClearNetworkingHistoryBetweenCallback = base::OnceCallback<void()>;
  
  virtual void ClearNetworkingHistoryBetween(::base::Time start_time, ::base::Time end_time, ClearNetworkingHistoryBetweenCallback callback) = 0;


  using ClearHttpCacheCallback = base::OnceCallback<void()>;
  
  virtual void ClearHttpCache(::base::Time start_time, ::base::Time end_time, ClearDataFilterPtr filter, ClearHttpCacheCallback callback) = 0;


  using ComputeHttpCacheSizeCallback = base::OnceCallback<void(bool, int64_t)>;
  
  virtual void ComputeHttpCacheSize(::base::Time start_time, ::base::Time end_time, ComputeHttpCacheSizeCallback callback) = 0;

  
  virtual void NotifyExternalCacheHit(const ::blink::KURL& url, const WTF::String& http_method, ::network::mojom::blink::NetworkIsolationKeyPtr key, bool is_subframe_document_resource, bool include_credentials) = 0;


  using ClearHostCacheCallback = base::OnceCallback<void()>;
  
  virtual void ClearHostCache(ClearDataFilterPtr filter, ClearHostCacheCallback callback) = 0;


  using ClearHttpAuthCacheCallback = base::OnceCallback<void()>;
  
  virtual void ClearHttpAuthCache(::base::Time start_time, ::base::Time end_time, ClearHttpAuthCacheCallback callback) = 0;


  using ClearReportingCacheReportsCallback = base::OnceCallback<void()>;
  
  virtual void ClearReportingCacheReports(ClearDataFilterPtr filter, ClearReportingCacheReportsCallback callback) = 0;


  using ClearReportingCacheClientsCallback = base::OnceCallback<void()>;
  
  virtual void ClearReportingCacheClients(ClearDataFilterPtr filter, ClearReportingCacheClientsCallback callback) = 0;


  using ClearNetworkErrorLoggingCallback = base::OnceCallback<void()>;
  
  virtual void ClearNetworkErrorLogging(ClearDataFilterPtr filter, ClearNetworkErrorLoggingCallback callback) = 0;


  using ClearDomainReliabilityCallback = base::OnceCallback<void()>;
  
  virtual void ClearDomainReliability(ClearDataFilterPtr filter, NetworkContext::DomainReliabilityClearMode mode, ClearDomainReliabilityCallback callback) = 0;

  
  virtual void SetDocumentReportingEndpoints(const ::base::UnguessableToken& reporting_source, const ::scoped_refptr<const ::blink::SecurityOrigin>& origin, const ::net::IsolationInfo& isolation_info, const WTF::HashMap<WTF::String, WTF::String>& endpoints) = 0;

  
  virtual void SendReportsAndRemoveSource(const ::base::UnguessableToken& reporting_source) = 0;

  
  virtual void QueueReport(const WTF::String& type, const WTF::String& group, const ::blink::KURL& url, const absl::optional<::base::UnguessableToken>& reporting_source, ::network::mojom::blink::NetworkIsolationKeyPtr network_isolation_key, const WTF::String& user_agent, ::base::Value::Dict body) = 0;

  
  virtual void QueueSignedExchangeReport(SignedExchangeReportPtr report, ::network::mojom::blink::NetworkIsolationKeyPtr network_isolation_key) = 0;


  using CloseAllConnectionsCallback = base::OnceCallback<void()>;
  
  virtual void CloseAllConnections(CloseAllConnectionsCallback callback) = 0;


  using CloseIdleConnectionsCallback = base::OnceCallback<void()>;
  
  virtual void CloseIdleConnections(CloseIdleConnectionsCallback callback) = 0;

  
  virtual void SetNetworkConditions(const ::base::UnguessableToken& throttling_profile_id, NetworkConditionsPtr conditions) = 0;

  
  virtual void SetAcceptLanguage(const WTF::String& new_accept_language) = 0;

  
  virtual void SetEnableReferrers(bool enable_referrers) = 0;

  
  virtual void SetCTPolicy(CTPolicyPtr ct_policy) = 0;


  using AddExpectCTCallback = base::OnceCallback<void(bool)>;
  
  virtual void AddExpectCT(const WTF::String& host, ::base::Time expiry, bool enforce, const ::blink::KURL& report_uri, ::network::mojom::blink::NetworkIsolationKeyPtr network_isolation_key, AddExpectCTCallback callback) = 0;


  using SetExpectCTTestReportCallback = base::OnceCallback<void(bool)>;
  
  virtual void SetExpectCTTestReport(const ::blink::KURL& report_uri, SetExpectCTTestReportCallback callback) = 0;


  using GetExpectCTStateCallback = base::OnceCallback<void(::base::Value::Dict)>;
  
  virtual void GetExpectCTState(const WTF::String& domain, ::network::mojom::blink::NetworkIsolationKeyPtr network_isolation_key, GetExpectCTStateCallback callback) = 0;

  
  virtual void CreateUDPSocket(::mojo::PendingReceiver<::network::mojom::blink::UDPSocket> receiver, ::mojo::PendingRemote<::network::mojom::blink::UDPSocketListener> listener) = 0;


  using CreateTCPServerSocketCallback = base::OnceCallback<void(int32_t, const absl::optional<::net::IPEndPoint>&)>;
  
  virtual void CreateTCPServerSocket(const ::net::IPEndPoint& local_addr, uint32_t backlog, const ::net::MutableNetworkTrafficAnnotationTag& traffic_annotation, ::mojo::PendingReceiver<::network::mojom::blink::TCPServerSocket> socket, CreateTCPServerSocketCallback callback) = 0;


  using CreateTCPConnectedSocketCallback = base::OnceCallback<void(int32_t, const absl::optional<::net::IPEndPoint>&, const absl::optional<::net::IPEndPoint>&, ::mojo::ScopedDataPipeConsumerHandle, ::mojo::ScopedDataPipeProducerHandle)>;
  
  virtual void CreateTCPConnectedSocket(const absl::optional<::net::IPEndPoint>& local_addr, ::network::mojom::blink::AddressListPtr remote_addr_list, ::network::mojom::blink::TCPConnectedSocketOptionsPtr tcp_connected_socket_options, const ::net::MutableNetworkTrafficAnnotationTag& traffic_annotation, ::mojo::PendingReceiver<::network::mojom::blink::TCPConnectedSocket> socket, ::mojo::PendingRemote<::network::mojom::blink::SocketObserver> observer, CreateTCPConnectedSocketCallback callback) = 0;


  using CreateTCPBoundSocketCallback = base::OnceCallback<void(int32_t, const absl::optional<::net::IPEndPoint>&)>;
  
  virtual void CreateTCPBoundSocket(const ::net::IPEndPoint& local_addr, const ::net::MutableNetworkTrafficAnnotationTag& traffic_annotation, ::mojo::PendingReceiver<::network::mojom::blink::TCPBoundSocket> socket, CreateTCPBoundSocketCallback callback) = 0;

  
  virtual void CreateProxyResolvingSocketFactory(::mojo::PendingReceiver<::network::mojom::blink::ProxyResolvingSocketFactory> factory) = 0;

  
  virtual void LookUpProxyForURL(const ::blink::KURL& url, ::network::mojom::blink::NetworkIsolationKeyPtr network_isolation_key, ::mojo::PendingRemote<::network::mojom::blink::ProxyLookupClient> proxy_lookup_client) = 0;


  using ForceReloadProxyConfigCallback = base::OnceCallback<void()>;
  
  virtual void ForceReloadProxyConfig(ForceReloadProxyConfigCallback callback) = 0;


  using ClearBadProxiesCacheCallback = base::OnceCallback<void()>;
  
  virtual void ClearBadProxiesCache(ClearBadProxiesCacheCallback callback) = 0;

  
  virtual void CreateWebSocket(const ::blink::KURL& url, const WTF::Vector<WTF::String>& requested_protocols, const ::net::SiteForCookies& site_for_cookies, const ::net::IsolationInfo& isolation_info, WTF::Vector<::network::mojom::blink::HttpHeaderPtr> additional_headers, int32_t process_id, const ::scoped_refptr<const ::blink::SecurityOrigin>& origin, uint32_t options, const ::net::MutableNetworkTrafficAnnotationTag& traffic_annotation, ::mojo::PendingRemote<::network::mojom::blink::WebSocketHandshakeClient> handshake_client, ::mojo::PendingRemote<::network::mojom::blink::URLLoaderNetworkServiceObserver> url_loader_network_observer, ::mojo::PendingRemote<::network::mojom::blink::WebSocketAuthenticationHandler> auth_handler, ::mojo::PendingRemote<TrustedHeaderClient> header_client, const absl::optional<::base::UnguessableToken>& throttling_profile_id) = 0;

  
  virtual void CreateWebTransport(const ::blink::KURL& url, const ::scoped_refptr<const ::blink::SecurityOrigin>& origin, ::network::mojom::blink::NetworkIsolationKeyPtr network_isolation_key, WTF::Vector<::network::mojom::blink::WebTransportCertificateFingerprintPtr> fingerprints, ::mojo::PendingRemote<::network::mojom::blink::WebTransportHandshakeClient> handshake_client) = 0;

  
  virtual void CreateNetLogExporter(::mojo::PendingReceiver<::network::mojom::blink::NetLogExporter> receiver) = 0;

  
  virtual void PreconnectSockets(uint32_t num_streams, const ::blink::KURL& url, bool allow_credentials, ::network::mojom::blink::NetworkIsolationKeyPtr network_isolation_key) = 0;

  
  virtual void CreateP2PSocketManager(::network::mojom::blink::NetworkIsolationKeyPtr network_isolation_key, ::mojo::PendingRemote<::network::mojom::blink::P2PTrustedSocketManagerClient> client, ::mojo::PendingReceiver<::network::mojom::blink::P2PTrustedSocketManager> trusted_socket_manager, ::mojo::PendingReceiver<::network::mojom::blink::P2PSocketManager> socket_manager) = 0;

  
  virtual void CreateMdnsResponder(::mojo::PendingReceiver<::network::mojom::blink::MdnsResponder> responder_receiver) = 0;

  
  virtual void ResolveHost(::network::mojom::blink::HostPortPairPtr host, ::network::mojom::blink::NetworkIsolationKeyPtr network_isolation_key, ::network::mojom::blink::ResolveHostParametersPtr optional_parameters, ::mojo::PendingRemote<::network::mojom::blink::ResolveHostClient> response_client) = 0;

  
  virtual void CreateHostResolver(::network::mojom::blink::DnsConfigOverridesPtr config_overrides, ::mojo::PendingReceiver<::network::mojom::blink::HostResolver> host_resolver) = 0;


  using VerifyCertForSignedExchangeCallback = base::OnceCallback<void(int32_t, ::network::mojom::blink::CertVerifyResultPtr, bool, const WTF::String&)>;
  
  virtual void VerifyCertForSignedExchange(::network::mojom::blink::X509CertificatePtr certificate, const ::blink::KURL& url, ::network::mojom::blink::NetworkIsolationKeyPtr network_isolation_key, const WTF::String& ocsp_response, const WTF::String& sct_list, VerifyCertForSignedExchangeCallback callback) = 0;


  using AddHSTSCallback = base::OnceCallback<void()>;
  
  virtual void AddHSTS(const WTF::String& host, ::base::Time expiry, bool include_subdomains, AddHSTSCallback callback) = 0;


  using IsHSTSActiveForHostCallback = base::OnceCallback<void(bool)>;
  
  virtual void IsHSTSActiveForHost(const WTF::String& host, IsHSTSActiveForHostCallback callback) = 0;


  using GetHSTSStateCallback = base::OnceCallback<void(::base::Value::Dict)>;
  
  virtual void GetHSTSState(const WTF::String& domain, GetHSTSStateCallback callback) = 0;


  using SetCorsOriginAccessListsForOriginCallback = base::OnceCallback<void()>;
  
  virtual void SetCorsOriginAccessListsForOrigin(const ::scoped_refptr<const ::blink::SecurityOrigin>& source_origin, WTF::Vector<::network::mojom::blink::CorsOriginPatternPtr> allow_patterns, WTF::Vector<::network::mojom::blink::CorsOriginPatternPtr> block_patterns, SetCorsOriginAccessListsForOriginCallback callback) = 0;


  using DeleteDynamicDataForHostCallback = base::OnceCallback<void(bool)>;
  
  virtual void DeleteDynamicDataForHost(const WTF::String& host, DeleteDynamicDataForHostCallback callback) = 0;

  
  virtual void SetSplitAuthCacheByNetworkIsolationKey(bool split_auth_cache_by_network_isolation_key) = 0;


  using SaveHttpAuthCacheProxyEntriesCallback = base::OnceCallback<void(const ::base::UnguessableToken&)>;
  
  virtual void SaveHttpAuthCacheProxyEntries(SaveHttpAuthCacheProxyEntriesCallback callback) = 0;


  using LoadHttpAuthCacheProxyEntriesCallback = base::OnceCallback<void()>;
  
  virtual void LoadHttpAuthCacheProxyEntries(const ::base::UnguessableToken& cache_key, LoadHttpAuthCacheProxyEntriesCallback callback) = 0;


  using AddAuthCacheEntryCallback = base::OnceCallback<void()>;
  
  virtual void AddAuthCacheEntry(const ::net::AuthChallengeInfo& challenge, ::network::mojom::blink::NetworkIsolationKeyPtr network_isolation_key, ::network::mojom::blink::AuthCredentialsPtr credentials, AddAuthCacheEntryCallback callback) = 0;

  
  virtual void SetCorsNonWildcardRequestHeadersSupport(bool value) = 0;


  using LookupServerBasicAuthCredentialsCallback = base::OnceCallback<void(::network::mojom::blink::AuthCredentialsPtr)>;
  
  virtual void LookupServerBasicAuthCredentials(const ::blink::KURL& url, ::network::mojom::blink::NetworkIsolationKeyPtr network_isolation_key, LookupServerBasicAuthCredentialsCallback callback) = 0;

  // Sync method. This signature is used by the client side; the service side
  // should implement the signature with callback below.
  
  virtual bool EnableStaticKeyPinningForTesting();

  using EnableStaticKeyPinningForTestingCallback = base::OnceCallback<void()>;
  
  virtual void EnableStaticKeyPinningForTesting(EnableStaticKeyPinningForTestingCallback callback) = 0;


  using VerifyCertificateForTestingCallback = base::OnceCallback<void(int32_t)>;
  
  virtual void VerifyCertificateForTesting(::network::mojom::blink::X509CertificatePtr certificate, const WTF::String& hostname, const WTF::String& ocsp_response, const WTF::String& sct_list, VerifyCertificateForTestingCallback callback) = 0;

  // Sync method. This signature is used by the client side; the service side
  // should implement the signature with callback below.
  
  virtual bool AddDomainReliabilityContextForTesting(const ::scoped_refptr<const ::blink::SecurityOrigin>& origin, const ::blink::KURL& upload_url);

  using AddDomainReliabilityContextForTestingCallback = base::OnceCallback<void()>;
  
  virtual void AddDomainReliabilityContextForTesting(const ::scoped_refptr<const ::blink::SecurityOrigin>& origin, const ::blink::KURL& upload_url, AddDomainReliabilityContextForTestingCallback callback) = 0;

  // Sync method. This signature is used by the client side; the service side
  // should implement the signature with callback below.
  
  virtual bool ForceDomainReliabilityUploadsForTesting();

  using ForceDomainReliabilityUploadsForTestingCallback = base::OnceCallback<void()>;
  
  virtual void ForceDomainReliabilityUploadsForTesting(ForceDomainReliabilityUploadsForTestingCallback callback) = 0;

  
  virtual void SetCTLogListAlwaysTimelyForTesting() = 0;

  
  virtual void SetSCTAuditingMode(SCTAuditingMode mode) = 0;

  
  virtual void AddReportingApiObserver(::mojo::PendingRemote<::network::mojom::blink::ReportingApiObserver> observer) = 0;
};



class BLINK_PLATFORM_EXPORT CustomProxyConnectionObserverProxy
    : public CustomProxyConnectionObserver {
 public:
  using InterfaceType = CustomProxyConnectionObserver;

  explicit CustomProxyConnectionObserverProxy(mojo::MessageReceiverWithResponder* receiver);
  
  void OnFallback(::proxy_resolver::mojom::blink::ProxyServerPtr bad_proxy, int32_t net_error) final;
  
  void OnTunnelHeadersReceived(::proxy_resolver::mojom::blink::ProxyServerPtr proxy_server, ::network::mojom::blink::HttpResponseHeadersPtr response_headers) final;

 private:
  mojo::MessageReceiverWithResponder* receiver_;
};



class BLINK_PLATFORM_EXPORT CustomProxyConfigClientProxy
    : public CustomProxyConfigClient {
 public:
  using InterfaceType = CustomProxyConfigClient;

  explicit CustomProxyConfigClientProxy(mojo::MessageReceiverWithResponder* receiver);
  
  void OnCustomProxyConfigUpdated(CustomProxyConfigPtr proxy_config, OnCustomProxyConfigUpdatedCallback callback) final;
  
  void MarkProxiesAsBad(::base::TimeDelta bypass_duration, ::network::mojom::blink::ProxyListPtr bad_proxies, MarkProxiesAsBadCallback callback) final;
  
  void ClearBadProxiesCache() final;

 private:
  mojo::MessageReceiverWithResponder* receiver_;
};



class BLINK_PLATFORM_EXPORT TrustedHeaderClientProxy
    : public TrustedHeaderClient {
 public:
  using InterfaceType = TrustedHeaderClient;

  explicit TrustedHeaderClientProxy(mojo::MessageReceiverWithResponder* receiver);
  
  void OnBeforeSendHeaders(const ::net::HttpRequestHeaders& headers, OnBeforeSendHeadersCallback callback) final;
  
  void OnHeadersReceived(const WTF::String& headers, const ::net::IPEndPoint& remote_endpoint, OnHeadersReceivedCallback callback) final;

 private:
  mojo::MessageReceiverWithResponder* receiver_;
};



class BLINK_PLATFORM_EXPORT TrustedURLLoaderHeaderClientProxy
    : public TrustedURLLoaderHeaderClient {
 public:
  using InterfaceType = TrustedURLLoaderHeaderClient;

  explicit TrustedURLLoaderHeaderClientProxy(mojo::MessageReceiverWithResponder* receiver);
  
  void OnLoaderCreated(int32_t request_id, ::mojo::PendingReceiver<TrustedHeaderClient> header_client) final;
  
  void OnLoaderForCorsPreflightCreated(const ::network::ResourceRequest& request, ::mojo::PendingReceiver<TrustedHeaderClient> header_client) final;

 private:
  mojo::MessageReceiverWithResponder* receiver_;
};



class BLINK_PLATFORM_EXPORT NetworkContextClientProxy
    : public NetworkContextClient {
 public:
  using InterfaceType = NetworkContextClient;

  explicit NetworkContextClientProxy(mojo::MessageReceiverWithResponder* receiver);
  
  void OnFileUploadRequested(int32_t process_id, bool async, const WTF::Vector<::base::FilePath>& file_paths, const ::blink::KURL& destination_url, OnFileUploadRequestedCallback callback) final;
  
  void OnCanSendReportingReports(const WTF::Vector<::scoped_refptr<const ::blink::SecurityOrigin>>& origins, OnCanSendReportingReportsCallback callback) final;
  
  void OnCanSendDomainReliabilityUpload(const ::scoped_refptr<const ::blink::SecurityOrigin>& origin, OnCanSendDomainReliabilityUploadCallback callback) final;
  
  void OnGenerateHttpNegotiateAuthToken(const WTF::String& server_auth_token, bool can_delegate, const WTF::String& auth_negotiate_android_account_type, const WTF::String& spn, OnGenerateHttpNegotiateAuthTokenCallback callback) final;
  
  void OnTrustTokenIssuanceDivertedToSystem(::network::mojom::blink::FulfillTrustTokenIssuanceRequestPtr request, OnTrustTokenIssuanceDivertedToSystemCallback callback) final;
  
  void OnCanSendSCTAuditingReport(OnCanSendSCTAuditingReportCallback callback) final;
  
  void OnNewSCTAuditingReportSent() final;

 private:
  mojo::MessageReceiverWithResponder* receiver_;
};



class BLINK_PLATFORM_EXPORT NetworkContextProxy
    : public NetworkContext {
 public:
  using InterfaceType = NetworkContext;

  explicit NetworkContextProxy(mojo::MessageReceiverWithResponder* receiver);
  
  void SetClient(::mojo::PendingRemote<NetworkContextClient> client) final;
  
  void CreateURLLoaderFactory(::mojo::PendingReceiver<::network::mojom::blink::URLLoaderFactory> url_loader_factory, URLLoaderFactoryParamsPtr params) final;
  
  void ResetURLLoaderFactories() final;
  
  void GetCookieManager(::mojo::PendingReceiver<::network::mojom::blink::CookieManager> cookie_manager) final;
  
  void GetRestrictedCookieManager(::mojo::PendingReceiver<::network::mojom::blink::RestrictedCookieManager> restricted_cookie_manager, ::network::mojom::blink::RestrictedCookieManagerRole role, const ::scoped_refptr<const ::blink::SecurityOrigin>& origin, const ::net::IsolationInfo& isolation_info, ::mojo::PendingRemote<::network::mojom::blink::CookieAccessObserver> cookie_observer) final;
  
  void GetTrustTokenQueryAnswerer(::mojo::PendingReceiver<::network::mojom::blink::TrustTokenQueryAnswerer> trust_token_query_answerer, const ::scoped_refptr<const ::blink::SecurityOrigin>& top_frame_origin) final;
  
  void ClearTrustTokenData(ClearDataFilterPtr filter, ClearTrustTokenDataCallback callback) final;
  
  void GetStoredTrustTokenCounts(GetStoredTrustTokenCountsCallback callback) final;
  
  void DeleteStoredTrustTokens(const ::scoped_refptr<const ::blink::SecurityOrigin>& issuer, DeleteStoredTrustTokensCallback callback) final;
  
  void SetBlockTrustTokens(bool block) final;
  
  void ClearNetworkingHistoryBetween(::base::Time start_time, ::base::Time end_time, ClearNetworkingHistoryBetweenCallback callback) final;
  
  void ClearHttpCache(::base::Time start_time, ::base::Time end_time, ClearDataFilterPtr filter, ClearHttpCacheCallback callback) final;
  
  void ComputeHttpCacheSize(::base::Time start_time, ::base::Time end_time, ComputeHttpCacheSizeCallback callback) final;
  
  void NotifyExternalCacheHit(const ::blink::KURL& url, const WTF::String& http_method, ::network::mojom::blink::NetworkIsolationKeyPtr key, bool is_subframe_document_resource, bool include_credentials) final;
  
  void ClearHostCache(ClearDataFilterPtr filter, ClearHostCacheCallback callback) final;
  
  void ClearHttpAuthCache(::base::Time start_time, ::base::Time end_time, ClearHttpAuthCacheCallback callback) final;
  
  void ClearReportingCacheReports(ClearDataFilterPtr filter, ClearReportingCacheReportsCallback callback) final;
  
  void ClearReportingCacheClients(ClearDataFilterPtr filter, ClearReportingCacheClientsCallback callback) final;
  
  void ClearNetworkErrorLogging(ClearDataFilterPtr filter, ClearNetworkErrorLoggingCallback callback) final;
  
  void ClearDomainReliability(ClearDataFilterPtr filter, NetworkContext::DomainReliabilityClearMode mode, ClearDomainReliabilityCallback callback) final;
  
  void SetDocumentReportingEndpoints(const ::base::UnguessableToken& reporting_source, const ::scoped_refptr<const ::blink::SecurityOrigin>& origin, const ::net::IsolationInfo& isolation_info, const WTF::HashMap<WTF::String, WTF::String>& endpoints) final;
  
  void SendReportsAndRemoveSource(const ::base::UnguessableToken& reporting_source) final;
  
  void QueueReport(const WTF::String& type, const WTF::String& group, const ::blink::KURL& url, const absl::optional<::base::UnguessableToken>& reporting_source, ::network::mojom::blink::NetworkIsolationKeyPtr network_isolation_key, const WTF::String& user_agent, ::base::Value::Dict body) final;
  
  void QueueSignedExchangeReport(SignedExchangeReportPtr report, ::network::mojom::blink::NetworkIsolationKeyPtr network_isolation_key) final;
  
  void CloseAllConnections(CloseAllConnectionsCallback callback) final;
  
  void CloseIdleConnections(CloseIdleConnectionsCallback callback) final;
  
  void SetNetworkConditions(const ::base::UnguessableToken& throttling_profile_id, NetworkConditionsPtr conditions) final;
  
  void SetAcceptLanguage(const WTF::String& new_accept_language) final;
  
  void SetEnableReferrers(bool enable_referrers) final;
  
  void SetCTPolicy(CTPolicyPtr ct_policy) final;
  
  void AddExpectCT(const WTF::String& host, ::base::Time expiry, bool enforce, const ::blink::KURL& report_uri, ::network::mojom::blink::NetworkIsolationKeyPtr network_isolation_key, AddExpectCTCallback callback) final;
  
  void SetExpectCTTestReport(const ::blink::KURL& report_uri, SetExpectCTTestReportCallback callback) final;
  
  void GetExpectCTState(const WTF::String& domain, ::network::mojom::blink::NetworkIsolationKeyPtr network_isolation_key, GetExpectCTStateCallback callback) final;
  
  void CreateUDPSocket(::mojo::PendingReceiver<::network::mojom::blink::UDPSocket> receiver, ::mojo::PendingRemote<::network::mojom::blink::UDPSocketListener> listener) final;
  
  void CreateTCPServerSocket(const ::net::IPEndPoint& local_addr, uint32_t backlog, const ::net::MutableNetworkTrafficAnnotationTag& traffic_annotation, ::mojo::PendingReceiver<::network::mojom::blink::TCPServerSocket> socket, CreateTCPServerSocketCallback callback) final;
  
  void CreateTCPConnectedSocket(const absl::optional<::net::IPEndPoint>& local_addr, ::network::mojom::blink::AddressListPtr remote_addr_list, ::network::mojom::blink::TCPConnectedSocketOptionsPtr tcp_connected_socket_options, const ::net::MutableNetworkTrafficAnnotationTag& traffic_annotation, ::mojo::PendingReceiver<::network::mojom::blink::TCPConnectedSocket> socket, ::mojo::PendingRemote<::network::mojom::blink::SocketObserver> observer, CreateTCPConnectedSocketCallback callback) final;
  
  void CreateTCPBoundSocket(const ::net::IPEndPoint& local_addr, const ::net::MutableNetworkTrafficAnnotationTag& traffic_annotation, ::mojo::PendingReceiver<::network::mojom::blink::TCPBoundSocket> socket, CreateTCPBoundSocketCallback callback) final;
  
  void CreateProxyResolvingSocketFactory(::mojo::PendingReceiver<::network::mojom::blink::ProxyResolvingSocketFactory> factory) final;
  
  void LookUpProxyForURL(const ::blink::KURL& url, ::network::mojom::blink::NetworkIsolationKeyPtr network_isolation_key, ::mojo::PendingRemote<::network::mojom::blink::ProxyLookupClient> proxy_lookup_client) final;
  
  void ForceReloadProxyConfig(ForceReloadProxyConfigCallback callback) final;
  
  void ClearBadProxiesCache(ClearBadProxiesCacheCallback callback) final;
  
  void CreateWebSocket(const ::blink::KURL& url, const WTF::Vector<WTF::String>& requested_protocols, const ::net::SiteForCookies& site_for_cookies, const ::net::IsolationInfo& isolation_info, WTF::Vector<::network::mojom::blink::HttpHeaderPtr> additional_headers, int32_t process_id, const ::scoped_refptr<const ::blink::SecurityOrigin>& origin, uint32_t options, const ::net::MutableNetworkTrafficAnnotationTag& traffic_annotation, ::mojo::PendingRemote<::network::mojom::blink::WebSocketHandshakeClient> handshake_client, ::mojo::PendingRemote<::network::mojom::blink::URLLoaderNetworkServiceObserver> url_loader_network_observer, ::mojo::PendingRemote<::network::mojom::blink::WebSocketAuthenticationHandler> auth_handler, ::mojo::PendingRemote<TrustedHeaderClient> header_client, const absl::optional<::base::UnguessableToken>& throttling_profile_id) final;
  
  void CreateWebTransport(const ::blink::KURL& url, const ::scoped_refptr<const ::blink::SecurityOrigin>& origin, ::network::mojom::blink::NetworkIsolationKeyPtr network_isolation_key, WTF::Vector<::network::mojom::blink::WebTransportCertificateFingerprintPtr> fingerprints, ::mojo::PendingRemote<::network::mojom::blink::WebTransportHandshakeClient> handshake_client) final;
  
  void CreateNetLogExporter(::mojo::PendingReceiver<::network::mojom::blink::NetLogExporter> receiver) final;
  
  void PreconnectSockets(uint32_t num_streams, const ::blink::KURL& url, bool allow_credentials, ::network::mojom::blink::NetworkIsolationKeyPtr network_isolation_key) final;
  
  void CreateP2PSocketManager(::network::mojom::blink::NetworkIsolationKeyPtr network_isolation_key, ::mojo::PendingRemote<::network::mojom::blink::P2PTrustedSocketManagerClient> client, ::mojo::PendingReceiver<::network::mojom::blink::P2PTrustedSocketManager> trusted_socket_manager, ::mojo::PendingReceiver<::network::mojom::blink::P2PSocketManager> socket_manager) final;
  
  void CreateMdnsResponder(::mojo::PendingReceiver<::network::mojom::blink::MdnsResponder> responder_receiver) final;
  
  void ResolveHost(::network::mojom::blink::HostPortPairPtr host, ::network::mojom::blink::NetworkIsolationKeyPtr network_isolation_key, ::network::mojom::blink::ResolveHostParametersPtr optional_parameters, ::mojo::PendingRemote<::network::mojom::blink::ResolveHostClient> response_client) final;
  
  void CreateHostResolver(::network::mojom::blink::DnsConfigOverridesPtr config_overrides, ::mojo::PendingReceiver<::network::mojom::blink::HostResolver> host_resolver) final;
  
  void VerifyCertForSignedExchange(::network::mojom::blink::X509CertificatePtr certificate, const ::blink::KURL& url, ::network::mojom::blink::NetworkIsolationKeyPtr network_isolation_key, const WTF::String& ocsp_response, const WTF::String& sct_list, VerifyCertForSignedExchangeCallback callback) final;
  
  void AddHSTS(const WTF::String& host, ::base::Time expiry, bool include_subdomains, AddHSTSCallback callback) final;
  
  void IsHSTSActiveForHost(const WTF::String& host, IsHSTSActiveForHostCallback callback) final;
  
  void GetHSTSState(const WTF::String& domain, GetHSTSStateCallback callback) final;
  
  void SetCorsOriginAccessListsForOrigin(const ::scoped_refptr<const ::blink::SecurityOrigin>& source_origin, WTF::Vector<::network::mojom::blink::CorsOriginPatternPtr> allow_patterns, WTF::Vector<::network::mojom::blink::CorsOriginPatternPtr> block_patterns, SetCorsOriginAccessListsForOriginCallback callback) final;
  
  void DeleteDynamicDataForHost(const WTF::String& host, DeleteDynamicDataForHostCallback callback) final;
  
  void SetSplitAuthCacheByNetworkIsolationKey(bool split_auth_cache_by_network_isolation_key) final;
  
  void SaveHttpAuthCacheProxyEntries(SaveHttpAuthCacheProxyEntriesCallback callback) final;
  
  void LoadHttpAuthCacheProxyEntries(const ::base::UnguessableToken& cache_key, LoadHttpAuthCacheProxyEntriesCallback callback) final;
  
  void AddAuthCacheEntry(const ::net::AuthChallengeInfo& challenge, ::network::mojom::blink::NetworkIsolationKeyPtr network_isolation_key, ::network::mojom::blink::AuthCredentialsPtr credentials, AddAuthCacheEntryCallback callback) final;
  
  void SetCorsNonWildcardRequestHeadersSupport(bool value) final;
  
  void LookupServerBasicAuthCredentials(const ::blink::KURL& url, ::network::mojom::blink::NetworkIsolationKeyPtr network_isolation_key, LookupServerBasicAuthCredentialsCallback callback) final;
  
  bool EnableStaticKeyPinningForTesting() final;
  
  void EnableStaticKeyPinningForTesting(EnableStaticKeyPinningForTestingCallback callback) final;
  
  void VerifyCertificateForTesting(::network::mojom::blink::X509CertificatePtr certificate, const WTF::String& hostname, const WTF::String& ocsp_response, const WTF::String& sct_list, VerifyCertificateForTestingCallback callback) final;
  
  bool AddDomainReliabilityContextForTesting(const ::scoped_refptr<const ::blink::SecurityOrigin>& origin, const ::blink::KURL& upload_url) final;
  
  void AddDomainReliabilityContextForTesting(const ::scoped_refptr<const ::blink::SecurityOrigin>& origin, const ::blink::KURL& upload_url, AddDomainReliabilityContextForTestingCallback callback) final;
  
  bool ForceDomainReliabilityUploadsForTesting() final;
  
  void ForceDomainReliabilityUploadsForTesting(ForceDomainReliabilityUploadsForTestingCallback callback) final;
  
  void SetCTLogListAlwaysTimelyForTesting() final;
  
  void SetSCTAuditingMode(SCTAuditingMode mode) final;
  
  void AddReportingApiObserver(::mojo::PendingRemote<::network::mojom::blink::ReportingApiObserver> observer) final;

 private:
  mojo::MessageReceiverWithResponder* receiver_;
};
class BLINK_PLATFORM_EXPORT CustomProxyConnectionObserverStubDispatch {
 public:
  static bool Accept(CustomProxyConnectionObserver* impl, mojo::Message* message);
  static bool AcceptWithResponder(
      CustomProxyConnectionObserver* impl,
      mojo::Message* message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder);
};

template <typename ImplRefTraits =
              mojo::RawPtrImplRefTraits<CustomProxyConnectionObserver>>
class CustomProxyConnectionObserverStub
    : public mojo::MessageReceiverWithResponderStatus {
 public:
  using ImplPointerType = typename ImplRefTraits::PointerType;

  CustomProxyConnectionObserverStub() = default;
  ~CustomProxyConnectionObserverStub() override = default;

  void set_sink(ImplPointerType sink) { sink_ = std::move(sink); }
  ImplPointerType& sink() { return sink_; }

  bool Accept(mojo::Message* message) override {
    if (ImplRefTraits::IsNull(sink_))
      return false;
    return CustomProxyConnectionObserverStubDispatch::Accept(
        ImplRefTraits::GetRawPointer(&sink_), message);
  }

  bool AcceptWithResponder(
      mojo::Message* message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) override {
    if (ImplRefTraits::IsNull(sink_))
      return false;
    return CustomProxyConnectionObserverStubDispatch::AcceptWithResponder(
        ImplRefTraits::GetRawPointer(&sink_), message, std::move(responder));
  }

 private:
  ImplPointerType sink_;
};
class BLINK_PLATFORM_EXPORT CustomProxyConfigClientStubDispatch {
 public:
  static bool Accept(CustomProxyConfigClient* impl, mojo::Message* message);
  static bool AcceptWithResponder(
      CustomProxyConfigClient* impl,
      mojo::Message* message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder);
};

template <typename ImplRefTraits =
              mojo::RawPtrImplRefTraits<CustomProxyConfigClient>>
class CustomProxyConfigClientStub
    : public mojo::MessageReceiverWithResponderStatus {
 public:
  using ImplPointerType = typename ImplRefTraits::PointerType;

  CustomProxyConfigClientStub() = default;
  ~CustomProxyConfigClientStub() override = default;

  void set_sink(ImplPointerType sink) { sink_ = std::move(sink); }
  ImplPointerType& sink() { return sink_; }

  bool Accept(mojo::Message* message) override {
    if (ImplRefTraits::IsNull(sink_))
      return false;
    return CustomProxyConfigClientStubDispatch::Accept(
        ImplRefTraits::GetRawPointer(&sink_), message);
  }

  bool AcceptWithResponder(
      mojo::Message* message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) override {
    if (ImplRefTraits::IsNull(sink_))
      return false;
    return CustomProxyConfigClientStubDispatch::AcceptWithResponder(
        ImplRefTraits::GetRawPointer(&sink_), message, std::move(responder));
  }

 private:
  ImplPointerType sink_;
};
class BLINK_PLATFORM_EXPORT TrustedHeaderClientStubDispatch {
 public:
  static bool Accept(TrustedHeaderClient* impl, mojo::Message* message);
  static bool AcceptWithResponder(
      TrustedHeaderClient* impl,
      mojo::Message* message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder);
};

template <typename ImplRefTraits =
              mojo::RawPtrImplRefTraits<TrustedHeaderClient>>
class TrustedHeaderClientStub
    : public mojo::MessageReceiverWithResponderStatus {
 public:
  using ImplPointerType = typename ImplRefTraits::PointerType;

  TrustedHeaderClientStub() = default;
  ~TrustedHeaderClientStub() override = default;

  void set_sink(ImplPointerType sink) { sink_ = std::move(sink); }
  ImplPointerType& sink() { return sink_; }

  bool Accept(mojo::Message* message) override {
    if (ImplRefTraits::IsNull(sink_))
      return false;
    return TrustedHeaderClientStubDispatch::Accept(
        ImplRefTraits::GetRawPointer(&sink_), message);
  }

  bool AcceptWithResponder(
      mojo::Message* message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) override {
    if (ImplRefTraits::IsNull(sink_))
      return false;
    return TrustedHeaderClientStubDispatch::AcceptWithResponder(
        ImplRefTraits::GetRawPointer(&sink_), message, std::move(responder));
  }

 private:
  ImplPointerType sink_;
};
class BLINK_PLATFORM_EXPORT TrustedURLLoaderHeaderClientStubDispatch {
 public:
  static bool Accept(TrustedURLLoaderHeaderClient* impl, mojo::Message* message);
  static bool AcceptWithResponder(
      TrustedURLLoaderHeaderClient* impl,
      mojo::Message* message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder);
};

template <typename ImplRefTraits =
              mojo::RawPtrImplRefTraits<TrustedURLLoaderHeaderClient>>
class TrustedURLLoaderHeaderClientStub
    : public mojo::MessageReceiverWithResponderStatus {
 public:
  using ImplPointerType = typename ImplRefTraits::PointerType;

  TrustedURLLoaderHeaderClientStub() = default;
  ~TrustedURLLoaderHeaderClientStub() override = default;

  void set_sink(ImplPointerType sink) { sink_ = std::move(sink); }
  ImplPointerType& sink() { return sink_; }

  bool Accept(mojo::Message* message) override {
    if (ImplRefTraits::IsNull(sink_))
      return false;
    return TrustedURLLoaderHeaderClientStubDispatch::Accept(
        ImplRefTraits::GetRawPointer(&sink_), message);
  }

  bool AcceptWithResponder(
      mojo::Message* message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) override {
    if (ImplRefTraits::IsNull(sink_))
      return false;
    return TrustedURLLoaderHeaderClientStubDispatch::AcceptWithResponder(
        ImplRefTraits::GetRawPointer(&sink_), message, std::move(responder));
  }

 private:
  ImplPointerType sink_;
};
class BLINK_PLATFORM_EXPORT NetworkContextClientStubDispatch {
 public:
  static bool Accept(NetworkContextClient* impl, mojo::Message* message);
  static bool AcceptWithResponder(
      NetworkContextClient* impl,
      mojo::Message* message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder);
};

template <typename ImplRefTraits =
              mojo::RawPtrImplRefTraits<NetworkContextClient>>
class NetworkContextClientStub
    : public mojo::MessageReceiverWithResponderStatus {
 public:
  using ImplPointerType = typename ImplRefTraits::PointerType;

  NetworkContextClientStub() = default;
  ~NetworkContextClientStub() override = default;

  void set_sink(ImplPointerType sink) { sink_ = std::move(sink); }
  ImplPointerType& sink() { return sink_; }

  bool Accept(mojo::Message* message) override {
    if (ImplRefTraits::IsNull(sink_))
      return false;
    return NetworkContextClientStubDispatch::Accept(
        ImplRefTraits::GetRawPointer(&sink_), message);
  }

  bool AcceptWithResponder(
      mojo::Message* message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) override {
    if (ImplRefTraits::IsNull(sink_))
      return false;
    return NetworkContextClientStubDispatch::AcceptWithResponder(
        ImplRefTraits::GetRawPointer(&sink_), message, std::move(responder));
  }

 private:
  ImplPointerType sink_;
};
class BLINK_PLATFORM_EXPORT NetworkContextStubDispatch {
 public:
  static bool Accept(NetworkContext* impl, mojo::Message* message);
  static bool AcceptWithResponder(
      NetworkContext* impl,
      mojo::Message* message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder);
};

template <typename ImplRefTraits =
              mojo::RawPtrImplRefTraits<NetworkContext>>
class NetworkContextStub
    : public mojo::MessageReceiverWithResponderStatus {
 public:
  using ImplPointerType = typename ImplRefTraits::PointerType;

  NetworkContextStub() = default;
  ~NetworkContextStub() override = default;

  void set_sink(ImplPointerType sink) { sink_ = std::move(sink); }
  ImplPointerType& sink() { return sink_; }

  bool Accept(mojo::Message* message) override {
    if (ImplRefTraits::IsNull(sink_))
      return false;
    return NetworkContextStubDispatch::Accept(
        ImplRefTraits::GetRawPointer(&sink_), message);
  }

  bool AcceptWithResponder(
      mojo::Message* message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) override {
    if (ImplRefTraits::IsNull(sink_))
      return false;
    return NetworkContextStubDispatch::AcceptWithResponder(
        ImplRefTraits::GetRawPointer(&sink_), message, std::move(responder));
  }

 private:
  ImplPointerType sink_;
};
class BLINK_PLATFORM_EXPORT CustomProxyConnectionObserverRequestValidator : public mojo::MessageReceiver {
 public:
  bool Accept(mojo::Message* message) override;
};
class BLINK_PLATFORM_EXPORT CustomProxyConfigClientRequestValidator : public mojo::MessageReceiver {
 public:
  bool Accept(mojo::Message* message) override;
};
class BLINK_PLATFORM_EXPORT TrustedHeaderClientRequestValidator : public mojo::MessageReceiver {
 public:
  bool Accept(mojo::Message* message) override;
};
class BLINK_PLATFORM_EXPORT TrustedURLLoaderHeaderClientRequestValidator : public mojo::MessageReceiver {
 public:
  bool Accept(mojo::Message* message) override;
};
class BLINK_PLATFORM_EXPORT NetworkContextClientRequestValidator : public mojo::MessageReceiver {
 public:
  bool Accept(mojo::Message* message) override;
};
class BLINK_PLATFORM_EXPORT NetworkContextRequestValidator : public mojo::MessageReceiver {
 public:
  bool Accept(mojo::Message* message) override;
};
class BLINK_PLATFORM_EXPORT CustomProxyConfigClientResponseValidator : public mojo::MessageReceiver {
 public:
  bool Accept(mojo::Message* message) override;
};
class BLINK_PLATFORM_EXPORT TrustedHeaderClientResponseValidator : public mojo::MessageReceiver {
 public:
  bool Accept(mojo::Message* message) override;
};
class BLINK_PLATFORM_EXPORT NetworkContextClientResponseValidator : public mojo::MessageReceiver {
 public:
  bool Accept(mojo::Message* message) override;
};
class BLINK_PLATFORM_EXPORT NetworkContextResponseValidator : public mojo::MessageReceiver {
 public:
  bool Accept(mojo::Message* message) override;
};







class BLINK_PLATFORM_EXPORT HttpAuthStaticNetworkContextParams {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<HttpAuthStaticNetworkContextParams, T>::value>;
  using DataView = HttpAuthStaticNetworkContextParamsDataView;
  using Data_ = internal::HttpAuthStaticNetworkContextParams_Data;

  template <typename... Args>
  static HttpAuthStaticNetworkContextParamsPtr New(Args&&... args) {
    return HttpAuthStaticNetworkContextParamsPtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static HttpAuthStaticNetworkContextParamsPtr From(const U& u) {
    return mojo::TypeConverter<HttpAuthStaticNetworkContextParamsPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, HttpAuthStaticNetworkContextParams>::Convert(*this);
  }


  HttpAuthStaticNetworkContextParams();

  explicit HttpAuthStaticNetworkContextParams(
      ::network::mojom::blink::DefaultCredentials allow_default_credentials);


  ~HttpAuthStaticNetworkContextParams();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = HttpAuthStaticNetworkContextParamsPtr>
  HttpAuthStaticNetworkContextParamsPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, HttpAuthStaticNetworkContextParams::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, HttpAuthStaticNetworkContextParams::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  size_t Hash(size_t seed) const;
  template <typename UserType>
  static WTF::Vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        HttpAuthStaticNetworkContextParams::DataView, WTF::Vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        HttpAuthStaticNetworkContextParams::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::HttpAuthStaticNetworkContextParams_UnserializedMessageContext<
            UserType, HttpAuthStaticNetworkContextParams::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<HttpAuthStaticNetworkContextParams::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const WTF::Vector<uint8_t>& input,
                          UserType* output) {
    return HttpAuthStaticNetworkContextParams::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::HttpAuthStaticNetworkContextParams_UnserializedMessageContext<
            UserType, HttpAuthStaticNetworkContextParams::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<HttpAuthStaticNetworkContextParams::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
  ::network::mojom::blink::DefaultCredentials allow_default_credentials;

  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, HttpAuthStaticNetworkContextParams::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, HttpAuthStaticNetworkContextParams::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, HttpAuthStaticNetworkContextParams::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, HttpAuthStaticNetworkContextParams::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}















class BLINK_PLATFORM_EXPORT CustomProxyConfig {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<CustomProxyConfig, T>::value>;
  using DataView = CustomProxyConfigDataView;
  using Data_ = internal::CustomProxyConfig_Data;

  template <typename... Args>
  static CustomProxyConfigPtr New(Args&&... args) {
    return CustomProxyConfigPtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static CustomProxyConfigPtr From(const U& u) {
    return mojo::TypeConverter<CustomProxyConfigPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, CustomProxyConfig>::Convert(*this);
  }


  CustomProxyConfig();

  CustomProxyConfig(
      ::network::mojom::blink::ProxyRulesPtr rules,
      bool should_override_existing_config,
      bool allow_non_idempotent_methods,
      const ::net::HttpRequestHeaders& connect_tunnel_headers);

CustomProxyConfig(const CustomProxyConfig&) = delete;
CustomProxyConfig& operator=(const CustomProxyConfig&) = delete;

  ~CustomProxyConfig();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = CustomProxyConfigPtr>
  CustomProxyConfigPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, CustomProxyConfig::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, CustomProxyConfig::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  template <typename UserType>
  static WTF::Vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        CustomProxyConfig::DataView, WTF::Vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        CustomProxyConfig::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::CustomProxyConfig_UnserializedMessageContext<
            UserType, CustomProxyConfig::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<CustomProxyConfig::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const WTF::Vector<uint8_t>& input,
                          UserType* output) {
    return CustomProxyConfig::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::CustomProxyConfig_UnserializedMessageContext<
            UserType, CustomProxyConfig::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<CustomProxyConfig::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
  ::network::mojom::blink::ProxyRulesPtr rules;
  
  bool should_override_existing_config;
  
  bool allow_non_idempotent_methods;
  
  ::net::HttpRequestHeaders connect_tunnel_headers;

  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, CustomProxyConfig::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, CustomProxyConfig::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, CustomProxyConfig::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, CustomProxyConfig::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





class BLINK_PLATFORM_EXPORT CertVerifierServiceRemoteParams {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<CertVerifierServiceRemoteParams, T>::value>;
  using DataView = CertVerifierServiceRemoteParamsDataView;
  using Data_ = internal::CertVerifierServiceRemoteParams_Data;

  template <typename... Args>
  static CertVerifierServiceRemoteParamsPtr New(Args&&... args) {
    return CertVerifierServiceRemoteParamsPtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static CertVerifierServiceRemoteParamsPtr From(const U& u) {
    return mojo::TypeConverter<CertVerifierServiceRemoteParamsPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, CertVerifierServiceRemoteParams>::Convert(*this);
  }


  CertVerifierServiceRemoteParams();

  explicit CertVerifierServiceRemoteParams(
      ::mojo::PendingRemote<::cert_verifier::mojom::blink::CertVerifierService> cert_verifier_service);

CertVerifierServiceRemoteParams(const CertVerifierServiceRemoteParams&) = delete;
CertVerifierServiceRemoteParams& operator=(const CertVerifierServiceRemoteParams&) = delete;

  ~CertVerifierServiceRemoteParams();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = CertVerifierServiceRemoteParamsPtr>
  CertVerifierServiceRemoteParamsPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, CertVerifierServiceRemoteParams::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, CertVerifierServiceRemoteParams::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        CertVerifierServiceRemoteParams::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::CertVerifierServiceRemoteParams_UnserializedMessageContext<
            UserType, CertVerifierServiceRemoteParams::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<CertVerifierServiceRemoteParams::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const WTF::Vector<uint8_t>& input,
                          UserType* output) {
    return CertVerifierServiceRemoteParams::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::CertVerifierServiceRemoteParams_UnserializedMessageContext<
            UserType, CertVerifierServiceRemoteParams::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<CertVerifierServiceRemoteParams::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
  ::mojo::PendingRemote<::cert_verifier::mojom::blink::CertVerifierService> cert_verifier_service;

  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, CertVerifierServiceRemoteParams::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, CertVerifierServiceRemoteParams::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, CertVerifierServiceRemoteParams::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, CertVerifierServiceRemoteParams::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}






class BLINK_PLATFORM_EXPORT CTPolicy {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<CTPolicy, T>::value>;
  using DataView = CTPolicyDataView;
  using Data_ = internal::CTPolicy_Data;

  template <typename... Args>
  static CTPolicyPtr New(Args&&... args) {
    return CTPolicyPtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static CTPolicyPtr From(const U& u) {
    return mojo::TypeConverter<CTPolicyPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, CTPolicy>::Convert(*this);
  }


  CTPolicy();

  CTPolicy(
      WTF::Vector<WTF::String> required_hosts,
      WTF::Vector<WTF::String> excluded_hosts,
      WTF::Vector<WTF::String> excluded_spkis,
      WTF::Vector<WTF::String> excluded_legacy_spkis);


  ~CTPolicy();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = CTPolicyPtr>
  CTPolicyPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, CTPolicy::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, CTPolicy::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  template <typename UserType>
  static WTF::Vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        CTPolicy::DataView, WTF::Vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        CTPolicy::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::CTPolicy_UnserializedMessageContext<
            UserType, CTPolicy::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<CTPolicy::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const WTF::Vector<uint8_t>& input,
                          UserType* output) {
    return CTPolicy::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::CTPolicy_UnserializedMessageContext<
            UserType, CTPolicy::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<CTPolicy::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
  WTF::Vector<WTF::String> required_hosts;
  
  WTF::Vector<WTF::String> excluded_hosts;
  
  WTF::Vector<WTF::String> excluded_spkis;
  
  WTF::Vector<WTF::String> excluded_legacy_spkis;

  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, CTPolicy::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, CTPolicy::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, CTPolicy::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, CTPolicy::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





class BLINK_PLATFORM_EXPORT NetworkContextFilePaths {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<NetworkContextFilePaths, T>::value>;
  using DataView = NetworkContextFilePathsDataView;
  using Data_ = internal::NetworkContextFilePaths_Data;

  template <typename... Args>
  static NetworkContextFilePathsPtr New(Args&&... args) {
    return NetworkContextFilePathsPtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static NetworkContextFilePathsPtr From(const U& u) {
    return mojo::TypeConverter<NetworkContextFilePathsPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, NetworkContextFilePaths>::Convert(*this);
  }


  NetworkContextFilePaths();

  NetworkContextFilePaths(
      ::network::mojom::blink::TransferableDirectoryPtr data_directory,
      const absl::optional<::base::FilePath>& unsandboxed_data_path,
      const absl::optional<::base::FilePath>& cookie_database_name,
      const absl::optional<::base::FilePath>& trust_token_database_name,
      const absl::optional<::base::FilePath>& http_server_properties_file_name,
      const absl::optional<::base::FilePath>& transport_security_persister_file_name,
      const absl::optional<::base::FilePath>& reporting_and_nel_store_database_name,
      const absl::optional<::base::FilePath>& sct_auditing_pending_reports_file_name,
      bool trigger_migration);

NetworkContextFilePaths(const NetworkContextFilePaths&) = delete;
NetworkContextFilePaths& operator=(const NetworkContextFilePaths&) = delete;

  ~NetworkContextFilePaths();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = NetworkContextFilePathsPtr>
  NetworkContextFilePathsPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, NetworkContextFilePaths::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, NetworkContextFilePaths::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        NetworkContextFilePaths::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::NetworkContextFilePaths_UnserializedMessageContext<
            UserType, NetworkContextFilePaths::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<NetworkContextFilePaths::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const WTF::Vector<uint8_t>& input,
                          UserType* output) {
    return NetworkContextFilePaths::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::NetworkContextFilePaths_UnserializedMessageContext<
            UserType, NetworkContextFilePaths::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<NetworkContextFilePaths::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
  ::network::mojom::blink::TransferableDirectoryPtr data_directory;
  
  absl::optional<::base::FilePath> unsandboxed_data_path;
  
  absl::optional<::base::FilePath> cookie_database_name;
  
  absl::optional<::base::FilePath> trust_token_database_name;
  
  absl::optional<::base::FilePath> http_server_properties_file_name;
  
  absl::optional<::base::FilePath> transport_security_persister_file_name;
  
  absl::optional<::base::FilePath> reporting_and_nel_store_database_name;
  
  absl::optional<::base::FilePath> sct_auditing_pending_reports_file_name;
  
  bool trigger_migration;

  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, NetworkContextFilePaths::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, NetworkContextFilePaths::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, NetworkContextFilePaths::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, NetworkContextFilePaths::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





class BLINK_PLATFORM_EXPORT NetworkContextParams {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<NetworkContextParams, T>::value>;
  using DataView = NetworkContextParamsDataView;
  using Data_ = internal::NetworkContextParams_Data;

  template <typename... Args>
  static NetworkContextParamsPtr New(Args&&... args) {
    return NetworkContextParamsPtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static NetworkContextParamsPtr From(const U& u) {
    return mojo::TypeConverter<NetworkContextParamsPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, NetworkContextParams>::Convert(*this);
  }


  NetworkContextParams();

  NetworkContextParams(
      const WTF::String& user_agent,
      const WTF::String& accept_language,
      bool enable_brotli,
      const WTF::String& quic_user_agent_id,
      bool enable_referrers,
      bool validate_referrer_policy_on_initial_request,
      ::mojo::PendingRemote<::proxy_resolver::mojom::blink::ProxyResolverFactory> proxy_resolver_factory,
      bool enable_encrypted_cookies,
      bool restore_old_session_cookies,
      bool persist_session_cookies,
      bool http_cache_enabled,
      int32_t http_cache_max_size,
      ::network::mojom::blink::TransferableDirectoryPtr http_cache_directory,
      ::mojo::PendingRemote<::network::mojom::blink::HttpCacheBackendFileOperationsFactory> http_cache_file_operations_factory,
      bool check_clear_text_permitted,
      bool disable_idle_sockets_close_on_memory_pressure,
      ::network::mojom::blink::SSLConfigPtr initial_ssl_config,
      ::mojo::PendingReceiver<::network::mojom::blink::SSLConfigClient> ssl_config_client_receiver,
      ::network::mojom::blink::ProxyConfigWithAnnotationPtr initial_proxy_config,
      ::mojo::PendingReceiver<::network::mojom::blink::ProxyConfigClient> proxy_config_client_receiver,
      CustomProxyConfigPtr initial_custom_proxy_config,
      ::mojo::PendingReceiver<CustomProxyConfigClient> custom_proxy_config_client_receiver,
      ::mojo::PendingRemote<CustomProxyConnectionObserver> custom_proxy_connection_observer_remote,
      ::mojo::PendingRemote<::network::mojom::blink::ProxyConfigPollerClient> proxy_config_poller_client,
      ::mojo::PendingRemote<::network::mojom::blink::ProxyErrorClient> proxy_error_client,
      ::mojo::PendingRemote<::network::mojom::blink::SocketBroker> socket_broker,
      bool pac_quick_check_enabled,
      bool enable_certificate_reporting,
      bool enforce_chrome_ct_policy,
      bool enable_expect_ct_reporting,
      SCTAuditingMode sct_auditing_mode,
      CTPolicyPtr ct_policy,
      CertVerifierServiceRemoteParamsPtr cert_verifier_params,
      ::network::mojom::blink::CookieManagerParamsPtr cookie_manager_params,
      ::mojo::PendingReceiver<::network::mojom::blink::CookieManager> cookie_manager,
      bool enable_domain_reliability,
      const WTF::String& domain_reliability_upload_reporter,
      bool discard_domain_reliablity_uploads,
      absl::optional<::base::TimeDelta> reporting_delivery_interval,
      bool skip_reporting_send_permission_check,
      WTF::Vector<::network::mojom::blink::CorsOriginAccessPatternsPtr> cors_origin_access_list,
      WTF::Vector<WTF::String> cors_exempt_header_list,
      bool allow_any_cors_exempt_header_for_browser,
      WTF::Vector<WTF::String> hsts_policy_bypass_list,
      HttpAuthStaticNetworkContextParamsPtr http_auth_static_network_context_params,
      bool reset_http_cache_backend,
      bool split_auth_cache_by_network_isolation_key,
      bool require_network_isolation_key,
      NetworkContextFilePathsPtr file_paths,
      bool block_trust_tokens,
      ::network::mojom::blink::FirstPartySetsAccessDelegateParamsPtr first_party_sets_access_delegate_params,
      ::mojo::PendingReceiver<::network::mojom::blink::FirstPartySetsAccessDelegate> first_party_sets_access_delegate_receiver);

NetworkContextParams(const NetworkContextParams&) = delete;
NetworkContextParams& operator=(const NetworkContextParams&) = delete;

  ~NetworkContextParams();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = NetworkContextParamsPtr>
  NetworkContextParamsPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, NetworkContextParams::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, NetworkContextParams::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        NetworkContextParams::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::NetworkContextParams_UnserializedMessageContext<
            UserType, NetworkContextParams::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<NetworkContextParams::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const WTF::Vector<uint8_t>& input,
                          UserType* output) {
    return NetworkContextParams::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::NetworkContextParams_UnserializedMessageContext<
            UserType, NetworkContextParams::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<NetworkContextParams::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
  WTF::String user_agent;
  
  WTF::String accept_language;
  
  bool enable_brotli;
  
  WTF::String quic_user_agent_id;
  
  bool enable_referrers;
  
  bool validate_referrer_policy_on_initial_request;
  
  ::mojo::PendingRemote<::proxy_resolver::mojom::blink::ProxyResolverFactory> proxy_resolver_factory;
  
  bool enable_encrypted_cookies;
  
  bool restore_old_session_cookies;
  
  bool persist_session_cookies;
  
  bool http_cache_enabled;
  
  int32_t http_cache_max_size;
  
  ::network::mojom::blink::TransferableDirectoryPtr http_cache_directory;
  
  ::mojo::PendingRemote<::network::mojom::blink::HttpCacheBackendFileOperationsFactory> http_cache_file_operations_factory;
  
  bool check_clear_text_permitted;
  
  bool disable_idle_sockets_close_on_memory_pressure;
  
  ::network::mojom::blink::SSLConfigPtr initial_ssl_config;
  
  ::mojo::PendingReceiver<::network::mojom::blink::SSLConfigClient> ssl_config_client_receiver;
  
  ::network::mojom::blink::ProxyConfigWithAnnotationPtr initial_proxy_config;
  
  ::mojo::PendingReceiver<::network::mojom::blink::ProxyConfigClient> proxy_config_client_receiver;
  
  CustomProxyConfigPtr initial_custom_proxy_config;
  
  ::mojo::PendingReceiver<CustomProxyConfigClient> custom_proxy_config_client_receiver;
  
  ::mojo::PendingRemote<CustomProxyConnectionObserver> custom_proxy_connection_observer_remote;
  
  ::mojo::PendingRemote<::network::mojom::blink::ProxyConfigPollerClient> proxy_config_poller_client;
  
  ::mojo::PendingRemote<::network::mojom::blink::ProxyErrorClient> proxy_error_client;
  
  ::mojo::PendingRemote<::network::mojom::blink::SocketBroker> socket_broker;
  
  bool pac_quick_check_enabled;
  
  bool enable_certificate_reporting;
  
  bool enforce_chrome_ct_policy;
  
  bool enable_expect_ct_reporting;
  
  SCTAuditingMode sct_auditing_mode;
  
  CTPolicyPtr ct_policy;
  
  CertVerifierServiceRemoteParamsPtr cert_verifier_params;
  
  ::network::mojom::blink::CookieManagerParamsPtr cookie_manager_params;
  
  ::mojo::PendingReceiver<::network::mojom::blink::CookieManager> cookie_manager;
  
  bool enable_domain_reliability;
  
  WTF::String domain_reliability_upload_reporter;
  
  bool discard_domain_reliablity_uploads;
  
  absl::optional<::base::TimeDelta> reporting_delivery_interval;
  
  bool skip_reporting_send_permission_check;
  
  WTF::Vector<::network::mojom::blink::CorsOriginAccessPatternsPtr> cors_origin_access_list;
  
  WTF::Vector<WTF::String> cors_exempt_header_list;
  
  bool allow_any_cors_exempt_header_for_browser;
  
  WTF::Vector<WTF::String> hsts_policy_bypass_list;
  
  HttpAuthStaticNetworkContextParamsPtr http_auth_static_network_context_params;
  
  bool reset_http_cache_backend;
  
  bool split_auth_cache_by_network_isolation_key;
  
  bool require_network_isolation_key;
  
  NetworkContextFilePathsPtr file_paths;
  
  bool block_trust_tokens;
  
  ::network::mojom::blink::FirstPartySetsAccessDelegateParamsPtr first_party_sets_access_delegate_params;
  
  ::mojo::PendingReceiver<::network::mojom::blink::FirstPartySetsAccessDelegate> first_party_sets_access_delegate_receiver;

  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, NetworkContextParams::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, NetworkContextParams::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, NetworkContextParams::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, NetworkContextParams::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





class BLINK_PLATFORM_EXPORT NetworkConditions {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<NetworkConditions, T>::value>;
  using DataView = NetworkConditionsDataView;
  using Data_ = internal::NetworkConditions_Data;

  template <typename... Args>
  static NetworkConditionsPtr New(Args&&... args) {
    return NetworkConditionsPtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static NetworkConditionsPtr From(const U& u) {
    return mojo::TypeConverter<NetworkConditionsPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, NetworkConditions>::Convert(*this);
  }


  NetworkConditions();

  NetworkConditions(
      bool offline,
      ::base::TimeDelta latency,
      double download_throughput,
      double upload_throughput);


  ~NetworkConditions();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = NetworkConditionsPtr>
  NetworkConditionsPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, NetworkConditions::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, NetworkConditions::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  template <typename UserType>
  static WTF::Vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        NetworkConditions::DataView, WTF::Vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        NetworkConditions::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::NetworkConditions_UnserializedMessageContext<
            UserType, NetworkConditions::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<NetworkConditions::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const WTF::Vector<uint8_t>& input,
                          UserType* output) {
    return NetworkConditions::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::NetworkConditions_UnserializedMessageContext<
            UserType, NetworkConditions::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<NetworkConditions::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
  bool offline;
  
  ::base::TimeDelta latency;
  
  double download_throughput;
  
  double upload_throughput;

  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, NetworkConditions::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, NetworkConditions::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, NetworkConditions::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, NetworkConditions::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





class BLINK_PLATFORM_EXPORT ClearDataFilter {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<ClearDataFilter, T>::value>;
  using DataView = ClearDataFilterDataView;
  using Data_ = internal::ClearDataFilter_Data;
  using Type = ClearDataFilter_Type;

  template <typename... Args>
  static ClearDataFilterPtr New(Args&&... args) {
    return ClearDataFilterPtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static ClearDataFilterPtr From(const U& u) {
    return mojo::TypeConverter<ClearDataFilterPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, ClearDataFilter>::Convert(*this);
  }


  ClearDataFilter();

  ClearDataFilter(
      ClearDataFilter::Type type,
      WTF::Vector<WTF::String> domains,
      WTF::Vector<::scoped_refptr<const ::blink::SecurityOrigin>> origins);


  ~ClearDataFilter();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = ClearDataFilterPtr>
  ClearDataFilterPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, ClearDataFilter::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, ClearDataFilter::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  template <typename UserType>
  static WTF::Vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        ClearDataFilter::DataView, WTF::Vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        ClearDataFilter::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::ClearDataFilter_UnserializedMessageContext<
            UserType, ClearDataFilter::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<ClearDataFilter::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const WTF::Vector<uint8_t>& input,
                          UserType* output) {
    return ClearDataFilter::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::ClearDataFilter_UnserializedMessageContext<
            UserType, ClearDataFilter::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<ClearDataFilter::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
  ClearDataFilter::Type type;
  
  WTF::Vector<WTF::String> domains;
  
  WTF::Vector<::scoped_refptr<const ::blink::SecurityOrigin>> origins;

  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, ClearDataFilter::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, ClearDataFilter::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, ClearDataFilter::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, ClearDataFilter::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





class BLINK_PLATFORM_EXPORT SignedExchangeReport {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<SignedExchangeReport, T>::value>;
  using DataView = SignedExchangeReportDataView;
  using Data_ = internal::SignedExchangeReport_Data;

  template <typename... Args>
  static SignedExchangeReportPtr New(Args&&... args) {
    return SignedExchangeReportPtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static SignedExchangeReportPtr From(const U& u) {
    return mojo::TypeConverter<SignedExchangeReportPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, SignedExchangeReport>::Convert(*this);
  }


  SignedExchangeReport();

  SignedExchangeReport(
      bool success,
      const WTF::String& type,
      const ::blink::KURL& outer_url,
      const ::blink::KURL& inner_url,
      const ::blink::KURL& cert_url,
      const WTF::String& referrer,
      const ::net::IPAddress& server_ip_address,
      const WTF::String& protocol,
      const WTF::String& method,
      int32_t status_code,
      ::base::TimeDelta elapsed_time);


  ~SignedExchangeReport();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = SignedExchangeReportPtr>
  SignedExchangeReportPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, SignedExchangeReport::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, SignedExchangeReport::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  template <typename UserType>
  static WTF::Vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        SignedExchangeReport::DataView, WTF::Vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        SignedExchangeReport::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::SignedExchangeReport_UnserializedMessageContext<
            UserType, SignedExchangeReport::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<SignedExchangeReport::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const WTF::Vector<uint8_t>& input,
                          UserType* output) {
    return SignedExchangeReport::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::SignedExchangeReport_UnserializedMessageContext<
            UserType, SignedExchangeReport::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<SignedExchangeReport::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
  bool success;
  
  WTF::String type;
  
  ::blink::KURL outer_url;
  
  ::blink::KURL inner_url;
  
  ::blink::KURL cert_url;
  
  WTF::String referrer;
  
  ::net::IPAddress server_ip_address;
  
  WTF::String protocol;
  
  WTF::String method;
  
  int32_t status_code;
  
  ::base::TimeDelta elapsed_time;

  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, SignedExchangeReport::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, SignedExchangeReport::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, SignedExchangeReport::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, SignedExchangeReport::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





class BLINK_PLATFORM_EXPORT URLLoaderFactoryOverride {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<URLLoaderFactoryOverride, T>::value>;
  using DataView = URLLoaderFactoryOverrideDataView;
  using Data_ = internal::URLLoaderFactoryOverride_Data;

  template <typename... Args>
  static URLLoaderFactoryOverridePtr New(Args&&... args) {
    return URLLoaderFactoryOverridePtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static URLLoaderFactoryOverridePtr From(const U& u) {
    return mojo::TypeConverter<URLLoaderFactoryOverridePtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, URLLoaderFactoryOverride>::Convert(*this);
  }


  URLLoaderFactoryOverride();

  URLLoaderFactoryOverride(
      ::mojo::PendingRemote<::network::mojom::blink::URLLoaderFactory> overriding_factory,
      ::mojo::PendingReceiver<::network::mojom::blink::URLLoaderFactory> overridden_factory_receiver,
      bool skip_cors_enabled_scheme_check);

URLLoaderFactoryOverride(const URLLoaderFactoryOverride&) = delete;
URLLoaderFactoryOverride& operator=(const URLLoaderFactoryOverride&) = delete;

  ~URLLoaderFactoryOverride();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = URLLoaderFactoryOverridePtr>
  URLLoaderFactoryOverridePtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, URLLoaderFactoryOverride::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, URLLoaderFactoryOverride::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        URLLoaderFactoryOverride::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::URLLoaderFactoryOverride_UnserializedMessageContext<
            UserType, URLLoaderFactoryOverride::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<URLLoaderFactoryOverride::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const WTF::Vector<uint8_t>& input,
                          UserType* output) {
    return URLLoaderFactoryOverride::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::URLLoaderFactoryOverride_UnserializedMessageContext<
            UserType, URLLoaderFactoryOverride::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<URLLoaderFactoryOverride::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
  ::mojo::PendingRemote<::network::mojom::blink::URLLoaderFactory> overriding_factory;
  
  ::mojo::PendingReceiver<::network::mojom::blink::URLLoaderFactory> overridden_factory_receiver;
  
  bool skip_cors_enabled_scheme_check;

  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, URLLoaderFactoryOverride::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, URLLoaderFactoryOverride::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, URLLoaderFactoryOverride::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, URLLoaderFactoryOverride::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





class BLINK_PLATFORM_EXPORT URLLoaderFactoryParams {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<URLLoaderFactoryParams, T>::value>;
  using DataView = URLLoaderFactoryParamsDataView;
  using Data_ = internal::URLLoaderFactoryParams_Data;

  template <typename... Args>
  static URLLoaderFactoryParamsPtr New(Args&&... args) {
    return URLLoaderFactoryParamsPtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static URLLoaderFactoryParamsPtr From(const U& u) {
    return mojo::TypeConverter<URLLoaderFactoryParamsPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, URLLoaderFactoryParams>::Convert(*this);
  }


  URLLoaderFactoryParams();

  URLLoaderFactoryParams(
      int32_t process_id,
      const ::scoped_refptr<const ::blink::SecurityOrigin>& request_initiator_origin_lock,
      bool is_corb_enabled,
      bool ignore_isolated_world_origin,
      bool unsafe_non_webby_initiator,
      bool disable_web_security,
      ::mojo::PendingRemote<TrustedURLLoaderHeaderClient> header_client,
      const ::net::IsolationInfo& isolation_info,
      bool disable_secure_dns,
      bool is_trusted,
      bool automatically_assign_isolation_info,
      bool provide_loading_state_updates,
      const absl::optional<::base::UnguessableToken>& top_frame_id,
      URLLoaderFactoryOverridePtr factory_override,
      ::network::mojom::blink::ClientSecurityStatePtr client_security_state,
      ::mojo::PendingRemote<::network::mojom::blink::CrossOriginEmbedderPolicyReporter> coep_reporter,
      ::mojo::PendingRemote<::network::mojom::blink::CookieAccessObserver> cookie_observer,
      ::mojo::PendingRemote<::network::mojom::blink::URLLoaderNetworkServiceObserver> url_loader_network_observer,
      ::mojo::PendingRemote<::network::mojom::blink::DevToolsObserver> devtools_observer,
      TrustTokenRedemptionPolicy trust_token_redemption_policy,
      const WTF::String& debug_tag);

URLLoaderFactoryParams(const URLLoaderFactoryParams&) = delete;
URLLoaderFactoryParams& operator=(const URLLoaderFactoryParams&) = delete;

  ~URLLoaderFactoryParams();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = URLLoaderFactoryParamsPtr>
  URLLoaderFactoryParamsPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, URLLoaderFactoryParams::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, URLLoaderFactoryParams::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        URLLoaderFactoryParams::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::URLLoaderFactoryParams_UnserializedMessageContext<
            UserType, URLLoaderFactoryParams::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<URLLoaderFactoryParams::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const WTF::Vector<uint8_t>& input,
                          UserType* output) {
    return URLLoaderFactoryParams::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::URLLoaderFactoryParams_UnserializedMessageContext<
            UserType, URLLoaderFactoryParams::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<URLLoaderFactoryParams::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
  int32_t process_id;
  
  ::scoped_refptr<const ::blink::SecurityOrigin> request_initiator_origin_lock;
  
  bool is_corb_enabled;
  
  bool ignore_isolated_world_origin;
  
  bool unsafe_non_webby_initiator;
  
  bool disable_web_security;
  
  ::mojo::PendingRemote<TrustedURLLoaderHeaderClient> header_client;
  
  ::net::IsolationInfo isolation_info;
  
  bool disable_secure_dns;
  
  bool is_trusted;
  
  bool automatically_assign_isolation_info;
  
  bool provide_loading_state_updates;
  
  absl::optional<::base::UnguessableToken> top_frame_id;
  
  URLLoaderFactoryOverridePtr factory_override;
  
  ::network::mojom::blink::ClientSecurityStatePtr client_security_state;
  
  ::mojo::PendingRemote<::network::mojom::blink::CrossOriginEmbedderPolicyReporter> coep_reporter;
  
  ::mojo::PendingRemote<::network::mojom::blink::CookieAccessObserver> cookie_observer;
  
  ::mojo::PendingRemote<::network::mojom::blink::URLLoaderNetworkServiceObserver> url_loader_network_observer;
  
  ::mojo::PendingRemote<::network::mojom::blink::DevToolsObserver> devtools_observer;
  
  TrustTokenRedemptionPolicy trust_token_redemption_policy;
  
  WTF::String debug_tag;

  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, URLLoaderFactoryParams::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, URLLoaderFactoryParams::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, URLLoaderFactoryParams::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, URLLoaderFactoryParams::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}

template <typename StructPtrType>
CustomProxyConfigPtr CustomProxyConfig::Clone() const {
  return New(
      mojo::Clone(rules),
      mojo::Clone(should_override_existing_config),
      mojo::Clone(allow_non_idempotent_methods),
      mojo::Clone(connect_tunnel_headers)
  );
}

template <typename T, CustomProxyConfig::EnableIfSame<T>*>
bool CustomProxyConfig::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->rules, other_struct.rules))
    return false;
  if (!mojo::Equals(this->should_override_existing_config, other_struct.should_override_existing_config))
    return false;
  if (!mojo::Equals(this->allow_non_idempotent_methods, other_struct.allow_non_idempotent_methods))
    return false;
  if (!mojo::Equals(this->connect_tunnel_headers, other_struct.connect_tunnel_headers))
    return false;
  return true;
}

template <typename T, CustomProxyConfig::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.rules < rhs.rules)
    return true;
  if (rhs.rules < lhs.rules)
    return false;
  if (lhs.should_override_existing_config < rhs.should_override_existing_config)
    return true;
  if (rhs.should_override_existing_config < lhs.should_override_existing_config)
    return false;
  if (lhs.allow_non_idempotent_methods < rhs.allow_non_idempotent_methods)
    return true;
  if (rhs.allow_non_idempotent_methods < lhs.allow_non_idempotent_methods)
    return false;
  if (lhs.connect_tunnel_headers < rhs.connect_tunnel_headers)
    return true;
  if (rhs.connect_tunnel_headers < lhs.connect_tunnel_headers)
    return false;
  return false;
}
template <typename StructPtrType>
CertVerifierServiceRemoteParamsPtr CertVerifierServiceRemoteParams::Clone() const {
  return New(
      mojo::Clone(cert_verifier_service)
  );
}

template <typename T, CertVerifierServiceRemoteParams::EnableIfSame<T>*>
bool CertVerifierServiceRemoteParams::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->cert_verifier_service, other_struct.cert_verifier_service))
    return false;
  return true;
}

template <typename T, CertVerifierServiceRemoteParams::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.cert_verifier_service < rhs.cert_verifier_service)
    return true;
  if (rhs.cert_verifier_service < lhs.cert_verifier_service)
    return false;
  return false;
}
template <typename StructPtrType>
HttpAuthStaticNetworkContextParamsPtr HttpAuthStaticNetworkContextParams::Clone() const {
  return New(
      mojo::Clone(allow_default_credentials)
  );
}

template <typename T, HttpAuthStaticNetworkContextParams::EnableIfSame<T>*>
bool HttpAuthStaticNetworkContextParams::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->allow_default_credentials, other_struct.allow_default_credentials))
    return false;
  return true;
}

template <typename T, HttpAuthStaticNetworkContextParams::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.allow_default_credentials < rhs.allow_default_credentials)
    return true;
  if (rhs.allow_default_credentials < lhs.allow_default_credentials)
    return false;
  return false;
}
template <typename StructPtrType>
CTPolicyPtr CTPolicy::Clone() const {
  return New(
      mojo::Clone(required_hosts),
      mojo::Clone(excluded_hosts),
      mojo::Clone(excluded_spkis),
      mojo::Clone(excluded_legacy_spkis)
  );
}

template <typename T, CTPolicy::EnableIfSame<T>*>
bool CTPolicy::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->required_hosts, other_struct.required_hosts))
    return false;
  if (!mojo::Equals(this->excluded_hosts, other_struct.excluded_hosts))
    return false;
  if (!mojo::Equals(this->excluded_spkis, other_struct.excluded_spkis))
    return false;
  if (!mojo::Equals(this->excluded_legacy_spkis, other_struct.excluded_legacy_spkis))
    return false;
  return true;
}

template <typename T, CTPolicy::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.required_hosts < rhs.required_hosts)
    return true;
  if (rhs.required_hosts < lhs.required_hosts)
    return false;
  if (lhs.excluded_hosts < rhs.excluded_hosts)
    return true;
  if (rhs.excluded_hosts < lhs.excluded_hosts)
    return false;
  if (lhs.excluded_spkis < rhs.excluded_spkis)
    return true;
  if (rhs.excluded_spkis < lhs.excluded_spkis)
    return false;
  if (lhs.excluded_legacy_spkis < rhs.excluded_legacy_spkis)
    return true;
  if (rhs.excluded_legacy_spkis < lhs.excluded_legacy_spkis)
    return false;
  return false;
}
template <typename StructPtrType>
NetworkContextFilePathsPtr NetworkContextFilePaths::Clone() const {
  return New(
      mojo::Clone(data_directory),
      mojo::Clone(unsandboxed_data_path),
      mojo::Clone(cookie_database_name),
      mojo::Clone(trust_token_database_name),
      mojo::Clone(http_server_properties_file_name),
      mojo::Clone(transport_security_persister_file_name),
      mojo::Clone(reporting_and_nel_store_database_name),
      mojo::Clone(sct_auditing_pending_reports_file_name),
      mojo::Clone(trigger_migration)
  );
}

template <typename T, NetworkContextFilePaths::EnableIfSame<T>*>
bool NetworkContextFilePaths::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->data_directory, other_struct.data_directory))
    return false;
  if (!mojo::Equals(this->unsandboxed_data_path, other_struct.unsandboxed_data_path))
    return false;
  if (!mojo::Equals(this->cookie_database_name, other_struct.cookie_database_name))
    return false;
  if (!mojo::Equals(this->trust_token_database_name, other_struct.trust_token_database_name))
    return false;
  if (!mojo::Equals(this->http_server_properties_file_name, other_struct.http_server_properties_file_name))
    return false;
  if (!mojo::Equals(this->transport_security_persister_file_name, other_struct.transport_security_persister_file_name))
    return false;
  if (!mojo::Equals(this->reporting_and_nel_store_database_name, other_struct.reporting_and_nel_store_database_name))
    return false;
  if (!mojo::Equals(this->sct_auditing_pending_reports_file_name, other_struct.sct_auditing_pending_reports_file_name))
    return false;
  if (!mojo::Equals(this->trigger_migration, other_struct.trigger_migration))
    return false;
  return true;
}

template <typename T, NetworkContextFilePaths::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.data_directory < rhs.data_directory)
    return true;
  if (rhs.data_directory < lhs.data_directory)
    return false;
  if (lhs.unsandboxed_data_path < rhs.unsandboxed_data_path)
    return true;
  if (rhs.unsandboxed_data_path < lhs.unsandboxed_data_path)
    return false;
  if (lhs.cookie_database_name < rhs.cookie_database_name)
    return true;
  if (rhs.cookie_database_name < lhs.cookie_database_name)
    return false;
  if (lhs.trust_token_database_name < rhs.trust_token_database_name)
    return true;
  if (rhs.trust_token_database_name < lhs.trust_token_database_name)
    return false;
  if (lhs.http_server_properties_file_name < rhs.http_server_properties_file_name)
    return true;
  if (rhs.http_server_properties_file_name < lhs.http_server_properties_file_name)
    return false;
  if (lhs.transport_security_persister_file_name < rhs.transport_security_persister_file_name)
    return true;
  if (rhs.transport_security_persister_file_name < lhs.transport_security_persister_file_name)
    return false;
  if (lhs.reporting_and_nel_store_database_name < rhs.reporting_and_nel_store_database_name)
    return true;
  if (rhs.reporting_and_nel_store_database_name < lhs.reporting_and_nel_store_database_name)
    return false;
  if (lhs.sct_auditing_pending_reports_file_name < rhs.sct_auditing_pending_reports_file_name)
    return true;
  if (rhs.sct_auditing_pending_reports_file_name < lhs.sct_auditing_pending_reports_file_name)
    return false;
  if (lhs.trigger_migration < rhs.trigger_migration)
    return true;
  if (rhs.trigger_migration < lhs.trigger_migration)
    return false;
  return false;
}
template <typename StructPtrType>
NetworkContextParamsPtr NetworkContextParams::Clone() const {
  return New(
      mojo::Clone(user_agent),
      mojo::Clone(accept_language),
      mojo::Clone(enable_brotli),
      mojo::Clone(quic_user_agent_id),
      mojo::Clone(enable_referrers),
      mojo::Clone(validate_referrer_policy_on_initial_request),
      mojo::Clone(proxy_resolver_factory),
      mojo::Clone(enable_encrypted_cookies),
      mojo::Clone(restore_old_session_cookies),
      mojo::Clone(persist_session_cookies),
      mojo::Clone(http_cache_enabled),
      mojo::Clone(http_cache_max_size),
      mojo::Clone(http_cache_directory),
      mojo::Clone(http_cache_file_operations_factory),
      mojo::Clone(check_clear_text_permitted),
      mojo::Clone(disable_idle_sockets_close_on_memory_pressure),
      mojo::Clone(initial_ssl_config),
      mojo::Clone(ssl_config_client_receiver),
      mojo::Clone(initial_proxy_config),
      mojo::Clone(proxy_config_client_receiver),
      mojo::Clone(initial_custom_proxy_config),
      mojo::Clone(custom_proxy_config_client_receiver),
      mojo::Clone(custom_proxy_connection_observer_remote),
      mojo::Clone(proxy_config_poller_client),
      mojo::Clone(proxy_error_client),
      mojo::Clone(socket_broker),
      mojo::Clone(pac_quick_check_enabled),
      mojo::Clone(enable_certificate_reporting),
      mojo::Clone(enforce_chrome_ct_policy),
      mojo::Clone(enable_expect_ct_reporting),
      mojo::Clone(sct_auditing_mode),
      mojo::Clone(ct_policy),
      mojo::Clone(cert_verifier_params),
      mojo::Clone(cookie_manager_params),
      mojo::Clone(cookie_manager),
      mojo::Clone(enable_domain_reliability),
      mojo::Clone(domain_reliability_upload_reporter),
      mojo::Clone(discard_domain_reliablity_uploads),
      mojo::Clone(reporting_delivery_interval),
      mojo::Clone(skip_reporting_send_permission_check),
      mojo::Clone(cors_origin_access_list),
      mojo::Clone(cors_exempt_header_list),
      mojo::Clone(allow_any_cors_exempt_header_for_browser),
      mojo::Clone(hsts_policy_bypass_list),
      mojo::Clone(http_auth_static_network_context_params),
      mojo::Clone(reset_http_cache_backend),
      mojo::Clone(split_auth_cache_by_network_isolation_key),
      mojo::Clone(require_network_isolation_key),
      mojo::Clone(file_paths),
      mojo::Clone(block_trust_tokens),
      mojo::Clone(first_party_sets_access_delegate_params),
      mojo::Clone(first_party_sets_access_delegate_receiver)
  );
}

template <typename T, NetworkContextParams::EnableIfSame<T>*>
bool NetworkContextParams::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->user_agent, other_struct.user_agent))
    return false;
  if (!mojo::Equals(this->accept_language, other_struct.accept_language))
    return false;
  if (!mojo::Equals(this->enable_brotli, other_struct.enable_brotli))
    return false;
  if (!mojo::Equals(this->quic_user_agent_id, other_struct.quic_user_agent_id))
    return false;
  if (!mojo::Equals(this->enable_referrers, other_struct.enable_referrers))
    return false;
  if (!mojo::Equals(this->validate_referrer_policy_on_initial_request, other_struct.validate_referrer_policy_on_initial_request))
    return false;
  if (!mojo::Equals(this->proxy_resolver_factory, other_struct.proxy_resolver_factory))
    return false;
  if (!mojo::Equals(this->enable_encrypted_cookies, other_struct.enable_encrypted_cookies))
    return false;
  if (!mojo::Equals(this->restore_old_session_cookies, other_struct.restore_old_session_cookies))
    return false;
  if (!mojo::Equals(this->persist_session_cookies, other_struct.persist_session_cookies))
    return false;
  if (!mojo::Equals(this->http_cache_enabled, other_struct.http_cache_enabled))
    return false;
  if (!mojo::Equals(this->http_cache_max_size, other_struct.http_cache_max_size))
    return false;
  if (!mojo::Equals(this->http_cache_directory, other_struct.http_cache_directory))
    return false;
  if (!mojo::Equals(this->http_cache_file_operations_factory, other_struct.http_cache_file_operations_factory))
    return false;
  if (!mojo::Equals(this->check_clear_text_permitted, other_struct.check_clear_text_permitted))
    return false;
  if (!mojo::Equals(this->disable_idle_sockets_close_on_memory_pressure, other_struct.disable_idle_sockets_close_on_memory_pressure))
    return false;
  if (!mojo::Equals(this->initial_ssl_config, other_struct.initial_ssl_config))
    return false;
  if (!mojo::Equals(this->ssl_config_client_receiver, other_struct.ssl_config_client_receiver))
    return false;
  if (!mojo::Equals(this->initial_proxy_config, other_struct.initial_proxy_config))
    return false;
  if (!mojo::Equals(this->proxy_config_client_receiver, other_struct.proxy_config_client_receiver))
    return false;
  if (!mojo::Equals(this->initial_custom_proxy_config, other_struct.initial_custom_proxy_config))
    return false;
  if (!mojo::Equals(this->custom_proxy_config_client_receiver, other_struct.custom_proxy_config_client_receiver))
    return false;
  if (!mojo::Equals(this->custom_proxy_connection_observer_remote, other_struct.custom_proxy_connection_observer_remote))
    return false;
  if (!mojo::Equals(this->proxy_config_poller_client, other_struct.proxy_config_poller_client))
    return false;
  if (!mojo::Equals(this->proxy_error_client, other_struct.proxy_error_client))
    return false;
  if (!mojo::Equals(this->socket_broker, other_struct.socket_broker))
    return false;
  if (!mojo::Equals(this->pac_quick_check_enabled, other_struct.pac_quick_check_enabled))
    return false;
  if (!mojo::Equals(this->enable_certificate_reporting, other_struct.enable_certificate_reporting))
    return false;
  if (!mojo::Equals(this->enforce_chrome_ct_policy, other_struct.enforce_chrome_ct_policy))
    return false;
  if (!mojo::Equals(this->enable_expect_ct_reporting, other_struct.enable_expect_ct_reporting))
    return false;
  if (!mojo::Equals(this->sct_auditing_mode, other_struct.sct_auditing_mode))
    return false;
  if (!mojo::Equals(this->ct_policy, other_struct.ct_policy))
    return false;
  if (!mojo::Equals(this->cert_verifier_params, other_struct.cert_verifier_params))
    return false;
  if (!mojo::Equals(this->cookie_manager_params, other_struct.cookie_manager_params))
    return false;
  if (!mojo::Equals(this->cookie_manager, other_struct.cookie_manager))
    return false;
  if (!mojo::Equals(this->enable_domain_reliability, other_struct.enable_domain_reliability))
    return false;
  if (!mojo::Equals(this->domain_reliability_upload_reporter, other_struct.domain_reliability_upload_reporter))
    return false;
  if (!mojo::Equals(this->discard_domain_reliablity_uploads, other_struct.discard_domain_reliablity_uploads))
    return false;
  if (!mojo::Equals(this->reporting_delivery_interval, other_struct.reporting_delivery_interval))
    return false;
  if (!mojo::Equals(this->skip_reporting_send_permission_check, other_struct.skip_reporting_send_permission_check))
    return false;
  if (!mojo::Equals(this->cors_origin_access_list, other_struct.cors_origin_access_list))
    return false;
  if (!mojo::Equals(this->cors_exempt_header_list, other_struct.cors_exempt_header_list))
    return false;
  if (!mojo::Equals(this->allow_any_cors_exempt_header_for_browser, other_struct.allow_any_cors_exempt_header_for_browser))
    return false;
  if (!mojo::Equals(this->hsts_policy_bypass_list, other_struct.hsts_policy_bypass_list))
    return false;
  if (!mojo::Equals(this->http_auth_static_network_context_params, other_struct.http_auth_static_network_context_params))
    return false;
  if (!mojo::Equals(this->reset_http_cache_backend, other_struct.reset_http_cache_backend))
    return false;
  if (!mojo::Equals(this->split_auth_cache_by_network_isolation_key, other_struct.split_auth_cache_by_network_isolation_key))
    return false;
  if (!mojo::Equals(this->require_network_isolation_key, other_struct.require_network_isolation_key))
    return false;
  if (!mojo::Equals(this->file_paths, other_struct.file_paths))
    return false;
  if (!mojo::Equals(this->block_trust_tokens, other_struct.block_trust_tokens))
    return false;
  if (!mojo::Equals(this->first_party_sets_access_delegate_params, other_struct.first_party_sets_access_delegate_params))
    return false;
  if (!mojo::Equals(this->first_party_sets_access_delegate_receiver, other_struct.first_party_sets_access_delegate_receiver))
    return false;
  return true;
}

template <typename T, NetworkContextParams::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.user_agent < rhs.user_agent)
    return true;
  if (rhs.user_agent < lhs.user_agent)
    return false;
  if (lhs.accept_language < rhs.accept_language)
    return true;
  if (rhs.accept_language < lhs.accept_language)
    return false;
  if (lhs.enable_brotli < rhs.enable_brotli)
    return true;
  if (rhs.enable_brotli < lhs.enable_brotli)
    return false;
  if (lhs.quic_user_agent_id < rhs.quic_user_agent_id)
    return true;
  if (rhs.quic_user_agent_id < lhs.quic_user_agent_id)
    return false;
  if (lhs.enable_referrers < rhs.enable_referrers)
    return true;
  if (rhs.enable_referrers < lhs.enable_referrers)
    return false;
  if (lhs.validate_referrer_policy_on_initial_request < rhs.validate_referrer_policy_on_initial_request)
    return true;
  if (rhs.validate_referrer_policy_on_initial_request < lhs.validate_referrer_policy_on_initial_request)
    return false;
  if (lhs.proxy_resolver_factory < rhs.proxy_resolver_factory)
    return true;
  if (rhs.proxy_resolver_factory < lhs.proxy_resolver_factory)
    return false;
  if (lhs.enable_encrypted_cookies < rhs.enable_encrypted_cookies)
    return true;
  if (rhs.enable_encrypted_cookies < lhs.enable_encrypted_cookies)
    return false;
  if (lhs.restore_old_session_cookies < rhs.restore_old_session_cookies)
    return true;
  if (rhs.restore_old_session_cookies < lhs.restore_old_session_cookies)
    return false;
  if (lhs.persist_session_cookies < rhs.persist_session_cookies)
    return true;
  if (rhs.persist_session_cookies < lhs.persist_session_cookies)
    return false;
  if (lhs.http_cache_enabled < rhs.http_cache_enabled)
    return true;
  if (rhs.http_cache_enabled < lhs.http_cache_enabled)
    return false;
  if (lhs.http_cache_max_size < rhs.http_cache_max_size)
    return true;
  if (rhs.http_cache_max_size < lhs.http_cache_max_size)
    return false;
  if (lhs.http_cache_directory < rhs.http_cache_directory)
    return true;
  if (rhs.http_cache_directory < lhs.http_cache_directory)
    return false;
  if (lhs.http_cache_file_operations_factory < rhs.http_cache_file_operations_factory)
    return true;
  if (rhs.http_cache_file_operations_factory < lhs.http_cache_file_operations_factory)
    return false;
  if (lhs.check_clear_text_permitted < rhs.check_clear_text_permitted)
    return true;
  if (rhs.check_clear_text_permitted < lhs.check_clear_text_permitted)
    return false;
  if (lhs.disable_idle_sockets_close_on_memory_pressure < rhs.disable_idle_sockets_close_on_memory_pressure)
    return true;
  if (rhs.disable_idle_sockets_close_on_memory_pressure < lhs.disable_idle_sockets_close_on_memory_pressure)
    return false;
  if (lhs.initial_ssl_config < rhs.initial_ssl_config)
    return true;
  if (rhs.initial_ssl_config < lhs.initial_ssl_config)
    return false;
  if (lhs.ssl_config_client_receiver < rhs.ssl_config_client_receiver)
    return true;
  if (rhs.ssl_config_client_receiver < lhs.ssl_config_client_receiver)
    return false;
  if (lhs.initial_proxy_config < rhs.initial_proxy_config)
    return true;
  if (rhs.initial_proxy_config < lhs.initial_proxy_config)
    return false;
  if (lhs.proxy_config_client_receiver < rhs.proxy_config_client_receiver)
    return true;
  if (rhs.proxy_config_client_receiver < lhs.proxy_config_client_receiver)
    return false;
  if (lhs.initial_custom_proxy_config < rhs.initial_custom_proxy_config)
    return true;
  if (rhs.initial_custom_proxy_config < lhs.initial_custom_proxy_config)
    return false;
  if (lhs.custom_proxy_config_client_receiver < rhs.custom_proxy_config_client_receiver)
    return true;
  if (rhs.custom_proxy_config_client_receiver < lhs.custom_proxy_config_client_receiver)
    return false;
  if (lhs.custom_proxy_connection_observer_remote < rhs.custom_proxy_connection_observer_remote)
    return true;
  if (rhs.custom_proxy_connection_observer_remote < lhs.custom_proxy_connection_observer_remote)
    return false;
  if (lhs.proxy_config_poller_client < rhs.proxy_config_poller_client)
    return true;
  if (rhs.proxy_config_poller_client < lhs.proxy_config_poller_client)
    return false;
  if (lhs.proxy_error_client < rhs.proxy_error_client)
    return true;
  if (rhs.proxy_error_client < lhs.proxy_error_client)
    return false;
  if (lhs.socket_broker < rhs.socket_broker)
    return true;
  if (rhs.socket_broker < lhs.socket_broker)
    return false;
  if (lhs.pac_quick_check_enabled < rhs.pac_quick_check_enabled)
    return true;
  if (rhs.pac_quick_check_enabled < lhs.pac_quick_check_enabled)
    return false;
  if (lhs.enable_certificate_reporting < rhs.enable_certificate_reporting)
    return true;
  if (rhs.enable_certificate_reporting < lhs.enable_certificate_reporting)
    return false;
  if (lhs.enforce_chrome_ct_policy < rhs.enforce_chrome_ct_policy)
    return true;
  if (rhs.enforce_chrome_ct_policy < lhs.enforce_chrome_ct_policy)
    return false;
  if (lhs.enable_expect_ct_reporting < rhs.enable_expect_ct_reporting)
    return true;
  if (rhs.enable_expect_ct_reporting < lhs.enable_expect_ct_reporting)
    return false;
  if (lhs.sct_auditing_mode < rhs.sct_auditing_mode)
    return true;
  if (rhs.sct_auditing_mode < lhs.sct_auditing_mode)
    return false;
  if (lhs.ct_policy < rhs.ct_policy)
    return true;
  if (rhs.ct_policy < lhs.ct_policy)
    return false;
  if (lhs.cert_verifier_params < rhs.cert_verifier_params)
    return true;
  if (rhs.cert_verifier_params < lhs.cert_verifier_params)
    return false;
  if (lhs.cookie_manager_params < rhs.cookie_manager_params)
    return true;
  if (rhs.cookie_manager_params < lhs.cookie_manager_params)
    return false;
  if (lhs.cookie_manager < rhs.cookie_manager)
    return true;
  if (rhs.cookie_manager < lhs.cookie_manager)
    return false;
  if (lhs.enable_domain_reliability < rhs.enable_domain_reliability)
    return true;
  if (rhs.enable_domain_reliability < lhs.enable_domain_reliability)
    return false;
  if (lhs.domain_reliability_upload_reporter < rhs.domain_reliability_upload_reporter)
    return true;
  if (rhs.domain_reliability_upload_reporter < lhs.domain_reliability_upload_reporter)
    return false;
  if (lhs.discard_domain_reliablity_uploads < rhs.discard_domain_reliablity_uploads)
    return true;
  if (rhs.discard_domain_reliablity_uploads < lhs.discard_domain_reliablity_uploads)
    return false;
  if (lhs.reporting_delivery_interval < rhs.reporting_delivery_interval)
    return true;
  if (rhs.reporting_delivery_interval < lhs.reporting_delivery_interval)
    return false;
  if (lhs.skip_reporting_send_permission_check < rhs.skip_reporting_send_permission_check)
    return true;
  if (rhs.skip_reporting_send_permission_check < lhs.skip_reporting_send_permission_check)
    return false;
  if (lhs.cors_origin_access_list < rhs.cors_origin_access_list)
    return true;
  if (rhs.cors_origin_access_list < lhs.cors_origin_access_list)
    return false;
  if (lhs.cors_exempt_header_list < rhs.cors_exempt_header_list)
    return true;
  if (rhs.cors_exempt_header_list < lhs.cors_exempt_header_list)
    return false;
  if (lhs.allow_any_cors_exempt_header_for_browser < rhs.allow_any_cors_exempt_header_for_browser)
    return true;
  if (rhs.allow_any_cors_exempt_header_for_browser < lhs.allow_any_cors_exempt_header_for_browser)
    return false;
  if (lhs.hsts_policy_bypass_list < rhs.hsts_policy_bypass_list)
    return true;
  if (rhs.hsts_policy_bypass_list < lhs.hsts_policy_bypass_list)
    return false;
  if (lhs.http_auth_static_network_context_params < rhs.http_auth_static_network_context_params)
    return true;
  if (rhs.http_auth_static_network_context_params < lhs.http_auth_static_network_context_params)
    return false;
  if (lhs.reset_http_cache_backend < rhs.reset_http_cache_backend)
    return true;
  if (rhs.reset_http_cache_backend < lhs.reset_http_cache_backend)
    return false;
  if (lhs.split_auth_cache_by_network_isolation_key < rhs.split_auth_cache_by_network_isolation_key)
    return true;
  if (rhs.split_auth_cache_by_network_isolation_key < lhs.split_auth_cache_by_network_isolation_key)
    return false;
  if (lhs.require_network_isolation_key < rhs.require_network_isolation_key)
    return true;
  if (rhs.require_network_isolation_key < lhs.require_network_isolation_key)
    return false;
  if (lhs.file_paths < rhs.file_paths)
    return true;
  if (rhs.file_paths < lhs.file_paths)
    return false;
  if (lhs.block_trust_tokens < rhs.block_trust_tokens)
    return true;
  if (rhs.block_trust_tokens < lhs.block_trust_tokens)
    return false;
  if (lhs.first_party_sets_access_delegate_params < rhs.first_party_sets_access_delegate_params)
    return true;
  if (rhs.first_party_sets_access_delegate_params < lhs.first_party_sets_access_delegate_params)
    return false;
  if (lhs.first_party_sets_access_delegate_receiver < rhs.first_party_sets_access_delegate_receiver)
    return true;
  if (rhs.first_party_sets_access_delegate_receiver < lhs.first_party_sets_access_delegate_receiver)
    return false;
  return false;
}
template <typename StructPtrType>
NetworkConditionsPtr NetworkConditions::Clone() const {
  return New(
      mojo::Clone(offline),
      mojo::Clone(latency),
      mojo::Clone(download_throughput),
      mojo::Clone(upload_throughput)
  );
}

template <typename T, NetworkConditions::EnableIfSame<T>*>
bool NetworkConditions::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->offline, other_struct.offline))
    return false;
  if (!mojo::Equals(this->latency, other_struct.latency))
    return false;
  if (!mojo::Equals(this->download_throughput, other_struct.download_throughput))
    return false;
  if (!mojo::Equals(this->upload_throughput, other_struct.upload_throughput))
    return false;
  return true;
}

template <typename T, NetworkConditions::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.offline < rhs.offline)
    return true;
  if (rhs.offline < lhs.offline)
    return false;
  if (lhs.latency < rhs.latency)
    return true;
  if (rhs.latency < lhs.latency)
    return false;
  if (lhs.download_throughput < rhs.download_throughput)
    return true;
  if (rhs.download_throughput < lhs.download_throughput)
    return false;
  if (lhs.upload_throughput < rhs.upload_throughput)
    return true;
  if (rhs.upload_throughput < lhs.upload_throughput)
    return false;
  return false;
}
template <typename StructPtrType>
ClearDataFilterPtr ClearDataFilter::Clone() const {
  return New(
      mojo::Clone(type),
      mojo::Clone(domains),
      mojo::Clone(origins)
  );
}

template <typename T, ClearDataFilter::EnableIfSame<T>*>
bool ClearDataFilter::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->type, other_struct.type))
    return false;
  if (!mojo::Equals(this->domains, other_struct.domains))
    return false;
  if (!mojo::Equals(this->origins, other_struct.origins))
    return false;
  return true;
}

template <typename T, ClearDataFilter::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.type < rhs.type)
    return true;
  if (rhs.type < lhs.type)
    return false;
  if (lhs.domains < rhs.domains)
    return true;
  if (rhs.domains < lhs.domains)
    return false;
  if (lhs.origins < rhs.origins)
    return true;
  if (rhs.origins < lhs.origins)
    return false;
  return false;
}
template <typename StructPtrType>
SignedExchangeReportPtr SignedExchangeReport::Clone() const {
  return New(
      mojo::Clone(success),
      mojo::Clone(type),
      mojo::Clone(outer_url),
      mojo::Clone(inner_url),
      mojo::Clone(cert_url),
      mojo::Clone(referrer),
      mojo::Clone(server_ip_address),
      mojo::Clone(protocol),
      mojo::Clone(method),
      mojo::Clone(status_code),
      mojo::Clone(elapsed_time)
  );
}

template <typename T, SignedExchangeReport::EnableIfSame<T>*>
bool SignedExchangeReport::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->success, other_struct.success))
    return false;
  if (!mojo::Equals(this->type, other_struct.type))
    return false;
  if (!mojo::Equals(this->outer_url, other_struct.outer_url))
    return false;
  if (!mojo::Equals(this->inner_url, other_struct.inner_url))
    return false;
  if (!mojo::Equals(this->cert_url, other_struct.cert_url))
    return false;
  if (!mojo::Equals(this->referrer, other_struct.referrer))
    return false;
  if (!mojo::Equals(this->server_ip_address, other_struct.server_ip_address))
    return false;
  if (!mojo::Equals(this->protocol, other_struct.protocol))
    return false;
  if (!mojo::Equals(this->method, other_struct.method))
    return false;
  if (!mojo::Equals(this->status_code, other_struct.status_code))
    return false;
  if (!mojo::Equals(this->elapsed_time, other_struct.elapsed_time))
    return false;
  return true;
}

template <typename T, SignedExchangeReport::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.success < rhs.success)
    return true;
  if (rhs.success < lhs.success)
    return false;
  if (lhs.type < rhs.type)
    return true;
  if (rhs.type < lhs.type)
    return false;
  if (lhs.outer_url < rhs.outer_url)
    return true;
  if (rhs.outer_url < lhs.outer_url)
    return false;
  if (lhs.inner_url < rhs.inner_url)
    return true;
  if (rhs.inner_url < lhs.inner_url)
    return false;
  if (lhs.cert_url < rhs.cert_url)
    return true;
  if (rhs.cert_url < lhs.cert_url)
    return false;
  if (lhs.referrer < rhs.referrer)
    return true;
  if (rhs.referrer < lhs.referrer)
    return false;
  if (lhs.server_ip_address < rhs.server_ip_address)
    return true;
  if (rhs.server_ip_address < lhs.server_ip_address)
    return false;
  if (lhs.protocol < rhs.protocol)
    return true;
  if (rhs.protocol < lhs.protocol)
    return false;
  if (lhs.method < rhs.method)
    return true;
  if (rhs.method < lhs.method)
    return false;
  if (lhs.status_code < rhs.status_code)
    return true;
  if (rhs.status_code < lhs.status_code)
    return false;
  if (lhs.elapsed_time < rhs.elapsed_time)
    return true;
  if (rhs.elapsed_time < lhs.elapsed_time)
    return false;
  return false;
}
template <typename StructPtrType>
URLLoaderFactoryOverridePtr URLLoaderFactoryOverride::Clone() const {
  return New(
      mojo::Clone(overriding_factory),
      mojo::Clone(overridden_factory_receiver),
      mojo::Clone(skip_cors_enabled_scheme_check)
  );
}

template <typename T, URLLoaderFactoryOverride::EnableIfSame<T>*>
bool URLLoaderFactoryOverride::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->overriding_factory, other_struct.overriding_factory))
    return false;
  if (!mojo::Equals(this->overridden_factory_receiver, other_struct.overridden_factory_receiver))
    return false;
  if (!mojo::Equals(this->skip_cors_enabled_scheme_check, other_struct.skip_cors_enabled_scheme_check))
    return false;
  return true;
}

template <typename T, URLLoaderFactoryOverride::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.overriding_factory < rhs.overriding_factory)
    return true;
  if (rhs.overriding_factory < lhs.overriding_factory)
    return false;
  if (lhs.overridden_factory_receiver < rhs.overridden_factory_receiver)
    return true;
  if (rhs.overridden_factory_receiver < lhs.overridden_factory_receiver)
    return false;
  if (lhs.skip_cors_enabled_scheme_check < rhs.skip_cors_enabled_scheme_check)
    return true;
  if (rhs.skip_cors_enabled_scheme_check < lhs.skip_cors_enabled_scheme_check)
    return false;
  return false;
}
template <typename StructPtrType>
URLLoaderFactoryParamsPtr URLLoaderFactoryParams::Clone() const {
  return New(
      mojo::Clone(process_id),
      mojo::Clone(request_initiator_origin_lock),
      mojo::Clone(is_corb_enabled),
      mojo::Clone(ignore_isolated_world_origin),
      mojo::Clone(unsafe_non_webby_initiator),
      mojo::Clone(disable_web_security),
      mojo::Clone(header_client),
      mojo::Clone(isolation_info),
      mojo::Clone(disable_secure_dns),
      mojo::Clone(is_trusted),
      mojo::Clone(automatically_assign_isolation_info),
      mojo::Clone(provide_loading_state_updates),
      mojo::Clone(top_frame_id),
      mojo::Clone(factory_override),
      mojo::Clone(client_security_state),
      mojo::Clone(coep_reporter),
      mojo::Clone(cookie_observer),
      mojo::Clone(url_loader_network_observer),
      mojo::Clone(devtools_observer),
      mojo::Clone(trust_token_redemption_policy),
      mojo::Clone(debug_tag)
  );
}

template <typename T, URLLoaderFactoryParams::EnableIfSame<T>*>
bool URLLoaderFactoryParams::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->process_id, other_struct.process_id))
    return false;
  if (!mojo::Equals(this->request_initiator_origin_lock, other_struct.request_initiator_origin_lock))
    return false;
  if (!mojo::Equals(this->is_corb_enabled, other_struct.is_corb_enabled))
    return false;
  if (!mojo::Equals(this->ignore_isolated_world_origin, other_struct.ignore_isolated_world_origin))
    return false;
  if (!mojo::Equals(this->unsafe_non_webby_initiator, other_struct.unsafe_non_webby_initiator))
    return false;
  if (!mojo::Equals(this->disable_web_security, other_struct.disable_web_security))
    return false;
  if (!mojo::Equals(this->header_client, other_struct.header_client))
    return false;
  if (!mojo::Equals(this->isolation_info, other_struct.isolation_info))
    return false;
  if (!mojo::Equals(this->disable_secure_dns, other_struct.disable_secure_dns))
    return false;
  if (!mojo::Equals(this->is_trusted, other_struct.is_trusted))
    return false;
  if (!mojo::Equals(this->automatically_assign_isolation_info, other_struct.automatically_assign_isolation_info))
    return false;
  if (!mojo::Equals(this->provide_loading_state_updates, other_struct.provide_loading_state_updates))
    return false;
  if (!mojo::Equals(this->top_frame_id, other_struct.top_frame_id))
    return false;
  if (!mojo::Equals(this->factory_override, other_struct.factory_override))
    return false;
  if (!mojo::Equals(this->client_security_state, other_struct.client_security_state))
    return false;
  if (!mojo::Equals(this->coep_reporter, other_struct.coep_reporter))
    return false;
  if (!mojo::Equals(this->cookie_observer, other_struct.cookie_observer))
    return false;
  if (!mojo::Equals(this->url_loader_network_observer, other_struct.url_loader_network_observer))
    return false;
  if (!mojo::Equals(this->devtools_observer, other_struct.devtools_observer))
    return false;
  if (!mojo::Equals(this->trust_token_redemption_policy, other_struct.trust_token_redemption_policy))
    return false;
  if (!mojo::Equals(this->debug_tag, other_struct.debug_tag))
    return false;
  return true;
}

template <typename T, URLLoaderFactoryParams::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.process_id < rhs.process_id)
    return true;
  if (rhs.process_id < lhs.process_id)
    return false;
  if (lhs.request_initiator_origin_lock < rhs.request_initiator_origin_lock)
    return true;
  if (rhs.request_initiator_origin_lock < lhs.request_initiator_origin_lock)
    return false;
  if (lhs.is_corb_enabled < rhs.is_corb_enabled)
    return true;
  if (rhs.is_corb_enabled < lhs.is_corb_enabled)
    return false;
  if (lhs.ignore_isolated_world_origin < rhs.ignore_isolated_world_origin)
    return true;
  if (rhs.ignore_isolated_world_origin < lhs.ignore_isolated_world_origin)
    return false;
  if (lhs.unsafe_non_webby_initiator < rhs.unsafe_non_webby_initiator)
    return true;
  if (rhs.unsafe_non_webby_initiator < lhs.unsafe_non_webby_initiator)
    return false;
  if (lhs.disable_web_security < rhs.disable_web_security)
    return true;
  if (rhs.disable_web_security < lhs.disable_web_security)
    return false;
  if (lhs.header_client < rhs.header_client)
    return true;
  if (rhs.header_client < lhs.header_client)
    return false;
  if (lhs.isolation_info < rhs.isolation_info)
    return true;
  if (rhs.isolation_info < lhs.isolation_info)
    return false;
  if (lhs.disable_secure_dns < rhs.disable_secure_dns)
    return true;
  if (rhs.disable_secure_dns < lhs.disable_secure_dns)
    return false;
  if (lhs.is_trusted < rhs.is_trusted)
    return true;
  if (rhs.is_trusted < lhs.is_trusted)
    return false;
  if (lhs.automatically_assign_isolation_info < rhs.automatically_assign_isolation_info)
    return true;
  if (rhs.automatically_assign_isolation_info < lhs.automatically_assign_isolation_info)
    return false;
  if (lhs.provide_loading_state_updates < rhs.provide_loading_state_updates)
    return true;
  if (rhs.provide_loading_state_updates < lhs.provide_loading_state_updates)
    return false;
  if (lhs.top_frame_id < rhs.top_frame_id)
    return true;
  if (rhs.top_frame_id < lhs.top_frame_id)
    return false;
  if (lhs.factory_override < rhs.factory_override)
    return true;
  if (rhs.factory_override < lhs.factory_override)
    return false;
  if (lhs.client_security_state < rhs.client_security_state)
    return true;
  if (rhs.client_security_state < lhs.client_security_state)
    return false;
  if (lhs.coep_reporter < rhs.coep_reporter)
    return true;
  if (rhs.coep_reporter < lhs.coep_reporter)
    return false;
  if (lhs.cookie_observer < rhs.cookie_observer)
    return true;
  if (rhs.cookie_observer < lhs.cookie_observer)
    return false;
  if (lhs.url_loader_network_observer < rhs.url_loader_network_observer)
    return true;
  if (rhs.url_loader_network_observer < lhs.url_loader_network_observer)
    return false;
  if (lhs.devtools_observer < rhs.devtools_observer)
    return true;
  if (rhs.devtools_observer < lhs.devtools_observer)
    return false;
  if (lhs.trust_token_redemption_policy < rhs.trust_token_redemption_policy)
    return true;
  if (rhs.trust_token_redemption_policy < lhs.trust_token_redemption_policy)
    return false;
  if (lhs.debug_tag < rhs.debug_tag)
    return true;
  if (rhs.debug_tag < lhs.debug_tag)
    return false;
  return false;
}


}  // namespace blink
}  // namespace mojom
}  // namespace network

namespace mojo {


template <>
struct BLINK_PLATFORM_EXPORT StructTraits<::network::mojom::blink::CustomProxyConfig::DataView,
                                         ::network::mojom::blink::CustomProxyConfigPtr> {
  static bool IsNull(const ::network::mojom::blink::CustomProxyConfigPtr& input) { return !input; }
  static void SetToNull(::network::mojom::blink::CustomProxyConfigPtr* output) { output->reset(); }

  static const decltype(::network::mojom::blink::CustomProxyConfig::rules)& rules(
      const ::network::mojom::blink::CustomProxyConfigPtr& input) {
    return input->rules;
  }

  static decltype(::network::mojom::blink::CustomProxyConfig::should_override_existing_config) should_override_existing_config(
      const ::network::mojom::blink::CustomProxyConfigPtr& input) {
    return input->should_override_existing_config;
  }

  static decltype(::network::mojom::blink::CustomProxyConfig::allow_non_idempotent_methods) allow_non_idempotent_methods(
      const ::network::mojom::blink::CustomProxyConfigPtr& input) {
    return input->allow_non_idempotent_methods;
  }

  static const decltype(::network::mojom::blink::CustomProxyConfig::connect_tunnel_headers)& connect_tunnel_headers(
      const ::network::mojom::blink::CustomProxyConfigPtr& input) {
    return input->connect_tunnel_headers;
  }

  static bool Read(::network::mojom::blink::CustomProxyConfig::DataView input, ::network::mojom::blink::CustomProxyConfigPtr* output);
};


template <>
struct BLINK_PLATFORM_EXPORT StructTraits<::network::mojom::blink::CertVerifierServiceRemoteParams::DataView,
                                         ::network::mojom::blink::CertVerifierServiceRemoteParamsPtr> {
  static bool IsNull(const ::network::mojom::blink::CertVerifierServiceRemoteParamsPtr& input) { return !input; }
  static void SetToNull(::network::mojom::blink::CertVerifierServiceRemoteParamsPtr* output) { output->reset(); }

  static  decltype(::network::mojom::blink::CertVerifierServiceRemoteParams::cert_verifier_service)& cert_verifier_service(
       ::network::mojom::blink::CertVerifierServiceRemoteParamsPtr& input) {
    return input->cert_verifier_service;
  }

  static bool Read(::network::mojom::blink::CertVerifierServiceRemoteParams::DataView input, ::network::mojom::blink::CertVerifierServiceRemoteParamsPtr* output);
};


template <>
struct BLINK_PLATFORM_EXPORT StructTraits<::network::mojom::blink::HttpAuthStaticNetworkContextParams::DataView,
                                         ::network::mojom::blink::HttpAuthStaticNetworkContextParamsPtr> {
  static bool IsNull(const ::network::mojom::blink::HttpAuthStaticNetworkContextParamsPtr& input) { return !input; }
  static void SetToNull(::network::mojom::blink::HttpAuthStaticNetworkContextParamsPtr* output) { output->reset(); }

  static decltype(::network::mojom::blink::HttpAuthStaticNetworkContextParams::allow_default_credentials) allow_default_credentials(
      const ::network::mojom::blink::HttpAuthStaticNetworkContextParamsPtr& input) {
    return input->allow_default_credentials;
  }

  static bool Read(::network::mojom::blink::HttpAuthStaticNetworkContextParams::DataView input, ::network::mojom::blink::HttpAuthStaticNetworkContextParamsPtr* output);
};


template <>
struct BLINK_PLATFORM_EXPORT StructTraits<::network::mojom::blink::CTPolicy::DataView,
                                         ::network::mojom::blink::CTPolicyPtr> {
  static bool IsNull(const ::network::mojom::blink::CTPolicyPtr& input) { return !input; }
  static void SetToNull(::network::mojom::blink::CTPolicyPtr* output) { output->reset(); }

  static const decltype(::network::mojom::blink::CTPolicy::required_hosts)& required_hosts(
      const ::network::mojom::blink::CTPolicyPtr& input) {
    return input->required_hosts;
  }

  static const decltype(::network::mojom::blink::CTPolicy::excluded_hosts)& excluded_hosts(
      const ::network::mojom::blink::CTPolicyPtr& input) {
    return input->excluded_hosts;
  }

  static const decltype(::network::mojom::blink::CTPolicy::excluded_spkis)& excluded_spkis(
      const ::network::mojom::blink::CTPolicyPtr& input) {
    return input->excluded_spkis;
  }

  static const decltype(::network::mojom::blink::CTPolicy::excluded_legacy_spkis)& excluded_legacy_spkis(
      const ::network::mojom::blink::CTPolicyPtr& input) {
    return input->excluded_legacy_spkis;
  }

  static bool Read(::network::mojom::blink::CTPolicy::DataView input, ::network::mojom::blink::CTPolicyPtr* output);
};


template <>
struct BLINK_PLATFORM_EXPORT StructTraits<::network::mojom::blink::NetworkContextFilePaths::DataView,
                                         ::network::mojom::blink::NetworkContextFilePathsPtr> {
  static bool IsNull(const ::network::mojom::blink::NetworkContextFilePathsPtr& input) { return !input; }
  static void SetToNull(::network::mojom::blink::NetworkContextFilePathsPtr* output) { output->reset(); }

  static  decltype(::network::mojom::blink::NetworkContextFilePaths::data_directory)& data_directory(
       ::network::mojom::blink::NetworkContextFilePathsPtr& input) {
    return input->data_directory;
  }

  static const decltype(::network::mojom::blink::NetworkContextFilePaths::unsandboxed_data_path)& unsandboxed_data_path(
      const ::network::mojom::blink::NetworkContextFilePathsPtr& input) {
    return input->unsandboxed_data_path;
  }

  static const decltype(::network::mojom::blink::NetworkContextFilePaths::cookie_database_name)& cookie_database_name(
      const ::network::mojom::blink::NetworkContextFilePathsPtr& input) {
    return input->cookie_database_name;
  }

  static const decltype(::network::mojom::blink::NetworkContextFilePaths::trust_token_database_name)& trust_token_database_name(
      const ::network::mojom::blink::NetworkContextFilePathsPtr& input) {
    return input->trust_token_database_name;
  }

  static const decltype(::network::mojom::blink::NetworkContextFilePaths::http_server_properties_file_name)& http_server_properties_file_name(
      const ::network::mojom::blink::NetworkContextFilePathsPtr& input) {
    return input->http_server_properties_file_name;
  }

  static const decltype(::network::mojom::blink::NetworkContextFilePaths::transport_security_persister_file_name)& transport_security_persister_file_name(
      const ::network::mojom::blink::NetworkContextFilePathsPtr& input) {
    return input->transport_security_persister_file_name;
  }

  static const decltype(::network::mojom::blink::NetworkContextFilePaths::reporting_and_nel_store_database_name)& reporting_and_nel_store_database_name(
      const ::network::mojom::blink::NetworkContextFilePathsPtr& input) {
    return input->reporting_and_nel_store_database_name;
  }

  static const decltype(::network::mojom::blink::NetworkContextFilePaths::sct_auditing_pending_reports_file_name)& sct_auditing_pending_reports_file_name(
      const ::network::mojom::blink::NetworkContextFilePathsPtr& input) {
    return input->sct_auditing_pending_reports_file_name;
  }

  static decltype(::network::mojom::blink::NetworkContextFilePaths::trigger_migration) trigger_migration(
      const ::network::mojom::blink::NetworkContextFilePathsPtr& input) {
    return input->trigger_migration;
  }

  static bool Read(::network::mojom::blink::NetworkContextFilePaths::DataView input, ::network::mojom::blink::NetworkContextFilePathsPtr* output);
};


template <>
struct BLINK_PLATFORM_EXPORT StructTraits<::network::mojom::blink::NetworkContextParams::DataView,
                                         ::network::mojom::blink::NetworkContextParamsPtr> {
  static bool IsNull(const ::network::mojom::blink::NetworkContextParamsPtr& input) { return !input; }
  static void SetToNull(::network::mojom::blink::NetworkContextParamsPtr* output) { output->reset(); }

  static const decltype(::network::mojom::blink::NetworkContextParams::user_agent)& user_agent(
      const ::network::mojom::blink::NetworkContextParamsPtr& input) {
    return input->user_agent;
  }

  static const decltype(::network::mojom::blink::NetworkContextParams::accept_language)& accept_language(
      const ::network::mojom::blink::NetworkContextParamsPtr& input) {
    return input->accept_language;
  }

  static decltype(::network::mojom::blink::NetworkContextParams::enable_brotli) enable_brotli(
      const ::network::mojom::blink::NetworkContextParamsPtr& input) {
    return input->enable_brotli;
  }

  static const decltype(::network::mojom::blink::NetworkContextParams::quic_user_agent_id)& quic_user_agent_id(
      const ::network::mojom::blink::NetworkContextParamsPtr& input) {
    return input->quic_user_agent_id;
  }

  static decltype(::network::mojom::blink::NetworkContextParams::enable_referrers) enable_referrers(
      const ::network::mojom::blink::NetworkContextParamsPtr& input) {
    return input->enable_referrers;
  }

  static decltype(::network::mojom::blink::NetworkContextParams::validate_referrer_policy_on_initial_request) validate_referrer_policy_on_initial_request(
      const ::network::mojom::blink::NetworkContextParamsPtr& input) {
    return input->validate_referrer_policy_on_initial_request;
  }

  static  decltype(::network::mojom::blink::NetworkContextParams::proxy_resolver_factory)& proxy_resolver_factory(
       ::network::mojom::blink::NetworkContextParamsPtr& input) {
    return input->proxy_resolver_factory;
  }

  static decltype(::network::mojom::blink::NetworkContextParams::enable_encrypted_cookies) enable_encrypted_cookies(
      const ::network::mojom::blink::NetworkContextParamsPtr& input) {
    return input->enable_encrypted_cookies;
  }

  static decltype(::network::mojom::blink::NetworkContextParams::restore_old_session_cookies) restore_old_session_cookies(
      const ::network::mojom::blink::NetworkContextParamsPtr& input) {
    return input->restore_old_session_cookies;
  }

  static decltype(::network::mojom::blink::NetworkContextParams::persist_session_cookies) persist_session_cookies(
      const ::network::mojom::blink::NetworkContextParamsPtr& input) {
    return input->persist_session_cookies;
  }

  static decltype(::network::mojom::blink::NetworkContextParams::http_cache_enabled) http_cache_enabled(
      const ::network::mojom::blink::NetworkContextParamsPtr& input) {
    return input->http_cache_enabled;
  }

  static decltype(::network::mojom::blink::NetworkContextParams::http_cache_max_size) http_cache_max_size(
      const ::network::mojom::blink::NetworkContextParamsPtr& input) {
    return input->http_cache_max_size;
  }

  static  decltype(::network::mojom::blink::NetworkContextParams::http_cache_directory)& http_cache_directory(
       ::network::mojom::blink::NetworkContextParamsPtr& input) {
    return input->http_cache_directory;
  }

  static  decltype(::network::mojom::blink::NetworkContextParams::http_cache_file_operations_factory)& http_cache_file_operations_factory(
       ::network::mojom::blink::NetworkContextParamsPtr& input) {
    return input->http_cache_file_operations_factory;
  }

  static decltype(::network::mojom::blink::NetworkContextParams::check_clear_text_permitted) check_clear_text_permitted(
      const ::network::mojom::blink::NetworkContextParamsPtr& input) {
    return input->check_clear_text_permitted;
  }

  static decltype(::network::mojom::blink::NetworkContextParams::disable_idle_sockets_close_on_memory_pressure) disable_idle_sockets_close_on_memory_pressure(
      const ::network::mojom::blink::NetworkContextParamsPtr& input) {
    return input->disable_idle_sockets_close_on_memory_pressure;
  }

  static const decltype(::network::mojom::blink::NetworkContextParams::initial_ssl_config)& initial_ssl_config(
      const ::network::mojom::blink::NetworkContextParamsPtr& input) {
    return input->initial_ssl_config;
  }

  static  decltype(::network::mojom::blink::NetworkContextParams::ssl_config_client_receiver)& ssl_config_client_receiver(
       ::network::mojom::blink::NetworkContextParamsPtr& input) {
    return input->ssl_config_client_receiver;
  }

  static  decltype(::network::mojom::blink::NetworkContextParams::initial_proxy_config)& initial_proxy_config(
       ::network::mojom::blink::NetworkContextParamsPtr& input) {
    return input->initial_proxy_config;
  }

  static  decltype(::network::mojom::blink::NetworkContextParams::proxy_config_client_receiver)& proxy_config_client_receiver(
       ::network::mojom::blink::NetworkContextParamsPtr& input) {
    return input->proxy_config_client_receiver;
  }

  static const decltype(::network::mojom::blink::NetworkContextParams::initial_custom_proxy_config)& initial_custom_proxy_config(
      const ::network::mojom::blink::NetworkContextParamsPtr& input) {
    return input->initial_custom_proxy_config;
  }

  static  decltype(::network::mojom::blink::NetworkContextParams::custom_proxy_config_client_receiver)& custom_proxy_config_client_receiver(
       ::network::mojom::blink::NetworkContextParamsPtr& input) {
    return input->custom_proxy_config_client_receiver;
  }

  static  decltype(::network::mojom::blink::NetworkContextParams::custom_proxy_connection_observer_remote)& custom_proxy_connection_observer_remote(
       ::network::mojom::blink::NetworkContextParamsPtr& input) {
    return input->custom_proxy_connection_observer_remote;
  }

  static  decltype(::network::mojom::blink::NetworkContextParams::proxy_config_poller_client)& proxy_config_poller_client(
       ::network::mojom::blink::NetworkContextParamsPtr& input) {
    return input->proxy_config_poller_client;
  }

  static  decltype(::network::mojom::blink::NetworkContextParams::proxy_error_client)& proxy_error_client(
       ::network::mojom::blink::NetworkContextParamsPtr& input) {
    return input->proxy_error_client;
  }

  static  decltype(::network::mojom::blink::NetworkContextParams::socket_broker)& socket_broker(
       ::network::mojom::blink::NetworkContextParamsPtr& input) {
    return input->socket_broker;
  }

  static decltype(::network::mojom::blink::NetworkContextParams::pac_quick_check_enabled) pac_quick_check_enabled(
      const ::network::mojom::blink::NetworkContextParamsPtr& input) {
    return input->pac_quick_check_enabled;
  }

  static decltype(::network::mojom::blink::NetworkContextParams::enable_certificate_reporting) enable_certificate_reporting(
      const ::network::mojom::blink::NetworkContextParamsPtr& input) {
    return input->enable_certificate_reporting;
  }

  static decltype(::network::mojom::blink::NetworkContextParams::enforce_chrome_ct_policy) enforce_chrome_ct_policy(
      const ::network::mojom::blink::NetworkContextParamsPtr& input) {
    return input->enforce_chrome_ct_policy;
  }

  static decltype(::network::mojom::blink::NetworkContextParams::enable_expect_ct_reporting) enable_expect_ct_reporting(
      const ::network::mojom::blink::NetworkContextParamsPtr& input) {
    return input->enable_expect_ct_reporting;
  }

  static decltype(::network::mojom::blink::NetworkContextParams::sct_auditing_mode) sct_auditing_mode(
      const ::network::mojom::blink::NetworkContextParamsPtr& input) {
    return input->sct_auditing_mode;
  }

  static const decltype(::network::mojom::blink::NetworkContextParams::ct_policy)& ct_policy(
      const ::network::mojom::blink::NetworkContextParamsPtr& input) {
    return input->ct_policy;
  }

  static  decltype(::network::mojom::blink::NetworkContextParams::cert_verifier_params)& cert_verifier_params(
       ::network::mojom::blink::NetworkContextParamsPtr& input) {
    return input->cert_verifier_params;
  }

  static const decltype(::network::mojom::blink::NetworkContextParams::cookie_manager_params)& cookie_manager_params(
      const ::network::mojom::blink::NetworkContextParamsPtr& input) {
    return input->cookie_manager_params;
  }

  static  decltype(::network::mojom::blink::NetworkContextParams::cookie_manager)& cookie_manager(
       ::network::mojom::blink::NetworkContextParamsPtr& input) {
    return input->cookie_manager;
  }

  static decltype(::network::mojom::blink::NetworkContextParams::enable_domain_reliability) enable_domain_reliability(
      const ::network::mojom::blink::NetworkContextParamsPtr& input) {
    return input->enable_domain_reliability;
  }

  static const decltype(::network::mojom::blink::NetworkContextParams::domain_reliability_upload_reporter)& domain_reliability_upload_reporter(
      const ::network::mojom::blink::NetworkContextParamsPtr& input) {
    return input->domain_reliability_upload_reporter;
  }

  static decltype(::network::mojom::blink::NetworkContextParams::discard_domain_reliablity_uploads) discard_domain_reliablity_uploads(
      const ::network::mojom::blink::NetworkContextParamsPtr& input) {
    return input->discard_domain_reliablity_uploads;
  }

  static const decltype(::network::mojom::blink::NetworkContextParams::reporting_delivery_interval)& reporting_delivery_interval(
      const ::network::mojom::blink::NetworkContextParamsPtr& input) {
    return input->reporting_delivery_interval;
  }

  static decltype(::network::mojom::blink::NetworkContextParams::skip_reporting_send_permission_check) skip_reporting_send_permission_check(
      const ::network::mojom::blink::NetworkContextParamsPtr& input) {
    return input->skip_reporting_send_permission_check;
  }

  static const decltype(::network::mojom::blink::NetworkContextParams::cors_origin_access_list)& cors_origin_access_list(
      const ::network::mojom::blink::NetworkContextParamsPtr& input) {
    return input->cors_origin_access_list;
  }

  static const decltype(::network::mojom::blink::NetworkContextParams::cors_exempt_header_list)& cors_exempt_header_list(
      const ::network::mojom::blink::NetworkContextParamsPtr& input) {
    return input->cors_exempt_header_list;
  }

  static decltype(::network::mojom::blink::NetworkContextParams::allow_any_cors_exempt_header_for_browser) allow_any_cors_exempt_header_for_browser(
      const ::network::mojom::blink::NetworkContextParamsPtr& input) {
    return input->allow_any_cors_exempt_header_for_browser;
  }

  static const decltype(::network::mojom::blink::NetworkContextParams::hsts_policy_bypass_list)& hsts_policy_bypass_list(
      const ::network::mojom::blink::NetworkContextParamsPtr& input) {
    return input->hsts_policy_bypass_list;
  }

  static const decltype(::network::mojom::blink::NetworkContextParams::http_auth_static_network_context_params)& http_auth_static_network_context_params(
      const ::network::mojom::blink::NetworkContextParamsPtr& input) {
    return input->http_auth_static_network_context_params;
  }

  static decltype(::network::mojom::blink::NetworkContextParams::reset_http_cache_backend) reset_http_cache_backend(
      const ::network::mojom::blink::NetworkContextParamsPtr& input) {
    return input->reset_http_cache_backend;
  }

  static decltype(::network::mojom::blink::NetworkContextParams::split_auth_cache_by_network_isolation_key) split_auth_cache_by_network_isolation_key(
      const ::network::mojom::blink::NetworkContextParamsPtr& input) {
    return input->split_auth_cache_by_network_isolation_key;
  }

  static decltype(::network::mojom::blink::NetworkContextParams::require_network_isolation_key) require_network_isolation_key(
      const ::network::mojom::blink::NetworkContextParamsPtr& input) {
    return input->require_network_isolation_key;
  }

  static  decltype(::network::mojom::blink::NetworkContextParams::file_paths)& file_paths(
       ::network::mojom::blink::NetworkContextParamsPtr& input) {
    return input->file_paths;
  }

  static decltype(::network::mojom::blink::NetworkContextParams::block_trust_tokens) block_trust_tokens(
      const ::network::mojom::blink::NetworkContextParamsPtr& input) {
    return input->block_trust_tokens;
  }

  static const decltype(::network::mojom::blink::NetworkContextParams::first_party_sets_access_delegate_params)& first_party_sets_access_delegate_params(
      const ::network::mojom::blink::NetworkContextParamsPtr& input) {
    return input->first_party_sets_access_delegate_params;
  }

  static  decltype(::network::mojom::blink::NetworkContextParams::first_party_sets_access_delegate_receiver)& first_party_sets_access_delegate_receiver(
       ::network::mojom::blink::NetworkContextParamsPtr& input) {
    return input->first_party_sets_access_delegate_receiver;
  }

  static bool Read(::network::mojom::blink::NetworkContextParams::DataView input, ::network::mojom::blink::NetworkContextParamsPtr* output);
};


template <>
struct BLINK_PLATFORM_EXPORT StructTraits<::network::mojom::blink::NetworkConditions::DataView,
                                         ::network::mojom::blink::NetworkConditionsPtr> {
  static bool IsNull(const ::network::mojom::blink::NetworkConditionsPtr& input) { return !input; }
  static void SetToNull(::network::mojom::blink::NetworkConditionsPtr* output) { output->reset(); }

  static decltype(::network::mojom::blink::NetworkConditions::offline) offline(
      const ::network::mojom::blink::NetworkConditionsPtr& input) {
    return input->offline;
  }

  static const decltype(::network::mojom::blink::NetworkConditions::latency)& latency(
      const ::network::mojom::blink::NetworkConditionsPtr& input) {
    return input->latency;
  }

  static decltype(::network::mojom::blink::NetworkConditions::download_throughput) download_throughput(
      const ::network::mojom::blink::NetworkConditionsPtr& input) {
    return input->download_throughput;
  }

  static decltype(::network::mojom::blink::NetworkConditions::upload_throughput) upload_throughput(
      const ::network::mojom::blink::NetworkConditionsPtr& input) {
    return input->upload_throughput;
  }

  static bool Read(::network::mojom::blink::NetworkConditions::DataView input, ::network::mojom::blink::NetworkConditionsPtr* output);
};


template <>
struct BLINK_PLATFORM_EXPORT StructTraits<::network::mojom::blink::ClearDataFilter::DataView,
                                         ::network::mojom::blink::ClearDataFilterPtr> {
  static bool IsNull(const ::network::mojom::blink::ClearDataFilterPtr& input) { return !input; }
  static void SetToNull(::network::mojom::blink::ClearDataFilterPtr* output) { output->reset(); }

  static decltype(::network::mojom::blink::ClearDataFilter::type) type(
      const ::network::mojom::blink::ClearDataFilterPtr& input) {
    return input->type;
  }

  static const decltype(::network::mojom::blink::ClearDataFilter::domains)& domains(
      const ::network::mojom::blink::ClearDataFilterPtr& input) {
    return input->domains;
  }

  static const decltype(::network::mojom::blink::ClearDataFilter::origins)& origins(
      const ::network::mojom::blink::ClearDataFilterPtr& input) {
    return input->origins;
  }

  static bool Read(::network::mojom::blink::ClearDataFilter::DataView input, ::network::mojom::blink::ClearDataFilterPtr* output);
};


template <>
struct BLINK_PLATFORM_EXPORT StructTraits<::network::mojom::blink::SignedExchangeReport::DataView,
                                         ::network::mojom::blink::SignedExchangeReportPtr> {
  static bool IsNull(const ::network::mojom::blink::SignedExchangeReportPtr& input) { return !input; }
  static void SetToNull(::network::mojom::blink::SignedExchangeReportPtr* output) { output->reset(); }

  static decltype(::network::mojom::blink::SignedExchangeReport::success) success(
      const ::network::mojom::blink::SignedExchangeReportPtr& input) {
    return input->success;
  }

  static const decltype(::network::mojom::blink::SignedExchangeReport::type)& type(
      const ::network::mojom::blink::SignedExchangeReportPtr& input) {
    return input->type;
  }

  static const decltype(::network::mojom::blink::SignedExchangeReport::outer_url)& outer_url(
      const ::network::mojom::blink::SignedExchangeReportPtr& input) {
    return input->outer_url;
  }

  static const decltype(::network::mojom::blink::SignedExchangeReport::inner_url)& inner_url(
      const ::network::mojom::blink::SignedExchangeReportPtr& input) {
    return input->inner_url;
  }

  static const decltype(::network::mojom::blink::SignedExchangeReport::cert_url)& cert_url(
      const ::network::mojom::blink::SignedExchangeReportPtr& input) {
    return input->cert_url;
  }

  static const decltype(::network::mojom::blink::SignedExchangeReport::referrer)& referrer(
      const ::network::mojom::blink::SignedExchangeReportPtr& input) {
    return input->referrer;
  }

  static const decltype(::network::mojom::blink::SignedExchangeReport::server_ip_address)& server_ip_address(
      const ::network::mojom::blink::SignedExchangeReportPtr& input) {
    return input->server_ip_address;
  }

  static const decltype(::network::mojom::blink::SignedExchangeReport::protocol)& protocol(
      const ::network::mojom::blink::SignedExchangeReportPtr& input) {
    return input->protocol;
  }

  static const decltype(::network::mojom::blink::SignedExchangeReport::method)& method(
      const ::network::mojom::blink::SignedExchangeReportPtr& input) {
    return input->method;
  }

  static decltype(::network::mojom::blink::SignedExchangeReport::status_code) status_code(
      const ::network::mojom::blink::SignedExchangeReportPtr& input) {
    return input->status_code;
  }

  static const decltype(::network::mojom::blink::SignedExchangeReport::elapsed_time)& elapsed_time(
      const ::network::mojom::blink::SignedExchangeReportPtr& input) {
    return input->elapsed_time;
  }

  static bool Read(::network::mojom::blink::SignedExchangeReport::DataView input, ::network::mojom::blink::SignedExchangeReportPtr* output);
};


template <>
struct BLINK_PLATFORM_EXPORT StructTraits<::network::mojom::blink::URLLoaderFactoryOverride::DataView,
                                         ::network::mojom::blink::URLLoaderFactoryOverridePtr> {
  static bool IsNull(const ::network::mojom::blink::URLLoaderFactoryOverridePtr& input) { return !input; }
  static void SetToNull(::network::mojom::blink::URLLoaderFactoryOverridePtr* output) { output->reset(); }

  static  decltype(::network::mojom::blink::URLLoaderFactoryOverride::overriding_factory)& overriding_factory(
       ::network::mojom::blink::URLLoaderFactoryOverridePtr& input) {
    return input->overriding_factory;
  }

  static  decltype(::network::mojom::blink::URLLoaderFactoryOverride::overridden_factory_receiver)& overridden_factory_receiver(
       ::network::mojom::blink::URLLoaderFactoryOverridePtr& input) {
    return input->overridden_factory_receiver;
  }

  static decltype(::network::mojom::blink::URLLoaderFactoryOverride::skip_cors_enabled_scheme_check) skip_cors_enabled_scheme_check(
      const ::network::mojom::blink::URLLoaderFactoryOverridePtr& input) {
    return input->skip_cors_enabled_scheme_check;
  }

  static bool Read(::network::mojom::blink::URLLoaderFactoryOverride::DataView input, ::network::mojom::blink::URLLoaderFactoryOverridePtr* output);
};


template <>
struct BLINK_PLATFORM_EXPORT StructTraits<::network::mojom::blink::URLLoaderFactoryParams::DataView,
                                         ::network::mojom::blink::URLLoaderFactoryParamsPtr> {
  static bool IsNull(const ::network::mojom::blink::URLLoaderFactoryParamsPtr& input) { return !input; }
  static void SetToNull(::network::mojom::blink::URLLoaderFactoryParamsPtr* output) { output->reset(); }

  static decltype(::network::mojom::blink::URLLoaderFactoryParams::process_id) process_id(
      const ::network::mojom::blink::URLLoaderFactoryParamsPtr& input) {
    return input->process_id;
  }

  static const decltype(::network::mojom::blink::URLLoaderFactoryParams::request_initiator_origin_lock)& request_initiator_origin_lock(
      const ::network::mojom::blink::URLLoaderFactoryParamsPtr& input) {
    return input->request_initiator_origin_lock;
  }

  static decltype(::network::mojom::blink::URLLoaderFactoryParams::is_corb_enabled) is_corb_enabled(
      const ::network::mojom::blink::URLLoaderFactoryParamsPtr& input) {
    return input->is_corb_enabled;
  }

  static decltype(::network::mojom::blink::URLLoaderFactoryParams::ignore_isolated_world_origin) ignore_isolated_world_origin(
      const ::network::mojom::blink::URLLoaderFactoryParamsPtr& input) {
    return input->ignore_isolated_world_origin;
  }

  static decltype(::network::mojom::blink::URLLoaderFactoryParams::unsafe_non_webby_initiator) unsafe_non_webby_initiator(
      const ::network::mojom::blink::URLLoaderFactoryParamsPtr& input) {
    return input->unsafe_non_webby_initiator;
  }

  static decltype(::network::mojom::blink::URLLoaderFactoryParams::disable_web_security) disable_web_security(
      const ::network::mojom::blink::URLLoaderFactoryParamsPtr& input) {
    return input->disable_web_security;
  }

  static  decltype(::network::mojom::blink::URLLoaderFactoryParams::header_client)& header_client(
       ::network::mojom::blink::URLLoaderFactoryParamsPtr& input) {
    return input->header_client;
  }

  static const decltype(::network::mojom::blink::URLLoaderFactoryParams::isolation_info)& isolation_info(
      const ::network::mojom::blink::URLLoaderFactoryParamsPtr& input) {
    return input->isolation_info;
  }

  static decltype(::network::mojom::blink::URLLoaderFactoryParams::disable_secure_dns) disable_secure_dns(
      const ::network::mojom::blink::URLLoaderFactoryParamsPtr& input) {
    return input->disable_secure_dns;
  }

  static decltype(::network::mojom::blink::URLLoaderFactoryParams::is_trusted) is_trusted(
      const ::network::mojom::blink::URLLoaderFactoryParamsPtr& input) {
    return input->is_trusted;
  }

  static decltype(::network::mojom::blink::URLLoaderFactoryParams::automatically_assign_isolation_info) automatically_assign_isolation_info(
      const ::network::mojom::blink::URLLoaderFactoryParamsPtr& input) {
    return input->automatically_assign_isolation_info;
  }

  static decltype(::network::mojom::blink::URLLoaderFactoryParams::provide_loading_state_updates) provide_loading_state_updates(
      const ::network::mojom::blink::URLLoaderFactoryParamsPtr& input) {
    return input->provide_loading_state_updates;
  }

  static const decltype(::network::mojom::blink::URLLoaderFactoryParams::top_frame_id)& top_frame_id(
      const ::network::mojom::blink::URLLoaderFactoryParamsPtr& input) {
    return input->top_frame_id;
  }

  static  decltype(::network::mojom::blink::URLLoaderFactoryParams::factory_override)& factory_override(
       ::network::mojom::blink::URLLoaderFactoryParamsPtr& input) {
    return input->factory_override;
  }

  static const decltype(::network::mojom::blink::URLLoaderFactoryParams::client_security_state)& client_security_state(
      const ::network::mojom::blink::URLLoaderFactoryParamsPtr& input) {
    return input->client_security_state;
  }

  static  decltype(::network::mojom::blink::URLLoaderFactoryParams::coep_reporter)& coep_reporter(
       ::network::mojom::blink::URLLoaderFactoryParamsPtr& input) {
    return input->coep_reporter;
  }

  static  decltype(::network::mojom::blink::URLLoaderFactoryParams::cookie_observer)& cookie_observer(
       ::network::mojom::blink::URLLoaderFactoryParamsPtr& input) {
    return input->cookie_observer;
  }

  static  decltype(::network::mojom::blink::URLLoaderFactoryParams::url_loader_network_observer)& url_loader_network_observer(
       ::network::mojom::blink::URLLoaderFactoryParamsPtr& input) {
    return input->url_loader_network_observer;
  }

  static  decltype(::network::mojom::blink::URLLoaderFactoryParams::devtools_observer)& devtools_observer(
       ::network::mojom::blink::URLLoaderFactoryParamsPtr& input) {
    return input->devtools_observer;
  }

  static decltype(::network::mojom::blink::URLLoaderFactoryParams::trust_token_redemption_policy) trust_token_redemption_policy(
      const ::network::mojom::blink::URLLoaderFactoryParamsPtr& input) {
    return input->trust_token_redemption_policy;
  }

  static const decltype(::network::mojom::blink::URLLoaderFactoryParams::debug_tag)& debug_tag(
      const ::network::mojom::blink::URLLoaderFactoryParamsPtr& input) {
    return input->debug_tag;
  }

  static bool Read(::network::mojom::blink::URLLoaderFactoryParams::DataView input, ::network::mojom::blink::URLLoaderFactoryParamsPtr* output);
};

}  // namespace mojo

#endif  // SERVICES_NETWORK_PUBLIC_MOJOM_NETWORK_CONTEXT_MOJOM_BLINK_H_