// services/network/public/mojom/trust_tokens.mojom-shared.h is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2016 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef SERVICES_NETWORK_PUBLIC_MOJOM_TRUST_TOKENS_MOJOM_SHARED_H_
#define SERVICES_NETWORK_PUBLIC_MOJOM_TRUST_TOKENS_MOJOM_SHARED_H_

#include <stdint.h>

#include <functional>
#include <iosfwd>
#include <type_traits>
#include <utility>
#include "mojo/public/cpp/bindings/array_data_view.h"
#include "mojo/public/cpp/bindings/enum_traits.h"
#include "mojo/public/cpp/bindings/interface_data_view.h"
#include "mojo/public/cpp/bindings/lib/bindings_internal.h"
#include "mojo/public/cpp/bindings/lib/serialization.h"
#include "mojo/public/cpp/bindings/map_data_view.h"
#include "mojo/public/cpp/bindings/string_data_view.h"

#include "third_party/perfetto/include/perfetto/tracing/traced_value_forward.h"

#include "services/network/public/mojom/trust_tokens.mojom-shared-internal.h"
#include "url/mojom/origin.mojom-shared.h"
#include "mojo/public/mojom/base/time.mojom-shared.h"
#include "mojo/public/cpp/bindings/lib/interface_serialization.h"






namespace network {
namespace mojom {
class TrustTokenParamsDataView;

class HasTrustTokensResultDataView;

class TrustTokenVerificationKeyDataView;

class TrustTokenKeyCommitmentResultDataView;

class FulfillTrustTokenIssuanceRequestDataView;

class FulfillTrustTokenIssuanceAnswerDataView;

class TrustTokenOperationResultDataView;

class StoredTrustTokensForIssuerDataView;



}  // namespace mojom
}  // namespace network

namespace mojo {
namespace internal {

template <>
struct MojomTypeTraits<::network::mojom::TrustTokenParamsDataView> {
  using Data = ::network::mojom::internal::TrustTokenParams_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::network::mojom::HasTrustTokensResultDataView> {
  using Data = ::network::mojom::internal::HasTrustTokensResult_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::network::mojom::TrustTokenVerificationKeyDataView> {
  using Data = ::network::mojom::internal::TrustTokenVerificationKey_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::network::mojom::TrustTokenKeyCommitmentResultDataView> {
  using Data = ::network::mojom::internal::TrustTokenKeyCommitmentResult_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::network::mojom::FulfillTrustTokenIssuanceRequestDataView> {
  using Data = ::network::mojom::internal::FulfillTrustTokenIssuanceRequest_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::network::mojom::FulfillTrustTokenIssuanceAnswerDataView> {
  using Data = ::network::mojom::internal::FulfillTrustTokenIssuanceAnswer_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::network::mojom::TrustTokenOperationResultDataView> {
  using Data = ::network::mojom::internal::TrustTokenOperationResult_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::network::mojom::StoredTrustTokensForIssuerDataView> {
  using Data = ::network::mojom::internal::StoredTrustTokensForIssuer_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

}  // namespace internal
}  // namespace mojo


namespace network {
namespace mojom {


enum class TrustTokenProtocolVersion : int32_t {
  
  kTrustTokenV3Pmb = 0,
  
  kTrustTokenV3Voprf = 1,
  kMinValue = 0,
  kMaxValue = 1,
};

 std::ostream& operator<<(std::ostream& os, TrustTokenProtocolVersion value);
inline bool IsKnownEnumValue(TrustTokenProtocolVersion value) {
  return internal::TrustTokenProtocolVersion_Data::IsKnownValue(
      static_cast<int32_t>(value));
}


enum class TrustTokenOperationStatus : int32_t {
  
  kOk = 0,
  
  kInvalidArgument = 1,
  
  kFailedPrecondition = 2,
  
  kResourceExhausted = 3,
  
  kAlreadyExists = 4,
  
  kUnavailable = 5,
  
  kBadResponse = 6,
  
  kInternalError = 7,
  
  kUnknownError = 8,
  
  kOperationSuccessfullyFulfilledLocally = 9,
  kMinValue = 0,
  kMaxValue = 9,
};

 std::ostream& operator<<(std::ostream& os, TrustTokenOperationStatus value);
inline bool IsKnownEnumValue(TrustTokenOperationStatus value) {
  return internal::TrustTokenOperationStatus_Data::IsKnownValue(
      static_cast<int32_t>(value));
}


enum class TrustTokenOperationType : int32_t {
  
  kIssuance = 0,
  
  kRedemption = 1,
  
  kSigning = 2,
  kMinValue = 0,
  kMaxValue = 2,
};

 std::ostream& operator<<(std::ostream& os, TrustTokenOperationType value);
inline bool IsKnownEnumValue(TrustTokenOperationType value) {
  return internal::TrustTokenOperationType_Data::IsKnownValue(
      static_cast<int32_t>(value));
}


enum class TrustTokenRefreshPolicy : int32_t {
  
  kUseCached = 0,
  
  kRefresh = 1,
  kMinValue = 0,
  kMaxValue = 1,
};

 std::ostream& operator<<(std::ostream& os, TrustTokenRefreshPolicy value);
inline bool IsKnownEnumValue(TrustTokenRefreshPolicy value) {
  return internal::TrustTokenRefreshPolicy_Data::IsKnownValue(
      static_cast<int32_t>(value));
}


enum class TrustTokenSignRequestData : int32_t {
  
  kOmit = 0,
  
  kHeadersOnly = 1,
  
  kInclude = 2,
  kMinValue = 0,
  kMaxValue = 2,
};

 std::ostream& operator<<(std::ostream& os, TrustTokenSignRequestData value);
inline bool IsKnownEnumValue(TrustTokenSignRequestData value) {
  return internal::TrustTokenSignRequestData_Data::IsKnownValue(
      static_cast<int32_t>(value));
}


enum class DeleteStoredTrustTokensStatus : int32_t {
  
  kSuccessTokensDeleted = 0,
  
  kSuccessNoTokensDeleted = 1,
  
  kFailureFeatureDisabled = 2,
  
  kFailureInvalidOrigin = 3,
  kMinValue = 0,
  kMaxValue = 3,
};

 std::ostream& operator<<(std::ostream& os, DeleteStoredTrustTokensStatus value);
inline bool IsKnownEnumValue(DeleteStoredTrustTokensStatus value) {
  return internal::DeleteStoredTrustTokensStatus_Data::IsKnownValue(
      static_cast<int32_t>(value));
}


enum class TrustTokenKeyCommitmentResult_Os : int32_t {
  
  kAndroid = 0,
  kMinValue = 0,
  kMaxValue = 0,
};

 std::ostream& operator<<(std::ostream& os, TrustTokenKeyCommitmentResult_Os value);
inline bool IsKnownEnumValue(TrustTokenKeyCommitmentResult_Os value) {
  return internal::TrustTokenKeyCommitmentResult_Os_Data::IsKnownValue(
      static_cast<int32_t>(value));
}


enum class TrustTokenKeyCommitmentResult_UnavailableLocalOperationFallback : int32_t {
  
  kWebIssuance = 0,
  
  kReturnWithError = 1,
  kMinValue = 0,
  kMaxValue = 1,
};

 std::ostream& operator<<(std::ostream& os, TrustTokenKeyCommitmentResult_UnavailableLocalOperationFallback value);
inline bool IsKnownEnumValue(TrustTokenKeyCommitmentResult_UnavailableLocalOperationFallback value) {
  return internal::TrustTokenKeyCommitmentResult_UnavailableLocalOperationFallback_Data::IsKnownValue(
      static_cast<int32_t>(value));
}


enum class FulfillTrustTokenIssuanceAnswer_Status : int32_t {
  
  kOk = 0,
  
  kNotFound = 1,
  
  kUnknownError = 2,
  kMinValue = 0,
  kMaxValue = 2,
};

 std::ostream& operator<<(std::ostream& os, FulfillTrustTokenIssuanceAnswer_Status value);
inline bool IsKnownEnumValue(FulfillTrustTokenIssuanceAnswer_Status value) {
  return internal::FulfillTrustTokenIssuanceAnswer_Status_Data::IsKnownValue(
      static_cast<int32_t>(value));
}
// Interface base classes. They are used for type safety check.
class TrustTokenQueryAnswererInterfaceBase {};

using TrustTokenQueryAnswererPtrDataView =
    mojo::InterfacePtrDataView<TrustTokenQueryAnswererInterfaceBase>;
using TrustTokenQueryAnswererRequestDataView =
    mojo::InterfaceRequestDataView<TrustTokenQueryAnswererInterfaceBase>;
using TrustTokenQueryAnswererAssociatedPtrInfoDataView =
    mojo::AssociatedInterfacePtrInfoDataView<TrustTokenQueryAnswererInterfaceBase>;
using TrustTokenQueryAnswererAssociatedRequestDataView =
    mojo::AssociatedInterfaceRequestDataView<TrustTokenQueryAnswererInterfaceBase>;


class TrustTokenParamsDataView {
 public:
  TrustTokenParamsDataView() = default;

  TrustTokenParamsDataView(
      internal::TrustTokenParams_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  template <typename UserType>
  [[nodiscard]] bool ReadType(UserType* output) const {
    auto data_value = data_->type;
    return mojo::internal::Deserialize<::network::mojom::TrustTokenOperationType>(
        data_value, output);
  }
  TrustTokenOperationType type() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::network::mojom::TrustTokenOperationType>(data_->type));
  }
  template <typename UserType>
  [[nodiscard]] bool ReadRefreshPolicy(UserType* output) const {
    auto data_value = data_->refresh_policy;
    return mojo::internal::Deserialize<::network::mojom::TrustTokenRefreshPolicy>(
        data_value, output);
  }
  TrustTokenRefreshPolicy refresh_policy() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::network::mojom::TrustTokenRefreshPolicy>(data_->refresh_policy));
  }
  inline void GetCustomKeyCommitmentDataView(
      mojo::StringDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadCustomKeyCommitment(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        mojo::StringDataView, UserType>(),
    "Attempting to read the optional `custom_key_commitment` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadCustomKeyCommitment` instead "
    "of `ReadCustomKeyCommitment if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->custom_key_commitment.Get();
    return mojo::internal::Deserialize<mojo::StringDataView>(
        pointer, output, message_);
  }
  template <typename UserType>
  [[nodiscard]] bool ReadSignRequestData(UserType* output) const {
    auto data_value = data_->sign_request_data;
    return mojo::internal::Deserialize<::network::mojom::TrustTokenSignRequestData>(
        data_value, output);
  }
  TrustTokenSignRequestData sign_request_data() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::network::mojom::TrustTokenSignRequestData>(data_->sign_request_data));
  }
  bool include_timestamp_header() const {
    return data_->include_timestamp_header;
  }
  inline void GetIssuersDataView(
      mojo::ArrayDataView<::url::mojom::OriginDataView>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadIssuers(UserType* output) {
    
    auto* pointer = data_->issuers.Get();
    return mojo::internal::Deserialize<mojo::ArrayDataView<::url::mojom::OriginDataView>>(
        pointer, output, message_);
  }
  inline void GetAdditionalSignedHeadersDataView(
      mojo::ArrayDataView<mojo::StringDataView>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadAdditionalSignedHeaders(UserType* output) {
    
    auto* pointer = data_->additional_signed_headers.Get();
    return mojo::internal::Deserialize<mojo::ArrayDataView<mojo::StringDataView>>(
        pointer, output, message_);
  }
  inline void GetPossiblyUnsafeAdditionalSigningDataDataView(
      mojo::StringDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadPossiblyUnsafeAdditionalSigningData(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        mojo::StringDataView, UserType>(),
    "Attempting to read the optional `possibly_unsafe_additional_signing_data` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadPossiblyUnsafeAdditionalSigningData` instead "
    "of `ReadPossiblyUnsafeAdditionalSigningData if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->possibly_unsafe_additional_signing_data.Get();
    return mojo::internal::Deserialize<mojo::StringDataView>(
        pointer, output, message_);
  }
 private:
  internal::TrustTokenParams_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class HasTrustTokensResultDataView {
 public:
  HasTrustTokensResultDataView() = default;

  HasTrustTokensResultDataView(
      internal::HasTrustTokensResult_Data* data,
      mojo::Message* message)
      : data_(data) {}

  bool is_null() const { return !data_; }
  template <typename UserType>
  [[nodiscard]] bool ReadStatus(UserType* output) const {
    auto data_value = data_->status;
    return mojo::internal::Deserialize<::network::mojom::TrustTokenOperationStatus>(
        data_value, output);
  }
  TrustTokenOperationStatus status() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::network::mojom::TrustTokenOperationStatus>(data_->status));
  }
  bool has_trust_tokens() const {
    return data_->has_trust_tokens;
  }
 private:
  internal::HasTrustTokensResult_Data* data_ = nullptr;
};



class TrustTokenVerificationKeyDataView {
 public:
  TrustTokenVerificationKeyDataView() = default;

  TrustTokenVerificationKeyDataView(
      internal::TrustTokenVerificationKey_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  inline void GetBodyDataView(
      mojo::StringDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadBody(UserType* output) {
    
    auto* pointer = data_->body.Get();
    return mojo::internal::Deserialize<mojo::StringDataView>(
        pointer, output, message_);
  }
  inline void GetExpiryDataView(
      ::mojo_base::mojom::TimeDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadExpiry(UserType* output) {
    
    auto* pointer = data_->expiry.Get();
    return mojo::internal::Deserialize<::mojo_base::mojom::TimeDataView>(
        pointer, output, message_);
  }
 private:
  internal::TrustTokenVerificationKey_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class TrustTokenKeyCommitmentResultDataView {
 public:
  TrustTokenKeyCommitmentResultDataView() = default;

  TrustTokenKeyCommitmentResultDataView(
      internal::TrustTokenKeyCommitmentResult_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  template <typename UserType>
  [[nodiscard]] bool ReadProtocolVersion(UserType* output) const {
    auto data_value = data_->protocol_version;
    return mojo::internal::Deserialize<::network::mojom::TrustTokenProtocolVersion>(
        data_value, output);
  }
  TrustTokenProtocolVersion protocol_version() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::network::mojom::TrustTokenProtocolVersion>(data_->protocol_version));
  }
  int32_t id() const {
    return data_->id;
  }
  int32_t batch_size() const {
    return data_->batch_size;
  }
  inline void GetKeysDataView(
      mojo::ArrayDataView<TrustTokenVerificationKeyDataView>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadKeys(UserType* output) {
    
    auto* pointer = data_->keys.Get();
    return mojo::internal::Deserialize<mojo::ArrayDataView<::network::mojom::TrustTokenVerificationKeyDataView>>(
        pointer, output, message_);
  }
  inline void GetRequestIssuanceLocallyOnDataView(
      mojo::ArrayDataView<TrustTokenKeyCommitmentResult_Os>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadRequestIssuanceLocallyOn(UserType* output) {
    
    auto* pointer = data_->request_issuance_locally_on.Get();
    return mojo::internal::Deserialize<mojo::ArrayDataView<::network::mojom::TrustTokenKeyCommitmentResult_Os>>(
        pointer, output, message_);
  }
  template <typename UserType>
  [[nodiscard]] bool ReadUnavailableLocalOperationFallback(UserType* output) const {
    auto data_value = data_->unavailable_local_operation_fallback;
    return mojo::internal::Deserialize<::network::mojom::TrustTokenKeyCommitmentResult_UnavailableLocalOperationFallback>(
        data_value, output);
  }
  TrustTokenKeyCommitmentResult_UnavailableLocalOperationFallback unavailable_local_operation_fallback() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::network::mojom::TrustTokenKeyCommitmentResult_UnavailableLocalOperationFallback>(data_->unavailable_local_operation_fallback));
  }
 private:
  internal::TrustTokenKeyCommitmentResult_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class FulfillTrustTokenIssuanceRequestDataView {
 public:
  FulfillTrustTokenIssuanceRequestDataView() = default;

  FulfillTrustTokenIssuanceRequestDataView(
      internal::FulfillTrustTokenIssuanceRequest_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  inline void GetIssuerDataView(
      ::url::mojom::OriginDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadIssuer(UserType* output) {
    
    auto* pointer = data_->issuer.Get();
    return mojo::internal::Deserialize<::url::mojom::OriginDataView>(
        pointer, output, message_);
  }
  inline void GetRequestDataView(
      mojo::StringDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadRequest(UserType* output) {
    
    auto* pointer = data_->request.Get();
    return mojo::internal::Deserialize<mojo::StringDataView>(
        pointer, output, message_);
  }
 private:
  internal::FulfillTrustTokenIssuanceRequest_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class FulfillTrustTokenIssuanceAnswerDataView {
 public:
  FulfillTrustTokenIssuanceAnswerDataView() = default;

  FulfillTrustTokenIssuanceAnswerDataView(
      internal::FulfillTrustTokenIssuanceAnswer_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  template <typename UserType>
  [[nodiscard]] bool ReadStatus(UserType* output) const {
    auto data_value = data_->status;
    return mojo::internal::Deserialize<::network::mojom::FulfillTrustTokenIssuanceAnswer_Status>(
        data_value, output);
  }
  FulfillTrustTokenIssuanceAnswer_Status status() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::network::mojom::FulfillTrustTokenIssuanceAnswer_Status>(data_->status));
  }
  inline void GetResponseDataView(
      mojo::StringDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadResponse(UserType* output) {
    
    auto* pointer = data_->response.Get();
    return mojo::internal::Deserialize<mojo::StringDataView>(
        pointer, output, message_);
  }
 private:
  internal::FulfillTrustTokenIssuanceAnswer_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class TrustTokenOperationResultDataView {
 public:
  TrustTokenOperationResultDataView() = default;

  TrustTokenOperationResultDataView(
      internal::TrustTokenOperationResult_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  template <typename UserType>
  [[nodiscard]] bool ReadType(UserType* output) const {
    auto data_value = data_->type;
    return mojo::internal::Deserialize<::network::mojom::TrustTokenOperationType>(
        data_value, output);
  }
  TrustTokenOperationType type() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::network::mojom::TrustTokenOperationType>(data_->type));
  }
  template <typename UserType>
  [[nodiscard]] bool ReadStatus(UserType* output) const {
    auto data_value = data_->status;
    return mojo::internal::Deserialize<::network::mojom::TrustTokenOperationStatus>(
        data_value, output);
  }
  TrustTokenOperationStatus status() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::network::mojom::TrustTokenOperationStatus>(data_->status));
  }
  inline void GetIssuerDataView(
      ::url::mojom::OriginDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadIssuer(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::url::mojom::OriginDataView, UserType>(),
    "Attempting to read the optional `issuer` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadIssuer` instead "
    "of `ReadIssuer if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->issuer.Get();
    return mojo::internal::Deserialize<::url::mojom::OriginDataView>(
        pointer, output, message_);
  }
  inline void GetTopLevelOriginDataView(
      ::url::mojom::OriginDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadTopLevelOrigin(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::url::mojom::OriginDataView, UserType>(),
    "Attempting to read the optional `top_level_origin` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadTopLevelOrigin` instead "
    "of `ReadTopLevelOrigin if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->top_level_origin.Get();
    return mojo::internal::Deserialize<::url::mojom::OriginDataView>(
        pointer, output, message_);
  }
  int32_t issued_token_count() const {
    return data_->issued_token_count;
  }
 private:
  internal::TrustTokenOperationResult_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class StoredTrustTokensForIssuerDataView {
 public:
  StoredTrustTokensForIssuerDataView() = default;

  StoredTrustTokensForIssuerDataView(
      internal::StoredTrustTokensForIssuer_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  inline void GetIssuerDataView(
      ::url::mojom::OriginDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadIssuer(UserType* output) {
    
    auto* pointer = data_->issuer.Get();
    return mojo::internal::Deserialize<::url::mojom::OriginDataView>(
        pointer, output, message_);
  }
  int32_t count() const {
    return data_->count;
  }
 private:
  internal::StoredTrustTokensForIssuer_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



}  // namespace mojom
}  // namespace network

namespace std {

template <>
struct hash<::network::mojom::TrustTokenProtocolVersion>
    : public mojo::internal::EnumHashImpl<::network::mojom::TrustTokenProtocolVersion> {};

template <>
struct hash<::network::mojom::TrustTokenOperationStatus>
    : public mojo::internal::EnumHashImpl<::network::mojom::TrustTokenOperationStatus> {};

template <>
struct hash<::network::mojom::TrustTokenOperationType>
    : public mojo::internal::EnumHashImpl<::network::mojom::TrustTokenOperationType> {};

template <>
struct hash<::network::mojom::TrustTokenRefreshPolicy>
    : public mojo::internal::EnumHashImpl<::network::mojom::TrustTokenRefreshPolicy> {};

template <>
struct hash<::network::mojom::TrustTokenSignRequestData>
    : public mojo::internal::EnumHashImpl<::network::mojom::TrustTokenSignRequestData> {};

template <>
struct hash<::network::mojom::DeleteStoredTrustTokensStatus>
    : public mojo::internal::EnumHashImpl<::network::mojom::DeleteStoredTrustTokensStatus> {};

template <>
struct hash<::network::mojom::TrustTokenKeyCommitmentResult_Os>
    : public mojo::internal::EnumHashImpl<::network::mojom::TrustTokenKeyCommitmentResult_Os> {};

template <>
struct hash<::network::mojom::TrustTokenKeyCommitmentResult_UnavailableLocalOperationFallback>
    : public mojo::internal::EnumHashImpl<::network::mojom::TrustTokenKeyCommitmentResult_UnavailableLocalOperationFallback> {};

template <>
struct hash<::network::mojom::FulfillTrustTokenIssuanceAnswer_Status>
    : public mojo::internal::EnumHashImpl<::network::mojom::FulfillTrustTokenIssuanceAnswer_Status> {};

}  // namespace std

namespace mojo {


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::network::mojom::TrustTokenProtocolVersion, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::network::mojom::TrustTokenProtocolVersion, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::network::mojom::TrustTokenProtocolVersion>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::network::mojom::TrustTokenOperationStatus, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::network::mojom::TrustTokenOperationStatus, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::network::mojom::TrustTokenOperationStatus>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::network::mojom::TrustTokenOperationType, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::network::mojom::TrustTokenOperationType, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::network::mojom::TrustTokenOperationType>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::network::mojom::TrustTokenRefreshPolicy, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::network::mojom::TrustTokenRefreshPolicy, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::network::mojom::TrustTokenRefreshPolicy>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::network::mojom::TrustTokenSignRequestData, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::network::mojom::TrustTokenSignRequestData, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::network::mojom::TrustTokenSignRequestData>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::network::mojom::DeleteStoredTrustTokensStatus, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::network::mojom::DeleteStoredTrustTokensStatus, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::network::mojom::DeleteStoredTrustTokensStatus>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::network::mojom::TrustTokenKeyCommitmentResult_Os, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::network::mojom::TrustTokenKeyCommitmentResult_Os, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::network::mojom::TrustTokenKeyCommitmentResult_Os>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::network::mojom::TrustTokenKeyCommitmentResult_UnavailableLocalOperationFallback, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::network::mojom::TrustTokenKeyCommitmentResult_UnavailableLocalOperationFallback, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::network::mojom::TrustTokenKeyCommitmentResult_UnavailableLocalOperationFallback>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::network::mojom::FulfillTrustTokenIssuanceAnswer_Status, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::network::mojom::FulfillTrustTokenIssuanceAnswer_Status, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::network::mojom::FulfillTrustTokenIssuanceAnswer_Status>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::network::mojom::TrustTokenParamsDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::network::mojom::TrustTokenParamsDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::network::mojom::internal::TrustTokenParams_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    mojo::internal::Serialize<::network::mojom::TrustTokenOperationType>(
        Traits::type(input), &fragment->type);
    mojo::internal::Serialize<::network::mojom::TrustTokenRefreshPolicy>(
        Traits::refresh_policy(input), &fragment->refresh_policy);
    decltype(Traits::custom_key_commitment(input)) in_custom_key_commitment = Traits::custom_key_commitment(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->custom_key_commitment)::BaseType> custom_key_commitment_fragment(
            fragment.message());
    mojo::internal::Serialize<mojo::StringDataView>(
        in_custom_key_commitment, custom_key_commitment_fragment);
    fragment->custom_key_commitment.Set(
        custom_key_commitment_fragment.is_null() ? nullptr : custom_key_commitment_fragment.data());
    mojo::internal::Serialize<::network::mojom::TrustTokenSignRequestData>(
        Traits::sign_request_data(input), &fragment->sign_request_data);
    fragment->include_timestamp_header = Traits::include_timestamp_header(input);
    decltype(Traits::issuers(input)) in_issuers = Traits::issuers(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->issuers)::BaseType>
        issuers_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams issuers_validate_params(
        0, false, nullptr);
    mojo::internal::Serialize<mojo::ArrayDataView<::url::mojom::OriginDataView>>(
        in_issuers, issuers_fragment, &issuers_validate_params);
    fragment->issuers.Set(
        issuers_fragment.is_null() ? nullptr : issuers_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->issuers.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null issuers in TrustTokenParams struct");
    decltype(Traits::additional_signed_headers(input)) in_additional_signed_headers = Traits::additional_signed_headers(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->additional_signed_headers)::BaseType>
        additional_signed_headers_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams additional_signed_headers_validate_params(
        0, false, new mojo::internal::ContainerValidateParams(0, false, nullptr));
    mojo::internal::Serialize<mojo::ArrayDataView<mojo::StringDataView>>(
        in_additional_signed_headers, additional_signed_headers_fragment, &additional_signed_headers_validate_params);
    fragment->additional_signed_headers.Set(
        additional_signed_headers_fragment.is_null() ? nullptr : additional_signed_headers_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->additional_signed_headers.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null additional_signed_headers in TrustTokenParams struct");
    decltype(Traits::possibly_unsafe_additional_signing_data(input)) in_possibly_unsafe_additional_signing_data = Traits::possibly_unsafe_additional_signing_data(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->possibly_unsafe_additional_signing_data)::BaseType> possibly_unsafe_additional_signing_data_fragment(
            fragment.message());
    mojo::internal::Serialize<mojo::StringDataView>(
        in_possibly_unsafe_additional_signing_data, possibly_unsafe_additional_signing_data_fragment);
    fragment->possibly_unsafe_additional_signing_data.Set(
        possibly_unsafe_additional_signing_data_fragment.is_null() ? nullptr : possibly_unsafe_additional_signing_data_fragment.data());
  }

  static bool Deserialize(::network::mojom::internal::TrustTokenParams_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::network::mojom::TrustTokenParamsDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::network::mojom::HasTrustTokensResultDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::network::mojom::HasTrustTokensResultDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::network::mojom::internal::HasTrustTokensResult_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    mojo::internal::Serialize<::network::mojom::TrustTokenOperationStatus>(
        Traits::status(input), &fragment->status);
    fragment->has_trust_tokens = Traits::has_trust_tokens(input);
  }

  static bool Deserialize(::network::mojom::internal::HasTrustTokensResult_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::network::mojom::HasTrustTokensResultDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::network::mojom::TrustTokenVerificationKeyDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::network::mojom::TrustTokenVerificationKeyDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::network::mojom::internal::TrustTokenVerificationKey_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    decltype(Traits::body(input)) in_body = Traits::body(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->body)::BaseType> body_fragment(
            fragment.message());
    mojo::internal::Serialize<mojo::StringDataView>(
        in_body, body_fragment);
    fragment->body.Set(
        body_fragment.is_null() ? nullptr : body_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->body.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null body in TrustTokenVerificationKey struct");
    decltype(Traits::expiry(input)) in_expiry = Traits::expiry(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->expiry)::BaseType> expiry_fragment(
            fragment.message());
    mojo::internal::Serialize<::mojo_base::mojom::TimeDataView>(
        in_expiry, expiry_fragment);
    fragment->expiry.Set(
        expiry_fragment.is_null() ? nullptr : expiry_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->expiry.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null expiry in TrustTokenVerificationKey struct");
  }

  static bool Deserialize(::network::mojom::internal::TrustTokenVerificationKey_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::network::mojom::TrustTokenVerificationKeyDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::network::mojom::TrustTokenKeyCommitmentResultDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::network::mojom::TrustTokenKeyCommitmentResultDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::network::mojom::internal::TrustTokenKeyCommitmentResult_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    mojo::internal::Serialize<::network::mojom::TrustTokenProtocolVersion>(
        Traits::protocol_version(input), &fragment->protocol_version);
    fragment->id = Traits::id(input);
    fragment->batch_size = Traits::batch_size(input);
    decltype(Traits::keys(input)) in_keys = Traits::keys(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->keys)::BaseType>
        keys_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams keys_validate_params(
        0, false, nullptr);
    mojo::internal::Serialize<mojo::ArrayDataView<::network::mojom::TrustTokenVerificationKeyDataView>>(
        in_keys, keys_fragment, &keys_validate_params);
    fragment->keys.Set(
        keys_fragment.is_null() ? nullptr : keys_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->keys.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null keys in TrustTokenKeyCommitmentResult struct");
    decltype(Traits::request_issuance_locally_on(input)) in_request_issuance_locally_on = Traits::request_issuance_locally_on(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->request_issuance_locally_on)::BaseType>
        request_issuance_locally_on_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams request_issuance_locally_on_validate_params(
        0, ::network::mojom::internal::TrustTokenKeyCommitmentResult_Os_Data::Validate);
    mojo::internal::Serialize<mojo::ArrayDataView<::network::mojom::TrustTokenKeyCommitmentResult_Os>>(
        in_request_issuance_locally_on, request_issuance_locally_on_fragment, &request_issuance_locally_on_validate_params);
    fragment->request_issuance_locally_on.Set(
        request_issuance_locally_on_fragment.is_null() ? nullptr : request_issuance_locally_on_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->request_issuance_locally_on.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null request_issuance_locally_on in TrustTokenKeyCommitmentResult struct");
    mojo::internal::Serialize<::network::mojom::TrustTokenKeyCommitmentResult_UnavailableLocalOperationFallback>(
        Traits::unavailable_local_operation_fallback(input), &fragment->unavailable_local_operation_fallback);
  }

  static bool Deserialize(::network::mojom::internal::TrustTokenKeyCommitmentResult_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::network::mojom::TrustTokenKeyCommitmentResultDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::network::mojom::FulfillTrustTokenIssuanceRequestDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::network::mojom::FulfillTrustTokenIssuanceRequestDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::network::mojom::internal::FulfillTrustTokenIssuanceRequest_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    decltype(Traits::issuer(input)) in_issuer = Traits::issuer(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->issuer)::BaseType> issuer_fragment(
            fragment.message());
    mojo::internal::Serialize<::url::mojom::OriginDataView>(
        in_issuer, issuer_fragment);
    fragment->issuer.Set(
        issuer_fragment.is_null() ? nullptr : issuer_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->issuer.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null issuer in FulfillTrustTokenIssuanceRequest struct");
    decltype(Traits::request(input)) in_request = Traits::request(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->request)::BaseType> request_fragment(
            fragment.message());
    mojo::internal::Serialize<mojo::StringDataView>(
        in_request, request_fragment);
    fragment->request.Set(
        request_fragment.is_null() ? nullptr : request_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->request.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null request in FulfillTrustTokenIssuanceRequest struct");
  }

  static bool Deserialize(::network::mojom::internal::FulfillTrustTokenIssuanceRequest_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::network::mojom::FulfillTrustTokenIssuanceRequestDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::network::mojom::FulfillTrustTokenIssuanceAnswerDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::network::mojom::FulfillTrustTokenIssuanceAnswerDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::network::mojom::internal::FulfillTrustTokenIssuanceAnswer_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    mojo::internal::Serialize<::network::mojom::FulfillTrustTokenIssuanceAnswer_Status>(
        Traits::status(input), &fragment->status);
    decltype(Traits::response(input)) in_response = Traits::response(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->response)::BaseType> response_fragment(
            fragment.message());
    mojo::internal::Serialize<mojo::StringDataView>(
        in_response, response_fragment);
    fragment->response.Set(
        response_fragment.is_null() ? nullptr : response_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->response.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null response in FulfillTrustTokenIssuanceAnswer struct");
  }

  static bool Deserialize(::network::mojom::internal::FulfillTrustTokenIssuanceAnswer_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::network::mojom::FulfillTrustTokenIssuanceAnswerDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::network::mojom::TrustTokenOperationResultDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::network::mojom::TrustTokenOperationResultDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::network::mojom::internal::TrustTokenOperationResult_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    mojo::internal::Serialize<::network::mojom::TrustTokenOperationType>(
        Traits::type(input), &fragment->type);
    mojo::internal::Serialize<::network::mojom::TrustTokenOperationStatus>(
        Traits::status(input), &fragment->status);
    decltype(Traits::issuer(input)) in_issuer = Traits::issuer(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->issuer)::BaseType> issuer_fragment(
            fragment.message());
    mojo::internal::Serialize<::url::mojom::OriginDataView>(
        in_issuer, issuer_fragment);
    fragment->issuer.Set(
        issuer_fragment.is_null() ? nullptr : issuer_fragment.data());
    decltype(Traits::top_level_origin(input)) in_top_level_origin = Traits::top_level_origin(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->top_level_origin)::BaseType> top_level_origin_fragment(
            fragment.message());
    mojo::internal::Serialize<::url::mojom::OriginDataView>(
        in_top_level_origin, top_level_origin_fragment);
    fragment->top_level_origin.Set(
        top_level_origin_fragment.is_null() ? nullptr : top_level_origin_fragment.data());
    fragment->issued_token_count = Traits::issued_token_count(input);
  }

  static bool Deserialize(::network::mojom::internal::TrustTokenOperationResult_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::network::mojom::TrustTokenOperationResultDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::network::mojom::StoredTrustTokensForIssuerDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::network::mojom::StoredTrustTokensForIssuerDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::network::mojom::internal::StoredTrustTokensForIssuer_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    decltype(Traits::issuer(input)) in_issuer = Traits::issuer(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->issuer)::BaseType> issuer_fragment(
            fragment.message());
    mojo::internal::Serialize<::url::mojom::OriginDataView>(
        in_issuer, issuer_fragment);
    fragment->issuer.Set(
        issuer_fragment.is_null() ? nullptr : issuer_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->issuer.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null issuer in StoredTrustTokensForIssuer struct");
    fragment->count = Traits::count(input);
  }

  static bool Deserialize(::network::mojom::internal::StoredTrustTokensForIssuer_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::network::mojom::StoredTrustTokensForIssuerDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal

}  // namespace mojo


namespace network {
namespace mojom {

inline void TrustTokenParamsDataView::GetCustomKeyCommitmentDataView(
    mojo::StringDataView* output) {
  auto pointer = data_->custom_key_commitment.Get();
  *output = mojo::StringDataView(pointer, message_);
}
inline void TrustTokenParamsDataView::GetIssuersDataView(
    mojo::ArrayDataView<::url::mojom::OriginDataView>* output) {
  auto pointer = data_->issuers.Get();
  *output = mojo::ArrayDataView<::url::mojom::OriginDataView>(pointer, message_);
}
inline void TrustTokenParamsDataView::GetAdditionalSignedHeadersDataView(
    mojo::ArrayDataView<mojo::StringDataView>* output) {
  auto pointer = data_->additional_signed_headers.Get();
  *output = mojo::ArrayDataView<mojo::StringDataView>(pointer, message_);
}
inline void TrustTokenParamsDataView::GetPossiblyUnsafeAdditionalSigningDataDataView(
    mojo::StringDataView* output) {
  auto pointer = data_->possibly_unsafe_additional_signing_data.Get();
  *output = mojo::StringDataView(pointer, message_);
}




inline void TrustTokenVerificationKeyDataView::GetBodyDataView(
    mojo::StringDataView* output) {
  auto pointer = data_->body.Get();
  *output = mojo::StringDataView(pointer, message_);
}
inline void TrustTokenVerificationKeyDataView::GetExpiryDataView(
    ::mojo_base::mojom::TimeDataView* output) {
  auto pointer = data_->expiry.Get();
  *output = ::mojo_base::mojom::TimeDataView(pointer, message_);
}


inline void TrustTokenKeyCommitmentResultDataView::GetKeysDataView(
    mojo::ArrayDataView<TrustTokenVerificationKeyDataView>* output) {
  auto pointer = data_->keys.Get();
  *output = mojo::ArrayDataView<TrustTokenVerificationKeyDataView>(pointer, message_);
}
inline void TrustTokenKeyCommitmentResultDataView::GetRequestIssuanceLocallyOnDataView(
    mojo::ArrayDataView<TrustTokenKeyCommitmentResult_Os>* output) {
  auto pointer = data_->request_issuance_locally_on.Get();
  *output = mojo::ArrayDataView<TrustTokenKeyCommitmentResult_Os>(pointer, message_);
}


inline void FulfillTrustTokenIssuanceRequestDataView::GetIssuerDataView(
    ::url::mojom::OriginDataView* output) {
  auto pointer = data_->issuer.Get();
  *output = ::url::mojom::OriginDataView(pointer, message_);
}
inline void FulfillTrustTokenIssuanceRequestDataView::GetRequestDataView(
    mojo::StringDataView* output) {
  auto pointer = data_->request.Get();
  *output = mojo::StringDataView(pointer, message_);
}


inline void FulfillTrustTokenIssuanceAnswerDataView::GetResponseDataView(
    mojo::StringDataView* output) {
  auto pointer = data_->response.Get();
  *output = mojo::StringDataView(pointer, message_);
}


inline void TrustTokenOperationResultDataView::GetIssuerDataView(
    ::url::mojom::OriginDataView* output) {
  auto pointer = data_->issuer.Get();
  *output = ::url::mojom::OriginDataView(pointer, message_);
}
inline void TrustTokenOperationResultDataView::GetTopLevelOriginDataView(
    ::url::mojom::OriginDataView* output) {
  auto pointer = data_->top_level_origin.Get();
  *output = ::url::mojom::OriginDataView(pointer, message_);
}


inline void StoredTrustTokensForIssuerDataView::GetIssuerDataView(
    ::url::mojom::OriginDataView* output) {
  auto pointer = data_->issuer.Get();
  *output = ::url::mojom::OriginDataView(pointer, message_);
}



}  // namespace mojom
}  // namespace network

// Declare TraceFormatTraits for enums, which should be defined in ::perfetto
// namespace.

namespace perfetto {

template <>
struct  TraceFormatTraits<::network::mojom::TrustTokenProtocolVersion> {
 static void WriteIntoTrace(perfetto::TracedValue context, ::network::mojom::TrustTokenProtocolVersion value);
};

} // namespace perfetto

namespace perfetto {

template <>
struct  TraceFormatTraits<::network::mojom::TrustTokenOperationStatus> {
 static void WriteIntoTrace(perfetto::TracedValue context, ::network::mojom::TrustTokenOperationStatus value);
};

} // namespace perfetto

namespace perfetto {

template <>
struct  TraceFormatTraits<::network::mojom::TrustTokenOperationType> {
 static void WriteIntoTrace(perfetto::TracedValue context, ::network::mojom::TrustTokenOperationType value);
};

} // namespace perfetto

namespace perfetto {

template <>
struct  TraceFormatTraits<::network::mojom::TrustTokenRefreshPolicy> {
 static void WriteIntoTrace(perfetto::TracedValue context, ::network::mojom::TrustTokenRefreshPolicy value);
};

} // namespace perfetto

namespace perfetto {

template <>
struct  TraceFormatTraits<::network::mojom::TrustTokenSignRequestData> {
 static void WriteIntoTrace(perfetto::TracedValue context, ::network::mojom::TrustTokenSignRequestData value);
};

} // namespace perfetto

namespace perfetto {

template <>
struct  TraceFormatTraits<::network::mojom::DeleteStoredTrustTokensStatus> {
 static void WriteIntoTrace(perfetto::TracedValue context, ::network::mojom::DeleteStoredTrustTokensStatus value);
};

} // namespace perfetto

namespace perfetto {

template <>
struct  TraceFormatTraits<::network::mojom::TrustTokenKeyCommitmentResult_Os> {
 static void WriteIntoTrace(perfetto::TracedValue context, ::network::mojom::TrustTokenKeyCommitmentResult_Os value);
};

} // namespace perfetto

namespace perfetto {

template <>
struct  TraceFormatTraits<::network::mojom::TrustTokenKeyCommitmentResult_UnavailableLocalOperationFallback> {
 static void WriteIntoTrace(perfetto::TracedValue context, ::network::mojom::TrustTokenKeyCommitmentResult_UnavailableLocalOperationFallback value);
};

} // namespace perfetto

namespace perfetto {

template <>
struct  TraceFormatTraits<::network::mojom::FulfillTrustTokenIssuanceAnswer_Status> {
 static void WriteIntoTrace(perfetto::TracedValue context, ::network::mojom::FulfillTrustTokenIssuanceAnswer_Status value);
};

} // namespace perfetto

#endif  // SERVICES_NETWORK_PUBLIC_MOJOM_TRUST_TOKENS_MOJOM_SHARED_H_