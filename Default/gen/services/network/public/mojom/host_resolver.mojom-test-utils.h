// services/network/public/mojom/host_resolver.mojom-test-utils.h is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2019 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef SERVICES_NETWORK_PUBLIC_MOJOM_HOST_RESOLVER_MOJOM_TEST_UTILS_H_
#define SERVICES_NETWORK_PUBLIC_MOJOM_HOST_RESOLVER_MOJOM_TEST_UTILS_H_

#include "services/network/public/mojom/host_resolver.mojom.h"


namespace network {
namespace mojom {


class  ResolveHostHandleInterceptorForTesting : public ResolveHostHandle {
  virtual ResolveHostHandle* GetForwardingInterface() = 0;
  void Cancel(int32_t result) override;
};
class  ResolveHostHandleAsyncWaiter {
 public:
  explicit ResolveHostHandleAsyncWaiter(ResolveHostHandle* proxy);

  ResolveHostHandleAsyncWaiter(const ResolveHostHandleAsyncWaiter&) = delete;
  ResolveHostHandleAsyncWaiter& operator=(const ResolveHostHandleAsyncWaiter&) = delete;

  ~ResolveHostHandleAsyncWaiter();

 private:
  ResolveHostHandle* const proxy_;
};


class  ResolveHostClientInterceptorForTesting : public ResolveHostClient {
  virtual ResolveHostClient* GetForwardingInterface() = 0;
  void OnComplete(int32_t result, const ::net::ResolveErrorInfo& resolve_error_info, const absl::optional<::net::AddressList>& resolved_addresses) override;
  void OnTextResults(const std::vector<std::string>& text_results) override;
  void OnHostnameResults(const std::vector<::net::HostPortPair>& hosts) override;
};
class  ResolveHostClientAsyncWaiter {
 public:
  explicit ResolveHostClientAsyncWaiter(ResolveHostClient* proxy);

  ResolveHostClientAsyncWaiter(const ResolveHostClientAsyncWaiter&) = delete;
  ResolveHostClientAsyncWaiter& operator=(const ResolveHostClientAsyncWaiter&) = delete;

  ~ResolveHostClientAsyncWaiter();

 private:
  ResolveHostClient* const proxy_;
};


class  MdnsListenClientInterceptorForTesting : public MdnsListenClient {
  virtual MdnsListenClient* GetForwardingInterface() = 0;
  void OnAddressResult(::net::MdnsListenerUpdateType update_type, ::net::DnsQueryType query_type, const ::net::IPEndPoint& endpoint) override;
  void OnTextResult(::net::MdnsListenerUpdateType update_type, ::net::DnsQueryType query_type, const std::vector<std::string>& text_records) override;
  void OnHostnameResult(::net::MdnsListenerUpdateType update_type, ::net::DnsQueryType query_type, const ::net::HostPortPair& host) override;
  void OnUnhandledResult(::net::MdnsListenerUpdateType update_type, ::net::DnsQueryType query_type) override;
};
class  MdnsListenClientAsyncWaiter {
 public:
  explicit MdnsListenClientAsyncWaiter(MdnsListenClient* proxy);

  MdnsListenClientAsyncWaiter(const MdnsListenClientAsyncWaiter&) = delete;
  MdnsListenClientAsyncWaiter& operator=(const MdnsListenClientAsyncWaiter&) = delete;

  ~MdnsListenClientAsyncWaiter();

 private:
  MdnsListenClient* const proxy_;
};


class  HostResolverInterceptorForTesting : public HostResolver {
  virtual HostResolver* GetForwardingInterface() = 0;
  void ResolveHost(const ::net::HostPortPair& host, const ::net::NetworkIsolationKey& network_isolation_key, ResolveHostParametersPtr optional_parameters, ::mojo::PendingRemote<ResolveHostClient> response_client) override;
  void MdnsListen(const ::net::HostPortPair& host, ::net::DnsQueryType query_type, ::mojo::PendingRemote<MdnsListenClient> response_client, MdnsListenCallback callback) override;
};
class  HostResolverAsyncWaiter {
 public:
  explicit HostResolverAsyncWaiter(HostResolver* proxy);

  HostResolverAsyncWaiter(const HostResolverAsyncWaiter&) = delete;
  HostResolverAsyncWaiter& operator=(const HostResolverAsyncWaiter&) = delete;

  ~HostResolverAsyncWaiter();
  void MdnsListen(
      const ::net::HostPortPair& host, ::net::DnsQueryType query_type, ::mojo::PendingRemote<MdnsListenClient> response_client, int32_t* out_result);

 private:
  HostResolver* const proxy_;
};


class  DnsConfigChangeManagerClientInterceptorForTesting : public DnsConfigChangeManagerClient {
  virtual DnsConfigChangeManagerClient* GetForwardingInterface() = 0;
  void OnDnsConfigChanged() override;
};
class  DnsConfigChangeManagerClientAsyncWaiter {
 public:
  explicit DnsConfigChangeManagerClientAsyncWaiter(DnsConfigChangeManagerClient* proxy);

  DnsConfigChangeManagerClientAsyncWaiter(const DnsConfigChangeManagerClientAsyncWaiter&) = delete;
  DnsConfigChangeManagerClientAsyncWaiter& operator=(const DnsConfigChangeManagerClientAsyncWaiter&) = delete;

  ~DnsConfigChangeManagerClientAsyncWaiter();

 private:
  DnsConfigChangeManagerClient* const proxy_;
};


class  DnsConfigChangeManagerInterceptorForTesting : public DnsConfigChangeManager {
  virtual DnsConfigChangeManager* GetForwardingInterface() = 0;
  void RequestNotifications(::mojo::PendingRemote<DnsConfigChangeManagerClient> client) override;
};
class  DnsConfigChangeManagerAsyncWaiter {
 public:
  explicit DnsConfigChangeManagerAsyncWaiter(DnsConfigChangeManager* proxy);

  DnsConfigChangeManagerAsyncWaiter(const DnsConfigChangeManagerAsyncWaiter&) = delete;
  DnsConfigChangeManagerAsyncWaiter& operator=(const DnsConfigChangeManagerAsyncWaiter&) = delete;

  ~DnsConfigChangeManagerAsyncWaiter();

 private:
  DnsConfigChangeManager* const proxy_;
};




}  // namespace mojom
}  // namespace network

#endif  // SERVICES_NETWORK_PUBLIC_MOJOM_HOST_RESOLVER_MOJOM_TEST_UTILS_H_