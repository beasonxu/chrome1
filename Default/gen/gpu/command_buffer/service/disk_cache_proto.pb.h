// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: disk_cache_proto.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_disk_5fcache_5fproto_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_disk_5fcache_5fproto_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3020000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3020000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_disk_5fcache_5fproto_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_disk_5fcache_5fproto_2eproto {
  static const uint32_t offsets[];
};
class GpuProgramProto;
struct GpuProgramProtoDefaultTypeInternal;
extern GpuProgramProtoDefaultTypeInternal _GpuProgramProto_default_instance_;
class ShaderAttributeProto;
struct ShaderAttributeProtoDefaultTypeInternal;
extern ShaderAttributeProtoDefaultTypeInternal _ShaderAttributeProto_default_instance_;
class ShaderInterfaceBlockFieldProto;
struct ShaderInterfaceBlockFieldProtoDefaultTypeInternal;
extern ShaderInterfaceBlockFieldProtoDefaultTypeInternal _ShaderInterfaceBlockFieldProto_default_instance_;
class ShaderInterfaceBlockProto;
struct ShaderInterfaceBlockProtoDefaultTypeInternal;
extern ShaderInterfaceBlockProtoDefaultTypeInternal _ShaderInterfaceBlockProto_default_instance_;
class ShaderOutputVariableProto;
struct ShaderOutputVariableProtoDefaultTypeInternal;
extern ShaderOutputVariableProtoDefaultTypeInternal _ShaderOutputVariableProto_default_instance_;
class ShaderProto;
struct ShaderProtoDefaultTypeInternal;
extern ShaderProtoDefaultTypeInternal _ShaderProto_default_instance_;
class ShaderUniformProto;
struct ShaderUniformProtoDefaultTypeInternal;
extern ShaderUniformProtoDefaultTypeInternal _ShaderUniformProto_default_instance_;
class ShaderVariableProto;
struct ShaderVariableProtoDefaultTypeInternal;
extern ShaderVariableProtoDefaultTypeInternal _ShaderVariableProto_default_instance_;
class ShaderVaryingProto;
struct ShaderVaryingProtoDefaultTypeInternal;
extern ShaderVaryingProtoDefaultTypeInternal _ShaderVaryingProto_default_instance_;
PROTOBUF_NAMESPACE_OPEN
template<> ::GpuProgramProto* Arena::CreateMaybeMessage<::GpuProgramProto>(Arena*);
template<> ::ShaderAttributeProto* Arena::CreateMaybeMessage<::ShaderAttributeProto>(Arena*);
template<> ::ShaderInterfaceBlockFieldProto* Arena::CreateMaybeMessage<::ShaderInterfaceBlockFieldProto>(Arena*);
template<> ::ShaderInterfaceBlockProto* Arena::CreateMaybeMessage<::ShaderInterfaceBlockProto>(Arena*);
template<> ::ShaderOutputVariableProto* Arena::CreateMaybeMessage<::ShaderOutputVariableProto>(Arena*);
template<> ::ShaderProto* Arena::CreateMaybeMessage<::ShaderProto>(Arena*);
template<> ::ShaderUniformProto* Arena::CreateMaybeMessage<::ShaderUniformProto>(Arena*);
template<> ::ShaderVariableProto* Arena::CreateMaybeMessage<::ShaderVariableProto>(Arena*);
template<> ::ShaderVaryingProto* Arena::CreateMaybeMessage<::ShaderVaryingProto>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

// ===================================================================

class ShaderVariableProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:ShaderVariableProto) */ {
 public:
  inline ShaderVariableProto() : ShaderVariableProto(nullptr) {}
  ~ShaderVariableProto() override;
  explicit PROTOBUF_CONSTEXPR ShaderVariableProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ShaderVariableProto(const ShaderVariableProto& from);
  ShaderVariableProto(ShaderVariableProto&& from) noexcept
    : ShaderVariableProto() {
    *this = ::std::move(from);
  }

  inline ShaderVariableProto& operator=(const ShaderVariableProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShaderVariableProto& operator=(ShaderVariableProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ShaderVariableProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const ShaderVariableProto* internal_default_instance() {
    return reinterpret_cast<const ShaderVariableProto*>(
               &_ShaderVariableProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(ShaderVariableProto& a, ShaderVariableProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(ShaderVariableProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShaderVariableProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ShaderVariableProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ShaderVariableProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ShaderVariableProto& from);
  void MergeFrom(const ShaderVariableProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ShaderVariableProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ShaderVariableProto";
  }
  protected:
  explicit ShaderVariableProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFieldsFieldNumber = 7,
    kNameFieldNumber = 3,
    kMappedNameFieldNumber = 4,
    kStructNameFieldNumber = 8,
    kTypeFieldNumber = 1,
    kPrecisionFieldNumber = 2,
    kArraySizeFieldNumber = 5,
    kStaticUseFieldNumber = 6,
  };
  // repeated .ShaderVariableProto fields = 7;
  int fields_size() const;
  private:
  int _internal_fields_size() const;
  public:
  void clear_fields();
  ::ShaderVariableProto* mutable_fields(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ShaderVariableProto >*
      mutable_fields();
  private:
  const ::ShaderVariableProto& _internal_fields(int index) const;
  ::ShaderVariableProto* _internal_add_fields();
  public:
  const ::ShaderVariableProto& fields(int index) const;
  ::ShaderVariableProto* add_fields();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ShaderVariableProto >&
      fields() const;

  // optional string name = 3;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional string mapped_name = 4;
  bool has_mapped_name() const;
  private:
  bool _internal_has_mapped_name() const;
  public:
  void clear_mapped_name();
  const std::string& mapped_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mapped_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mapped_name();
  PROTOBUF_NODISCARD std::string* release_mapped_name();
  void set_allocated_mapped_name(std::string* mapped_name);
  private:
  const std::string& _internal_mapped_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mapped_name(const std::string& value);
  std::string* _internal_mutable_mapped_name();
  public:

  // optional string struct_name = 8;
  bool has_struct_name() const;
  private:
  bool _internal_has_struct_name() const;
  public:
  void clear_struct_name();
  const std::string& struct_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_struct_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_struct_name();
  PROTOBUF_NODISCARD std::string* release_struct_name();
  void set_allocated_struct_name(std::string* struct_name);
  private:
  const std::string& _internal_struct_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_struct_name(const std::string& value);
  std::string* _internal_mutable_struct_name();
  public:

  // optional uint32 type = 1;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  uint32_t type() const;
  void set_type(uint32_t value);
  private:
  uint32_t _internal_type() const;
  void _internal_set_type(uint32_t value);
  public:

  // optional uint32 precision = 2;
  bool has_precision() const;
  private:
  bool _internal_has_precision() const;
  public:
  void clear_precision();
  uint32_t precision() const;
  void set_precision(uint32_t value);
  private:
  uint32_t _internal_precision() const;
  void _internal_set_precision(uint32_t value);
  public:

  // optional uint32 array_size = 5;
  bool has_array_size() const;
  private:
  bool _internal_has_array_size() const;
  public:
  void clear_array_size();
  uint32_t array_size() const;
  void set_array_size(uint32_t value);
  private:
  uint32_t _internal_array_size() const;
  void _internal_set_array_size(uint32_t value);
  public:

  // optional bool static_use = 6;
  bool has_static_use() const;
  private:
  bool _internal_has_static_use() const;
  public:
  void clear_static_use();
  bool static_use() const;
  void set_static_use(bool value);
  private:
  bool _internal_static_use() const;
  void _internal_set_static_use(bool value);
  public:

  // @@protoc_insertion_point(class_scope:ShaderVariableProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ShaderVariableProto > fields_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mapped_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr struct_name_;
  uint32_t type_;
  uint32_t precision_;
  uint32_t array_size_;
  bool static_use_;
  friend struct ::TableStruct_disk_5fcache_5fproto_2eproto;
};
// -------------------------------------------------------------------

class ShaderAttributeProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:ShaderAttributeProto) */ {
 public:
  inline ShaderAttributeProto() : ShaderAttributeProto(nullptr) {}
  ~ShaderAttributeProto() override;
  explicit PROTOBUF_CONSTEXPR ShaderAttributeProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ShaderAttributeProto(const ShaderAttributeProto& from);
  ShaderAttributeProto(ShaderAttributeProto&& from) noexcept
    : ShaderAttributeProto() {
    *this = ::std::move(from);
  }

  inline ShaderAttributeProto& operator=(const ShaderAttributeProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShaderAttributeProto& operator=(ShaderAttributeProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ShaderAttributeProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const ShaderAttributeProto* internal_default_instance() {
    return reinterpret_cast<const ShaderAttributeProto*>(
               &_ShaderAttributeProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ShaderAttributeProto& a, ShaderAttributeProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(ShaderAttributeProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShaderAttributeProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ShaderAttributeProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ShaderAttributeProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ShaderAttributeProto& from);
  void MergeFrom(const ShaderAttributeProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ShaderAttributeProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ShaderAttributeProto";
  }
  protected:
  explicit ShaderAttributeProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBasicFieldNumber = 1,
    kLocationFieldNumber = 2,
  };
  // optional .ShaderVariableProto basic = 1;
  bool has_basic() const;
  private:
  bool _internal_has_basic() const;
  public:
  void clear_basic();
  const ::ShaderVariableProto& basic() const;
  PROTOBUF_NODISCARD ::ShaderVariableProto* release_basic();
  ::ShaderVariableProto* mutable_basic();
  void set_allocated_basic(::ShaderVariableProto* basic);
  private:
  const ::ShaderVariableProto& _internal_basic() const;
  ::ShaderVariableProto* _internal_mutable_basic();
  public:
  void unsafe_arena_set_allocated_basic(
      ::ShaderVariableProto* basic);
  ::ShaderVariableProto* unsafe_arena_release_basic();

  // optional int32 location = 2;
  bool has_location() const;
  private:
  bool _internal_has_location() const;
  public:
  void clear_location();
  int32_t location() const;
  void set_location(int32_t value);
  private:
  int32_t _internal_location() const;
  void _internal_set_location(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ShaderAttributeProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::ShaderVariableProto* basic_;
  int32_t location_;
  friend struct ::TableStruct_disk_5fcache_5fproto_2eproto;
};
// -------------------------------------------------------------------

class ShaderUniformProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:ShaderUniformProto) */ {
 public:
  inline ShaderUniformProto() : ShaderUniformProto(nullptr) {}
  ~ShaderUniformProto() override;
  explicit PROTOBUF_CONSTEXPR ShaderUniformProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ShaderUniformProto(const ShaderUniformProto& from);
  ShaderUniformProto(ShaderUniformProto&& from) noexcept
    : ShaderUniformProto() {
    *this = ::std::move(from);
  }

  inline ShaderUniformProto& operator=(const ShaderUniformProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShaderUniformProto& operator=(ShaderUniformProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ShaderUniformProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const ShaderUniformProto* internal_default_instance() {
    return reinterpret_cast<const ShaderUniformProto*>(
               &_ShaderUniformProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ShaderUniformProto& a, ShaderUniformProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(ShaderUniformProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShaderUniformProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ShaderUniformProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ShaderUniformProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ShaderUniformProto& from);
  void MergeFrom(const ShaderUniformProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ShaderUniformProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ShaderUniformProto";
  }
  protected:
  explicit ShaderUniformProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBasicFieldNumber = 1,
  };
  // optional .ShaderVariableProto basic = 1;
  bool has_basic() const;
  private:
  bool _internal_has_basic() const;
  public:
  void clear_basic();
  const ::ShaderVariableProto& basic() const;
  PROTOBUF_NODISCARD ::ShaderVariableProto* release_basic();
  ::ShaderVariableProto* mutable_basic();
  void set_allocated_basic(::ShaderVariableProto* basic);
  private:
  const ::ShaderVariableProto& _internal_basic() const;
  ::ShaderVariableProto* _internal_mutable_basic();
  public:
  void unsafe_arena_set_allocated_basic(
      ::ShaderVariableProto* basic);
  ::ShaderVariableProto* unsafe_arena_release_basic();

  // @@protoc_insertion_point(class_scope:ShaderUniformProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::ShaderVariableProto* basic_;
  friend struct ::TableStruct_disk_5fcache_5fproto_2eproto;
};
// -------------------------------------------------------------------

class ShaderVaryingProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:ShaderVaryingProto) */ {
 public:
  inline ShaderVaryingProto() : ShaderVaryingProto(nullptr) {}
  ~ShaderVaryingProto() override;
  explicit PROTOBUF_CONSTEXPR ShaderVaryingProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ShaderVaryingProto(const ShaderVaryingProto& from);
  ShaderVaryingProto(ShaderVaryingProto&& from) noexcept
    : ShaderVaryingProto() {
    *this = ::std::move(from);
  }

  inline ShaderVaryingProto& operator=(const ShaderVaryingProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShaderVaryingProto& operator=(ShaderVaryingProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ShaderVaryingProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const ShaderVaryingProto* internal_default_instance() {
    return reinterpret_cast<const ShaderVaryingProto*>(
               &_ShaderVaryingProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ShaderVaryingProto& a, ShaderVaryingProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(ShaderVaryingProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShaderVaryingProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ShaderVaryingProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ShaderVaryingProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ShaderVaryingProto& from);
  void MergeFrom(const ShaderVaryingProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ShaderVaryingProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ShaderVaryingProto";
  }
  protected:
  explicit ShaderVaryingProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBasicFieldNumber = 1,
    kInterpolationFieldNumber = 2,
    kIsInvariantFieldNumber = 3,
  };
  // optional .ShaderVariableProto basic = 1;
  bool has_basic() const;
  private:
  bool _internal_has_basic() const;
  public:
  void clear_basic();
  const ::ShaderVariableProto& basic() const;
  PROTOBUF_NODISCARD ::ShaderVariableProto* release_basic();
  ::ShaderVariableProto* mutable_basic();
  void set_allocated_basic(::ShaderVariableProto* basic);
  private:
  const ::ShaderVariableProto& _internal_basic() const;
  ::ShaderVariableProto* _internal_mutable_basic();
  public:
  void unsafe_arena_set_allocated_basic(
      ::ShaderVariableProto* basic);
  ::ShaderVariableProto* unsafe_arena_release_basic();

  // optional int32 interpolation = 2;
  bool has_interpolation() const;
  private:
  bool _internal_has_interpolation() const;
  public:
  void clear_interpolation();
  int32_t interpolation() const;
  void set_interpolation(int32_t value);
  private:
  int32_t _internal_interpolation() const;
  void _internal_set_interpolation(int32_t value);
  public:

  // optional bool is_invariant = 3;
  bool has_is_invariant() const;
  private:
  bool _internal_has_is_invariant() const;
  public:
  void clear_is_invariant();
  bool is_invariant() const;
  void set_is_invariant(bool value);
  private:
  bool _internal_is_invariant() const;
  void _internal_set_is_invariant(bool value);
  public:

  // @@protoc_insertion_point(class_scope:ShaderVaryingProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::ShaderVariableProto* basic_;
  int32_t interpolation_;
  bool is_invariant_;
  friend struct ::TableStruct_disk_5fcache_5fproto_2eproto;
};
// -------------------------------------------------------------------

class ShaderOutputVariableProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:ShaderOutputVariableProto) */ {
 public:
  inline ShaderOutputVariableProto() : ShaderOutputVariableProto(nullptr) {}
  ~ShaderOutputVariableProto() override;
  explicit PROTOBUF_CONSTEXPR ShaderOutputVariableProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ShaderOutputVariableProto(const ShaderOutputVariableProto& from);
  ShaderOutputVariableProto(ShaderOutputVariableProto&& from) noexcept
    : ShaderOutputVariableProto() {
    *this = ::std::move(from);
  }

  inline ShaderOutputVariableProto& operator=(const ShaderOutputVariableProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShaderOutputVariableProto& operator=(ShaderOutputVariableProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ShaderOutputVariableProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const ShaderOutputVariableProto* internal_default_instance() {
    return reinterpret_cast<const ShaderOutputVariableProto*>(
               &_ShaderOutputVariableProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ShaderOutputVariableProto& a, ShaderOutputVariableProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(ShaderOutputVariableProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShaderOutputVariableProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ShaderOutputVariableProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ShaderOutputVariableProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ShaderOutputVariableProto& from);
  void MergeFrom(const ShaderOutputVariableProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ShaderOutputVariableProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ShaderOutputVariableProto";
  }
  protected:
  explicit ShaderOutputVariableProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBasicFieldNumber = 1,
    kLocationFieldNumber = 2,
  };
  // optional .ShaderVariableProto basic = 1;
  bool has_basic() const;
  private:
  bool _internal_has_basic() const;
  public:
  void clear_basic();
  const ::ShaderVariableProto& basic() const;
  PROTOBUF_NODISCARD ::ShaderVariableProto* release_basic();
  ::ShaderVariableProto* mutable_basic();
  void set_allocated_basic(::ShaderVariableProto* basic);
  private:
  const ::ShaderVariableProto& _internal_basic() const;
  ::ShaderVariableProto* _internal_mutable_basic();
  public:
  void unsafe_arena_set_allocated_basic(
      ::ShaderVariableProto* basic);
  ::ShaderVariableProto* unsafe_arena_release_basic();

  // optional int32 location = 2;
  bool has_location() const;
  private:
  bool _internal_has_location() const;
  public:
  void clear_location();
  int32_t location() const;
  void set_location(int32_t value);
  private:
  int32_t _internal_location() const;
  void _internal_set_location(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ShaderOutputVariableProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::ShaderVariableProto* basic_;
  int32_t location_;
  friend struct ::TableStruct_disk_5fcache_5fproto_2eproto;
};
// -------------------------------------------------------------------

class ShaderInterfaceBlockFieldProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:ShaderInterfaceBlockFieldProto) */ {
 public:
  inline ShaderInterfaceBlockFieldProto() : ShaderInterfaceBlockFieldProto(nullptr) {}
  ~ShaderInterfaceBlockFieldProto() override;
  explicit PROTOBUF_CONSTEXPR ShaderInterfaceBlockFieldProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ShaderInterfaceBlockFieldProto(const ShaderInterfaceBlockFieldProto& from);
  ShaderInterfaceBlockFieldProto(ShaderInterfaceBlockFieldProto&& from) noexcept
    : ShaderInterfaceBlockFieldProto() {
    *this = ::std::move(from);
  }

  inline ShaderInterfaceBlockFieldProto& operator=(const ShaderInterfaceBlockFieldProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShaderInterfaceBlockFieldProto& operator=(ShaderInterfaceBlockFieldProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ShaderInterfaceBlockFieldProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const ShaderInterfaceBlockFieldProto* internal_default_instance() {
    return reinterpret_cast<const ShaderInterfaceBlockFieldProto*>(
               &_ShaderInterfaceBlockFieldProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ShaderInterfaceBlockFieldProto& a, ShaderInterfaceBlockFieldProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(ShaderInterfaceBlockFieldProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShaderInterfaceBlockFieldProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ShaderInterfaceBlockFieldProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ShaderInterfaceBlockFieldProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ShaderInterfaceBlockFieldProto& from);
  void MergeFrom(const ShaderInterfaceBlockFieldProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ShaderInterfaceBlockFieldProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ShaderInterfaceBlockFieldProto";
  }
  protected:
  explicit ShaderInterfaceBlockFieldProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBasicFieldNumber = 1,
    kIsRowMajorLayoutFieldNumber = 2,
  };
  // optional .ShaderVariableProto basic = 1;
  bool has_basic() const;
  private:
  bool _internal_has_basic() const;
  public:
  void clear_basic();
  const ::ShaderVariableProto& basic() const;
  PROTOBUF_NODISCARD ::ShaderVariableProto* release_basic();
  ::ShaderVariableProto* mutable_basic();
  void set_allocated_basic(::ShaderVariableProto* basic);
  private:
  const ::ShaderVariableProto& _internal_basic() const;
  ::ShaderVariableProto* _internal_mutable_basic();
  public:
  void unsafe_arena_set_allocated_basic(
      ::ShaderVariableProto* basic);
  ::ShaderVariableProto* unsafe_arena_release_basic();

  // optional bool is_row_major_layout = 2;
  bool has_is_row_major_layout() const;
  private:
  bool _internal_has_is_row_major_layout() const;
  public:
  void clear_is_row_major_layout();
  bool is_row_major_layout() const;
  void set_is_row_major_layout(bool value);
  private:
  bool _internal_is_row_major_layout() const;
  void _internal_set_is_row_major_layout(bool value);
  public:

  // @@protoc_insertion_point(class_scope:ShaderInterfaceBlockFieldProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::ShaderVariableProto* basic_;
  bool is_row_major_layout_;
  friend struct ::TableStruct_disk_5fcache_5fproto_2eproto;
};
// -------------------------------------------------------------------

class ShaderInterfaceBlockProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:ShaderInterfaceBlockProto) */ {
 public:
  inline ShaderInterfaceBlockProto() : ShaderInterfaceBlockProto(nullptr) {}
  ~ShaderInterfaceBlockProto() override;
  explicit PROTOBUF_CONSTEXPR ShaderInterfaceBlockProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ShaderInterfaceBlockProto(const ShaderInterfaceBlockProto& from);
  ShaderInterfaceBlockProto(ShaderInterfaceBlockProto&& from) noexcept
    : ShaderInterfaceBlockProto() {
    *this = ::std::move(from);
  }

  inline ShaderInterfaceBlockProto& operator=(const ShaderInterfaceBlockProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShaderInterfaceBlockProto& operator=(ShaderInterfaceBlockProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ShaderInterfaceBlockProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const ShaderInterfaceBlockProto* internal_default_instance() {
    return reinterpret_cast<const ShaderInterfaceBlockProto*>(
               &_ShaderInterfaceBlockProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(ShaderInterfaceBlockProto& a, ShaderInterfaceBlockProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(ShaderInterfaceBlockProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShaderInterfaceBlockProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ShaderInterfaceBlockProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ShaderInterfaceBlockProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ShaderInterfaceBlockProto& from);
  void MergeFrom(const ShaderInterfaceBlockProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ShaderInterfaceBlockProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ShaderInterfaceBlockProto";
  }
  protected:
  explicit ShaderInterfaceBlockProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFieldsFieldNumber = 8,
    kNameFieldNumber = 1,
    kMappedNameFieldNumber = 2,
    kInstanceNameFieldNumber = 3,
    kArraySizeFieldNumber = 4,
    kLayoutFieldNumber = 5,
    kIsRowMajorLayoutFieldNumber = 6,
    kStaticUseFieldNumber = 7,
  };
  // repeated .ShaderInterfaceBlockFieldProto fields = 8;
  int fields_size() const;
  private:
  int _internal_fields_size() const;
  public:
  void clear_fields();
  ::ShaderInterfaceBlockFieldProto* mutable_fields(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ShaderInterfaceBlockFieldProto >*
      mutable_fields();
  private:
  const ::ShaderInterfaceBlockFieldProto& _internal_fields(int index) const;
  ::ShaderInterfaceBlockFieldProto* _internal_add_fields();
  public:
  const ::ShaderInterfaceBlockFieldProto& fields(int index) const;
  ::ShaderInterfaceBlockFieldProto* add_fields();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ShaderInterfaceBlockFieldProto >&
      fields() const;

  // optional string name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional string mapped_name = 2;
  bool has_mapped_name() const;
  private:
  bool _internal_has_mapped_name() const;
  public:
  void clear_mapped_name();
  const std::string& mapped_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mapped_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mapped_name();
  PROTOBUF_NODISCARD std::string* release_mapped_name();
  void set_allocated_mapped_name(std::string* mapped_name);
  private:
  const std::string& _internal_mapped_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mapped_name(const std::string& value);
  std::string* _internal_mutable_mapped_name();
  public:

  // optional string instance_name = 3;
  bool has_instance_name() const;
  private:
  bool _internal_has_instance_name() const;
  public:
  void clear_instance_name();
  const std::string& instance_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_instance_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_instance_name();
  PROTOBUF_NODISCARD std::string* release_instance_name();
  void set_allocated_instance_name(std::string* instance_name);
  private:
  const std::string& _internal_instance_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_instance_name(const std::string& value);
  std::string* _internal_mutable_instance_name();
  public:

  // optional uint32 array_size = 4;
  bool has_array_size() const;
  private:
  bool _internal_has_array_size() const;
  public:
  void clear_array_size();
  uint32_t array_size() const;
  void set_array_size(uint32_t value);
  private:
  uint32_t _internal_array_size() const;
  void _internal_set_array_size(uint32_t value);
  public:

  // optional int32 layout = 5;
  bool has_layout() const;
  private:
  bool _internal_has_layout() const;
  public:
  void clear_layout();
  int32_t layout() const;
  void set_layout(int32_t value);
  private:
  int32_t _internal_layout() const;
  void _internal_set_layout(int32_t value);
  public:

  // optional bool is_row_major_layout = 6;
  bool has_is_row_major_layout() const;
  private:
  bool _internal_has_is_row_major_layout() const;
  public:
  void clear_is_row_major_layout();
  bool is_row_major_layout() const;
  void set_is_row_major_layout(bool value);
  private:
  bool _internal_is_row_major_layout() const;
  void _internal_set_is_row_major_layout(bool value);
  public:

  // optional bool static_use = 7;
  bool has_static_use() const;
  private:
  bool _internal_has_static_use() const;
  public:
  void clear_static_use();
  bool static_use() const;
  void set_static_use(bool value);
  private:
  bool _internal_static_use() const;
  void _internal_set_static_use(bool value);
  public:

  // @@protoc_insertion_point(class_scope:ShaderInterfaceBlockProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ShaderInterfaceBlockFieldProto > fields_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mapped_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr instance_name_;
  uint32_t array_size_;
  int32_t layout_;
  bool is_row_major_layout_;
  bool static_use_;
  friend struct ::TableStruct_disk_5fcache_5fproto_2eproto;
};
// -------------------------------------------------------------------

class ShaderProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:ShaderProto) */ {
 public:
  inline ShaderProto() : ShaderProto(nullptr) {}
  ~ShaderProto() override;
  explicit PROTOBUF_CONSTEXPR ShaderProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ShaderProto(const ShaderProto& from);
  ShaderProto(ShaderProto&& from) noexcept
    : ShaderProto() {
    *this = ::std::move(from);
  }

  inline ShaderProto& operator=(const ShaderProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShaderProto& operator=(ShaderProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ShaderProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const ShaderProto* internal_default_instance() {
    return reinterpret_cast<const ShaderProto*>(
               &_ShaderProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(ShaderProto& a, ShaderProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(ShaderProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShaderProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ShaderProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ShaderProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ShaderProto& from);
  void MergeFrom(const ShaderProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ShaderProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ShaderProto";
  }
  protected:
  explicit ShaderProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAttribsFieldNumber = 2,
    kUniformsFieldNumber = 3,
    kVaryingsFieldNumber = 4,
    kOutputVariablesFieldNumber = 5,
    kInterfaceBlocksFieldNumber = 6,
    kShaFieldNumber = 1,
  };
  // repeated .ShaderAttributeProto attribs = 2;
  int attribs_size() const;
  private:
  int _internal_attribs_size() const;
  public:
  void clear_attribs();
  ::ShaderAttributeProto* mutable_attribs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ShaderAttributeProto >*
      mutable_attribs();
  private:
  const ::ShaderAttributeProto& _internal_attribs(int index) const;
  ::ShaderAttributeProto* _internal_add_attribs();
  public:
  const ::ShaderAttributeProto& attribs(int index) const;
  ::ShaderAttributeProto* add_attribs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ShaderAttributeProto >&
      attribs() const;

  // repeated .ShaderUniformProto uniforms = 3;
  int uniforms_size() const;
  private:
  int _internal_uniforms_size() const;
  public:
  void clear_uniforms();
  ::ShaderUniformProto* mutable_uniforms(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ShaderUniformProto >*
      mutable_uniforms();
  private:
  const ::ShaderUniformProto& _internal_uniforms(int index) const;
  ::ShaderUniformProto* _internal_add_uniforms();
  public:
  const ::ShaderUniformProto& uniforms(int index) const;
  ::ShaderUniformProto* add_uniforms();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ShaderUniformProto >&
      uniforms() const;

  // repeated .ShaderVaryingProto varyings = 4;
  int varyings_size() const;
  private:
  int _internal_varyings_size() const;
  public:
  void clear_varyings();
  ::ShaderVaryingProto* mutable_varyings(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ShaderVaryingProto >*
      mutable_varyings();
  private:
  const ::ShaderVaryingProto& _internal_varyings(int index) const;
  ::ShaderVaryingProto* _internal_add_varyings();
  public:
  const ::ShaderVaryingProto& varyings(int index) const;
  ::ShaderVaryingProto* add_varyings();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ShaderVaryingProto >&
      varyings() const;

  // repeated .ShaderOutputVariableProto output_variables = 5;
  int output_variables_size() const;
  private:
  int _internal_output_variables_size() const;
  public:
  void clear_output_variables();
  ::ShaderOutputVariableProto* mutable_output_variables(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ShaderOutputVariableProto >*
      mutable_output_variables();
  private:
  const ::ShaderOutputVariableProto& _internal_output_variables(int index) const;
  ::ShaderOutputVariableProto* _internal_add_output_variables();
  public:
  const ::ShaderOutputVariableProto& output_variables(int index) const;
  ::ShaderOutputVariableProto* add_output_variables();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ShaderOutputVariableProto >&
      output_variables() const;

  // repeated .ShaderInterfaceBlockProto interface_blocks = 6;
  int interface_blocks_size() const;
  private:
  int _internal_interface_blocks_size() const;
  public:
  void clear_interface_blocks();
  ::ShaderInterfaceBlockProto* mutable_interface_blocks(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ShaderInterfaceBlockProto >*
      mutable_interface_blocks();
  private:
  const ::ShaderInterfaceBlockProto& _internal_interface_blocks(int index) const;
  ::ShaderInterfaceBlockProto* _internal_add_interface_blocks();
  public:
  const ::ShaderInterfaceBlockProto& interface_blocks(int index) const;
  ::ShaderInterfaceBlockProto* add_interface_blocks();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ShaderInterfaceBlockProto >&
      interface_blocks() const;

  // optional bytes sha = 1;
  bool has_sha() const;
  private:
  bool _internal_has_sha() const;
  public:
  void clear_sha();
  const std::string& sha() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sha(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sha();
  PROTOBUF_NODISCARD std::string* release_sha();
  void set_allocated_sha(std::string* sha);
  private:
  const std::string& _internal_sha() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sha(const std::string& value);
  std::string* _internal_mutable_sha();
  public:

  // @@protoc_insertion_point(class_scope:ShaderProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ShaderAttributeProto > attribs_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ShaderUniformProto > uniforms_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ShaderVaryingProto > varyings_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ShaderOutputVariableProto > output_variables_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ShaderInterfaceBlockProto > interface_blocks_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sha_;
  friend struct ::TableStruct_disk_5fcache_5fproto_2eproto;
};
// -------------------------------------------------------------------

class GpuProgramProto final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:GpuProgramProto) */ {
 public:
  inline GpuProgramProto() : GpuProgramProto(nullptr) {}
  ~GpuProgramProto() override;
  explicit PROTOBUF_CONSTEXPR GpuProgramProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GpuProgramProto(const GpuProgramProto& from);
  GpuProgramProto(GpuProgramProto&& from) noexcept
    : GpuProgramProto() {
    *this = ::std::move(from);
  }

  inline GpuProgramProto& operator=(const GpuProgramProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline GpuProgramProto& operator=(GpuProgramProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const GpuProgramProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const GpuProgramProto* internal_default_instance() {
    return reinterpret_cast<const GpuProgramProto*>(
               &_GpuProgramProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(GpuProgramProto& a, GpuProgramProto& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(GpuProgramProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GpuProgramProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GpuProgramProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GpuProgramProto>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const GpuProgramProto& from);
  void MergeFrom(const GpuProgramProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GpuProgramProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GpuProgramProto";
  }
  protected:
  explicit GpuProgramProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kShaFieldNumber = 1,
    kProgramFieldNumber = 3,
    kVertexShaderFieldNumber = 4,
    kFragmentShaderFieldNumber = 5,
    kFormatFieldNumber = 2,
    kProgramIsCompressedFieldNumber = 6,
    kProgramDecompressedLengthFieldNumber = 7,
  };
  // optional bytes sha = 1;
  bool has_sha() const;
  private:
  bool _internal_has_sha() const;
  public:
  void clear_sha();
  const std::string& sha() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sha(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sha();
  PROTOBUF_NODISCARD std::string* release_sha();
  void set_allocated_sha(std::string* sha);
  private:
  const std::string& _internal_sha() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sha(const std::string& value);
  std::string* _internal_mutable_sha();
  public:

  // optional bytes program = 3;
  bool has_program() const;
  private:
  bool _internal_has_program() const;
  public:
  void clear_program();
  const std::string& program() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_program(ArgT0&& arg0, ArgT... args);
  std::string* mutable_program();
  PROTOBUF_NODISCARD std::string* release_program();
  void set_allocated_program(std::string* program);
  private:
  const std::string& _internal_program() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_program(const std::string& value);
  std::string* _internal_mutable_program();
  public:

  // optional .ShaderProto vertex_shader = 4;
  bool has_vertex_shader() const;
  private:
  bool _internal_has_vertex_shader() const;
  public:
  void clear_vertex_shader();
  const ::ShaderProto& vertex_shader() const;
  PROTOBUF_NODISCARD ::ShaderProto* release_vertex_shader();
  ::ShaderProto* mutable_vertex_shader();
  void set_allocated_vertex_shader(::ShaderProto* vertex_shader);
  private:
  const ::ShaderProto& _internal_vertex_shader() const;
  ::ShaderProto* _internal_mutable_vertex_shader();
  public:
  void unsafe_arena_set_allocated_vertex_shader(
      ::ShaderProto* vertex_shader);
  ::ShaderProto* unsafe_arena_release_vertex_shader();

  // optional .ShaderProto fragment_shader = 5;
  bool has_fragment_shader() const;
  private:
  bool _internal_has_fragment_shader() const;
  public:
  void clear_fragment_shader();
  const ::ShaderProto& fragment_shader() const;
  PROTOBUF_NODISCARD ::ShaderProto* release_fragment_shader();
  ::ShaderProto* mutable_fragment_shader();
  void set_allocated_fragment_shader(::ShaderProto* fragment_shader);
  private:
  const ::ShaderProto& _internal_fragment_shader() const;
  ::ShaderProto* _internal_mutable_fragment_shader();
  public:
  void unsafe_arena_set_allocated_fragment_shader(
      ::ShaderProto* fragment_shader);
  ::ShaderProto* unsafe_arena_release_fragment_shader();

  // optional uint32 format = 2;
  bool has_format() const;
  private:
  bool _internal_has_format() const;
  public:
  void clear_format();
  uint32_t format() const;
  void set_format(uint32_t value);
  private:
  uint32_t _internal_format() const;
  void _internal_set_format(uint32_t value);
  public:

  // optional bool program_is_compressed = 6;
  bool has_program_is_compressed() const;
  private:
  bool _internal_has_program_is_compressed() const;
  public:
  void clear_program_is_compressed();
  bool program_is_compressed() const;
  void set_program_is_compressed(bool value);
  private:
  bool _internal_program_is_compressed() const;
  void _internal_set_program_is_compressed(bool value);
  public:

  // optional uint32 program_decompressed_length = 7;
  bool has_program_decompressed_length() const;
  private:
  bool _internal_has_program_decompressed_length() const;
  public:
  void clear_program_decompressed_length();
  uint32_t program_decompressed_length() const;
  void set_program_decompressed_length(uint32_t value);
  private:
  uint32_t _internal_program_decompressed_length() const;
  void _internal_set_program_decompressed_length(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:GpuProgramProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sha_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr program_;
  ::ShaderProto* vertex_shader_;
  ::ShaderProto* fragment_shader_;
  uint32_t format_;
  bool program_is_compressed_;
  uint32_t program_decompressed_length_;
  friend struct ::TableStruct_disk_5fcache_5fproto_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ShaderVariableProto

// optional uint32 type = 1;
inline bool ShaderVariableProto::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ShaderVariableProto::has_type() const {
  return _internal_has_type();
}
inline void ShaderVariableProto::clear_type() {
  type_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline uint32_t ShaderVariableProto::_internal_type() const {
  return type_;
}
inline uint32_t ShaderVariableProto::type() const {
  // @@protoc_insertion_point(field_get:ShaderVariableProto.type)
  return _internal_type();
}
inline void ShaderVariableProto::_internal_set_type(uint32_t value) {
  _has_bits_[0] |= 0x00000008u;
  type_ = value;
}
inline void ShaderVariableProto::set_type(uint32_t value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:ShaderVariableProto.type)
}

// optional uint32 precision = 2;
inline bool ShaderVariableProto::_internal_has_precision() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ShaderVariableProto::has_precision() const {
  return _internal_has_precision();
}
inline void ShaderVariableProto::clear_precision() {
  precision_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline uint32_t ShaderVariableProto::_internal_precision() const {
  return precision_;
}
inline uint32_t ShaderVariableProto::precision() const {
  // @@protoc_insertion_point(field_get:ShaderVariableProto.precision)
  return _internal_precision();
}
inline void ShaderVariableProto::_internal_set_precision(uint32_t value) {
  _has_bits_[0] |= 0x00000010u;
  precision_ = value;
}
inline void ShaderVariableProto::set_precision(uint32_t value) {
  _internal_set_precision(value);
  // @@protoc_insertion_point(field_set:ShaderVariableProto.precision)
}

// optional string name = 3;
inline bool ShaderVariableProto::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ShaderVariableProto::has_name() const {
  return _internal_has_name();
}
inline void ShaderVariableProto::clear_name() {
  name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ShaderVariableProto::name() const {
  // @@protoc_insertion_point(field_get:ShaderVariableProto.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ShaderVariableProto::set_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ShaderVariableProto.name)
}
inline std::string* ShaderVariableProto::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:ShaderVariableProto.name)
  return _s;
}
inline const std::string& ShaderVariableProto::_internal_name() const {
  return name_.Get();
}
inline void ShaderVariableProto::_internal_set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(value, GetArenaForAllocation());
}
inline std::string* ShaderVariableProto::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  return name_.Mutable(GetArenaForAllocation());
}
inline std::string* ShaderVariableProto::release_name() {
  // @@protoc_insertion_point(field_release:ShaderVariableProto.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault()) {
    name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ShaderVariableProto::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault()) {
    name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ShaderVariableProto.name)
}

// optional string mapped_name = 4;
inline bool ShaderVariableProto::_internal_has_mapped_name() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ShaderVariableProto::has_mapped_name() const {
  return _internal_has_mapped_name();
}
inline void ShaderVariableProto::clear_mapped_name() {
  mapped_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ShaderVariableProto::mapped_name() const {
  // @@protoc_insertion_point(field_get:ShaderVariableProto.mapped_name)
  return _internal_mapped_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ShaderVariableProto::set_mapped_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 mapped_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ShaderVariableProto.mapped_name)
}
inline std::string* ShaderVariableProto::mutable_mapped_name() {
  std::string* _s = _internal_mutable_mapped_name();
  // @@protoc_insertion_point(field_mutable:ShaderVariableProto.mapped_name)
  return _s;
}
inline const std::string& ShaderVariableProto::_internal_mapped_name() const {
  return mapped_name_.Get();
}
inline void ShaderVariableProto::_internal_set_mapped_name(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  mapped_name_.Set(value, GetArenaForAllocation());
}
inline std::string* ShaderVariableProto::_internal_mutable_mapped_name() {
  _has_bits_[0] |= 0x00000002u;
  return mapped_name_.Mutable(GetArenaForAllocation());
}
inline std::string* ShaderVariableProto::release_mapped_name() {
  // @@protoc_insertion_point(field_release:ShaderVariableProto.mapped_name)
  if (!_internal_has_mapped_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = mapped_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (mapped_name_.IsDefault()) {
    mapped_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ShaderVariableProto::set_allocated_mapped_name(std::string* mapped_name) {
  if (mapped_name != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  mapped_name_.SetAllocated(mapped_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (mapped_name_.IsDefault()) {
    mapped_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ShaderVariableProto.mapped_name)
}

// optional uint32 array_size = 5;
inline bool ShaderVariableProto::_internal_has_array_size() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool ShaderVariableProto::has_array_size() const {
  return _internal_has_array_size();
}
inline void ShaderVariableProto::clear_array_size() {
  array_size_ = 0u;
  _has_bits_[0] &= ~0x00000020u;
}
inline uint32_t ShaderVariableProto::_internal_array_size() const {
  return array_size_;
}
inline uint32_t ShaderVariableProto::array_size() const {
  // @@protoc_insertion_point(field_get:ShaderVariableProto.array_size)
  return _internal_array_size();
}
inline void ShaderVariableProto::_internal_set_array_size(uint32_t value) {
  _has_bits_[0] |= 0x00000020u;
  array_size_ = value;
}
inline void ShaderVariableProto::set_array_size(uint32_t value) {
  _internal_set_array_size(value);
  // @@protoc_insertion_point(field_set:ShaderVariableProto.array_size)
}

// optional bool static_use = 6;
inline bool ShaderVariableProto::_internal_has_static_use() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool ShaderVariableProto::has_static_use() const {
  return _internal_has_static_use();
}
inline void ShaderVariableProto::clear_static_use() {
  static_use_ = false;
  _has_bits_[0] &= ~0x00000040u;
}
inline bool ShaderVariableProto::_internal_static_use() const {
  return static_use_;
}
inline bool ShaderVariableProto::static_use() const {
  // @@protoc_insertion_point(field_get:ShaderVariableProto.static_use)
  return _internal_static_use();
}
inline void ShaderVariableProto::_internal_set_static_use(bool value) {
  _has_bits_[0] |= 0x00000040u;
  static_use_ = value;
}
inline void ShaderVariableProto::set_static_use(bool value) {
  _internal_set_static_use(value);
  // @@protoc_insertion_point(field_set:ShaderVariableProto.static_use)
}

// repeated .ShaderVariableProto fields = 7;
inline int ShaderVariableProto::_internal_fields_size() const {
  return fields_.size();
}
inline int ShaderVariableProto::fields_size() const {
  return _internal_fields_size();
}
inline void ShaderVariableProto::clear_fields() {
  fields_.Clear();
}
inline ::ShaderVariableProto* ShaderVariableProto::mutable_fields(int index) {
  // @@protoc_insertion_point(field_mutable:ShaderVariableProto.fields)
  return fields_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ShaderVariableProto >*
ShaderVariableProto::mutable_fields() {
  // @@protoc_insertion_point(field_mutable_list:ShaderVariableProto.fields)
  return &fields_;
}
inline const ::ShaderVariableProto& ShaderVariableProto::_internal_fields(int index) const {
  return fields_.Get(index);
}
inline const ::ShaderVariableProto& ShaderVariableProto::fields(int index) const {
  // @@protoc_insertion_point(field_get:ShaderVariableProto.fields)
  return _internal_fields(index);
}
inline ::ShaderVariableProto* ShaderVariableProto::_internal_add_fields() {
  return fields_.Add();
}
inline ::ShaderVariableProto* ShaderVariableProto::add_fields() {
  ::ShaderVariableProto* _add = _internal_add_fields();
  // @@protoc_insertion_point(field_add:ShaderVariableProto.fields)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ShaderVariableProto >&
ShaderVariableProto::fields() const {
  // @@protoc_insertion_point(field_list:ShaderVariableProto.fields)
  return fields_;
}

// optional string struct_name = 8;
inline bool ShaderVariableProto::_internal_has_struct_name() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ShaderVariableProto::has_struct_name() const {
  return _internal_has_struct_name();
}
inline void ShaderVariableProto::clear_struct_name() {
  struct_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& ShaderVariableProto::struct_name() const {
  // @@protoc_insertion_point(field_get:ShaderVariableProto.struct_name)
  return _internal_struct_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ShaderVariableProto::set_struct_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 struct_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ShaderVariableProto.struct_name)
}
inline std::string* ShaderVariableProto::mutable_struct_name() {
  std::string* _s = _internal_mutable_struct_name();
  // @@protoc_insertion_point(field_mutable:ShaderVariableProto.struct_name)
  return _s;
}
inline const std::string& ShaderVariableProto::_internal_struct_name() const {
  return struct_name_.Get();
}
inline void ShaderVariableProto::_internal_set_struct_name(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  struct_name_.Set(value, GetArenaForAllocation());
}
inline std::string* ShaderVariableProto::_internal_mutable_struct_name() {
  _has_bits_[0] |= 0x00000004u;
  return struct_name_.Mutable(GetArenaForAllocation());
}
inline std::string* ShaderVariableProto::release_struct_name() {
  // @@protoc_insertion_point(field_release:ShaderVariableProto.struct_name)
  if (!_internal_has_struct_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = struct_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (struct_name_.IsDefault()) {
    struct_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ShaderVariableProto::set_allocated_struct_name(std::string* struct_name) {
  if (struct_name != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  struct_name_.SetAllocated(struct_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (struct_name_.IsDefault()) {
    struct_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ShaderVariableProto.struct_name)
}

// -------------------------------------------------------------------

// ShaderAttributeProto

// optional .ShaderVariableProto basic = 1;
inline bool ShaderAttributeProto::_internal_has_basic() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || basic_ != nullptr);
  return value;
}
inline bool ShaderAttributeProto::has_basic() const {
  return _internal_has_basic();
}
inline void ShaderAttributeProto::clear_basic() {
  if (basic_ != nullptr) basic_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::ShaderVariableProto& ShaderAttributeProto::_internal_basic() const {
  const ::ShaderVariableProto* p = basic_;
  return p != nullptr ? *p : reinterpret_cast<const ::ShaderVariableProto&>(
      ::_ShaderVariableProto_default_instance_);
}
inline const ::ShaderVariableProto& ShaderAttributeProto::basic() const {
  // @@protoc_insertion_point(field_get:ShaderAttributeProto.basic)
  return _internal_basic();
}
inline void ShaderAttributeProto::unsafe_arena_set_allocated_basic(
    ::ShaderVariableProto* basic) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(basic_);
  }
  basic_ = basic;
  if (basic) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ShaderAttributeProto.basic)
}
inline ::ShaderVariableProto* ShaderAttributeProto::release_basic() {
  _has_bits_[0] &= ~0x00000001u;
  ::ShaderVariableProto* temp = basic_;
  basic_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ShaderVariableProto* ShaderAttributeProto::unsafe_arena_release_basic() {
  // @@protoc_insertion_point(field_release:ShaderAttributeProto.basic)
  _has_bits_[0] &= ~0x00000001u;
  ::ShaderVariableProto* temp = basic_;
  basic_ = nullptr;
  return temp;
}
inline ::ShaderVariableProto* ShaderAttributeProto::_internal_mutable_basic() {
  _has_bits_[0] |= 0x00000001u;
  if (basic_ == nullptr) {
    auto* p = CreateMaybeMessage<::ShaderVariableProto>(GetArenaForAllocation());
    basic_ = p;
  }
  return basic_;
}
inline ::ShaderVariableProto* ShaderAttributeProto::mutable_basic() {
  ::ShaderVariableProto* _msg = _internal_mutable_basic();
  // @@protoc_insertion_point(field_mutable:ShaderAttributeProto.basic)
  return _msg;
}
inline void ShaderAttributeProto::set_allocated_basic(::ShaderVariableProto* basic) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete basic_;
  }
  if (basic) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(basic);
    if (message_arena != submessage_arena) {
      basic = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, basic, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  basic_ = basic;
  // @@protoc_insertion_point(field_set_allocated:ShaderAttributeProto.basic)
}

// optional int32 location = 2;
inline bool ShaderAttributeProto::_internal_has_location() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ShaderAttributeProto::has_location() const {
  return _internal_has_location();
}
inline void ShaderAttributeProto::clear_location() {
  location_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline int32_t ShaderAttributeProto::_internal_location() const {
  return location_;
}
inline int32_t ShaderAttributeProto::location() const {
  // @@protoc_insertion_point(field_get:ShaderAttributeProto.location)
  return _internal_location();
}
inline void ShaderAttributeProto::_internal_set_location(int32_t value) {
  _has_bits_[0] |= 0x00000002u;
  location_ = value;
}
inline void ShaderAttributeProto::set_location(int32_t value) {
  _internal_set_location(value);
  // @@protoc_insertion_point(field_set:ShaderAttributeProto.location)
}

// -------------------------------------------------------------------

// ShaderUniformProto

// optional .ShaderVariableProto basic = 1;
inline bool ShaderUniformProto::_internal_has_basic() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || basic_ != nullptr);
  return value;
}
inline bool ShaderUniformProto::has_basic() const {
  return _internal_has_basic();
}
inline void ShaderUniformProto::clear_basic() {
  if (basic_ != nullptr) basic_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::ShaderVariableProto& ShaderUniformProto::_internal_basic() const {
  const ::ShaderVariableProto* p = basic_;
  return p != nullptr ? *p : reinterpret_cast<const ::ShaderVariableProto&>(
      ::_ShaderVariableProto_default_instance_);
}
inline const ::ShaderVariableProto& ShaderUniformProto::basic() const {
  // @@protoc_insertion_point(field_get:ShaderUniformProto.basic)
  return _internal_basic();
}
inline void ShaderUniformProto::unsafe_arena_set_allocated_basic(
    ::ShaderVariableProto* basic) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(basic_);
  }
  basic_ = basic;
  if (basic) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ShaderUniformProto.basic)
}
inline ::ShaderVariableProto* ShaderUniformProto::release_basic() {
  _has_bits_[0] &= ~0x00000001u;
  ::ShaderVariableProto* temp = basic_;
  basic_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ShaderVariableProto* ShaderUniformProto::unsafe_arena_release_basic() {
  // @@protoc_insertion_point(field_release:ShaderUniformProto.basic)
  _has_bits_[0] &= ~0x00000001u;
  ::ShaderVariableProto* temp = basic_;
  basic_ = nullptr;
  return temp;
}
inline ::ShaderVariableProto* ShaderUniformProto::_internal_mutable_basic() {
  _has_bits_[0] |= 0x00000001u;
  if (basic_ == nullptr) {
    auto* p = CreateMaybeMessage<::ShaderVariableProto>(GetArenaForAllocation());
    basic_ = p;
  }
  return basic_;
}
inline ::ShaderVariableProto* ShaderUniformProto::mutable_basic() {
  ::ShaderVariableProto* _msg = _internal_mutable_basic();
  // @@protoc_insertion_point(field_mutable:ShaderUniformProto.basic)
  return _msg;
}
inline void ShaderUniformProto::set_allocated_basic(::ShaderVariableProto* basic) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete basic_;
  }
  if (basic) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(basic);
    if (message_arena != submessage_arena) {
      basic = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, basic, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  basic_ = basic;
  // @@protoc_insertion_point(field_set_allocated:ShaderUniformProto.basic)
}

// -------------------------------------------------------------------

// ShaderVaryingProto

// optional .ShaderVariableProto basic = 1;
inline bool ShaderVaryingProto::_internal_has_basic() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || basic_ != nullptr);
  return value;
}
inline bool ShaderVaryingProto::has_basic() const {
  return _internal_has_basic();
}
inline void ShaderVaryingProto::clear_basic() {
  if (basic_ != nullptr) basic_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::ShaderVariableProto& ShaderVaryingProto::_internal_basic() const {
  const ::ShaderVariableProto* p = basic_;
  return p != nullptr ? *p : reinterpret_cast<const ::ShaderVariableProto&>(
      ::_ShaderVariableProto_default_instance_);
}
inline const ::ShaderVariableProto& ShaderVaryingProto::basic() const {
  // @@protoc_insertion_point(field_get:ShaderVaryingProto.basic)
  return _internal_basic();
}
inline void ShaderVaryingProto::unsafe_arena_set_allocated_basic(
    ::ShaderVariableProto* basic) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(basic_);
  }
  basic_ = basic;
  if (basic) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ShaderVaryingProto.basic)
}
inline ::ShaderVariableProto* ShaderVaryingProto::release_basic() {
  _has_bits_[0] &= ~0x00000001u;
  ::ShaderVariableProto* temp = basic_;
  basic_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ShaderVariableProto* ShaderVaryingProto::unsafe_arena_release_basic() {
  // @@protoc_insertion_point(field_release:ShaderVaryingProto.basic)
  _has_bits_[0] &= ~0x00000001u;
  ::ShaderVariableProto* temp = basic_;
  basic_ = nullptr;
  return temp;
}
inline ::ShaderVariableProto* ShaderVaryingProto::_internal_mutable_basic() {
  _has_bits_[0] |= 0x00000001u;
  if (basic_ == nullptr) {
    auto* p = CreateMaybeMessage<::ShaderVariableProto>(GetArenaForAllocation());
    basic_ = p;
  }
  return basic_;
}
inline ::ShaderVariableProto* ShaderVaryingProto::mutable_basic() {
  ::ShaderVariableProto* _msg = _internal_mutable_basic();
  // @@protoc_insertion_point(field_mutable:ShaderVaryingProto.basic)
  return _msg;
}
inline void ShaderVaryingProto::set_allocated_basic(::ShaderVariableProto* basic) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete basic_;
  }
  if (basic) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(basic);
    if (message_arena != submessage_arena) {
      basic = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, basic, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  basic_ = basic;
  // @@protoc_insertion_point(field_set_allocated:ShaderVaryingProto.basic)
}

// optional int32 interpolation = 2;
inline bool ShaderVaryingProto::_internal_has_interpolation() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ShaderVaryingProto::has_interpolation() const {
  return _internal_has_interpolation();
}
inline void ShaderVaryingProto::clear_interpolation() {
  interpolation_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline int32_t ShaderVaryingProto::_internal_interpolation() const {
  return interpolation_;
}
inline int32_t ShaderVaryingProto::interpolation() const {
  // @@protoc_insertion_point(field_get:ShaderVaryingProto.interpolation)
  return _internal_interpolation();
}
inline void ShaderVaryingProto::_internal_set_interpolation(int32_t value) {
  _has_bits_[0] |= 0x00000002u;
  interpolation_ = value;
}
inline void ShaderVaryingProto::set_interpolation(int32_t value) {
  _internal_set_interpolation(value);
  // @@protoc_insertion_point(field_set:ShaderVaryingProto.interpolation)
}

// optional bool is_invariant = 3;
inline bool ShaderVaryingProto::_internal_has_is_invariant() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ShaderVaryingProto::has_is_invariant() const {
  return _internal_has_is_invariant();
}
inline void ShaderVaryingProto::clear_is_invariant() {
  is_invariant_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool ShaderVaryingProto::_internal_is_invariant() const {
  return is_invariant_;
}
inline bool ShaderVaryingProto::is_invariant() const {
  // @@protoc_insertion_point(field_get:ShaderVaryingProto.is_invariant)
  return _internal_is_invariant();
}
inline void ShaderVaryingProto::_internal_set_is_invariant(bool value) {
  _has_bits_[0] |= 0x00000004u;
  is_invariant_ = value;
}
inline void ShaderVaryingProto::set_is_invariant(bool value) {
  _internal_set_is_invariant(value);
  // @@protoc_insertion_point(field_set:ShaderVaryingProto.is_invariant)
}

// -------------------------------------------------------------------

// ShaderOutputVariableProto

// optional .ShaderVariableProto basic = 1;
inline bool ShaderOutputVariableProto::_internal_has_basic() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || basic_ != nullptr);
  return value;
}
inline bool ShaderOutputVariableProto::has_basic() const {
  return _internal_has_basic();
}
inline void ShaderOutputVariableProto::clear_basic() {
  if (basic_ != nullptr) basic_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::ShaderVariableProto& ShaderOutputVariableProto::_internal_basic() const {
  const ::ShaderVariableProto* p = basic_;
  return p != nullptr ? *p : reinterpret_cast<const ::ShaderVariableProto&>(
      ::_ShaderVariableProto_default_instance_);
}
inline const ::ShaderVariableProto& ShaderOutputVariableProto::basic() const {
  // @@protoc_insertion_point(field_get:ShaderOutputVariableProto.basic)
  return _internal_basic();
}
inline void ShaderOutputVariableProto::unsafe_arena_set_allocated_basic(
    ::ShaderVariableProto* basic) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(basic_);
  }
  basic_ = basic;
  if (basic) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ShaderOutputVariableProto.basic)
}
inline ::ShaderVariableProto* ShaderOutputVariableProto::release_basic() {
  _has_bits_[0] &= ~0x00000001u;
  ::ShaderVariableProto* temp = basic_;
  basic_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ShaderVariableProto* ShaderOutputVariableProto::unsafe_arena_release_basic() {
  // @@protoc_insertion_point(field_release:ShaderOutputVariableProto.basic)
  _has_bits_[0] &= ~0x00000001u;
  ::ShaderVariableProto* temp = basic_;
  basic_ = nullptr;
  return temp;
}
inline ::ShaderVariableProto* ShaderOutputVariableProto::_internal_mutable_basic() {
  _has_bits_[0] |= 0x00000001u;
  if (basic_ == nullptr) {
    auto* p = CreateMaybeMessage<::ShaderVariableProto>(GetArenaForAllocation());
    basic_ = p;
  }
  return basic_;
}
inline ::ShaderVariableProto* ShaderOutputVariableProto::mutable_basic() {
  ::ShaderVariableProto* _msg = _internal_mutable_basic();
  // @@protoc_insertion_point(field_mutable:ShaderOutputVariableProto.basic)
  return _msg;
}
inline void ShaderOutputVariableProto::set_allocated_basic(::ShaderVariableProto* basic) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete basic_;
  }
  if (basic) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(basic);
    if (message_arena != submessage_arena) {
      basic = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, basic, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  basic_ = basic;
  // @@protoc_insertion_point(field_set_allocated:ShaderOutputVariableProto.basic)
}

// optional int32 location = 2;
inline bool ShaderOutputVariableProto::_internal_has_location() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ShaderOutputVariableProto::has_location() const {
  return _internal_has_location();
}
inline void ShaderOutputVariableProto::clear_location() {
  location_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline int32_t ShaderOutputVariableProto::_internal_location() const {
  return location_;
}
inline int32_t ShaderOutputVariableProto::location() const {
  // @@protoc_insertion_point(field_get:ShaderOutputVariableProto.location)
  return _internal_location();
}
inline void ShaderOutputVariableProto::_internal_set_location(int32_t value) {
  _has_bits_[0] |= 0x00000002u;
  location_ = value;
}
inline void ShaderOutputVariableProto::set_location(int32_t value) {
  _internal_set_location(value);
  // @@protoc_insertion_point(field_set:ShaderOutputVariableProto.location)
}

// -------------------------------------------------------------------

// ShaderInterfaceBlockFieldProto

// optional .ShaderVariableProto basic = 1;
inline bool ShaderInterfaceBlockFieldProto::_internal_has_basic() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || basic_ != nullptr);
  return value;
}
inline bool ShaderInterfaceBlockFieldProto::has_basic() const {
  return _internal_has_basic();
}
inline void ShaderInterfaceBlockFieldProto::clear_basic() {
  if (basic_ != nullptr) basic_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::ShaderVariableProto& ShaderInterfaceBlockFieldProto::_internal_basic() const {
  const ::ShaderVariableProto* p = basic_;
  return p != nullptr ? *p : reinterpret_cast<const ::ShaderVariableProto&>(
      ::_ShaderVariableProto_default_instance_);
}
inline const ::ShaderVariableProto& ShaderInterfaceBlockFieldProto::basic() const {
  // @@protoc_insertion_point(field_get:ShaderInterfaceBlockFieldProto.basic)
  return _internal_basic();
}
inline void ShaderInterfaceBlockFieldProto::unsafe_arena_set_allocated_basic(
    ::ShaderVariableProto* basic) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(basic_);
  }
  basic_ = basic;
  if (basic) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ShaderInterfaceBlockFieldProto.basic)
}
inline ::ShaderVariableProto* ShaderInterfaceBlockFieldProto::release_basic() {
  _has_bits_[0] &= ~0x00000001u;
  ::ShaderVariableProto* temp = basic_;
  basic_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ShaderVariableProto* ShaderInterfaceBlockFieldProto::unsafe_arena_release_basic() {
  // @@protoc_insertion_point(field_release:ShaderInterfaceBlockFieldProto.basic)
  _has_bits_[0] &= ~0x00000001u;
  ::ShaderVariableProto* temp = basic_;
  basic_ = nullptr;
  return temp;
}
inline ::ShaderVariableProto* ShaderInterfaceBlockFieldProto::_internal_mutable_basic() {
  _has_bits_[0] |= 0x00000001u;
  if (basic_ == nullptr) {
    auto* p = CreateMaybeMessage<::ShaderVariableProto>(GetArenaForAllocation());
    basic_ = p;
  }
  return basic_;
}
inline ::ShaderVariableProto* ShaderInterfaceBlockFieldProto::mutable_basic() {
  ::ShaderVariableProto* _msg = _internal_mutable_basic();
  // @@protoc_insertion_point(field_mutable:ShaderInterfaceBlockFieldProto.basic)
  return _msg;
}
inline void ShaderInterfaceBlockFieldProto::set_allocated_basic(::ShaderVariableProto* basic) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete basic_;
  }
  if (basic) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(basic);
    if (message_arena != submessage_arena) {
      basic = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, basic, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  basic_ = basic;
  // @@protoc_insertion_point(field_set_allocated:ShaderInterfaceBlockFieldProto.basic)
}

// optional bool is_row_major_layout = 2;
inline bool ShaderInterfaceBlockFieldProto::_internal_has_is_row_major_layout() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ShaderInterfaceBlockFieldProto::has_is_row_major_layout() const {
  return _internal_has_is_row_major_layout();
}
inline void ShaderInterfaceBlockFieldProto::clear_is_row_major_layout() {
  is_row_major_layout_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool ShaderInterfaceBlockFieldProto::_internal_is_row_major_layout() const {
  return is_row_major_layout_;
}
inline bool ShaderInterfaceBlockFieldProto::is_row_major_layout() const {
  // @@protoc_insertion_point(field_get:ShaderInterfaceBlockFieldProto.is_row_major_layout)
  return _internal_is_row_major_layout();
}
inline void ShaderInterfaceBlockFieldProto::_internal_set_is_row_major_layout(bool value) {
  _has_bits_[0] |= 0x00000002u;
  is_row_major_layout_ = value;
}
inline void ShaderInterfaceBlockFieldProto::set_is_row_major_layout(bool value) {
  _internal_set_is_row_major_layout(value);
  // @@protoc_insertion_point(field_set:ShaderInterfaceBlockFieldProto.is_row_major_layout)
}

// -------------------------------------------------------------------

// ShaderInterfaceBlockProto

// optional string name = 1;
inline bool ShaderInterfaceBlockProto::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ShaderInterfaceBlockProto::has_name() const {
  return _internal_has_name();
}
inline void ShaderInterfaceBlockProto::clear_name() {
  name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ShaderInterfaceBlockProto::name() const {
  // @@protoc_insertion_point(field_get:ShaderInterfaceBlockProto.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ShaderInterfaceBlockProto::set_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ShaderInterfaceBlockProto.name)
}
inline std::string* ShaderInterfaceBlockProto::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:ShaderInterfaceBlockProto.name)
  return _s;
}
inline const std::string& ShaderInterfaceBlockProto::_internal_name() const {
  return name_.Get();
}
inline void ShaderInterfaceBlockProto::_internal_set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(value, GetArenaForAllocation());
}
inline std::string* ShaderInterfaceBlockProto::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  return name_.Mutable(GetArenaForAllocation());
}
inline std::string* ShaderInterfaceBlockProto::release_name() {
  // @@protoc_insertion_point(field_release:ShaderInterfaceBlockProto.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault()) {
    name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ShaderInterfaceBlockProto::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault()) {
    name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ShaderInterfaceBlockProto.name)
}

// optional string mapped_name = 2;
inline bool ShaderInterfaceBlockProto::_internal_has_mapped_name() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ShaderInterfaceBlockProto::has_mapped_name() const {
  return _internal_has_mapped_name();
}
inline void ShaderInterfaceBlockProto::clear_mapped_name() {
  mapped_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ShaderInterfaceBlockProto::mapped_name() const {
  // @@protoc_insertion_point(field_get:ShaderInterfaceBlockProto.mapped_name)
  return _internal_mapped_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ShaderInterfaceBlockProto::set_mapped_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 mapped_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ShaderInterfaceBlockProto.mapped_name)
}
inline std::string* ShaderInterfaceBlockProto::mutable_mapped_name() {
  std::string* _s = _internal_mutable_mapped_name();
  // @@protoc_insertion_point(field_mutable:ShaderInterfaceBlockProto.mapped_name)
  return _s;
}
inline const std::string& ShaderInterfaceBlockProto::_internal_mapped_name() const {
  return mapped_name_.Get();
}
inline void ShaderInterfaceBlockProto::_internal_set_mapped_name(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  mapped_name_.Set(value, GetArenaForAllocation());
}
inline std::string* ShaderInterfaceBlockProto::_internal_mutable_mapped_name() {
  _has_bits_[0] |= 0x00000002u;
  return mapped_name_.Mutable(GetArenaForAllocation());
}
inline std::string* ShaderInterfaceBlockProto::release_mapped_name() {
  // @@protoc_insertion_point(field_release:ShaderInterfaceBlockProto.mapped_name)
  if (!_internal_has_mapped_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = mapped_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (mapped_name_.IsDefault()) {
    mapped_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ShaderInterfaceBlockProto::set_allocated_mapped_name(std::string* mapped_name) {
  if (mapped_name != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  mapped_name_.SetAllocated(mapped_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (mapped_name_.IsDefault()) {
    mapped_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ShaderInterfaceBlockProto.mapped_name)
}

// optional string instance_name = 3;
inline bool ShaderInterfaceBlockProto::_internal_has_instance_name() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ShaderInterfaceBlockProto::has_instance_name() const {
  return _internal_has_instance_name();
}
inline void ShaderInterfaceBlockProto::clear_instance_name() {
  instance_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& ShaderInterfaceBlockProto::instance_name() const {
  // @@protoc_insertion_point(field_get:ShaderInterfaceBlockProto.instance_name)
  return _internal_instance_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ShaderInterfaceBlockProto::set_instance_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 instance_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ShaderInterfaceBlockProto.instance_name)
}
inline std::string* ShaderInterfaceBlockProto::mutable_instance_name() {
  std::string* _s = _internal_mutable_instance_name();
  // @@protoc_insertion_point(field_mutable:ShaderInterfaceBlockProto.instance_name)
  return _s;
}
inline const std::string& ShaderInterfaceBlockProto::_internal_instance_name() const {
  return instance_name_.Get();
}
inline void ShaderInterfaceBlockProto::_internal_set_instance_name(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  instance_name_.Set(value, GetArenaForAllocation());
}
inline std::string* ShaderInterfaceBlockProto::_internal_mutable_instance_name() {
  _has_bits_[0] |= 0x00000004u;
  return instance_name_.Mutable(GetArenaForAllocation());
}
inline std::string* ShaderInterfaceBlockProto::release_instance_name() {
  // @@protoc_insertion_point(field_release:ShaderInterfaceBlockProto.instance_name)
  if (!_internal_has_instance_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = instance_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (instance_name_.IsDefault()) {
    instance_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ShaderInterfaceBlockProto::set_allocated_instance_name(std::string* instance_name) {
  if (instance_name != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  instance_name_.SetAllocated(instance_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (instance_name_.IsDefault()) {
    instance_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ShaderInterfaceBlockProto.instance_name)
}

// optional uint32 array_size = 4;
inline bool ShaderInterfaceBlockProto::_internal_has_array_size() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ShaderInterfaceBlockProto::has_array_size() const {
  return _internal_has_array_size();
}
inline void ShaderInterfaceBlockProto::clear_array_size() {
  array_size_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline uint32_t ShaderInterfaceBlockProto::_internal_array_size() const {
  return array_size_;
}
inline uint32_t ShaderInterfaceBlockProto::array_size() const {
  // @@protoc_insertion_point(field_get:ShaderInterfaceBlockProto.array_size)
  return _internal_array_size();
}
inline void ShaderInterfaceBlockProto::_internal_set_array_size(uint32_t value) {
  _has_bits_[0] |= 0x00000008u;
  array_size_ = value;
}
inline void ShaderInterfaceBlockProto::set_array_size(uint32_t value) {
  _internal_set_array_size(value);
  // @@protoc_insertion_point(field_set:ShaderInterfaceBlockProto.array_size)
}

// optional int32 layout = 5;
inline bool ShaderInterfaceBlockProto::_internal_has_layout() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ShaderInterfaceBlockProto::has_layout() const {
  return _internal_has_layout();
}
inline void ShaderInterfaceBlockProto::clear_layout() {
  layout_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline int32_t ShaderInterfaceBlockProto::_internal_layout() const {
  return layout_;
}
inline int32_t ShaderInterfaceBlockProto::layout() const {
  // @@protoc_insertion_point(field_get:ShaderInterfaceBlockProto.layout)
  return _internal_layout();
}
inline void ShaderInterfaceBlockProto::_internal_set_layout(int32_t value) {
  _has_bits_[0] |= 0x00000010u;
  layout_ = value;
}
inline void ShaderInterfaceBlockProto::set_layout(int32_t value) {
  _internal_set_layout(value);
  // @@protoc_insertion_point(field_set:ShaderInterfaceBlockProto.layout)
}

// optional bool is_row_major_layout = 6;
inline bool ShaderInterfaceBlockProto::_internal_has_is_row_major_layout() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool ShaderInterfaceBlockProto::has_is_row_major_layout() const {
  return _internal_has_is_row_major_layout();
}
inline void ShaderInterfaceBlockProto::clear_is_row_major_layout() {
  is_row_major_layout_ = false;
  _has_bits_[0] &= ~0x00000020u;
}
inline bool ShaderInterfaceBlockProto::_internal_is_row_major_layout() const {
  return is_row_major_layout_;
}
inline bool ShaderInterfaceBlockProto::is_row_major_layout() const {
  // @@protoc_insertion_point(field_get:ShaderInterfaceBlockProto.is_row_major_layout)
  return _internal_is_row_major_layout();
}
inline void ShaderInterfaceBlockProto::_internal_set_is_row_major_layout(bool value) {
  _has_bits_[0] |= 0x00000020u;
  is_row_major_layout_ = value;
}
inline void ShaderInterfaceBlockProto::set_is_row_major_layout(bool value) {
  _internal_set_is_row_major_layout(value);
  // @@protoc_insertion_point(field_set:ShaderInterfaceBlockProto.is_row_major_layout)
}

// optional bool static_use = 7;
inline bool ShaderInterfaceBlockProto::_internal_has_static_use() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool ShaderInterfaceBlockProto::has_static_use() const {
  return _internal_has_static_use();
}
inline void ShaderInterfaceBlockProto::clear_static_use() {
  static_use_ = false;
  _has_bits_[0] &= ~0x00000040u;
}
inline bool ShaderInterfaceBlockProto::_internal_static_use() const {
  return static_use_;
}
inline bool ShaderInterfaceBlockProto::static_use() const {
  // @@protoc_insertion_point(field_get:ShaderInterfaceBlockProto.static_use)
  return _internal_static_use();
}
inline void ShaderInterfaceBlockProto::_internal_set_static_use(bool value) {
  _has_bits_[0] |= 0x00000040u;
  static_use_ = value;
}
inline void ShaderInterfaceBlockProto::set_static_use(bool value) {
  _internal_set_static_use(value);
  // @@protoc_insertion_point(field_set:ShaderInterfaceBlockProto.static_use)
}

// repeated .ShaderInterfaceBlockFieldProto fields = 8;
inline int ShaderInterfaceBlockProto::_internal_fields_size() const {
  return fields_.size();
}
inline int ShaderInterfaceBlockProto::fields_size() const {
  return _internal_fields_size();
}
inline void ShaderInterfaceBlockProto::clear_fields() {
  fields_.Clear();
}
inline ::ShaderInterfaceBlockFieldProto* ShaderInterfaceBlockProto::mutable_fields(int index) {
  // @@protoc_insertion_point(field_mutable:ShaderInterfaceBlockProto.fields)
  return fields_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ShaderInterfaceBlockFieldProto >*
ShaderInterfaceBlockProto::mutable_fields() {
  // @@protoc_insertion_point(field_mutable_list:ShaderInterfaceBlockProto.fields)
  return &fields_;
}
inline const ::ShaderInterfaceBlockFieldProto& ShaderInterfaceBlockProto::_internal_fields(int index) const {
  return fields_.Get(index);
}
inline const ::ShaderInterfaceBlockFieldProto& ShaderInterfaceBlockProto::fields(int index) const {
  // @@protoc_insertion_point(field_get:ShaderInterfaceBlockProto.fields)
  return _internal_fields(index);
}
inline ::ShaderInterfaceBlockFieldProto* ShaderInterfaceBlockProto::_internal_add_fields() {
  return fields_.Add();
}
inline ::ShaderInterfaceBlockFieldProto* ShaderInterfaceBlockProto::add_fields() {
  ::ShaderInterfaceBlockFieldProto* _add = _internal_add_fields();
  // @@protoc_insertion_point(field_add:ShaderInterfaceBlockProto.fields)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ShaderInterfaceBlockFieldProto >&
ShaderInterfaceBlockProto::fields() const {
  // @@protoc_insertion_point(field_list:ShaderInterfaceBlockProto.fields)
  return fields_;
}

// -------------------------------------------------------------------

// ShaderProto

// optional bytes sha = 1;
inline bool ShaderProto::_internal_has_sha() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ShaderProto::has_sha() const {
  return _internal_has_sha();
}
inline void ShaderProto::clear_sha() {
  sha_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ShaderProto::sha() const {
  // @@protoc_insertion_point(field_get:ShaderProto.sha)
  return _internal_sha();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ShaderProto::set_sha(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 sha_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ShaderProto.sha)
}
inline std::string* ShaderProto::mutable_sha() {
  std::string* _s = _internal_mutable_sha();
  // @@protoc_insertion_point(field_mutable:ShaderProto.sha)
  return _s;
}
inline const std::string& ShaderProto::_internal_sha() const {
  return sha_.Get();
}
inline void ShaderProto::_internal_set_sha(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  sha_.Set(value, GetArenaForAllocation());
}
inline std::string* ShaderProto::_internal_mutable_sha() {
  _has_bits_[0] |= 0x00000001u;
  return sha_.Mutable(GetArenaForAllocation());
}
inline std::string* ShaderProto::release_sha() {
  // @@protoc_insertion_point(field_release:ShaderProto.sha)
  if (!_internal_has_sha()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = sha_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (sha_.IsDefault()) {
    sha_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ShaderProto::set_allocated_sha(std::string* sha) {
  if (sha != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  sha_.SetAllocated(sha, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (sha_.IsDefault()) {
    sha_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ShaderProto.sha)
}

// repeated .ShaderAttributeProto attribs = 2;
inline int ShaderProto::_internal_attribs_size() const {
  return attribs_.size();
}
inline int ShaderProto::attribs_size() const {
  return _internal_attribs_size();
}
inline void ShaderProto::clear_attribs() {
  attribs_.Clear();
}
inline ::ShaderAttributeProto* ShaderProto::mutable_attribs(int index) {
  // @@protoc_insertion_point(field_mutable:ShaderProto.attribs)
  return attribs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ShaderAttributeProto >*
ShaderProto::mutable_attribs() {
  // @@protoc_insertion_point(field_mutable_list:ShaderProto.attribs)
  return &attribs_;
}
inline const ::ShaderAttributeProto& ShaderProto::_internal_attribs(int index) const {
  return attribs_.Get(index);
}
inline const ::ShaderAttributeProto& ShaderProto::attribs(int index) const {
  // @@protoc_insertion_point(field_get:ShaderProto.attribs)
  return _internal_attribs(index);
}
inline ::ShaderAttributeProto* ShaderProto::_internal_add_attribs() {
  return attribs_.Add();
}
inline ::ShaderAttributeProto* ShaderProto::add_attribs() {
  ::ShaderAttributeProto* _add = _internal_add_attribs();
  // @@protoc_insertion_point(field_add:ShaderProto.attribs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ShaderAttributeProto >&
ShaderProto::attribs() const {
  // @@protoc_insertion_point(field_list:ShaderProto.attribs)
  return attribs_;
}

// repeated .ShaderUniformProto uniforms = 3;
inline int ShaderProto::_internal_uniforms_size() const {
  return uniforms_.size();
}
inline int ShaderProto::uniforms_size() const {
  return _internal_uniforms_size();
}
inline void ShaderProto::clear_uniforms() {
  uniforms_.Clear();
}
inline ::ShaderUniformProto* ShaderProto::mutable_uniforms(int index) {
  // @@protoc_insertion_point(field_mutable:ShaderProto.uniforms)
  return uniforms_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ShaderUniformProto >*
ShaderProto::mutable_uniforms() {
  // @@protoc_insertion_point(field_mutable_list:ShaderProto.uniforms)
  return &uniforms_;
}
inline const ::ShaderUniformProto& ShaderProto::_internal_uniforms(int index) const {
  return uniforms_.Get(index);
}
inline const ::ShaderUniformProto& ShaderProto::uniforms(int index) const {
  // @@protoc_insertion_point(field_get:ShaderProto.uniforms)
  return _internal_uniforms(index);
}
inline ::ShaderUniformProto* ShaderProto::_internal_add_uniforms() {
  return uniforms_.Add();
}
inline ::ShaderUniformProto* ShaderProto::add_uniforms() {
  ::ShaderUniformProto* _add = _internal_add_uniforms();
  // @@protoc_insertion_point(field_add:ShaderProto.uniforms)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ShaderUniformProto >&
ShaderProto::uniforms() const {
  // @@protoc_insertion_point(field_list:ShaderProto.uniforms)
  return uniforms_;
}

// repeated .ShaderVaryingProto varyings = 4;
inline int ShaderProto::_internal_varyings_size() const {
  return varyings_.size();
}
inline int ShaderProto::varyings_size() const {
  return _internal_varyings_size();
}
inline void ShaderProto::clear_varyings() {
  varyings_.Clear();
}
inline ::ShaderVaryingProto* ShaderProto::mutable_varyings(int index) {
  // @@protoc_insertion_point(field_mutable:ShaderProto.varyings)
  return varyings_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ShaderVaryingProto >*
ShaderProto::mutable_varyings() {
  // @@protoc_insertion_point(field_mutable_list:ShaderProto.varyings)
  return &varyings_;
}
inline const ::ShaderVaryingProto& ShaderProto::_internal_varyings(int index) const {
  return varyings_.Get(index);
}
inline const ::ShaderVaryingProto& ShaderProto::varyings(int index) const {
  // @@protoc_insertion_point(field_get:ShaderProto.varyings)
  return _internal_varyings(index);
}
inline ::ShaderVaryingProto* ShaderProto::_internal_add_varyings() {
  return varyings_.Add();
}
inline ::ShaderVaryingProto* ShaderProto::add_varyings() {
  ::ShaderVaryingProto* _add = _internal_add_varyings();
  // @@protoc_insertion_point(field_add:ShaderProto.varyings)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ShaderVaryingProto >&
ShaderProto::varyings() const {
  // @@protoc_insertion_point(field_list:ShaderProto.varyings)
  return varyings_;
}

// repeated .ShaderOutputVariableProto output_variables = 5;
inline int ShaderProto::_internal_output_variables_size() const {
  return output_variables_.size();
}
inline int ShaderProto::output_variables_size() const {
  return _internal_output_variables_size();
}
inline void ShaderProto::clear_output_variables() {
  output_variables_.Clear();
}
inline ::ShaderOutputVariableProto* ShaderProto::mutable_output_variables(int index) {
  // @@protoc_insertion_point(field_mutable:ShaderProto.output_variables)
  return output_variables_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ShaderOutputVariableProto >*
ShaderProto::mutable_output_variables() {
  // @@protoc_insertion_point(field_mutable_list:ShaderProto.output_variables)
  return &output_variables_;
}
inline const ::ShaderOutputVariableProto& ShaderProto::_internal_output_variables(int index) const {
  return output_variables_.Get(index);
}
inline const ::ShaderOutputVariableProto& ShaderProto::output_variables(int index) const {
  // @@protoc_insertion_point(field_get:ShaderProto.output_variables)
  return _internal_output_variables(index);
}
inline ::ShaderOutputVariableProto* ShaderProto::_internal_add_output_variables() {
  return output_variables_.Add();
}
inline ::ShaderOutputVariableProto* ShaderProto::add_output_variables() {
  ::ShaderOutputVariableProto* _add = _internal_add_output_variables();
  // @@protoc_insertion_point(field_add:ShaderProto.output_variables)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ShaderOutputVariableProto >&
ShaderProto::output_variables() const {
  // @@protoc_insertion_point(field_list:ShaderProto.output_variables)
  return output_variables_;
}

// repeated .ShaderInterfaceBlockProto interface_blocks = 6;
inline int ShaderProto::_internal_interface_blocks_size() const {
  return interface_blocks_.size();
}
inline int ShaderProto::interface_blocks_size() const {
  return _internal_interface_blocks_size();
}
inline void ShaderProto::clear_interface_blocks() {
  interface_blocks_.Clear();
}
inline ::ShaderInterfaceBlockProto* ShaderProto::mutable_interface_blocks(int index) {
  // @@protoc_insertion_point(field_mutable:ShaderProto.interface_blocks)
  return interface_blocks_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ShaderInterfaceBlockProto >*
ShaderProto::mutable_interface_blocks() {
  // @@protoc_insertion_point(field_mutable_list:ShaderProto.interface_blocks)
  return &interface_blocks_;
}
inline const ::ShaderInterfaceBlockProto& ShaderProto::_internal_interface_blocks(int index) const {
  return interface_blocks_.Get(index);
}
inline const ::ShaderInterfaceBlockProto& ShaderProto::interface_blocks(int index) const {
  // @@protoc_insertion_point(field_get:ShaderProto.interface_blocks)
  return _internal_interface_blocks(index);
}
inline ::ShaderInterfaceBlockProto* ShaderProto::_internal_add_interface_blocks() {
  return interface_blocks_.Add();
}
inline ::ShaderInterfaceBlockProto* ShaderProto::add_interface_blocks() {
  ::ShaderInterfaceBlockProto* _add = _internal_add_interface_blocks();
  // @@protoc_insertion_point(field_add:ShaderProto.interface_blocks)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ShaderInterfaceBlockProto >&
ShaderProto::interface_blocks() const {
  // @@protoc_insertion_point(field_list:ShaderProto.interface_blocks)
  return interface_blocks_;
}

// -------------------------------------------------------------------

// GpuProgramProto

// optional bytes sha = 1;
inline bool GpuProgramProto::_internal_has_sha() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GpuProgramProto::has_sha() const {
  return _internal_has_sha();
}
inline void GpuProgramProto::clear_sha() {
  sha_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& GpuProgramProto::sha() const {
  // @@protoc_insertion_point(field_get:GpuProgramProto.sha)
  return _internal_sha();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GpuProgramProto::set_sha(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 sha_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:GpuProgramProto.sha)
}
inline std::string* GpuProgramProto::mutable_sha() {
  std::string* _s = _internal_mutable_sha();
  // @@protoc_insertion_point(field_mutable:GpuProgramProto.sha)
  return _s;
}
inline const std::string& GpuProgramProto::_internal_sha() const {
  return sha_.Get();
}
inline void GpuProgramProto::_internal_set_sha(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  sha_.Set(value, GetArenaForAllocation());
}
inline std::string* GpuProgramProto::_internal_mutable_sha() {
  _has_bits_[0] |= 0x00000001u;
  return sha_.Mutable(GetArenaForAllocation());
}
inline std::string* GpuProgramProto::release_sha() {
  // @@protoc_insertion_point(field_release:GpuProgramProto.sha)
  if (!_internal_has_sha()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = sha_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (sha_.IsDefault()) {
    sha_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void GpuProgramProto::set_allocated_sha(std::string* sha) {
  if (sha != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  sha_.SetAllocated(sha, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (sha_.IsDefault()) {
    sha_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GpuProgramProto.sha)
}

// optional uint32 format = 2;
inline bool GpuProgramProto::_internal_has_format() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool GpuProgramProto::has_format() const {
  return _internal_has_format();
}
inline void GpuProgramProto::clear_format() {
  format_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline uint32_t GpuProgramProto::_internal_format() const {
  return format_;
}
inline uint32_t GpuProgramProto::format() const {
  // @@protoc_insertion_point(field_get:GpuProgramProto.format)
  return _internal_format();
}
inline void GpuProgramProto::_internal_set_format(uint32_t value) {
  _has_bits_[0] |= 0x00000010u;
  format_ = value;
}
inline void GpuProgramProto::set_format(uint32_t value) {
  _internal_set_format(value);
  // @@protoc_insertion_point(field_set:GpuProgramProto.format)
}

// optional bytes program = 3;
inline bool GpuProgramProto::_internal_has_program() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool GpuProgramProto::has_program() const {
  return _internal_has_program();
}
inline void GpuProgramProto::clear_program() {
  program_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& GpuProgramProto::program() const {
  // @@protoc_insertion_point(field_get:GpuProgramProto.program)
  return _internal_program();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GpuProgramProto::set_program(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 program_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:GpuProgramProto.program)
}
inline std::string* GpuProgramProto::mutable_program() {
  std::string* _s = _internal_mutable_program();
  // @@protoc_insertion_point(field_mutable:GpuProgramProto.program)
  return _s;
}
inline const std::string& GpuProgramProto::_internal_program() const {
  return program_.Get();
}
inline void GpuProgramProto::_internal_set_program(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  program_.Set(value, GetArenaForAllocation());
}
inline std::string* GpuProgramProto::_internal_mutable_program() {
  _has_bits_[0] |= 0x00000002u;
  return program_.Mutable(GetArenaForAllocation());
}
inline std::string* GpuProgramProto::release_program() {
  // @@protoc_insertion_point(field_release:GpuProgramProto.program)
  if (!_internal_has_program()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = program_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (program_.IsDefault()) {
    program_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void GpuProgramProto::set_allocated_program(std::string* program) {
  if (program != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  program_.SetAllocated(program, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (program_.IsDefault()) {
    program_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GpuProgramProto.program)
}

// optional bool program_is_compressed = 6;
inline bool GpuProgramProto::_internal_has_program_is_compressed() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool GpuProgramProto::has_program_is_compressed() const {
  return _internal_has_program_is_compressed();
}
inline void GpuProgramProto::clear_program_is_compressed() {
  program_is_compressed_ = false;
  _has_bits_[0] &= ~0x00000020u;
}
inline bool GpuProgramProto::_internal_program_is_compressed() const {
  return program_is_compressed_;
}
inline bool GpuProgramProto::program_is_compressed() const {
  // @@protoc_insertion_point(field_get:GpuProgramProto.program_is_compressed)
  return _internal_program_is_compressed();
}
inline void GpuProgramProto::_internal_set_program_is_compressed(bool value) {
  _has_bits_[0] |= 0x00000020u;
  program_is_compressed_ = value;
}
inline void GpuProgramProto::set_program_is_compressed(bool value) {
  _internal_set_program_is_compressed(value);
  // @@protoc_insertion_point(field_set:GpuProgramProto.program_is_compressed)
}

// optional uint32 program_decompressed_length = 7;
inline bool GpuProgramProto::_internal_has_program_decompressed_length() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool GpuProgramProto::has_program_decompressed_length() const {
  return _internal_has_program_decompressed_length();
}
inline void GpuProgramProto::clear_program_decompressed_length() {
  program_decompressed_length_ = 0u;
  _has_bits_[0] &= ~0x00000040u;
}
inline uint32_t GpuProgramProto::_internal_program_decompressed_length() const {
  return program_decompressed_length_;
}
inline uint32_t GpuProgramProto::program_decompressed_length() const {
  // @@protoc_insertion_point(field_get:GpuProgramProto.program_decompressed_length)
  return _internal_program_decompressed_length();
}
inline void GpuProgramProto::_internal_set_program_decompressed_length(uint32_t value) {
  _has_bits_[0] |= 0x00000040u;
  program_decompressed_length_ = value;
}
inline void GpuProgramProto::set_program_decompressed_length(uint32_t value) {
  _internal_set_program_decompressed_length(value);
  // @@protoc_insertion_point(field_set:GpuProgramProto.program_decompressed_length)
}

// optional .ShaderProto vertex_shader = 4;
inline bool GpuProgramProto::_internal_has_vertex_shader() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || vertex_shader_ != nullptr);
  return value;
}
inline bool GpuProgramProto::has_vertex_shader() const {
  return _internal_has_vertex_shader();
}
inline void GpuProgramProto::clear_vertex_shader() {
  if (vertex_shader_ != nullptr) vertex_shader_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::ShaderProto& GpuProgramProto::_internal_vertex_shader() const {
  const ::ShaderProto* p = vertex_shader_;
  return p != nullptr ? *p : reinterpret_cast<const ::ShaderProto&>(
      ::_ShaderProto_default_instance_);
}
inline const ::ShaderProto& GpuProgramProto::vertex_shader() const {
  // @@protoc_insertion_point(field_get:GpuProgramProto.vertex_shader)
  return _internal_vertex_shader();
}
inline void GpuProgramProto::unsafe_arena_set_allocated_vertex_shader(
    ::ShaderProto* vertex_shader) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(vertex_shader_);
  }
  vertex_shader_ = vertex_shader;
  if (vertex_shader) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GpuProgramProto.vertex_shader)
}
inline ::ShaderProto* GpuProgramProto::release_vertex_shader() {
  _has_bits_[0] &= ~0x00000004u;
  ::ShaderProto* temp = vertex_shader_;
  vertex_shader_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ShaderProto* GpuProgramProto::unsafe_arena_release_vertex_shader() {
  // @@protoc_insertion_point(field_release:GpuProgramProto.vertex_shader)
  _has_bits_[0] &= ~0x00000004u;
  ::ShaderProto* temp = vertex_shader_;
  vertex_shader_ = nullptr;
  return temp;
}
inline ::ShaderProto* GpuProgramProto::_internal_mutable_vertex_shader() {
  _has_bits_[0] |= 0x00000004u;
  if (vertex_shader_ == nullptr) {
    auto* p = CreateMaybeMessage<::ShaderProto>(GetArenaForAllocation());
    vertex_shader_ = p;
  }
  return vertex_shader_;
}
inline ::ShaderProto* GpuProgramProto::mutable_vertex_shader() {
  ::ShaderProto* _msg = _internal_mutable_vertex_shader();
  // @@protoc_insertion_point(field_mutable:GpuProgramProto.vertex_shader)
  return _msg;
}
inline void GpuProgramProto::set_allocated_vertex_shader(::ShaderProto* vertex_shader) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete vertex_shader_;
  }
  if (vertex_shader) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(vertex_shader);
    if (message_arena != submessage_arena) {
      vertex_shader = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, vertex_shader, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  vertex_shader_ = vertex_shader;
  // @@protoc_insertion_point(field_set_allocated:GpuProgramProto.vertex_shader)
}

// optional .ShaderProto fragment_shader = 5;
inline bool GpuProgramProto::_internal_has_fragment_shader() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || fragment_shader_ != nullptr);
  return value;
}
inline bool GpuProgramProto::has_fragment_shader() const {
  return _internal_has_fragment_shader();
}
inline void GpuProgramProto::clear_fragment_shader() {
  if (fragment_shader_ != nullptr) fragment_shader_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::ShaderProto& GpuProgramProto::_internal_fragment_shader() const {
  const ::ShaderProto* p = fragment_shader_;
  return p != nullptr ? *p : reinterpret_cast<const ::ShaderProto&>(
      ::_ShaderProto_default_instance_);
}
inline const ::ShaderProto& GpuProgramProto::fragment_shader() const {
  // @@protoc_insertion_point(field_get:GpuProgramProto.fragment_shader)
  return _internal_fragment_shader();
}
inline void GpuProgramProto::unsafe_arena_set_allocated_fragment_shader(
    ::ShaderProto* fragment_shader) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(fragment_shader_);
  }
  fragment_shader_ = fragment_shader;
  if (fragment_shader) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GpuProgramProto.fragment_shader)
}
inline ::ShaderProto* GpuProgramProto::release_fragment_shader() {
  _has_bits_[0] &= ~0x00000008u;
  ::ShaderProto* temp = fragment_shader_;
  fragment_shader_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ShaderProto* GpuProgramProto::unsafe_arena_release_fragment_shader() {
  // @@protoc_insertion_point(field_release:GpuProgramProto.fragment_shader)
  _has_bits_[0] &= ~0x00000008u;
  ::ShaderProto* temp = fragment_shader_;
  fragment_shader_ = nullptr;
  return temp;
}
inline ::ShaderProto* GpuProgramProto::_internal_mutable_fragment_shader() {
  _has_bits_[0] |= 0x00000008u;
  if (fragment_shader_ == nullptr) {
    auto* p = CreateMaybeMessage<::ShaderProto>(GetArenaForAllocation());
    fragment_shader_ = p;
  }
  return fragment_shader_;
}
inline ::ShaderProto* GpuProgramProto::mutable_fragment_shader() {
  ::ShaderProto* _msg = _internal_mutable_fragment_shader();
  // @@protoc_insertion_point(field_mutable:GpuProgramProto.fragment_shader)
  return _msg;
}
inline void GpuProgramProto::set_allocated_fragment_shader(::ShaderProto* fragment_shader) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete fragment_shader_;
  }
  if (fragment_shader) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(fragment_shader);
    if (message_arena != submessage_arena) {
      fragment_shader = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, fragment_shader, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  fragment_shader_ = fragment_shader;
  // @@protoc_insertion_point(field_set_allocated:GpuProgramProto.fragment_shader)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_disk_5fcache_5fproto_2eproto
