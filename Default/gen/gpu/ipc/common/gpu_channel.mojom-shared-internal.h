// gpu/ipc/common/gpu_channel.mojom-shared-internal.h is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2016 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef GPU_IPC_COMMON_GPU_CHANNEL_MOJOM_SHARED_INTERNAL_H_
#define GPU_IPC_COMMON_GPU_CHANNEL_MOJOM_SHARED_INTERNAL_H_
#include "mojo/public/cpp/bindings/lib/array_internal.h"
#include "mojo/public/cpp/bindings/lib/bindings_internal.h"
#include "mojo/public/cpp/bindings/lib/map_data_internal.h"
#include "mojo/public/cpp/bindings/lib/buffer.h"
#include "gpu/ipc/common/capabilities.mojom-shared-internal.h"
#include "gpu/ipc/common/context_result.mojom-shared-internal.h"
#include "gpu/ipc/common/mailbox.mojom-shared-internal.h"
#include "gpu/ipc/common/surface_handle.mojom-shared-internal.h"
#include "gpu/ipc/common/sync_token.mojom-shared-internal.h"
#include "gpu/ipc/common/vulkan_ycbcr_info.mojom-shared-internal.h"
#include "mojo/public/mojom/base/shared_memory.mojom-shared-internal.h"
#include "mojo/public/mojom/base/unguessable_token.mojom-shared-internal.h"
#include "mojo/public/mojom/base/generic_pending_associated_receiver.mojom-shared-internal.h"
#include "services/viz/public/mojom/compositing/resource_format.mojom-shared-internal.h"
#include "skia/public/mojom/image_info.mojom-shared-internal.h"
#include "skia/public/mojom/surface_origin.mojom-shared-internal.h"
#include "ui/gfx/geometry/mojom/geometry.mojom-shared-internal.h"
#include "ui/gfx/mojom/buffer_types.mojom-shared-internal.h"
#include "ui/gfx/mojom/color_space.mojom-shared-internal.h"
#include "ui/gfx/mojom/gpu_fence_handle.mojom-shared-internal.h"
#include "ui/gfx/mojom/presentation_feedback.mojom-shared-internal.h"
#include "ui/gl/mojom/gpu_preference.mojom-shared-internal.h"
#include "url/mojom/url.mojom-shared-internal.h"
#include "mojo/public/cpp/bindings/lib/native_enum_data.h"
#include "mojo/public/interfaces/bindings/native_struct.mojom-shared-internal.h"
#include "base/component_export.h"



namespace mojo {
namespace internal {
class ValidationContext;
}
}
namespace gpu {
namespace mojom {
namespace internal {
class ContextCreationAttribs_Data;
class CreateCommandBufferParams_Data;
class CommandBufferState_Data;
class ScheduleImageDecodeParams_Data;
using SwapBuffersCompleteParams_Data = mojo::native::internal::NativeStruct_Data;
class DeferredRequest_Data;
class DeferredCommandBufferRequest_Data;
class AsyncFlushParams_Data;
class ReturnFrontBufferParams_Data;
class CreateSharedImageParams_Data;
class CreateSharedImageWithDataParams_Data;
class CreateGMBSharedImageParams_Data;
class UpdateSharedImageParams_Data;
class DeferredRequestParams_Data;
class DeferredCommandBufferRequestParams_Data;
class DeferredSharedImageRequest_Data;

struct ContextType_Data {
 public:
  static bool constexpr kIsExtensible = false;

  static bool IsKnownValue(int32_t value) {
    switch (value) {
      case 0:
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
        return true;
    }
    return false;
  }

  static bool Validate(int32_t value,
                       mojo::internal::ValidationContext* validation_context) {
    if (kIsExtensible || IsKnownValue(value))
      return true;

    ReportValidationError(validation_context,
                          mojo::internal::VALIDATION_ERROR_UNKNOWN_ENUM_VALUE);
    return false;
  }
};

struct ContextColorSpace_Data {
 public:
  static bool constexpr kIsExtensible = false;

  static bool IsKnownValue(int32_t value) {
    switch (value) {
      case 0:
      case 1:
      case 2:
        return true;
    }
    return false;
  }

  static bool Validate(int32_t value,
                       mojo::internal::ValidationContext* validation_context) {
    if (kIsExtensible || IsKnownValue(value))
      return true;

    ReportValidationError(validation_context,
                          mojo::internal::VALIDATION_ERROR_UNKNOWN_ENUM_VALUE);
    return false;
  }
};

struct SchedulingPriority_Data {
 public:
  static bool constexpr kIsExtensible = false;

  static bool IsKnownValue(int32_t value) {
    switch (value) {
      case 0:
      case 1:
      case 2:
        return true;
    }
    return false;
  }

  static bool Validate(int32_t value,
                       mojo::internal::ValidationContext* validation_context) {
    if (kIsExtensible || IsKnownValue(value))
      return true;

    ReportValidationError(validation_context,
                          mojo::internal::VALIDATION_ERROR_UNKNOWN_ENUM_VALUE);
    return false;
  }
};
using Error_Data =
    mojo::internal::NativeEnum_Data;
using ContextLostReason_Data =
    mojo::internal::NativeEnum_Data;

#pragma pack(push, 1)


class COMPONENT_EXPORT(MOJOM_SHARED_GPU_EXPORT) DeferredRequestParams_Data {
 public:
  // Used to identify Mojom Union Data Classes.
  typedef void MojomUnionDataType;

  DeferredRequestParams_Data() = default;
  // Do nothing in the destructor since it won't be called when it is a
  // non-inlined union.
  ~DeferredRequestParams_Data() = default;

  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context,
                       bool inlined);

  bool is_null() const { return size == 0; }

  void set_null() {
    size = 0U;
    tag = static_cast<DeferredRequestParams_Tag>(0);
    data.unknown = 0U;
  }

  // TODO(crbug.com/1148486): SHOUTY_CASE values are being deprecated per C++ code style
  // guidelines (https://google.github.io/styleguide/cppguide.html#Enumerator_Names),
  // please use kCamelCase values instead.  Cleanup NULL_VALUE, BOOL_VALUE, INT_VALUE, etc.
  // generation once codebase is transitioned to kNullValue, kBoolValue, kIntValue, etc.
  enum class DeferredRequestParams_Tag : uint32_t {

    
    kCommandBufferRequest,
    
    kSharedImageRequest,
    
    kDestroyStreamTexture,
  };

  // A note on layout:
  // "Each non-static data member is allocated as if it were the sole member of
  // a struct." - Section 9.5.2 ISO/IEC 14882:2011 (The C++ Spec)
  union MOJO_ALIGNAS(8) Union_ {
    Union_() : unknown(0) {}
    mojo::internal::Pointer<internal::DeferredCommandBufferRequest_Data> f_command_buffer_request;
    mojo::internal::Pointer<internal::DeferredSharedImageRequest_Data> f_shared_image_request;
    int32_t f_destroy_stream_texture;
    uint64_t unknown;
  };

  uint32_t size;
  DeferredRequestParams_Tag tag;
  Union_ data;
};
static_assert(sizeof(DeferredRequestParams_Data) == mojo::internal::kUnionDataSize,
              "Bad sizeof(DeferredRequestParams_Data)");


class COMPONENT_EXPORT(MOJOM_SHARED_GPU_EXPORT) DeferredCommandBufferRequestParams_Data {
 public:
  // Used to identify Mojom Union Data Classes.
  typedef void MojomUnionDataType;

  DeferredCommandBufferRequestParams_Data() = default;
  // Do nothing in the destructor since it won't be called when it is a
  // non-inlined union.
  ~DeferredCommandBufferRequestParams_Data() = default;

  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context,
                       bool inlined);

  bool is_null() const { return size == 0; }

  void set_null() {
    size = 0U;
    tag = static_cast<DeferredCommandBufferRequestParams_Tag>(0);
    data.unknown = 0U;
  }

  // TODO(crbug.com/1148486): SHOUTY_CASE values are being deprecated per C++ code style
  // guidelines (https://google.github.io/styleguide/cppguide.html#Enumerator_Names),
  // please use kCamelCase values instead.  Cleanup NULL_VALUE, BOOL_VALUE, INT_VALUE, etc.
  // generation once codebase is transitioned to kNullValue, kBoolValue, kIntValue, etc.
  enum class DeferredCommandBufferRequestParams_Tag : uint32_t {

    
    kAsyncFlush,
    
    kDestroyTransferBuffer,
    
    kTakeFrontBuffer,
    
    kReturnFrontBuffer,
  };

  // A note on layout:
  // "Each non-static data member is allocated as if it were the sole member of
  // a struct." - Section 9.5.2 ISO/IEC 14882:2011 (The C++ Spec)
  union MOJO_ALIGNAS(8) Union_ {
    Union_() : unknown(0) {}
    mojo::internal::Pointer<internal::AsyncFlushParams_Data> f_async_flush;
    int32_t f_destroy_transfer_buffer;
    mojo::internal::Pointer<::gpu::mojom::internal::Mailbox_Data> f_take_front_buffer;
    mojo::internal::Pointer<internal::ReturnFrontBufferParams_Data> f_return_front_buffer;
    uint64_t unknown;
  };

  uint32_t size;
  DeferredCommandBufferRequestParams_Tag tag;
  Union_ data;
};
static_assert(sizeof(DeferredCommandBufferRequestParams_Data) == mojo::internal::kUnionDataSize,
              "Bad sizeof(DeferredCommandBufferRequestParams_Data)");


class COMPONENT_EXPORT(MOJOM_SHARED_GPU_EXPORT) DeferredSharedImageRequest_Data {
 public:
  // Used to identify Mojom Union Data Classes.
  typedef void MojomUnionDataType;

  DeferredSharedImageRequest_Data() = default;
  // Do nothing in the destructor since it won't be called when it is a
  // non-inlined union.
  ~DeferredSharedImageRequest_Data() = default;

  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context,
                       bool inlined);

  bool is_null() const { return size == 0; }

  void set_null() {
    size = 0U;
    tag = static_cast<DeferredSharedImageRequest_Tag>(0);
    data.unknown = 0U;
  }

  // TODO(crbug.com/1148486): SHOUTY_CASE values are being deprecated per C++ code style
  // guidelines (https://google.github.io/styleguide/cppguide.html#Enumerator_Names),
  // please use kCamelCase values instead.  Cleanup NULL_VALUE, BOOL_VALUE, INT_VALUE, etc.
  // generation once codebase is transitioned to kNullValue, kBoolValue, kIntValue, etc.
  enum class DeferredSharedImageRequest_Tag : uint32_t {

    
    kNop,
    
    kCreateSharedImage,
    
    kCreateSharedImageWithData,
    
    kCreateGmbSharedImage,
    
    kRegisterUploadBuffer,
    
    kUpdateSharedImage,
    
    kDestroySharedImage,
  };

  // A note on layout:
  // "Each non-static data member is allocated as if it were the sole member of
  // a struct." - Section 9.5.2 ISO/IEC 14882:2011 (The C++ Spec)
  union MOJO_ALIGNAS(8) Union_ {
    Union_() : unknown(0) {}
    uint8_t f_nop;
    mojo::internal::Pointer<internal::CreateSharedImageParams_Data> f_create_shared_image;
    mojo::internal::Pointer<internal::CreateSharedImageWithDataParams_Data> f_create_shared_image_with_data;
    mojo::internal::Pointer<internal::CreateGMBSharedImageParams_Data> f_create_gmb_shared_image;
    mojo::internal::Pointer<::mojo_base::mojom::internal::ReadOnlySharedMemoryRegion_Data> f_register_upload_buffer;
    mojo::internal::Pointer<internal::UpdateSharedImageParams_Data> f_update_shared_image;
    mojo::internal::Pointer<::gpu::mojom::internal::Mailbox_Data> f_destroy_shared_image;
    uint64_t unknown;
  };

  uint32_t size;
  DeferredSharedImageRequest_Tag tag;
  Union_ data;
};
static_assert(sizeof(DeferredSharedImageRequest_Data) == mojo::internal::kUnionDataSize,
              "Bad sizeof(DeferredSharedImageRequest_Data)");
class COMPONENT_EXPORT(MOJOM_SHARED_GPU_EXPORT) ContextCreationAttribs_Data {
 public:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);

  mojo::internal::StructHeader header_;
  mojo::internal::Pointer<::gfx::mojom::internal::Size_Data> offscreen_framebuffer_size;
  int32_t gpu_preference;
  int32_t alpha_size;
  int32_t blue_size;
  int32_t green_size;
  int32_t red_size;
  int32_t depth_size;
  int32_t stencil_size;
  int32_t samples;
  int32_t sample_buffers;
  uint8_t buffer_preserved : 1;
  uint8_t bind_generates_resource : 1;
  uint8_t fail_if_major_perf_caveat : 1;
  uint8_t lose_context_when_out_of_memory : 1;
  uint8_t should_use_native_gmb_for_backbuffer : 1;
  uint8_t own_offscreen_surface : 1;
  uint8_t single_buffer : 1;
  uint8_t enable_gles2_interface : 1;
  uint8_t enable_grcontext : 1;
  uint8_t enable_raster_interface : 1;
  uint8_t enable_oop_rasterization : 1;
  uint8_t enable_swap_timestamps_if_supported : 1;
  uint8_t pad21_[2];
  int32_t context_type;
  int32_t color_space;

 private:
  friend class mojo::internal::MessageFragment<ContextCreationAttribs_Data>;

  ContextCreationAttribs_Data();
  ~ContextCreationAttribs_Data() = delete;
};
static_assert(sizeof(ContextCreationAttribs_Data) == 64,
              "Bad sizeof(ContextCreationAttribs_Data)");
// Used by ContextCreationAttribs::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView>
struct ContextCreationAttribs_UnserializedMessageContext
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  ContextCreationAttribs_UnserializedMessageContext(
    uint32_t message_name,
    uint32_t message_flags,
    UserType input)
      : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
      , user_data_(std::move(input)) {}
  ~ContextCreationAttribs_UnserializedMessageContext() override = default;

  UserType TakeData() {
    return std::move(user_data_);
  }

 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::Message& message) override {
    mojo::internal::MessageFragment<ContextCreationAttribs_Data> fragment(message);
    mojo::internal::Serialize<DataView>(user_data_, fragment);
  }

  UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag
    ContextCreationAttribs_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class COMPONENT_EXPORT(MOJOM_SHARED_GPU_EXPORT) CreateCommandBufferParams_Data {
 public:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);

  mojo::internal::StructHeader header_;
  mojo::internal::Pointer<::gpu::mojom::internal::SurfaceHandle_Data> surface_handle;
  int32_t share_group_id;
  int32_t stream_id;
  int32_t stream_priority;
  uint8_t pad3_[4];
  mojo::internal::Pointer<internal::ContextCreationAttribs_Data> attribs;
  mojo::internal::Pointer<::url::mojom::internal::Url_Data> active_url;

 private:
  friend class mojo::internal::MessageFragment<CreateCommandBufferParams_Data>;

  CreateCommandBufferParams_Data();
  ~CreateCommandBufferParams_Data() = delete;
};
static_assert(sizeof(CreateCommandBufferParams_Data) == 48,
              "Bad sizeof(CreateCommandBufferParams_Data)");
// Used by CreateCommandBufferParams::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView>
struct CreateCommandBufferParams_UnserializedMessageContext
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  CreateCommandBufferParams_UnserializedMessageContext(
    uint32_t message_name,
    uint32_t message_flags,
    UserType input)
      : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
      , user_data_(std::move(input)) {}
  ~CreateCommandBufferParams_UnserializedMessageContext() override = default;

  UserType TakeData() {
    return std::move(user_data_);
  }

 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::Message& message) override {
    mojo::internal::MessageFragment<CreateCommandBufferParams_Data> fragment(message);
    mojo::internal::Serialize<DataView>(user_data_, fragment);
  }

  UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag
    CreateCommandBufferParams_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class COMPONENT_EXPORT(MOJOM_SHARED_GPU_EXPORT) CommandBufferState_Data {
 public:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);

  mojo::internal::StructHeader header_;
  int32_t get_offset;
  int32_t token;
  uint64_t release_count;
  int32_t error;
  int32_t context_lost_reason;
  uint32_t generation;
  uint32_t set_get_buffer_count;

 private:
  friend class mojo::internal::MessageFragment<CommandBufferState_Data>;

  CommandBufferState_Data();
  ~CommandBufferState_Data() = delete;
};
static_assert(sizeof(CommandBufferState_Data) == 40,
              "Bad sizeof(CommandBufferState_Data)");
// Used by CommandBufferState::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView>
struct CommandBufferState_UnserializedMessageContext
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  CommandBufferState_UnserializedMessageContext(
    uint32_t message_name,
    uint32_t message_flags,
    UserType input)
      : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
      , user_data_(std::move(input)) {}
  ~CommandBufferState_UnserializedMessageContext() override = default;

  UserType TakeData() {
    return std::move(user_data_);
  }

 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::Message& message) override {
    mojo::internal::MessageFragment<CommandBufferState_Data> fragment(message);
    mojo::internal::Serialize<DataView>(user_data_, fragment);
  }

  UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag
    CommandBufferState_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class COMPONENT_EXPORT(MOJOM_SHARED_GPU_EXPORT) ScheduleImageDecodeParams_Data {
 public:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);

  mojo::internal::StructHeader header_;
  mojo::internal::Pointer<mojo::internal::Array_Data<uint8_t>> encoded_data;
  mojo::internal::Pointer<::gfx::mojom::internal::Size_Data> output_size;
  int32_t raster_decoder_route_id;
  uint32_t transfer_cache_entry_id;
  int32_t discardable_handle_shm_id;
  uint32_t discardable_handle_shm_offset;
  uint64_t discardable_handle_release_count;
  mojo::internal::Pointer<::gfx::mojom::internal::ColorSpace_Data> target_color_space;
  uint8_t needs_mips : 1;
  uint8_t padfinal_[7];

 private:
  friend class mojo::internal::MessageFragment<ScheduleImageDecodeParams_Data>;

  ScheduleImageDecodeParams_Data();
  ~ScheduleImageDecodeParams_Data() = delete;
};
static_assert(sizeof(ScheduleImageDecodeParams_Data) == 64,
              "Bad sizeof(ScheduleImageDecodeParams_Data)");
// Used by ScheduleImageDecodeParams::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView>
struct ScheduleImageDecodeParams_UnserializedMessageContext
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  ScheduleImageDecodeParams_UnserializedMessageContext(
    uint32_t message_name,
    uint32_t message_flags,
    UserType input)
      : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
      , user_data_(std::move(input)) {}
  ~ScheduleImageDecodeParams_UnserializedMessageContext() override = default;

  UserType TakeData() {
    return std::move(user_data_);
  }

 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::Message& message) override {
    mojo::internal::MessageFragment<ScheduleImageDecodeParams_Data> fragment(message);
    mojo::internal::Serialize<DataView>(user_data_, fragment);
  }

  UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag
    ScheduleImageDecodeParams_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class COMPONENT_EXPORT(MOJOM_SHARED_GPU_EXPORT) DeferredRequest_Data {
 public:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);

  mojo::internal::StructHeader header_;
  internal::DeferredRequestParams_Data params;
  mojo::internal::Pointer<mojo::internal::Array_Data<mojo::internal::Pointer<::gpu::mojom::internal::SyncToken_Data>>> sync_token_fences;

 private:
  friend class mojo::internal::MessageFragment<DeferredRequest_Data>;

  DeferredRequest_Data();
  ~DeferredRequest_Data() = delete;
};
static_assert(sizeof(DeferredRequest_Data) == 32,
              "Bad sizeof(DeferredRequest_Data)");
// Used by DeferredRequest::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView>
struct DeferredRequest_UnserializedMessageContext
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  DeferredRequest_UnserializedMessageContext(
    uint32_t message_name,
    uint32_t message_flags,
    UserType input)
      : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
      , user_data_(std::move(input)) {}
  ~DeferredRequest_UnserializedMessageContext() override = default;

  UserType TakeData() {
    return std::move(user_data_);
  }

 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::Message& message) override {
    mojo::internal::MessageFragment<DeferredRequest_Data> fragment(message);
    mojo::internal::Serialize<DataView>(user_data_, fragment);
  }

  UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag
    DeferredRequest_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class COMPONENT_EXPORT(MOJOM_SHARED_GPU_EXPORT) DeferredCommandBufferRequest_Data {
 public:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);

  mojo::internal::StructHeader header_;
  int32_t routing_id;
  uint8_t pad0_[4];
  internal::DeferredCommandBufferRequestParams_Data params;

 private:
  friend class mojo::internal::MessageFragment<DeferredCommandBufferRequest_Data>;

  DeferredCommandBufferRequest_Data();
  ~DeferredCommandBufferRequest_Data() = delete;
};
static_assert(sizeof(DeferredCommandBufferRequest_Data) == 32,
              "Bad sizeof(DeferredCommandBufferRequest_Data)");
// Used by DeferredCommandBufferRequest::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView>
struct DeferredCommandBufferRequest_UnserializedMessageContext
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  DeferredCommandBufferRequest_UnserializedMessageContext(
    uint32_t message_name,
    uint32_t message_flags,
    UserType input)
      : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
      , user_data_(std::move(input)) {}
  ~DeferredCommandBufferRequest_UnserializedMessageContext() override = default;

  UserType TakeData() {
    return std::move(user_data_);
  }

 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::Message& message) override {
    mojo::internal::MessageFragment<DeferredCommandBufferRequest_Data> fragment(message);
    mojo::internal::Serialize<DataView>(user_data_, fragment);
  }

  UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag
    DeferredCommandBufferRequest_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class COMPONENT_EXPORT(MOJOM_SHARED_GPU_EXPORT) AsyncFlushParams_Data {
 public:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);

  mojo::internal::StructHeader header_;
  int32_t put_offset;
  uint32_t flush_id;
  mojo::internal::Pointer<mojo::internal::Array_Data<mojo::internal::Pointer<::gpu::mojom::internal::SyncToken_Data>>> sync_token_fences;

 private:
  friend class mojo::internal::MessageFragment<AsyncFlushParams_Data>;

  AsyncFlushParams_Data();
  ~AsyncFlushParams_Data() = delete;
};
static_assert(sizeof(AsyncFlushParams_Data) == 24,
              "Bad sizeof(AsyncFlushParams_Data)");
// Used by AsyncFlushParams::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView>
struct AsyncFlushParams_UnserializedMessageContext
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  AsyncFlushParams_UnserializedMessageContext(
    uint32_t message_name,
    uint32_t message_flags,
    UserType input)
      : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
      , user_data_(std::move(input)) {}
  ~AsyncFlushParams_UnserializedMessageContext() override = default;

  UserType TakeData() {
    return std::move(user_data_);
  }

 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::Message& message) override {
    mojo::internal::MessageFragment<AsyncFlushParams_Data> fragment(message);
    mojo::internal::Serialize<DataView>(user_data_, fragment);
  }

  UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag
    AsyncFlushParams_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class COMPONENT_EXPORT(MOJOM_SHARED_GPU_EXPORT) ReturnFrontBufferParams_Data {
 public:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);

  mojo::internal::StructHeader header_;
  mojo::internal::Pointer<::gpu::mojom::internal::Mailbox_Data> mailbox;
  uint8_t is_lost : 1;
  uint8_t padfinal_[7];

 private:
  friend class mojo::internal::MessageFragment<ReturnFrontBufferParams_Data>;

  ReturnFrontBufferParams_Data();
  ~ReturnFrontBufferParams_Data() = delete;
};
static_assert(sizeof(ReturnFrontBufferParams_Data) == 24,
              "Bad sizeof(ReturnFrontBufferParams_Data)");
// Used by ReturnFrontBufferParams::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView>
struct ReturnFrontBufferParams_UnserializedMessageContext
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  ReturnFrontBufferParams_UnserializedMessageContext(
    uint32_t message_name,
    uint32_t message_flags,
    UserType input)
      : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
      , user_data_(std::move(input)) {}
  ~ReturnFrontBufferParams_UnserializedMessageContext() override = default;

  UserType TakeData() {
    return std::move(user_data_);
  }

 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::Message& message) override {
    mojo::internal::MessageFragment<ReturnFrontBufferParams_Data> fragment(message);
    mojo::internal::Serialize<DataView>(user_data_, fragment);
  }

  UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag
    ReturnFrontBufferParams_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class COMPONENT_EXPORT(MOJOM_SHARED_GPU_EXPORT) CreateSharedImageParams_Data {
 public:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);

  mojo::internal::StructHeader header_;
  mojo::internal::Pointer<::gpu::mojom::internal::Mailbox_Data> mailbox;
  int32_t format;
  uint32_t usage;
  mojo::internal::Pointer<::gfx::mojom::internal::Size_Data> size;
  mojo::internal::Pointer<::gfx::mojom::internal::ColorSpace_Data> color_space;
  uint32_t release_id;
  int32_t surface_origin;
  int32_t alpha_type;
  uint8_t padfinal_[4];

 private:
  friend class mojo::internal::MessageFragment<CreateSharedImageParams_Data>;

  CreateSharedImageParams_Data();
  ~CreateSharedImageParams_Data() = delete;
};
static_assert(sizeof(CreateSharedImageParams_Data) == 56,
              "Bad sizeof(CreateSharedImageParams_Data)");
// Used by CreateSharedImageParams::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView>
struct CreateSharedImageParams_UnserializedMessageContext
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  CreateSharedImageParams_UnserializedMessageContext(
    uint32_t message_name,
    uint32_t message_flags,
    UserType input)
      : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
      , user_data_(std::move(input)) {}
  ~CreateSharedImageParams_UnserializedMessageContext() override = default;

  UserType TakeData() {
    return std::move(user_data_);
  }

 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::Message& message) override {
    mojo::internal::MessageFragment<CreateSharedImageParams_Data> fragment(message);
    mojo::internal::Serialize<DataView>(user_data_, fragment);
  }

  UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag
    CreateSharedImageParams_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class COMPONENT_EXPORT(MOJOM_SHARED_GPU_EXPORT) CreateSharedImageWithDataParams_Data {
 public:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);

  mojo::internal::StructHeader header_;
  mojo::internal::Pointer<::gpu::mojom::internal::Mailbox_Data> mailbox;
  int32_t format;
  uint32_t usage;
  mojo::internal::Pointer<::gfx::mojom::internal::Size_Data> size;
  mojo::internal::Pointer<::gfx::mojom::internal::ColorSpace_Data> color_space;
  uint32_t release_id;
  uint32_t pixel_data_offset;
  uint32_t pixel_data_size;
  uint8_t done_with_shm : 1;
  uint8_t pad8_[3];
  int32_t surface_origin;
  int32_t alpha_type;

 private:
  friend class mojo::internal::MessageFragment<CreateSharedImageWithDataParams_Data>;

  CreateSharedImageWithDataParams_Data();
  ~CreateSharedImageWithDataParams_Data() = delete;
};
static_assert(sizeof(CreateSharedImageWithDataParams_Data) == 64,
              "Bad sizeof(CreateSharedImageWithDataParams_Data)");
// Used by CreateSharedImageWithDataParams::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView>
struct CreateSharedImageWithDataParams_UnserializedMessageContext
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  CreateSharedImageWithDataParams_UnserializedMessageContext(
    uint32_t message_name,
    uint32_t message_flags,
    UserType input)
      : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
      , user_data_(std::move(input)) {}
  ~CreateSharedImageWithDataParams_UnserializedMessageContext() override = default;

  UserType TakeData() {
    return std::move(user_data_);
  }

 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::Message& message) override {
    mojo::internal::MessageFragment<CreateSharedImageWithDataParams_Data> fragment(message);
    mojo::internal::Serialize<DataView>(user_data_, fragment);
  }

  UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag
    CreateSharedImageWithDataParams_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class COMPONENT_EXPORT(MOJOM_SHARED_GPU_EXPORT) CreateGMBSharedImageParams_Data {
 public:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);

  mojo::internal::StructHeader header_;
  mojo::internal::Pointer<::gpu::mojom::internal::Mailbox_Data> mailbox;
  mojo::internal::Pointer<::gfx::mojom::internal::GpuMemoryBufferHandle_Data> buffer_handle;
  mojo::internal::Pointer<::gfx::mojom::internal::Size_Data> size;
  int32_t format;
  int32_t plane;
  mojo::internal::Pointer<::gfx::mojom::internal::ColorSpace_Data> color_space;
  uint32_t usage;
  uint32_t release_id;
  int32_t surface_origin;
  int32_t alpha_type;

 private:
  friend class mojo::internal::MessageFragment<CreateGMBSharedImageParams_Data>;

  CreateGMBSharedImageParams_Data();
  ~CreateGMBSharedImageParams_Data() = delete;
};
static_assert(sizeof(CreateGMBSharedImageParams_Data) == 64,
              "Bad sizeof(CreateGMBSharedImageParams_Data)");
// Used by CreateGMBSharedImageParams::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView>
struct CreateGMBSharedImageParams_UnserializedMessageContext
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  CreateGMBSharedImageParams_UnserializedMessageContext(
    uint32_t message_name,
    uint32_t message_flags,
    UserType input)
      : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
      , user_data_(std::move(input)) {}
  ~CreateGMBSharedImageParams_UnserializedMessageContext() override = default;

  UserType TakeData() {
    return std::move(user_data_);
  }

 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::Message& message) override {
    mojo::internal::MessageFragment<CreateGMBSharedImageParams_Data> fragment(message);
    mojo::internal::Serialize<DataView>(user_data_, fragment);
  }

  UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag
    CreateGMBSharedImageParams_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class COMPONENT_EXPORT(MOJOM_SHARED_GPU_EXPORT) UpdateSharedImageParams_Data {
 public:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);

  mojo::internal::StructHeader header_;
  mojo::internal::Pointer<::gpu::mojom::internal::Mailbox_Data> mailbox;
  uint32_t release_id;
  uint8_t pad1_[4];
  mojo::internal::Pointer<::gfx::mojom::internal::GpuFenceHandle_Data> in_fence_handle;

 private:
  friend class mojo::internal::MessageFragment<UpdateSharedImageParams_Data>;

  UpdateSharedImageParams_Data();
  ~UpdateSharedImageParams_Data() = delete;
};
static_assert(sizeof(UpdateSharedImageParams_Data) == 32,
              "Bad sizeof(UpdateSharedImageParams_Data)");
// Used by UpdateSharedImageParams::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView>
struct UpdateSharedImageParams_UnserializedMessageContext
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  UpdateSharedImageParams_UnserializedMessageContext(
    uint32_t message_name,
    uint32_t message_flags,
    UserType input)
      : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
      , user_data_(std::move(input)) {}
  ~UpdateSharedImageParams_UnserializedMessageContext() override = default;

  UserType TakeData() {
    return std::move(user_data_);
  }

 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::Message& message) override {
    mojo::internal::MessageFragment<UpdateSharedImageParams_Data> fragment(message);
    mojo::internal::Serialize<DataView>(user_data_, fragment);
  }

  UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag
    UpdateSharedImageParams_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};

#pragma pack(pop)

}  // namespace internal
}  // namespace mojom
}  // namespace gpu

#endif  // GPU_IPC_COMMON_GPU_CHANNEL_MOJOM_SHARED_INTERNAL_H_