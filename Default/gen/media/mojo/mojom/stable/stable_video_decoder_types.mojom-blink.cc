// media/mojo/mojom/stable/stable_video_decoder_types.mojom-blink.cc is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2013 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#if defined(__clang__)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-private-field"
#endif

#include "media/mojo/mojom/stable/stable_video_decoder_types.mojom-blink.h"

#include <math.h>
#include <stdint.h>
#include <utility>

#include "base/debug/alias.h"
#include "base/hash/md5_constexpr.h"
#include "base/run_loop.h"
#include "base/strings/string_number_conversions.h"
#include "base/trace_event/trace_event.h"
#include "base/trace_event/typed_macros.h"
#include "mojo/public/cpp/bindings/lib/generated_code_util.h"
#include "mojo/public/cpp/bindings/lib/message_internal.h"
#include "mojo/public/cpp/bindings/lib/send_message_helper.h"
#include "mojo/public/cpp/bindings/lib/proxy_to_responder.h"
#include "mojo/public/cpp/bindings/lib/serialization_util.h"
#include "mojo/public/cpp/bindings/lib/unserialized_message_context.h"
#include "mojo/public/cpp/bindings/lib/validate_params.h"
#include "mojo/public/cpp/bindings/lib/validation_errors.h"
#include "mojo/public/cpp/bindings/mojo_buildflags.h"
#include "mojo/public/interfaces/bindings/interface_control_messages.mojom.h"
#include "third_party/perfetto/include/perfetto/tracing/traced_value.h"

#include "media/mojo/mojom/stable/stable_video_decoder_types.mojom-params-data.h"
#include "media/mojo/mojom/stable/stable_video_decoder_types.mojom-shared-message-ids.h"

#include "media/mojo/mojom/stable/stable_video_decoder_types.mojom-blink-import-headers.h"
#include "media/mojo/mojom/stable/stable_video_decoder_types.mojom-blink-test-utils.h"
#include "mojo/public/cpp/bindings/lib/wtf_serialization.h"


#ifndef MEDIA_MOJO_MOJOM_STABLE_STABLE_VIDEO_DECODER_TYPES_MOJOM_BLINK_JUMBO_H_
#define MEDIA_MOJO_MOJOM_STABLE_STABLE_VIDEO_DECODER_TYPES_MOJOM_BLINK_JUMBO_H_
#endif



namespace media {
namespace stable {
namespace mojom {
namespace blink {
SubsampleEntry::SubsampleEntry()
    : clear_bytes(),
      cypher_bytes() {}

SubsampleEntry::SubsampleEntry(
    uint32_t clear_bytes_in,
    uint32_t cypher_bytes_in)
    : clear_bytes(std::move(clear_bytes_in)),
      cypher_bytes(std::move(cypher_bytes_in)) {}

SubsampleEntry::~SubsampleEntry() = default;
size_t SubsampleEntry::Hash(size_t seed) const {
  seed = mojo::internal::WTFHash(seed, this->clear_bytes);
  seed = mojo::internal::WTFHash(seed, this->cypher_bytes);
  return seed;
}

void SubsampleEntry::WriteIntoTrace(
    perfetto::TracedValue traced_context) const {
  [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "clear_bytes"), this->clear_bytes,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type uint32_t>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "cypher_bytes"), this->cypher_bytes,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type uint32_t>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool SubsampleEntry::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
DecryptConfig::DecryptConfig()
    : encryption_scheme(),
      key_id(),
      iv(),
      subsamples(),
      encryption_pattern() {}

DecryptConfig::DecryptConfig(
    EncryptionScheme encryption_scheme_in,
    const WTF::String& key_id_in,
    const WTF::String& iv_in,
    WTF::Vector<SubsampleEntryPtr> subsamples_in,
    ::media::mojom::blink::EncryptionPatternPtr encryption_pattern_in)
    : encryption_scheme(std::move(encryption_scheme_in)),
      key_id(std::move(key_id_in)),
      iv(std::move(iv_in)),
      subsamples(std::move(subsamples_in)),
      encryption_pattern(std::move(encryption_pattern_in)) {}

DecryptConfig::~DecryptConfig() = default;

void DecryptConfig::WriteIntoTrace(
    perfetto::TracedValue traced_context) const {
  [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "encryption_scheme"), this->encryption_scheme,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type EncryptionScheme>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "key_id"), this->key_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const WTF::String&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "iv"), this->iv,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const WTF::String&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "subsamples"), this->subsamples,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type WTF::Vector<SubsampleEntryPtr>>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "encryption_pattern"), this->encryption_pattern,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type ::media::mojom::blink::EncryptionPatternPtr>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool DecryptConfig::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
ColorVolumeMetadata::ColorVolumeMetadata()
    : primary_r(),
      primary_g(),
      primary_b(),
      white_point(),
      luminance_max(),
      luminance_min() {}

ColorVolumeMetadata::ColorVolumeMetadata(
    const ::gfx::PointF& primary_r_in,
    const ::gfx::PointF& primary_g_in,
    const ::gfx::PointF& primary_b_in,
    const ::gfx::PointF& white_point_in,
    float luminance_max_in,
    float luminance_min_in)
    : primary_r(std::move(primary_r_in)),
      primary_g(std::move(primary_g_in)),
      primary_b(std::move(primary_b_in)),
      white_point(std::move(white_point_in)),
      luminance_max(std::move(luminance_max_in)),
      luminance_min(std::move(luminance_min_in)) {}

ColorVolumeMetadata::~ColorVolumeMetadata() = default;

void ColorVolumeMetadata::WriteIntoTrace(
    perfetto::TracedValue traced_context) const {
  [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "primary_r"), this->primary_r,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const ::gfx::PointF&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "primary_g"), this->primary_g,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const ::gfx::PointF&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "primary_b"), this->primary_b,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const ::gfx::PointF&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "white_point"), this->white_point,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const ::gfx::PointF&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "luminance_max"), this->luminance_max,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type float>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "luminance_min"), this->luminance_min,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type float>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool ColorVolumeMetadata::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
HDRMetadata::HDRMetadata()
    : color_volume_metadata(),
      max_content_light_level(),
      max_frame_average_light_level() {}

HDRMetadata::HDRMetadata(
    ColorVolumeMetadataPtr color_volume_metadata_in,
    uint32_t max_content_light_level_in,
    uint32_t max_frame_average_light_level_in)
    : color_volume_metadata(std::move(color_volume_metadata_in)),
      max_content_light_level(std::move(max_content_light_level_in)),
      max_frame_average_light_level(std::move(max_frame_average_light_level_in)) {}

HDRMetadata::~HDRMetadata() = default;

void HDRMetadata::WriteIntoTrace(
    perfetto::TracedValue traced_context) const {
  [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "color_volume_metadata"), this->color_volume_metadata,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type ColorVolumeMetadataPtr>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "max_content_light_level"), this->max_content_light_level,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type uint32_t>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "max_frame_average_light_level"), this->max_frame_average_light_level,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type uint32_t>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool HDRMetadata::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
VideoDecoderConfig::VideoDecoderConfig()
    : codec(),
      profile(),
      level(),
      has_alpha(),
      coded_size(),
      visible_rect(),
      natural_size(),
      extra_data(),
      encryption_scheme(),
      color_space_info(),
      hdr_metadata() {}

VideoDecoderConfig::VideoDecoderConfig(
    VideoCodec codec_in,
    VideoCodecProfile profile_in,
    uint32_t level_in,
    bool has_alpha_in,
    const ::gfx::Size& coded_size_in,
    const ::gfx::Rect& visible_rect_in,
    const ::gfx::Size& natural_size_in,
    WTF::Vector<uint8_t> extra_data_in,
    EncryptionScheme encryption_scheme_in,
    ColorSpacePtr color_space_info_in,
    HDRMetadataPtr hdr_metadata_in)
    : codec(std::move(codec_in)),
      profile(std::move(profile_in)),
      level(std::move(level_in)),
      has_alpha(std::move(has_alpha_in)),
      coded_size(std::move(coded_size_in)),
      visible_rect(std::move(visible_rect_in)),
      natural_size(std::move(natural_size_in)),
      extra_data(std::move(extra_data_in)),
      encryption_scheme(std::move(encryption_scheme_in)),
      color_space_info(std::move(color_space_info_in)),
      hdr_metadata(std::move(hdr_metadata_in)) {}

VideoDecoderConfig::~VideoDecoderConfig() = default;

void VideoDecoderConfig::WriteIntoTrace(
    perfetto::TracedValue traced_context) const {
  [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "codec"), this->codec,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type VideoCodec>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "profile"), this->profile,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type VideoCodecProfile>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "level"), this->level,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type uint32_t>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "has_alpha"), this->has_alpha,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type bool>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "coded_size"), this->coded_size,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const ::gfx::Size&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "visible_rect"), this->visible_rect,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const ::gfx::Rect&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "natural_size"), this->natural_size,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const ::gfx::Size&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "extra_data"), this->extra_data,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const WTF::Vector<uint8_t>&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "encryption_scheme"), this->encryption_scheme,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type EncryptionScheme>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "color_space_info"), this->color_space_info,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type ColorSpacePtr>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "hdr_metadata"), this->hdr_metadata,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type HDRMetadataPtr>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool VideoDecoderConfig::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
SupportedVideoDecoderConfig::SupportedVideoDecoderConfig()
    : profile_min(),
      profile_max(),
      coded_size_min(),
      coded_size_max(),
      allow_encrypted(),
      require_encrypted() {}

SupportedVideoDecoderConfig::SupportedVideoDecoderConfig(
    VideoCodecProfile profile_min_in,
    VideoCodecProfile profile_max_in,
    const ::gfx::Size& coded_size_min_in,
    const ::gfx::Size& coded_size_max_in,
    bool allow_encrypted_in,
    bool require_encrypted_in)
    : profile_min(std::move(profile_min_in)),
      profile_max(std::move(profile_max_in)),
      coded_size_min(std::move(coded_size_min_in)),
      coded_size_max(std::move(coded_size_max_in)),
      allow_encrypted(std::move(allow_encrypted_in)),
      require_encrypted(std::move(require_encrypted_in)) {}

SupportedVideoDecoderConfig::~SupportedVideoDecoderConfig() = default;

void SupportedVideoDecoderConfig::WriteIntoTrace(
    perfetto::TracedValue traced_context) const {
  [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "profile_min"), this->profile_min,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type VideoCodecProfile>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "profile_max"), this->profile_max,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type VideoCodecProfile>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "coded_size_min"), this->coded_size_min,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const ::gfx::Size&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "coded_size_max"), this->coded_size_max,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const ::gfx::Size&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "allow_encrypted"), this->allow_encrypted,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type bool>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "require_encrypted"), this->require_encrypted,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type bool>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool SupportedVideoDecoderConfig::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
StatusData::StatusData()
    : group(),
      code(),
      message(),
      frames(),
      cause(),
      data() {}

StatusData::StatusData(
    const WTF::String& group_in,
    StatusCode code_in,
    const WTF::String& message_in,
    WTF::Vector<::base::Value> frames_in,
    StatusDataPtr cause_in,
    ::base::Value data_in)
    : group(std::move(group_in)),
      code(std::move(code_in)),
      message(std::move(message_in)),
      frames(std::move(frames_in)),
      cause(std::move(cause_in)),
      data(std::move(data_in)) {}

StatusData::~StatusData() = default;

void StatusData::WriteIntoTrace(
    perfetto::TracedValue traced_context) const {
  [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "group"), this->group,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const WTF::String&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "code"), this->code,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type StatusCode>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "message"), this->message,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const WTF::String&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "frames"), this->frames,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type WTF::Vector<::base::Value>>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "cause"), this->cause,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type StatusDataPtr>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "data"), this->data,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type ::base::Value>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool StatusData::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
Status::Status()
    : internal() {}

Status::Status(
    StatusDataPtr internal_in)
    : internal(std::move(internal_in)) {}

Status::~Status() = default;

void Status::WriteIntoTrace(
    perfetto::TracedValue traced_context) const {
  [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "internal"), this->internal,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type StatusDataPtr>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool Status::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
DecoderBuffer::DecoderBuffer()
    : timestamp(),
      duration(),
      is_end_of_stream(),
      data_size(),
      is_key_frame(),
      side_data(),
      decrypt_config(),
      front_discard(),
      back_discard() {}

DecoderBuffer::DecoderBuffer(
    ::base::TimeDelta timestamp_in,
    ::base::TimeDelta duration_in,
    bool is_end_of_stream_in,
    uint32_t data_size_in,
    bool is_key_frame_in,
    WTF::Vector<uint8_t> side_data_in,
    DecryptConfigPtr decrypt_config_in,
    ::base::TimeDelta front_discard_in,
    ::base::TimeDelta back_discard_in)
    : timestamp(std::move(timestamp_in)),
      duration(std::move(duration_in)),
      is_end_of_stream(std::move(is_end_of_stream_in)),
      data_size(std::move(data_size_in)),
      is_key_frame(std::move(is_key_frame_in)),
      side_data(std::move(side_data_in)),
      decrypt_config(std::move(decrypt_config_in)),
      front_discard(std::move(front_discard_in)),
      back_discard(std::move(back_discard_in)) {}

DecoderBuffer::~DecoderBuffer() = default;

void DecoderBuffer::WriteIntoTrace(
    perfetto::TracedValue traced_context) const {
  [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "timestamp"), this->timestamp,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type ::base::TimeDelta>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "duration"), this->duration,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type ::base::TimeDelta>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "is_end_of_stream"), this->is_end_of_stream,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type bool>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "data_size"), this->data_size,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type uint32_t>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "is_key_frame"), this->is_key_frame,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type bool>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "side_data"), this->side_data,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const WTF::Vector<uint8_t>&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "decrypt_config"), this->decrypt_config,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type DecryptConfigPtr>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "front_discard"), this->front_discard,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type ::base::TimeDelta>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "back_discard"), this->back_discard,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type ::base::TimeDelta>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool DecoderBuffer::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
ColorSpace::ColorSpace()
    : primaries(),
      transfer(),
      matrix(),
      range(),
      custom_primary_matrix(),
      transfer_params() {}

ColorSpace::ColorSpace(
    ColorSpacePrimaryID primaries_in,
    ColorSpaceTransferID transfer_in,
    ColorSpaceMatrixID matrix_in,
    ColorSpaceRangeID range_in,
    WTF::Vector<float> custom_primary_matrix_in,
    WTF::Vector<float> transfer_params_in)
    : primaries(std::move(primaries_in)),
      transfer(std::move(transfer_in)),
      matrix(std::move(matrix_in)),
      range(std::move(range_in)),
      custom_primary_matrix(std::move(custom_primary_matrix_in)),
      transfer_params(std::move(transfer_params_in)) {}

ColorSpace::~ColorSpace() = default;

void ColorSpace::WriteIntoTrace(
    perfetto::TracedValue traced_context) const {
  [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "primaries"), this->primaries,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type ColorSpacePrimaryID>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "transfer"), this->transfer,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type ColorSpaceTransferID>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "matrix"), this->matrix,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type ColorSpaceMatrixID>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "range"), this->range,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type ColorSpaceRangeID>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "custom_primary_matrix"), this->custom_primary_matrix,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const WTF::Vector<float>&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "transfer_params"), this->transfer_params,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const WTF::Vector<float>&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool ColorSpace::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
EosVideoFrameData::EosVideoFrameData() {}

EosVideoFrameData::~EosVideoFrameData() = default;
size_t EosVideoFrameData::Hash(size_t seed) const {
  return seed;
}

void EosVideoFrameData::WriteIntoTrace(
    perfetto::TracedValue traced_context) const {
  [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
}

bool EosVideoFrameData::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
NativeGpuMemoryBufferHandle::NativeGpuMemoryBufferHandle()
    : id(),
      platform_handle() {}

NativeGpuMemoryBufferHandle::NativeGpuMemoryBufferHandle(
    ::gfx::GpuMemoryBufferId id_in,
    ::media::stable::mojom::blink::NativePixmapHandlePtr platform_handle_in)
    : id(std::move(id_in)),
      platform_handle(std::move(platform_handle_in)) {}

NativeGpuMemoryBufferHandle::~NativeGpuMemoryBufferHandle() = default;

void NativeGpuMemoryBufferHandle::WriteIntoTrace(
    perfetto::TracedValue traced_context) const {
  [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "id"), this->id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type ::gfx::GpuMemoryBufferId>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "platform_handle"), this->platform_handle,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type ::media::stable::mojom::blink::NativePixmapHandlePtr>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool NativeGpuMemoryBufferHandle::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
GpuMemoryBufferVideoFrameData::GpuMemoryBufferVideoFrameData()
    : gpu_memory_buffer_handle() {}

GpuMemoryBufferVideoFrameData::GpuMemoryBufferVideoFrameData(
    NativeGpuMemoryBufferHandlePtr gpu_memory_buffer_handle_in)
    : gpu_memory_buffer_handle(std::move(gpu_memory_buffer_handle_in)) {}

GpuMemoryBufferVideoFrameData::~GpuMemoryBufferVideoFrameData() = default;

void GpuMemoryBufferVideoFrameData::WriteIntoTrace(
    perfetto::TracedValue traced_context) const {
  [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "gpu_memory_buffer_handle"), this->gpu_memory_buffer_handle,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type NativeGpuMemoryBufferHandlePtr>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool GpuMemoryBufferVideoFrameData::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
VideoFrameMetadata::VideoFrameMetadata()
    : allow_overlay(),
      end_of_stream(),
      read_lock_fences_enabled(),
      protected_video(),
      hw_protected(),
      power_efficient() {}

VideoFrameMetadata::VideoFrameMetadata(
    bool allow_overlay_in,
    bool end_of_stream_in,
    bool read_lock_fences_enabled_in,
    bool protected_video_in,
    bool hw_protected_in,
    bool power_efficient_in)
    : allow_overlay(std::move(allow_overlay_in)),
      end_of_stream(std::move(end_of_stream_in)),
      read_lock_fences_enabled(std::move(read_lock_fences_enabled_in)),
      protected_video(std::move(protected_video_in)),
      hw_protected(std::move(hw_protected_in)),
      power_efficient(std::move(power_efficient_in)) {}

VideoFrameMetadata::~VideoFrameMetadata() = default;
size_t VideoFrameMetadata::Hash(size_t seed) const {
  seed = mojo::internal::WTFHash(seed, this->allow_overlay);
  seed = mojo::internal::WTFHash(seed, this->end_of_stream);
  seed = mojo::internal::WTFHash(seed, this->read_lock_fences_enabled);
  seed = mojo::internal::WTFHash(seed, this->protected_video);
  seed = mojo::internal::WTFHash(seed, this->hw_protected);
  seed = mojo::internal::WTFHash(seed, this->power_efficient);
  return seed;
}

void VideoFrameMetadata::WriteIntoTrace(
    perfetto::TracedValue traced_context) const {
  [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "allow_overlay"), this->allow_overlay,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type bool>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "end_of_stream"), this->end_of_stream,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type bool>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "read_lock_fences_enabled"), this->read_lock_fences_enabled,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type bool>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "protected_video"), this->protected_video,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type bool>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "hw_protected"), this->hw_protected,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type bool>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "power_efficient"), this->power_efficient,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type bool>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool VideoFrameMetadata::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
VideoFrame::VideoFrame()
    : format(),
      coded_size(),
      visible_rect(),
      natural_size(),
      timestamp(),
      data(),
      metadata(),
      color_space(),
      hdr_metadata() {}

VideoFrame::VideoFrame(
    VideoPixelFormat format_in,
    const ::gfx::Size& coded_size_in,
    const ::gfx::Rect& visible_rect_in,
    const ::gfx::Size& natural_size_in,
    ::base::TimeDelta timestamp_in,
    VideoFrameDataPtr data_in,
    VideoFrameMetadataPtr metadata_in,
    ColorSpacePtr color_space_in,
    HDRMetadataPtr hdr_metadata_in)
    : format(std::move(format_in)),
      coded_size(std::move(coded_size_in)),
      visible_rect(std::move(visible_rect_in)),
      natural_size(std::move(natural_size_in)),
      timestamp(std::move(timestamp_in)),
      data(std::move(data_in)),
      metadata(std::move(metadata_in)),
      color_space(std::move(color_space_in)),
      hdr_metadata(std::move(hdr_metadata_in)) {}

VideoFrame::~VideoFrame() = default;

void VideoFrame::WriteIntoTrace(
    perfetto::TracedValue traced_context) const {
  [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "format"), this->format,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type VideoPixelFormat>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "coded_size"), this->coded_size,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const ::gfx::Size&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "visible_rect"), this->visible_rect,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const ::gfx::Rect&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "natural_size"), this->natural_size,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const ::gfx::Size&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "timestamp"), this->timestamp,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type ::base::TimeDelta>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "data"), this->data,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type VideoFrameDataPtr>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "metadata"), this->metadata,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type VideoFrameMetadataPtr>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "color_space"), this->color_space,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type ColorSpacePtr>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "hdr_metadata"), this->hdr_metadata,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type HDRMetadataPtr>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool VideoFrame::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
MediaLogRecord::MediaLogRecord()
    : id(),
      type(),
      params(),
      time() {}

MediaLogRecord::MediaLogRecord(
    int32_t id_in,
    MediaLogRecord::Type type_in,
    ::base::Value params_in,
    ::base::TimeTicks time_in)
    : id(std::move(id_in)),
      type(std::move(type_in)),
      params(std::move(params_in)),
      time(std::move(time_in)) {}

MediaLogRecord::~MediaLogRecord() = default;

void MediaLogRecord::WriteIntoTrace(
    perfetto::TracedValue traced_context) const {
  [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "id"), this->id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type int32_t>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "type"), this->type,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type MediaLogRecord::Type>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "params"), this->params,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type ::base::Value>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "time"), this->time,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type ::base::TimeTicks>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool MediaLogRecord::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
VideoFrameData::VideoFrameData() : tag_(Tag::kEosData) {
  data_.eos_data = new EosVideoFrameDataPtr;
}

VideoFrameData::~VideoFrameData() {
  DestroyActive();
}


void VideoFrameData::set_eos_data(
    EosVideoFrameDataPtr eos_data) {
  if (tag_ == Tag::kEosData) {
    *(data_.eos_data) = std::move(eos_data);
  } else {
    DestroyActive();
    tag_ = Tag::kEosData;
    data_.eos_data = new EosVideoFrameDataPtr(
        std::move(eos_data));
  }
}
void VideoFrameData::set_gpu_memory_buffer_data(
    GpuMemoryBufferVideoFrameDataPtr gpu_memory_buffer_data) {
  if (tag_ == Tag::kGpuMemoryBufferData) {
    *(data_.gpu_memory_buffer_data) = std::move(gpu_memory_buffer_data);
  } else {
    DestroyActive();
    tag_ = Tag::kGpuMemoryBufferData;
    data_.gpu_memory_buffer_data = new GpuMemoryBufferVideoFrameDataPtr(
        std::move(gpu_memory_buffer_data));
  }
}

void VideoFrameData::DestroyActive() {
  switch (tag_) {

    case Tag::kEosData:

      delete data_.eos_data;
      break;
    case Tag::kGpuMemoryBufferData:

      delete data_.gpu_memory_buffer_data;
      break;
  }
}

bool VideoFrameData::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context, false);
}


}  // namespace blink
}  // namespace mojom
}  // namespace stable
}  // namespace media


namespace mojo {


// static
bool StructTraits<::media::stable::mojom::blink::SubsampleEntry::DataView, ::media::stable::mojom::blink::SubsampleEntryPtr>::Read(
    ::media::stable::mojom::blink::SubsampleEntry::DataView input,
    ::media::stable::mojom::blink::SubsampleEntryPtr* output) {
  bool success = true;
  ::media::stable::mojom::blink::SubsampleEntryPtr result(::media::stable::mojom::blink::SubsampleEntry::New());
  
      if (success)
        result->clear_bytes = input.clear_bytes();
      if (success)
        result->cypher_bytes = input.cypher_bytes();
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::media::stable::mojom::blink::DecryptConfig::DataView, ::media::stable::mojom::blink::DecryptConfigPtr>::Read(
    ::media::stable::mojom::blink::DecryptConfig::DataView input,
    ::media::stable::mojom::blink::DecryptConfigPtr* output) {
  bool success = true;
  ::media::stable::mojom::blink::DecryptConfigPtr result(::media::stable::mojom::blink::DecryptConfig::New());
  
      if (success && !input.ReadEncryptionScheme(&result->encryption_scheme))
        success = false;
      if (success && !input.ReadKeyId(&result->key_id))
        success = false;
      if (success && !input.ReadIv(&result->iv))
        success = false;
      if (success && !input.ReadSubsamples(&result->subsamples))
        success = false;
      if (success && !input.ReadEncryptionPattern(&result->encryption_pattern))
        success = false;
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::media::stable::mojom::blink::ColorVolumeMetadata::DataView, ::media::stable::mojom::blink::ColorVolumeMetadataPtr>::Read(
    ::media::stable::mojom::blink::ColorVolumeMetadata::DataView input,
    ::media::stable::mojom::blink::ColorVolumeMetadataPtr* output) {
  bool success = true;
  ::media::stable::mojom::blink::ColorVolumeMetadataPtr result(::media::stable::mojom::blink::ColorVolumeMetadata::New());
  
      if (success && !input.ReadPrimaryR(&result->primary_r))
        success = false;
      if (success && !input.ReadPrimaryG(&result->primary_g))
        success = false;
      if (success && !input.ReadPrimaryB(&result->primary_b))
        success = false;
      if (success && !input.ReadWhitePoint(&result->white_point))
        success = false;
      if (success)
        result->luminance_max = input.luminance_max();
      if (success)
        result->luminance_min = input.luminance_min();
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::media::stable::mojom::blink::HDRMetadata::DataView, ::media::stable::mojom::blink::HDRMetadataPtr>::Read(
    ::media::stable::mojom::blink::HDRMetadata::DataView input,
    ::media::stable::mojom::blink::HDRMetadataPtr* output) {
  bool success = true;
  ::media::stable::mojom::blink::HDRMetadataPtr result(::media::stable::mojom::blink::HDRMetadata::New());
  
      if (success && !input.ReadColorVolumeMetadata(&result->color_volume_metadata))
        success = false;
      if (success)
        result->max_content_light_level = input.max_content_light_level();
      if (success)
        result->max_frame_average_light_level = input.max_frame_average_light_level();
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::media::stable::mojom::blink::VideoDecoderConfig::DataView, ::media::stable::mojom::blink::VideoDecoderConfigPtr>::Read(
    ::media::stable::mojom::blink::VideoDecoderConfig::DataView input,
    ::media::stable::mojom::blink::VideoDecoderConfigPtr* output) {
  bool success = true;
  ::media::stable::mojom::blink::VideoDecoderConfigPtr result(::media::stable::mojom::blink::VideoDecoderConfig::New());
  
      if (success && !input.ReadCodec(&result->codec))
        success = false;
      if (success && !input.ReadProfile(&result->profile))
        success = false;
      if (success)
        result->level = input.level();
      if (success)
        result->has_alpha = input.has_alpha();
      if (success && !input.ReadCodedSize(&result->coded_size))
        success = false;
      if (success && !input.ReadVisibleRect(&result->visible_rect))
        success = false;
      if (success && !input.ReadNaturalSize(&result->natural_size))
        success = false;
      if (success && !input.ReadExtraData(&result->extra_data))
        success = false;
      if (success && !input.ReadEncryptionScheme(&result->encryption_scheme))
        success = false;
      if (success && !input.ReadColorSpaceInfo(&result->color_space_info))
        success = false;
      if (success && !input.ReadHdrMetadata(&result->hdr_metadata))
        success = false;
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::media::stable::mojom::blink::SupportedVideoDecoderConfig::DataView, ::media::stable::mojom::blink::SupportedVideoDecoderConfigPtr>::Read(
    ::media::stable::mojom::blink::SupportedVideoDecoderConfig::DataView input,
    ::media::stable::mojom::blink::SupportedVideoDecoderConfigPtr* output) {
  bool success = true;
  ::media::stable::mojom::blink::SupportedVideoDecoderConfigPtr result(::media::stable::mojom::blink::SupportedVideoDecoderConfig::New());
  
      if (success && !input.ReadProfileMin(&result->profile_min))
        success = false;
      if (success && !input.ReadProfileMax(&result->profile_max))
        success = false;
      if (success && !input.ReadCodedSizeMin(&result->coded_size_min))
        success = false;
      if (success && !input.ReadCodedSizeMax(&result->coded_size_max))
        success = false;
      if (success)
        result->allow_encrypted = input.allow_encrypted();
      if (success)
        result->require_encrypted = input.require_encrypted();
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::media::stable::mojom::blink::StatusData::DataView, ::media::stable::mojom::blink::StatusDataPtr>::Read(
    ::media::stable::mojom::blink::StatusData::DataView input,
    ::media::stable::mojom::blink::StatusDataPtr* output) {
  bool success = true;
  ::media::stable::mojom::blink::StatusDataPtr result(::media::stable::mojom::blink::StatusData::New());
  
      if (success && !input.ReadGroup(&result->group))
        success = false;
      if (success && !input.ReadCode(&result->code))
        success = false;
      if (success && !input.ReadMessage(&result->message))
        success = false;
      if (success && !input.ReadFrames(&result->frames))
        success = false;
      if (success && !input.ReadCause(&result->cause))
        success = false;
      if (success && !input.ReadData(&result->data))
        success = false;
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::media::stable::mojom::blink::Status::DataView, ::media::stable::mojom::blink::StatusPtr>::Read(
    ::media::stable::mojom::blink::Status::DataView input,
    ::media::stable::mojom::blink::StatusPtr* output) {
  bool success = true;
  ::media::stable::mojom::blink::StatusPtr result(::media::stable::mojom::blink::Status::New());
  
      if (success && !input.ReadInternal(&result->internal))
        success = false;
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::media::stable::mojom::blink::DecoderBuffer::DataView, ::media::stable::mojom::blink::DecoderBufferPtr>::Read(
    ::media::stable::mojom::blink::DecoderBuffer::DataView input,
    ::media::stable::mojom::blink::DecoderBufferPtr* output) {
  bool success = true;
  ::media::stable::mojom::blink::DecoderBufferPtr result(::media::stable::mojom::blink::DecoderBuffer::New());
  
      if (success && !input.ReadTimestamp(&result->timestamp))
        success = false;
      if (success && !input.ReadDuration(&result->duration))
        success = false;
      if (success)
        result->is_end_of_stream = input.is_end_of_stream();
      if (success)
        result->data_size = input.data_size();
      if (success)
        result->is_key_frame = input.is_key_frame();
      if (success && !input.ReadSideData(&result->side_data))
        success = false;
      if (success && !input.ReadDecryptConfig(&result->decrypt_config))
        success = false;
      if (success && !input.ReadFrontDiscard(&result->front_discard))
        success = false;
      if (success && !input.ReadBackDiscard(&result->back_discard))
        success = false;
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::media::stable::mojom::blink::ColorSpace::DataView, ::media::stable::mojom::blink::ColorSpacePtr>::Read(
    ::media::stable::mojom::blink::ColorSpace::DataView input,
    ::media::stable::mojom::blink::ColorSpacePtr* output) {
  bool success = true;
  ::media::stable::mojom::blink::ColorSpacePtr result(::media::stable::mojom::blink::ColorSpace::New());
  
      if (success && !input.ReadPrimaries(&result->primaries))
        success = false;
      if (success && !input.ReadTransfer(&result->transfer))
        success = false;
      if (success && !input.ReadMatrix(&result->matrix))
        success = false;
      if (success && !input.ReadRange(&result->range))
        success = false;
      if (success && !input.ReadCustomPrimaryMatrix(&result->custom_primary_matrix))
        success = false;
      if (success && !input.ReadTransferParams(&result->transfer_params))
        success = false;
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::media::stable::mojom::blink::EosVideoFrameData::DataView, ::media::stable::mojom::blink::EosVideoFrameDataPtr>::Read(
    ::media::stable::mojom::blink::EosVideoFrameData::DataView input,
    ::media::stable::mojom::blink::EosVideoFrameDataPtr* output) {
  bool success = true;
  ::media::stable::mojom::blink::EosVideoFrameDataPtr result(::media::stable::mojom::blink::EosVideoFrameData::New());
  
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::media::stable::mojom::blink::NativeGpuMemoryBufferHandle::DataView, ::media::stable::mojom::blink::NativeGpuMemoryBufferHandlePtr>::Read(
    ::media::stable::mojom::blink::NativeGpuMemoryBufferHandle::DataView input,
    ::media::stable::mojom::blink::NativeGpuMemoryBufferHandlePtr* output) {
  bool success = true;
  ::media::stable::mojom::blink::NativeGpuMemoryBufferHandlePtr result(::media::stable::mojom::blink::NativeGpuMemoryBufferHandle::New());
  
      if (success && !input.ReadId(&result->id))
        success = false;
      if (success && !input.ReadPlatformHandle(&result->platform_handle))
        success = false;
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::media::stable::mojom::blink::GpuMemoryBufferVideoFrameData::DataView, ::media::stable::mojom::blink::GpuMemoryBufferVideoFrameDataPtr>::Read(
    ::media::stable::mojom::blink::GpuMemoryBufferVideoFrameData::DataView input,
    ::media::stable::mojom::blink::GpuMemoryBufferVideoFrameDataPtr* output) {
  bool success = true;
  ::media::stable::mojom::blink::GpuMemoryBufferVideoFrameDataPtr result(::media::stable::mojom::blink::GpuMemoryBufferVideoFrameData::New());
  
      if (success && !input.ReadGpuMemoryBufferHandle(&result->gpu_memory_buffer_handle))
        success = false;
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::media::stable::mojom::blink::VideoFrameMetadata::DataView, ::media::stable::mojom::blink::VideoFrameMetadataPtr>::Read(
    ::media::stable::mojom::blink::VideoFrameMetadata::DataView input,
    ::media::stable::mojom::blink::VideoFrameMetadataPtr* output) {
  bool success = true;
  ::media::stable::mojom::blink::VideoFrameMetadataPtr result(::media::stable::mojom::blink::VideoFrameMetadata::New());
  
      if (success)
        result->allow_overlay = input.allow_overlay();
      if (success)
        result->end_of_stream = input.end_of_stream();
      if (success)
        result->read_lock_fences_enabled = input.read_lock_fences_enabled();
      if (success)
        result->protected_video = input.protected_video();
      if (success)
        result->hw_protected = input.hw_protected();
      if (success)
        result->power_efficient = input.power_efficient();
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::media::stable::mojom::blink::VideoFrame::DataView, ::media::stable::mojom::blink::VideoFramePtr>::Read(
    ::media::stable::mojom::blink::VideoFrame::DataView input,
    ::media::stable::mojom::blink::VideoFramePtr* output) {
  bool success = true;
  ::media::stable::mojom::blink::VideoFramePtr result(::media::stable::mojom::blink::VideoFrame::New());
  
      if (success && !input.ReadFormat(&result->format))
        success = false;
      if (success && !input.ReadCodedSize(&result->coded_size))
        success = false;
      if (success && !input.ReadVisibleRect(&result->visible_rect))
        success = false;
      if (success && !input.ReadNaturalSize(&result->natural_size))
        success = false;
      if (success && !input.ReadTimestamp(&result->timestamp))
        success = false;
      if (success && !input.ReadData(&result->data))
        success = false;
      if (success && !input.ReadMetadata(&result->metadata))
        success = false;
      if (success && !input.ReadColorSpace(&result->color_space))
        success = false;
      if (success && !input.ReadHdrMetadata(&result->hdr_metadata))
        success = false;
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::media::stable::mojom::blink::MediaLogRecord::DataView, ::media::stable::mojom::blink::MediaLogRecordPtr>::Read(
    ::media::stable::mojom::blink::MediaLogRecord::DataView input,
    ::media::stable::mojom::blink::MediaLogRecordPtr* output) {
  bool success = true;
  ::media::stable::mojom::blink::MediaLogRecordPtr result(::media::stable::mojom::blink::MediaLogRecord::New());
  
      if (success)
        result->id = input.id();
      if (success && !input.ReadType(&result->type))
        success = false;
      if (success && !input.ReadParams(&result->params))
        success = false;
      if (success && !input.ReadTime(&result->time))
        success = false;
  *output = std::move(result);
  return success;
}

// static
bool UnionTraits<::media::stable::mojom::blink::VideoFrameData::DataView, ::media::stable::mojom::blink::VideoFrameDataPtr>::Read(
    ::media::stable::mojom::blink::VideoFrameData::DataView input,
    ::media::stable::mojom::blink::VideoFrameDataPtr* output) {
  using UnionType = ::media::stable::mojom::blink::VideoFrameData;
  using Tag = UnionType::Tag;

  switch (input.tag()) {
    case Tag::kEosData: {
      ::media::stable::mojom::blink::EosVideoFrameDataPtr result_eos_data;
      if (!input.ReadEosData(&result_eos_data))
        return false;

      *output = UnionType::NewEosData(
          std::move(result_eos_data));
      break;
    }
    case Tag::kGpuMemoryBufferData: {
      ::media::stable::mojom::blink::GpuMemoryBufferVideoFrameDataPtr result_gpu_memory_buffer_data;
      if (!input.ReadGpuMemoryBufferData(&result_gpu_memory_buffer_data))
        return false;

      *output = UnionType::NewGpuMemoryBufferData(
          std::move(result_gpu_memory_buffer_data));
      break;
    }
    default:

      return false;
  }
  return true;
}

}  // namespace mojo


// Symbols declared in the -test-utils.h header are defined here instead of a
// separate .cc file to save compile time.


namespace media {
namespace stable {
namespace mojom {
namespace blink {




}  // namespace blink
}  // namespace mojom
}  // namespace stable
}  // namespace media


#if defined(__clang__)
#pragma clang diagnostic pop
#endif