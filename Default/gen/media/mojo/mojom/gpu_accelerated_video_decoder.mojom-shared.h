// media/mojo/mojom/gpu_accelerated_video_decoder.mojom-shared.h is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2016 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef MEDIA_MOJO_MOJOM_GPU_ACCELERATED_VIDEO_DECODER_MOJOM_SHARED_H_
#define MEDIA_MOJO_MOJOM_GPU_ACCELERATED_VIDEO_DECODER_MOJOM_SHARED_H_

#include <stdint.h>

#include <functional>
#include <iosfwd>
#include <type_traits>
#include <utility>
#include "mojo/public/cpp/bindings/array_data_view.h"
#include "mojo/public/cpp/bindings/enum_traits.h"
#include "mojo/public/cpp/bindings/interface_data_view.h"
#include "mojo/public/cpp/bindings/lib/bindings_internal.h"
#include "mojo/public/cpp/bindings/lib/serialization.h"
#include "mojo/public/cpp/bindings/map_data_view.h"
#include "mojo/public/cpp/bindings/string_data_view.h"

#include "third_party/perfetto/include/perfetto/tracing/traced_value_forward.h"

#include "media/mojo/mojom/gpu_accelerated_video_decoder.mojom-shared-internal.h"
#include "media/mojo/mojom/media_types.mojom-shared.h"
#include "media/mojo/mojom/video_decoder.mojom-shared.h"
#include "ui/gfx/geometry/mojom/geometry.mojom-shared.h"
#include "ui/gfx/mojom/color_space.mojom-shared.h"
#include "mojo/public/cpp/bindings/lib/interface_serialization.h"


#include "mojo/public/cpp/bindings/native_enum.h"
#include "mojo/public/cpp/bindings/lib/native_struct_serialization.h"




namespace media {
namespace mojom {
using VideoDecodeAcceleratorConfigDataView = mojo::native::NativeStructDataView;

using BitstreamBufferDataView = mojo::native::NativeStructDataView;

class PictureBufferAssignmentDataView;

class PictureReadyParamsDataView;



}  // namespace mojom
}  // namespace media

namespace mojo {
namespace internal {

template <>
struct MojomTypeTraits<::media::mojom::PictureBufferAssignmentDataView> {
  using Data = ::media::mojom::internal::PictureBufferAssignment_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::media::mojom::PictureReadyParamsDataView> {
  using Data = ::media::mojom::internal::PictureReadyParams_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

}  // namespace internal
}  // namespace mojo


namespace media {
namespace mojom {
// Interface base classes. They are used for type safety check.
class GpuAcceleratedVideoDecoderProviderInterfaceBase {};

using GpuAcceleratedVideoDecoderProviderPtrDataView =
    mojo::InterfacePtrDataView<GpuAcceleratedVideoDecoderProviderInterfaceBase>;
using GpuAcceleratedVideoDecoderProviderRequestDataView =
    mojo::InterfaceRequestDataView<GpuAcceleratedVideoDecoderProviderInterfaceBase>;
using GpuAcceleratedVideoDecoderProviderAssociatedPtrInfoDataView =
    mojo::AssociatedInterfacePtrInfoDataView<GpuAcceleratedVideoDecoderProviderInterfaceBase>;
using GpuAcceleratedVideoDecoderProviderAssociatedRequestDataView =
    mojo::AssociatedInterfaceRequestDataView<GpuAcceleratedVideoDecoderProviderInterfaceBase>;
class GpuAcceleratedVideoDecoderInterfaceBase {};

using GpuAcceleratedVideoDecoderPtrDataView =
    mojo::InterfacePtrDataView<GpuAcceleratedVideoDecoderInterfaceBase>;
using GpuAcceleratedVideoDecoderRequestDataView =
    mojo::InterfaceRequestDataView<GpuAcceleratedVideoDecoderInterfaceBase>;
using GpuAcceleratedVideoDecoderAssociatedPtrInfoDataView =
    mojo::AssociatedInterfacePtrInfoDataView<GpuAcceleratedVideoDecoderInterfaceBase>;
using GpuAcceleratedVideoDecoderAssociatedRequestDataView =
    mojo::AssociatedInterfaceRequestDataView<GpuAcceleratedVideoDecoderInterfaceBase>;
class GpuAcceleratedVideoDecoderClientInterfaceBase {};

using GpuAcceleratedVideoDecoderClientPtrDataView =
    mojo::InterfacePtrDataView<GpuAcceleratedVideoDecoderClientInterfaceBase>;
using GpuAcceleratedVideoDecoderClientRequestDataView =
    mojo::InterfaceRequestDataView<GpuAcceleratedVideoDecoderClientInterfaceBase>;
using GpuAcceleratedVideoDecoderClientAssociatedPtrInfoDataView =
    mojo::AssociatedInterfacePtrInfoDataView<GpuAcceleratedVideoDecoderClientInterfaceBase>;
using GpuAcceleratedVideoDecoderClientAssociatedRequestDataView =
    mojo::AssociatedInterfaceRequestDataView<GpuAcceleratedVideoDecoderClientInterfaceBase>;


class PictureBufferAssignmentDataView {
 public:
  PictureBufferAssignmentDataView() = default;

  PictureBufferAssignmentDataView(
      internal::PictureBufferAssignment_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  int32_t buffer_id() const {
    return data_->buffer_id;
  }
  inline void GetTextureIdsDataView(
      mojo::ArrayDataView<uint32_t>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadTextureIds(UserType* output) {
    
    auto* pointer = data_->texture_ids.Get();
    return mojo::internal::Deserialize<mojo::ArrayDataView<uint32_t>>(
        pointer, output, message_);
  }
 private:
  internal::PictureBufferAssignment_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class PictureReadyParamsDataView {
 public:
  PictureReadyParamsDataView() = default;

  PictureReadyParamsDataView(
      internal::PictureReadyParams_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  int32_t picture_buffer_id() const {
    return data_->picture_buffer_id;
  }
  int32_t bitstream_buffer_id() const {
    return data_->bitstream_buffer_id;
  }
  inline void GetVisibleRectDataView(
      ::gfx::mojom::RectDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadVisibleRect(UserType* output) {
    
    auto* pointer = data_->visible_rect.Get();
    return mojo::internal::Deserialize<::gfx::mojom::RectDataView>(
        pointer, output, message_);
  }
  inline void GetColorSpaceDataView(
      ::gfx::mojom::ColorSpaceDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadColorSpace(UserType* output) {
    
    auto* pointer = data_->color_space.Get();
    return mojo::internal::Deserialize<::gfx::mojom::ColorSpaceDataView>(
        pointer, output, message_);
  }
  bool allow_overlay() const {
    return data_->allow_overlay;
  }
  bool read_lock_fences_enabled() const {
    return data_->read_lock_fences_enabled;
  }
  bool size_changed() const {
    return data_->size_changed;
  }
  bool surface_texture() const {
    return data_->surface_texture;
  }
  bool wants_promotion_hint() const {
    return data_->wants_promotion_hint;
  }
 private:
  internal::PictureReadyParams_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



}  // namespace mojom
}  // namespace media

namespace std {

}  // namespace std

namespace mojo {


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::media::mojom::PictureBufferAssignmentDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::media::mojom::PictureBufferAssignmentDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::media::mojom::internal::PictureBufferAssignment_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    fragment->buffer_id = Traits::buffer_id(input);
    decltype(Traits::texture_ids(input)) in_texture_ids = Traits::texture_ids(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->texture_ids)::BaseType>
        texture_ids_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams texture_ids_validate_params(
        0, false, nullptr);
    mojo::internal::Serialize<mojo::ArrayDataView<uint32_t>>(
        in_texture_ids, texture_ids_fragment, &texture_ids_validate_params);
    fragment->texture_ids.Set(
        texture_ids_fragment.is_null() ? nullptr : texture_ids_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->texture_ids.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null texture_ids in PictureBufferAssignment struct");
  }

  static bool Deserialize(::media::mojom::internal::PictureBufferAssignment_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::media::mojom::PictureBufferAssignmentDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::media::mojom::PictureReadyParamsDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::media::mojom::PictureReadyParamsDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::media::mojom::internal::PictureReadyParams_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    fragment->picture_buffer_id = Traits::picture_buffer_id(input);
    fragment->bitstream_buffer_id = Traits::bitstream_buffer_id(input);
    decltype(Traits::visible_rect(input)) in_visible_rect = Traits::visible_rect(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->visible_rect)::BaseType> visible_rect_fragment(
            fragment.message());
    mojo::internal::Serialize<::gfx::mojom::RectDataView>(
        in_visible_rect, visible_rect_fragment);
    fragment->visible_rect.Set(
        visible_rect_fragment.is_null() ? nullptr : visible_rect_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->visible_rect.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null visible_rect in PictureReadyParams struct");
    decltype(Traits::color_space(input)) in_color_space = Traits::color_space(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->color_space)::BaseType> color_space_fragment(
            fragment.message());
    mojo::internal::Serialize<::gfx::mojom::ColorSpaceDataView>(
        in_color_space, color_space_fragment);
    fragment->color_space.Set(
        color_space_fragment.is_null() ? nullptr : color_space_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->color_space.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null color_space in PictureReadyParams struct");
    fragment->allow_overlay = Traits::allow_overlay(input);
    fragment->read_lock_fences_enabled = Traits::read_lock_fences_enabled(input);
    fragment->size_changed = Traits::size_changed(input);
    fragment->surface_texture = Traits::surface_texture(input);
    fragment->wants_promotion_hint = Traits::wants_promotion_hint(input);
  }

  static bool Deserialize(::media::mojom::internal::PictureReadyParams_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::media::mojom::PictureReadyParamsDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal

}  // namespace mojo


namespace media {
namespace mojom {

inline void PictureBufferAssignmentDataView::GetTextureIdsDataView(
    mojo::ArrayDataView<uint32_t>* output) {
  auto pointer = data_->texture_ids.Get();
  *output = mojo::ArrayDataView<uint32_t>(pointer, message_);
}


inline void PictureReadyParamsDataView::GetVisibleRectDataView(
    ::gfx::mojom::RectDataView* output) {
  auto pointer = data_->visible_rect.Get();
  *output = ::gfx::mojom::RectDataView(pointer, message_);
}
inline void PictureReadyParamsDataView::GetColorSpaceDataView(
    ::gfx::mojom::ColorSpaceDataView* output) {
  auto pointer = data_->color_space.Get();
  *output = ::gfx::mojom::ColorSpaceDataView(pointer, message_);
}



}  // namespace mojom
}  // namespace media

// Declare TraceFormatTraits for enums, which should be defined in ::perfetto
// namespace.

#endif  // MEDIA_MOJO_MOJOM_GPU_ACCELERATED_VIDEO_DECODER_MOJOM_SHARED_H_