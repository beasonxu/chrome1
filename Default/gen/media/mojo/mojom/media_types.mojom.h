// media/mojo/mojom/media_types.mojom.h is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2013 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef MEDIA_MOJO_MOJOM_MEDIA_TYPES_MOJOM_H_
#define MEDIA_MOJO_MOJOM_MEDIA_TYPES_MOJOM_H_

#include <stdint.h>

#include <limits>
#include <type_traits>
#include <utility>

#include "third_party/abseil-cpp/absl/types/optional.h"
#include "mojo/public/cpp/bindings/clone_traits.h"
#include "mojo/public/cpp/bindings/equals_traits.h"
#include "mojo/public/cpp/bindings/lib/serialization.h"
#include "mojo/public/cpp/bindings/struct_ptr.h"
#include "mojo/public/cpp/bindings/struct_traits.h"
#include "mojo/public/cpp/bindings/union_traits.h"

#include "third_party/perfetto/include/perfetto/tracing/traced_value_forward.h"

#include "media/mojo/mojom/media_types.mojom-shared.h"
#include "media/mojo/mojom/media_types.mojom-forward.h"
#include "gpu/ipc/common/mailbox_holder.mojom.h"
#include "gpu/ipc/common/vulkan_ycbcr_info.mojom.h"
#include "media/mojo/mojom/audio_data.mojom-forward.h"
#include "media/mojo/mojom/encryption_pattern.mojom.h"
#include "mojo/public/mojom/base/shared_memory.mojom.h"
#include "mojo/public/mojom/base/time.mojom.h"
#include "mojo/public/mojom/base/values.mojom.h"
#include "mojo/public/mojom/base/unguessable_token.mojom.h"
#include "ui/gfx/geometry/mojom/geometry.mojom.h"
#include "ui/gfx/mojom/buffer_types.mojom.h"
#include "ui/gfx/mojom/color_space.mojom.h"
#include "ui/gfx/mojom/hdr_metadata.mojom.h"
#include <string>
#include <vector>

#include "mojo/public/cpp/bindings/lib/control_message_handler.h"
#include "mojo/public/cpp/bindings/raw_ptr_impl_ref_traits.h"


#include "mojo/public/cpp/bindings/lib/native_enum_serialization.h"
#include "mojo/public/cpp/bindings/lib/native_struct_serialization.h"
#include "media/base/ipc/media_param_traits_macros.h"
#include "media/base/video_decoder_config.h"
#include "media/mojo/mojom/audio_decoder_config_mojom_traits.h"
#include "media/mojo/mojom/media_types_enum_mojom_traits.h"
#include "media/mojo/mojom/pipeline_status_mojom_traits.h"
#include "media/mojo/mojom/status_mojom_traits.h"
#include "media/mojo/mojom/supported_video_decoder_config_mojom_traits.h"
#include "media/mojo/mojom/video_color_space_mojom_traits.h"
#include "media/mojo/mojom/video_encode_accelerator_mojom_traits.h"
#include "media/mojo/mojom/video_frame_metadata_mojom_traits.h"
#include "media/mojo/mojom/video_frame_mojom_traits.h"
#include "media/mojo/mojom/video_transformation_mojom_traits.h"




namespace media {
namespace mojom {






class  VideoTransformation {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<VideoTransformation, T>::value>;
  using DataView = VideoTransformationDataView;
  using Data_ = internal::VideoTransformation_Data;

  template <typename... Args>
  static VideoTransformationPtr New(Args&&... args) {
    return VideoTransformationPtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static VideoTransformationPtr From(const U& u) {
    return mojo::TypeConverter<VideoTransformationPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, VideoTransformation>::Convert(*this);
  }


  VideoTransformation();

  VideoTransformation(
      ::media::VideoRotation rotation,
      bool mirrored);


  ~VideoTransformation();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = VideoTransformationPtr>
  VideoTransformationPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, VideoTransformation::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, VideoTransformation::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        VideoTransformation::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        VideoTransformation::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::VideoTransformation_UnserializedMessageContext<
            UserType, VideoTransformation::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<VideoTransformation::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return VideoTransformation::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::VideoTransformation_UnserializedMessageContext<
            UserType, VideoTransformation::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<VideoTransformation::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
  ::media::VideoRotation rotation;
  
  bool mirrored;

  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, VideoTransformation::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, VideoTransformation::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, VideoTransformation::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, VideoTransformation::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





class  VideoColorSpace {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<VideoColorSpace, T>::value>;
  using DataView = VideoColorSpaceDataView;
  using Data_ = internal::VideoColorSpace_Data;
  using PrimaryID = VideoColorSpace_PrimaryID;
  using TransferID = VideoColorSpace_TransferID;
  using MatrixID = VideoColorSpace_MatrixID;
  using RangeID = VideoColorSpace_RangeID;

  template <typename... Args>
  static VideoColorSpacePtr New(Args&&... args) {
    return VideoColorSpacePtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static VideoColorSpacePtr From(const U& u) {
    return mojo::TypeConverter<VideoColorSpacePtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, VideoColorSpace>::Convert(*this);
  }


  VideoColorSpace();

  VideoColorSpace(
      ::media::VideoColorSpace::PrimaryID primaries,
      VideoColorSpace::TransferID transfer,
      VideoColorSpace::MatrixID matrix,
      VideoColorSpace::RangeID range);


  ~VideoColorSpace();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = VideoColorSpacePtr>
  VideoColorSpacePtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, VideoColorSpace::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, VideoColorSpace::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        VideoColorSpace::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        VideoColorSpace::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::VideoColorSpace_UnserializedMessageContext<
            UserType, VideoColorSpace::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<VideoColorSpace::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return VideoColorSpace::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::VideoColorSpace_UnserializedMessageContext<
            UserType, VideoColorSpace::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<VideoColorSpace::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
  ::media::VideoColorSpace::PrimaryID primaries;
  
  VideoColorSpace::TransferID transfer;
  
  VideoColorSpace::MatrixID matrix;
  
  VideoColorSpace::RangeID range;

  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, VideoColorSpace::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, VideoColorSpace::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, VideoColorSpace::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, VideoColorSpace::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}













class  EosVideoFrameData {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<EosVideoFrameData, T>::value>;
  using DataView = EosVideoFrameDataDataView;
  using Data_ = internal::EosVideoFrameData_Data;

  template <typename... Args>
  static EosVideoFrameDataPtr New(Args&&... args) {
    return EosVideoFrameDataPtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static EosVideoFrameDataPtr From(const U& u) {
    return mojo::TypeConverter<EosVideoFrameDataPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, EosVideoFrameData>::Convert(*this);
  }


  EosVideoFrameData();


  ~EosVideoFrameData();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = EosVideoFrameDataPtr>
  EosVideoFrameDataPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, EosVideoFrameData::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, EosVideoFrameData::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  size_t Hash(size_t seed) const;
  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        EosVideoFrameData::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        EosVideoFrameData::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::EosVideoFrameData_UnserializedMessageContext<
            UserType, EosVideoFrameData::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<EosVideoFrameData::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return EosVideoFrameData::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::EosVideoFrameData_UnserializedMessageContext<
            UserType, EosVideoFrameData::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<EosVideoFrameData::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }


  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, EosVideoFrameData::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, EosVideoFrameData::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, EosVideoFrameData::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, EosVideoFrameData::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}










class  PredictionTargets {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<PredictionTargets, T>::value>;
  using DataView = PredictionTargetsDataView;
  using Data_ = internal::PredictionTargets_Data;

  template <typename... Args>
  static PredictionTargetsPtr New(Args&&... args) {
    return PredictionTargetsPtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static PredictionTargetsPtr From(const U& u) {
    return mojo::TypeConverter<PredictionTargetsPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, PredictionTargets>::Convert(*this);
  }


  PredictionTargets();

  PredictionTargets(
      uint32_t frames_decoded,
      uint32_t frames_dropped,
      uint32_t frames_power_efficient);


  ~PredictionTargets();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = PredictionTargetsPtr>
  PredictionTargetsPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, PredictionTargets::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, PredictionTargets::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  size_t Hash(size_t seed) const;
  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        PredictionTargets::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        PredictionTargets::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::PredictionTargets_UnserializedMessageContext<
            UserType, PredictionTargets::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<PredictionTargets::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return PredictionTargets::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::PredictionTargets_UnserializedMessageContext<
            UserType, PredictionTargets::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<PredictionTargets::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
  uint32_t frames_decoded;
  
  uint32_t frames_dropped;
  
  uint32_t frames_power_efficient;

  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, PredictionTargets::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, PredictionTargets::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, PredictionTargets::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, PredictionTargets::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





class  AudioPipelineInfo {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<AudioPipelineInfo, T>::value>;
  using DataView = AudioPipelineInfoDataView;
  using Data_ = internal::AudioPipelineInfo_Data;

  template <typename... Args>
  static AudioPipelineInfoPtr New(Args&&... args) {
    return AudioPipelineInfoPtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static AudioPipelineInfoPtr From(const U& u) {
    return mojo::TypeConverter<AudioPipelineInfoPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, AudioPipelineInfo>::Convert(*this);
  }


  AudioPipelineInfo();

  AudioPipelineInfo(
      ::media::AudioDecoderType decoder_type,
      bool is_platform_decoder,
      bool has_decrypting_demuxer_stream,
      EncryptionType encryption_type);


  ~AudioPipelineInfo();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = AudioPipelineInfoPtr>
  AudioPipelineInfoPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, AudioPipelineInfo::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, AudioPipelineInfo::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        AudioPipelineInfo::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        AudioPipelineInfo::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::AudioPipelineInfo_UnserializedMessageContext<
            UserType, AudioPipelineInfo::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<AudioPipelineInfo::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return AudioPipelineInfo::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::AudioPipelineInfo_UnserializedMessageContext<
            UserType, AudioPipelineInfo::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<AudioPipelineInfo::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
  ::media::AudioDecoderType decoder_type;
  
  bool is_platform_decoder;
  
  bool has_decrypting_demuxer_stream;
  
  EncryptionType encryption_type;

  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, AudioPipelineInfo::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, AudioPipelineInfo::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, AudioPipelineInfo::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, AudioPipelineInfo::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





class  VideoPipelineInfo {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<VideoPipelineInfo, T>::value>;
  using DataView = VideoPipelineInfoDataView;
  using Data_ = internal::VideoPipelineInfo_Data;

  template <typename... Args>
  static VideoPipelineInfoPtr New(Args&&... args) {
    return VideoPipelineInfoPtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static VideoPipelineInfoPtr From(const U& u) {
    return mojo::TypeConverter<VideoPipelineInfoPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, VideoPipelineInfo>::Convert(*this);
  }


  VideoPipelineInfo();

  VideoPipelineInfo(
      ::media::VideoDecoderType decoder_type,
      bool is_platform_decoder,
      bool has_decrypting_demuxer_stream,
      EncryptionType encryption_type);


  ~VideoPipelineInfo();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = VideoPipelineInfoPtr>
  VideoPipelineInfoPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, VideoPipelineInfo::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, VideoPipelineInfo::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        VideoPipelineInfo::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        VideoPipelineInfo::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::VideoPipelineInfo_UnserializedMessageContext<
            UserType, VideoPipelineInfo::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<VideoPipelineInfo::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return VideoPipelineInfo::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::VideoPipelineInfo_UnserializedMessageContext<
            UserType, VideoPipelineInfo::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<VideoPipelineInfo::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
  ::media::VideoDecoderType decoder_type;
  
  bool is_platform_decoder;
  
  bool has_decrypting_demuxer_stream;
  
  EncryptionType encryption_type;

  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, VideoPipelineInfo::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, VideoPipelineInfo::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, VideoPipelineInfo::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, VideoPipelineInfo::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}









class  VideoFrameData {
 public:
  using DataView = VideoFrameDataDataView;
  using Data_ = internal::VideoFrameData_Data;
  using Tag = Data_::VideoFrameData_Tag;

  template <typename... Args>
  static VideoFrameDataPtr New(Args&&... args) {
    static_assert(
        sizeof...(args) < 0,
        "Do not use Union::New(); to create a union of a given subtype, use "
        "New<SubType>(), not New() followed by set_<sub_type>(). To represent "
        "an empty union, mark the field or parameter as nullable in the mojom "
        "definition.");
  }
  // Construct an instance holding |eos_data|.
  static VideoFrameDataPtr
  NewEosData(
      EosVideoFrameDataPtr eos_data) {
    auto result = VideoFrameDataPtr(absl::in_place);
    result->set_eos_data(std::move(eos_data));
    return result;
  }
  // Construct an instance holding |shared_buffer_data|.
  static VideoFrameDataPtr
  NewSharedBufferData(
      SharedBufferVideoFrameDataPtr shared_buffer_data) {
    auto result = VideoFrameDataPtr(absl::in_place);
    result->set_shared_buffer_data(std::move(shared_buffer_data));
    return result;
  }
  // Construct an instance holding |gpu_memory_buffer_data|.
  static VideoFrameDataPtr
  NewGpuMemoryBufferData(
      GpuMemoryBufferVideoFrameDataPtr gpu_memory_buffer_data) {
    auto result = VideoFrameDataPtr(absl::in_place);
    result->set_gpu_memory_buffer_data(std::move(gpu_memory_buffer_data));
    return result;
  }
  // Construct an instance holding |mailbox_data|.
  static VideoFrameDataPtr
  NewMailboxData(
      MailboxVideoFrameDataPtr mailbox_data) {
    auto result = VideoFrameDataPtr(absl::in_place);
    result->set_mailbox_data(std::move(mailbox_data));
    return result;
  }

  template <typename U>
  static VideoFrameDataPtr From(const U& u) {
    return mojo::TypeConverter<VideoFrameDataPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, VideoFrameData>::Convert(*this);
  }

  VideoFrameData();
  ~VideoFrameData();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename UnionPtrType = VideoFrameDataPtr>
  VideoFrameDataPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T,
            typename std::enable_if<std::is_same<
                T, VideoFrameData>::value>::type* = nullptr>
  bool Equals(const T& other) const;

  template <typename T,
            typename std::enable_if<std::is_same<
                T, VideoFrameData>::value>::type* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }

  Tag which() const {
    return tag_;
  }


  
  bool is_eos_data() const { return tag_ == Tag::kEosData; }

  
  EosVideoFrameDataPtr& get_eos_data() const {
    CHECK(tag_ == Tag::kEosData);
    return *(data_.eos_data);
  }

  
  void set_eos_data(
      EosVideoFrameDataPtr eos_data);
  
  bool is_shared_buffer_data() const { return tag_ == Tag::kSharedBufferData; }

  
  SharedBufferVideoFrameDataPtr& get_shared_buffer_data() const {
    CHECK(tag_ == Tag::kSharedBufferData);
    return *(data_.shared_buffer_data);
  }

  
  void set_shared_buffer_data(
      SharedBufferVideoFrameDataPtr shared_buffer_data);
  
  bool is_gpu_memory_buffer_data() const { return tag_ == Tag::kGpuMemoryBufferData; }

  
  GpuMemoryBufferVideoFrameDataPtr& get_gpu_memory_buffer_data() const {
    CHECK(tag_ == Tag::kGpuMemoryBufferData);
    return *(data_.gpu_memory_buffer_data);
  }

  
  void set_gpu_memory_buffer_data(
      GpuMemoryBufferVideoFrameDataPtr gpu_memory_buffer_data);
  
  bool is_mailbox_data() const { return tag_ == Tag::kMailboxData; }

  
  MailboxVideoFrameDataPtr& get_mailbox_data() const {
    CHECK(tag_ == Tag::kMailboxData);
    return *(data_.mailbox_data);
  }

  
  void set_mailbox_data(
      MailboxVideoFrameDataPtr mailbox_data);

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        VideoFrameData::DataView>(input);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    return mojo::internal::DeserializeImpl<VideoFrameData::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

 private:
  union Union_ {
    Union_() = default;
    ~Union_() = default;
    EosVideoFrameDataPtr* eos_data;
    SharedBufferVideoFrameDataPtr* shared_buffer_data;
    GpuMemoryBufferVideoFrameDataPtr* gpu_memory_buffer_data;
    MailboxVideoFrameDataPtr* mailbox_data;
  };

  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);

  void DestroyActive();
  Tag tag_;
  Union_ data_;
};








class  AudioDecoderConfig {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<AudioDecoderConfig, T>::value>;
  using DataView = AudioDecoderConfigDataView;
  using Data_ = internal::AudioDecoderConfig_Data;

  template <typename... Args>
  static AudioDecoderConfigPtr New(Args&&... args) {
    return AudioDecoderConfigPtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static AudioDecoderConfigPtr From(const U& u) {
    return mojo::TypeConverter<AudioDecoderConfigPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, AudioDecoderConfig>::Convert(*this);
  }


  AudioDecoderConfig();

  AudioDecoderConfig(
      ::media::AudioCodec codec,
      ::media::SampleFormat sample_format,
      ::media::ChannelLayout channel_layout,
      int32_t samples_per_second,
      std::vector<uint8_t> extra_data,
      ::media::EncryptionScheme encryption_scheme,
      ::base::TimeDelta seek_preroll,
      int32_t codec_delay,
      ::media::AudioCodecProfile profile,
      ::media::ChannelLayout target_output_channel_layout,
      ::media::SampleFormat target_output_sample_format,
      bool should_discard_decoder_delay,
      std::vector<uint8_t> aac_extra_data);


  ~AudioDecoderConfig();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = AudioDecoderConfigPtr>
  AudioDecoderConfigPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, AudioDecoderConfig::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, AudioDecoderConfig::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        AudioDecoderConfig::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        AudioDecoderConfig::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::AudioDecoderConfig_UnserializedMessageContext<
            UserType, AudioDecoderConfig::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<AudioDecoderConfig::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return AudioDecoderConfig::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::AudioDecoderConfig_UnserializedMessageContext<
            UserType, AudioDecoderConfig::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<AudioDecoderConfig::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
  ::media::AudioCodec codec;
  
  ::media::SampleFormat sample_format;
  
  ::media::ChannelLayout channel_layout;
  
  int32_t samples_per_second;
  
  std::vector<uint8_t> extra_data;
  
  ::media::EncryptionScheme encryption_scheme;
  
  ::base::TimeDelta seek_preroll;
  
  int32_t codec_delay;
  
  ::media::AudioCodecProfile profile;
  
  ::media::ChannelLayout target_output_channel_layout;
  
  ::media::SampleFormat target_output_sample_format;
  
  bool should_discard_decoder_delay;
  
  std::vector<uint8_t> aac_extra_data;

  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, AudioDecoderConfig::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, AudioDecoderConfig::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, AudioDecoderConfig::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, AudioDecoderConfig::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





class  VideoDecoderConfig {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<VideoDecoderConfig, T>::value>;
  using DataView = VideoDecoderConfigDataView;
  using Data_ = internal::VideoDecoderConfig_Data;

  template <typename... Args>
  static VideoDecoderConfigPtr New(Args&&... args) {
    return VideoDecoderConfigPtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static VideoDecoderConfigPtr From(const U& u) {
    return mojo::TypeConverter<VideoDecoderConfigPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, VideoDecoderConfig>::Convert(*this);
  }


  VideoDecoderConfig();

  VideoDecoderConfig(
      ::media::VideoCodec codec,
      ::media::VideoCodecProfile profile,
      uint32_t level,
      bool has_alpha,
      const ::media::VideoTransformation& transformation,
      const ::gfx::Size& coded_size,
      const ::gfx::Rect& visible_rect,
      const ::gfx::Size& natural_size,
      std::vector<uint8_t> extra_data,
      ::media::EncryptionScheme encryption_scheme,
      VideoColorSpacePtr color_space_info,
      const absl::optional<::gfx::HDRMetadata>& hdr_metadata);

VideoDecoderConfig(const VideoDecoderConfig&) = delete;
VideoDecoderConfig& operator=(const VideoDecoderConfig&) = delete;

  ~VideoDecoderConfig();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = VideoDecoderConfigPtr>
  VideoDecoderConfigPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, VideoDecoderConfig::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, VideoDecoderConfig::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        VideoDecoderConfig::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        VideoDecoderConfig::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::VideoDecoderConfig_UnserializedMessageContext<
            UserType, VideoDecoderConfig::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<VideoDecoderConfig::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return VideoDecoderConfig::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::VideoDecoderConfig_UnserializedMessageContext<
            UserType, VideoDecoderConfig::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<VideoDecoderConfig::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
  ::media::VideoCodec codec;
  
  ::media::VideoCodecProfile profile;
  
  uint32_t level;
  
  bool has_alpha;
  
  ::media::VideoTransformation transformation;
  
  ::gfx::Size coded_size;
  
  ::gfx::Rect visible_rect;
  
  ::gfx::Size natural_size;
  
  std::vector<uint8_t> extra_data;
  
  ::media::EncryptionScheme encryption_scheme;
  
  VideoColorSpacePtr color_space_info;
  
  absl::optional<::gfx::HDRMetadata> hdr_metadata;

  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, VideoDecoderConfig::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, VideoDecoderConfig::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, VideoDecoderConfig::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, VideoDecoderConfig::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}






class  DecryptConfig {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<DecryptConfig, T>::value>;
  using DataView = DecryptConfigDataView;
  using Data_ = internal::DecryptConfig_Data;

  template <typename... Args>
  static DecryptConfigPtr New(Args&&... args) {
    return DecryptConfigPtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static DecryptConfigPtr From(const U& u) {
    return mojo::TypeConverter<DecryptConfigPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, DecryptConfig>::Convert(*this);
  }


  DecryptConfig();

  DecryptConfig(
      ::media::EncryptionScheme encryption_scheme,
      const std::string& key_id,
      const std::string& iv,
      std::vector<::media::SubsampleEntry> subsamples,
      const absl::optional<::media::EncryptionPattern>& encryption_pattern);


  ~DecryptConfig();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = DecryptConfigPtr>
  DecryptConfigPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, DecryptConfig::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, DecryptConfig::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        DecryptConfig::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        DecryptConfig::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::DecryptConfig_UnserializedMessageContext<
            UserType, DecryptConfig::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<DecryptConfig::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return DecryptConfig::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::DecryptConfig_UnserializedMessageContext<
            UserType, DecryptConfig::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<DecryptConfig::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
  ::media::EncryptionScheme encryption_scheme;
  
  std::string key_id;
  
  std::string iv;
  
  std::vector<::media::SubsampleEntry> subsamples;
  
  absl::optional<::media::EncryptionPattern> encryption_pattern;

  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, DecryptConfig::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, DecryptConfig::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, DecryptConfig::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, DecryptConfig::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





class  DecoderBuffer {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<DecoderBuffer, T>::value>;
  using DataView = DecoderBufferDataView;
  using Data_ = internal::DecoderBuffer_Data;

  template <typename... Args>
  static DecoderBufferPtr New(Args&&... args) {
    return DecoderBufferPtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static DecoderBufferPtr From(const U& u) {
    return mojo::TypeConverter<DecoderBufferPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, DecoderBuffer>::Convert(*this);
  }


  DecoderBuffer();

  DecoderBuffer(
      ::base::TimeDelta timestamp,
      ::base::TimeDelta duration,
      bool is_end_of_stream,
      uint32_t data_size,
      bool is_key_frame,
      std::vector<uint8_t> side_data,
      DecryptConfigPtr decrypt_config,
      ::base::TimeDelta front_discard,
      ::base::TimeDelta back_discard);

DecoderBuffer(const DecoderBuffer&) = delete;
DecoderBuffer& operator=(const DecoderBuffer&) = delete;

  ~DecoderBuffer();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = DecoderBufferPtr>
  DecoderBufferPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, DecoderBuffer::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, DecoderBuffer::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        DecoderBuffer::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        DecoderBuffer::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::DecoderBuffer_UnserializedMessageContext<
            UserType, DecoderBuffer::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<DecoderBuffer::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return DecoderBuffer::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::DecoderBuffer_UnserializedMessageContext<
            UserType, DecoderBuffer::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<DecoderBuffer::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
  ::base::TimeDelta timestamp;
  
  ::base::TimeDelta duration;
  
  bool is_end_of_stream;
  
  uint32_t data_size;
  
  bool is_key_frame;
  
  std::vector<uint8_t> side_data;
  
  DecryptConfigPtr decrypt_config;
  
  ::base::TimeDelta front_discard;
  
  ::base::TimeDelta back_discard;

  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, DecoderBuffer::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, DecoderBuffer::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, DecoderBuffer::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, DecoderBuffer::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





class  AudioBuffer {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<AudioBuffer, T>::value>;
  using DataView = AudioBufferDataView;
  using Data_ = internal::AudioBuffer_Data;

  template <typename... Args>
  static AudioBufferPtr New(Args&&... args) {
    return AudioBufferPtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static AudioBufferPtr From(const U& u) {
    return mojo::TypeConverter<AudioBufferPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, AudioBuffer>::Convert(*this);
  }


  AudioBuffer();

  AudioBuffer(
      ::media::SampleFormat sample_format,
      ::media::ChannelLayout channel_layout,
      int32_t channel_count,
      int32_t sample_rate,
      int32_t frame_count,
      bool end_of_stream,
      ::base::TimeDelta timestamp,
      std::vector<uint8_t> data);


  ~AudioBuffer();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = AudioBufferPtr>
  AudioBufferPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, AudioBuffer::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, AudioBuffer::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        AudioBuffer::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        AudioBuffer::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::AudioBuffer_UnserializedMessageContext<
            UserType, AudioBuffer::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<AudioBuffer::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return AudioBuffer::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::AudioBuffer_UnserializedMessageContext<
            UserType, AudioBuffer::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<AudioBuffer::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
  ::media::SampleFormat sample_format;
  
  ::media::ChannelLayout channel_layout;
  
  int32_t channel_count;
  
  int32_t sample_rate;
  
  int32_t frame_count;
  
  bool end_of_stream;
  
  ::base::TimeDelta timestamp;
  
  std::vector<uint8_t> data;

  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, AudioBuffer::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, AudioBuffer::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, AudioBuffer::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, AudioBuffer::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





class  VideoFrameMetadata {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<VideoFrameMetadata, T>::value>;
  using DataView = VideoFrameMetadataDataView;
  using Data_ = internal::VideoFrameMetadata_Data;

  template <typename... Args>
  static VideoFrameMetadataPtr New(Args&&... args) {
    return VideoFrameMetadataPtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static VideoFrameMetadataPtr From(const U& u) {
    return mojo::TypeConverter<VideoFrameMetadataPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, VideoFrameMetadata>::Convert(*this);
  }


  VideoFrameMetadata();

  VideoFrameMetadata(
      bool allow_overlay,
      absl::optional<::base::TimeTicks> capture_begin_time,
      absl::optional<::base::TimeTicks> capture_end_time,
      bool has_capture_counter,
      int32_t capture_counter,
      const absl::optional<::gfx::Rect>& capture_update_rect,
      const absl::optional<::gfx::Size>& source_size,
      const absl::optional<::gfx::Rect>& region_capture_rect,
      uint32_t crop_version,
      bool copy_required,
      bool end_of_stream,
      absl::optional<::base::TimeDelta> frame_duration,
      bool has_frame_rate,
      double frame_rate,
      bool interactive_content,
      absl::optional<::base::TimeTicks> reference_time,
      bool read_lock_fences_enabled,
      const absl::optional<::media::VideoTransformation>& transformation,
      bool texture_owner,
      bool wants_promotion_hint,
      bool protected_video,
      bool hw_protected,
      bool is_webgpu_compatible,
      const absl::optional<::base::UnguessableToken>& overlay_plane_id,
      bool power_efficient,
      bool texture_origin_is_top_left,
      bool has_device_scale_factor,
      double device_scale_factor,
      bool has_page_scale_factor,
      double page_scale_factor,
      bool has_root_scroll_offset_x,
      double root_scroll_offset_x,
      bool has_root_scroll_offset_y,
      double root_scroll_offset_y,
      bool has_top_controls_visible_height,
      double top_controls_visible_height,
      absl::optional<::base::TimeTicks> decode_begin_time,
      absl::optional<::base::TimeTicks> decode_end_time,
      absl::optional<::base::TimeDelta> processing_time,
      bool has_rtp_timestamp,
      double rtp_timestamp,
      absl::optional<::base::TimeTicks> receive_time,
      absl::optional<::base::TimeDelta> wallclock_frame_duration);


  ~VideoFrameMetadata();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = VideoFrameMetadataPtr>
  VideoFrameMetadataPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, VideoFrameMetadata::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, VideoFrameMetadata::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        VideoFrameMetadata::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        VideoFrameMetadata::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::VideoFrameMetadata_UnserializedMessageContext<
            UserType, VideoFrameMetadata::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<VideoFrameMetadata::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return VideoFrameMetadata::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::VideoFrameMetadata_UnserializedMessageContext<
            UserType, VideoFrameMetadata::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<VideoFrameMetadata::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
  bool allow_overlay;
  
  absl::optional<::base::TimeTicks> capture_begin_time;
  
  absl::optional<::base::TimeTicks> capture_end_time;
  
  bool has_capture_counter;
  
  int32_t capture_counter;
  
  absl::optional<::gfx::Rect> capture_update_rect;
  
  absl::optional<::gfx::Size> source_size;
  
  absl::optional<::gfx::Rect> region_capture_rect;
  
  uint32_t crop_version;
  
  bool copy_required;
  
  bool end_of_stream;
  
  absl::optional<::base::TimeDelta> frame_duration;
  
  bool has_frame_rate;
  
  double frame_rate;
  
  bool interactive_content;
  
  absl::optional<::base::TimeTicks> reference_time;
  
  bool read_lock_fences_enabled;
  
  absl::optional<::media::VideoTransformation> transformation;
  
  bool texture_owner;
  
  bool wants_promotion_hint;
  
  bool protected_video;
  
  bool hw_protected;
  
  bool is_webgpu_compatible;
  
  absl::optional<::base::UnguessableToken> overlay_plane_id;
  
  bool power_efficient;
  
  bool texture_origin_is_top_left;
  
  bool has_device_scale_factor;
  
  double device_scale_factor;
  
  bool has_page_scale_factor;
  
  double page_scale_factor;
  
  bool has_root_scroll_offset_x;
  
  double root_scroll_offset_x;
  
  bool has_root_scroll_offset_y;
  
  double root_scroll_offset_y;
  
  bool has_top_controls_visible_height;
  
  double top_controls_visible_height;
  
  absl::optional<::base::TimeTicks> decode_begin_time;
  
  absl::optional<::base::TimeTicks> decode_end_time;
  
  absl::optional<::base::TimeDelta> processing_time;
  
  bool has_rtp_timestamp;
  
  double rtp_timestamp;
  
  absl::optional<::base::TimeTicks> receive_time;
  
  absl::optional<::base::TimeDelta> wallclock_frame_duration;

  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, VideoFrameMetadata::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, VideoFrameMetadata::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, VideoFrameMetadata::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, VideoFrameMetadata::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





class  VideoFrame {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<VideoFrame, T>::value>;
  using DataView = VideoFrameDataView;
  using Data_ = internal::VideoFrame_Data;

  template <typename... Args>
  static VideoFramePtr New(Args&&... args) {
    return VideoFramePtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static VideoFramePtr From(const U& u) {
    return mojo::TypeConverter<VideoFramePtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, VideoFrame>::Convert(*this);
  }


  VideoFrame();

  VideoFrame(
      ::media::VideoPixelFormat format,
      const ::gfx::Size& coded_size,
      const ::gfx::Rect& visible_rect,
      const ::gfx::Size& natural_size,
      ::base::TimeDelta timestamp,
      VideoFrameDataPtr data,
      const ::media::VideoFrameMetadata& metadata,
      const ::gfx::ColorSpace& color_space,
      const absl::optional<::gfx::HDRMetadata>& hdr_metadata);

VideoFrame(const VideoFrame&) = delete;
VideoFrame& operator=(const VideoFrame&) = delete;

  ~VideoFrame();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = VideoFramePtr>
  VideoFramePtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, VideoFrame::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, VideoFrame::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        VideoFrame::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::VideoFrame_UnserializedMessageContext<
            UserType, VideoFrame::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<VideoFrame::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return VideoFrame::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::VideoFrame_UnserializedMessageContext<
            UserType, VideoFrame::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<VideoFrame::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
  ::media::VideoPixelFormat format;
  
  ::gfx::Size coded_size;
  
  ::gfx::Rect visible_rect;
  
  ::gfx::Size natural_size;
  
  ::base::TimeDelta timestamp;
  
  VideoFrameDataPtr data;
  
  ::media::VideoFrameMetadata metadata;
  
  ::gfx::ColorSpace color_space;
  
  absl::optional<::gfx::HDRMetadata> hdr_metadata;

  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, VideoFrame::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, VideoFrame::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, VideoFrame::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, VideoFrame::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}






class  SharedBufferVideoFrameData {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<SharedBufferVideoFrameData, T>::value>;
  using DataView = SharedBufferVideoFrameDataDataView;
  using Data_ = internal::SharedBufferVideoFrameData_Data;

  template <typename... Args>
  static SharedBufferVideoFrameDataPtr New(Args&&... args) {
    return SharedBufferVideoFrameDataPtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static SharedBufferVideoFrameDataPtr From(const U& u) {
    return mojo::TypeConverter<SharedBufferVideoFrameDataPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, SharedBufferVideoFrameData>::Convert(*this);
  }


  SharedBufferVideoFrameData();

  SharedBufferVideoFrameData(
      ::base::UnsafeSharedMemoryRegion frame_data,
      std::vector<int32_t> strides,
      std::vector<uint32_t> offsets);

SharedBufferVideoFrameData(const SharedBufferVideoFrameData&) = delete;
SharedBufferVideoFrameData& operator=(const SharedBufferVideoFrameData&) = delete;

  ~SharedBufferVideoFrameData();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = SharedBufferVideoFrameDataPtr>
  SharedBufferVideoFrameDataPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, SharedBufferVideoFrameData::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, SharedBufferVideoFrameData::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        SharedBufferVideoFrameData::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::SharedBufferVideoFrameData_UnserializedMessageContext<
            UserType, SharedBufferVideoFrameData::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<SharedBufferVideoFrameData::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return SharedBufferVideoFrameData::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::SharedBufferVideoFrameData_UnserializedMessageContext<
            UserType, SharedBufferVideoFrameData::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<SharedBufferVideoFrameData::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
  ::base::UnsafeSharedMemoryRegion frame_data;
  
  std::vector<int32_t> strides;
  
  std::vector<uint32_t> offsets;

  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, SharedBufferVideoFrameData::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, SharedBufferVideoFrameData::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, SharedBufferVideoFrameData::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, SharedBufferVideoFrameData::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





class  GpuMemoryBufferVideoFrameData {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<GpuMemoryBufferVideoFrameData, T>::value>;
  using DataView = GpuMemoryBufferVideoFrameDataDataView;
  using Data_ = internal::GpuMemoryBufferVideoFrameData_Data;

  template <typename... Args>
  static GpuMemoryBufferVideoFrameDataPtr New(Args&&... args) {
    return GpuMemoryBufferVideoFrameDataPtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static GpuMemoryBufferVideoFrameDataPtr From(const U& u) {
    return mojo::TypeConverter<GpuMemoryBufferVideoFrameDataPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, GpuMemoryBufferVideoFrameData>::Convert(*this);
  }


  GpuMemoryBufferVideoFrameData();

  GpuMemoryBufferVideoFrameData(
      ::gfx::GpuMemoryBufferHandle gpu_memory_buffer_handle,
      std::vector<::gpu::MailboxHolder> mailbox_holder);

GpuMemoryBufferVideoFrameData(const GpuMemoryBufferVideoFrameData&) = delete;
GpuMemoryBufferVideoFrameData& operator=(const GpuMemoryBufferVideoFrameData&) = delete;

  ~GpuMemoryBufferVideoFrameData();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = GpuMemoryBufferVideoFrameDataPtr>
  GpuMemoryBufferVideoFrameDataPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, GpuMemoryBufferVideoFrameData::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, GpuMemoryBufferVideoFrameData::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        GpuMemoryBufferVideoFrameData::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::GpuMemoryBufferVideoFrameData_UnserializedMessageContext<
            UserType, GpuMemoryBufferVideoFrameData::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<GpuMemoryBufferVideoFrameData::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return GpuMemoryBufferVideoFrameData::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::GpuMemoryBufferVideoFrameData_UnserializedMessageContext<
            UserType, GpuMemoryBufferVideoFrameData::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<GpuMemoryBufferVideoFrameData::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
  ::gfx::GpuMemoryBufferHandle gpu_memory_buffer_handle;
  
  std::vector<::gpu::MailboxHolder> mailbox_holder;

  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, GpuMemoryBufferVideoFrameData::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, GpuMemoryBufferVideoFrameData::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, GpuMemoryBufferVideoFrameData::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, GpuMemoryBufferVideoFrameData::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





class  MailboxVideoFrameData {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<MailboxVideoFrameData, T>::value>;
  using DataView = MailboxVideoFrameDataDataView;
  using Data_ = internal::MailboxVideoFrameData_Data;

  template <typename... Args>
  static MailboxVideoFrameDataPtr New(Args&&... args) {
    return MailboxVideoFrameDataPtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static MailboxVideoFrameDataPtr From(const U& u) {
    return mojo::TypeConverter<MailboxVideoFrameDataPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, MailboxVideoFrameData>::Convert(*this);
  }


  MailboxVideoFrameData();

  MailboxVideoFrameData(
      std::vector<::gpu::MailboxHolder> mailbox_holder,
      absl::optional<::gpu::VulkanYCbCrInfo> ycbcr_data);


  ~MailboxVideoFrameData();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = MailboxVideoFrameDataPtr>
  MailboxVideoFrameDataPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, MailboxVideoFrameData::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, MailboxVideoFrameData::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        MailboxVideoFrameData::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        MailboxVideoFrameData::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::MailboxVideoFrameData_UnserializedMessageContext<
            UserType, MailboxVideoFrameData::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<MailboxVideoFrameData::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return MailboxVideoFrameData::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::MailboxVideoFrameData_UnserializedMessageContext<
            UserType, MailboxVideoFrameData::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<MailboxVideoFrameData::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
  std::vector<::gpu::MailboxHolder> mailbox_holder;
  
  absl::optional<::gpu::VulkanYCbCrInfo> ycbcr_data;

  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, MailboxVideoFrameData::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, MailboxVideoFrameData::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, MailboxVideoFrameData::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, MailboxVideoFrameData::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





class  PipelineStatistics {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<PipelineStatistics, T>::value>;
  using DataView = PipelineStatisticsDataView;
  using Data_ = internal::PipelineStatistics_Data;

  template <typename... Args>
  static PipelineStatisticsPtr New(Args&&... args) {
    return PipelineStatisticsPtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static PipelineStatisticsPtr From(const U& u) {
    return mojo::TypeConverter<PipelineStatisticsPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, PipelineStatistics>::Convert(*this);
  }


  PipelineStatistics();

  PipelineStatistics(
      uint64_t audio_bytes_decoded,
      uint64_t video_bytes_decoded,
      uint32_t video_frames_decoded,
      uint32_t video_frames_dropped,
      int64_t audio_memory_usage,
      int64_t video_memory_usage);


  ~PipelineStatistics();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = PipelineStatisticsPtr>
  PipelineStatisticsPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, PipelineStatistics::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, PipelineStatistics::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        PipelineStatistics::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        PipelineStatistics::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::PipelineStatistics_UnserializedMessageContext<
            UserType, PipelineStatistics::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<PipelineStatistics::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return PipelineStatistics::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::PipelineStatistics_UnserializedMessageContext<
            UserType, PipelineStatistics::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<PipelineStatistics::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
  uint64_t audio_bytes_decoded;
  
  uint64_t video_bytes_decoded;
  
  uint32_t video_frames_decoded;
  
  uint32_t video_frames_dropped;
  
  int64_t audio_memory_usage;
  
  int64_t video_memory_usage;

  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, PipelineStatistics::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, PipelineStatistics::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, PipelineStatistics::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, PipelineStatistics::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





class  PredictionFeatures {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<PredictionFeatures, T>::value>;
  using DataView = PredictionFeaturesDataView;
  using Data_ = internal::PredictionFeatures_Data;

  template <typename... Args>
  static PredictionFeaturesPtr New(Args&&... args) {
    return PredictionFeaturesPtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static PredictionFeaturesPtr From(const U& u) {
    return mojo::TypeConverter<PredictionFeaturesPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, PredictionFeatures>::Convert(*this);
  }


  PredictionFeatures();

  PredictionFeatures(
      ::media::VideoCodecProfile profile,
      const ::gfx::Size& video_size,
      double frames_per_sec,
      const std::string& key_system,
      bool use_hw_secure_codecs);


  ~PredictionFeatures();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = PredictionFeaturesPtr>
  PredictionFeaturesPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, PredictionFeatures::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, PredictionFeatures::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        PredictionFeatures::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        PredictionFeatures::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::PredictionFeatures_UnserializedMessageContext<
            UserType, PredictionFeatures::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<PredictionFeatures::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return PredictionFeatures::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::PredictionFeatures_UnserializedMessageContext<
            UserType, PredictionFeatures::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<PredictionFeatures::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
  ::media::VideoCodecProfile profile;
  
  ::gfx::Size video_size;
  
  double frames_per_sec;
  
  std::string key_system;
  
  bool use_hw_secure_codecs;

  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, PredictionFeatures::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, PredictionFeatures::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, PredictionFeatures::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, PredictionFeatures::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}








class  StatusData {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<StatusData, T>::value>;
  using DataView = StatusDataDataView;
  using Data_ = internal::StatusData_Data;

  template <typename... Args>
  static StatusDataPtr New(Args&&... args) {
    return StatusDataPtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static StatusDataPtr From(const U& u) {
    return mojo::TypeConverter<StatusDataPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, StatusData>::Convert(*this);
  }


  StatusData();

  StatusData(
      const std::string& group,
      uint16_t code,
      const std::string& message,
      std::vector<::base::Value> frames,
      const absl::optional<::media::internal::StatusData>& cause,
      ::base::Value data,
      uint64_t packed_root_cause);

StatusData(const StatusData&) = delete;
StatusData& operator=(const StatusData&) = delete;

  ~StatusData();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = StatusDataPtr>
  StatusDataPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, StatusData::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, StatusData::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        StatusData::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        StatusData::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::StatusData_UnserializedMessageContext<
            UserType, StatusData::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<StatusData::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return StatusData::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::StatusData_UnserializedMessageContext<
            UserType, StatusData::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<StatusData::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
  std::string group;
  
  uint16_t code;
  
  std::string message;
  
  std::vector<::base::Value> frames;
  
  absl::optional<::media::internal::StatusData> cause;
  
  ::base::Value data;
  
  uint64_t packed_root_cause;

  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, StatusData::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, StatusData::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, StatusData::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, StatusData::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





class  EncoderStatus {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<EncoderStatus, T>::value>;
  using DataView = EncoderStatusDataView;
  using Data_ = internal::EncoderStatus_Data;

  template <typename... Args>
  static EncoderStatusPtr New(Args&&... args) {
    return EncoderStatusPtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static EncoderStatusPtr From(const U& u) {
    return mojo::TypeConverter<EncoderStatusPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, EncoderStatus>::Convert(*this);
  }


  EncoderStatus();

  explicit EncoderStatus(
      const absl::optional<::media::internal::StatusData>& internal);


  ~EncoderStatus();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = EncoderStatusPtr>
  EncoderStatusPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, EncoderStatus::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, EncoderStatus::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        EncoderStatus::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        EncoderStatus::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::EncoderStatus_UnserializedMessageContext<
            UserType, EncoderStatus::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<EncoderStatus::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return EncoderStatus::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::EncoderStatus_UnserializedMessageContext<
            UserType, EncoderStatus::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<EncoderStatus::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
  absl::optional<::media::internal::StatusData> internal;

  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, EncoderStatus::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, EncoderStatus::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, EncoderStatus::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, EncoderStatus::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





class  DecoderStatus {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<DecoderStatus, T>::value>;
  using DataView = DecoderStatusDataView;
  using Data_ = internal::DecoderStatus_Data;

  template <typename... Args>
  static DecoderStatusPtr New(Args&&... args) {
    return DecoderStatusPtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static DecoderStatusPtr From(const U& u) {
    return mojo::TypeConverter<DecoderStatusPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, DecoderStatus>::Convert(*this);
  }


  DecoderStatus();

  explicit DecoderStatus(
      const absl::optional<::media::internal::StatusData>& internal);


  ~DecoderStatus();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = DecoderStatusPtr>
  DecoderStatusPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, DecoderStatus::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, DecoderStatus::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        DecoderStatus::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        DecoderStatus::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::DecoderStatus_UnserializedMessageContext<
            UserType, DecoderStatus::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<DecoderStatus::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return DecoderStatus::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::DecoderStatus_UnserializedMessageContext<
            UserType, DecoderStatus::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<DecoderStatus::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
  absl::optional<::media::internal::StatusData> internal;

  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, DecoderStatus::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, DecoderStatus::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, DecoderStatus::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, DecoderStatus::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





class  PipelineStatus {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<PipelineStatus, T>::value>;
  using DataView = PipelineStatusDataView;
  using Data_ = internal::PipelineStatus_Data;

  template <typename... Args>
  static PipelineStatusPtr New(Args&&... args) {
    return PipelineStatusPtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static PipelineStatusPtr From(const U& u) {
    return mojo::TypeConverter<PipelineStatusPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, PipelineStatus>::Convert(*this);
  }


  PipelineStatus();

  explicit PipelineStatus(
      const absl::optional<::media::internal::StatusData>& internal);


  ~PipelineStatus();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = PipelineStatusPtr>
  PipelineStatusPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, PipelineStatus::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, PipelineStatus::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        PipelineStatus::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        PipelineStatus::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::PipelineStatus_UnserializedMessageContext<
            UserType, PipelineStatus::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<PipelineStatus::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return PipelineStatus::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::PipelineStatus_UnserializedMessageContext<
            UserType, PipelineStatus::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<PipelineStatus::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
  absl::optional<::media::internal::StatusData> internal;

  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, PipelineStatus::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, PipelineStatus::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, PipelineStatus::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, PipelineStatus::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}

template <typename UnionPtrType>
VideoFrameDataPtr VideoFrameData::Clone() const {
  switch (tag_) {
    case Tag::kEosData:
      return NewEosData(
          mojo::Clone(*data_.eos_data));
    case Tag::kSharedBufferData:
      return NewSharedBufferData(
          mojo::Clone(*data_.shared_buffer_data));
    case Tag::kGpuMemoryBufferData:
      return NewGpuMemoryBufferData(
          mojo::Clone(*data_.gpu_memory_buffer_data));
    case Tag::kMailboxData:
      return NewMailboxData(
          mojo::Clone(*data_.mailbox_data));
  }
  return nullptr;
}

template <typename T,
          typename std::enable_if<std::is_same<
              T, VideoFrameData>::value>::type*>
bool VideoFrameData::Equals(const T& other) const {
  if (tag_ != other.which())
    return false;

  switch (tag_) {
    case Tag::kEosData:
      return mojo::Equals(*(data_.eos_data), *(other.data_.eos_data));
    case Tag::kSharedBufferData:
      return mojo::Equals(*(data_.shared_buffer_data), *(other.data_.shared_buffer_data));
    case Tag::kGpuMemoryBufferData:
      return mojo::Equals(*(data_.gpu_memory_buffer_data), *(other.data_.gpu_memory_buffer_data));
    case Tag::kMailboxData:
      return mojo::Equals(*(data_.mailbox_data), *(other.data_.mailbox_data));
  }

  return false;
}
template <typename StructPtrType>
VideoTransformationPtr VideoTransformation::Clone() const {
  return New(
      mojo::Clone(rotation),
      mojo::Clone(mirrored)
  );
}

template <typename T, VideoTransformation::EnableIfSame<T>*>
bool VideoTransformation::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->rotation, other_struct.rotation))
    return false;
  if (!mojo::Equals(this->mirrored, other_struct.mirrored))
    return false;
  return true;
}

template <typename T, VideoTransformation::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.rotation < rhs.rotation)
    return true;
  if (rhs.rotation < lhs.rotation)
    return false;
  if (lhs.mirrored < rhs.mirrored)
    return true;
  if (rhs.mirrored < lhs.mirrored)
    return false;
  return false;
}
template <typename StructPtrType>
VideoColorSpacePtr VideoColorSpace::Clone() const {
  return New(
      mojo::Clone(primaries),
      mojo::Clone(transfer),
      mojo::Clone(matrix),
      mojo::Clone(range)
  );
}

template <typename T, VideoColorSpace::EnableIfSame<T>*>
bool VideoColorSpace::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->primaries, other_struct.primaries))
    return false;
  if (!mojo::Equals(this->transfer, other_struct.transfer))
    return false;
  if (!mojo::Equals(this->matrix, other_struct.matrix))
    return false;
  if (!mojo::Equals(this->range, other_struct.range))
    return false;
  return true;
}

template <typename T, VideoColorSpace::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.primaries < rhs.primaries)
    return true;
  if (rhs.primaries < lhs.primaries)
    return false;
  if (lhs.transfer < rhs.transfer)
    return true;
  if (rhs.transfer < lhs.transfer)
    return false;
  if (lhs.matrix < rhs.matrix)
    return true;
  if (rhs.matrix < lhs.matrix)
    return false;
  if (lhs.range < rhs.range)
    return true;
  if (rhs.range < lhs.range)
    return false;
  return false;
}
template <typename StructPtrType>
AudioDecoderConfigPtr AudioDecoderConfig::Clone() const {
  return New(
      mojo::Clone(codec),
      mojo::Clone(sample_format),
      mojo::Clone(channel_layout),
      mojo::Clone(samples_per_second),
      mojo::Clone(extra_data),
      mojo::Clone(encryption_scheme),
      mojo::Clone(seek_preroll),
      mojo::Clone(codec_delay),
      mojo::Clone(profile),
      mojo::Clone(target_output_channel_layout),
      mojo::Clone(target_output_sample_format),
      mojo::Clone(should_discard_decoder_delay),
      mojo::Clone(aac_extra_data)
  );
}

template <typename T, AudioDecoderConfig::EnableIfSame<T>*>
bool AudioDecoderConfig::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->codec, other_struct.codec))
    return false;
  if (!mojo::Equals(this->sample_format, other_struct.sample_format))
    return false;
  if (!mojo::Equals(this->channel_layout, other_struct.channel_layout))
    return false;
  if (!mojo::Equals(this->samples_per_second, other_struct.samples_per_second))
    return false;
  if (!mojo::Equals(this->extra_data, other_struct.extra_data))
    return false;
  if (!mojo::Equals(this->encryption_scheme, other_struct.encryption_scheme))
    return false;
  if (!mojo::Equals(this->seek_preroll, other_struct.seek_preroll))
    return false;
  if (!mojo::Equals(this->codec_delay, other_struct.codec_delay))
    return false;
  if (!mojo::Equals(this->profile, other_struct.profile))
    return false;
  if (!mojo::Equals(this->target_output_channel_layout, other_struct.target_output_channel_layout))
    return false;
  if (!mojo::Equals(this->target_output_sample_format, other_struct.target_output_sample_format))
    return false;
  if (!mojo::Equals(this->should_discard_decoder_delay, other_struct.should_discard_decoder_delay))
    return false;
  if (!mojo::Equals(this->aac_extra_data, other_struct.aac_extra_data))
    return false;
  return true;
}

template <typename T, AudioDecoderConfig::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.codec < rhs.codec)
    return true;
  if (rhs.codec < lhs.codec)
    return false;
  if (lhs.sample_format < rhs.sample_format)
    return true;
  if (rhs.sample_format < lhs.sample_format)
    return false;
  if (lhs.channel_layout < rhs.channel_layout)
    return true;
  if (rhs.channel_layout < lhs.channel_layout)
    return false;
  if (lhs.samples_per_second < rhs.samples_per_second)
    return true;
  if (rhs.samples_per_second < lhs.samples_per_second)
    return false;
  if (lhs.extra_data < rhs.extra_data)
    return true;
  if (rhs.extra_data < lhs.extra_data)
    return false;
  if (lhs.encryption_scheme < rhs.encryption_scheme)
    return true;
  if (rhs.encryption_scheme < lhs.encryption_scheme)
    return false;
  if (lhs.seek_preroll < rhs.seek_preroll)
    return true;
  if (rhs.seek_preroll < lhs.seek_preroll)
    return false;
  if (lhs.codec_delay < rhs.codec_delay)
    return true;
  if (rhs.codec_delay < lhs.codec_delay)
    return false;
  if (lhs.profile < rhs.profile)
    return true;
  if (rhs.profile < lhs.profile)
    return false;
  if (lhs.target_output_channel_layout < rhs.target_output_channel_layout)
    return true;
  if (rhs.target_output_channel_layout < lhs.target_output_channel_layout)
    return false;
  if (lhs.target_output_sample_format < rhs.target_output_sample_format)
    return true;
  if (rhs.target_output_sample_format < lhs.target_output_sample_format)
    return false;
  if (lhs.should_discard_decoder_delay < rhs.should_discard_decoder_delay)
    return true;
  if (rhs.should_discard_decoder_delay < lhs.should_discard_decoder_delay)
    return false;
  if (lhs.aac_extra_data < rhs.aac_extra_data)
    return true;
  if (rhs.aac_extra_data < lhs.aac_extra_data)
    return false;
  return false;
}
template <typename StructPtrType>
VideoDecoderConfigPtr VideoDecoderConfig::Clone() const {
  return New(
      mojo::Clone(codec),
      mojo::Clone(profile),
      mojo::Clone(level),
      mojo::Clone(has_alpha),
      mojo::Clone(transformation),
      mojo::Clone(coded_size),
      mojo::Clone(visible_rect),
      mojo::Clone(natural_size),
      mojo::Clone(extra_data),
      mojo::Clone(encryption_scheme),
      mojo::Clone(color_space_info),
      mojo::Clone(hdr_metadata)
  );
}

template <typename T, VideoDecoderConfig::EnableIfSame<T>*>
bool VideoDecoderConfig::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->codec, other_struct.codec))
    return false;
  if (!mojo::Equals(this->profile, other_struct.profile))
    return false;
  if (!mojo::Equals(this->level, other_struct.level))
    return false;
  if (!mojo::Equals(this->has_alpha, other_struct.has_alpha))
    return false;
  if (!mojo::Equals(this->transformation, other_struct.transformation))
    return false;
  if (!mojo::Equals(this->coded_size, other_struct.coded_size))
    return false;
  if (!mojo::Equals(this->visible_rect, other_struct.visible_rect))
    return false;
  if (!mojo::Equals(this->natural_size, other_struct.natural_size))
    return false;
  if (!mojo::Equals(this->extra_data, other_struct.extra_data))
    return false;
  if (!mojo::Equals(this->encryption_scheme, other_struct.encryption_scheme))
    return false;
  if (!mojo::Equals(this->color_space_info, other_struct.color_space_info))
    return false;
  if (!mojo::Equals(this->hdr_metadata, other_struct.hdr_metadata))
    return false;
  return true;
}

template <typename T, VideoDecoderConfig::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.codec < rhs.codec)
    return true;
  if (rhs.codec < lhs.codec)
    return false;
  if (lhs.profile < rhs.profile)
    return true;
  if (rhs.profile < lhs.profile)
    return false;
  if (lhs.level < rhs.level)
    return true;
  if (rhs.level < lhs.level)
    return false;
  if (lhs.has_alpha < rhs.has_alpha)
    return true;
  if (rhs.has_alpha < lhs.has_alpha)
    return false;
  if (lhs.transformation < rhs.transformation)
    return true;
  if (rhs.transformation < lhs.transformation)
    return false;
  if (lhs.coded_size < rhs.coded_size)
    return true;
  if (rhs.coded_size < lhs.coded_size)
    return false;
  if (lhs.visible_rect < rhs.visible_rect)
    return true;
  if (rhs.visible_rect < lhs.visible_rect)
    return false;
  if (lhs.natural_size < rhs.natural_size)
    return true;
  if (rhs.natural_size < lhs.natural_size)
    return false;
  if (lhs.extra_data < rhs.extra_data)
    return true;
  if (rhs.extra_data < lhs.extra_data)
    return false;
  if (lhs.encryption_scheme < rhs.encryption_scheme)
    return true;
  if (rhs.encryption_scheme < lhs.encryption_scheme)
    return false;
  if (lhs.color_space_info < rhs.color_space_info)
    return true;
  if (rhs.color_space_info < lhs.color_space_info)
    return false;
  if (lhs.hdr_metadata < rhs.hdr_metadata)
    return true;
  if (rhs.hdr_metadata < lhs.hdr_metadata)
    return false;
  return false;
}
template <typename StructPtrType>
DecryptConfigPtr DecryptConfig::Clone() const {
  return New(
      mojo::Clone(encryption_scheme),
      mojo::Clone(key_id),
      mojo::Clone(iv),
      mojo::Clone(subsamples),
      mojo::Clone(encryption_pattern)
  );
}

template <typename T, DecryptConfig::EnableIfSame<T>*>
bool DecryptConfig::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->encryption_scheme, other_struct.encryption_scheme))
    return false;
  if (!mojo::Equals(this->key_id, other_struct.key_id))
    return false;
  if (!mojo::Equals(this->iv, other_struct.iv))
    return false;
  if (!mojo::Equals(this->subsamples, other_struct.subsamples))
    return false;
  if (!mojo::Equals(this->encryption_pattern, other_struct.encryption_pattern))
    return false;
  return true;
}

template <typename T, DecryptConfig::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.encryption_scheme < rhs.encryption_scheme)
    return true;
  if (rhs.encryption_scheme < lhs.encryption_scheme)
    return false;
  if (lhs.key_id < rhs.key_id)
    return true;
  if (rhs.key_id < lhs.key_id)
    return false;
  if (lhs.iv < rhs.iv)
    return true;
  if (rhs.iv < lhs.iv)
    return false;
  if (lhs.subsamples < rhs.subsamples)
    return true;
  if (rhs.subsamples < lhs.subsamples)
    return false;
  if (lhs.encryption_pattern < rhs.encryption_pattern)
    return true;
  if (rhs.encryption_pattern < lhs.encryption_pattern)
    return false;
  return false;
}
template <typename StructPtrType>
DecoderBufferPtr DecoderBuffer::Clone() const {
  return New(
      mojo::Clone(timestamp),
      mojo::Clone(duration),
      mojo::Clone(is_end_of_stream),
      mojo::Clone(data_size),
      mojo::Clone(is_key_frame),
      mojo::Clone(side_data),
      mojo::Clone(decrypt_config),
      mojo::Clone(front_discard),
      mojo::Clone(back_discard)
  );
}

template <typename T, DecoderBuffer::EnableIfSame<T>*>
bool DecoderBuffer::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->timestamp, other_struct.timestamp))
    return false;
  if (!mojo::Equals(this->duration, other_struct.duration))
    return false;
  if (!mojo::Equals(this->is_end_of_stream, other_struct.is_end_of_stream))
    return false;
  if (!mojo::Equals(this->data_size, other_struct.data_size))
    return false;
  if (!mojo::Equals(this->is_key_frame, other_struct.is_key_frame))
    return false;
  if (!mojo::Equals(this->side_data, other_struct.side_data))
    return false;
  if (!mojo::Equals(this->decrypt_config, other_struct.decrypt_config))
    return false;
  if (!mojo::Equals(this->front_discard, other_struct.front_discard))
    return false;
  if (!mojo::Equals(this->back_discard, other_struct.back_discard))
    return false;
  return true;
}

template <typename T, DecoderBuffer::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.timestamp < rhs.timestamp)
    return true;
  if (rhs.timestamp < lhs.timestamp)
    return false;
  if (lhs.duration < rhs.duration)
    return true;
  if (rhs.duration < lhs.duration)
    return false;
  if (lhs.is_end_of_stream < rhs.is_end_of_stream)
    return true;
  if (rhs.is_end_of_stream < lhs.is_end_of_stream)
    return false;
  if (lhs.data_size < rhs.data_size)
    return true;
  if (rhs.data_size < lhs.data_size)
    return false;
  if (lhs.is_key_frame < rhs.is_key_frame)
    return true;
  if (rhs.is_key_frame < lhs.is_key_frame)
    return false;
  if (lhs.side_data < rhs.side_data)
    return true;
  if (rhs.side_data < lhs.side_data)
    return false;
  if (lhs.decrypt_config < rhs.decrypt_config)
    return true;
  if (rhs.decrypt_config < lhs.decrypt_config)
    return false;
  if (lhs.front_discard < rhs.front_discard)
    return true;
  if (rhs.front_discard < lhs.front_discard)
    return false;
  if (lhs.back_discard < rhs.back_discard)
    return true;
  if (rhs.back_discard < lhs.back_discard)
    return false;
  return false;
}
template <typename StructPtrType>
AudioBufferPtr AudioBuffer::Clone() const {
  return New(
      mojo::Clone(sample_format),
      mojo::Clone(channel_layout),
      mojo::Clone(channel_count),
      mojo::Clone(sample_rate),
      mojo::Clone(frame_count),
      mojo::Clone(end_of_stream),
      mojo::Clone(timestamp),
      mojo::Clone(data)
  );
}

template <typename T, AudioBuffer::EnableIfSame<T>*>
bool AudioBuffer::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->sample_format, other_struct.sample_format))
    return false;
  if (!mojo::Equals(this->channel_layout, other_struct.channel_layout))
    return false;
  if (!mojo::Equals(this->channel_count, other_struct.channel_count))
    return false;
  if (!mojo::Equals(this->sample_rate, other_struct.sample_rate))
    return false;
  if (!mojo::Equals(this->frame_count, other_struct.frame_count))
    return false;
  if (!mojo::Equals(this->end_of_stream, other_struct.end_of_stream))
    return false;
  if (!mojo::Equals(this->timestamp, other_struct.timestamp))
    return false;
  if (!mojo::Equals(this->data, other_struct.data))
    return false;
  return true;
}

template <typename T, AudioBuffer::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.sample_format < rhs.sample_format)
    return true;
  if (rhs.sample_format < lhs.sample_format)
    return false;
  if (lhs.channel_layout < rhs.channel_layout)
    return true;
  if (rhs.channel_layout < lhs.channel_layout)
    return false;
  if (lhs.channel_count < rhs.channel_count)
    return true;
  if (rhs.channel_count < lhs.channel_count)
    return false;
  if (lhs.sample_rate < rhs.sample_rate)
    return true;
  if (rhs.sample_rate < lhs.sample_rate)
    return false;
  if (lhs.frame_count < rhs.frame_count)
    return true;
  if (rhs.frame_count < lhs.frame_count)
    return false;
  if (lhs.end_of_stream < rhs.end_of_stream)
    return true;
  if (rhs.end_of_stream < lhs.end_of_stream)
    return false;
  if (lhs.timestamp < rhs.timestamp)
    return true;
  if (rhs.timestamp < lhs.timestamp)
    return false;
  if (lhs.data < rhs.data)
    return true;
  if (rhs.data < lhs.data)
    return false;
  return false;
}
template <typename StructPtrType>
VideoFrameMetadataPtr VideoFrameMetadata::Clone() const {
  return New(
      mojo::Clone(allow_overlay),
      mojo::Clone(capture_begin_time),
      mojo::Clone(capture_end_time),
      mojo::Clone(has_capture_counter),
      mojo::Clone(capture_counter),
      mojo::Clone(capture_update_rect),
      mojo::Clone(source_size),
      mojo::Clone(region_capture_rect),
      mojo::Clone(crop_version),
      mojo::Clone(copy_required),
      mojo::Clone(end_of_stream),
      mojo::Clone(frame_duration),
      mojo::Clone(has_frame_rate),
      mojo::Clone(frame_rate),
      mojo::Clone(interactive_content),
      mojo::Clone(reference_time),
      mojo::Clone(read_lock_fences_enabled),
      mojo::Clone(transformation),
      mojo::Clone(texture_owner),
      mojo::Clone(wants_promotion_hint),
      mojo::Clone(protected_video),
      mojo::Clone(hw_protected),
      mojo::Clone(is_webgpu_compatible),
      mojo::Clone(overlay_plane_id),
      mojo::Clone(power_efficient),
      mojo::Clone(texture_origin_is_top_left),
      mojo::Clone(has_device_scale_factor),
      mojo::Clone(device_scale_factor),
      mojo::Clone(has_page_scale_factor),
      mojo::Clone(page_scale_factor),
      mojo::Clone(has_root_scroll_offset_x),
      mojo::Clone(root_scroll_offset_x),
      mojo::Clone(has_root_scroll_offset_y),
      mojo::Clone(root_scroll_offset_y),
      mojo::Clone(has_top_controls_visible_height),
      mojo::Clone(top_controls_visible_height),
      mojo::Clone(decode_begin_time),
      mojo::Clone(decode_end_time),
      mojo::Clone(processing_time),
      mojo::Clone(has_rtp_timestamp),
      mojo::Clone(rtp_timestamp),
      mojo::Clone(receive_time),
      mojo::Clone(wallclock_frame_duration)
  );
}

template <typename T, VideoFrameMetadata::EnableIfSame<T>*>
bool VideoFrameMetadata::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->allow_overlay, other_struct.allow_overlay))
    return false;
  if (!mojo::Equals(this->capture_begin_time, other_struct.capture_begin_time))
    return false;
  if (!mojo::Equals(this->capture_end_time, other_struct.capture_end_time))
    return false;
  if (!mojo::Equals(this->has_capture_counter, other_struct.has_capture_counter))
    return false;
  if (!mojo::Equals(this->capture_counter, other_struct.capture_counter))
    return false;
  if (!mojo::Equals(this->capture_update_rect, other_struct.capture_update_rect))
    return false;
  if (!mojo::Equals(this->source_size, other_struct.source_size))
    return false;
  if (!mojo::Equals(this->region_capture_rect, other_struct.region_capture_rect))
    return false;
  if (!mojo::Equals(this->crop_version, other_struct.crop_version))
    return false;
  if (!mojo::Equals(this->copy_required, other_struct.copy_required))
    return false;
  if (!mojo::Equals(this->end_of_stream, other_struct.end_of_stream))
    return false;
  if (!mojo::Equals(this->frame_duration, other_struct.frame_duration))
    return false;
  if (!mojo::Equals(this->has_frame_rate, other_struct.has_frame_rate))
    return false;
  if (!mojo::Equals(this->frame_rate, other_struct.frame_rate))
    return false;
  if (!mojo::Equals(this->interactive_content, other_struct.interactive_content))
    return false;
  if (!mojo::Equals(this->reference_time, other_struct.reference_time))
    return false;
  if (!mojo::Equals(this->read_lock_fences_enabled, other_struct.read_lock_fences_enabled))
    return false;
  if (!mojo::Equals(this->transformation, other_struct.transformation))
    return false;
  if (!mojo::Equals(this->texture_owner, other_struct.texture_owner))
    return false;
  if (!mojo::Equals(this->wants_promotion_hint, other_struct.wants_promotion_hint))
    return false;
  if (!mojo::Equals(this->protected_video, other_struct.protected_video))
    return false;
  if (!mojo::Equals(this->hw_protected, other_struct.hw_protected))
    return false;
  if (!mojo::Equals(this->is_webgpu_compatible, other_struct.is_webgpu_compatible))
    return false;
  if (!mojo::Equals(this->overlay_plane_id, other_struct.overlay_plane_id))
    return false;
  if (!mojo::Equals(this->power_efficient, other_struct.power_efficient))
    return false;
  if (!mojo::Equals(this->texture_origin_is_top_left, other_struct.texture_origin_is_top_left))
    return false;
  if (!mojo::Equals(this->has_device_scale_factor, other_struct.has_device_scale_factor))
    return false;
  if (!mojo::Equals(this->device_scale_factor, other_struct.device_scale_factor))
    return false;
  if (!mojo::Equals(this->has_page_scale_factor, other_struct.has_page_scale_factor))
    return false;
  if (!mojo::Equals(this->page_scale_factor, other_struct.page_scale_factor))
    return false;
  if (!mojo::Equals(this->has_root_scroll_offset_x, other_struct.has_root_scroll_offset_x))
    return false;
  if (!mojo::Equals(this->root_scroll_offset_x, other_struct.root_scroll_offset_x))
    return false;
  if (!mojo::Equals(this->has_root_scroll_offset_y, other_struct.has_root_scroll_offset_y))
    return false;
  if (!mojo::Equals(this->root_scroll_offset_y, other_struct.root_scroll_offset_y))
    return false;
  if (!mojo::Equals(this->has_top_controls_visible_height, other_struct.has_top_controls_visible_height))
    return false;
  if (!mojo::Equals(this->top_controls_visible_height, other_struct.top_controls_visible_height))
    return false;
  if (!mojo::Equals(this->decode_begin_time, other_struct.decode_begin_time))
    return false;
  if (!mojo::Equals(this->decode_end_time, other_struct.decode_end_time))
    return false;
  if (!mojo::Equals(this->processing_time, other_struct.processing_time))
    return false;
  if (!mojo::Equals(this->has_rtp_timestamp, other_struct.has_rtp_timestamp))
    return false;
  if (!mojo::Equals(this->rtp_timestamp, other_struct.rtp_timestamp))
    return false;
  if (!mojo::Equals(this->receive_time, other_struct.receive_time))
    return false;
  if (!mojo::Equals(this->wallclock_frame_duration, other_struct.wallclock_frame_duration))
    return false;
  return true;
}

template <typename T, VideoFrameMetadata::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.allow_overlay < rhs.allow_overlay)
    return true;
  if (rhs.allow_overlay < lhs.allow_overlay)
    return false;
  if (lhs.capture_begin_time < rhs.capture_begin_time)
    return true;
  if (rhs.capture_begin_time < lhs.capture_begin_time)
    return false;
  if (lhs.capture_end_time < rhs.capture_end_time)
    return true;
  if (rhs.capture_end_time < lhs.capture_end_time)
    return false;
  if (lhs.has_capture_counter < rhs.has_capture_counter)
    return true;
  if (rhs.has_capture_counter < lhs.has_capture_counter)
    return false;
  if (lhs.capture_counter < rhs.capture_counter)
    return true;
  if (rhs.capture_counter < lhs.capture_counter)
    return false;
  if (lhs.capture_update_rect < rhs.capture_update_rect)
    return true;
  if (rhs.capture_update_rect < lhs.capture_update_rect)
    return false;
  if (lhs.source_size < rhs.source_size)
    return true;
  if (rhs.source_size < lhs.source_size)
    return false;
  if (lhs.region_capture_rect < rhs.region_capture_rect)
    return true;
  if (rhs.region_capture_rect < lhs.region_capture_rect)
    return false;
  if (lhs.crop_version < rhs.crop_version)
    return true;
  if (rhs.crop_version < lhs.crop_version)
    return false;
  if (lhs.copy_required < rhs.copy_required)
    return true;
  if (rhs.copy_required < lhs.copy_required)
    return false;
  if (lhs.end_of_stream < rhs.end_of_stream)
    return true;
  if (rhs.end_of_stream < lhs.end_of_stream)
    return false;
  if (lhs.frame_duration < rhs.frame_duration)
    return true;
  if (rhs.frame_duration < lhs.frame_duration)
    return false;
  if (lhs.has_frame_rate < rhs.has_frame_rate)
    return true;
  if (rhs.has_frame_rate < lhs.has_frame_rate)
    return false;
  if (lhs.frame_rate < rhs.frame_rate)
    return true;
  if (rhs.frame_rate < lhs.frame_rate)
    return false;
  if (lhs.interactive_content < rhs.interactive_content)
    return true;
  if (rhs.interactive_content < lhs.interactive_content)
    return false;
  if (lhs.reference_time < rhs.reference_time)
    return true;
  if (rhs.reference_time < lhs.reference_time)
    return false;
  if (lhs.read_lock_fences_enabled < rhs.read_lock_fences_enabled)
    return true;
  if (rhs.read_lock_fences_enabled < lhs.read_lock_fences_enabled)
    return false;
  if (lhs.transformation < rhs.transformation)
    return true;
  if (rhs.transformation < lhs.transformation)
    return false;
  if (lhs.texture_owner < rhs.texture_owner)
    return true;
  if (rhs.texture_owner < lhs.texture_owner)
    return false;
  if (lhs.wants_promotion_hint < rhs.wants_promotion_hint)
    return true;
  if (rhs.wants_promotion_hint < lhs.wants_promotion_hint)
    return false;
  if (lhs.protected_video < rhs.protected_video)
    return true;
  if (rhs.protected_video < lhs.protected_video)
    return false;
  if (lhs.hw_protected < rhs.hw_protected)
    return true;
  if (rhs.hw_protected < lhs.hw_protected)
    return false;
  if (lhs.is_webgpu_compatible < rhs.is_webgpu_compatible)
    return true;
  if (rhs.is_webgpu_compatible < lhs.is_webgpu_compatible)
    return false;
  if (lhs.overlay_plane_id < rhs.overlay_plane_id)
    return true;
  if (rhs.overlay_plane_id < lhs.overlay_plane_id)
    return false;
  if (lhs.power_efficient < rhs.power_efficient)
    return true;
  if (rhs.power_efficient < lhs.power_efficient)
    return false;
  if (lhs.texture_origin_is_top_left < rhs.texture_origin_is_top_left)
    return true;
  if (rhs.texture_origin_is_top_left < lhs.texture_origin_is_top_left)
    return false;
  if (lhs.has_device_scale_factor < rhs.has_device_scale_factor)
    return true;
  if (rhs.has_device_scale_factor < lhs.has_device_scale_factor)
    return false;
  if (lhs.device_scale_factor < rhs.device_scale_factor)
    return true;
  if (rhs.device_scale_factor < lhs.device_scale_factor)
    return false;
  if (lhs.has_page_scale_factor < rhs.has_page_scale_factor)
    return true;
  if (rhs.has_page_scale_factor < lhs.has_page_scale_factor)
    return false;
  if (lhs.page_scale_factor < rhs.page_scale_factor)
    return true;
  if (rhs.page_scale_factor < lhs.page_scale_factor)
    return false;
  if (lhs.has_root_scroll_offset_x < rhs.has_root_scroll_offset_x)
    return true;
  if (rhs.has_root_scroll_offset_x < lhs.has_root_scroll_offset_x)
    return false;
  if (lhs.root_scroll_offset_x < rhs.root_scroll_offset_x)
    return true;
  if (rhs.root_scroll_offset_x < lhs.root_scroll_offset_x)
    return false;
  if (lhs.has_root_scroll_offset_y < rhs.has_root_scroll_offset_y)
    return true;
  if (rhs.has_root_scroll_offset_y < lhs.has_root_scroll_offset_y)
    return false;
  if (lhs.root_scroll_offset_y < rhs.root_scroll_offset_y)
    return true;
  if (rhs.root_scroll_offset_y < lhs.root_scroll_offset_y)
    return false;
  if (lhs.has_top_controls_visible_height < rhs.has_top_controls_visible_height)
    return true;
  if (rhs.has_top_controls_visible_height < lhs.has_top_controls_visible_height)
    return false;
  if (lhs.top_controls_visible_height < rhs.top_controls_visible_height)
    return true;
  if (rhs.top_controls_visible_height < lhs.top_controls_visible_height)
    return false;
  if (lhs.decode_begin_time < rhs.decode_begin_time)
    return true;
  if (rhs.decode_begin_time < lhs.decode_begin_time)
    return false;
  if (lhs.decode_end_time < rhs.decode_end_time)
    return true;
  if (rhs.decode_end_time < lhs.decode_end_time)
    return false;
  if (lhs.processing_time < rhs.processing_time)
    return true;
  if (rhs.processing_time < lhs.processing_time)
    return false;
  if (lhs.has_rtp_timestamp < rhs.has_rtp_timestamp)
    return true;
  if (rhs.has_rtp_timestamp < lhs.has_rtp_timestamp)
    return false;
  if (lhs.rtp_timestamp < rhs.rtp_timestamp)
    return true;
  if (rhs.rtp_timestamp < lhs.rtp_timestamp)
    return false;
  if (lhs.receive_time < rhs.receive_time)
    return true;
  if (rhs.receive_time < lhs.receive_time)
    return false;
  if (lhs.wallclock_frame_duration < rhs.wallclock_frame_duration)
    return true;
  if (rhs.wallclock_frame_duration < lhs.wallclock_frame_duration)
    return false;
  return false;
}
template <typename StructPtrType>
VideoFramePtr VideoFrame::Clone() const {
  return New(
      mojo::Clone(format),
      mojo::Clone(coded_size),
      mojo::Clone(visible_rect),
      mojo::Clone(natural_size),
      mojo::Clone(timestamp),
      mojo::Clone(data),
      mojo::Clone(metadata),
      mojo::Clone(color_space),
      mojo::Clone(hdr_metadata)
  );
}

template <typename T, VideoFrame::EnableIfSame<T>*>
bool VideoFrame::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->format, other_struct.format))
    return false;
  if (!mojo::Equals(this->coded_size, other_struct.coded_size))
    return false;
  if (!mojo::Equals(this->visible_rect, other_struct.visible_rect))
    return false;
  if (!mojo::Equals(this->natural_size, other_struct.natural_size))
    return false;
  if (!mojo::Equals(this->timestamp, other_struct.timestamp))
    return false;
  if (!mojo::Equals(this->data, other_struct.data))
    return false;
  if (!mojo::Equals(this->metadata, other_struct.metadata))
    return false;
  if (!mojo::Equals(this->color_space, other_struct.color_space))
    return false;
  if (!mojo::Equals(this->hdr_metadata, other_struct.hdr_metadata))
    return false;
  return true;
}

template <typename T, VideoFrame::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.format < rhs.format)
    return true;
  if (rhs.format < lhs.format)
    return false;
  if (lhs.coded_size < rhs.coded_size)
    return true;
  if (rhs.coded_size < lhs.coded_size)
    return false;
  if (lhs.visible_rect < rhs.visible_rect)
    return true;
  if (rhs.visible_rect < lhs.visible_rect)
    return false;
  if (lhs.natural_size < rhs.natural_size)
    return true;
  if (rhs.natural_size < lhs.natural_size)
    return false;
  if (lhs.timestamp < rhs.timestamp)
    return true;
  if (rhs.timestamp < lhs.timestamp)
    return false;
  if (lhs.data < rhs.data)
    return true;
  if (rhs.data < lhs.data)
    return false;
  if (lhs.metadata < rhs.metadata)
    return true;
  if (rhs.metadata < lhs.metadata)
    return false;
  if (lhs.color_space < rhs.color_space)
    return true;
  if (rhs.color_space < lhs.color_space)
    return false;
  if (lhs.hdr_metadata < rhs.hdr_metadata)
    return true;
  if (rhs.hdr_metadata < lhs.hdr_metadata)
    return false;
  return false;
}
template <typename StructPtrType>
EosVideoFrameDataPtr EosVideoFrameData::Clone() const {
  return New(
  );
}

template <typename T, EosVideoFrameData::EnableIfSame<T>*>
bool EosVideoFrameData::Equals(const T& other_struct) const {
  return true;
}

template <typename T, EosVideoFrameData::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  return false;
}
template <typename StructPtrType>
SharedBufferVideoFrameDataPtr SharedBufferVideoFrameData::Clone() const {
  return New(
      mojo::Clone(frame_data),
      mojo::Clone(strides),
      mojo::Clone(offsets)
  );
}

template <typename T, SharedBufferVideoFrameData::EnableIfSame<T>*>
bool SharedBufferVideoFrameData::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->frame_data, other_struct.frame_data))
    return false;
  if (!mojo::Equals(this->strides, other_struct.strides))
    return false;
  if (!mojo::Equals(this->offsets, other_struct.offsets))
    return false;
  return true;
}

template <typename T, SharedBufferVideoFrameData::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.frame_data < rhs.frame_data)
    return true;
  if (rhs.frame_data < lhs.frame_data)
    return false;
  if (lhs.strides < rhs.strides)
    return true;
  if (rhs.strides < lhs.strides)
    return false;
  if (lhs.offsets < rhs.offsets)
    return true;
  if (rhs.offsets < lhs.offsets)
    return false;
  return false;
}
template <typename StructPtrType>
GpuMemoryBufferVideoFrameDataPtr GpuMemoryBufferVideoFrameData::Clone() const {
  return New(
      mojo::Clone(gpu_memory_buffer_handle),
      mojo::Clone(mailbox_holder)
  );
}

template <typename T, GpuMemoryBufferVideoFrameData::EnableIfSame<T>*>
bool GpuMemoryBufferVideoFrameData::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->gpu_memory_buffer_handle, other_struct.gpu_memory_buffer_handle))
    return false;
  if (!mojo::Equals(this->mailbox_holder, other_struct.mailbox_holder))
    return false;
  return true;
}

template <typename T, GpuMemoryBufferVideoFrameData::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.gpu_memory_buffer_handle < rhs.gpu_memory_buffer_handle)
    return true;
  if (rhs.gpu_memory_buffer_handle < lhs.gpu_memory_buffer_handle)
    return false;
  if (lhs.mailbox_holder < rhs.mailbox_holder)
    return true;
  if (rhs.mailbox_holder < lhs.mailbox_holder)
    return false;
  return false;
}
template <typename StructPtrType>
MailboxVideoFrameDataPtr MailboxVideoFrameData::Clone() const {
  return New(
      mojo::Clone(mailbox_holder),
      mojo::Clone(ycbcr_data)
  );
}

template <typename T, MailboxVideoFrameData::EnableIfSame<T>*>
bool MailboxVideoFrameData::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->mailbox_holder, other_struct.mailbox_holder))
    return false;
  if (!mojo::Equals(this->ycbcr_data, other_struct.ycbcr_data))
    return false;
  return true;
}

template <typename T, MailboxVideoFrameData::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.mailbox_holder < rhs.mailbox_holder)
    return true;
  if (rhs.mailbox_holder < lhs.mailbox_holder)
    return false;
  if (lhs.ycbcr_data < rhs.ycbcr_data)
    return true;
  if (rhs.ycbcr_data < lhs.ycbcr_data)
    return false;
  return false;
}
template <typename StructPtrType>
PipelineStatisticsPtr PipelineStatistics::Clone() const {
  return New(
      mojo::Clone(audio_bytes_decoded),
      mojo::Clone(video_bytes_decoded),
      mojo::Clone(video_frames_decoded),
      mojo::Clone(video_frames_dropped),
      mojo::Clone(audio_memory_usage),
      mojo::Clone(video_memory_usage)
  );
}

template <typename T, PipelineStatistics::EnableIfSame<T>*>
bool PipelineStatistics::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->audio_bytes_decoded, other_struct.audio_bytes_decoded))
    return false;
  if (!mojo::Equals(this->video_bytes_decoded, other_struct.video_bytes_decoded))
    return false;
  if (!mojo::Equals(this->video_frames_decoded, other_struct.video_frames_decoded))
    return false;
  if (!mojo::Equals(this->video_frames_dropped, other_struct.video_frames_dropped))
    return false;
  if (!mojo::Equals(this->audio_memory_usage, other_struct.audio_memory_usage))
    return false;
  if (!mojo::Equals(this->video_memory_usage, other_struct.video_memory_usage))
    return false;
  return true;
}

template <typename T, PipelineStatistics::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.audio_bytes_decoded < rhs.audio_bytes_decoded)
    return true;
  if (rhs.audio_bytes_decoded < lhs.audio_bytes_decoded)
    return false;
  if (lhs.video_bytes_decoded < rhs.video_bytes_decoded)
    return true;
  if (rhs.video_bytes_decoded < lhs.video_bytes_decoded)
    return false;
  if (lhs.video_frames_decoded < rhs.video_frames_decoded)
    return true;
  if (rhs.video_frames_decoded < lhs.video_frames_decoded)
    return false;
  if (lhs.video_frames_dropped < rhs.video_frames_dropped)
    return true;
  if (rhs.video_frames_dropped < lhs.video_frames_dropped)
    return false;
  if (lhs.audio_memory_usage < rhs.audio_memory_usage)
    return true;
  if (rhs.audio_memory_usage < lhs.audio_memory_usage)
    return false;
  if (lhs.video_memory_usage < rhs.video_memory_usage)
    return true;
  if (rhs.video_memory_usage < lhs.video_memory_usage)
    return false;
  return false;
}
template <typename StructPtrType>
PredictionFeaturesPtr PredictionFeatures::Clone() const {
  return New(
      mojo::Clone(profile),
      mojo::Clone(video_size),
      mojo::Clone(frames_per_sec),
      mojo::Clone(key_system),
      mojo::Clone(use_hw_secure_codecs)
  );
}

template <typename T, PredictionFeatures::EnableIfSame<T>*>
bool PredictionFeatures::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->profile, other_struct.profile))
    return false;
  if (!mojo::Equals(this->video_size, other_struct.video_size))
    return false;
  if (!mojo::Equals(this->frames_per_sec, other_struct.frames_per_sec))
    return false;
  if (!mojo::Equals(this->key_system, other_struct.key_system))
    return false;
  if (!mojo::Equals(this->use_hw_secure_codecs, other_struct.use_hw_secure_codecs))
    return false;
  return true;
}

template <typename T, PredictionFeatures::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.profile < rhs.profile)
    return true;
  if (rhs.profile < lhs.profile)
    return false;
  if (lhs.video_size < rhs.video_size)
    return true;
  if (rhs.video_size < lhs.video_size)
    return false;
  if (lhs.frames_per_sec < rhs.frames_per_sec)
    return true;
  if (rhs.frames_per_sec < lhs.frames_per_sec)
    return false;
  if (lhs.key_system < rhs.key_system)
    return true;
  if (rhs.key_system < lhs.key_system)
    return false;
  if (lhs.use_hw_secure_codecs < rhs.use_hw_secure_codecs)
    return true;
  if (rhs.use_hw_secure_codecs < lhs.use_hw_secure_codecs)
    return false;
  return false;
}
template <typename StructPtrType>
PredictionTargetsPtr PredictionTargets::Clone() const {
  return New(
      mojo::Clone(frames_decoded),
      mojo::Clone(frames_dropped),
      mojo::Clone(frames_power_efficient)
  );
}

template <typename T, PredictionTargets::EnableIfSame<T>*>
bool PredictionTargets::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->frames_decoded, other_struct.frames_decoded))
    return false;
  if (!mojo::Equals(this->frames_dropped, other_struct.frames_dropped))
    return false;
  if (!mojo::Equals(this->frames_power_efficient, other_struct.frames_power_efficient))
    return false;
  return true;
}

template <typename T, PredictionTargets::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.frames_decoded < rhs.frames_decoded)
    return true;
  if (rhs.frames_decoded < lhs.frames_decoded)
    return false;
  if (lhs.frames_dropped < rhs.frames_dropped)
    return true;
  if (rhs.frames_dropped < lhs.frames_dropped)
    return false;
  if (lhs.frames_power_efficient < rhs.frames_power_efficient)
    return true;
  if (rhs.frames_power_efficient < lhs.frames_power_efficient)
    return false;
  return false;
}
template <typename StructPtrType>
AudioPipelineInfoPtr AudioPipelineInfo::Clone() const {
  return New(
      mojo::Clone(decoder_type),
      mojo::Clone(is_platform_decoder),
      mojo::Clone(has_decrypting_demuxer_stream),
      mojo::Clone(encryption_type)
  );
}

template <typename T, AudioPipelineInfo::EnableIfSame<T>*>
bool AudioPipelineInfo::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->decoder_type, other_struct.decoder_type))
    return false;
  if (!mojo::Equals(this->is_platform_decoder, other_struct.is_platform_decoder))
    return false;
  if (!mojo::Equals(this->has_decrypting_demuxer_stream, other_struct.has_decrypting_demuxer_stream))
    return false;
  if (!mojo::Equals(this->encryption_type, other_struct.encryption_type))
    return false;
  return true;
}

template <typename T, AudioPipelineInfo::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.decoder_type < rhs.decoder_type)
    return true;
  if (rhs.decoder_type < lhs.decoder_type)
    return false;
  if (lhs.is_platform_decoder < rhs.is_platform_decoder)
    return true;
  if (rhs.is_platform_decoder < lhs.is_platform_decoder)
    return false;
  if (lhs.has_decrypting_demuxer_stream < rhs.has_decrypting_demuxer_stream)
    return true;
  if (rhs.has_decrypting_demuxer_stream < lhs.has_decrypting_demuxer_stream)
    return false;
  if (lhs.encryption_type < rhs.encryption_type)
    return true;
  if (rhs.encryption_type < lhs.encryption_type)
    return false;
  return false;
}
template <typename StructPtrType>
VideoPipelineInfoPtr VideoPipelineInfo::Clone() const {
  return New(
      mojo::Clone(decoder_type),
      mojo::Clone(is_platform_decoder),
      mojo::Clone(has_decrypting_demuxer_stream),
      mojo::Clone(encryption_type)
  );
}

template <typename T, VideoPipelineInfo::EnableIfSame<T>*>
bool VideoPipelineInfo::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->decoder_type, other_struct.decoder_type))
    return false;
  if (!mojo::Equals(this->is_platform_decoder, other_struct.is_platform_decoder))
    return false;
  if (!mojo::Equals(this->has_decrypting_demuxer_stream, other_struct.has_decrypting_demuxer_stream))
    return false;
  if (!mojo::Equals(this->encryption_type, other_struct.encryption_type))
    return false;
  return true;
}

template <typename T, VideoPipelineInfo::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.decoder_type < rhs.decoder_type)
    return true;
  if (rhs.decoder_type < lhs.decoder_type)
    return false;
  if (lhs.is_platform_decoder < rhs.is_platform_decoder)
    return true;
  if (rhs.is_platform_decoder < lhs.is_platform_decoder)
    return false;
  if (lhs.has_decrypting_demuxer_stream < rhs.has_decrypting_demuxer_stream)
    return true;
  if (rhs.has_decrypting_demuxer_stream < lhs.has_decrypting_demuxer_stream)
    return false;
  if (lhs.encryption_type < rhs.encryption_type)
    return true;
  if (rhs.encryption_type < lhs.encryption_type)
    return false;
  return false;
}
template <typename StructPtrType>
StatusDataPtr StatusData::Clone() const {
  return New(
      mojo::Clone(group),
      mojo::Clone(code),
      mojo::Clone(message),
      mojo::Clone(frames),
      mojo::Clone(cause),
      mojo::Clone(data),
      mojo::Clone(packed_root_cause)
  );
}

template <typename T, StatusData::EnableIfSame<T>*>
bool StatusData::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->group, other_struct.group))
    return false;
  if (!mojo::Equals(this->code, other_struct.code))
    return false;
  if (!mojo::Equals(this->message, other_struct.message))
    return false;
  if (!mojo::Equals(this->frames, other_struct.frames))
    return false;
  if (!mojo::Equals(this->cause, other_struct.cause))
    return false;
  if (!mojo::Equals(this->data, other_struct.data))
    return false;
  if (!mojo::Equals(this->packed_root_cause, other_struct.packed_root_cause))
    return false;
  return true;
}

template <typename T, StatusData::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.group < rhs.group)
    return true;
  if (rhs.group < lhs.group)
    return false;
  if (lhs.code < rhs.code)
    return true;
  if (rhs.code < lhs.code)
    return false;
  if (lhs.message < rhs.message)
    return true;
  if (rhs.message < lhs.message)
    return false;
  if (lhs.frames < rhs.frames)
    return true;
  if (rhs.frames < lhs.frames)
    return false;
  if (lhs.cause < rhs.cause)
    return true;
  if (rhs.cause < lhs.cause)
    return false;
  if (lhs.data < rhs.data)
    return true;
  if (rhs.data < lhs.data)
    return false;
  if (lhs.packed_root_cause < rhs.packed_root_cause)
    return true;
  if (rhs.packed_root_cause < lhs.packed_root_cause)
    return false;
  return false;
}
template <typename StructPtrType>
EncoderStatusPtr EncoderStatus::Clone() const {
  return New(
      mojo::Clone(internal)
  );
}

template <typename T, EncoderStatus::EnableIfSame<T>*>
bool EncoderStatus::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->internal, other_struct.internal))
    return false;
  return true;
}

template <typename T, EncoderStatus::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.internal < rhs.internal)
    return true;
  if (rhs.internal < lhs.internal)
    return false;
  return false;
}
template <typename StructPtrType>
DecoderStatusPtr DecoderStatus::Clone() const {
  return New(
      mojo::Clone(internal)
  );
}

template <typename T, DecoderStatus::EnableIfSame<T>*>
bool DecoderStatus::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->internal, other_struct.internal))
    return false;
  return true;
}

template <typename T, DecoderStatus::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.internal < rhs.internal)
    return true;
  if (rhs.internal < lhs.internal)
    return false;
  return false;
}
template <typename StructPtrType>
PipelineStatusPtr PipelineStatus::Clone() const {
  return New(
      mojo::Clone(internal)
  );
}

template <typename T, PipelineStatus::EnableIfSame<T>*>
bool PipelineStatus::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->internal, other_struct.internal))
    return false;
  return true;
}

template <typename T, PipelineStatus::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.internal < rhs.internal)
    return true;
  if (rhs.internal < lhs.internal)
    return false;
  return false;
}


}  // namespace mojom
}  // namespace media

namespace mojo {


template <>
struct  StructTraits<::media::mojom::VideoTransformation::DataView,
                                         ::media::mojom::VideoTransformationPtr> {
  static bool IsNull(const ::media::mojom::VideoTransformationPtr& input) { return !input; }
  static void SetToNull(::media::mojom::VideoTransformationPtr* output) { output->reset(); }

  static decltype(::media::mojom::VideoTransformation::rotation) rotation(
      const ::media::mojom::VideoTransformationPtr& input) {
    return input->rotation;
  }

  static decltype(::media::mojom::VideoTransformation::mirrored) mirrored(
      const ::media::mojom::VideoTransformationPtr& input) {
    return input->mirrored;
  }

  static bool Read(::media::mojom::VideoTransformation::DataView input, ::media::mojom::VideoTransformationPtr* output);
};


template <>
struct  StructTraits<::media::mojom::VideoColorSpace::DataView,
                                         ::media::mojom::VideoColorSpacePtr> {
  static bool IsNull(const ::media::mojom::VideoColorSpacePtr& input) { return !input; }
  static void SetToNull(::media::mojom::VideoColorSpacePtr* output) { output->reset(); }

  static decltype(::media::mojom::VideoColorSpace::primaries) primaries(
      const ::media::mojom::VideoColorSpacePtr& input) {
    return input->primaries;
  }

  static decltype(::media::mojom::VideoColorSpace::transfer) transfer(
      const ::media::mojom::VideoColorSpacePtr& input) {
    return input->transfer;
  }

  static decltype(::media::mojom::VideoColorSpace::matrix) matrix(
      const ::media::mojom::VideoColorSpacePtr& input) {
    return input->matrix;
  }

  static decltype(::media::mojom::VideoColorSpace::range) range(
      const ::media::mojom::VideoColorSpacePtr& input) {
    return input->range;
  }

  static bool Read(::media::mojom::VideoColorSpace::DataView input, ::media::mojom::VideoColorSpacePtr* output);
};


template <>
struct  StructTraits<::media::mojom::AudioDecoderConfig::DataView,
                                         ::media::mojom::AudioDecoderConfigPtr> {
  static bool IsNull(const ::media::mojom::AudioDecoderConfigPtr& input) { return !input; }
  static void SetToNull(::media::mojom::AudioDecoderConfigPtr* output) { output->reset(); }

  static decltype(::media::mojom::AudioDecoderConfig::codec) codec(
      const ::media::mojom::AudioDecoderConfigPtr& input) {
    return input->codec;
  }

  static decltype(::media::mojom::AudioDecoderConfig::sample_format) sample_format(
      const ::media::mojom::AudioDecoderConfigPtr& input) {
    return input->sample_format;
  }

  static decltype(::media::mojom::AudioDecoderConfig::channel_layout) channel_layout(
      const ::media::mojom::AudioDecoderConfigPtr& input) {
    return input->channel_layout;
  }

  static decltype(::media::mojom::AudioDecoderConfig::samples_per_second) samples_per_second(
      const ::media::mojom::AudioDecoderConfigPtr& input) {
    return input->samples_per_second;
  }

  static const decltype(::media::mojom::AudioDecoderConfig::extra_data)& extra_data(
      const ::media::mojom::AudioDecoderConfigPtr& input) {
    return input->extra_data;
  }

  static decltype(::media::mojom::AudioDecoderConfig::encryption_scheme) encryption_scheme(
      const ::media::mojom::AudioDecoderConfigPtr& input) {
    return input->encryption_scheme;
  }

  static const decltype(::media::mojom::AudioDecoderConfig::seek_preroll)& seek_preroll(
      const ::media::mojom::AudioDecoderConfigPtr& input) {
    return input->seek_preroll;
  }

  static decltype(::media::mojom::AudioDecoderConfig::codec_delay) codec_delay(
      const ::media::mojom::AudioDecoderConfigPtr& input) {
    return input->codec_delay;
  }

  static decltype(::media::mojom::AudioDecoderConfig::profile) profile(
      const ::media::mojom::AudioDecoderConfigPtr& input) {
    return input->profile;
  }

  static decltype(::media::mojom::AudioDecoderConfig::target_output_channel_layout) target_output_channel_layout(
      const ::media::mojom::AudioDecoderConfigPtr& input) {
    return input->target_output_channel_layout;
  }

  static decltype(::media::mojom::AudioDecoderConfig::target_output_sample_format) target_output_sample_format(
      const ::media::mojom::AudioDecoderConfigPtr& input) {
    return input->target_output_sample_format;
  }

  static decltype(::media::mojom::AudioDecoderConfig::should_discard_decoder_delay) should_discard_decoder_delay(
      const ::media::mojom::AudioDecoderConfigPtr& input) {
    return input->should_discard_decoder_delay;
  }

  static const decltype(::media::mojom::AudioDecoderConfig::aac_extra_data)& aac_extra_data(
      const ::media::mojom::AudioDecoderConfigPtr& input) {
    return input->aac_extra_data;
  }

  static bool Read(::media::mojom::AudioDecoderConfig::DataView input, ::media::mojom::AudioDecoderConfigPtr* output);
};


template <>
struct  StructTraits<::media::mojom::VideoDecoderConfig::DataView,
                                         ::media::mojom::VideoDecoderConfigPtr> {
  static bool IsNull(const ::media::mojom::VideoDecoderConfigPtr& input) { return !input; }
  static void SetToNull(::media::mojom::VideoDecoderConfigPtr* output) { output->reset(); }

  static decltype(::media::mojom::VideoDecoderConfig::codec) codec(
      const ::media::mojom::VideoDecoderConfigPtr& input) {
    return input->codec;
  }

  static decltype(::media::mojom::VideoDecoderConfig::profile) profile(
      const ::media::mojom::VideoDecoderConfigPtr& input) {
    return input->profile;
  }

  static decltype(::media::mojom::VideoDecoderConfig::level) level(
      const ::media::mojom::VideoDecoderConfigPtr& input) {
    return input->level;
  }

  static decltype(::media::mojom::VideoDecoderConfig::has_alpha) has_alpha(
      const ::media::mojom::VideoDecoderConfigPtr& input) {
    return input->has_alpha;
  }

  static const decltype(::media::mojom::VideoDecoderConfig::transformation)& transformation(
      const ::media::mojom::VideoDecoderConfigPtr& input) {
    return input->transformation;
  }

  static const decltype(::media::mojom::VideoDecoderConfig::coded_size)& coded_size(
      const ::media::mojom::VideoDecoderConfigPtr& input) {
    return input->coded_size;
  }

  static const decltype(::media::mojom::VideoDecoderConfig::visible_rect)& visible_rect(
      const ::media::mojom::VideoDecoderConfigPtr& input) {
    return input->visible_rect;
  }

  static const decltype(::media::mojom::VideoDecoderConfig::natural_size)& natural_size(
      const ::media::mojom::VideoDecoderConfigPtr& input) {
    return input->natural_size;
  }

  static const decltype(::media::mojom::VideoDecoderConfig::extra_data)& extra_data(
      const ::media::mojom::VideoDecoderConfigPtr& input) {
    return input->extra_data;
  }

  static decltype(::media::mojom::VideoDecoderConfig::encryption_scheme) encryption_scheme(
      const ::media::mojom::VideoDecoderConfigPtr& input) {
    return input->encryption_scheme;
  }

  static const decltype(::media::mojom::VideoDecoderConfig::color_space_info)& color_space_info(
      const ::media::mojom::VideoDecoderConfigPtr& input) {
    return input->color_space_info;
  }

  static const decltype(::media::mojom::VideoDecoderConfig::hdr_metadata)& hdr_metadata(
      const ::media::mojom::VideoDecoderConfigPtr& input) {
    return input->hdr_metadata;
  }

  static bool Read(::media::mojom::VideoDecoderConfig::DataView input, ::media::mojom::VideoDecoderConfigPtr* output);
};


template <>
struct  StructTraits<::media::mojom::DecryptConfig::DataView,
                                         ::media::mojom::DecryptConfigPtr> {
  static bool IsNull(const ::media::mojom::DecryptConfigPtr& input) { return !input; }
  static void SetToNull(::media::mojom::DecryptConfigPtr* output) { output->reset(); }

  static decltype(::media::mojom::DecryptConfig::encryption_scheme) encryption_scheme(
      const ::media::mojom::DecryptConfigPtr& input) {
    return input->encryption_scheme;
  }

  static const decltype(::media::mojom::DecryptConfig::key_id)& key_id(
      const ::media::mojom::DecryptConfigPtr& input) {
    return input->key_id;
  }

  static const decltype(::media::mojom::DecryptConfig::iv)& iv(
      const ::media::mojom::DecryptConfigPtr& input) {
    return input->iv;
  }

  static const decltype(::media::mojom::DecryptConfig::subsamples)& subsamples(
      const ::media::mojom::DecryptConfigPtr& input) {
    return input->subsamples;
  }

  static const decltype(::media::mojom::DecryptConfig::encryption_pattern)& encryption_pattern(
      const ::media::mojom::DecryptConfigPtr& input) {
    return input->encryption_pattern;
  }

  static bool Read(::media::mojom::DecryptConfig::DataView input, ::media::mojom::DecryptConfigPtr* output);
};


template <>
struct  StructTraits<::media::mojom::DecoderBuffer::DataView,
                                         ::media::mojom::DecoderBufferPtr> {
  static bool IsNull(const ::media::mojom::DecoderBufferPtr& input) { return !input; }
  static void SetToNull(::media::mojom::DecoderBufferPtr* output) { output->reset(); }

  static const decltype(::media::mojom::DecoderBuffer::timestamp)& timestamp(
      const ::media::mojom::DecoderBufferPtr& input) {
    return input->timestamp;
  }

  static const decltype(::media::mojom::DecoderBuffer::duration)& duration(
      const ::media::mojom::DecoderBufferPtr& input) {
    return input->duration;
  }

  static decltype(::media::mojom::DecoderBuffer::is_end_of_stream) is_end_of_stream(
      const ::media::mojom::DecoderBufferPtr& input) {
    return input->is_end_of_stream;
  }

  static decltype(::media::mojom::DecoderBuffer::data_size) data_size(
      const ::media::mojom::DecoderBufferPtr& input) {
    return input->data_size;
  }

  static decltype(::media::mojom::DecoderBuffer::is_key_frame) is_key_frame(
      const ::media::mojom::DecoderBufferPtr& input) {
    return input->is_key_frame;
  }

  static const decltype(::media::mojom::DecoderBuffer::side_data)& side_data(
      const ::media::mojom::DecoderBufferPtr& input) {
    return input->side_data;
  }

  static const decltype(::media::mojom::DecoderBuffer::decrypt_config)& decrypt_config(
      const ::media::mojom::DecoderBufferPtr& input) {
    return input->decrypt_config;
  }

  static const decltype(::media::mojom::DecoderBuffer::front_discard)& front_discard(
      const ::media::mojom::DecoderBufferPtr& input) {
    return input->front_discard;
  }

  static const decltype(::media::mojom::DecoderBuffer::back_discard)& back_discard(
      const ::media::mojom::DecoderBufferPtr& input) {
    return input->back_discard;
  }

  static bool Read(::media::mojom::DecoderBuffer::DataView input, ::media::mojom::DecoderBufferPtr* output);
};


template <>
struct  StructTraits<::media::mojom::AudioBuffer::DataView,
                                         ::media::mojom::AudioBufferPtr> {
  static bool IsNull(const ::media::mojom::AudioBufferPtr& input) { return !input; }
  static void SetToNull(::media::mojom::AudioBufferPtr* output) { output->reset(); }

  static decltype(::media::mojom::AudioBuffer::sample_format) sample_format(
      const ::media::mojom::AudioBufferPtr& input) {
    return input->sample_format;
  }

  static decltype(::media::mojom::AudioBuffer::channel_layout) channel_layout(
      const ::media::mojom::AudioBufferPtr& input) {
    return input->channel_layout;
  }

  static decltype(::media::mojom::AudioBuffer::channel_count) channel_count(
      const ::media::mojom::AudioBufferPtr& input) {
    return input->channel_count;
  }

  static decltype(::media::mojom::AudioBuffer::sample_rate) sample_rate(
      const ::media::mojom::AudioBufferPtr& input) {
    return input->sample_rate;
  }

  static decltype(::media::mojom::AudioBuffer::frame_count) frame_count(
      const ::media::mojom::AudioBufferPtr& input) {
    return input->frame_count;
  }

  static decltype(::media::mojom::AudioBuffer::end_of_stream) end_of_stream(
      const ::media::mojom::AudioBufferPtr& input) {
    return input->end_of_stream;
  }

  static const decltype(::media::mojom::AudioBuffer::timestamp)& timestamp(
      const ::media::mojom::AudioBufferPtr& input) {
    return input->timestamp;
  }

  static const decltype(::media::mojom::AudioBuffer::data)& data(
      const ::media::mojom::AudioBufferPtr& input) {
    return input->data;
  }

  static bool Read(::media::mojom::AudioBuffer::DataView input, ::media::mojom::AudioBufferPtr* output);
};


template <>
struct  StructTraits<::media::mojom::VideoFrameMetadata::DataView,
                                         ::media::mojom::VideoFrameMetadataPtr> {
  static bool IsNull(const ::media::mojom::VideoFrameMetadataPtr& input) { return !input; }
  static void SetToNull(::media::mojom::VideoFrameMetadataPtr* output) { output->reset(); }

  static decltype(::media::mojom::VideoFrameMetadata::allow_overlay) allow_overlay(
      const ::media::mojom::VideoFrameMetadataPtr& input) {
    return input->allow_overlay;
  }

  static const decltype(::media::mojom::VideoFrameMetadata::capture_begin_time)& capture_begin_time(
      const ::media::mojom::VideoFrameMetadataPtr& input) {
    return input->capture_begin_time;
  }

  static const decltype(::media::mojom::VideoFrameMetadata::capture_end_time)& capture_end_time(
      const ::media::mojom::VideoFrameMetadataPtr& input) {
    return input->capture_end_time;
  }

  static decltype(::media::mojom::VideoFrameMetadata::has_capture_counter) has_capture_counter(
      const ::media::mojom::VideoFrameMetadataPtr& input) {
    return input->has_capture_counter;
  }

  static decltype(::media::mojom::VideoFrameMetadata::capture_counter) capture_counter(
      const ::media::mojom::VideoFrameMetadataPtr& input) {
    return input->capture_counter;
  }

  static const decltype(::media::mojom::VideoFrameMetadata::capture_update_rect)& capture_update_rect(
      const ::media::mojom::VideoFrameMetadataPtr& input) {
    return input->capture_update_rect;
  }

  static const decltype(::media::mojom::VideoFrameMetadata::source_size)& source_size(
      const ::media::mojom::VideoFrameMetadataPtr& input) {
    return input->source_size;
  }

  static const decltype(::media::mojom::VideoFrameMetadata::region_capture_rect)& region_capture_rect(
      const ::media::mojom::VideoFrameMetadataPtr& input) {
    return input->region_capture_rect;
  }

  static decltype(::media::mojom::VideoFrameMetadata::crop_version) crop_version(
      const ::media::mojom::VideoFrameMetadataPtr& input) {
    return input->crop_version;
  }

  static decltype(::media::mojom::VideoFrameMetadata::copy_required) copy_required(
      const ::media::mojom::VideoFrameMetadataPtr& input) {
    return input->copy_required;
  }

  static decltype(::media::mojom::VideoFrameMetadata::end_of_stream) end_of_stream(
      const ::media::mojom::VideoFrameMetadataPtr& input) {
    return input->end_of_stream;
  }

  static const decltype(::media::mojom::VideoFrameMetadata::frame_duration)& frame_duration(
      const ::media::mojom::VideoFrameMetadataPtr& input) {
    return input->frame_duration;
  }

  static decltype(::media::mojom::VideoFrameMetadata::has_frame_rate) has_frame_rate(
      const ::media::mojom::VideoFrameMetadataPtr& input) {
    return input->has_frame_rate;
  }

  static decltype(::media::mojom::VideoFrameMetadata::frame_rate) frame_rate(
      const ::media::mojom::VideoFrameMetadataPtr& input) {
    return input->frame_rate;
  }

  static decltype(::media::mojom::VideoFrameMetadata::interactive_content) interactive_content(
      const ::media::mojom::VideoFrameMetadataPtr& input) {
    return input->interactive_content;
  }

  static const decltype(::media::mojom::VideoFrameMetadata::reference_time)& reference_time(
      const ::media::mojom::VideoFrameMetadataPtr& input) {
    return input->reference_time;
  }

  static decltype(::media::mojom::VideoFrameMetadata::read_lock_fences_enabled) read_lock_fences_enabled(
      const ::media::mojom::VideoFrameMetadataPtr& input) {
    return input->read_lock_fences_enabled;
  }

  static const decltype(::media::mojom::VideoFrameMetadata::transformation)& transformation(
      const ::media::mojom::VideoFrameMetadataPtr& input) {
    return input->transformation;
  }

  static decltype(::media::mojom::VideoFrameMetadata::texture_owner) texture_owner(
      const ::media::mojom::VideoFrameMetadataPtr& input) {
    return input->texture_owner;
  }

  static decltype(::media::mojom::VideoFrameMetadata::wants_promotion_hint) wants_promotion_hint(
      const ::media::mojom::VideoFrameMetadataPtr& input) {
    return input->wants_promotion_hint;
  }

  static decltype(::media::mojom::VideoFrameMetadata::protected_video) protected_video(
      const ::media::mojom::VideoFrameMetadataPtr& input) {
    return input->protected_video;
  }

  static decltype(::media::mojom::VideoFrameMetadata::hw_protected) hw_protected(
      const ::media::mojom::VideoFrameMetadataPtr& input) {
    return input->hw_protected;
  }

  static decltype(::media::mojom::VideoFrameMetadata::is_webgpu_compatible) is_webgpu_compatible(
      const ::media::mojom::VideoFrameMetadataPtr& input) {
    return input->is_webgpu_compatible;
  }

  static const decltype(::media::mojom::VideoFrameMetadata::overlay_plane_id)& overlay_plane_id(
      const ::media::mojom::VideoFrameMetadataPtr& input) {
    return input->overlay_plane_id;
  }

  static decltype(::media::mojom::VideoFrameMetadata::power_efficient) power_efficient(
      const ::media::mojom::VideoFrameMetadataPtr& input) {
    return input->power_efficient;
  }

  static decltype(::media::mojom::VideoFrameMetadata::texture_origin_is_top_left) texture_origin_is_top_left(
      const ::media::mojom::VideoFrameMetadataPtr& input) {
    return input->texture_origin_is_top_left;
  }

  static decltype(::media::mojom::VideoFrameMetadata::has_device_scale_factor) has_device_scale_factor(
      const ::media::mojom::VideoFrameMetadataPtr& input) {
    return input->has_device_scale_factor;
  }

  static decltype(::media::mojom::VideoFrameMetadata::device_scale_factor) device_scale_factor(
      const ::media::mojom::VideoFrameMetadataPtr& input) {
    return input->device_scale_factor;
  }

  static decltype(::media::mojom::VideoFrameMetadata::has_page_scale_factor) has_page_scale_factor(
      const ::media::mojom::VideoFrameMetadataPtr& input) {
    return input->has_page_scale_factor;
  }

  static decltype(::media::mojom::VideoFrameMetadata::page_scale_factor) page_scale_factor(
      const ::media::mojom::VideoFrameMetadataPtr& input) {
    return input->page_scale_factor;
  }

  static decltype(::media::mojom::VideoFrameMetadata::has_root_scroll_offset_x) has_root_scroll_offset_x(
      const ::media::mojom::VideoFrameMetadataPtr& input) {
    return input->has_root_scroll_offset_x;
  }

  static decltype(::media::mojom::VideoFrameMetadata::root_scroll_offset_x) root_scroll_offset_x(
      const ::media::mojom::VideoFrameMetadataPtr& input) {
    return input->root_scroll_offset_x;
  }

  static decltype(::media::mojom::VideoFrameMetadata::has_root_scroll_offset_y) has_root_scroll_offset_y(
      const ::media::mojom::VideoFrameMetadataPtr& input) {
    return input->has_root_scroll_offset_y;
  }

  static decltype(::media::mojom::VideoFrameMetadata::root_scroll_offset_y) root_scroll_offset_y(
      const ::media::mojom::VideoFrameMetadataPtr& input) {
    return input->root_scroll_offset_y;
  }

  static decltype(::media::mojom::VideoFrameMetadata::has_top_controls_visible_height) has_top_controls_visible_height(
      const ::media::mojom::VideoFrameMetadataPtr& input) {
    return input->has_top_controls_visible_height;
  }

  static decltype(::media::mojom::VideoFrameMetadata::top_controls_visible_height) top_controls_visible_height(
      const ::media::mojom::VideoFrameMetadataPtr& input) {
    return input->top_controls_visible_height;
  }

  static const decltype(::media::mojom::VideoFrameMetadata::decode_begin_time)& decode_begin_time(
      const ::media::mojom::VideoFrameMetadataPtr& input) {
    return input->decode_begin_time;
  }

  static const decltype(::media::mojom::VideoFrameMetadata::decode_end_time)& decode_end_time(
      const ::media::mojom::VideoFrameMetadataPtr& input) {
    return input->decode_end_time;
  }

  static const decltype(::media::mojom::VideoFrameMetadata::processing_time)& processing_time(
      const ::media::mojom::VideoFrameMetadataPtr& input) {
    return input->processing_time;
  }

  static decltype(::media::mojom::VideoFrameMetadata::has_rtp_timestamp) has_rtp_timestamp(
      const ::media::mojom::VideoFrameMetadataPtr& input) {
    return input->has_rtp_timestamp;
  }

  static decltype(::media::mojom::VideoFrameMetadata::rtp_timestamp) rtp_timestamp(
      const ::media::mojom::VideoFrameMetadataPtr& input) {
    return input->rtp_timestamp;
  }

  static const decltype(::media::mojom::VideoFrameMetadata::receive_time)& receive_time(
      const ::media::mojom::VideoFrameMetadataPtr& input) {
    return input->receive_time;
  }

  static const decltype(::media::mojom::VideoFrameMetadata::wallclock_frame_duration)& wallclock_frame_duration(
      const ::media::mojom::VideoFrameMetadataPtr& input) {
    return input->wallclock_frame_duration;
  }

  static bool Read(::media::mojom::VideoFrameMetadata::DataView input, ::media::mojom::VideoFrameMetadataPtr* output);
};


template <>
struct  StructTraits<::media::mojom::VideoFrame::DataView,
                                         ::media::mojom::VideoFramePtr> {
  static bool IsNull(const ::media::mojom::VideoFramePtr& input) { return !input; }
  static void SetToNull(::media::mojom::VideoFramePtr* output) { output->reset(); }

  static decltype(::media::mojom::VideoFrame::format) format(
      const ::media::mojom::VideoFramePtr& input) {
    return input->format;
  }

  static const decltype(::media::mojom::VideoFrame::coded_size)& coded_size(
      const ::media::mojom::VideoFramePtr& input) {
    return input->coded_size;
  }

  static const decltype(::media::mojom::VideoFrame::visible_rect)& visible_rect(
      const ::media::mojom::VideoFramePtr& input) {
    return input->visible_rect;
  }

  static const decltype(::media::mojom::VideoFrame::natural_size)& natural_size(
      const ::media::mojom::VideoFramePtr& input) {
    return input->natural_size;
  }

  static const decltype(::media::mojom::VideoFrame::timestamp)& timestamp(
      const ::media::mojom::VideoFramePtr& input) {
    return input->timestamp;
  }

  static  decltype(::media::mojom::VideoFrame::data)& data(
       ::media::mojom::VideoFramePtr& input) {
    return input->data;
  }

  static const decltype(::media::mojom::VideoFrame::metadata)& metadata(
      const ::media::mojom::VideoFramePtr& input) {
    return input->metadata;
  }

  static const decltype(::media::mojom::VideoFrame::color_space)& color_space(
      const ::media::mojom::VideoFramePtr& input) {
    return input->color_space;
  }

  static const decltype(::media::mojom::VideoFrame::hdr_metadata)& hdr_metadata(
      const ::media::mojom::VideoFramePtr& input) {
    return input->hdr_metadata;
  }

  static bool Read(::media::mojom::VideoFrame::DataView input, ::media::mojom::VideoFramePtr* output);
};


template <>
struct  StructTraits<::media::mojom::EosVideoFrameData::DataView,
                                         ::media::mojom::EosVideoFrameDataPtr> {
  static bool IsNull(const ::media::mojom::EosVideoFrameDataPtr& input) { return !input; }
  static void SetToNull(::media::mojom::EosVideoFrameDataPtr* output) { output->reset(); }

  static bool Read(::media::mojom::EosVideoFrameData::DataView input, ::media::mojom::EosVideoFrameDataPtr* output);
};


template <>
struct  StructTraits<::media::mojom::SharedBufferVideoFrameData::DataView,
                                         ::media::mojom::SharedBufferVideoFrameDataPtr> {
  static bool IsNull(const ::media::mojom::SharedBufferVideoFrameDataPtr& input) { return !input; }
  static void SetToNull(::media::mojom::SharedBufferVideoFrameDataPtr* output) { output->reset(); }

  static  decltype(::media::mojom::SharedBufferVideoFrameData::frame_data)& frame_data(
       ::media::mojom::SharedBufferVideoFrameDataPtr& input) {
    return input->frame_data;
  }

  static const decltype(::media::mojom::SharedBufferVideoFrameData::strides)& strides(
      const ::media::mojom::SharedBufferVideoFrameDataPtr& input) {
    return input->strides;
  }

  static const decltype(::media::mojom::SharedBufferVideoFrameData::offsets)& offsets(
      const ::media::mojom::SharedBufferVideoFrameDataPtr& input) {
    return input->offsets;
  }

  static bool Read(::media::mojom::SharedBufferVideoFrameData::DataView input, ::media::mojom::SharedBufferVideoFrameDataPtr* output);
};


template <>
struct  StructTraits<::media::mojom::GpuMemoryBufferVideoFrameData::DataView,
                                         ::media::mojom::GpuMemoryBufferVideoFrameDataPtr> {
  static bool IsNull(const ::media::mojom::GpuMemoryBufferVideoFrameDataPtr& input) { return !input; }
  static void SetToNull(::media::mojom::GpuMemoryBufferVideoFrameDataPtr* output) { output->reset(); }

  static  decltype(::media::mojom::GpuMemoryBufferVideoFrameData::gpu_memory_buffer_handle)& gpu_memory_buffer_handle(
       ::media::mojom::GpuMemoryBufferVideoFrameDataPtr& input) {
    return input->gpu_memory_buffer_handle;
  }

  static const decltype(::media::mojom::GpuMemoryBufferVideoFrameData::mailbox_holder)& mailbox_holder(
      const ::media::mojom::GpuMemoryBufferVideoFrameDataPtr& input) {
    return input->mailbox_holder;
  }

  static bool Read(::media::mojom::GpuMemoryBufferVideoFrameData::DataView input, ::media::mojom::GpuMemoryBufferVideoFrameDataPtr* output);
};


template <>
struct  StructTraits<::media::mojom::MailboxVideoFrameData::DataView,
                                         ::media::mojom::MailboxVideoFrameDataPtr> {
  static bool IsNull(const ::media::mojom::MailboxVideoFrameDataPtr& input) { return !input; }
  static void SetToNull(::media::mojom::MailboxVideoFrameDataPtr* output) { output->reset(); }

  static const decltype(::media::mojom::MailboxVideoFrameData::mailbox_holder)& mailbox_holder(
      const ::media::mojom::MailboxVideoFrameDataPtr& input) {
    return input->mailbox_holder;
  }

  static const decltype(::media::mojom::MailboxVideoFrameData::ycbcr_data)& ycbcr_data(
      const ::media::mojom::MailboxVideoFrameDataPtr& input) {
    return input->ycbcr_data;
  }

  static bool Read(::media::mojom::MailboxVideoFrameData::DataView input, ::media::mojom::MailboxVideoFrameDataPtr* output);
};


template <>
struct  StructTraits<::media::mojom::PipelineStatistics::DataView,
                                         ::media::mojom::PipelineStatisticsPtr> {
  static bool IsNull(const ::media::mojom::PipelineStatisticsPtr& input) { return !input; }
  static void SetToNull(::media::mojom::PipelineStatisticsPtr* output) { output->reset(); }

  static decltype(::media::mojom::PipelineStatistics::audio_bytes_decoded) audio_bytes_decoded(
      const ::media::mojom::PipelineStatisticsPtr& input) {
    return input->audio_bytes_decoded;
  }

  static decltype(::media::mojom::PipelineStatistics::video_bytes_decoded) video_bytes_decoded(
      const ::media::mojom::PipelineStatisticsPtr& input) {
    return input->video_bytes_decoded;
  }

  static decltype(::media::mojom::PipelineStatistics::video_frames_decoded) video_frames_decoded(
      const ::media::mojom::PipelineStatisticsPtr& input) {
    return input->video_frames_decoded;
  }

  static decltype(::media::mojom::PipelineStatistics::video_frames_dropped) video_frames_dropped(
      const ::media::mojom::PipelineStatisticsPtr& input) {
    return input->video_frames_dropped;
  }

  static decltype(::media::mojom::PipelineStatistics::audio_memory_usage) audio_memory_usage(
      const ::media::mojom::PipelineStatisticsPtr& input) {
    return input->audio_memory_usage;
  }

  static decltype(::media::mojom::PipelineStatistics::video_memory_usage) video_memory_usage(
      const ::media::mojom::PipelineStatisticsPtr& input) {
    return input->video_memory_usage;
  }

  static bool Read(::media::mojom::PipelineStatistics::DataView input, ::media::mojom::PipelineStatisticsPtr* output);
};


template <>
struct  StructTraits<::media::mojom::PredictionFeatures::DataView,
                                         ::media::mojom::PredictionFeaturesPtr> {
  static bool IsNull(const ::media::mojom::PredictionFeaturesPtr& input) { return !input; }
  static void SetToNull(::media::mojom::PredictionFeaturesPtr* output) { output->reset(); }

  static decltype(::media::mojom::PredictionFeatures::profile) profile(
      const ::media::mojom::PredictionFeaturesPtr& input) {
    return input->profile;
  }

  static const decltype(::media::mojom::PredictionFeatures::video_size)& video_size(
      const ::media::mojom::PredictionFeaturesPtr& input) {
    return input->video_size;
  }

  static decltype(::media::mojom::PredictionFeatures::frames_per_sec) frames_per_sec(
      const ::media::mojom::PredictionFeaturesPtr& input) {
    return input->frames_per_sec;
  }

  static const decltype(::media::mojom::PredictionFeatures::key_system)& key_system(
      const ::media::mojom::PredictionFeaturesPtr& input) {
    return input->key_system;
  }

  static decltype(::media::mojom::PredictionFeatures::use_hw_secure_codecs) use_hw_secure_codecs(
      const ::media::mojom::PredictionFeaturesPtr& input) {
    return input->use_hw_secure_codecs;
  }

  static bool Read(::media::mojom::PredictionFeatures::DataView input, ::media::mojom::PredictionFeaturesPtr* output);
};


template <>
struct  StructTraits<::media::mojom::PredictionTargets::DataView,
                                         ::media::mojom::PredictionTargetsPtr> {
  static bool IsNull(const ::media::mojom::PredictionTargetsPtr& input) { return !input; }
  static void SetToNull(::media::mojom::PredictionTargetsPtr* output) { output->reset(); }

  static decltype(::media::mojom::PredictionTargets::frames_decoded) frames_decoded(
      const ::media::mojom::PredictionTargetsPtr& input) {
    return input->frames_decoded;
  }

  static decltype(::media::mojom::PredictionTargets::frames_dropped) frames_dropped(
      const ::media::mojom::PredictionTargetsPtr& input) {
    return input->frames_dropped;
  }

  static decltype(::media::mojom::PredictionTargets::frames_power_efficient) frames_power_efficient(
      const ::media::mojom::PredictionTargetsPtr& input) {
    return input->frames_power_efficient;
  }

  static bool Read(::media::mojom::PredictionTargets::DataView input, ::media::mojom::PredictionTargetsPtr* output);
};


template <>
struct  StructTraits<::media::mojom::AudioPipelineInfo::DataView,
                                         ::media::mojom::AudioPipelineInfoPtr> {
  static bool IsNull(const ::media::mojom::AudioPipelineInfoPtr& input) { return !input; }
  static void SetToNull(::media::mojom::AudioPipelineInfoPtr* output) { output->reset(); }

  static decltype(::media::mojom::AudioPipelineInfo::decoder_type) decoder_type(
      const ::media::mojom::AudioPipelineInfoPtr& input) {
    return input->decoder_type;
  }

  static decltype(::media::mojom::AudioPipelineInfo::is_platform_decoder) is_platform_decoder(
      const ::media::mojom::AudioPipelineInfoPtr& input) {
    return input->is_platform_decoder;
  }

  static decltype(::media::mojom::AudioPipelineInfo::has_decrypting_demuxer_stream) has_decrypting_demuxer_stream(
      const ::media::mojom::AudioPipelineInfoPtr& input) {
    return input->has_decrypting_demuxer_stream;
  }

  static decltype(::media::mojom::AudioPipelineInfo::encryption_type) encryption_type(
      const ::media::mojom::AudioPipelineInfoPtr& input) {
    return input->encryption_type;
  }

  static bool Read(::media::mojom::AudioPipelineInfo::DataView input, ::media::mojom::AudioPipelineInfoPtr* output);
};


template <>
struct  StructTraits<::media::mojom::VideoPipelineInfo::DataView,
                                         ::media::mojom::VideoPipelineInfoPtr> {
  static bool IsNull(const ::media::mojom::VideoPipelineInfoPtr& input) { return !input; }
  static void SetToNull(::media::mojom::VideoPipelineInfoPtr* output) { output->reset(); }

  static decltype(::media::mojom::VideoPipelineInfo::decoder_type) decoder_type(
      const ::media::mojom::VideoPipelineInfoPtr& input) {
    return input->decoder_type;
  }

  static decltype(::media::mojom::VideoPipelineInfo::is_platform_decoder) is_platform_decoder(
      const ::media::mojom::VideoPipelineInfoPtr& input) {
    return input->is_platform_decoder;
  }

  static decltype(::media::mojom::VideoPipelineInfo::has_decrypting_demuxer_stream) has_decrypting_demuxer_stream(
      const ::media::mojom::VideoPipelineInfoPtr& input) {
    return input->has_decrypting_demuxer_stream;
  }

  static decltype(::media::mojom::VideoPipelineInfo::encryption_type) encryption_type(
      const ::media::mojom::VideoPipelineInfoPtr& input) {
    return input->encryption_type;
  }

  static bool Read(::media::mojom::VideoPipelineInfo::DataView input, ::media::mojom::VideoPipelineInfoPtr* output);
};


template <>
struct  StructTraits<::media::mojom::StatusData::DataView,
                                         ::media::mojom::StatusDataPtr> {
  static bool IsNull(const ::media::mojom::StatusDataPtr& input) { return !input; }
  static void SetToNull(::media::mojom::StatusDataPtr* output) { output->reset(); }

  static const decltype(::media::mojom::StatusData::group)& group(
      const ::media::mojom::StatusDataPtr& input) {
    return input->group;
  }

  static decltype(::media::mojom::StatusData::code) code(
      const ::media::mojom::StatusDataPtr& input) {
    return input->code;
  }

  static const decltype(::media::mojom::StatusData::message)& message(
      const ::media::mojom::StatusDataPtr& input) {
    return input->message;
  }

  static const decltype(::media::mojom::StatusData::frames)& frames(
      const ::media::mojom::StatusDataPtr& input) {
    return input->frames;
  }

  static const decltype(::media::mojom::StatusData::cause)& cause(
      const ::media::mojom::StatusDataPtr& input) {
    return input->cause;
  }

  static const decltype(::media::mojom::StatusData::data)& data(
      const ::media::mojom::StatusDataPtr& input) {
    return input->data;
  }

  static decltype(::media::mojom::StatusData::packed_root_cause) packed_root_cause(
      const ::media::mojom::StatusDataPtr& input) {
    return input->packed_root_cause;
  }

  static bool Read(::media::mojom::StatusData::DataView input, ::media::mojom::StatusDataPtr* output);
};


template <>
struct  StructTraits<::media::mojom::EncoderStatus::DataView,
                                         ::media::mojom::EncoderStatusPtr> {
  static bool IsNull(const ::media::mojom::EncoderStatusPtr& input) { return !input; }
  static void SetToNull(::media::mojom::EncoderStatusPtr* output) { output->reset(); }

  static const decltype(::media::mojom::EncoderStatus::internal)& internal(
      const ::media::mojom::EncoderStatusPtr& input) {
    return input->internal;
  }

  static bool Read(::media::mojom::EncoderStatus::DataView input, ::media::mojom::EncoderStatusPtr* output);
};


template <>
struct  StructTraits<::media::mojom::DecoderStatus::DataView,
                                         ::media::mojom::DecoderStatusPtr> {
  static bool IsNull(const ::media::mojom::DecoderStatusPtr& input) { return !input; }
  static void SetToNull(::media::mojom::DecoderStatusPtr* output) { output->reset(); }

  static const decltype(::media::mojom::DecoderStatus::internal)& internal(
      const ::media::mojom::DecoderStatusPtr& input) {
    return input->internal;
  }

  static bool Read(::media::mojom::DecoderStatus::DataView input, ::media::mojom::DecoderStatusPtr* output);
};


template <>
struct  StructTraits<::media::mojom::PipelineStatus::DataView,
                                         ::media::mojom::PipelineStatusPtr> {
  static bool IsNull(const ::media::mojom::PipelineStatusPtr& input) { return !input; }
  static void SetToNull(::media::mojom::PipelineStatusPtr* output) { output->reset(); }

  static const decltype(::media::mojom::PipelineStatus::internal)& internal(
      const ::media::mojom::PipelineStatusPtr& input) {
    return input->internal;
  }

  static bool Read(::media::mojom::PipelineStatus::DataView input, ::media::mojom::PipelineStatusPtr* output);
};


template <>
struct  UnionTraits<::media::mojom::VideoFrameData::DataView,
                                        ::media::mojom::VideoFrameDataPtr> {
  static bool IsNull(const ::media::mojom::VideoFrameDataPtr& input) { return !input; }
  static void SetToNull(::media::mojom::VideoFrameDataPtr* output) { output->reset(); }

  static ::media::mojom::VideoFrameData::Tag GetTag(const ::media::mojom::VideoFrameDataPtr& input) {
    return input->which();
  }

  static const ::media::mojom::EosVideoFrameDataPtr& eos_data(const ::media::mojom::VideoFrameDataPtr& input) {
    return input->get_eos_data();
  }

  static  ::media::mojom::SharedBufferVideoFrameDataPtr& shared_buffer_data( ::media::mojom::VideoFrameDataPtr& input) {
    return input->get_shared_buffer_data();
  }

  static  ::media::mojom::GpuMemoryBufferVideoFrameDataPtr& gpu_memory_buffer_data( ::media::mojom::VideoFrameDataPtr& input) {
    return input->get_gpu_memory_buffer_data();
  }

  static const ::media::mojom::MailboxVideoFrameDataPtr& mailbox_data(const ::media::mojom::VideoFrameDataPtr& input) {
    return input->get_mailbox_data();
  }

  static bool Read(::media::mojom::VideoFrameData::DataView input, ::media::mojom::VideoFrameDataPtr* output);
};

}  // namespace mojo

#endif  // MEDIA_MOJO_MOJOM_MEDIA_TYPES_MOJOM_H_