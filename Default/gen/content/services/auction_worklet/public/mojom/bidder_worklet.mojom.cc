// content/services/auction_worklet/public/mojom/bidder_worklet.mojom.cc is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2013 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#if defined(__clang__)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-private-field"
#endif

#include "content/services/auction_worklet/public/mojom/bidder_worklet.mojom.h"

#include <math.h>
#include <stdint.h>
#include <utility>

#include "base/debug/alias.h"
#include "base/hash/md5_constexpr.h"
#include "base/run_loop.h"
#include "base/strings/string_number_conversions.h"
#include "base/trace_event/trace_event.h"
#include "base/trace_event/typed_macros.h"
#include "mojo/public/cpp/bindings/lib/generated_code_util.h"
#include "mojo/public/cpp/bindings/lib/message_internal.h"
#include "mojo/public/cpp/bindings/lib/send_message_helper.h"
#include "mojo/public/cpp/bindings/lib/proxy_to_responder.h"
#include "mojo/public/cpp/bindings/lib/serialization_util.h"
#include "mojo/public/cpp/bindings/lib/unserialized_message_context.h"
#include "mojo/public/cpp/bindings/lib/validate_params.h"
#include "mojo/public/cpp/bindings/lib/validation_errors.h"
#include "mojo/public/cpp/bindings/mojo_buildflags.h"
#include "mojo/public/interfaces/bindings/interface_control_messages.mojom.h"
#include "third_party/perfetto/include/perfetto/tracing/traced_value.h"

#include "content/services/auction_worklet/public/mojom/bidder_worklet.mojom-params-data.h"
#include "content/services/auction_worklet/public/mojom/bidder_worklet.mojom-shared-message-ids.h"

#include "content/services/auction_worklet/public/mojom/bidder_worklet.mojom-import-headers.h"
#include "content/services/auction_worklet/public/mojom/bidder_worklet.mojom-test-utils.h"


#ifndef CONTENT_SERVICES_AUCTION_WORKLET_PUBLIC_MOJOM_BIDDER_WORKLET_MOJOM_JUMBO_H_
#define CONTENT_SERVICES_AUCTION_WORKLET_PUBLIC_MOJOM_BIDDER_WORKLET_MOJOM_JUMBO_H_
#endif



namespace auction_worklet {
namespace mojom {
PreviousWin::PreviousWin()
    : time(),
      ad_json() {}

PreviousWin::PreviousWin(
    ::base::Time time_in,
    const std::string& ad_json_in)
    : time(std::move(time_in)),
      ad_json(std::move(ad_json_in)) {}

PreviousWin::~PreviousWin() = default;

void PreviousWin::WriteIntoTrace(
    perfetto::TracedValue traced_context) const {
  [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "time"), this->time,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type ::base::Time>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "ad_json"), this->ad_json,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const std::string&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool PreviousWin::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
BidderWorkletNonSharedParams::BidderWorkletNonSharedParams()
    : name(),
      execution_mode(),
      daily_update_url(),
      trusted_bidding_signals_keys(),
      user_bidding_signals(),
      ads(),
      ad_components() {}

BidderWorkletNonSharedParams::BidderWorkletNonSharedParams(
    const std::string& name_in,
    ::blink::mojom::InterestGroup::ExecutionMode execution_mode_in,
    const absl::optional<::GURL>& daily_update_url_in,
    absl::optional<std::vector<std::string>> trusted_bidding_signals_keys_in,
    const absl::optional<std::string>& user_bidding_signals_in,
    absl::optional<std::vector<::blink::InterestGroup::Ad>> ads_in,
    absl::optional<std::vector<::blink::InterestGroup::Ad>> ad_components_in)
    : name(std::move(name_in)),
      execution_mode(std::move(execution_mode_in)),
      daily_update_url(std::move(daily_update_url_in)),
      trusted_bidding_signals_keys(std::move(trusted_bidding_signals_keys_in)),
      user_bidding_signals(std::move(user_bidding_signals_in)),
      ads(std::move(ads_in)),
      ad_components(std::move(ad_components_in)) {}

BidderWorkletNonSharedParams::~BidderWorkletNonSharedParams() = default;

void BidderWorkletNonSharedParams::WriteIntoTrace(
    perfetto::TracedValue traced_context) const {
  [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "name"), this->name,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const std::string&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "execution_mode"), this->execution_mode,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type ::blink::mojom::InterestGroup::ExecutionMode>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "daily_update_url"), this->daily_update_url,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const absl::optional<::GURL>&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "trusted_bidding_signals_keys"), this->trusted_bidding_signals_keys,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const absl::optional<std::vector<std::string>>&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "user_bidding_signals"), this->user_bidding_signals,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const absl::optional<std::string>&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "ads"), this->ads,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const absl::optional<std::vector<::blink::InterestGroup::Ad>>&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "ad_components"), this->ad_components,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const absl::optional<std::vector<::blink::InterestGroup::Ad>>&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool BidderWorkletNonSharedParams::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
BiddingBrowserSignals::BiddingBrowserSignals()
    : join_count(),
      bid_count(),
      prev_wins() {}

BiddingBrowserSignals::BiddingBrowserSignals(
    int32_t join_count_in,
    int32_t bid_count_in,
    std::vector<PreviousWinPtr> prev_wins_in)
    : join_count(std::move(join_count_in)),
      bid_count(std::move(bid_count_in)),
      prev_wins(std::move(prev_wins_in)) {}

BiddingBrowserSignals::~BiddingBrowserSignals() = default;

void BiddingBrowserSignals::WriteIntoTrace(
    perfetto::TracedValue traced_context) const {
  [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "join_count"), this->join_count,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type int32_t>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "bid_count"), this->bid_count,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type int32_t>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "prev_wins"), this->prev_wins,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type std::vector<PreviousWinPtr>>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool BiddingBrowserSignals::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
BidderWorkletBid::BidderWorkletBid()
    : ad(),
      bid(),
      render_url(),
      ad_components(),
      bid_duration() {}

BidderWorkletBid::BidderWorkletBid(
    const std::string& ad_in,
    double bid_in,
    const ::GURL& render_url_in,
    absl::optional<std::vector<::GURL>> ad_components_in,
    ::base::TimeDelta bid_duration_in)
    : ad(std::move(ad_in)),
      bid(std::move(bid_in)),
      render_url(std::move(render_url_in)),
      ad_components(std::move(ad_components_in)),
      bid_duration(std::move(bid_duration_in)) {}

BidderWorkletBid::~BidderWorkletBid() = default;

void BidderWorkletBid::WriteIntoTrace(
    perfetto::TracedValue traced_context) const {
  [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "ad"), this->ad,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const std::string&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "bid"), this->bid,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type double>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "render_url"), this->render_url,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const ::GURL&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "ad_components"), this->ad_components,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const absl::optional<std::vector<::GURL>>&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "bid_duration"), this->bid_duration,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type ::base::TimeDelta>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool BidderWorkletBid::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
const char BidderWorklet::Name_[] = "auction_worklet.mojom.BidderWorklet";

BidderWorklet::IPCStableHashFunction BidderWorklet::MessageToMethodInfo_(mojo::Message& message) {
#if !BUILDFLAG(IS_FUCHSIA)
  switch (message.name()) {
    case internal::kBidderWorklet_GenerateBid_Name: {
      return &BidderWorklet::GenerateBid_Sym::IPCStableHash;
    }
    case internal::kBidderWorklet_SendPendingSignalsRequests_Name: {
      return &BidderWorklet::SendPendingSignalsRequests_Sym::IPCStableHash;
    }
    case internal::kBidderWorklet_ReportWin_Name: {
      return &BidderWorklet::ReportWin_Sym::IPCStableHash;
    }
    case internal::kBidderWorklet_ConnectDevToolsAgent_Name: {
      return &BidderWorklet::ConnectDevToolsAgent_Sym::IPCStableHash;
    }
  }
#endif  // !BUILDFLAG(IS_FUCHSIA)
  return nullptr;
}


const char* BidderWorklet::MessageToMethodName_(mojo::Message& message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  bool is_response = message.has_flag(mojo::Message::kFlagIsResponse);
  if (!is_response) {
    switch (message.name()) {
      case internal::kBidderWorklet_GenerateBid_Name:
            return "Receive auction_worklet::mojom::BidderWorklet::GenerateBid";
      case internal::kBidderWorklet_SendPendingSignalsRequests_Name:
            return "Receive auction_worklet::mojom::BidderWorklet::SendPendingSignalsRequests";
      case internal::kBidderWorklet_ReportWin_Name:
            return "Receive auction_worklet::mojom::BidderWorklet::ReportWin";
      case internal::kBidderWorklet_ConnectDevToolsAgent_Name:
            return "Receive auction_worklet::mojom::BidderWorklet::ConnectDevToolsAgent";
    }
  } else {
    switch (message.name()) {
      case internal::kBidderWorklet_GenerateBid_Name:
            return "Receive reply auction_worklet::mojom::BidderWorklet::GenerateBid";
      case internal::kBidderWorklet_SendPendingSignalsRequests_Name:
            return "Receive reply auction_worklet::mojom::BidderWorklet::SendPendingSignalsRequests";
      case internal::kBidderWorklet_ReportWin_Name:
            return "Receive reply auction_worklet::mojom::BidderWorklet::ReportWin";
      case internal::kBidderWorklet_ConnectDevToolsAgent_Name:
            return "Receive reply auction_worklet::mojom::BidderWorklet::ConnectDevToolsAgent";
    }
  }
  return "Receive unknown mojo message";
#else
  bool is_response = message.has_flag(mojo::Message::kFlagIsResponse);
  if (is_response) {
    return "Receive mojo reply";
  } else {
    return "Receive mojo message";
  }
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
}

#if !BUILDFLAG(IS_FUCHSIA)
uint32_t BidderWorklet::GenerateBid_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)auction_worklet::mojom::BidderWorklet::GenerateBid");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t BidderWorklet::SendPendingSignalsRequests_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)auction_worklet::mojom::BidderWorklet::SendPendingSignalsRequests");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t BidderWorklet::ReportWin_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)auction_worklet::mojom::BidderWorklet::ReportWin");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t BidderWorklet::ConnectDevToolsAgent_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)auction_worklet::mojom::BidderWorklet::ConnectDevToolsAgent");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
# endif // !BUILDFLAG(IS_FUCHSIA)

class BidderWorklet_GenerateBid_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  BidderWorklet_GenerateBid_ForwardToCallback(
      BidderWorklet::GenerateBidCallback callback
      ) : callback_(std::move(callback)) {
  }

  BidderWorklet_GenerateBid_ForwardToCallback(const BidderWorklet_GenerateBid_ForwardToCallback&) = delete;
  BidderWorklet_GenerateBid_ForwardToCallback& operator=(const BidderWorklet_GenerateBid_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  BidderWorklet::GenerateBidCallback callback_;
};

class BidderWorklet_ReportWin_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  BidderWorklet_ReportWin_ForwardToCallback(
      BidderWorklet::ReportWinCallback callback
      ) : callback_(std::move(callback)) {
  }

  BidderWorklet_ReportWin_ForwardToCallback(const BidderWorklet_ReportWin_ForwardToCallback&) = delete;
  BidderWorklet_ReportWin_ForwardToCallback& operator=(const BidderWorklet_ReportWin_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  BidderWorklet::ReportWinCallback callback_;
};

BidderWorkletProxy::BidderWorkletProxy(mojo::MessageReceiverWithResponder* receiver)
    : receiver_(receiver) {
}

void BidderWorkletProxy::GenerateBid(
    BidderWorkletNonSharedParamsPtr in_bidder_worklet_non_shared_params, const ::url::Origin& in_interest_group_join_origin, const absl::optional<std::string>& in_auction_signals_json, const absl::optional<std::string>& in_per_buyer_signals_json, absl::optional<::base::TimeDelta> in_per_buyer_timeout, const ::url::Origin& in_browser_signal_seller_origin, const absl::optional<::url::Origin>& in_browser_signal_top_level_seller_origin, BiddingBrowserSignalsPtr in_bidding_browser_signals, ::base::Time in_auction_start_time, uint64_t in_trace_id, GenerateBidCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send auction_worklet::mojom::BidderWorklet::GenerateBid", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("bidder_worklet_non_shared_params"), in_bidder_worklet_non_shared_params,
                        "<value of type BidderWorkletNonSharedParamsPtr>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("interest_group_join_origin"), in_interest_group_join_origin,
                        "<value of type const ::url::Origin&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("auction_signals_json"), in_auction_signals_json,
                        "<value of type const absl::optional<std::string>&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("per_buyer_signals_json"), in_per_buyer_signals_json,
                        "<value of type const absl::optional<std::string>&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("per_buyer_timeout"), in_per_buyer_timeout,
                        "<value of type absl::optional<::base::TimeDelta>>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("browser_signal_seller_origin"), in_browser_signal_seller_origin,
                        "<value of type const ::url::Origin&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("browser_signal_top_level_seller_origin"), in_browser_signal_top_level_seller_origin,
                        "<value of type const absl::optional<::url::Origin>&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("bidding_browser_signals"), in_bidding_browser_signals,
                        "<value of type BiddingBrowserSignalsPtr>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("auction_start_time"), in_auction_start_time,
                        "<value of type ::base::Time>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("trace_id"), in_trace_id,
                        "<value of type uint64_t>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kBidderWorklet_GenerateBid_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::auction_worklet::mojom::internal::BidderWorklet_GenerateBid_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->bidder_worklet_non_shared_params)::BaseType> bidder_worklet_non_shared_params_fragment(
          params.message());
  mojo::internal::Serialize<::auction_worklet::mojom::BidderWorkletNonSharedParamsDataView>(
      in_bidder_worklet_non_shared_params, bidder_worklet_non_shared_params_fragment);
  params->bidder_worklet_non_shared_params.Set(
      bidder_worklet_non_shared_params_fragment.is_null() ? nullptr : bidder_worklet_non_shared_params_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->bidder_worklet_non_shared_params.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null bidder_worklet_non_shared_params in BidderWorklet.GenerateBid request");
  mojo::internal::MessageFragment<
      typename decltype(params->interest_group_join_origin)::BaseType> interest_group_join_origin_fragment(
          params.message());
  mojo::internal::Serialize<::url::mojom::OriginDataView>(
      in_interest_group_join_origin, interest_group_join_origin_fragment);
  params->interest_group_join_origin.Set(
      interest_group_join_origin_fragment.is_null() ? nullptr : interest_group_join_origin_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->interest_group_join_origin.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null interest_group_join_origin in BidderWorklet.GenerateBid request");
  mojo::internal::MessageFragment<
      typename decltype(params->auction_signals_json)::BaseType> auction_signals_json_fragment(
          params.message());
  mojo::internal::Serialize<mojo::StringDataView>(
      in_auction_signals_json, auction_signals_json_fragment);
  params->auction_signals_json.Set(
      auction_signals_json_fragment.is_null() ? nullptr : auction_signals_json_fragment.data());
  mojo::internal::MessageFragment<
      typename decltype(params->per_buyer_signals_json)::BaseType> per_buyer_signals_json_fragment(
          params.message());
  mojo::internal::Serialize<mojo::StringDataView>(
      in_per_buyer_signals_json, per_buyer_signals_json_fragment);
  params->per_buyer_signals_json.Set(
      per_buyer_signals_json_fragment.is_null() ? nullptr : per_buyer_signals_json_fragment.data());
  mojo::internal::MessageFragment<
      typename decltype(params->per_buyer_timeout)::BaseType> per_buyer_timeout_fragment(
          params.message());
  mojo::internal::Serialize<::mojo_base::mojom::TimeDeltaDataView>(
      in_per_buyer_timeout, per_buyer_timeout_fragment);
  params->per_buyer_timeout.Set(
      per_buyer_timeout_fragment.is_null() ? nullptr : per_buyer_timeout_fragment.data());
  mojo::internal::MessageFragment<
      typename decltype(params->browser_signal_seller_origin)::BaseType> browser_signal_seller_origin_fragment(
          params.message());
  mojo::internal::Serialize<::url::mojom::OriginDataView>(
      in_browser_signal_seller_origin, browser_signal_seller_origin_fragment);
  params->browser_signal_seller_origin.Set(
      browser_signal_seller_origin_fragment.is_null() ? nullptr : browser_signal_seller_origin_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->browser_signal_seller_origin.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null browser_signal_seller_origin in BidderWorklet.GenerateBid request");
  mojo::internal::MessageFragment<
      typename decltype(params->browser_signal_top_level_seller_origin)::BaseType> browser_signal_top_level_seller_origin_fragment(
          params.message());
  mojo::internal::Serialize<::url::mojom::OriginDataView>(
      in_browser_signal_top_level_seller_origin, browser_signal_top_level_seller_origin_fragment);
  params->browser_signal_top_level_seller_origin.Set(
      browser_signal_top_level_seller_origin_fragment.is_null() ? nullptr : browser_signal_top_level_seller_origin_fragment.data());
  mojo::internal::MessageFragment<
      typename decltype(params->bidding_browser_signals)::BaseType> bidding_browser_signals_fragment(
          params.message());
  mojo::internal::Serialize<::auction_worklet::mojom::BiddingBrowserSignalsDataView>(
      in_bidding_browser_signals, bidding_browser_signals_fragment);
  params->bidding_browser_signals.Set(
      bidding_browser_signals_fragment.is_null() ? nullptr : bidding_browser_signals_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->bidding_browser_signals.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null bidding_browser_signals in BidderWorklet.GenerateBid request");
  mojo::internal::MessageFragment<
      typename decltype(params->auction_start_time)::BaseType> auction_start_time_fragment(
          params.message());
  mojo::internal::Serialize<::mojo_base::mojom::TimeDataView>(
      in_auction_start_time, auction_start_time_fragment);
  params->auction_start_time.Set(
      auction_start_time_fragment.is_null() ? nullptr : auction_start_time_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->auction_start_time.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null auction_start_time in BidderWorklet.GenerateBid request");
  params->trace_id = in_trace_id;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(BidderWorklet::Name_);
  message.set_method_name("GenerateBid");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new BidderWorklet_GenerateBid_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void BidderWorkletProxy::SendPendingSignalsRequests(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send auction_worklet::mojom::BidderWorklet::SendPendingSignalsRequests");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kBidderWorklet_SendPendingSignalsRequests_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::auction_worklet::mojom::internal::BidderWorklet_SendPendingSignalsRequests_Params_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(BidderWorklet::Name_);
  message.set_method_name("SendPendingSignalsRequests");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void BidderWorkletProxy::ReportWin(
    const std::string& in_interest_group_name, const absl::optional<std::string>& in_auction_signals_json, const absl::optional<std::string>& in_per_buyer_signals_json, const std::string& in_seller_signals_json, const ::GURL& in_browser_signal_render_url, double in_browser_signal_bid, double in_browser_signal_highest_scoring_other_bid, bool in_browser_signal_made_highest_scoring_other_bid, const ::url::Origin& in_browser_signal_seller_origin, const absl::optional<::url::Origin>& in_browser_signal_top_level_seller_origin, uint32_t in_bidding_signals_data_version, bool in_has_bidding_signals_data_version, uint64_t in_trace_id, ReportWinCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send auction_worklet::mojom::BidderWorklet::ReportWin", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("interest_group_name"), in_interest_group_name,
                        "<value of type const std::string&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("auction_signals_json"), in_auction_signals_json,
                        "<value of type const absl::optional<std::string>&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("per_buyer_signals_json"), in_per_buyer_signals_json,
                        "<value of type const absl::optional<std::string>&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("seller_signals_json"), in_seller_signals_json,
                        "<value of type const std::string&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("browser_signal_render_url"), in_browser_signal_render_url,
                        "<value of type const ::GURL&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("browser_signal_bid"), in_browser_signal_bid,
                        "<value of type double>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("browser_signal_highest_scoring_other_bid"), in_browser_signal_highest_scoring_other_bid,
                        "<value of type double>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("browser_signal_made_highest_scoring_other_bid"), in_browser_signal_made_highest_scoring_other_bid,
                        "<value of type bool>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("browser_signal_seller_origin"), in_browser_signal_seller_origin,
                        "<value of type const ::url::Origin&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("browser_signal_top_level_seller_origin"), in_browser_signal_top_level_seller_origin,
                        "<value of type const absl::optional<::url::Origin>&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("bidding_signals_data_version"), in_bidding_signals_data_version,
                        "<value of type uint32_t>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("has_bidding_signals_data_version"), in_has_bidding_signals_data_version,
                        "<value of type bool>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("trace_id"), in_trace_id,
                        "<value of type uint64_t>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kBidderWorklet_ReportWin_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::auction_worklet::mojom::internal::BidderWorklet_ReportWin_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->interest_group_name)::BaseType> interest_group_name_fragment(
          params.message());
  mojo::internal::Serialize<mojo::StringDataView>(
      in_interest_group_name, interest_group_name_fragment);
  params->interest_group_name.Set(
      interest_group_name_fragment.is_null() ? nullptr : interest_group_name_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->interest_group_name.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null interest_group_name in BidderWorklet.ReportWin request");
  mojo::internal::MessageFragment<
      typename decltype(params->auction_signals_json)::BaseType> auction_signals_json_fragment(
          params.message());
  mojo::internal::Serialize<mojo::StringDataView>(
      in_auction_signals_json, auction_signals_json_fragment);
  params->auction_signals_json.Set(
      auction_signals_json_fragment.is_null() ? nullptr : auction_signals_json_fragment.data());
  mojo::internal::MessageFragment<
      typename decltype(params->per_buyer_signals_json)::BaseType> per_buyer_signals_json_fragment(
          params.message());
  mojo::internal::Serialize<mojo::StringDataView>(
      in_per_buyer_signals_json, per_buyer_signals_json_fragment);
  params->per_buyer_signals_json.Set(
      per_buyer_signals_json_fragment.is_null() ? nullptr : per_buyer_signals_json_fragment.data());
  mojo::internal::MessageFragment<
      typename decltype(params->seller_signals_json)::BaseType> seller_signals_json_fragment(
          params.message());
  mojo::internal::Serialize<mojo::StringDataView>(
      in_seller_signals_json, seller_signals_json_fragment);
  params->seller_signals_json.Set(
      seller_signals_json_fragment.is_null() ? nullptr : seller_signals_json_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->seller_signals_json.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null seller_signals_json in BidderWorklet.ReportWin request");
  mojo::internal::MessageFragment<
      typename decltype(params->browser_signal_render_url)::BaseType> browser_signal_render_url_fragment(
          params.message());
  mojo::internal::Serialize<::url::mojom::UrlDataView>(
      in_browser_signal_render_url, browser_signal_render_url_fragment);
  params->browser_signal_render_url.Set(
      browser_signal_render_url_fragment.is_null() ? nullptr : browser_signal_render_url_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->browser_signal_render_url.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null browser_signal_render_url in BidderWorklet.ReportWin request");
  params->browser_signal_bid = in_browser_signal_bid;
  params->browser_signal_highest_scoring_other_bid = in_browser_signal_highest_scoring_other_bid;
  params->browser_signal_made_highest_scoring_other_bid = in_browser_signal_made_highest_scoring_other_bid;
  mojo::internal::MessageFragment<
      typename decltype(params->browser_signal_seller_origin)::BaseType> browser_signal_seller_origin_fragment(
          params.message());
  mojo::internal::Serialize<::url::mojom::OriginDataView>(
      in_browser_signal_seller_origin, browser_signal_seller_origin_fragment);
  params->browser_signal_seller_origin.Set(
      browser_signal_seller_origin_fragment.is_null() ? nullptr : browser_signal_seller_origin_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->browser_signal_seller_origin.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null browser_signal_seller_origin in BidderWorklet.ReportWin request");
  mojo::internal::MessageFragment<
      typename decltype(params->browser_signal_top_level_seller_origin)::BaseType> browser_signal_top_level_seller_origin_fragment(
          params.message());
  mojo::internal::Serialize<::url::mojom::OriginDataView>(
      in_browser_signal_top_level_seller_origin, browser_signal_top_level_seller_origin_fragment);
  params->browser_signal_top_level_seller_origin.Set(
      browser_signal_top_level_seller_origin_fragment.is_null() ? nullptr : browser_signal_top_level_seller_origin_fragment.data());
  params->bidding_signals_data_version = in_bidding_signals_data_version;
  params->has_bidding_signals_data_version = in_has_bidding_signals_data_version;
  params->trace_id = in_trace_id;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(BidderWorklet::Name_);
  message.set_method_name("ReportWin");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new BidderWorklet_ReportWin_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void BidderWorkletProxy::ConnectDevToolsAgent(
    ::mojo::PendingAssociatedReceiver<::blink::mojom::DevToolsAgent> in_agent) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send auction_worklet::mojom::BidderWorklet::ConnectDevToolsAgent", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("agent"), in_agent,
                        "<value of type ::mojo::PendingAssociatedReceiver<::blink::mojom::DevToolsAgent>>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kBidderWorklet_ConnectDevToolsAgent_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::auction_worklet::mojom::internal::BidderWorklet_ConnectDevToolsAgent_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::Serialize<::blink::mojom::DevToolsAgentAssociatedRequestDataView>(
      in_agent, &params->agent, &params.message());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      !mojo::internal::IsHandleOrInterfaceValid(params->agent),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_INVALID_INTERFACE_ID,
      "invalid agent in BidderWorklet.ConnectDevToolsAgent request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(BidderWorklet::Name_);
  message.set_method_name("ConnectDevToolsAgent");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}
class BidderWorklet_GenerateBid_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static BidderWorklet::GenerateBidCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<BidderWorklet_GenerateBid_ProxyToResponder> proxy(
        new BidderWorklet_GenerateBid_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&BidderWorklet_GenerateBid_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~BidderWorklet_GenerateBid_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  BidderWorklet_GenerateBid_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "BidderWorklet::GenerateBidCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      BidderWorkletBidPtr in_bid, uint32_t in_bidding_signals_data_version, bool in_has_bidding_signals_data_version, const absl::optional<::GURL>& in_debug_loss_report_url, const absl::optional<::GURL>& in_debug_win_report_url, double in_set_priority, bool in_has_set_priority, std::vector<::auction_worklet::mojom::PrivateAggregationRequestPtr> in_pa_requests, const std::vector<std::string>& in_errors);
};

bool BidderWorklet_GenerateBid_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::BidderWorklet_GenerateBid_ResponseParams_Data* params =
      reinterpret_cast<
          internal::BidderWorklet_GenerateBid_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  BidderWorkletBidPtr p_bid{};
  uint32_t p_bidding_signals_data_version{};
  bool p_has_bidding_signals_data_version{};
  absl::optional<::GURL> p_debug_loss_report_url{};
  absl::optional<::GURL> p_debug_win_report_url{};
  double p_set_priority{};
  bool p_has_set_priority{};
  std::vector<::auction_worklet::mojom::PrivateAggregationRequestPtr> p_pa_requests{};
  std::vector<std::string> p_errors{};
  BidderWorklet_GenerateBid_ResponseParamsDataView input_data_view(params, message);
  
  if (success && !input_data_view.ReadBid(&p_bid))
    success = false;
  if (success)
    p_bidding_signals_data_version = input_data_view.bidding_signals_data_version();
  if (success)
    p_has_bidding_signals_data_version = input_data_view.has_bidding_signals_data_version();
  if (success && !input_data_view.ReadDebugLossReportUrl(&p_debug_loss_report_url))
    success = false;
  if (success && !input_data_view.ReadDebugWinReportUrl(&p_debug_win_report_url))
    success = false;
  if (success)
    p_set_priority = input_data_view.set_priority();
  if (success)
    p_has_set_priority = input_data_view.has_set_priority();
  if (success && !input_data_view.ReadPaRequests(&p_pa_requests))
    success = false;
  if (success && !input_data_view.ReadErrors(&p_errors))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        BidderWorklet::Name_, 0, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_bid), 
std::move(p_bidding_signals_data_version), 
std::move(p_has_bidding_signals_data_version), 
std::move(p_debug_loss_report_url), 
std::move(p_debug_win_report_url), 
std::move(p_set_priority), 
std::move(p_has_set_priority), 
std::move(p_pa_requests), 
std::move(p_errors));
  return true;
}

void BidderWorklet_GenerateBid_ProxyToResponder::Run(
    BidderWorkletBidPtr in_bid, uint32_t in_bidding_signals_data_version, bool in_has_bidding_signals_data_version, const absl::optional<::GURL>& in_debug_loss_report_url, const absl::optional<::GURL>& in_debug_win_report_url, double in_set_priority, bool in_has_set_priority, std::vector<::auction_worklet::mojom::PrivateAggregationRequestPtr> in_pa_requests, const std::vector<std::string>& in_errors) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send reply auction_worklet::mojom::BidderWorklet::GenerateBid", "async_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("bid"), in_bid,
                        "<value of type BidderWorkletBidPtr>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("bidding_signals_data_version"), in_bidding_signals_data_version,
                        "<value of type uint32_t>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("has_bidding_signals_data_version"), in_has_bidding_signals_data_version,
                        "<value of type bool>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("debug_loss_report_url"), in_debug_loss_report_url,
                        "<value of type const absl::optional<::GURL>&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("debug_win_report_url"), in_debug_win_report_url,
                        "<value of type const absl::optional<::GURL>&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("set_priority"), in_set_priority,
                        "<value of type double>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("has_set_priority"), in_has_set_priority,
                        "<value of type bool>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("pa_requests"), in_pa_requests,
                        "<value of type std::vector<::auction_worklet::mojom::PrivateAggregationRequestPtr>>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("errors"), in_errors,
                        "<value of type const std::vector<std::string>&>");
   });
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kBidderWorklet_GenerateBid_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::auction_worklet::mojom::internal::BidderWorklet_GenerateBid_ResponseParams_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->bid)::BaseType> bid_fragment(
          params.message());
  mojo::internal::Serialize<::auction_worklet::mojom::BidderWorkletBidDataView>(
      in_bid, bid_fragment);
  params->bid.Set(
      bid_fragment.is_null() ? nullptr : bid_fragment.data());
  params->bidding_signals_data_version = in_bidding_signals_data_version;
  params->has_bidding_signals_data_version = in_has_bidding_signals_data_version;
  mojo::internal::MessageFragment<
      typename decltype(params->debug_loss_report_url)::BaseType> debug_loss_report_url_fragment(
          params.message());
  mojo::internal::Serialize<::url::mojom::UrlDataView>(
      in_debug_loss_report_url, debug_loss_report_url_fragment);
  params->debug_loss_report_url.Set(
      debug_loss_report_url_fragment.is_null() ? nullptr : debug_loss_report_url_fragment.data());
  mojo::internal::MessageFragment<
      typename decltype(params->debug_win_report_url)::BaseType> debug_win_report_url_fragment(
          params.message());
  mojo::internal::Serialize<::url::mojom::UrlDataView>(
      in_debug_win_report_url, debug_win_report_url_fragment);
  params->debug_win_report_url.Set(
      debug_win_report_url_fragment.is_null() ? nullptr : debug_win_report_url_fragment.data());
  params->set_priority = in_set_priority;
  params->has_set_priority = in_has_set_priority;
  mojo::internal::MessageFragment<
      typename decltype(params->pa_requests)::BaseType>
      pa_requests_fragment(params.message());
  const mojo::internal::ContainerValidateParams pa_requests_validate_params(
      0, false, nullptr);
  mojo::internal::Serialize<mojo::ArrayDataView<::auction_worklet::mojom::PrivateAggregationRequestDataView>>(
      in_pa_requests, pa_requests_fragment, &pa_requests_validate_params);
  params->pa_requests.Set(
      pa_requests_fragment.is_null() ? nullptr : pa_requests_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->pa_requests.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null pa_requests in ");
  mojo::internal::MessageFragment<
      typename decltype(params->errors)::BaseType>
      errors_fragment(params.message());
  const mojo::internal::ContainerValidateParams errors_validate_params(
      0, false, new mojo::internal::ContainerValidateParams(0, false, nullptr));
  mojo::internal::Serialize<mojo::ArrayDataView<mojo::StringDataView>>(
      in_errors, errors_fragment, &errors_validate_params);
  params->errors.Set(
      errors_fragment.is_null() ? nullptr : errors_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->errors.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null errors in ");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(BidderWorklet::Name_);
  message.set_method_name("GenerateBid");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class BidderWorklet_ReportWin_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static BidderWorklet::ReportWinCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<BidderWorklet_ReportWin_ProxyToResponder> proxy(
        new BidderWorklet_ReportWin_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&BidderWorklet_ReportWin_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~BidderWorklet_ReportWin_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  BidderWorklet_ReportWin_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "BidderWorklet::ReportWinCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      const absl::optional<::GURL>& in_report_url, const base::flat_map<std::string, ::GURL>& in_ad_beacon_map, std::vector<::auction_worklet::mojom::PrivateAggregationRequestPtr> in_pa_requests, const std::vector<std::string>& in_errors);
};

bool BidderWorklet_ReportWin_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::BidderWorklet_ReportWin_ResponseParams_Data* params =
      reinterpret_cast<
          internal::BidderWorklet_ReportWin_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  absl::optional<::GURL> p_report_url{};
  base::flat_map<std::string, ::GURL> p_ad_beacon_map{};
  std::vector<::auction_worklet::mojom::PrivateAggregationRequestPtr> p_pa_requests{};
  std::vector<std::string> p_errors{};
  BidderWorklet_ReportWin_ResponseParamsDataView input_data_view(params, message);
  
  if (success && !input_data_view.ReadReportUrl(&p_report_url))
    success = false;
  if (success && !input_data_view.ReadAdBeaconMap(&p_ad_beacon_map))
    success = false;
  if (success && !input_data_view.ReadPaRequests(&p_pa_requests))
    success = false;
  if (success && !input_data_view.ReadErrors(&p_errors))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        BidderWorklet::Name_, 2, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_report_url), 
std::move(p_ad_beacon_map), 
std::move(p_pa_requests), 
std::move(p_errors));
  return true;
}

void BidderWorklet_ReportWin_ProxyToResponder::Run(
    const absl::optional<::GURL>& in_report_url, const base::flat_map<std::string, ::GURL>& in_ad_beacon_map, std::vector<::auction_worklet::mojom::PrivateAggregationRequestPtr> in_pa_requests, const std::vector<std::string>& in_errors) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send reply auction_worklet::mojom::BidderWorklet::ReportWin", "async_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("report_url"), in_report_url,
                        "<value of type const absl::optional<::GURL>&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("ad_beacon_map"), in_ad_beacon_map,
                        "<value of type const base::flat_map<std::string, ::GURL>&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("pa_requests"), in_pa_requests,
                        "<value of type std::vector<::auction_worklet::mojom::PrivateAggregationRequestPtr>>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("errors"), in_errors,
                        "<value of type const std::vector<std::string>&>");
   });
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kBidderWorklet_ReportWin_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::auction_worklet::mojom::internal::BidderWorklet_ReportWin_ResponseParams_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->report_url)::BaseType> report_url_fragment(
          params.message());
  mojo::internal::Serialize<::url::mojom::UrlDataView>(
      in_report_url, report_url_fragment);
  params->report_url.Set(
      report_url_fragment.is_null() ? nullptr : report_url_fragment.data());
  mojo::internal::MessageFragment<
      typename decltype(params->ad_beacon_map)::BaseType>
      ad_beacon_map_fragment(params.message());
  const mojo::internal::ContainerValidateParams ad_beacon_map_validate_params(
      new mojo::internal::ContainerValidateParams(0, false, new mojo::internal::ContainerValidateParams(0, false, nullptr)), new mojo::internal::ContainerValidateParams(0, false, nullptr));
  mojo::internal::Serialize<mojo::MapDataView<mojo::StringDataView, ::url::mojom::UrlDataView>>(
      in_ad_beacon_map, ad_beacon_map_fragment, &ad_beacon_map_validate_params);
  params->ad_beacon_map.Set(
      ad_beacon_map_fragment.is_null() ? nullptr : ad_beacon_map_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->ad_beacon_map.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null ad_beacon_map in ");
  mojo::internal::MessageFragment<
      typename decltype(params->pa_requests)::BaseType>
      pa_requests_fragment(params.message());
  const mojo::internal::ContainerValidateParams pa_requests_validate_params(
      0, false, nullptr);
  mojo::internal::Serialize<mojo::ArrayDataView<::auction_worklet::mojom::PrivateAggregationRequestDataView>>(
      in_pa_requests, pa_requests_fragment, &pa_requests_validate_params);
  params->pa_requests.Set(
      pa_requests_fragment.is_null() ? nullptr : pa_requests_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->pa_requests.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null pa_requests in ");
  mojo::internal::MessageFragment<
      typename decltype(params->errors)::BaseType>
      errors_fragment(params.message());
  const mojo::internal::ContainerValidateParams errors_validate_params(
      0, false, new mojo::internal::ContainerValidateParams(0, false, nullptr));
  mojo::internal::Serialize<mojo::ArrayDataView<mojo::StringDataView>>(
      in_errors, errors_fragment, &errors_validate_params);
  params->errors.Set(
      errors_fragment.is_null() ? nullptr : errors_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->errors.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null errors in ");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(BidderWorklet::Name_);
  message.set_method_name("ReportWin");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}

// static
bool BidderWorkletStubDispatch::Accept(
    BidderWorklet* impl,
    mojo::Message* message) {
  switch (message->header()->name) {
    case internal::kBidderWorklet_GenerateBid_Name: {
      break;
    }
    case internal::kBidderWorklet_SendPendingSignalsRequests_Name: {

      DCHECK(message->is_serialized());
      internal::BidderWorklet_SendPendingSignalsRequests_Params_Data* params =
          reinterpret_cast<internal::BidderWorklet_SendPendingSignalsRequests_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      BidderWorklet_SendPendingSignalsRequests_ParamsDataView input_data_view(params, message);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            BidderWorklet::Name_, 1, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SendPendingSignalsRequests();
      return true;
    }
    case internal::kBidderWorklet_ReportWin_Name: {
      break;
    }
    case internal::kBidderWorklet_ConnectDevToolsAgent_Name: {

      DCHECK(message->is_serialized());
      internal::BidderWorklet_ConnectDevToolsAgent_Params_Data* params =
          reinterpret_cast<internal::BidderWorklet_ConnectDevToolsAgent_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::mojo::PendingAssociatedReceiver<::blink::mojom::DevToolsAgent> p_agent{};
      BidderWorklet_ConnectDevToolsAgent_ParamsDataView input_data_view(params, message);
      
      if (success) {
        p_agent =
            input_data_view.TakeAgent<decltype(p_agent)>();
      }
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            BidderWorklet::Name_, 3, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->ConnectDevToolsAgent(
std::move(p_agent));
      return true;
    }
  }
  return false;
}

// static
bool BidderWorkletStubDispatch::AcceptWithResponder(
    BidderWorklet* impl,
    mojo::Message* message,
    std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
  [[maybe_unused]] const bool message_is_sync =
      message->has_flag(mojo::Message::kFlagIsSync);
  [[maybe_unused]] const uint64_t request_id = message->request_id();
  switch (message->header()->name) {
    case internal::kBidderWorklet_GenerateBid_Name: {

      internal::BidderWorklet_GenerateBid_Params_Data* params =
          reinterpret_cast<
              internal::BidderWorklet_GenerateBid_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      BidderWorkletNonSharedParamsPtr p_bidder_worklet_non_shared_params{};
      ::url::Origin p_interest_group_join_origin{};
      absl::optional<std::string> p_auction_signals_json{};
      absl::optional<std::string> p_per_buyer_signals_json{};
      absl::optional<::base::TimeDelta> p_per_buyer_timeout{};
      ::url::Origin p_browser_signal_seller_origin{};
      absl::optional<::url::Origin> p_browser_signal_top_level_seller_origin{};
      BiddingBrowserSignalsPtr p_bidding_browser_signals{};
      ::base::Time p_auction_start_time{};
      uint64_t p_trace_id{};
      BidderWorklet_GenerateBid_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadBidderWorkletNonSharedParams(&p_bidder_worklet_non_shared_params))
        success = false;
      if (success && !input_data_view.ReadInterestGroupJoinOrigin(&p_interest_group_join_origin))
        success = false;
      if (success && !input_data_view.ReadAuctionSignalsJson(&p_auction_signals_json))
        success = false;
      if (success && !input_data_view.ReadPerBuyerSignalsJson(&p_per_buyer_signals_json))
        success = false;
      if (success && !input_data_view.ReadPerBuyerTimeout(&p_per_buyer_timeout))
        success = false;
      if (success && !input_data_view.ReadBrowserSignalSellerOrigin(&p_browser_signal_seller_origin))
        success = false;
      if (success && !input_data_view.ReadBrowserSignalTopLevelSellerOrigin(&p_browser_signal_top_level_seller_origin))
        success = false;
      if (success && !input_data_view.ReadBiddingBrowserSignals(&p_bidding_browser_signals))
        success = false;
      if (success && !input_data_view.ReadAuctionStartTime(&p_auction_start_time))
        success = false;
      if (success)
        p_trace_id = input_data_view.trace_id();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            BidderWorklet::Name_, 0, false);
        return false;
      }
      BidderWorklet::GenerateBidCallback callback =
          BidderWorklet_GenerateBid_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->GenerateBid(
std::move(p_bidder_worklet_non_shared_params), 
std::move(p_interest_group_join_origin), 
std::move(p_auction_signals_json), 
std::move(p_per_buyer_signals_json), 
std::move(p_per_buyer_timeout), 
std::move(p_browser_signal_seller_origin), 
std::move(p_browser_signal_top_level_seller_origin), 
std::move(p_bidding_browser_signals), 
std::move(p_auction_start_time), 
std::move(p_trace_id), std::move(callback));
      return true;
    }
    case internal::kBidderWorklet_SendPendingSignalsRequests_Name: {
      break;
    }
    case internal::kBidderWorklet_ReportWin_Name: {

      internal::BidderWorklet_ReportWin_Params_Data* params =
          reinterpret_cast<
              internal::BidderWorklet_ReportWin_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      std::string p_interest_group_name{};
      absl::optional<std::string> p_auction_signals_json{};
      absl::optional<std::string> p_per_buyer_signals_json{};
      std::string p_seller_signals_json{};
      ::GURL p_browser_signal_render_url{};
      double p_browser_signal_bid{};
      double p_browser_signal_highest_scoring_other_bid{};
      bool p_browser_signal_made_highest_scoring_other_bid{};
      ::url::Origin p_browser_signal_seller_origin{};
      absl::optional<::url::Origin> p_browser_signal_top_level_seller_origin{};
      uint32_t p_bidding_signals_data_version{};
      bool p_has_bidding_signals_data_version{};
      uint64_t p_trace_id{};
      BidderWorklet_ReportWin_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadInterestGroupName(&p_interest_group_name))
        success = false;
      if (success && !input_data_view.ReadAuctionSignalsJson(&p_auction_signals_json))
        success = false;
      if (success && !input_data_view.ReadPerBuyerSignalsJson(&p_per_buyer_signals_json))
        success = false;
      if (success && !input_data_view.ReadSellerSignalsJson(&p_seller_signals_json))
        success = false;
      if (success && !input_data_view.ReadBrowserSignalRenderUrl(&p_browser_signal_render_url))
        success = false;
      if (success)
        p_browser_signal_bid = input_data_view.browser_signal_bid();
      if (success)
        p_browser_signal_highest_scoring_other_bid = input_data_view.browser_signal_highest_scoring_other_bid();
      if (success)
        p_browser_signal_made_highest_scoring_other_bid = input_data_view.browser_signal_made_highest_scoring_other_bid();
      if (success && !input_data_view.ReadBrowserSignalSellerOrigin(&p_browser_signal_seller_origin))
        success = false;
      if (success && !input_data_view.ReadBrowserSignalTopLevelSellerOrigin(&p_browser_signal_top_level_seller_origin))
        success = false;
      if (success)
        p_bidding_signals_data_version = input_data_view.bidding_signals_data_version();
      if (success)
        p_has_bidding_signals_data_version = input_data_view.has_bidding_signals_data_version();
      if (success)
        p_trace_id = input_data_view.trace_id();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            BidderWorklet::Name_, 2, false);
        return false;
      }
      BidderWorklet::ReportWinCallback callback =
          BidderWorklet_ReportWin_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->ReportWin(
std::move(p_interest_group_name), 
std::move(p_auction_signals_json), 
std::move(p_per_buyer_signals_json), 
std::move(p_seller_signals_json), 
std::move(p_browser_signal_render_url), 
std::move(p_browser_signal_bid), 
std::move(p_browser_signal_highest_scoring_other_bid), 
std::move(p_browser_signal_made_highest_scoring_other_bid), 
std::move(p_browser_signal_seller_origin), 
std::move(p_browser_signal_top_level_seller_origin), 
std::move(p_bidding_signals_data_version), 
std::move(p_has_bidding_signals_data_version), 
std::move(p_trace_id), std::move(callback));
      return true;
    }
    case internal::kBidderWorklet_ConnectDevToolsAgent_Name: {
      break;
    }
  }
  return false;
}


static const mojo::internal::GenericValidationInfo kBidderWorkletValidationInfo[] = {
    {&internal::BidderWorklet_GenerateBid_Params_Data::Validate,
     &internal::BidderWorklet_GenerateBid_ResponseParams_Data::Validate},
    {&internal::BidderWorklet_SendPendingSignalsRequests_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::BidderWorklet_ReportWin_Params_Data::Validate,
     &internal::BidderWorklet_ReportWin_ResponseParams_Data::Validate},
    {&internal::BidderWorklet_ConnectDevToolsAgent_Params_Data::Validate,
     nullptr /* no response */},
};

bool BidderWorkletRequestValidator::Accept(mojo::Message* message) {
  const char* name = ::auction_worklet::mojom::BidderWorklet::Name_;
  return mojo::internal::ValidateRequestGenericPacked(message, name, kBidderWorkletValidationInfo);
}

bool BidderWorkletResponseValidator::Accept(mojo::Message* message) {
  const char* name = ::auction_worklet::mojom::BidderWorklet::Name_;
  return mojo::internal::ValidateResponseGenericPacked(message, name, kBidderWorkletValidationInfo);
}


}  // namespace mojom
}  // namespace auction_worklet


namespace mojo {


// static
bool StructTraits<::auction_worklet::mojom::PreviousWin::DataView, ::auction_worklet::mojom::PreviousWinPtr>::Read(
    ::auction_worklet::mojom::PreviousWin::DataView input,
    ::auction_worklet::mojom::PreviousWinPtr* output) {
  bool success = true;
  ::auction_worklet::mojom::PreviousWinPtr result(::auction_worklet::mojom::PreviousWin::New());
  
      if (success && !input.ReadTime(&result->time))
        success = false;
      if (success && !input.ReadAdJson(&result->ad_json))
        success = false;
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::auction_worklet::mojom::BidderWorkletNonSharedParams::DataView, ::auction_worklet::mojom::BidderWorkletNonSharedParamsPtr>::Read(
    ::auction_worklet::mojom::BidderWorkletNonSharedParams::DataView input,
    ::auction_worklet::mojom::BidderWorkletNonSharedParamsPtr* output) {
  bool success = true;
  ::auction_worklet::mojom::BidderWorkletNonSharedParamsPtr result(::auction_worklet::mojom::BidderWorkletNonSharedParams::New());
  
      if (success && !input.ReadName(&result->name))
        success = false;
      if (success && !input.ReadExecutionMode(&result->execution_mode))
        success = false;
      if (success && !input.ReadDailyUpdateUrl(&result->daily_update_url))
        success = false;
      if (success && !input.ReadTrustedBiddingSignalsKeys(&result->trusted_bidding_signals_keys))
        success = false;
      if (success && !input.ReadUserBiddingSignals(&result->user_bidding_signals))
        success = false;
      if (success && !input.ReadAds(&result->ads))
        success = false;
      if (success && !input.ReadAdComponents(&result->ad_components))
        success = false;
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::auction_worklet::mojom::BiddingBrowserSignals::DataView, ::auction_worklet::mojom::BiddingBrowserSignalsPtr>::Read(
    ::auction_worklet::mojom::BiddingBrowserSignals::DataView input,
    ::auction_worklet::mojom::BiddingBrowserSignalsPtr* output) {
  bool success = true;
  ::auction_worklet::mojom::BiddingBrowserSignalsPtr result(::auction_worklet::mojom::BiddingBrowserSignals::New());
  
      if (success)
        result->join_count = input.join_count();
      if (success)
        result->bid_count = input.bid_count();
      if (success && !input.ReadPrevWins(&result->prev_wins))
        success = false;
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::auction_worklet::mojom::BidderWorkletBid::DataView, ::auction_worklet::mojom::BidderWorkletBidPtr>::Read(
    ::auction_worklet::mojom::BidderWorkletBid::DataView input,
    ::auction_worklet::mojom::BidderWorkletBidPtr* output) {
  bool success = true;
  ::auction_worklet::mojom::BidderWorkletBidPtr result(::auction_worklet::mojom::BidderWorkletBid::New());
  
      if (success && !input.ReadAd(&result->ad))
        success = false;
      if (success)
        result->bid = input.bid();
      if (success && !input.ReadRenderUrl(&result->render_url))
        success = false;
      if (success && !input.ReadAdComponents(&result->ad_components))
        success = false;
      if (success && !input.ReadBidDuration(&result->bid_duration))
        success = false;
  *output = std::move(result);
  return success;
}

}  // namespace mojo


// Symbols declared in the -test-utils.h header are defined here instead of a
// separate .cc file to save compile time.


namespace auction_worklet {
namespace mojom {


void BidderWorkletInterceptorForTesting::GenerateBid(BidderWorkletNonSharedParamsPtr bidder_worklet_non_shared_params, const ::url::Origin& interest_group_join_origin, const absl::optional<std::string>& auction_signals_json, const absl::optional<std::string>& per_buyer_signals_json, absl::optional<::base::TimeDelta> per_buyer_timeout, const ::url::Origin& browser_signal_seller_origin, const absl::optional<::url::Origin>& browser_signal_top_level_seller_origin, BiddingBrowserSignalsPtr bidding_browser_signals, ::base::Time auction_start_time, uint64_t trace_id, GenerateBidCallback callback) {
  GetForwardingInterface()->GenerateBid(std::move(bidder_worklet_non_shared_params), std::move(interest_group_join_origin), std::move(auction_signals_json), std::move(per_buyer_signals_json), std::move(per_buyer_timeout), std::move(browser_signal_seller_origin), std::move(browser_signal_top_level_seller_origin), std::move(bidding_browser_signals), std::move(auction_start_time), std::move(trace_id), std::move(callback));
}
void BidderWorkletInterceptorForTesting::SendPendingSignalsRequests() {
  GetForwardingInterface()->SendPendingSignalsRequests();
}
void BidderWorkletInterceptorForTesting::ReportWin(const std::string& interest_group_name, const absl::optional<std::string>& auction_signals_json, const absl::optional<std::string>& per_buyer_signals_json, const std::string& seller_signals_json, const ::GURL& browser_signal_render_url, double browser_signal_bid, double browser_signal_highest_scoring_other_bid, bool browser_signal_made_highest_scoring_other_bid, const ::url::Origin& browser_signal_seller_origin, const absl::optional<::url::Origin>& browser_signal_top_level_seller_origin, uint32_t bidding_signals_data_version, bool has_bidding_signals_data_version, uint64_t trace_id, ReportWinCallback callback) {
  GetForwardingInterface()->ReportWin(std::move(interest_group_name), std::move(auction_signals_json), std::move(per_buyer_signals_json), std::move(seller_signals_json), std::move(browser_signal_render_url), std::move(browser_signal_bid), std::move(browser_signal_highest_scoring_other_bid), std::move(browser_signal_made_highest_scoring_other_bid), std::move(browser_signal_seller_origin), std::move(browser_signal_top_level_seller_origin), std::move(bidding_signals_data_version), std::move(has_bidding_signals_data_version), std::move(trace_id), std::move(callback));
}
void BidderWorkletInterceptorForTesting::ConnectDevToolsAgent(::mojo::PendingAssociatedReceiver<::blink::mojom::DevToolsAgent> agent) {
  GetForwardingInterface()->ConnectDevToolsAgent(std::move(agent));
}
BidderWorkletAsyncWaiter::BidderWorkletAsyncWaiter(
    BidderWorklet* proxy) : proxy_(proxy) {}

BidderWorkletAsyncWaiter::~BidderWorkletAsyncWaiter() = default;

void BidderWorkletAsyncWaiter::GenerateBid(
    BidderWorkletNonSharedParamsPtr bidder_worklet_non_shared_params, const ::url::Origin& interest_group_join_origin, const absl::optional<std::string>& auction_signals_json, const absl::optional<std::string>& per_buyer_signals_json, absl::optional<::base::TimeDelta> per_buyer_timeout, const ::url::Origin& browser_signal_seller_origin, const absl::optional<::url::Origin>& browser_signal_top_level_seller_origin, BiddingBrowserSignalsPtr bidding_browser_signals, ::base::Time auction_start_time, uint64_t trace_id, BidderWorkletBidPtr* out_bid, uint32_t* out_bidding_signals_data_version, bool* out_has_bidding_signals_data_version, absl::optional<::GURL>* out_debug_loss_report_url, absl::optional<::GURL>* out_debug_win_report_url, double* out_set_priority, bool* out_has_set_priority, std::vector<::auction_worklet::mojom::PrivateAggregationRequestPtr>* out_pa_requests, std::vector<std::string>* out_errors) {
  base::RunLoop loop;
  proxy_->GenerateBid(std::move(bidder_worklet_non_shared_params),std::move(interest_group_join_origin),std::move(auction_signals_json),std::move(per_buyer_signals_json),std::move(per_buyer_timeout),std::move(browser_signal_seller_origin),std::move(browser_signal_top_level_seller_origin),std::move(bidding_browser_signals),std::move(auction_start_time),std::move(trace_id),
      base::BindOnce(
          [](base::RunLoop* loop,
             BidderWorkletBidPtr* out_bid
,
             uint32_t* out_bidding_signals_data_version
,
             bool* out_has_bidding_signals_data_version
,
             absl::optional<::GURL>* out_debug_loss_report_url
,
             absl::optional<::GURL>* out_debug_win_report_url
,
             double* out_set_priority
,
             bool* out_has_set_priority
,
             std::vector<::auction_worklet::mojom::PrivateAggregationRequestPtr>* out_pa_requests
,
             std::vector<std::string>* out_errors
,
             BidderWorkletBidPtr bid,
             uint32_t bidding_signals_data_version,
             bool has_bidding_signals_data_version,
             const absl::optional<::GURL>& debug_loss_report_url,
             const absl::optional<::GURL>& debug_win_report_url,
             double set_priority,
             bool has_set_priority,
             std::vector<::auction_worklet::mojom::PrivateAggregationRequestPtr> pa_requests,
             const std::vector<std::string>& errors) {*out_bid = std::move(bid);*out_bidding_signals_data_version = std::move(bidding_signals_data_version);*out_has_bidding_signals_data_version = std::move(has_bidding_signals_data_version);*out_debug_loss_report_url = std::move(debug_loss_report_url);*out_debug_win_report_url = std::move(debug_win_report_url);*out_set_priority = std::move(set_priority);*out_has_set_priority = std::move(has_set_priority);*out_pa_requests = std::move(pa_requests);*out_errors = std::move(errors);
            loop->Quit();
          },
          &loop,
          out_bid,
          out_bidding_signals_data_version,
          out_has_bidding_signals_data_version,
          out_debug_loss_report_url,
          out_debug_win_report_url,
          out_set_priority,
          out_has_set_priority,
          out_pa_requests,
          out_errors));
  loop.Run();
}
void BidderWorkletAsyncWaiter::ReportWin(
    const std::string& interest_group_name, const absl::optional<std::string>& auction_signals_json, const absl::optional<std::string>& per_buyer_signals_json, const std::string& seller_signals_json, const ::GURL& browser_signal_render_url, double browser_signal_bid, double browser_signal_highest_scoring_other_bid, bool browser_signal_made_highest_scoring_other_bid, const ::url::Origin& browser_signal_seller_origin, const absl::optional<::url::Origin>& browser_signal_top_level_seller_origin, uint32_t bidding_signals_data_version, bool has_bidding_signals_data_version, uint64_t trace_id, absl::optional<::GURL>* out_report_url, base::flat_map<std::string, ::GURL>* out_ad_beacon_map, std::vector<::auction_worklet::mojom::PrivateAggregationRequestPtr>* out_pa_requests, std::vector<std::string>* out_errors) {
  base::RunLoop loop;
  proxy_->ReportWin(std::move(interest_group_name),std::move(auction_signals_json),std::move(per_buyer_signals_json),std::move(seller_signals_json),std::move(browser_signal_render_url),std::move(browser_signal_bid),std::move(browser_signal_highest_scoring_other_bid),std::move(browser_signal_made_highest_scoring_other_bid),std::move(browser_signal_seller_origin),std::move(browser_signal_top_level_seller_origin),std::move(bidding_signals_data_version),std::move(has_bidding_signals_data_version),std::move(trace_id),
      base::BindOnce(
          [](base::RunLoop* loop,
             absl::optional<::GURL>* out_report_url
,
             base::flat_map<std::string, ::GURL>* out_ad_beacon_map
,
             std::vector<::auction_worklet::mojom::PrivateAggregationRequestPtr>* out_pa_requests
,
             std::vector<std::string>* out_errors
,
             const absl::optional<::GURL>& report_url,
             const base::flat_map<std::string, ::GURL>& ad_beacon_map,
             std::vector<::auction_worklet::mojom::PrivateAggregationRequestPtr> pa_requests,
             const std::vector<std::string>& errors) {*out_report_url = std::move(report_url);*out_ad_beacon_map = std::move(ad_beacon_map);*out_pa_requests = std::move(pa_requests);*out_errors = std::move(errors);
            loop->Quit();
          },
          &loop,
          out_report_url,
          out_ad_beacon_map,
          out_pa_requests,
          out_errors));
  loop.Run();
}





}  // namespace mojom
}  // namespace auction_worklet


#if defined(__clang__)
#pragma clang diagnostic pop
#endif