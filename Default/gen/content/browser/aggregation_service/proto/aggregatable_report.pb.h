// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: aggregatable_report.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_aggregatable_5freport_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_aggregatable_5freport_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3020000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3020000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_aggregatable_5freport_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_aggregatable_5freport_2eproto {
  static const uint32_t offsets[];
};
namespace content {
namespace proto {
class AggregatableReportHistogramContribution;
struct AggregatableReportHistogramContributionDefaultTypeInternal;
extern AggregatableReportHistogramContributionDefaultTypeInternal _AggregatableReportHistogramContribution_default_instance_;
class AggregatableReportRequest;
struct AggregatableReportRequestDefaultTypeInternal;
extern AggregatableReportRequestDefaultTypeInternal _AggregatableReportRequest_default_instance_;
class AggregatableReportSharedInfo;
struct AggregatableReportSharedInfoDefaultTypeInternal;
extern AggregatableReportSharedInfoDefaultTypeInternal _AggregatableReportSharedInfo_default_instance_;
class AggregationServicePayloadContents;
struct AggregationServicePayloadContentsDefaultTypeInternal;
extern AggregationServicePayloadContentsDefaultTypeInternal _AggregationServicePayloadContents_default_instance_;
}  // namespace proto
}  // namespace content
PROTOBUF_NAMESPACE_OPEN
template<> ::content::proto::AggregatableReportHistogramContribution* Arena::CreateMaybeMessage<::content::proto::AggregatableReportHistogramContribution>(Arena*);
template<> ::content::proto::AggregatableReportRequest* Arena::CreateMaybeMessage<::content::proto::AggregatableReportRequest>(Arena*);
template<> ::content::proto::AggregatableReportSharedInfo* Arena::CreateMaybeMessage<::content::proto::AggregatableReportSharedInfo>(Arena*);
template<> ::content::proto::AggregationServicePayloadContents* Arena::CreateMaybeMessage<::content::proto::AggregationServicePayloadContents>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace content {
namespace proto {

enum AggregationServicePayloadContents_Operation : int {
  AggregationServicePayloadContents_Operation_HISTOGRAM = 0,
  AggregationServicePayloadContents_Operation_AggregationServicePayloadContents_Operation_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  AggregationServicePayloadContents_Operation_AggregationServicePayloadContents_Operation_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool AggregationServicePayloadContents_Operation_IsValid(int value);
constexpr AggregationServicePayloadContents_Operation AggregationServicePayloadContents_Operation_Operation_MIN = AggregationServicePayloadContents_Operation_HISTOGRAM;
constexpr AggregationServicePayloadContents_Operation AggregationServicePayloadContents_Operation_Operation_MAX = AggregationServicePayloadContents_Operation_HISTOGRAM;
constexpr int AggregationServicePayloadContents_Operation_Operation_ARRAYSIZE = AggregationServicePayloadContents_Operation_Operation_MAX + 1;

const std::string& AggregationServicePayloadContents_Operation_Name(AggregationServicePayloadContents_Operation value);
template<typename T>
inline const std::string& AggregationServicePayloadContents_Operation_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AggregationServicePayloadContents_Operation>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AggregationServicePayloadContents_Operation_Name.");
  return AggregationServicePayloadContents_Operation_Name(static_cast<AggregationServicePayloadContents_Operation>(enum_t_value));
}
bool AggregationServicePayloadContents_Operation_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AggregationServicePayloadContents_Operation* value);
enum AggregatableReportSharedInfo_DebugMode : int {
  AggregatableReportSharedInfo_DebugMode_DISABLED = 0,
  AggregatableReportSharedInfo_DebugMode_ENABLED = 1,
  AggregatableReportSharedInfo_DebugMode_AggregatableReportSharedInfo_DebugMode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  AggregatableReportSharedInfo_DebugMode_AggregatableReportSharedInfo_DebugMode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool AggregatableReportSharedInfo_DebugMode_IsValid(int value);
constexpr AggregatableReportSharedInfo_DebugMode AggregatableReportSharedInfo_DebugMode_DebugMode_MIN = AggregatableReportSharedInfo_DebugMode_DISABLED;
constexpr AggregatableReportSharedInfo_DebugMode AggregatableReportSharedInfo_DebugMode_DebugMode_MAX = AggregatableReportSharedInfo_DebugMode_ENABLED;
constexpr int AggregatableReportSharedInfo_DebugMode_DebugMode_ARRAYSIZE = AggregatableReportSharedInfo_DebugMode_DebugMode_MAX + 1;

const std::string& AggregatableReportSharedInfo_DebugMode_Name(AggregatableReportSharedInfo_DebugMode value);
template<typename T>
inline const std::string& AggregatableReportSharedInfo_DebugMode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AggregatableReportSharedInfo_DebugMode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AggregatableReportSharedInfo_DebugMode_Name.");
  return AggregatableReportSharedInfo_DebugMode_Name(static_cast<AggregatableReportSharedInfo_DebugMode>(enum_t_value));
}
bool AggregatableReportSharedInfo_DebugMode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AggregatableReportSharedInfo_DebugMode* value);
enum AggregationServiceMode : int {
  TEE_BASED = 0,
  EXPERIMENTAL_POPLAR = 1,
  AggregationServiceMode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  AggregationServiceMode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool AggregationServiceMode_IsValid(int value);
constexpr AggregationServiceMode AggregationServiceMode_MIN = TEE_BASED;
constexpr AggregationServiceMode AggregationServiceMode_MAX = EXPERIMENTAL_POPLAR;
constexpr int AggregationServiceMode_ARRAYSIZE = AggregationServiceMode_MAX + 1;

const std::string& AggregationServiceMode_Name(AggregationServiceMode value);
template<typename T>
inline const std::string& AggregationServiceMode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AggregationServiceMode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AggregationServiceMode_Name.");
  return AggregationServiceMode_Name(static_cast<AggregationServiceMode>(enum_t_value));
}
bool AggregationServiceMode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AggregationServiceMode* value);
// ===================================================================

class AggregatableReportHistogramContribution final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:content.proto.AggregatableReportHistogramContribution) */ {
 public:
  inline AggregatableReportHistogramContribution() : AggregatableReportHistogramContribution(nullptr) {}
  ~AggregatableReportHistogramContribution() override;
  explicit PROTOBUF_CONSTEXPR AggregatableReportHistogramContribution(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AggregatableReportHistogramContribution(const AggregatableReportHistogramContribution& from);
  AggregatableReportHistogramContribution(AggregatableReportHistogramContribution&& from) noexcept
    : AggregatableReportHistogramContribution() {
    *this = ::std::move(from);
  }

  inline AggregatableReportHistogramContribution& operator=(const AggregatableReportHistogramContribution& from) {
    CopyFrom(from);
    return *this;
  }
  inline AggregatableReportHistogramContribution& operator=(AggregatableReportHistogramContribution&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const AggregatableReportHistogramContribution& default_instance() {
    return *internal_default_instance();
  }
  static inline const AggregatableReportHistogramContribution* internal_default_instance() {
    return reinterpret_cast<const AggregatableReportHistogramContribution*>(
               &_AggregatableReportHistogramContribution_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(AggregatableReportHistogramContribution& a, AggregatableReportHistogramContribution& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(AggregatableReportHistogramContribution* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AggregatableReportHistogramContribution* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AggregatableReportHistogramContribution* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AggregatableReportHistogramContribution>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const AggregatableReportHistogramContribution& from);
  void MergeFrom(const AggregatableReportHistogramContribution& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AggregatableReportHistogramContribution* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "content.proto.AggregatableReportHistogramContribution";
  }
  protected:
  explicit AggregatableReportHistogramContribution(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBucketHighFieldNumber = 1,
    kBucketLowFieldNumber = 2,
    kValueFieldNumber = 3,
  };
  // uint64 bucket_high = 1;
  void clear_bucket_high();
  uint64_t bucket_high() const;
  void set_bucket_high(uint64_t value);
  private:
  uint64_t _internal_bucket_high() const;
  void _internal_set_bucket_high(uint64_t value);
  public:

  // uint64 bucket_low = 2;
  void clear_bucket_low();
  uint64_t bucket_low() const;
  void set_bucket_low(uint64_t value);
  private:
  uint64_t _internal_bucket_low() const;
  void _internal_set_bucket_low(uint64_t value);
  public:

  // int32 value = 3;
  void clear_value();
  int32_t value() const;
  void set_value(int32_t value);
  private:
  int32_t _internal_value() const;
  void _internal_set_value(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:content.proto.AggregatableReportHistogramContribution)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint64_t bucket_high_;
  uint64_t bucket_low_;
  int32_t value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_aggregatable_5freport_2eproto;
};
// -------------------------------------------------------------------

class AggregationServicePayloadContents final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:content.proto.AggregationServicePayloadContents) */ {
 public:
  inline AggregationServicePayloadContents() : AggregationServicePayloadContents(nullptr) {}
  ~AggregationServicePayloadContents() override;
  explicit PROTOBUF_CONSTEXPR AggregationServicePayloadContents(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AggregationServicePayloadContents(const AggregationServicePayloadContents& from);
  AggregationServicePayloadContents(AggregationServicePayloadContents&& from) noexcept
    : AggregationServicePayloadContents() {
    *this = ::std::move(from);
  }

  inline AggregationServicePayloadContents& operator=(const AggregationServicePayloadContents& from) {
    CopyFrom(from);
    return *this;
  }
  inline AggregationServicePayloadContents& operator=(AggregationServicePayloadContents&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const AggregationServicePayloadContents& default_instance() {
    return *internal_default_instance();
  }
  static inline const AggregationServicePayloadContents* internal_default_instance() {
    return reinterpret_cast<const AggregationServicePayloadContents*>(
               &_AggregationServicePayloadContents_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(AggregationServicePayloadContents& a, AggregationServicePayloadContents& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(AggregationServicePayloadContents* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AggregationServicePayloadContents* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AggregationServicePayloadContents* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AggregationServicePayloadContents>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const AggregationServicePayloadContents& from);
  void MergeFrom(const AggregationServicePayloadContents& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AggregationServicePayloadContents* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "content.proto.AggregationServicePayloadContents";
  }
  protected:
  explicit AggregationServicePayloadContents(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef AggregationServicePayloadContents_Operation Operation;
  static constexpr Operation HISTOGRAM =
    AggregationServicePayloadContents_Operation_HISTOGRAM;
  static inline bool Operation_IsValid(int value) {
    return AggregationServicePayloadContents_Operation_IsValid(value);
  }
  static constexpr Operation Operation_MIN =
    AggregationServicePayloadContents_Operation_Operation_MIN;
  static constexpr Operation Operation_MAX =
    AggregationServicePayloadContents_Operation_Operation_MAX;
  static constexpr int Operation_ARRAYSIZE =
    AggregationServicePayloadContents_Operation_Operation_ARRAYSIZE;
  template<typename T>
  static inline const std::string& Operation_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Operation>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Operation_Name.");
    return AggregationServicePayloadContents_Operation_Name(enum_t_value);
  }
  static inline bool Operation_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Operation* value) {
    return AggregationServicePayloadContents_Operation_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kContributionsFieldNumber = 2,
    kOperationFieldNumber = 1,
    kAggregationModeFieldNumber = 3,
  };
  // repeated .content.proto.AggregatableReportHistogramContribution contributions = 2;
  int contributions_size() const;
  private:
  int _internal_contributions_size() const;
  public:
  void clear_contributions();
  ::content::proto::AggregatableReportHistogramContribution* mutable_contributions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::content::proto::AggregatableReportHistogramContribution >*
      mutable_contributions();
  private:
  const ::content::proto::AggregatableReportHistogramContribution& _internal_contributions(int index) const;
  ::content::proto::AggregatableReportHistogramContribution* _internal_add_contributions();
  public:
  const ::content::proto::AggregatableReportHistogramContribution& contributions(int index) const;
  ::content::proto::AggregatableReportHistogramContribution* add_contributions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::content::proto::AggregatableReportHistogramContribution >&
      contributions() const;

  // .content.proto.AggregationServicePayloadContents.Operation operation = 1;
  void clear_operation();
  ::content::proto::AggregationServicePayloadContents_Operation operation() const;
  void set_operation(::content::proto::AggregationServicePayloadContents_Operation value);
  private:
  ::content::proto::AggregationServicePayloadContents_Operation _internal_operation() const;
  void _internal_set_operation(::content::proto::AggregationServicePayloadContents_Operation value);
  public:

  // .content.proto.AggregationServiceMode aggregation_mode = 3;
  void clear_aggregation_mode();
  ::content::proto::AggregationServiceMode aggregation_mode() const;
  void set_aggregation_mode(::content::proto::AggregationServiceMode value);
  private:
  ::content::proto::AggregationServiceMode _internal_aggregation_mode() const;
  void _internal_set_aggregation_mode(::content::proto::AggregationServiceMode value);
  public:

  // @@protoc_insertion_point(class_scope:content.proto.AggregationServicePayloadContents)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::content::proto::AggregatableReportHistogramContribution > contributions_;
  int operation_;
  int aggregation_mode_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_aggregatable_5freport_2eproto;
};
// -------------------------------------------------------------------

class AggregatableReportSharedInfo final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:content.proto.AggregatableReportSharedInfo) */ {
 public:
  inline AggregatableReportSharedInfo() : AggregatableReportSharedInfo(nullptr) {}
  ~AggregatableReportSharedInfo() override;
  explicit PROTOBUF_CONSTEXPR AggregatableReportSharedInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AggregatableReportSharedInfo(const AggregatableReportSharedInfo& from);
  AggregatableReportSharedInfo(AggregatableReportSharedInfo&& from) noexcept
    : AggregatableReportSharedInfo() {
    *this = ::std::move(from);
  }

  inline AggregatableReportSharedInfo& operator=(const AggregatableReportSharedInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline AggregatableReportSharedInfo& operator=(AggregatableReportSharedInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const AggregatableReportSharedInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const AggregatableReportSharedInfo* internal_default_instance() {
    return reinterpret_cast<const AggregatableReportSharedInfo*>(
               &_AggregatableReportSharedInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(AggregatableReportSharedInfo& a, AggregatableReportSharedInfo& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(AggregatableReportSharedInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AggregatableReportSharedInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AggregatableReportSharedInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AggregatableReportSharedInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const AggregatableReportSharedInfo& from);
  void MergeFrom(const AggregatableReportSharedInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AggregatableReportSharedInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "content.proto.AggregatableReportSharedInfo";
  }
  protected:
  explicit AggregatableReportSharedInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef AggregatableReportSharedInfo_DebugMode DebugMode;
  static constexpr DebugMode DISABLED =
    AggregatableReportSharedInfo_DebugMode_DISABLED;
  static constexpr DebugMode ENABLED =
    AggregatableReportSharedInfo_DebugMode_ENABLED;
  static inline bool DebugMode_IsValid(int value) {
    return AggregatableReportSharedInfo_DebugMode_IsValid(value);
  }
  static constexpr DebugMode DebugMode_MIN =
    AggregatableReportSharedInfo_DebugMode_DebugMode_MIN;
  static constexpr DebugMode DebugMode_MAX =
    AggregatableReportSharedInfo_DebugMode_DebugMode_MAX;
  static constexpr int DebugMode_ARRAYSIZE =
    AggregatableReportSharedInfo_DebugMode_DebugMode_ARRAYSIZE;
  template<typename T>
  static inline const std::string& DebugMode_Name(T enum_t_value) {
    static_assert(::std::is_same<T, DebugMode>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function DebugMode_Name.");
    return AggregatableReportSharedInfo_DebugMode_Name(enum_t_value);
  }
  static inline bool DebugMode_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      DebugMode* value) {
    return AggregatableReportSharedInfo_DebugMode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kReportIdFieldNumber = 2,
    kReportingOriginFieldNumber = 3,
    kApiVersionFieldNumber = 5,
    kApiIdentifierFieldNumber = 6,
    kScheduledReportTimeFieldNumber = 1,
    kDebugModeFieldNumber = 4,
  };
  // string report_id = 2;
  void clear_report_id();
  const std::string& report_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_report_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_report_id();
  PROTOBUF_NODISCARD std::string* release_report_id();
  void set_allocated_report_id(std::string* report_id);
  private:
  const std::string& _internal_report_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_report_id(const std::string& value);
  std::string* _internal_mutable_report_id();
  public:

  // string reporting_origin = 3;
  void clear_reporting_origin();
  const std::string& reporting_origin() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_reporting_origin(ArgT0&& arg0, ArgT... args);
  std::string* mutable_reporting_origin();
  PROTOBUF_NODISCARD std::string* release_reporting_origin();
  void set_allocated_reporting_origin(std::string* reporting_origin);
  private:
  const std::string& _internal_reporting_origin() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_reporting_origin(const std::string& value);
  std::string* _internal_mutable_reporting_origin();
  public:

  // string api_version = 5;
  void clear_api_version();
  const std::string& api_version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_api_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_api_version();
  PROTOBUF_NODISCARD std::string* release_api_version();
  void set_allocated_api_version(std::string* api_version);
  private:
  const std::string& _internal_api_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_api_version(const std::string& value);
  std::string* _internal_mutable_api_version();
  public:

  // string api_identifier = 6;
  void clear_api_identifier();
  const std::string& api_identifier() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_api_identifier(ArgT0&& arg0, ArgT... args);
  std::string* mutable_api_identifier();
  PROTOBUF_NODISCARD std::string* release_api_identifier();
  void set_allocated_api_identifier(std::string* api_identifier);
  private:
  const std::string& _internal_api_identifier() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_api_identifier(const std::string& value);
  std::string* _internal_mutable_api_identifier();
  public:

  // int64 scheduled_report_time = 1;
  void clear_scheduled_report_time();
  int64_t scheduled_report_time() const;
  void set_scheduled_report_time(int64_t value);
  private:
  int64_t _internal_scheduled_report_time() const;
  void _internal_set_scheduled_report_time(int64_t value);
  public:

  // .content.proto.AggregatableReportSharedInfo.DebugMode debug_mode = 4;
  void clear_debug_mode();
  ::content::proto::AggregatableReportSharedInfo_DebugMode debug_mode() const;
  void set_debug_mode(::content::proto::AggregatableReportSharedInfo_DebugMode value);
  private:
  ::content::proto::AggregatableReportSharedInfo_DebugMode _internal_debug_mode() const;
  void _internal_set_debug_mode(::content::proto::AggregatableReportSharedInfo_DebugMode value);
  public:

  // @@protoc_insertion_point(class_scope:content.proto.AggregatableReportSharedInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr report_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr reporting_origin_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr api_version_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr api_identifier_;
  int64_t scheduled_report_time_;
  int debug_mode_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_aggregatable_5freport_2eproto;
};
// -------------------------------------------------------------------

class AggregatableReportRequest final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:content.proto.AggregatableReportRequest) */ {
 public:
  inline AggregatableReportRequest() : AggregatableReportRequest(nullptr) {}
  ~AggregatableReportRequest() override;
  explicit PROTOBUF_CONSTEXPR AggregatableReportRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AggregatableReportRequest(const AggregatableReportRequest& from);
  AggregatableReportRequest(AggregatableReportRequest&& from) noexcept
    : AggregatableReportRequest() {
    *this = ::std::move(from);
  }

  inline AggregatableReportRequest& operator=(const AggregatableReportRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AggregatableReportRequest& operator=(AggregatableReportRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const AggregatableReportRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const AggregatableReportRequest* internal_default_instance() {
    return reinterpret_cast<const AggregatableReportRequest*>(
               &_AggregatableReportRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(AggregatableReportRequest& a, AggregatableReportRequest& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(AggregatableReportRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AggregatableReportRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AggregatableReportRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AggregatableReportRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const AggregatableReportRequest& from);
  void MergeFrom(const AggregatableReportRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AggregatableReportRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "content.proto.AggregatableReportRequest";
  }
  protected:
  explicit AggregatableReportRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReportingPathFieldNumber = 3,
    kPayloadContentsFieldNumber = 1,
    kSharedInfoFieldNumber = 2,
  };
  // string reporting_path = 3;
  void clear_reporting_path();
  const std::string& reporting_path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_reporting_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_reporting_path();
  PROTOBUF_NODISCARD std::string* release_reporting_path();
  void set_allocated_reporting_path(std::string* reporting_path);
  private:
  const std::string& _internal_reporting_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_reporting_path(const std::string& value);
  std::string* _internal_mutable_reporting_path();
  public:

  // .content.proto.AggregationServicePayloadContents payload_contents = 1;
  bool has_payload_contents() const;
  private:
  bool _internal_has_payload_contents() const;
  public:
  void clear_payload_contents();
  const ::content::proto::AggregationServicePayloadContents& payload_contents() const;
  PROTOBUF_NODISCARD ::content::proto::AggregationServicePayloadContents* release_payload_contents();
  ::content::proto::AggregationServicePayloadContents* mutable_payload_contents();
  void set_allocated_payload_contents(::content::proto::AggregationServicePayloadContents* payload_contents);
  private:
  const ::content::proto::AggregationServicePayloadContents& _internal_payload_contents() const;
  ::content::proto::AggregationServicePayloadContents* _internal_mutable_payload_contents();
  public:
  void unsafe_arena_set_allocated_payload_contents(
      ::content::proto::AggregationServicePayloadContents* payload_contents);
  ::content::proto::AggregationServicePayloadContents* unsafe_arena_release_payload_contents();

  // .content.proto.AggregatableReportSharedInfo shared_info = 2;
  bool has_shared_info() const;
  private:
  bool _internal_has_shared_info() const;
  public:
  void clear_shared_info();
  const ::content::proto::AggregatableReportSharedInfo& shared_info() const;
  PROTOBUF_NODISCARD ::content::proto::AggregatableReportSharedInfo* release_shared_info();
  ::content::proto::AggregatableReportSharedInfo* mutable_shared_info();
  void set_allocated_shared_info(::content::proto::AggregatableReportSharedInfo* shared_info);
  private:
  const ::content::proto::AggregatableReportSharedInfo& _internal_shared_info() const;
  ::content::proto::AggregatableReportSharedInfo* _internal_mutable_shared_info();
  public:
  void unsafe_arena_set_allocated_shared_info(
      ::content::proto::AggregatableReportSharedInfo* shared_info);
  ::content::proto::AggregatableReportSharedInfo* unsafe_arena_release_shared_info();

  // @@protoc_insertion_point(class_scope:content.proto.AggregatableReportRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr reporting_path_;
  ::content::proto::AggregationServicePayloadContents* payload_contents_;
  ::content::proto::AggregatableReportSharedInfo* shared_info_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_aggregatable_5freport_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// AggregatableReportHistogramContribution

// uint64 bucket_high = 1;
inline void AggregatableReportHistogramContribution::clear_bucket_high() {
  bucket_high_ = uint64_t{0u};
}
inline uint64_t AggregatableReportHistogramContribution::_internal_bucket_high() const {
  return bucket_high_;
}
inline uint64_t AggregatableReportHistogramContribution::bucket_high() const {
  // @@protoc_insertion_point(field_get:content.proto.AggregatableReportHistogramContribution.bucket_high)
  return _internal_bucket_high();
}
inline void AggregatableReportHistogramContribution::_internal_set_bucket_high(uint64_t value) {
  
  bucket_high_ = value;
}
inline void AggregatableReportHistogramContribution::set_bucket_high(uint64_t value) {
  _internal_set_bucket_high(value);
  // @@protoc_insertion_point(field_set:content.proto.AggregatableReportHistogramContribution.bucket_high)
}

// uint64 bucket_low = 2;
inline void AggregatableReportHistogramContribution::clear_bucket_low() {
  bucket_low_ = uint64_t{0u};
}
inline uint64_t AggregatableReportHistogramContribution::_internal_bucket_low() const {
  return bucket_low_;
}
inline uint64_t AggregatableReportHistogramContribution::bucket_low() const {
  // @@protoc_insertion_point(field_get:content.proto.AggregatableReportHistogramContribution.bucket_low)
  return _internal_bucket_low();
}
inline void AggregatableReportHistogramContribution::_internal_set_bucket_low(uint64_t value) {
  
  bucket_low_ = value;
}
inline void AggregatableReportHistogramContribution::set_bucket_low(uint64_t value) {
  _internal_set_bucket_low(value);
  // @@protoc_insertion_point(field_set:content.proto.AggregatableReportHistogramContribution.bucket_low)
}

// int32 value = 3;
inline void AggregatableReportHistogramContribution::clear_value() {
  value_ = 0;
}
inline int32_t AggregatableReportHistogramContribution::_internal_value() const {
  return value_;
}
inline int32_t AggregatableReportHistogramContribution::value() const {
  // @@protoc_insertion_point(field_get:content.proto.AggregatableReportHistogramContribution.value)
  return _internal_value();
}
inline void AggregatableReportHistogramContribution::_internal_set_value(int32_t value) {
  
  value_ = value;
}
inline void AggregatableReportHistogramContribution::set_value(int32_t value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:content.proto.AggregatableReportHistogramContribution.value)
}

// -------------------------------------------------------------------

// AggregationServicePayloadContents

// .content.proto.AggregationServicePayloadContents.Operation operation = 1;
inline void AggregationServicePayloadContents::clear_operation() {
  operation_ = 0;
}
inline ::content::proto::AggregationServicePayloadContents_Operation AggregationServicePayloadContents::_internal_operation() const {
  return static_cast< ::content::proto::AggregationServicePayloadContents_Operation >(operation_);
}
inline ::content::proto::AggregationServicePayloadContents_Operation AggregationServicePayloadContents::operation() const {
  // @@protoc_insertion_point(field_get:content.proto.AggregationServicePayloadContents.operation)
  return _internal_operation();
}
inline void AggregationServicePayloadContents::_internal_set_operation(::content::proto::AggregationServicePayloadContents_Operation value) {
  
  operation_ = value;
}
inline void AggregationServicePayloadContents::set_operation(::content::proto::AggregationServicePayloadContents_Operation value) {
  _internal_set_operation(value);
  // @@protoc_insertion_point(field_set:content.proto.AggregationServicePayloadContents.operation)
}

// repeated .content.proto.AggregatableReportHistogramContribution contributions = 2;
inline int AggregationServicePayloadContents::_internal_contributions_size() const {
  return contributions_.size();
}
inline int AggregationServicePayloadContents::contributions_size() const {
  return _internal_contributions_size();
}
inline void AggregationServicePayloadContents::clear_contributions() {
  contributions_.Clear();
}
inline ::content::proto::AggregatableReportHistogramContribution* AggregationServicePayloadContents::mutable_contributions(int index) {
  // @@protoc_insertion_point(field_mutable:content.proto.AggregationServicePayloadContents.contributions)
  return contributions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::content::proto::AggregatableReportHistogramContribution >*
AggregationServicePayloadContents::mutable_contributions() {
  // @@protoc_insertion_point(field_mutable_list:content.proto.AggregationServicePayloadContents.contributions)
  return &contributions_;
}
inline const ::content::proto::AggregatableReportHistogramContribution& AggregationServicePayloadContents::_internal_contributions(int index) const {
  return contributions_.Get(index);
}
inline const ::content::proto::AggregatableReportHistogramContribution& AggregationServicePayloadContents::contributions(int index) const {
  // @@protoc_insertion_point(field_get:content.proto.AggregationServicePayloadContents.contributions)
  return _internal_contributions(index);
}
inline ::content::proto::AggregatableReportHistogramContribution* AggregationServicePayloadContents::_internal_add_contributions() {
  return contributions_.Add();
}
inline ::content::proto::AggregatableReportHistogramContribution* AggregationServicePayloadContents::add_contributions() {
  ::content::proto::AggregatableReportHistogramContribution* _add = _internal_add_contributions();
  // @@protoc_insertion_point(field_add:content.proto.AggregationServicePayloadContents.contributions)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::content::proto::AggregatableReportHistogramContribution >&
AggregationServicePayloadContents::contributions() const {
  // @@protoc_insertion_point(field_list:content.proto.AggregationServicePayloadContents.contributions)
  return contributions_;
}

// .content.proto.AggregationServiceMode aggregation_mode = 3;
inline void AggregationServicePayloadContents::clear_aggregation_mode() {
  aggregation_mode_ = 0;
}
inline ::content::proto::AggregationServiceMode AggregationServicePayloadContents::_internal_aggregation_mode() const {
  return static_cast< ::content::proto::AggregationServiceMode >(aggregation_mode_);
}
inline ::content::proto::AggregationServiceMode AggregationServicePayloadContents::aggregation_mode() const {
  // @@protoc_insertion_point(field_get:content.proto.AggregationServicePayloadContents.aggregation_mode)
  return _internal_aggregation_mode();
}
inline void AggregationServicePayloadContents::_internal_set_aggregation_mode(::content::proto::AggregationServiceMode value) {
  
  aggregation_mode_ = value;
}
inline void AggregationServicePayloadContents::set_aggregation_mode(::content::proto::AggregationServiceMode value) {
  _internal_set_aggregation_mode(value);
  // @@protoc_insertion_point(field_set:content.proto.AggregationServicePayloadContents.aggregation_mode)
}

// -------------------------------------------------------------------

// AggregatableReportSharedInfo

// int64 scheduled_report_time = 1;
inline void AggregatableReportSharedInfo::clear_scheduled_report_time() {
  scheduled_report_time_ = int64_t{0};
}
inline int64_t AggregatableReportSharedInfo::_internal_scheduled_report_time() const {
  return scheduled_report_time_;
}
inline int64_t AggregatableReportSharedInfo::scheduled_report_time() const {
  // @@protoc_insertion_point(field_get:content.proto.AggregatableReportSharedInfo.scheduled_report_time)
  return _internal_scheduled_report_time();
}
inline void AggregatableReportSharedInfo::_internal_set_scheduled_report_time(int64_t value) {
  
  scheduled_report_time_ = value;
}
inline void AggregatableReportSharedInfo::set_scheduled_report_time(int64_t value) {
  _internal_set_scheduled_report_time(value);
  // @@protoc_insertion_point(field_set:content.proto.AggregatableReportSharedInfo.scheduled_report_time)
}

// string report_id = 2;
inline void AggregatableReportSharedInfo::clear_report_id() {
  report_id_.ClearToEmpty();
}
inline const std::string& AggregatableReportSharedInfo::report_id() const {
  // @@protoc_insertion_point(field_get:content.proto.AggregatableReportSharedInfo.report_id)
  return _internal_report_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AggregatableReportSharedInfo::set_report_id(ArgT0&& arg0, ArgT... args) {
 
 report_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:content.proto.AggregatableReportSharedInfo.report_id)
}
inline std::string* AggregatableReportSharedInfo::mutable_report_id() {
  std::string* _s = _internal_mutable_report_id();
  // @@protoc_insertion_point(field_mutable:content.proto.AggregatableReportSharedInfo.report_id)
  return _s;
}
inline const std::string& AggregatableReportSharedInfo::_internal_report_id() const {
  return report_id_.Get();
}
inline void AggregatableReportSharedInfo::_internal_set_report_id(const std::string& value) {
  
  report_id_.Set(value, GetArenaForAllocation());
}
inline std::string* AggregatableReportSharedInfo::_internal_mutable_report_id() {
  
  return report_id_.Mutable(GetArenaForAllocation());
}
inline std::string* AggregatableReportSharedInfo::release_report_id() {
  // @@protoc_insertion_point(field_release:content.proto.AggregatableReportSharedInfo.report_id)
  return report_id_.Release();
}
inline void AggregatableReportSharedInfo::set_allocated_report_id(std::string* report_id) {
  if (report_id != nullptr) {
    
  } else {
    
  }
  report_id_.SetAllocated(report_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (report_id_.IsDefault()) {
    report_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:content.proto.AggregatableReportSharedInfo.report_id)
}

// string reporting_origin = 3;
inline void AggregatableReportSharedInfo::clear_reporting_origin() {
  reporting_origin_.ClearToEmpty();
}
inline const std::string& AggregatableReportSharedInfo::reporting_origin() const {
  // @@protoc_insertion_point(field_get:content.proto.AggregatableReportSharedInfo.reporting_origin)
  return _internal_reporting_origin();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AggregatableReportSharedInfo::set_reporting_origin(ArgT0&& arg0, ArgT... args) {
 
 reporting_origin_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:content.proto.AggregatableReportSharedInfo.reporting_origin)
}
inline std::string* AggregatableReportSharedInfo::mutable_reporting_origin() {
  std::string* _s = _internal_mutable_reporting_origin();
  // @@protoc_insertion_point(field_mutable:content.proto.AggregatableReportSharedInfo.reporting_origin)
  return _s;
}
inline const std::string& AggregatableReportSharedInfo::_internal_reporting_origin() const {
  return reporting_origin_.Get();
}
inline void AggregatableReportSharedInfo::_internal_set_reporting_origin(const std::string& value) {
  
  reporting_origin_.Set(value, GetArenaForAllocation());
}
inline std::string* AggregatableReportSharedInfo::_internal_mutable_reporting_origin() {
  
  return reporting_origin_.Mutable(GetArenaForAllocation());
}
inline std::string* AggregatableReportSharedInfo::release_reporting_origin() {
  // @@protoc_insertion_point(field_release:content.proto.AggregatableReportSharedInfo.reporting_origin)
  return reporting_origin_.Release();
}
inline void AggregatableReportSharedInfo::set_allocated_reporting_origin(std::string* reporting_origin) {
  if (reporting_origin != nullptr) {
    
  } else {
    
  }
  reporting_origin_.SetAllocated(reporting_origin, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (reporting_origin_.IsDefault()) {
    reporting_origin_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:content.proto.AggregatableReportSharedInfo.reporting_origin)
}

// .content.proto.AggregatableReportSharedInfo.DebugMode debug_mode = 4;
inline void AggregatableReportSharedInfo::clear_debug_mode() {
  debug_mode_ = 0;
}
inline ::content::proto::AggregatableReportSharedInfo_DebugMode AggregatableReportSharedInfo::_internal_debug_mode() const {
  return static_cast< ::content::proto::AggregatableReportSharedInfo_DebugMode >(debug_mode_);
}
inline ::content::proto::AggregatableReportSharedInfo_DebugMode AggregatableReportSharedInfo::debug_mode() const {
  // @@protoc_insertion_point(field_get:content.proto.AggregatableReportSharedInfo.debug_mode)
  return _internal_debug_mode();
}
inline void AggregatableReportSharedInfo::_internal_set_debug_mode(::content::proto::AggregatableReportSharedInfo_DebugMode value) {
  
  debug_mode_ = value;
}
inline void AggregatableReportSharedInfo::set_debug_mode(::content::proto::AggregatableReportSharedInfo_DebugMode value) {
  _internal_set_debug_mode(value);
  // @@protoc_insertion_point(field_set:content.proto.AggregatableReportSharedInfo.debug_mode)
}

// string api_version = 5;
inline void AggregatableReportSharedInfo::clear_api_version() {
  api_version_.ClearToEmpty();
}
inline const std::string& AggregatableReportSharedInfo::api_version() const {
  // @@protoc_insertion_point(field_get:content.proto.AggregatableReportSharedInfo.api_version)
  return _internal_api_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AggregatableReportSharedInfo::set_api_version(ArgT0&& arg0, ArgT... args) {
 
 api_version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:content.proto.AggregatableReportSharedInfo.api_version)
}
inline std::string* AggregatableReportSharedInfo::mutable_api_version() {
  std::string* _s = _internal_mutable_api_version();
  // @@protoc_insertion_point(field_mutable:content.proto.AggregatableReportSharedInfo.api_version)
  return _s;
}
inline const std::string& AggregatableReportSharedInfo::_internal_api_version() const {
  return api_version_.Get();
}
inline void AggregatableReportSharedInfo::_internal_set_api_version(const std::string& value) {
  
  api_version_.Set(value, GetArenaForAllocation());
}
inline std::string* AggregatableReportSharedInfo::_internal_mutable_api_version() {
  
  return api_version_.Mutable(GetArenaForAllocation());
}
inline std::string* AggregatableReportSharedInfo::release_api_version() {
  // @@protoc_insertion_point(field_release:content.proto.AggregatableReportSharedInfo.api_version)
  return api_version_.Release();
}
inline void AggregatableReportSharedInfo::set_allocated_api_version(std::string* api_version) {
  if (api_version != nullptr) {
    
  } else {
    
  }
  api_version_.SetAllocated(api_version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (api_version_.IsDefault()) {
    api_version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:content.proto.AggregatableReportSharedInfo.api_version)
}

// string api_identifier = 6;
inline void AggregatableReportSharedInfo::clear_api_identifier() {
  api_identifier_.ClearToEmpty();
}
inline const std::string& AggregatableReportSharedInfo::api_identifier() const {
  // @@protoc_insertion_point(field_get:content.proto.AggregatableReportSharedInfo.api_identifier)
  return _internal_api_identifier();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AggregatableReportSharedInfo::set_api_identifier(ArgT0&& arg0, ArgT... args) {
 
 api_identifier_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:content.proto.AggregatableReportSharedInfo.api_identifier)
}
inline std::string* AggregatableReportSharedInfo::mutable_api_identifier() {
  std::string* _s = _internal_mutable_api_identifier();
  // @@protoc_insertion_point(field_mutable:content.proto.AggregatableReportSharedInfo.api_identifier)
  return _s;
}
inline const std::string& AggregatableReportSharedInfo::_internal_api_identifier() const {
  return api_identifier_.Get();
}
inline void AggregatableReportSharedInfo::_internal_set_api_identifier(const std::string& value) {
  
  api_identifier_.Set(value, GetArenaForAllocation());
}
inline std::string* AggregatableReportSharedInfo::_internal_mutable_api_identifier() {
  
  return api_identifier_.Mutable(GetArenaForAllocation());
}
inline std::string* AggregatableReportSharedInfo::release_api_identifier() {
  // @@protoc_insertion_point(field_release:content.proto.AggregatableReportSharedInfo.api_identifier)
  return api_identifier_.Release();
}
inline void AggregatableReportSharedInfo::set_allocated_api_identifier(std::string* api_identifier) {
  if (api_identifier != nullptr) {
    
  } else {
    
  }
  api_identifier_.SetAllocated(api_identifier, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (api_identifier_.IsDefault()) {
    api_identifier_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:content.proto.AggregatableReportSharedInfo.api_identifier)
}

// -------------------------------------------------------------------

// AggregatableReportRequest

// .content.proto.AggregationServicePayloadContents payload_contents = 1;
inline bool AggregatableReportRequest::_internal_has_payload_contents() const {
  return this != internal_default_instance() && payload_contents_ != nullptr;
}
inline bool AggregatableReportRequest::has_payload_contents() const {
  return _internal_has_payload_contents();
}
inline void AggregatableReportRequest::clear_payload_contents() {
  if (GetArenaForAllocation() == nullptr && payload_contents_ != nullptr) {
    delete payload_contents_;
  }
  payload_contents_ = nullptr;
}
inline const ::content::proto::AggregationServicePayloadContents& AggregatableReportRequest::_internal_payload_contents() const {
  const ::content::proto::AggregationServicePayloadContents* p = payload_contents_;
  return p != nullptr ? *p : reinterpret_cast<const ::content::proto::AggregationServicePayloadContents&>(
      ::content::proto::_AggregationServicePayloadContents_default_instance_);
}
inline const ::content::proto::AggregationServicePayloadContents& AggregatableReportRequest::payload_contents() const {
  // @@protoc_insertion_point(field_get:content.proto.AggregatableReportRequest.payload_contents)
  return _internal_payload_contents();
}
inline void AggregatableReportRequest::unsafe_arena_set_allocated_payload_contents(
    ::content::proto::AggregationServicePayloadContents* payload_contents) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(payload_contents_);
  }
  payload_contents_ = payload_contents;
  if (payload_contents) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:content.proto.AggregatableReportRequest.payload_contents)
}
inline ::content::proto::AggregationServicePayloadContents* AggregatableReportRequest::release_payload_contents() {
  
  ::content::proto::AggregationServicePayloadContents* temp = payload_contents_;
  payload_contents_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::content::proto::AggregationServicePayloadContents* AggregatableReportRequest::unsafe_arena_release_payload_contents() {
  // @@protoc_insertion_point(field_release:content.proto.AggregatableReportRequest.payload_contents)
  
  ::content::proto::AggregationServicePayloadContents* temp = payload_contents_;
  payload_contents_ = nullptr;
  return temp;
}
inline ::content::proto::AggregationServicePayloadContents* AggregatableReportRequest::_internal_mutable_payload_contents() {
  
  if (payload_contents_ == nullptr) {
    auto* p = CreateMaybeMessage<::content::proto::AggregationServicePayloadContents>(GetArenaForAllocation());
    payload_contents_ = p;
  }
  return payload_contents_;
}
inline ::content::proto::AggregationServicePayloadContents* AggregatableReportRequest::mutable_payload_contents() {
  ::content::proto::AggregationServicePayloadContents* _msg = _internal_mutable_payload_contents();
  // @@protoc_insertion_point(field_mutable:content.proto.AggregatableReportRequest.payload_contents)
  return _msg;
}
inline void AggregatableReportRequest::set_allocated_payload_contents(::content::proto::AggregationServicePayloadContents* payload_contents) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete payload_contents_;
  }
  if (payload_contents) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(payload_contents);
    if (message_arena != submessage_arena) {
      payload_contents = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, payload_contents, submessage_arena);
    }
    
  } else {
    
  }
  payload_contents_ = payload_contents;
  // @@protoc_insertion_point(field_set_allocated:content.proto.AggregatableReportRequest.payload_contents)
}

// .content.proto.AggregatableReportSharedInfo shared_info = 2;
inline bool AggregatableReportRequest::_internal_has_shared_info() const {
  return this != internal_default_instance() && shared_info_ != nullptr;
}
inline bool AggregatableReportRequest::has_shared_info() const {
  return _internal_has_shared_info();
}
inline void AggregatableReportRequest::clear_shared_info() {
  if (GetArenaForAllocation() == nullptr && shared_info_ != nullptr) {
    delete shared_info_;
  }
  shared_info_ = nullptr;
}
inline const ::content::proto::AggregatableReportSharedInfo& AggregatableReportRequest::_internal_shared_info() const {
  const ::content::proto::AggregatableReportSharedInfo* p = shared_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::content::proto::AggregatableReportSharedInfo&>(
      ::content::proto::_AggregatableReportSharedInfo_default_instance_);
}
inline const ::content::proto::AggregatableReportSharedInfo& AggregatableReportRequest::shared_info() const {
  // @@protoc_insertion_point(field_get:content.proto.AggregatableReportRequest.shared_info)
  return _internal_shared_info();
}
inline void AggregatableReportRequest::unsafe_arena_set_allocated_shared_info(
    ::content::proto::AggregatableReportSharedInfo* shared_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(shared_info_);
  }
  shared_info_ = shared_info;
  if (shared_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:content.proto.AggregatableReportRequest.shared_info)
}
inline ::content::proto::AggregatableReportSharedInfo* AggregatableReportRequest::release_shared_info() {
  
  ::content::proto::AggregatableReportSharedInfo* temp = shared_info_;
  shared_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::content::proto::AggregatableReportSharedInfo* AggregatableReportRequest::unsafe_arena_release_shared_info() {
  // @@protoc_insertion_point(field_release:content.proto.AggregatableReportRequest.shared_info)
  
  ::content::proto::AggregatableReportSharedInfo* temp = shared_info_;
  shared_info_ = nullptr;
  return temp;
}
inline ::content::proto::AggregatableReportSharedInfo* AggregatableReportRequest::_internal_mutable_shared_info() {
  
  if (shared_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::content::proto::AggregatableReportSharedInfo>(GetArenaForAllocation());
    shared_info_ = p;
  }
  return shared_info_;
}
inline ::content::proto::AggregatableReportSharedInfo* AggregatableReportRequest::mutable_shared_info() {
  ::content::proto::AggregatableReportSharedInfo* _msg = _internal_mutable_shared_info();
  // @@protoc_insertion_point(field_mutable:content.proto.AggregatableReportRequest.shared_info)
  return _msg;
}
inline void AggregatableReportRequest::set_allocated_shared_info(::content::proto::AggregatableReportSharedInfo* shared_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete shared_info_;
  }
  if (shared_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(shared_info);
    if (message_arena != submessage_arena) {
      shared_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, shared_info, submessage_arena);
    }
    
  } else {
    
  }
  shared_info_ = shared_info;
  // @@protoc_insertion_point(field_set_allocated:content.proto.AggregatableReportRequest.shared_info)
}

// string reporting_path = 3;
inline void AggregatableReportRequest::clear_reporting_path() {
  reporting_path_.ClearToEmpty();
}
inline const std::string& AggregatableReportRequest::reporting_path() const {
  // @@protoc_insertion_point(field_get:content.proto.AggregatableReportRequest.reporting_path)
  return _internal_reporting_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AggregatableReportRequest::set_reporting_path(ArgT0&& arg0, ArgT... args) {
 
 reporting_path_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:content.proto.AggregatableReportRequest.reporting_path)
}
inline std::string* AggregatableReportRequest::mutable_reporting_path() {
  std::string* _s = _internal_mutable_reporting_path();
  // @@protoc_insertion_point(field_mutable:content.proto.AggregatableReportRequest.reporting_path)
  return _s;
}
inline const std::string& AggregatableReportRequest::_internal_reporting_path() const {
  return reporting_path_.Get();
}
inline void AggregatableReportRequest::_internal_set_reporting_path(const std::string& value) {
  
  reporting_path_.Set(value, GetArenaForAllocation());
}
inline std::string* AggregatableReportRequest::_internal_mutable_reporting_path() {
  
  return reporting_path_.Mutable(GetArenaForAllocation());
}
inline std::string* AggregatableReportRequest::release_reporting_path() {
  // @@protoc_insertion_point(field_release:content.proto.AggregatableReportRequest.reporting_path)
  return reporting_path_.Release();
}
inline void AggregatableReportRequest::set_allocated_reporting_path(std::string* reporting_path) {
  if (reporting_path != nullptr) {
    
  } else {
    
  }
  reporting_path_.SetAllocated(reporting_path, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (reporting_path_.IsDefault()) {
    reporting_path_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:content.proto.AggregatableReportRequest.reporting_path)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto
}  // namespace content

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::content::proto::AggregationServicePayloadContents_Operation> : ::std::true_type {};
template <> struct is_proto_enum< ::content::proto::AggregatableReportSharedInfo_DebugMode> : ::std::true_type {};
template <> struct is_proto_enum< ::content::proto::AggregationServiceMode> : ::std::true_type {};

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_aggregatable_5freport_2eproto
