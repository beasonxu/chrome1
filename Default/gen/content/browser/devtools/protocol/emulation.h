// This file is generated by TypeBuilder_h.template.

// Copyright (c) 2016 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef content_protocol_Emulation_h
#define content_protocol_Emulation_h

#include "content/common/content_export.h"
#include "content/browser/devtools/protocol/protocol.h"
// For each imported domain we generate a ValueConversions struct instead of a full domain definition
// and include Domain::API version from there.
#include "content/browser/devtools/protocol/dom.h"
#include "content/browser/devtools/protocol/page.h"
#include "content/browser/devtools/protocol/runtime.h"

namespace content {
namespace protocol {
namespace Emulation {
class ScreenOrientation;
class DisplayFeature;
class MediaFeature;
class UserAgentBrandVersion;
class UserAgentMetadata;

// ------------- Forward and enum declarations.

namespace SetEmitTouchEventsForMouse {
namespace ConfigurationEnum {
CONTENT_EXPORT extern const char* Mobile;
CONTENT_EXPORT extern const char* Desktop;
} // ConfigurationEnum
} // SetEmitTouchEventsForMouse

namespace SetEmulatedVisionDeficiency {
namespace TypeEnum {
CONTENT_EXPORT extern const char* None;
CONTENT_EXPORT extern const char* Achromatopsia;
CONTENT_EXPORT extern const char* BlurredVision;
CONTENT_EXPORT extern const char* Deuteranopia;
CONTENT_EXPORT extern const char* Protanopia;
CONTENT_EXPORT extern const char* Tritanopia;
} // TypeEnum
} // SetEmulatedVisionDeficiency

// ------------- Type and builder declarations.

class CONTENT_EXPORT ScreenOrientation : public ::crdtp::ProtocolObject<ScreenOrientation> {
public:
    ~ScreenOrientation() override { }

    struct CONTENT_EXPORT TypeEnum {
        static const char* PortraitPrimary;
        static const char* PortraitSecondary;
        static const char* LandscapePrimary;
        static const char* LandscapeSecondary;
    }; // TypeEnum

    String GetType() { return m_type; }
    void SetType(const String& value) { m_type = value; }

    int GetAngle() { return m_angle; }
    void SetAngle(int value) { m_angle = value; }

    template<int STATE>
    class ScreenOrientationBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            TypeSet = 1 << 1,
            AngleSet = 1 << 2,
            AllFieldsSet = (TypeSet | AngleSet | 0)};


        ScreenOrientationBuilder<STATE | TypeSet>& SetType(const String& value)
        {
            static_assert(!(STATE & TypeSet), "property type should not be set yet");
            m_result->SetType(value);
            return castState<TypeSet>();
        }

        ScreenOrientationBuilder<STATE | AngleSet>& SetAngle(int value)
        {
            static_assert(!(STATE & AngleSet), "property angle should not be set yet");
            m_result->SetAngle(value);
            return castState<AngleSet>();
        }

        std::unique_ptr<ScreenOrientation> Build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class ScreenOrientation;
        ScreenOrientationBuilder() : m_result(new ScreenOrientation()) { }

        template<int STEP> ScreenOrientationBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<ScreenOrientationBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Emulation::ScreenOrientation> m_result;
    };

    static ScreenOrientationBuilder<0> Create()
    {
        return ScreenOrientationBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    ScreenOrientation()
    {
          m_angle = 0;
    }

    String m_type;
    int m_angle;
};


class CONTENT_EXPORT DisplayFeature : public ::crdtp::ProtocolObject<DisplayFeature> {
public:
    ~DisplayFeature() override { }

    struct CONTENT_EXPORT OrientationEnum {
        static const char* Vertical;
        static const char* Horizontal;
    }; // OrientationEnum

    String GetOrientation() { return m_orientation; }
    void SetOrientation(const String& value) { m_orientation = value; }

    int GetOffset() { return m_offset; }
    void SetOffset(int value) { m_offset = value; }

    int GetMaskLength() { return m_maskLength; }
    void SetMaskLength(int value) { m_maskLength = value; }

    template<int STATE>
    class DisplayFeatureBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            OrientationSet = 1 << 1,
            OffsetSet = 1 << 2,
            MaskLengthSet = 1 << 3,
            AllFieldsSet = (OrientationSet | OffsetSet | MaskLengthSet | 0)};


        DisplayFeatureBuilder<STATE | OrientationSet>& SetOrientation(const String& value)
        {
            static_assert(!(STATE & OrientationSet), "property orientation should not be set yet");
            m_result->SetOrientation(value);
            return castState<OrientationSet>();
        }

        DisplayFeatureBuilder<STATE | OffsetSet>& SetOffset(int value)
        {
            static_assert(!(STATE & OffsetSet), "property offset should not be set yet");
            m_result->SetOffset(value);
            return castState<OffsetSet>();
        }

        DisplayFeatureBuilder<STATE | MaskLengthSet>& SetMaskLength(int value)
        {
            static_assert(!(STATE & MaskLengthSet), "property maskLength should not be set yet");
            m_result->SetMaskLength(value);
            return castState<MaskLengthSet>();
        }

        std::unique_ptr<DisplayFeature> Build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class DisplayFeature;
        DisplayFeatureBuilder() : m_result(new DisplayFeature()) { }

        template<int STEP> DisplayFeatureBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<DisplayFeatureBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Emulation::DisplayFeature> m_result;
    };

    static DisplayFeatureBuilder<0> Create()
    {
        return DisplayFeatureBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    DisplayFeature()
    {
          m_offset = 0;
          m_maskLength = 0;
    }

    String m_orientation;
    int m_offset;
    int m_maskLength;
};


class CONTENT_EXPORT MediaFeature : public ::crdtp::ProtocolObject<MediaFeature> {
public:
    ~MediaFeature() override { }

    String GetName() { return m_name; }
    void SetName(const String& value) { m_name = value; }

    String GetValue() { return m_value; }
    void SetValue(const String& value) { m_value = value; }

    template<int STATE>
    class MediaFeatureBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            NameSet = 1 << 1,
            ValueSet = 1 << 2,
            AllFieldsSet = (NameSet | ValueSet | 0)};


        MediaFeatureBuilder<STATE | NameSet>& SetName(const String& value)
        {
            static_assert(!(STATE & NameSet), "property name should not be set yet");
            m_result->SetName(value);
            return castState<NameSet>();
        }

        MediaFeatureBuilder<STATE | ValueSet>& SetValue(const String& value)
        {
            static_assert(!(STATE & ValueSet), "property value should not be set yet");
            m_result->SetValue(value);
            return castState<ValueSet>();
        }

        std::unique_ptr<MediaFeature> Build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class MediaFeature;
        MediaFeatureBuilder() : m_result(new MediaFeature()) { }

        template<int STEP> MediaFeatureBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<MediaFeatureBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Emulation::MediaFeature> m_result;
    };

    static MediaFeatureBuilder<0> Create()
    {
        return MediaFeatureBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    MediaFeature()
    {
    }

    String m_name;
    String m_value;
};


class CONTENT_EXPORT UserAgentBrandVersion : public ::crdtp::ProtocolObject<UserAgentBrandVersion> {
public:
    ~UserAgentBrandVersion() override { }

    String GetBrand() { return m_brand; }
    void SetBrand(const String& value) { m_brand = value; }

    String GetVersion() { return m_version; }
    void SetVersion(const String& value) { m_version = value; }

    template<int STATE>
    class UserAgentBrandVersionBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            BrandSet = 1 << 1,
            VersionSet = 1 << 2,
            AllFieldsSet = (BrandSet | VersionSet | 0)};


        UserAgentBrandVersionBuilder<STATE | BrandSet>& SetBrand(const String& value)
        {
            static_assert(!(STATE & BrandSet), "property brand should not be set yet");
            m_result->SetBrand(value);
            return castState<BrandSet>();
        }

        UserAgentBrandVersionBuilder<STATE | VersionSet>& SetVersion(const String& value)
        {
            static_assert(!(STATE & VersionSet), "property version should not be set yet");
            m_result->SetVersion(value);
            return castState<VersionSet>();
        }

        std::unique_ptr<UserAgentBrandVersion> Build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class UserAgentBrandVersion;
        UserAgentBrandVersionBuilder() : m_result(new UserAgentBrandVersion()) { }

        template<int STEP> UserAgentBrandVersionBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<UserAgentBrandVersionBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Emulation::UserAgentBrandVersion> m_result;
    };

    static UserAgentBrandVersionBuilder<0> Create()
    {
        return UserAgentBrandVersionBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    UserAgentBrandVersion()
    {
    }

    String m_brand;
    String m_version;
};


class CONTENT_EXPORT UserAgentMetadata : public ::crdtp::ProtocolObject<UserAgentMetadata> {
public:
    ~UserAgentMetadata() override { }

    bool HasBrands() { return m_brands.isJust(); }
    protocol::Array<protocol::Emulation::UserAgentBrandVersion>* GetBrands(protocol::Array<protocol::Emulation::UserAgentBrandVersion>* defaultValue) { return m_brands.isJust() ? m_brands.fromJust() : defaultValue; }
    void SetBrands(std::unique_ptr<protocol::Array<protocol::Emulation::UserAgentBrandVersion>> value) { m_brands = std::move(value); }

    bool HasFullVersionList() { return m_fullVersionList.isJust(); }
    protocol::Array<protocol::Emulation::UserAgentBrandVersion>* GetFullVersionList(protocol::Array<protocol::Emulation::UserAgentBrandVersion>* defaultValue) { return m_fullVersionList.isJust() ? m_fullVersionList.fromJust() : defaultValue; }
    void SetFullVersionList(std::unique_ptr<protocol::Array<protocol::Emulation::UserAgentBrandVersion>> value) { m_fullVersionList = std::move(value); }

    bool HasFullVersion() { return m_fullVersion.isJust(); }
    String GetFullVersion(const String& defaultValue) { return m_fullVersion.isJust() ? m_fullVersion.fromJust() : defaultValue; }
    void SetFullVersion(const String& value) { m_fullVersion = value; }

    String GetPlatform() { return m_platform; }
    void SetPlatform(const String& value) { m_platform = value; }

    String GetPlatformVersion() { return m_platformVersion; }
    void SetPlatformVersion(const String& value) { m_platformVersion = value; }

    String GetArchitecture() { return m_architecture; }
    void SetArchitecture(const String& value) { m_architecture = value; }

    String GetModel() { return m_model; }
    void SetModel(const String& value) { m_model = value; }

    bool GetMobile() { return m_mobile; }
    void SetMobile(bool value) { m_mobile = value; }

    bool HasBitness() { return m_bitness.isJust(); }
    String GetBitness(const String& defaultValue) { return m_bitness.isJust() ? m_bitness.fromJust() : defaultValue; }
    void SetBitness(const String& value) { m_bitness = value; }

    bool HasWow64() { return m_wow64.isJust(); }
    bool GetWow64(bool defaultValue) { return m_wow64.isJust() ? m_wow64.fromJust() : defaultValue; }
    void SetWow64(bool value) { m_wow64 = value; }

    template<int STATE>
    class UserAgentMetadataBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            PlatformSet = 1 << 1,
            PlatformVersionSet = 1 << 2,
            ArchitectureSet = 1 << 3,
            ModelSet = 1 << 4,
            MobileSet = 1 << 5,
            AllFieldsSet = (PlatformSet | PlatformVersionSet | ArchitectureSet | ModelSet | MobileSet | 0)};


        UserAgentMetadataBuilder<STATE>& SetBrands(std::unique_ptr<protocol::Array<protocol::Emulation::UserAgentBrandVersion>> value)
        {
            m_result->SetBrands(std::move(value));
            return *this;
        }

        UserAgentMetadataBuilder<STATE>& SetFullVersionList(std::unique_ptr<protocol::Array<protocol::Emulation::UserAgentBrandVersion>> value)
        {
            m_result->SetFullVersionList(std::move(value));
            return *this;
        }

        UserAgentMetadataBuilder<STATE>& SetFullVersion(const String& value)
        {
            m_result->SetFullVersion(value);
            return *this;
        }

        UserAgentMetadataBuilder<STATE | PlatformSet>& SetPlatform(const String& value)
        {
            static_assert(!(STATE & PlatformSet), "property platform should not be set yet");
            m_result->SetPlatform(value);
            return castState<PlatformSet>();
        }

        UserAgentMetadataBuilder<STATE | PlatformVersionSet>& SetPlatformVersion(const String& value)
        {
            static_assert(!(STATE & PlatformVersionSet), "property platformVersion should not be set yet");
            m_result->SetPlatformVersion(value);
            return castState<PlatformVersionSet>();
        }

        UserAgentMetadataBuilder<STATE | ArchitectureSet>& SetArchitecture(const String& value)
        {
            static_assert(!(STATE & ArchitectureSet), "property architecture should not be set yet");
            m_result->SetArchitecture(value);
            return castState<ArchitectureSet>();
        }

        UserAgentMetadataBuilder<STATE | ModelSet>& SetModel(const String& value)
        {
            static_assert(!(STATE & ModelSet), "property model should not be set yet");
            m_result->SetModel(value);
            return castState<ModelSet>();
        }

        UserAgentMetadataBuilder<STATE | MobileSet>& SetMobile(bool value)
        {
            static_assert(!(STATE & MobileSet), "property mobile should not be set yet");
            m_result->SetMobile(value);
            return castState<MobileSet>();
        }

        UserAgentMetadataBuilder<STATE>& SetBitness(const String& value)
        {
            m_result->SetBitness(value);
            return *this;
        }

        UserAgentMetadataBuilder<STATE>& SetWow64(bool value)
        {
            m_result->SetWow64(value);
            return *this;
        }

        std::unique_ptr<UserAgentMetadata> Build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class UserAgentMetadata;
        UserAgentMetadataBuilder() : m_result(new UserAgentMetadata()) { }

        template<int STEP> UserAgentMetadataBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<UserAgentMetadataBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Emulation::UserAgentMetadata> m_result;
    };

    static UserAgentMetadataBuilder<0> Create()
    {
        return UserAgentMetadataBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    UserAgentMetadata()
    {
          m_mobile = false;
    }

    Maybe<protocol::Array<protocol::Emulation::UserAgentBrandVersion>> m_brands;
    Maybe<protocol::Array<protocol::Emulation::UserAgentBrandVersion>> m_fullVersionList;
    Maybe<String> m_fullVersion;
    String m_platform;
    String m_platformVersion;
    String m_architecture;
    String m_model;
    bool m_mobile;
    Maybe<String> m_bitness;
    Maybe<bool> m_wow64;
};


// ------------- Backend interface.

class CONTENT_EXPORT Backend {
public:
    virtual ~Backend() { }

    virtual DispatchResponse CanEmulate(bool* out_result) = 0;
    virtual DispatchResponse ClearDeviceMetricsOverride() = 0;
    virtual DispatchResponse ClearGeolocationOverride() = 0;
    virtual DispatchResponse SetFocusEmulationEnabled(bool in_enabled) = 0;
    virtual DispatchResponse SetDeviceMetricsOverride(int in_width, int in_height, double in_deviceScaleFactor, bool in_mobile, Maybe<double> in_scale, Maybe<int> in_screenWidth, Maybe<int> in_screenHeight, Maybe<int> in_positionX, Maybe<int> in_positionY, Maybe<bool> in_dontSetVisibleSize, Maybe<protocol::Emulation::ScreenOrientation> in_screenOrientation, Maybe<protocol::Page::Viewport> in_viewport, Maybe<protocol::Emulation::DisplayFeature> in_displayFeature) = 0;
    virtual DispatchResponse SetEmitTouchEventsForMouse(bool in_enabled, Maybe<String> in_configuration) = 0;
    virtual DispatchResponse SetEmulatedMedia(Maybe<String> in_media, Maybe<protocol::Array<protocol::Emulation::MediaFeature>> in_features) = 0;
    virtual DispatchResponse SetGeolocationOverride(Maybe<double> in_latitude, Maybe<double> in_longitude, Maybe<double> in_accuracy) = 0;
    virtual DispatchResponse SetIdleOverride(bool in_isUserActive, bool in_isScreenUnlocked) = 0;
    virtual DispatchResponse ClearIdleOverride() = 0;
    virtual DispatchResponse SetVisibleSize(int in_width, int in_height) = 0;
    virtual DispatchResponse SetUserAgentOverride(const String& in_userAgent, Maybe<String> in_acceptLanguage, Maybe<String> in_platform, Maybe<protocol::Emulation::UserAgentMetadata> in_userAgentMetadata) = 0;

    virtual DispatchResponse Disable()
    {
        return DispatchResponse::Success();
    }
};

// ------------- Frontend interface.

class CONTENT_EXPORT Frontend {
public:
  explicit Frontend(FrontendChannel* frontend_channel) : frontend_channel_(frontend_channel) {}
    void VirtualTimeBudgetExpired();

  void flush();
  void sendRawNotification(std::unique_ptr<Serializable>);
 private:
  FrontendChannel* frontend_channel_;
};

// ------------- Dispatcher.

class CONTENT_EXPORT Dispatcher {
public:
    static void wire(UberDispatcher*, Backend*);

private:
    Dispatcher() { }
};

// ------------- Metainfo.

class CONTENT_EXPORT Metainfo {
public:
    using BackendClass = Backend;
    using FrontendClass = Frontend;
    using DispatcherClass = Dispatcher;
    static const char domainName[];
    static const char commandPrefix[];
    static const char version[];
};

} // namespace Emulation
} // namespace content
} // namespace protocol

#endif // !defined(content_protocol_Emulation_h)
