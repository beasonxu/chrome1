// This file is generated by TypeBuilder_h.template.

// Copyright (c) 2016 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef content_protocol_Audits_h
#define content_protocol_Audits_h

#include "content/common/content_export.h"
#include "content/browser/devtools/protocol/protocol.h"
// For each imported domain we generate a ValueConversions struct instead of a full domain definition
// and include Domain::API version from there.
#include "content/browser/devtools/protocol/network.h"

namespace content {
namespace protocol {
namespace Audits {
class AffectedCookie;
class AffectedRequest;
class AffectedFrame;
using CookieExclusionReason = String;
using CookieWarningReason = String;
using CookieOperation = String;
class CookieIssueDetails;
using MixedContentResolutionStatus = String;
using MixedContentResourceType = String;
class MixedContentIssueDetails;
using BlockedByResponseReason = String;
class BlockedByResponseIssueDetails;
using HeavyAdResolutionStatus = String;
using HeavyAdReason = String;
class HeavyAdIssueDetails;
using ContentSecurityPolicyViolationType = String;
class SourceCodeLocation;
class ContentSecurityPolicyIssueDetails;
using SharedArrayBufferIssueType = String;
class SharedArrayBufferIssueDetails;
using TwaQualityEnforcementViolationType = String;
class TrustedWebActivityIssueDetails;
class LowTextContrastIssueDetails;
class CorsIssueDetails;
using AttributionReportingIssueType = String;
class AttributionReportingIssueDetails;
class QuirksModeIssueDetails;
class NavigatorUserAgentIssueDetails;
using GenericIssueErrorType = String;
class GenericIssueDetails;
using DeprecationIssueType = String;
class DeprecationIssueDetails;
using ClientHintIssueReason = String;
class FederatedAuthRequestIssueDetails;
using FederatedAuthRequestIssueReason = String;
class ClientHintIssueDetails;
using InspectorIssueCode = String;
class InspectorIssueDetails;
using IssueId = String;
class InspectorIssue;

// ------------- Forward and enum declarations.

namespace CookieExclusionReasonEnum {
CONTENT_EXPORT extern const char ExcludeSameSiteUnspecifiedTreatedAsLax[];
CONTENT_EXPORT extern const char ExcludeSameSiteNoneInsecure[];
CONTENT_EXPORT extern const char ExcludeSameSiteLax[];
CONTENT_EXPORT extern const char ExcludeSameSiteStrict[];
CONTENT_EXPORT extern const char ExcludeInvalidSameParty[];
CONTENT_EXPORT extern const char ExcludeSamePartyCrossPartyContext[];
CONTENT_EXPORT extern const char ExcludeDomainNonASCII[];
} // namespace CookieExclusionReasonEnum

namespace CookieWarningReasonEnum {
CONTENT_EXPORT extern const char WarnSameSiteUnspecifiedCrossSiteContext[];
CONTENT_EXPORT extern const char WarnSameSiteNoneInsecure[];
CONTENT_EXPORT extern const char WarnSameSiteUnspecifiedLaxAllowUnsafe[];
CONTENT_EXPORT extern const char WarnSameSiteStrictLaxDowngradeStrict[];
CONTENT_EXPORT extern const char WarnSameSiteStrictCrossDowngradeStrict[];
CONTENT_EXPORT extern const char WarnSameSiteStrictCrossDowngradeLax[];
CONTENT_EXPORT extern const char WarnSameSiteLaxCrossDowngradeStrict[];
CONTENT_EXPORT extern const char WarnSameSiteLaxCrossDowngradeLax[];
CONTENT_EXPORT extern const char WarnAttributeValueExceedsMaxSize[];
CONTENT_EXPORT extern const char WarnDomainNonASCII[];
} // namespace CookieWarningReasonEnum

namespace CookieOperationEnum {
CONTENT_EXPORT extern const char SetCookie[];
CONTENT_EXPORT extern const char ReadCookie[];
} // namespace CookieOperationEnum

namespace MixedContentResolutionStatusEnum {
CONTENT_EXPORT extern const char MixedContentBlocked[];
CONTENT_EXPORT extern const char MixedContentAutomaticallyUpgraded[];
CONTENT_EXPORT extern const char MixedContentWarning[];
} // namespace MixedContentResolutionStatusEnum

namespace MixedContentResourceTypeEnum {
CONTENT_EXPORT extern const char AttributionSrc[];
CONTENT_EXPORT extern const char Audio[];
CONTENT_EXPORT extern const char Beacon[];
CONTENT_EXPORT extern const char CSPReport[];
CONTENT_EXPORT extern const char Download[];
CONTENT_EXPORT extern const char EventSource[];
CONTENT_EXPORT extern const char Favicon[];
CONTENT_EXPORT extern const char Font[];
CONTENT_EXPORT extern const char Form[];
CONTENT_EXPORT extern const char Frame[];
CONTENT_EXPORT extern const char Image[];
CONTENT_EXPORT extern const char Import[];
CONTENT_EXPORT extern const char Manifest[];
CONTENT_EXPORT extern const char Ping[];
CONTENT_EXPORT extern const char PluginData[];
CONTENT_EXPORT extern const char PluginResource[];
CONTENT_EXPORT extern const char Prefetch[];
CONTENT_EXPORT extern const char Resource[];
CONTENT_EXPORT extern const char Script[];
CONTENT_EXPORT extern const char ServiceWorker[];
CONTENT_EXPORT extern const char SharedWorker[];
CONTENT_EXPORT extern const char Stylesheet[];
CONTENT_EXPORT extern const char Track[];
CONTENT_EXPORT extern const char Video[];
CONTENT_EXPORT extern const char Worker[];
CONTENT_EXPORT extern const char XMLHttpRequest[];
CONTENT_EXPORT extern const char XSLT[];
} // namespace MixedContentResourceTypeEnum

namespace BlockedByResponseReasonEnum {
CONTENT_EXPORT extern const char CoepFrameResourceNeedsCoepHeader[];
CONTENT_EXPORT extern const char CoopSandboxedIFrameCannotNavigateToCoopPage[];
CONTENT_EXPORT extern const char CorpNotSameOrigin[];
CONTENT_EXPORT extern const char CorpNotSameOriginAfterDefaultedToSameOriginByCoep[];
CONTENT_EXPORT extern const char CorpNotSameSite[];
} // namespace BlockedByResponseReasonEnum

namespace HeavyAdResolutionStatusEnum {
CONTENT_EXPORT extern const char HeavyAdBlocked[];
CONTENT_EXPORT extern const char HeavyAdWarning[];
} // namespace HeavyAdResolutionStatusEnum

namespace HeavyAdReasonEnum {
CONTENT_EXPORT extern const char NetworkTotalLimit[];
CONTENT_EXPORT extern const char CpuTotalLimit[];
CONTENT_EXPORT extern const char CpuPeakLimit[];
} // namespace HeavyAdReasonEnum

namespace ContentSecurityPolicyViolationTypeEnum {
CONTENT_EXPORT extern const char KInlineViolation[];
CONTENT_EXPORT extern const char KEvalViolation[];
CONTENT_EXPORT extern const char KURLViolation[];
CONTENT_EXPORT extern const char KTrustedTypesSinkViolation[];
CONTENT_EXPORT extern const char KTrustedTypesPolicyViolation[];
CONTENT_EXPORT extern const char KWasmEvalViolation[];
} // namespace ContentSecurityPolicyViolationTypeEnum

namespace SharedArrayBufferIssueTypeEnum {
CONTENT_EXPORT extern const char TransferIssue[];
CONTENT_EXPORT extern const char CreationIssue[];
} // namespace SharedArrayBufferIssueTypeEnum

namespace TwaQualityEnforcementViolationTypeEnum {
CONTENT_EXPORT extern const char KHttpError[];
CONTENT_EXPORT extern const char KUnavailableOffline[];
CONTENT_EXPORT extern const char KDigitalAssetLinks[];
} // namespace TwaQualityEnforcementViolationTypeEnum

namespace AttributionReportingIssueTypeEnum {
CONTENT_EXPORT extern const char PermissionPolicyDisabled[];
CONTENT_EXPORT extern const char UntrustworthyReportingOrigin[];
CONTENT_EXPORT extern const char InsecureContext[];
CONTENT_EXPORT extern const char InvalidHeader[];
CONTENT_EXPORT extern const char InvalidRegisterTriggerHeader[];
CONTENT_EXPORT extern const char InvalidEligibleHeader[];
CONTENT_EXPORT extern const char TooManyConcurrentRequests[];
CONTENT_EXPORT extern const char SourceAndTriggerHeaders[];
CONTENT_EXPORT extern const char SourceIgnored[];
CONTENT_EXPORT extern const char TriggerIgnored[];
} // namespace AttributionReportingIssueTypeEnum

namespace GenericIssueErrorTypeEnum {
CONTENT_EXPORT extern const char CrossOriginPortalPostMessageError[];
} // namespace GenericIssueErrorTypeEnum

namespace DeprecationIssueTypeEnum {
CONTENT_EXPORT extern const char AuthorizationCoveredByWildcard[];
CONTENT_EXPORT extern const char CanRequestURLHTTPContainingNewline[];
CONTENT_EXPORT extern const char ChromeLoadTimesConnectionInfo[];
CONTENT_EXPORT extern const char ChromeLoadTimesFirstPaintAfterLoadTime[];
CONTENT_EXPORT extern const char ChromeLoadTimesWasAlternateProtocolAvailable[];
CONTENT_EXPORT extern const char CookieWithTruncatingChar[];
CONTENT_EXPORT extern const char CrossOriginAccessBasedOnDocumentDomain[];
CONTENT_EXPORT extern const char CrossOriginWindowAlert[];
CONTENT_EXPORT extern const char CrossOriginWindowConfirm[];
CONTENT_EXPORT extern const char CSSSelectorInternalMediaControlsOverlayCastButton[];
CONTENT_EXPORT extern const char DeprecationExample[];
CONTENT_EXPORT extern const char DocumentDomainSettingWithoutOriginAgentClusterHeader[];
CONTENT_EXPORT extern const char EventPath[];
CONTENT_EXPORT extern const char ExpectCTHeader[];
CONTENT_EXPORT extern const char GeolocationInsecureOrigin[];
CONTENT_EXPORT extern const char GeolocationInsecureOriginDeprecatedNotRemoved[];
CONTENT_EXPORT extern const char GetUserMediaInsecureOrigin[];
CONTENT_EXPORT extern const char HostCandidateAttributeGetter[];
CONTENT_EXPORT extern const char IdentityInCanMakePaymentEvent[];
CONTENT_EXPORT extern const char InsecurePrivateNetworkSubresourceRequest[];
CONTENT_EXPORT extern const char LegacyConstraintGoogIPv6[];
CONTENT_EXPORT extern const char LocalCSSFileExtensionRejected[];
CONTENT_EXPORT extern const char MediaSourceAbortRemove[];
CONTENT_EXPORT extern const char MediaSourceDurationTruncatingBuffered[];
CONTENT_EXPORT extern const char NavigateEventRestoreScroll[];
CONTENT_EXPORT extern const char NavigateEventTransitionWhile[];
CONTENT_EXPORT extern const char NoSysexWebMIDIWithoutPermission[];
CONTENT_EXPORT extern const char NotificationInsecureOrigin[];
CONTENT_EXPORT extern const char NotificationPermissionRequestedIframe[];
CONTENT_EXPORT extern const char ObsoleteWebRtcCipherSuite[];
CONTENT_EXPORT extern const char OpenWebDatabaseInsecureContext[];
CONTENT_EXPORT extern const char OverflowVisibleOnReplacedElement[];
CONTENT_EXPORT extern const char PersistentQuotaType[];
CONTENT_EXPORT extern const char PictureSourceSrc[];
CONTENT_EXPORT extern const char PrefixedCancelAnimationFrame[];
CONTENT_EXPORT extern const char PrefixedRequestAnimationFrame[];
CONTENT_EXPORT extern const char PrefixedStorageInfo[];
CONTENT_EXPORT extern const char PrefixedVideoDisplayingFullscreen[];
CONTENT_EXPORT extern const char PrefixedVideoEnterFullscreen[];
CONTENT_EXPORT extern const char PrefixedVideoEnterFullScreen[];
CONTENT_EXPORT extern const char PrefixedVideoExitFullscreen[];
CONTENT_EXPORT extern const char PrefixedVideoExitFullScreen[];
CONTENT_EXPORT extern const char PrefixedVideoSupportsFullscreen[];
CONTENT_EXPORT extern const char RangeExpand[];
CONTENT_EXPORT extern const char RequestedSubresourceWithEmbeddedCredentials[];
CONTENT_EXPORT extern const char RTCConstraintEnableDtlsSrtpFalse[];
CONTENT_EXPORT extern const char RTCConstraintEnableDtlsSrtpTrue[];
CONTENT_EXPORT extern const char RTCPeerConnectionComplexPlanBSdpUsingDefaultSdpSemantics[];
CONTENT_EXPORT extern const char RTCPeerConnectionSdpSemanticsPlanB[];
CONTENT_EXPORT extern const char RtcpMuxPolicyNegotiate[];
CONTENT_EXPORT extern const char SharedArrayBufferConstructedWithoutIsolation[];
CONTENT_EXPORT extern const char TextToSpeech_DisallowedByAutoplay[];
CONTENT_EXPORT extern const char V8SharedArrayBufferConstructedInExtensionWithoutIsolation[];
CONTENT_EXPORT extern const char XHRJSONEncodingDetection[];
CONTENT_EXPORT extern const char XMLHttpRequestSynchronousInNonWorkerOutsideBeforeUnload[];
CONTENT_EXPORT extern const char XRSupportsSession[];
} // namespace DeprecationIssueTypeEnum

namespace ClientHintIssueReasonEnum {
CONTENT_EXPORT extern const char MetaTagAllowListInvalidOrigin[];
CONTENT_EXPORT extern const char MetaTagModifiedHTML[];
} // namespace ClientHintIssueReasonEnum

namespace FederatedAuthRequestIssueReasonEnum {
CONTENT_EXPORT extern const char ApprovalDeclined[];
CONTENT_EXPORT extern const char TooManyRequests[];
CONTENT_EXPORT extern const char ManifestListHttpNotFound[];
CONTENT_EXPORT extern const char ManifestListNoResponse[];
CONTENT_EXPORT extern const char ManifestListInvalidResponse[];
CONTENT_EXPORT extern const char ManifestNotInManifestList[];
CONTENT_EXPORT extern const char ManifestListTooBig[];
CONTENT_EXPORT extern const char ManifestHttpNotFound[];
CONTENT_EXPORT extern const char ManifestNoResponse[];
CONTENT_EXPORT extern const char ManifestInvalidResponse[];
CONTENT_EXPORT extern const char ClientMetadataHttpNotFound[];
CONTENT_EXPORT extern const char ClientMetadataNoResponse[];
CONTENT_EXPORT extern const char ClientMetadataInvalidResponse[];
CONTENT_EXPORT extern const char DisabledInSettings[];
CONTENT_EXPORT extern const char ErrorFetchingSignin[];
CONTENT_EXPORT extern const char InvalidSigninResponse[];
CONTENT_EXPORT extern const char AccountsHttpNotFound[];
CONTENT_EXPORT extern const char AccountsNoResponse[];
CONTENT_EXPORT extern const char AccountsInvalidResponse[];
CONTENT_EXPORT extern const char IdTokenHttpNotFound[];
CONTENT_EXPORT extern const char IdTokenNoResponse[];
CONTENT_EXPORT extern const char IdTokenInvalidResponse[];
CONTENT_EXPORT extern const char IdTokenInvalidRequest[];
CONTENT_EXPORT extern const char ErrorIdToken[];
CONTENT_EXPORT extern const char Canceled[];
} // namespace FederatedAuthRequestIssueReasonEnum

namespace InspectorIssueCodeEnum {
CONTENT_EXPORT extern const char CookieIssue[];
CONTENT_EXPORT extern const char MixedContentIssue[];
CONTENT_EXPORT extern const char BlockedByResponseIssue[];
CONTENT_EXPORT extern const char HeavyAdIssue[];
CONTENT_EXPORT extern const char ContentSecurityPolicyIssue[];
CONTENT_EXPORT extern const char SharedArrayBufferIssue[];
CONTENT_EXPORT extern const char TrustedWebActivityIssue[];
CONTENT_EXPORT extern const char LowTextContrastIssue[];
CONTENT_EXPORT extern const char CorsIssue[];
CONTENT_EXPORT extern const char AttributionReportingIssue[];
CONTENT_EXPORT extern const char QuirksModeIssue[];
CONTENT_EXPORT extern const char NavigatorUserAgentIssue[];
CONTENT_EXPORT extern const char GenericIssue[];
CONTENT_EXPORT extern const char DeprecationIssue[];
CONTENT_EXPORT extern const char ClientHintIssue[];
CONTENT_EXPORT extern const char FederatedAuthRequestIssue[];
} // namespace InspectorIssueCodeEnum

namespace GetEncodedResponse {
namespace EncodingEnum {
CONTENT_EXPORT extern const char* Webp;
CONTENT_EXPORT extern const char* Jpeg;
CONTENT_EXPORT extern const char* Png;
} // EncodingEnum
} // GetEncodedResponse

// ------------- Type and builder declarations.

class CONTENT_EXPORT AffectedCookie : public ::crdtp::ProtocolObject<AffectedCookie> {
public:
    ~AffectedCookie() override { }

    String GetName() { return m_name; }
    void SetName(const String& value) { m_name = value; }

    String GetPath() { return m_path; }
    void SetPath(const String& value) { m_path = value; }

    String GetDomain() { return m_domain; }
    void SetDomain(const String& value) { m_domain = value; }

    template<int STATE>
    class AffectedCookieBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            NameSet = 1 << 1,
            PathSet = 1 << 2,
            DomainSet = 1 << 3,
            AllFieldsSet = (NameSet | PathSet | DomainSet | 0)};


        AffectedCookieBuilder<STATE | NameSet>& SetName(const String& value)
        {
            static_assert(!(STATE & NameSet), "property name should not be set yet");
            m_result->SetName(value);
            return castState<NameSet>();
        }

        AffectedCookieBuilder<STATE | PathSet>& SetPath(const String& value)
        {
            static_assert(!(STATE & PathSet), "property path should not be set yet");
            m_result->SetPath(value);
            return castState<PathSet>();
        }

        AffectedCookieBuilder<STATE | DomainSet>& SetDomain(const String& value)
        {
            static_assert(!(STATE & DomainSet), "property domain should not be set yet");
            m_result->SetDomain(value);
            return castState<DomainSet>();
        }

        std::unique_ptr<AffectedCookie> Build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class AffectedCookie;
        AffectedCookieBuilder() : m_result(new AffectedCookie()) { }

        template<int STEP> AffectedCookieBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<AffectedCookieBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Audits::AffectedCookie> m_result;
    };

    static AffectedCookieBuilder<0> Create()
    {
        return AffectedCookieBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    AffectedCookie()
    {
    }

    String m_name;
    String m_path;
    String m_domain;
};


class CONTENT_EXPORT AffectedRequest : public ::crdtp::ProtocolObject<AffectedRequest> {
public:
    ~AffectedRequest() override { }

    String GetRequestId() { return m_requestId; }
    void SetRequestId(const String& value) { m_requestId = value; }

    bool HasUrl() { return m_url.isJust(); }
    String GetUrl(const String& defaultValue) { return m_url.isJust() ? m_url.fromJust() : defaultValue; }
    void SetUrl(const String& value) { m_url = value; }

    template<int STATE>
    class AffectedRequestBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            RequestIdSet = 1 << 1,
            AllFieldsSet = (RequestIdSet | 0)};


        AffectedRequestBuilder<STATE | RequestIdSet>& SetRequestId(const String& value)
        {
            static_assert(!(STATE & RequestIdSet), "property requestId should not be set yet");
            m_result->SetRequestId(value);
            return castState<RequestIdSet>();
        }

        AffectedRequestBuilder<STATE>& SetUrl(const String& value)
        {
            m_result->SetUrl(value);
            return *this;
        }

        std::unique_ptr<AffectedRequest> Build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class AffectedRequest;
        AffectedRequestBuilder() : m_result(new AffectedRequest()) { }

        template<int STEP> AffectedRequestBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<AffectedRequestBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Audits::AffectedRequest> m_result;
    };

    static AffectedRequestBuilder<0> Create()
    {
        return AffectedRequestBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    AffectedRequest()
    {
    }

    String m_requestId;
    Maybe<String> m_url;
};


class CONTENT_EXPORT AffectedFrame : public ::crdtp::ProtocolObject<AffectedFrame> {
public:
    ~AffectedFrame() override { }

    String GetFrameId() { return m_frameId; }
    void SetFrameId(const String& value) { m_frameId = value; }

    template<int STATE>
    class AffectedFrameBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            FrameIdSet = 1 << 1,
            AllFieldsSet = (FrameIdSet | 0)};


        AffectedFrameBuilder<STATE | FrameIdSet>& SetFrameId(const String& value)
        {
            static_assert(!(STATE & FrameIdSet), "property frameId should not be set yet");
            m_result->SetFrameId(value);
            return castState<FrameIdSet>();
        }

        std::unique_ptr<AffectedFrame> Build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class AffectedFrame;
        AffectedFrameBuilder() : m_result(new AffectedFrame()) { }

        template<int STEP> AffectedFrameBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<AffectedFrameBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Audits::AffectedFrame> m_result;
    };

    static AffectedFrameBuilder<0> Create()
    {
        return AffectedFrameBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    AffectedFrame()
    {
    }

    String m_frameId;
};


class CONTENT_EXPORT CookieIssueDetails : public ::crdtp::ProtocolObject<CookieIssueDetails> {
public:
    ~CookieIssueDetails() override { }

    bool HasCookie() { return m_cookie.isJust(); }
    protocol::Audits::AffectedCookie* GetCookie(protocol::Audits::AffectedCookie* defaultValue) { return m_cookie.isJust() ? m_cookie.fromJust() : defaultValue; }
    void SetCookie(std::unique_ptr<protocol::Audits::AffectedCookie> value) { m_cookie = std::move(value); }

    bool HasRawCookieLine() { return m_rawCookieLine.isJust(); }
    String GetRawCookieLine(const String& defaultValue) { return m_rawCookieLine.isJust() ? m_rawCookieLine.fromJust() : defaultValue; }
    void SetRawCookieLine(const String& value) { m_rawCookieLine = value; }

    protocol::Array<String>* GetCookieWarningReasons() { return m_cookieWarningReasons.get(); }
    void SetCookieWarningReasons(std::unique_ptr<protocol::Array<String>> value) { m_cookieWarningReasons = std::move(value); }

    protocol::Array<String>* GetCookieExclusionReasons() { return m_cookieExclusionReasons.get(); }
    void SetCookieExclusionReasons(std::unique_ptr<protocol::Array<String>> value) { m_cookieExclusionReasons = std::move(value); }

    String GetOperation() { return m_operation; }
    void SetOperation(const String& value) { m_operation = value; }

    bool HasSiteForCookies() { return m_siteForCookies.isJust(); }
    String GetSiteForCookies(const String& defaultValue) { return m_siteForCookies.isJust() ? m_siteForCookies.fromJust() : defaultValue; }
    void SetSiteForCookies(const String& value) { m_siteForCookies = value; }

    bool HasCookieUrl() { return m_cookieUrl.isJust(); }
    String GetCookieUrl(const String& defaultValue) { return m_cookieUrl.isJust() ? m_cookieUrl.fromJust() : defaultValue; }
    void SetCookieUrl(const String& value) { m_cookieUrl = value; }

    bool HasRequest() { return m_request.isJust(); }
    protocol::Audits::AffectedRequest* GetRequest(protocol::Audits::AffectedRequest* defaultValue) { return m_request.isJust() ? m_request.fromJust() : defaultValue; }
    void SetRequest(std::unique_ptr<protocol::Audits::AffectedRequest> value) { m_request = std::move(value); }

    template<int STATE>
    class CookieIssueDetailsBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            CookieWarningReasonsSet = 1 << 1,
            CookieExclusionReasonsSet = 1 << 2,
            OperationSet = 1 << 3,
            AllFieldsSet = (CookieWarningReasonsSet | CookieExclusionReasonsSet | OperationSet | 0)};


        CookieIssueDetailsBuilder<STATE>& SetCookie(std::unique_ptr<protocol::Audits::AffectedCookie> value)
        {
            m_result->SetCookie(std::move(value));
            return *this;
        }

        CookieIssueDetailsBuilder<STATE>& SetRawCookieLine(const String& value)
        {
            m_result->SetRawCookieLine(value);
            return *this;
        }

        CookieIssueDetailsBuilder<STATE | CookieWarningReasonsSet>& SetCookieWarningReasons(std::unique_ptr<protocol::Array<String>> value)
        {
            static_assert(!(STATE & CookieWarningReasonsSet), "property cookieWarningReasons should not be set yet");
            m_result->SetCookieWarningReasons(std::move(value));
            return castState<CookieWarningReasonsSet>();
        }

        CookieIssueDetailsBuilder<STATE | CookieExclusionReasonsSet>& SetCookieExclusionReasons(std::unique_ptr<protocol::Array<String>> value)
        {
            static_assert(!(STATE & CookieExclusionReasonsSet), "property cookieExclusionReasons should not be set yet");
            m_result->SetCookieExclusionReasons(std::move(value));
            return castState<CookieExclusionReasonsSet>();
        }

        CookieIssueDetailsBuilder<STATE | OperationSet>& SetOperation(const String& value)
        {
            static_assert(!(STATE & OperationSet), "property operation should not be set yet");
            m_result->SetOperation(value);
            return castState<OperationSet>();
        }

        CookieIssueDetailsBuilder<STATE>& SetSiteForCookies(const String& value)
        {
            m_result->SetSiteForCookies(value);
            return *this;
        }

        CookieIssueDetailsBuilder<STATE>& SetCookieUrl(const String& value)
        {
            m_result->SetCookieUrl(value);
            return *this;
        }

        CookieIssueDetailsBuilder<STATE>& SetRequest(std::unique_ptr<protocol::Audits::AffectedRequest> value)
        {
            m_result->SetRequest(std::move(value));
            return *this;
        }

        std::unique_ptr<CookieIssueDetails> Build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class CookieIssueDetails;
        CookieIssueDetailsBuilder() : m_result(new CookieIssueDetails()) { }

        template<int STEP> CookieIssueDetailsBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<CookieIssueDetailsBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Audits::CookieIssueDetails> m_result;
    };

    static CookieIssueDetailsBuilder<0> Create()
    {
        return CookieIssueDetailsBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    CookieIssueDetails()
    {
    }

    Maybe<protocol::Audits::AffectedCookie> m_cookie;
    Maybe<String> m_rawCookieLine;
    std::unique_ptr<protocol::Array<String>> m_cookieWarningReasons;
    std::unique_ptr<protocol::Array<String>> m_cookieExclusionReasons;
    String m_operation;
    Maybe<String> m_siteForCookies;
    Maybe<String> m_cookieUrl;
    Maybe<protocol::Audits::AffectedRequest> m_request;
};


class CONTENT_EXPORT MixedContentIssueDetails : public ::crdtp::ProtocolObject<MixedContentIssueDetails> {
public:
    ~MixedContentIssueDetails() override { }

    bool HasResourceType() { return m_resourceType.isJust(); }
    String GetResourceType(const String& defaultValue) { return m_resourceType.isJust() ? m_resourceType.fromJust() : defaultValue; }
    void SetResourceType(const String& value) { m_resourceType = value; }

    String GetResolutionStatus() { return m_resolutionStatus; }
    void SetResolutionStatus(const String& value) { m_resolutionStatus = value; }

    String GetInsecureURL() { return m_insecureURL; }
    void SetInsecureURL(const String& value) { m_insecureURL = value; }

    String GetMainResourceURL() { return m_mainResourceURL; }
    void SetMainResourceURL(const String& value) { m_mainResourceURL = value; }

    bool HasRequest() { return m_request.isJust(); }
    protocol::Audits::AffectedRequest* GetRequest(protocol::Audits::AffectedRequest* defaultValue) { return m_request.isJust() ? m_request.fromJust() : defaultValue; }
    void SetRequest(std::unique_ptr<protocol::Audits::AffectedRequest> value) { m_request = std::move(value); }

    bool HasFrame() { return m_frame.isJust(); }
    protocol::Audits::AffectedFrame* GetFrame(protocol::Audits::AffectedFrame* defaultValue) { return m_frame.isJust() ? m_frame.fromJust() : defaultValue; }
    void SetFrame(std::unique_ptr<protocol::Audits::AffectedFrame> value) { m_frame = std::move(value); }

    template<int STATE>
    class MixedContentIssueDetailsBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            ResolutionStatusSet = 1 << 1,
            InsecureURLSet = 1 << 2,
            MainResourceURLSet = 1 << 3,
            AllFieldsSet = (ResolutionStatusSet | InsecureURLSet | MainResourceURLSet | 0)};


        MixedContentIssueDetailsBuilder<STATE>& SetResourceType(const String& value)
        {
            m_result->SetResourceType(value);
            return *this;
        }

        MixedContentIssueDetailsBuilder<STATE | ResolutionStatusSet>& SetResolutionStatus(const String& value)
        {
            static_assert(!(STATE & ResolutionStatusSet), "property resolutionStatus should not be set yet");
            m_result->SetResolutionStatus(value);
            return castState<ResolutionStatusSet>();
        }

        MixedContentIssueDetailsBuilder<STATE | InsecureURLSet>& SetInsecureURL(const String& value)
        {
            static_assert(!(STATE & InsecureURLSet), "property insecureURL should not be set yet");
            m_result->SetInsecureURL(value);
            return castState<InsecureURLSet>();
        }

        MixedContentIssueDetailsBuilder<STATE | MainResourceURLSet>& SetMainResourceURL(const String& value)
        {
            static_assert(!(STATE & MainResourceURLSet), "property mainResourceURL should not be set yet");
            m_result->SetMainResourceURL(value);
            return castState<MainResourceURLSet>();
        }

        MixedContentIssueDetailsBuilder<STATE>& SetRequest(std::unique_ptr<protocol::Audits::AffectedRequest> value)
        {
            m_result->SetRequest(std::move(value));
            return *this;
        }

        MixedContentIssueDetailsBuilder<STATE>& SetFrame(std::unique_ptr<protocol::Audits::AffectedFrame> value)
        {
            m_result->SetFrame(std::move(value));
            return *this;
        }

        std::unique_ptr<MixedContentIssueDetails> Build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class MixedContentIssueDetails;
        MixedContentIssueDetailsBuilder() : m_result(new MixedContentIssueDetails()) { }

        template<int STEP> MixedContentIssueDetailsBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<MixedContentIssueDetailsBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Audits::MixedContentIssueDetails> m_result;
    };

    static MixedContentIssueDetailsBuilder<0> Create()
    {
        return MixedContentIssueDetailsBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    MixedContentIssueDetails()
    {
    }

    Maybe<String> m_resourceType;
    String m_resolutionStatus;
    String m_insecureURL;
    String m_mainResourceURL;
    Maybe<protocol::Audits::AffectedRequest> m_request;
    Maybe<protocol::Audits::AffectedFrame> m_frame;
};


class CONTENT_EXPORT BlockedByResponseIssueDetails : public ::crdtp::ProtocolObject<BlockedByResponseIssueDetails> {
public:
    ~BlockedByResponseIssueDetails() override { }

    protocol::Audits::AffectedRequest* GetRequest() { return m_request.get(); }
    void SetRequest(std::unique_ptr<protocol::Audits::AffectedRequest> value) { m_request = std::move(value); }

    bool HasParentFrame() { return m_parentFrame.isJust(); }
    protocol::Audits::AffectedFrame* GetParentFrame(protocol::Audits::AffectedFrame* defaultValue) { return m_parentFrame.isJust() ? m_parentFrame.fromJust() : defaultValue; }
    void SetParentFrame(std::unique_ptr<protocol::Audits::AffectedFrame> value) { m_parentFrame = std::move(value); }

    bool HasBlockedFrame() { return m_blockedFrame.isJust(); }
    protocol::Audits::AffectedFrame* GetBlockedFrame(protocol::Audits::AffectedFrame* defaultValue) { return m_blockedFrame.isJust() ? m_blockedFrame.fromJust() : defaultValue; }
    void SetBlockedFrame(std::unique_ptr<protocol::Audits::AffectedFrame> value) { m_blockedFrame = std::move(value); }

    String GetReason() { return m_reason; }
    void SetReason(const String& value) { m_reason = value; }

    template<int STATE>
    class BlockedByResponseIssueDetailsBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            RequestSet = 1 << 1,
            ReasonSet = 1 << 2,
            AllFieldsSet = (RequestSet | ReasonSet | 0)};


        BlockedByResponseIssueDetailsBuilder<STATE | RequestSet>& SetRequest(std::unique_ptr<protocol::Audits::AffectedRequest> value)
        {
            static_assert(!(STATE & RequestSet), "property request should not be set yet");
            m_result->SetRequest(std::move(value));
            return castState<RequestSet>();
        }

        BlockedByResponseIssueDetailsBuilder<STATE>& SetParentFrame(std::unique_ptr<protocol::Audits::AffectedFrame> value)
        {
            m_result->SetParentFrame(std::move(value));
            return *this;
        }

        BlockedByResponseIssueDetailsBuilder<STATE>& SetBlockedFrame(std::unique_ptr<protocol::Audits::AffectedFrame> value)
        {
            m_result->SetBlockedFrame(std::move(value));
            return *this;
        }

        BlockedByResponseIssueDetailsBuilder<STATE | ReasonSet>& SetReason(const String& value)
        {
            static_assert(!(STATE & ReasonSet), "property reason should not be set yet");
            m_result->SetReason(value);
            return castState<ReasonSet>();
        }

        std::unique_ptr<BlockedByResponseIssueDetails> Build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class BlockedByResponseIssueDetails;
        BlockedByResponseIssueDetailsBuilder() : m_result(new BlockedByResponseIssueDetails()) { }

        template<int STEP> BlockedByResponseIssueDetailsBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<BlockedByResponseIssueDetailsBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Audits::BlockedByResponseIssueDetails> m_result;
    };

    static BlockedByResponseIssueDetailsBuilder<0> Create()
    {
        return BlockedByResponseIssueDetailsBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    BlockedByResponseIssueDetails()
    {
    }

    std::unique_ptr<protocol::Audits::AffectedRequest> m_request;
    Maybe<protocol::Audits::AffectedFrame> m_parentFrame;
    Maybe<protocol::Audits::AffectedFrame> m_blockedFrame;
    String m_reason;
};


class CONTENT_EXPORT HeavyAdIssueDetails : public ::crdtp::ProtocolObject<HeavyAdIssueDetails> {
public:
    ~HeavyAdIssueDetails() override { }

    String GetResolution() { return m_resolution; }
    void SetResolution(const String& value) { m_resolution = value; }

    String GetReason() { return m_reason; }
    void SetReason(const String& value) { m_reason = value; }

    protocol::Audits::AffectedFrame* GetFrame() { return m_frame.get(); }
    void SetFrame(std::unique_ptr<protocol::Audits::AffectedFrame> value) { m_frame = std::move(value); }

    template<int STATE>
    class HeavyAdIssueDetailsBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            ResolutionSet = 1 << 1,
            ReasonSet = 1 << 2,
            FrameSet = 1 << 3,
            AllFieldsSet = (ResolutionSet | ReasonSet | FrameSet | 0)};


        HeavyAdIssueDetailsBuilder<STATE | ResolutionSet>& SetResolution(const String& value)
        {
            static_assert(!(STATE & ResolutionSet), "property resolution should not be set yet");
            m_result->SetResolution(value);
            return castState<ResolutionSet>();
        }

        HeavyAdIssueDetailsBuilder<STATE | ReasonSet>& SetReason(const String& value)
        {
            static_assert(!(STATE & ReasonSet), "property reason should not be set yet");
            m_result->SetReason(value);
            return castState<ReasonSet>();
        }

        HeavyAdIssueDetailsBuilder<STATE | FrameSet>& SetFrame(std::unique_ptr<protocol::Audits::AffectedFrame> value)
        {
            static_assert(!(STATE & FrameSet), "property frame should not be set yet");
            m_result->SetFrame(std::move(value));
            return castState<FrameSet>();
        }

        std::unique_ptr<HeavyAdIssueDetails> Build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class HeavyAdIssueDetails;
        HeavyAdIssueDetailsBuilder() : m_result(new HeavyAdIssueDetails()) { }

        template<int STEP> HeavyAdIssueDetailsBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<HeavyAdIssueDetailsBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Audits::HeavyAdIssueDetails> m_result;
    };

    static HeavyAdIssueDetailsBuilder<0> Create()
    {
        return HeavyAdIssueDetailsBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    HeavyAdIssueDetails()
    {
    }

    String m_resolution;
    String m_reason;
    std::unique_ptr<protocol::Audits::AffectedFrame> m_frame;
};


class CONTENT_EXPORT SourceCodeLocation : public ::crdtp::ProtocolObject<SourceCodeLocation> {
public:
    ~SourceCodeLocation() override { }

    bool HasScriptId() { return m_scriptId.isJust(); }
    String GetScriptId(const String& defaultValue) { return m_scriptId.isJust() ? m_scriptId.fromJust() : defaultValue; }
    void SetScriptId(const String& value) { m_scriptId = value; }

    String GetUrl() { return m_url; }
    void SetUrl(const String& value) { m_url = value; }

    int GetLineNumber() { return m_lineNumber; }
    void SetLineNumber(int value) { m_lineNumber = value; }

    int GetColumnNumber() { return m_columnNumber; }
    void SetColumnNumber(int value) { m_columnNumber = value; }

    template<int STATE>
    class SourceCodeLocationBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            UrlSet = 1 << 1,
            LineNumberSet = 1 << 2,
            ColumnNumberSet = 1 << 3,
            AllFieldsSet = (UrlSet | LineNumberSet | ColumnNumberSet | 0)};


        SourceCodeLocationBuilder<STATE>& SetScriptId(const String& value)
        {
            m_result->SetScriptId(value);
            return *this;
        }

        SourceCodeLocationBuilder<STATE | UrlSet>& SetUrl(const String& value)
        {
            static_assert(!(STATE & UrlSet), "property url should not be set yet");
            m_result->SetUrl(value);
            return castState<UrlSet>();
        }

        SourceCodeLocationBuilder<STATE | LineNumberSet>& SetLineNumber(int value)
        {
            static_assert(!(STATE & LineNumberSet), "property lineNumber should not be set yet");
            m_result->SetLineNumber(value);
            return castState<LineNumberSet>();
        }

        SourceCodeLocationBuilder<STATE | ColumnNumberSet>& SetColumnNumber(int value)
        {
            static_assert(!(STATE & ColumnNumberSet), "property columnNumber should not be set yet");
            m_result->SetColumnNumber(value);
            return castState<ColumnNumberSet>();
        }

        std::unique_ptr<SourceCodeLocation> Build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class SourceCodeLocation;
        SourceCodeLocationBuilder() : m_result(new SourceCodeLocation()) { }

        template<int STEP> SourceCodeLocationBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<SourceCodeLocationBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Audits::SourceCodeLocation> m_result;
    };

    static SourceCodeLocationBuilder<0> Create()
    {
        return SourceCodeLocationBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    SourceCodeLocation()
    {
          m_lineNumber = 0;
          m_columnNumber = 0;
    }

    Maybe<String> m_scriptId;
    String m_url;
    int m_lineNumber;
    int m_columnNumber;
};


class CONTENT_EXPORT ContentSecurityPolicyIssueDetails : public ::crdtp::ProtocolObject<ContentSecurityPolicyIssueDetails> {
public:
    ~ContentSecurityPolicyIssueDetails() override { }

    bool HasBlockedURL() { return m_blockedURL.isJust(); }
    String GetBlockedURL(const String& defaultValue) { return m_blockedURL.isJust() ? m_blockedURL.fromJust() : defaultValue; }
    void SetBlockedURL(const String& value) { m_blockedURL = value; }

    String GetViolatedDirective() { return m_violatedDirective; }
    void SetViolatedDirective(const String& value) { m_violatedDirective = value; }

    bool GetIsReportOnly() { return m_isReportOnly; }
    void SetIsReportOnly(bool value) { m_isReportOnly = value; }

    String GetContentSecurityPolicyViolationType() { return m_contentSecurityPolicyViolationType; }
    void SetContentSecurityPolicyViolationType(const String& value) { m_contentSecurityPolicyViolationType = value; }

    bool HasFrameAncestor() { return m_frameAncestor.isJust(); }
    protocol::Audits::AffectedFrame* GetFrameAncestor(protocol::Audits::AffectedFrame* defaultValue) { return m_frameAncestor.isJust() ? m_frameAncestor.fromJust() : defaultValue; }
    void SetFrameAncestor(std::unique_ptr<protocol::Audits::AffectedFrame> value) { m_frameAncestor = std::move(value); }

    bool HasSourceCodeLocation() { return m_sourceCodeLocation.isJust(); }
    protocol::Audits::SourceCodeLocation* GetSourceCodeLocation(protocol::Audits::SourceCodeLocation* defaultValue) { return m_sourceCodeLocation.isJust() ? m_sourceCodeLocation.fromJust() : defaultValue; }
    void SetSourceCodeLocation(std::unique_ptr<protocol::Audits::SourceCodeLocation> value) { m_sourceCodeLocation = std::move(value); }

    bool HasViolatingNodeId() { return m_violatingNodeId.isJust(); }
    int GetViolatingNodeId(int defaultValue) { return m_violatingNodeId.isJust() ? m_violatingNodeId.fromJust() : defaultValue; }
    void SetViolatingNodeId(int value) { m_violatingNodeId = value; }

    template<int STATE>
    class ContentSecurityPolicyIssueDetailsBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            ViolatedDirectiveSet = 1 << 1,
            IsReportOnlySet = 1 << 2,
            ContentSecurityPolicyViolationTypeSet = 1 << 3,
            AllFieldsSet = (ViolatedDirectiveSet | IsReportOnlySet | ContentSecurityPolicyViolationTypeSet | 0)};


        ContentSecurityPolicyIssueDetailsBuilder<STATE>& SetBlockedURL(const String& value)
        {
            m_result->SetBlockedURL(value);
            return *this;
        }

        ContentSecurityPolicyIssueDetailsBuilder<STATE | ViolatedDirectiveSet>& SetViolatedDirective(const String& value)
        {
            static_assert(!(STATE & ViolatedDirectiveSet), "property violatedDirective should not be set yet");
            m_result->SetViolatedDirective(value);
            return castState<ViolatedDirectiveSet>();
        }

        ContentSecurityPolicyIssueDetailsBuilder<STATE | IsReportOnlySet>& SetIsReportOnly(bool value)
        {
            static_assert(!(STATE & IsReportOnlySet), "property isReportOnly should not be set yet");
            m_result->SetIsReportOnly(value);
            return castState<IsReportOnlySet>();
        }

        ContentSecurityPolicyIssueDetailsBuilder<STATE | ContentSecurityPolicyViolationTypeSet>& SetContentSecurityPolicyViolationType(const String& value)
        {
            static_assert(!(STATE & ContentSecurityPolicyViolationTypeSet), "property contentSecurityPolicyViolationType should not be set yet");
            m_result->SetContentSecurityPolicyViolationType(value);
            return castState<ContentSecurityPolicyViolationTypeSet>();
        }

        ContentSecurityPolicyIssueDetailsBuilder<STATE>& SetFrameAncestor(std::unique_ptr<protocol::Audits::AffectedFrame> value)
        {
            m_result->SetFrameAncestor(std::move(value));
            return *this;
        }

        ContentSecurityPolicyIssueDetailsBuilder<STATE>& SetSourceCodeLocation(std::unique_ptr<protocol::Audits::SourceCodeLocation> value)
        {
            m_result->SetSourceCodeLocation(std::move(value));
            return *this;
        }

        ContentSecurityPolicyIssueDetailsBuilder<STATE>& SetViolatingNodeId(int value)
        {
            m_result->SetViolatingNodeId(value);
            return *this;
        }

        std::unique_ptr<ContentSecurityPolicyIssueDetails> Build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class ContentSecurityPolicyIssueDetails;
        ContentSecurityPolicyIssueDetailsBuilder() : m_result(new ContentSecurityPolicyIssueDetails()) { }

        template<int STEP> ContentSecurityPolicyIssueDetailsBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<ContentSecurityPolicyIssueDetailsBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Audits::ContentSecurityPolicyIssueDetails> m_result;
    };

    static ContentSecurityPolicyIssueDetailsBuilder<0> Create()
    {
        return ContentSecurityPolicyIssueDetailsBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    ContentSecurityPolicyIssueDetails()
    {
          m_isReportOnly = false;
    }

    Maybe<String> m_blockedURL;
    String m_violatedDirective;
    bool m_isReportOnly;
    String m_contentSecurityPolicyViolationType;
    Maybe<protocol::Audits::AffectedFrame> m_frameAncestor;
    Maybe<protocol::Audits::SourceCodeLocation> m_sourceCodeLocation;
    Maybe<int> m_violatingNodeId;
};


class CONTENT_EXPORT SharedArrayBufferIssueDetails : public ::crdtp::ProtocolObject<SharedArrayBufferIssueDetails> {
public:
    ~SharedArrayBufferIssueDetails() override { }

    protocol::Audits::SourceCodeLocation* GetSourceCodeLocation() { return m_sourceCodeLocation.get(); }
    void SetSourceCodeLocation(std::unique_ptr<protocol::Audits::SourceCodeLocation> value) { m_sourceCodeLocation = std::move(value); }

    bool GetIsWarning() { return m_isWarning; }
    void SetIsWarning(bool value) { m_isWarning = value; }

    String GetType() { return m_type; }
    void SetType(const String& value) { m_type = value; }

    template<int STATE>
    class SharedArrayBufferIssueDetailsBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            SourceCodeLocationSet = 1 << 1,
            IsWarningSet = 1 << 2,
            TypeSet = 1 << 3,
            AllFieldsSet = (SourceCodeLocationSet | IsWarningSet | TypeSet | 0)};


        SharedArrayBufferIssueDetailsBuilder<STATE | SourceCodeLocationSet>& SetSourceCodeLocation(std::unique_ptr<protocol::Audits::SourceCodeLocation> value)
        {
            static_assert(!(STATE & SourceCodeLocationSet), "property sourceCodeLocation should not be set yet");
            m_result->SetSourceCodeLocation(std::move(value));
            return castState<SourceCodeLocationSet>();
        }

        SharedArrayBufferIssueDetailsBuilder<STATE | IsWarningSet>& SetIsWarning(bool value)
        {
            static_assert(!(STATE & IsWarningSet), "property isWarning should not be set yet");
            m_result->SetIsWarning(value);
            return castState<IsWarningSet>();
        }

        SharedArrayBufferIssueDetailsBuilder<STATE | TypeSet>& SetType(const String& value)
        {
            static_assert(!(STATE & TypeSet), "property type should not be set yet");
            m_result->SetType(value);
            return castState<TypeSet>();
        }

        std::unique_ptr<SharedArrayBufferIssueDetails> Build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class SharedArrayBufferIssueDetails;
        SharedArrayBufferIssueDetailsBuilder() : m_result(new SharedArrayBufferIssueDetails()) { }

        template<int STEP> SharedArrayBufferIssueDetailsBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<SharedArrayBufferIssueDetailsBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Audits::SharedArrayBufferIssueDetails> m_result;
    };

    static SharedArrayBufferIssueDetailsBuilder<0> Create()
    {
        return SharedArrayBufferIssueDetailsBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    SharedArrayBufferIssueDetails()
    {
          m_isWarning = false;
    }

    std::unique_ptr<protocol::Audits::SourceCodeLocation> m_sourceCodeLocation;
    bool m_isWarning;
    String m_type;
};


class CONTENT_EXPORT TrustedWebActivityIssueDetails : public ::crdtp::ProtocolObject<TrustedWebActivityIssueDetails> {
public:
    ~TrustedWebActivityIssueDetails() override { }

    String GetUrl() { return m_url; }
    void SetUrl(const String& value) { m_url = value; }

    String GetViolationType() { return m_violationType; }
    void SetViolationType(const String& value) { m_violationType = value; }

    bool HasHttpStatusCode() { return m_httpStatusCode.isJust(); }
    int GetHttpStatusCode(int defaultValue) { return m_httpStatusCode.isJust() ? m_httpStatusCode.fromJust() : defaultValue; }
    void SetHttpStatusCode(int value) { m_httpStatusCode = value; }

    bool HasPackageName() { return m_packageName.isJust(); }
    String GetPackageName(const String& defaultValue) { return m_packageName.isJust() ? m_packageName.fromJust() : defaultValue; }
    void SetPackageName(const String& value) { m_packageName = value; }

    bool HasSignature() { return m_signature.isJust(); }
    String GetSignature(const String& defaultValue) { return m_signature.isJust() ? m_signature.fromJust() : defaultValue; }
    void SetSignature(const String& value) { m_signature = value; }

    template<int STATE>
    class TrustedWebActivityIssueDetailsBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            UrlSet = 1 << 1,
            ViolationTypeSet = 1 << 2,
            AllFieldsSet = (UrlSet | ViolationTypeSet | 0)};


        TrustedWebActivityIssueDetailsBuilder<STATE | UrlSet>& SetUrl(const String& value)
        {
            static_assert(!(STATE & UrlSet), "property url should not be set yet");
            m_result->SetUrl(value);
            return castState<UrlSet>();
        }

        TrustedWebActivityIssueDetailsBuilder<STATE | ViolationTypeSet>& SetViolationType(const String& value)
        {
            static_assert(!(STATE & ViolationTypeSet), "property violationType should not be set yet");
            m_result->SetViolationType(value);
            return castState<ViolationTypeSet>();
        }

        TrustedWebActivityIssueDetailsBuilder<STATE>& SetHttpStatusCode(int value)
        {
            m_result->SetHttpStatusCode(value);
            return *this;
        }

        TrustedWebActivityIssueDetailsBuilder<STATE>& SetPackageName(const String& value)
        {
            m_result->SetPackageName(value);
            return *this;
        }

        TrustedWebActivityIssueDetailsBuilder<STATE>& SetSignature(const String& value)
        {
            m_result->SetSignature(value);
            return *this;
        }

        std::unique_ptr<TrustedWebActivityIssueDetails> Build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class TrustedWebActivityIssueDetails;
        TrustedWebActivityIssueDetailsBuilder() : m_result(new TrustedWebActivityIssueDetails()) { }

        template<int STEP> TrustedWebActivityIssueDetailsBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<TrustedWebActivityIssueDetailsBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Audits::TrustedWebActivityIssueDetails> m_result;
    };

    static TrustedWebActivityIssueDetailsBuilder<0> Create()
    {
        return TrustedWebActivityIssueDetailsBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    TrustedWebActivityIssueDetails()
    {
    }

    String m_url;
    String m_violationType;
    Maybe<int> m_httpStatusCode;
    Maybe<String> m_packageName;
    Maybe<String> m_signature;
};


class CONTENT_EXPORT LowTextContrastIssueDetails : public ::crdtp::ProtocolObject<LowTextContrastIssueDetails> {
public:
    ~LowTextContrastIssueDetails() override { }

    int GetViolatingNodeId() { return m_violatingNodeId; }
    void SetViolatingNodeId(int value) { m_violatingNodeId = value; }

    String GetViolatingNodeSelector() { return m_violatingNodeSelector; }
    void SetViolatingNodeSelector(const String& value) { m_violatingNodeSelector = value; }

    double GetContrastRatio() { return m_contrastRatio; }
    void SetContrastRatio(double value) { m_contrastRatio = value; }

    double GetThresholdAA() { return m_thresholdAA; }
    void SetThresholdAA(double value) { m_thresholdAA = value; }

    double GetThresholdAAA() { return m_thresholdAAA; }
    void SetThresholdAAA(double value) { m_thresholdAAA = value; }

    String GetFontSize() { return m_fontSize; }
    void SetFontSize(const String& value) { m_fontSize = value; }

    String GetFontWeight() { return m_fontWeight; }
    void SetFontWeight(const String& value) { m_fontWeight = value; }

    template<int STATE>
    class LowTextContrastIssueDetailsBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            ViolatingNodeIdSet = 1 << 1,
            ViolatingNodeSelectorSet = 1 << 2,
            ContrastRatioSet = 1 << 3,
            ThresholdAASet = 1 << 4,
            ThresholdAAASet = 1 << 5,
            FontSizeSet = 1 << 6,
            FontWeightSet = 1 << 7,
            AllFieldsSet = (ViolatingNodeIdSet | ViolatingNodeSelectorSet | ContrastRatioSet | ThresholdAASet | ThresholdAAASet | FontSizeSet | FontWeightSet | 0)};


        LowTextContrastIssueDetailsBuilder<STATE | ViolatingNodeIdSet>& SetViolatingNodeId(int value)
        {
            static_assert(!(STATE & ViolatingNodeIdSet), "property violatingNodeId should not be set yet");
            m_result->SetViolatingNodeId(value);
            return castState<ViolatingNodeIdSet>();
        }

        LowTextContrastIssueDetailsBuilder<STATE | ViolatingNodeSelectorSet>& SetViolatingNodeSelector(const String& value)
        {
            static_assert(!(STATE & ViolatingNodeSelectorSet), "property violatingNodeSelector should not be set yet");
            m_result->SetViolatingNodeSelector(value);
            return castState<ViolatingNodeSelectorSet>();
        }

        LowTextContrastIssueDetailsBuilder<STATE | ContrastRatioSet>& SetContrastRatio(double value)
        {
            static_assert(!(STATE & ContrastRatioSet), "property contrastRatio should not be set yet");
            m_result->SetContrastRatio(value);
            return castState<ContrastRatioSet>();
        }

        LowTextContrastIssueDetailsBuilder<STATE | ThresholdAASet>& SetThresholdAA(double value)
        {
            static_assert(!(STATE & ThresholdAASet), "property thresholdAA should not be set yet");
            m_result->SetThresholdAA(value);
            return castState<ThresholdAASet>();
        }

        LowTextContrastIssueDetailsBuilder<STATE | ThresholdAAASet>& SetThresholdAAA(double value)
        {
            static_assert(!(STATE & ThresholdAAASet), "property thresholdAAA should not be set yet");
            m_result->SetThresholdAAA(value);
            return castState<ThresholdAAASet>();
        }

        LowTextContrastIssueDetailsBuilder<STATE | FontSizeSet>& SetFontSize(const String& value)
        {
            static_assert(!(STATE & FontSizeSet), "property fontSize should not be set yet");
            m_result->SetFontSize(value);
            return castState<FontSizeSet>();
        }

        LowTextContrastIssueDetailsBuilder<STATE | FontWeightSet>& SetFontWeight(const String& value)
        {
            static_assert(!(STATE & FontWeightSet), "property fontWeight should not be set yet");
            m_result->SetFontWeight(value);
            return castState<FontWeightSet>();
        }

        std::unique_ptr<LowTextContrastIssueDetails> Build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class LowTextContrastIssueDetails;
        LowTextContrastIssueDetailsBuilder() : m_result(new LowTextContrastIssueDetails()) { }

        template<int STEP> LowTextContrastIssueDetailsBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<LowTextContrastIssueDetailsBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Audits::LowTextContrastIssueDetails> m_result;
    };

    static LowTextContrastIssueDetailsBuilder<0> Create()
    {
        return LowTextContrastIssueDetailsBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    LowTextContrastIssueDetails()
    {
          m_violatingNodeId = 0;
          m_contrastRatio = 0;
          m_thresholdAA = 0;
          m_thresholdAAA = 0;
    }

    int m_violatingNodeId;
    String m_violatingNodeSelector;
    double m_contrastRatio;
    double m_thresholdAA;
    double m_thresholdAAA;
    String m_fontSize;
    String m_fontWeight;
};


class CONTENT_EXPORT CorsIssueDetails : public ::crdtp::ProtocolObject<CorsIssueDetails> {
public:
    ~CorsIssueDetails() override { }

    protocol::Network::CorsErrorStatus* GetCorsErrorStatus() { return m_corsErrorStatus.get(); }
    void SetCorsErrorStatus(std::unique_ptr<protocol::Network::CorsErrorStatus> value) { m_corsErrorStatus = std::move(value); }

    bool GetIsWarning() { return m_isWarning; }
    void SetIsWarning(bool value) { m_isWarning = value; }

    protocol::Audits::AffectedRequest* GetRequest() { return m_request.get(); }
    void SetRequest(std::unique_ptr<protocol::Audits::AffectedRequest> value) { m_request = std::move(value); }

    bool HasLocation() { return m_location.isJust(); }
    protocol::Audits::SourceCodeLocation* GetLocation(protocol::Audits::SourceCodeLocation* defaultValue) { return m_location.isJust() ? m_location.fromJust() : defaultValue; }
    void SetLocation(std::unique_ptr<protocol::Audits::SourceCodeLocation> value) { m_location = std::move(value); }

    bool HasInitiatorOrigin() { return m_initiatorOrigin.isJust(); }
    String GetInitiatorOrigin(const String& defaultValue) { return m_initiatorOrigin.isJust() ? m_initiatorOrigin.fromJust() : defaultValue; }
    void SetInitiatorOrigin(const String& value) { m_initiatorOrigin = value; }

    bool HasResourceIPAddressSpace() { return m_resourceIPAddressSpace.isJust(); }
    String GetResourceIPAddressSpace(const String& defaultValue) { return m_resourceIPAddressSpace.isJust() ? m_resourceIPAddressSpace.fromJust() : defaultValue; }
    void SetResourceIPAddressSpace(const String& value) { m_resourceIPAddressSpace = value; }

    bool HasClientSecurityState() { return m_clientSecurityState.isJust(); }
    protocol::Network::ClientSecurityState* GetClientSecurityState(protocol::Network::ClientSecurityState* defaultValue) { return m_clientSecurityState.isJust() ? m_clientSecurityState.fromJust() : defaultValue; }
    void SetClientSecurityState(std::unique_ptr<protocol::Network::ClientSecurityState> value) { m_clientSecurityState = std::move(value); }

    template<int STATE>
    class CorsIssueDetailsBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            CorsErrorStatusSet = 1 << 1,
            IsWarningSet = 1 << 2,
            RequestSet = 1 << 3,
            AllFieldsSet = (CorsErrorStatusSet | IsWarningSet | RequestSet | 0)};


        CorsIssueDetailsBuilder<STATE | CorsErrorStatusSet>& SetCorsErrorStatus(std::unique_ptr<protocol::Network::CorsErrorStatus> value)
        {
            static_assert(!(STATE & CorsErrorStatusSet), "property corsErrorStatus should not be set yet");
            m_result->SetCorsErrorStatus(std::move(value));
            return castState<CorsErrorStatusSet>();
        }

        CorsIssueDetailsBuilder<STATE | IsWarningSet>& SetIsWarning(bool value)
        {
            static_assert(!(STATE & IsWarningSet), "property isWarning should not be set yet");
            m_result->SetIsWarning(value);
            return castState<IsWarningSet>();
        }

        CorsIssueDetailsBuilder<STATE | RequestSet>& SetRequest(std::unique_ptr<protocol::Audits::AffectedRequest> value)
        {
            static_assert(!(STATE & RequestSet), "property request should not be set yet");
            m_result->SetRequest(std::move(value));
            return castState<RequestSet>();
        }

        CorsIssueDetailsBuilder<STATE>& SetLocation(std::unique_ptr<protocol::Audits::SourceCodeLocation> value)
        {
            m_result->SetLocation(std::move(value));
            return *this;
        }

        CorsIssueDetailsBuilder<STATE>& SetInitiatorOrigin(const String& value)
        {
            m_result->SetInitiatorOrigin(value);
            return *this;
        }

        CorsIssueDetailsBuilder<STATE>& SetResourceIPAddressSpace(const String& value)
        {
            m_result->SetResourceIPAddressSpace(value);
            return *this;
        }

        CorsIssueDetailsBuilder<STATE>& SetClientSecurityState(std::unique_ptr<protocol::Network::ClientSecurityState> value)
        {
            m_result->SetClientSecurityState(std::move(value));
            return *this;
        }

        std::unique_ptr<CorsIssueDetails> Build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class CorsIssueDetails;
        CorsIssueDetailsBuilder() : m_result(new CorsIssueDetails()) { }

        template<int STEP> CorsIssueDetailsBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<CorsIssueDetailsBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Audits::CorsIssueDetails> m_result;
    };

    static CorsIssueDetailsBuilder<0> Create()
    {
        return CorsIssueDetailsBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    CorsIssueDetails()
    {
          m_isWarning = false;
    }

    std::unique_ptr<protocol::Network::CorsErrorStatus> m_corsErrorStatus;
    bool m_isWarning;
    std::unique_ptr<protocol::Audits::AffectedRequest> m_request;
    Maybe<protocol::Audits::SourceCodeLocation> m_location;
    Maybe<String> m_initiatorOrigin;
    Maybe<String> m_resourceIPAddressSpace;
    Maybe<protocol::Network::ClientSecurityState> m_clientSecurityState;
};


class CONTENT_EXPORT AttributionReportingIssueDetails : public ::crdtp::ProtocolObject<AttributionReportingIssueDetails> {
public:
    ~AttributionReportingIssueDetails() override { }

    String GetViolationType() { return m_violationType; }
    void SetViolationType(const String& value) { m_violationType = value; }

    bool HasRequest() { return m_request.isJust(); }
    protocol::Audits::AffectedRequest* GetRequest(protocol::Audits::AffectedRequest* defaultValue) { return m_request.isJust() ? m_request.fromJust() : defaultValue; }
    void SetRequest(std::unique_ptr<protocol::Audits::AffectedRequest> value) { m_request = std::move(value); }

    bool HasViolatingNodeId() { return m_violatingNodeId.isJust(); }
    int GetViolatingNodeId(int defaultValue) { return m_violatingNodeId.isJust() ? m_violatingNodeId.fromJust() : defaultValue; }
    void SetViolatingNodeId(int value) { m_violatingNodeId = value; }

    bool HasInvalidParameter() { return m_invalidParameter.isJust(); }
    String GetInvalidParameter(const String& defaultValue) { return m_invalidParameter.isJust() ? m_invalidParameter.fromJust() : defaultValue; }
    void SetInvalidParameter(const String& value) { m_invalidParameter = value; }

    template<int STATE>
    class AttributionReportingIssueDetailsBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            ViolationTypeSet = 1 << 1,
            AllFieldsSet = (ViolationTypeSet | 0)};


        AttributionReportingIssueDetailsBuilder<STATE | ViolationTypeSet>& SetViolationType(const String& value)
        {
            static_assert(!(STATE & ViolationTypeSet), "property violationType should not be set yet");
            m_result->SetViolationType(value);
            return castState<ViolationTypeSet>();
        }

        AttributionReportingIssueDetailsBuilder<STATE>& SetRequest(std::unique_ptr<protocol::Audits::AffectedRequest> value)
        {
            m_result->SetRequest(std::move(value));
            return *this;
        }

        AttributionReportingIssueDetailsBuilder<STATE>& SetViolatingNodeId(int value)
        {
            m_result->SetViolatingNodeId(value);
            return *this;
        }

        AttributionReportingIssueDetailsBuilder<STATE>& SetInvalidParameter(const String& value)
        {
            m_result->SetInvalidParameter(value);
            return *this;
        }

        std::unique_ptr<AttributionReportingIssueDetails> Build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class AttributionReportingIssueDetails;
        AttributionReportingIssueDetailsBuilder() : m_result(new AttributionReportingIssueDetails()) { }

        template<int STEP> AttributionReportingIssueDetailsBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<AttributionReportingIssueDetailsBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Audits::AttributionReportingIssueDetails> m_result;
    };

    static AttributionReportingIssueDetailsBuilder<0> Create()
    {
        return AttributionReportingIssueDetailsBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    AttributionReportingIssueDetails()
    {
    }

    String m_violationType;
    Maybe<protocol::Audits::AffectedRequest> m_request;
    Maybe<int> m_violatingNodeId;
    Maybe<String> m_invalidParameter;
};


class CONTENT_EXPORT QuirksModeIssueDetails : public ::crdtp::ProtocolObject<QuirksModeIssueDetails> {
public:
    ~QuirksModeIssueDetails() override { }

    bool GetIsLimitedQuirksMode() { return m_isLimitedQuirksMode; }
    void SetIsLimitedQuirksMode(bool value) { m_isLimitedQuirksMode = value; }

    int GetDocumentNodeId() { return m_documentNodeId; }
    void SetDocumentNodeId(int value) { m_documentNodeId = value; }

    String GetUrl() { return m_url; }
    void SetUrl(const String& value) { m_url = value; }

    String GetFrameId() { return m_frameId; }
    void SetFrameId(const String& value) { m_frameId = value; }

    String GetLoaderId() { return m_loaderId; }
    void SetLoaderId(const String& value) { m_loaderId = value; }

    template<int STATE>
    class QuirksModeIssueDetailsBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            IsLimitedQuirksModeSet = 1 << 1,
            DocumentNodeIdSet = 1 << 2,
            UrlSet = 1 << 3,
            FrameIdSet = 1 << 4,
            LoaderIdSet = 1 << 5,
            AllFieldsSet = (IsLimitedQuirksModeSet | DocumentNodeIdSet | UrlSet | FrameIdSet | LoaderIdSet | 0)};


        QuirksModeIssueDetailsBuilder<STATE | IsLimitedQuirksModeSet>& SetIsLimitedQuirksMode(bool value)
        {
            static_assert(!(STATE & IsLimitedQuirksModeSet), "property isLimitedQuirksMode should not be set yet");
            m_result->SetIsLimitedQuirksMode(value);
            return castState<IsLimitedQuirksModeSet>();
        }

        QuirksModeIssueDetailsBuilder<STATE | DocumentNodeIdSet>& SetDocumentNodeId(int value)
        {
            static_assert(!(STATE & DocumentNodeIdSet), "property documentNodeId should not be set yet");
            m_result->SetDocumentNodeId(value);
            return castState<DocumentNodeIdSet>();
        }

        QuirksModeIssueDetailsBuilder<STATE | UrlSet>& SetUrl(const String& value)
        {
            static_assert(!(STATE & UrlSet), "property url should not be set yet");
            m_result->SetUrl(value);
            return castState<UrlSet>();
        }

        QuirksModeIssueDetailsBuilder<STATE | FrameIdSet>& SetFrameId(const String& value)
        {
            static_assert(!(STATE & FrameIdSet), "property frameId should not be set yet");
            m_result->SetFrameId(value);
            return castState<FrameIdSet>();
        }

        QuirksModeIssueDetailsBuilder<STATE | LoaderIdSet>& SetLoaderId(const String& value)
        {
            static_assert(!(STATE & LoaderIdSet), "property loaderId should not be set yet");
            m_result->SetLoaderId(value);
            return castState<LoaderIdSet>();
        }

        std::unique_ptr<QuirksModeIssueDetails> Build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class QuirksModeIssueDetails;
        QuirksModeIssueDetailsBuilder() : m_result(new QuirksModeIssueDetails()) { }

        template<int STEP> QuirksModeIssueDetailsBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<QuirksModeIssueDetailsBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Audits::QuirksModeIssueDetails> m_result;
    };

    static QuirksModeIssueDetailsBuilder<0> Create()
    {
        return QuirksModeIssueDetailsBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    QuirksModeIssueDetails()
    {
          m_isLimitedQuirksMode = false;
          m_documentNodeId = 0;
    }

    bool m_isLimitedQuirksMode;
    int m_documentNodeId;
    String m_url;
    String m_frameId;
    String m_loaderId;
};


class CONTENT_EXPORT NavigatorUserAgentIssueDetails : public ::crdtp::ProtocolObject<NavigatorUserAgentIssueDetails> {
public:
    ~NavigatorUserAgentIssueDetails() override { }

    String GetUrl() { return m_url; }
    void SetUrl(const String& value) { m_url = value; }

    bool HasLocation() { return m_location.isJust(); }
    protocol::Audits::SourceCodeLocation* GetLocation(protocol::Audits::SourceCodeLocation* defaultValue) { return m_location.isJust() ? m_location.fromJust() : defaultValue; }
    void SetLocation(std::unique_ptr<protocol::Audits::SourceCodeLocation> value) { m_location = std::move(value); }

    template<int STATE>
    class NavigatorUserAgentIssueDetailsBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            UrlSet = 1 << 1,
            AllFieldsSet = (UrlSet | 0)};


        NavigatorUserAgentIssueDetailsBuilder<STATE | UrlSet>& SetUrl(const String& value)
        {
            static_assert(!(STATE & UrlSet), "property url should not be set yet");
            m_result->SetUrl(value);
            return castState<UrlSet>();
        }

        NavigatorUserAgentIssueDetailsBuilder<STATE>& SetLocation(std::unique_ptr<protocol::Audits::SourceCodeLocation> value)
        {
            m_result->SetLocation(std::move(value));
            return *this;
        }

        std::unique_ptr<NavigatorUserAgentIssueDetails> Build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class NavigatorUserAgentIssueDetails;
        NavigatorUserAgentIssueDetailsBuilder() : m_result(new NavigatorUserAgentIssueDetails()) { }

        template<int STEP> NavigatorUserAgentIssueDetailsBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<NavigatorUserAgentIssueDetailsBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Audits::NavigatorUserAgentIssueDetails> m_result;
    };

    static NavigatorUserAgentIssueDetailsBuilder<0> Create()
    {
        return NavigatorUserAgentIssueDetailsBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    NavigatorUserAgentIssueDetails()
    {
    }

    String m_url;
    Maybe<protocol::Audits::SourceCodeLocation> m_location;
};


class CONTENT_EXPORT GenericIssueDetails : public ::crdtp::ProtocolObject<GenericIssueDetails> {
public:
    ~GenericIssueDetails() override { }

    String GetErrorType() { return m_errorType; }
    void SetErrorType(const String& value) { m_errorType = value; }

    bool HasFrameId() { return m_frameId.isJust(); }
    String GetFrameId(const String& defaultValue) { return m_frameId.isJust() ? m_frameId.fromJust() : defaultValue; }
    void SetFrameId(const String& value) { m_frameId = value; }

    template<int STATE>
    class GenericIssueDetailsBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            ErrorTypeSet = 1 << 1,
            AllFieldsSet = (ErrorTypeSet | 0)};


        GenericIssueDetailsBuilder<STATE | ErrorTypeSet>& SetErrorType(const String& value)
        {
            static_assert(!(STATE & ErrorTypeSet), "property errorType should not be set yet");
            m_result->SetErrorType(value);
            return castState<ErrorTypeSet>();
        }

        GenericIssueDetailsBuilder<STATE>& SetFrameId(const String& value)
        {
            m_result->SetFrameId(value);
            return *this;
        }

        std::unique_ptr<GenericIssueDetails> Build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class GenericIssueDetails;
        GenericIssueDetailsBuilder() : m_result(new GenericIssueDetails()) { }

        template<int STEP> GenericIssueDetailsBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<GenericIssueDetailsBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Audits::GenericIssueDetails> m_result;
    };

    static GenericIssueDetailsBuilder<0> Create()
    {
        return GenericIssueDetailsBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    GenericIssueDetails()
    {
    }

    String m_errorType;
    Maybe<String> m_frameId;
};


class CONTENT_EXPORT DeprecationIssueDetails : public ::crdtp::ProtocolObject<DeprecationIssueDetails> {
public:
    ~DeprecationIssueDetails() override { }

    bool HasAffectedFrame() { return m_affectedFrame.isJust(); }
    protocol::Audits::AffectedFrame* GetAffectedFrame(protocol::Audits::AffectedFrame* defaultValue) { return m_affectedFrame.isJust() ? m_affectedFrame.fromJust() : defaultValue; }
    void SetAffectedFrame(std::unique_ptr<protocol::Audits::AffectedFrame> value) { m_affectedFrame = std::move(value); }

    protocol::Audits::SourceCodeLocation* GetSourceCodeLocation() { return m_sourceCodeLocation.get(); }
    void SetSourceCodeLocation(std::unique_ptr<protocol::Audits::SourceCodeLocation> value) { m_sourceCodeLocation = std::move(value); }

    String GetType() { return m_type; }
    void SetType(const String& value) { m_type = value; }

    template<int STATE>
    class DeprecationIssueDetailsBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            SourceCodeLocationSet = 1 << 1,
            TypeSet = 1 << 2,
            AllFieldsSet = (SourceCodeLocationSet | TypeSet | 0)};


        DeprecationIssueDetailsBuilder<STATE>& SetAffectedFrame(std::unique_ptr<protocol::Audits::AffectedFrame> value)
        {
            m_result->SetAffectedFrame(std::move(value));
            return *this;
        }

        DeprecationIssueDetailsBuilder<STATE | SourceCodeLocationSet>& SetSourceCodeLocation(std::unique_ptr<protocol::Audits::SourceCodeLocation> value)
        {
            static_assert(!(STATE & SourceCodeLocationSet), "property sourceCodeLocation should not be set yet");
            m_result->SetSourceCodeLocation(std::move(value));
            return castState<SourceCodeLocationSet>();
        }

        DeprecationIssueDetailsBuilder<STATE | TypeSet>& SetType(const String& value)
        {
            static_assert(!(STATE & TypeSet), "property type should not be set yet");
            m_result->SetType(value);
            return castState<TypeSet>();
        }

        std::unique_ptr<DeprecationIssueDetails> Build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class DeprecationIssueDetails;
        DeprecationIssueDetailsBuilder() : m_result(new DeprecationIssueDetails()) { }

        template<int STEP> DeprecationIssueDetailsBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<DeprecationIssueDetailsBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Audits::DeprecationIssueDetails> m_result;
    };

    static DeprecationIssueDetailsBuilder<0> Create()
    {
        return DeprecationIssueDetailsBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    DeprecationIssueDetails()
    {
    }

    Maybe<protocol::Audits::AffectedFrame> m_affectedFrame;
    std::unique_ptr<protocol::Audits::SourceCodeLocation> m_sourceCodeLocation;
    String m_type;
};


class CONTENT_EXPORT FederatedAuthRequestIssueDetails : public ::crdtp::ProtocolObject<FederatedAuthRequestIssueDetails> {
public:
    ~FederatedAuthRequestIssueDetails() override { }

    String GetFederatedAuthRequestIssueReason() { return m_federatedAuthRequestIssueReason; }
    void SetFederatedAuthRequestIssueReason(const String& value) { m_federatedAuthRequestIssueReason = value; }

    template<int STATE>
    class FederatedAuthRequestIssueDetailsBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            FederatedAuthRequestIssueReasonSet = 1 << 1,
            AllFieldsSet = (FederatedAuthRequestIssueReasonSet | 0)};


        FederatedAuthRequestIssueDetailsBuilder<STATE | FederatedAuthRequestIssueReasonSet>& SetFederatedAuthRequestIssueReason(const String& value)
        {
            static_assert(!(STATE & FederatedAuthRequestIssueReasonSet), "property federatedAuthRequestIssueReason should not be set yet");
            m_result->SetFederatedAuthRequestIssueReason(value);
            return castState<FederatedAuthRequestIssueReasonSet>();
        }

        std::unique_ptr<FederatedAuthRequestIssueDetails> Build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class FederatedAuthRequestIssueDetails;
        FederatedAuthRequestIssueDetailsBuilder() : m_result(new FederatedAuthRequestIssueDetails()) { }

        template<int STEP> FederatedAuthRequestIssueDetailsBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<FederatedAuthRequestIssueDetailsBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Audits::FederatedAuthRequestIssueDetails> m_result;
    };

    static FederatedAuthRequestIssueDetailsBuilder<0> Create()
    {
        return FederatedAuthRequestIssueDetailsBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    FederatedAuthRequestIssueDetails()
    {
    }

    String m_federatedAuthRequestIssueReason;
};


class CONTENT_EXPORT ClientHintIssueDetails : public ::crdtp::ProtocolObject<ClientHintIssueDetails> {
public:
    ~ClientHintIssueDetails() override { }

    protocol::Audits::SourceCodeLocation* GetSourceCodeLocation() { return m_sourceCodeLocation.get(); }
    void SetSourceCodeLocation(std::unique_ptr<protocol::Audits::SourceCodeLocation> value) { m_sourceCodeLocation = std::move(value); }

    String GetClientHintIssueReason() { return m_clientHintIssueReason; }
    void SetClientHintIssueReason(const String& value) { m_clientHintIssueReason = value; }

    template<int STATE>
    class ClientHintIssueDetailsBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            SourceCodeLocationSet = 1 << 1,
            ClientHintIssueReasonSet = 1 << 2,
            AllFieldsSet = (SourceCodeLocationSet | ClientHintIssueReasonSet | 0)};


        ClientHintIssueDetailsBuilder<STATE | SourceCodeLocationSet>& SetSourceCodeLocation(std::unique_ptr<protocol::Audits::SourceCodeLocation> value)
        {
            static_assert(!(STATE & SourceCodeLocationSet), "property sourceCodeLocation should not be set yet");
            m_result->SetSourceCodeLocation(std::move(value));
            return castState<SourceCodeLocationSet>();
        }

        ClientHintIssueDetailsBuilder<STATE | ClientHintIssueReasonSet>& SetClientHintIssueReason(const String& value)
        {
            static_assert(!(STATE & ClientHintIssueReasonSet), "property clientHintIssueReason should not be set yet");
            m_result->SetClientHintIssueReason(value);
            return castState<ClientHintIssueReasonSet>();
        }

        std::unique_ptr<ClientHintIssueDetails> Build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class ClientHintIssueDetails;
        ClientHintIssueDetailsBuilder() : m_result(new ClientHintIssueDetails()) { }

        template<int STEP> ClientHintIssueDetailsBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<ClientHintIssueDetailsBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Audits::ClientHintIssueDetails> m_result;
    };

    static ClientHintIssueDetailsBuilder<0> Create()
    {
        return ClientHintIssueDetailsBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    ClientHintIssueDetails()
    {
    }

    std::unique_ptr<protocol::Audits::SourceCodeLocation> m_sourceCodeLocation;
    String m_clientHintIssueReason;
};


class CONTENT_EXPORT InspectorIssueDetails : public ::crdtp::ProtocolObject<InspectorIssueDetails> {
public:
    ~InspectorIssueDetails() override { }

    bool HasCookieIssueDetails() { return m_cookieIssueDetails.isJust(); }
    protocol::Audits::CookieIssueDetails* GetCookieIssueDetails(protocol::Audits::CookieIssueDetails* defaultValue) { return m_cookieIssueDetails.isJust() ? m_cookieIssueDetails.fromJust() : defaultValue; }
    void SetCookieIssueDetails(std::unique_ptr<protocol::Audits::CookieIssueDetails> value) { m_cookieIssueDetails = std::move(value); }

    bool HasMixedContentIssueDetails() { return m_mixedContentIssueDetails.isJust(); }
    protocol::Audits::MixedContentIssueDetails* GetMixedContentIssueDetails(protocol::Audits::MixedContentIssueDetails* defaultValue) { return m_mixedContentIssueDetails.isJust() ? m_mixedContentIssueDetails.fromJust() : defaultValue; }
    void SetMixedContentIssueDetails(std::unique_ptr<protocol::Audits::MixedContentIssueDetails> value) { m_mixedContentIssueDetails = std::move(value); }

    bool HasBlockedByResponseIssueDetails() { return m_blockedByResponseIssueDetails.isJust(); }
    protocol::Audits::BlockedByResponseIssueDetails* GetBlockedByResponseIssueDetails(protocol::Audits::BlockedByResponseIssueDetails* defaultValue) { return m_blockedByResponseIssueDetails.isJust() ? m_blockedByResponseIssueDetails.fromJust() : defaultValue; }
    void SetBlockedByResponseIssueDetails(std::unique_ptr<protocol::Audits::BlockedByResponseIssueDetails> value) { m_blockedByResponseIssueDetails = std::move(value); }

    bool HasHeavyAdIssueDetails() { return m_heavyAdIssueDetails.isJust(); }
    protocol::Audits::HeavyAdIssueDetails* GetHeavyAdIssueDetails(protocol::Audits::HeavyAdIssueDetails* defaultValue) { return m_heavyAdIssueDetails.isJust() ? m_heavyAdIssueDetails.fromJust() : defaultValue; }
    void SetHeavyAdIssueDetails(std::unique_ptr<protocol::Audits::HeavyAdIssueDetails> value) { m_heavyAdIssueDetails = std::move(value); }

    bool HasContentSecurityPolicyIssueDetails() { return m_contentSecurityPolicyIssueDetails.isJust(); }
    protocol::Audits::ContentSecurityPolicyIssueDetails* GetContentSecurityPolicyIssueDetails(protocol::Audits::ContentSecurityPolicyIssueDetails* defaultValue) { return m_contentSecurityPolicyIssueDetails.isJust() ? m_contentSecurityPolicyIssueDetails.fromJust() : defaultValue; }
    void SetContentSecurityPolicyIssueDetails(std::unique_ptr<protocol::Audits::ContentSecurityPolicyIssueDetails> value) { m_contentSecurityPolicyIssueDetails = std::move(value); }

    bool HasSharedArrayBufferIssueDetails() { return m_sharedArrayBufferIssueDetails.isJust(); }
    protocol::Audits::SharedArrayBufferIssueDetails* GetSharedArrayBufferIssueDetails(protocol::Audits::SharedArrayBufferIssueDetails* defaultValue) { return m_sharedArrayBufferIssueDetails.isJust() ? m_sharedArrayBufferIssueDetails.fromJust() : defaultValue; }
    void SetSharedArrayBufferIssueDetails(std::unique_ptr<protocol::Audits::SharedArrayBufferIssueDetails> value) { m_sharedArrayBufferIssueDetails = std::move(value); }

    bool HasTwaQualityEnforcementDetails() { return m_twaQualityEnforcementDetails.isJust(); }
    protocol::Audits::TrustedWebActivityIssueDetails* GetTwaQualityEnforcementDetails(protocol::Audits::TrustedWebActivityIssueDetails* defaultValue) { return m_twaQualityEnforcementDetails.isJust() ? m_twaQualityEnforcementDetails.fromJust() : defaultValue; }
    void SetTwaQualityEnforcementDetails(std::unique_ptr<protocol::Audits::TrustedWebActivityIssueDetails> value) { m_twaQualityEnforcementDetails = std::move(value); }

    bool HasLowTextContrastIssueDetails() { return m_lowTextContrastIssueDetails.isJust(); }
    protocol::Audits::LowTextContrastIssueDetails* GetLowTextContrastIssueDetails(protocol::Audits::LowTextContrastIssueDetails* defaultValue) { return m_lowTextContrastIssueDetails.isJust() ? m_lowTextContrastIssueDetails.fromJust() : defaultValue; }
    void SetLowTextContrastIssueDetails(std::unique_ptr<protocol::Audits::LowTextContrastIssueDetails> value) { m_lowTextContrastIssueDetails = std::move(value); }

    bool HasCorsIssueDetails() { return m_corsIssueDetails.isJust(); }
    protocol::Audits::CorsIssueDetails* GetCorsIssueDetails(protocol::Audits::CorsIssueDetails* defaultValue) { return m_corsIssueDetails.isJust() ? m_corsIssueDetails.fromJust() : defaultValue; }
    void SetCorsIssueDetails(std::unique_ptr<protocol::Audits::CorsIssueDetails> value) { m_corsIssueDetails = std::move(value); }

    bool HasAttributionReportingIssueDetails() { return m_attributionReportingIssueDetails.isJust(); }
    protocol::Audits::AttributionReportingIssueDetails* GetAttributionReportingIssueDetails(protocol::Audits::AttributionReportingIssueDetails* defaultValue) { return m_attributionReportingIssueDetails.isJust() ? m_attributionReportingIssueDetails.fromJust() : defaultValue; }
    void SetAttributionReportingIssueDetails(std::unique_ptr<protocol::Audits::AttributionReportingIssueDetails> value) { m_attributionReportingIssueDetails = std::move(value); }

    bool HasQuirksModeIssueDetails() { return m_quirksModeIssueDetails.isJust(); }
    protocol::Audits::QuirksModeIssueDetails* GetQuirksModeIssueDetails(protocol::Audits::QuirksModeIssueDetails* defaultValue) { return m_quirksModeIssueDetails.isJust() ? m_quirksModeIssueDetails.fromJust() : defaultValue; }
    void SetQuirksModeIssueDetails(std::unique_ptr<protocol::Audits::QuirksModeIssueDetails> value) { m_quirksModeIssueDetails = std::move(value); }

    bool HasNavigatorUserAgentIssueDetails() { return m_navigatorUserAgentIssueDetails.isJust(); }
    protocol::Audits::NavigatorUserAgentIssueDetails* GetNavigatorUserAgentIssueDetails(protocol::Audits::NavigatorUserAgentIssueDetails* defaultValue) { return m_navigatorUserAgentIssueDetails.isJust() ? m_navigatorUserAgentIssueDetails.fromJust() : defaultValue; }
    void SetNavigatorUserAgentIssueDetails(std::unique_ptr<protocol::Audits::NavigatorUserAgentIssueDetails> value) { m_navigatorUserAgentIssueDetails = std::move(value); }

    bool HasGenericIssueDetails() { return m_genericIssueDetails.isJust(); }
    protocol::Audits::GenericIssueDetails* GetGenericIssueDetails(protocol::Audits::GenericIssueDetails* defaultValue) { return m_genericIssueDetails.isJust() ? m_genericIssueDetails.fromJust() : defaultValue; }
    void SetGenericIssueDetails(std::unique_ptr<protocol::Audits::GenericIssueDetails> value) { m_genericIssueDetails = std::move(value); }

    bool HasDeprecationIssueDetails() { return m_deprecationIssueDetails.isJust(); }
    protocol::Audits::DeprecationIssueDetails* GetDeprecationIssueDetails(protocol::Audits::DeprecationIssueDetails* defaultValue) { return m_deprecationIssueDetails.isJust() ? m_deprecationIssueDetails.fromJust() : defaultValue; }
    void SetDeprecationIssueDetails(std::unique_ptr<protocol::Audits::DeprecationIssueDetails> value) { m_deprecationIssueDetails = std::move(value); }

    bool HasClientHintIssueDetails() { return m_clientHintIssueDetails.isJust(); }
    protocol::Audits::ClientHintIssueDetails* GetClientHintIssueDetails(protocol::Audits::ClientHintIssueDetails* defaultValue) { return m_clientHintIssueDetails.isJust() ? m_clientHintIssueDetails.fromJust() : defaultValue; }
    void SetClientHintIssueDetails(std::unique_ptr<protocol::Audits::ClientHintIssueDetails> value) { m_clientHintIssueDetails = std::move(value); }

    bool HasFederatedAuthRequestIssueDetails() { return m_federatedAuthRequestIssueDetails.isJust(); }
    protocol::Audits::FederatedAuthRequestIssueDetails* GetFederatedAuthRequestIssueDetails(protocol::Audits::FederatedAuthRequestIssueDetails* defaultValue) { return m_federatedAuthRequestIssueDetails.isJust() ? m_federatedAuthRequestIssueDetails.fromJust() : defaultValue; }
    void SetFederatedAuthRequestIssueDetails(std::unique_ptr<protocol::Audits::FederatedAuthRequestIssueDetails> value) { m_federatedAuthRequestIssueDetails = std::move(value); }

    template<int STATE>
    class InspectorIssueDetailsBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            AllFieldsSet = (0)};


        InspectorIssueDetailsBuilder<STATE>& SetCookieIssueDetails(std::unique_ptr<protocol::Audits::CookieIssueDetails> value)
        {
            m_result->SetCookieIssueDetails(std::move(value));
            return *this;
        }

        InspectorIssueDetailsBuilder<STATE>& SetMixedContentIssueDetails(std::unique_ptr<protocol::Audits::MixedContentIssueDetails> value)
        {
            m_result->SetMixedContentIssueDetails(std::move(value));
            return *this;
        }

        InspectorIssueDetailsBuilder<STATE>& SetBlockedByResponseIssueDetails(std::unique_ptr<protocol::Audits::BlockedByResponseIssueDetails> value)
        {
            m_result->SetBlockedByResponseIssueDetails(std::move(value));
            return *this;
        }

        InspectorIssueDetailsBuilder<STATE>& SetHeavyAdIssueDetails(std::unique_ptr<protocol::Audits::HeavyAdIssueDetails> value)
        {
            m_result->SetHeavyAdIssueDetails(std::move(value));
            return *this;
        }

        InspectorIssueDetailsBuilder<STATE>& SetContentSecurityPolicyIssueDetails(std::unique_ptr<protocol::Audits::ContentSecurityPolicyIssueDetails> value)
        {
            m_result->SetContentSecurityPolicyIssueDetails(std::move(value));
            return *this;
        }

        InspectorIssueDetailsBuilder<STATE>& SetSharedArrayBufferIssueDetails(std::unique_ptr<protocol::Audits::SharedArrayBufferIssueDetails> value)
        {
            m_result->SetSharedArrayBufferIssueDetails(std::move(value));
            return *this;
        }

        InspectorIssueDetailsBuilder<STATE>& SetTwaQualityEnforcementDetails(std::unique_ptr<protocol::Audits::TrustedWebActivityIssueDetails> value)
        {
            m_result->SetTwaQualityEnforcementDetails(std::move(value));
            return *this;
        }

        InspectorIssueDetailsBuilder<STATE>& SetLowTextContrastIssueDetails(std::unique_ptr<protocol::Audits::LowTextContrastIssueDetails> value)
        {
            m_result->SetLowTextContrastIssueDetails(std::move(value));
            return *this;
        }

        InspectorIssueDetailsBuilder<STATE>& SetCorsIssueDetails(std::unique_ptr<protocol::Audits::CorsIssueDetails> value)
        {
            m_result->SetCorsIssueDetails(std::move(value));
            return *this;
        }

        InspectorIssueDetailsBuilder<STATE>& SetAttributionReportingIssueDetails(std::unique_ptr<protocol::Audits::AttributionReportingIssueDetails> value)
        {
            m_result->SetAttributionReportingIssueDetails(std::move(value));
            return *this;
        }

        InspectorIssueDetailsBuilder<STATE>& SetQuirksModeIssueDetails(std::unique_ptr<protocol::Audits::QuirksModeIssueDetails> value)
        {
            m_result->SetQuirksModeIssueDetails(std::move(value));
            return *this;
        }

        InspectorIssueDetailsBuilder<STATE>& SetNavigatorUserAgentIssueDetails(std::unique_ptr<protocol::Audits::NavigatorUserAgentIssueDetails> value)
        {
            m_result->SetNavigatorUserAgentIssueDetails(std::move(value));
            return *this;
        }

        InspectorIssueDetailsBuilder<STATE>& SetGenericIssueDetails(std::unique_ptr<protocol::Audits::GenericIssueDetails> value)
        {
            m_result->SetGenericIssueDetails(std::move(value));
            return *this;
        }

        InspectorIssueDetailsBuilder<STATE>& SetDeprecationIssueDetails(std::unique_ptr<protocol::Audits::DeprecationIssueDetails> value)
        {
            m_result->SetDeprecationIssueDetails(std::move(value));
            return *this;
        }

        InspectorIssueDetailsBuilder<STATE>& SetClientHintIssueDetails(std::unique_ptr<protocol::Audits::ClientHintIssueDetails> value)
        {
            m_result->SetClientHintIssueDetails(std::move(value));
            return *this;
        }

        InspectorIssueDetailsBuilder<STATE>& SetFederatedAuthRequestIssueDetails(std::unique_ptr<protocol::Audits::FederatedAuthRequestIssueDetails> value)
        {
            m_result->SetFederatedAuthRequestIssueDetails(std::move(value));
            return *this;
        }

        std::unique_ptr<InspectorIssueDetails> Build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class InspectorIssueDetails;
        InspectorIssueDetailsBuilder() : m_result(new InspectorIssueDetails()) { }

        template<int STEP> InspectorIssueDetailsBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<InspectorIssueDetailsBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Audits::InspectorIssueDetails> m_result;
    };

    static InspectorIssueDetailsBuilder<0> Create()
    {
        return InspectorIssueDetailsBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    InspectorIssueDetails()
    {
    }

    Maybe<protocol::Audits::CookieIssueDetails> m_cookieIssueDetails;
    Maybe<protocol::Audits::MixedContentIssueDetails> m_mixedContentIssueDetails;
    Maybe<protocol::Audits::BlockedByResponseIssueDetails> m_blockedByResponseIssueDetails;
    Maybe<protocol::Audits::HeavyAdIssueDetails> m_heavyAdIssueDetails;
    Maybe<protocol::Audits::ContentSecurityPolicyIssueDetails> m_contentSecurityPolicyIssueDetails;
    Maybe<protocol::Audits::SharedArrayBufferIssueDetails> m_sharedArrayBufferIssueDetails;
    Maybe<protocol::Audits::TrustedWebActivityIssueDetails> m_twaQualityEnforcementDetails;
    Maybe<protocol::Audits::LowTextContrastIssueDetails> m_lowTextContrastIssueDetails;
    Maybe<protocol::Audits::CorsIssueDetails> m_corsIssueDetails;
    Maybe<protocol::Audits::AttributionReportingIssueDetails> m_attributionReportingIssueDetails;
    Maybe<protocol::Audits::QuirksModeIssueDetails> m_quirksModeIssueDetails;
    Maybe<protocol::Audits::NavigatorUserAgentIssueDetails> m_navigatorUserAgentIssueDetails;
    Maybe<protocol::Audits::GenericIssueDetails> m_genericIssueDetails;
    Maybe<protocol::Audits::DeprecationIssueDetails> m_deprecationIssueDetails;
    Maybe<protocol::Audits::ClientHintIssueDetails> m_clientHintIssueDetails;
    Maybe<protocol::Audits::FederatedAuthRequestIssueDetails> m_federatedAuthRequestIssueDetails;
};


class CONTENT_EXPORT InspectorIssue : public ::crdtp::ProtocolObject<InspectorIssue> {
public:
    ~InspectorIssue() override { }

    String GetCode() { return m_code; }
    void SetCode(const String& value) { m_code = value; }

    protocol::Audits::InspectorIssueDetails* GetDetails() { return m_details.get(); }
    void SetDetails(std::unique_ptr<protocol::Audits::InspectorIssueDetails> value) { m_details = std::move(value); }

    bool HasIssueId() { return m_issueId.isJust(); }
    String GetIssueId(const String& defaultValue) { return m_issueId.isJust() ? m_issueId.fromJust() : defaultValue; }
    void SetIssueId(const String& value) { m_issueId = value; }

    template<int STATE>
    class InspectorIssueBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            CodeSet = 1 << 1,
            DetailsSet = 1 << 2,
            AllFieldsSet = (CodeSet | DetailsSet | 0)};


        InspectorIssueBuilder<STATE | CodeSet>& SetCode(const String& value)
        {
            static_assert(!(STATE & CodeSet), "property code should not be set yet");
            m_result->SetCode(value);
            return castState<CodeSet>();
        }

        InspectorIssueBuilder<STATE | DetailsSet>& SetDetails(std::unique_ptr<protocol::Audits::InspectorIssueDetails> value)
        {
            static_assert(!(STATE & DetailsSet), "property details should not be set yet");
            m_result->SetDetails(std::move(value));
            return castState<DetailsSet>();
        }

        InspectorIssueBuilder<STATE>& SetIssueId(const String& value)
        {
            m_result->SetIssueId(value);
            return *this;
        }

        std::unique_ptr<InspectorIssue> Build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class InspectorIssue;
        InspectorIssueBuilder() : m_result(new InspectorIssue()) { }

        template<int STEP> InspectorIssueBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<InspectorIssueBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Audits::InspectorIssue> m_result;
    };

    static InspectorIssueBuilder<0> Create()
    {
        return InspectorIssueBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    InspectorIssue()
    {
    }

    String m_code;
    std::unique_ptr<protocol::Audits::InspectorIssueDetails> m_details;
    Maybe<String> m_issueId;
};


// ------------- Backend interface.

class CONTENT_EXPORT Backend {
public:
    virtual ~Backend() { }

    virtual DispatchResponse Disable() = 0;
    virtual DispatchResponse Enable() = 0;

};

// ------------- Frontend interface.

class CONTENT_EXPORT Frontend {
public:
  explicit Frontend(FrontendChannel* frontend_channel) : frontend_channel_(frontend_channel) {}
    void IssueAdded(std::unique_ptr<protocol::Audits::InspectorIssue> issue);

  void flush();
  void sendRawNotification(std::unique_ptr<Serializable>);
 private:
  FrontendChannel* frontend_channel_;
};

// ------------- Dispatcher.

class CONTENT_EXPORT Dispatcher {
public:
    static void wire(UberDispatcher*, Backend*);

private:
    Dispatcher() { }
};

// ------------- Metainfo.

class CONTENT_EXPORT Metainfo {
public:
    using BackendClass = Backend;
    using FrontendClass = Frontend;
    using DispatcherClass = Dispatcher;
    static const char domainName[];
    static const char commandPrefix[];
    static const char version[];
};

} // namespace Audits
} // namespace content
} // namespace protocol

#endif // !defined(content_protocol_Audits_h)
