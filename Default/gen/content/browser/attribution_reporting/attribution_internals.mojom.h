// content/browser/attribution_reporting/attribution_internals.mojom.h is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2013 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef CONTENT_BROWSER_ATTRIBUTION_REPORTING_ATTRIBUTION_INTERNALS_MOJOM_H_
#define CONTENT_BROWSER_ATTRIBUTION_REPORTING_ATTRIBUTION_INTERNALS_MOJOM_H_

#include <stdint.h>

#include <limits>
#include <type_traits>
#include <utility>

#include "third_party/abseil-cpp/absl/types/optional.h"
#include "mojo/public/cpp/bindings/clone_traits.h"
#include "mojo/public/cpp/bindings/equals_traits.h"
#include "mojo/public/cpp/bindings/lib/serialization.h"
#include "mojo/public/cpp/bindings/struct_ptr.h"
#include "mojo/public/cpp/bindings/struct_traits.h"
#include "mojo/public/cpp/bindings/union_traits.h"

#include "third_party/perfetto/include/perfetto/tracing/traced_value_forward.h"

#include "content/browser/attribution_reporting/attribution_internals.mojom-shared.h"
#include "content/browser/attribution_reporting/attribution_internals.mojom-forward.h"
#include "url/mojom/origin.mojom.h"
#include "url/mojom/url.mojom.h"
#include <string>
#include <vector>

#include "mojo/public/cpp/bindings/lib/control_message_handler.h"
#include "mojo/public/cpp/bindings/raw_ptr_impl_ref_traits.h"


#include "content/browser/attribution_reporting/attribution_internals_mojom_traits.h"
#include "content/browser/attribution_reporting/attribution_report.h"
#include "content/browser/attribution_reporting/attribution_source_type.h"




namespace attribution_internals {
namespace mojom {

class ObserverProxy;

template <typename ImplRefTraits>
class ObserverStub;

class ObserverRequestValidator;


class  Observer
    : public ObserverInterfaceBase {
 public:
  using IPCStableHashFunction = uint32_t(*)();

  static const char Name_[];
  static IPCStableHashFunction MessageToMethodInfo_(mojo::Message& message);
  static const char* MessageToMethodName_(mojo::Message& message);
  static constexpr uint32_t Version_ = 0;
  static constexpr bool PassesAssociatedKinds_ = false;
  static constexpr bool HasSyncMethods_ = false;
  static constexpr bool HasUninterruptableMethods_ = false;

  using Base_ = ObserverInterfaceBase;
  using Proxy_ = ObserverProxy;

  template <typename ImplRefTraits>
  using Stub_ = ObserverStub<ImplRefTraits>;

  using RequestValidator_ = ObserverRequestValidator;
  using ResponseValidator_ = mojo::PassThroughFilter;
  enum MethodMinVersions : uint32_t {
    kOnSourcesChangedMinVersion = 0,
    kOnReportsChangedMinVersion = 0,
    kOnSourceRejectedOrDeactivatedMinVersion = 0,
    kOnReportSentMinVersion = 0,
    kOnReportDroppedMinVersion = 0,
    kOnTriggerHandledMinVersion = 0,
  };

// crbug.com/1340245 - this causes binary size bloat on Fuchsia, and we're OK
// with not having this data in traces there.
#if !BUILDFLAG(IS_FUCHSIA)
  struct OnSourcesChanged_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct OnReportsChanged_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct OnSourceRejectedOrDeactivated_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct OnReportSent_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct OnReportDropped_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct OnTriggerHandled_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
#endif // !BUILDFLAG(IS_FUCHSIA)
  virtual ~Observer() = default;

  
  virtual void OnSourcesChanged() = 0;

  
  virtual void OnReportsChanged(::content::AttributionReport::ReportType report_type) = 0;

  
  virtual void OnSourceRejectedOrDeactivated(WebUISourcePtr source) = 0;

  
  virtual void OnReportSent(WebUIReportPtr report) = 0;

  
  virtual void OnReportDropped(WebUIReportPtr report) = 0;

  
  virtual void OnTriggerHandled(WebUITriggerPtr trigger) = 0;
};

class HandlerProxy;

template <typename ImplRefTraits>
class HandlerStub;

class HandlerRequestValidator;
class HandlerResponseValidator;


class  Handler
    : public HandlerInterfaceBase {
 public:
  using IPCStableHashFunction = uint32_t(*)();

  static const char Name_[];
  static IPCStableHashFunction MessageToMethodInfo_(mojo::Message& message);
  static const char* MessageToMethodName_(mojo::Message& message);
  static constexpr uint32_t Version_ = 0;
  static constexpr bool PassesAssociatedKinds_ = false;
  static constexpr bool HasSyncMethods_ = false;
  static constexpr bool HasUninterruptableMethods_ = false;

  using Base_ = HandlerInterfaceBase;
  using Proxy_ = HandlerProxy;

  template <typename ImplRefTraits>
  using Stub_ = HandlerStub<ImplRefTraits>;

  using RequestValidator_ = HandlerRequestValidator;
  using ResponseValidator_ = HandlerResponseValidator;
  enum MethodMinVersions : uint32_t {
    kIsAttributionReportingEnabledMinVersion = 0,
    kGetActiveSourcesMinVersion = 0,
    kGetReportsMinVersion = 0,
    kSendReportsMinVersion = 0,
    kClearStorageMinVersion = 0,
    kAddObserverMinVersion = 0,
  };

// crbug.com/1340245 - this causes binary size bloat on Fuchsia, and we're OK
// with not having this data in traces there.
#if !BUILDFLAG(IS_FUCHSIA)
  struct IsAttributionReportingEnabled_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct GetActiveSources_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct GetReports_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct SendReports_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct ClearStorage_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct AddObserver_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
#endif // !BUILDFLAG(IS_FUCHSIA)
  virtual ~Handler() = default;


  using IsAttributionReportingEnabledCallback = base::OnceCallback<void(bool, bool)>;
  
  virtual void IsAttributionReportingEnabled(IsAttributionReportingEnabledCallback callback) = 0;


  using GetActiveSourcesCallback = base::OnceCallback<void(std::vector<WebUISourcePtr>)>;
  
  virtual void GetActiveSources(GetActiveSourcesCallback callback) = 0;


  using GetReportsCallback = base::OnceCallback<void(std::vector<WebUIReportPtr>)>;
  
  virtual void GetReports(::content::AttributionReport::ReportType report_type, GetReportsCallback callback) = 0;


  using SendReportsCallback = base::OnceCallback<void()>;
  
  virtual void SendReports(const std::vector<::content::AttributionReport::Id>& ids, SendReportsCallback callback) = 0;


  using ClearStorageCallback = base::OnceCallback<void()>;
  
  virtual void ClearStorage(ClearStorageCallback callback) = 0;


  using AddObserverCallback = base::OnceCallback<void(bool)>;
  
  virtual void AddObserver(::mojo::PendingRemote<Observer> observer, AddObserverCallback callback) = 0;
};



class  ObserverProxy
    : public Observer {
 public:
  using InterfaceType = Observer;

  explicit ObserverProxy(mojo::MessageReceiverWithResponder* receiver);
  
  void OnSourcesChanged() final;
  
  void OnReportsChanged(::content::AttributionReport::ReportType report_type) final;
  
  void OnSourceRejectedOrDeactivated(WebUISourcePtr source) final;
  
  void OnReportSent(WebUIReportPtr report) final;
  
  void OnReportDropped(WebUIReportPtr report) final;
  
  void OnTriggerHandled(WebUITriggerPtr trigger) final;

 private:
  mojo::MessageReceiverWithResponder* receiver_;
};



class  HandlerProxy
    : public Handler {
 public:
  using InterfaceType = Handler;

  explicit HandlerProxy(mojo::MessageReceiverWithResponder* receiver);
  
  void IsAttributionReportingEnabled(IsAttributionReportingEnabledCallback callback) final;
  
  void GetActiveSources(GetActiveSourcesCallback callback) final;
  
  void GetReports(::content::AttributionReport::ReportType report_type, GetReportsCallback callback) final;
  
  void SendReports(const std::vector<::content::AttributionReport::Id>& ids, SendReportsCallback callback) final;
  
  void ClearStorage(ClearStorageCallback callback) final;
  
  void AddObserver(::mojo::PendingRemote<Observer> observer, AddObserverCallback callback) final;

 private:
  mojo::MessageReceiverWithResponder* receiver_;
};
class  ObserverStubDispatch {
 public:
  static bool Accept(Observer* impl, mojo::Message* message);
  static bool AcceptWithResponder(
      Observer* impl,
      mojo::Message* message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder);
};

template <typename ImplRefTraits =
              mojo::RawPtrImplRefTraits<Observer>>
class ObserverStub
    : public mojo::MessageReceiverWithResponderStatus {
 public:
  using ImplPointerType = typename ImplRefTraits::PointerType;

  ObserverStub() = default;
  ~ObserverStub() override = default;

  void set_sink(ImplPointerType sink) { sink_ = std::move(sink); }
  ImplPointerType& sink() { return sink_; }

  bool Accept(mojo::Message* message) override {
    if (ImplRefTraits::IsNull(sink_))
      return false;
    return ObserverStubDispatch::Accept(
        ImplRefTraits::GetRawPointer(&sink_), message);
  }

  bool AcceptWithResponder(
      mojo::Message* message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) override {
    if (ImplRefTraits::IsNull(sink_))
      return false;
    return ObserverStubDispatch::AcceptWithResponder(
        ImplRefTraits::GetRawPointer(&sink_), message, std::move(responder));
  }

 private:
  ImplPointerType sink_;
};
class  HandlerStubDispatch {
 public:
  static bool Accept(Handler* impl, mojo::Message* message);
  static bool AcceptWithResponder(
      Handler* impl,
      mojo::Message* message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder);
};

template <typename ImplRefTraits =
              mojo::RawPtrImplRefTraits<Handler>>
class HandlerStub
    : public mojo::MessageReceiverWithResponderStatus {
 public:
  using ImplPointerType = typename ImplRefTraits::PointerType;

  HandlerStub() = default;
  ~HandlerStub() override = default;

  void set_sink(ImplPointerType sink) { sink_ = std::move(sink); }
  ImplPointerType& sink() { return sink_; }

  bool Accept(mojo::Message* message) override {
    if (ImplRefTraits::IsNull(sink_))
      return false;
    return HandlerStubDispatch::Accept(
        ImplRefTraits::GetRawPointer(&sink_), message);
  }

  bool AcceptWithResponder(
      mojo::Message* message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) override {
    if (ImplRefTraits::IsNull(sink_))
      return false;
    return HandlerStubDispatch::AcceptWithResponder(
        ImplRefTraits::GetRawPointer(&sink_), message, std::move(responder));
  }

 private:
  ImplPointerType sink_;
};
class  ObserverRequestValidator : public mojo::MessageReceiver {
 public:
  bool Accept(mojo::Message* message) override;
};
class  HandlerRequestValidator : public mojo::MessageReceiver {
 public:
  bool Accept(mojo::Message* message) override;
};
class  HandlerResponseValidator : public mojo::MessageReceiver {
 public:
  bool Accept(mojo::Message* message) override;
};





class  EventLevelReportID {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<EventLevelReportID, T>::value>;
  using DataView = EventLevelReportIDDataView;
  using Data_ = internal::EventLevelReportID_Data;

  template <typename... Args>
  static EventLevelReportIDPtr New(Args&&... args) {
    return EventLevelReportIDPtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static EventLevelReportIDPtr From(const U& u) {
    return mojo::TypeConverter<EventLevelReportIDPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, EventLevelReportID>::Convert(*this);
  }


  EventLevelReportID();

  explicit EventLevelReportID(
      int64_t value);


  ~EventLevelReportID();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = EventLevelReportIDPtr>
  EventLevelReportIDPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, EventLevelReportID::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, EventLevelReportID::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        EventLevelReportID::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        EventLevelReportID::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::EventLevelReportID_UnserializedMessageContext<
            UserType, EventLevelReportID::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<EventLevelReportID::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return EventLevelReportID::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::EventLevelReportID_UnserializedMessageContext<
            UserType, EventLevelReportID::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<EventLevelReportID::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
  int64_t value;

  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, EventLevelReportID::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, EventLevelReportID::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, EventLevelReportID::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, EventLevelReportID::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





class  AggregatableAttributionReportID {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<AggregatableAttributionReportID, T>::value>;
  using DataView = AggregatableAttributionReportIDDataView;
  using Data_ = internal::AggregatableAttributionReportID_Data;

  template <typename... Args>
  static AggregatableAttributionReportIDPtr New(Args&&... args) {
    return AggregatableAttributionReportIDPtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static AggregatableAttributionReportIDPtr From(const U& u) {
    return mojo::TypeConverter<AggregatableAttributionReportIDPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, AggregatableAttributionReportID>::Convert(*this);
  }


  AggregatableAttributionReportID();

  explicit AggregatableAttributionReportID(
      int64_t value);


  ~AggregatableAttributionReportID();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = AggregatableAttributionReportIDPtr>
  AggregatableAttributionReportIDPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, AggregatableAttributionReportID::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, AggregatableAttributionReportID::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        AggregatableAttributionReportID::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        AggregatableAttributionReportID::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::AggregatableAttributionReportID_UnserializedMessageContext<
            UserType, AggregatableAttributionReportID::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<AggregatableAttributionReportID::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return AggregatableAttributionReportID::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::AggregatableAttributionReportID_UnserializedMessageContext<
            UserType, AggregatableAttributionReportID::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<AggregatableAttributionReportID::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
  int64_t value;

  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, AggregatableAttributionReportID::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, AggregatableAttributionReportID::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, AggregatableAttributionReportID::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, AggregatableAttributionReportID::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





class  WebUIReportEventLevelData {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<WebUIReportEventLevelData, T>::value>;
  using DataView = WebUIReportEventLevelDataDataView;
  using Data_ = internal::WebUIReportEventLevelData_Data;

  template <typename... Args>
  static WebUIReportEventLevelDataPtr New(Args&&... args) {
    return WebUIReportEventLevelDataPtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static WebUIReportEventLevelDataPtr From(const U& u) {
    return mojo::TypeConverter<WebUIReportEventLevelDataPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, WebUIReportEventLevelData>::Convert(*this);
  }


  WebUIReportEventLevelData();

  WebUIReportEventLevelData(
      int64_t priority,
      bool attributed_truthfully);


  ~WebUIReportEventLevelData();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = WebUIReportEventLevelDataPtr>
  WebUIReportEventLevelDataPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, WebUIReportEventLevelData::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, WebUIReportEventLevelData::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  size_t Hash(size_t seed) const;
  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        WebUIReportEventLevelData::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        WebUIReportEventLevelData::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::WebUIReportEventLevelData_UnserializedMessageContext<
            UserType, WebUIReportEventLevelData::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<WebUIReportEventLevelData::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return WebUIReportEventLevelData::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::WebUIReportEventLevelData_UnserializedMessageContext<
            UserType, WebUIReportEventLevelData::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<WebUIReportEventLevelData::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
  int64_t priority;
  
  bool attributed_truthfully;

  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, WebUIReportEventLevelData::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, WebUIReportEventLevelData::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, WebUIReportEventLevelData::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, WebUIReportEventLevelData::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





class  AggregatableHistogramContribution {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<AggregatableHistogramContribution, T>::value>;
  using DataView = AggregatableHistogramContributionDataView;
  using Data_ = internal::AggregatableHistogramContribution_Data;

  template <typename... Args>
  static AggregatableHistogramContributionPtr New(Args&&... args) {
    return AggregatableHistogramContributionPtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static AggregatableHistogramContributionPtr From(const U& u) {
    return mojo::TypeConverter<AggregatableHistogramContributionPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, AggregatableHistogramContribution>::Convert(*this);
  }


  AggregatableHistogramContribution();

  AggregatableHistogramContribution(
      const std::string& key,
      uint32_t value);


  ~AggregatableHistogramContribution();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = AggregatableHistogramContributionPtr>
  AggregatableHistogramContributionPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, AggregatableHistogramContribution::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, AggregatableHistogramContribution::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  size_t Hash(size_t seed) const;
  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        AggregatableHistogramContribution::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        AggregatableHistogramContribution::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::AggregatableHistogramContribution_UnserializedMessageContext<
            UserType, AggregatableHistogramContribution::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<AggregatableHistogramContribution::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return AggregatableHistogramContribution::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::AggregatableHistogramContribution_UnserializedMessageContext<
            UserType, AggregatableHistogramContribution::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<AggregatableHistogramContribution::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
  std::string key;
  
  uint32_t value;

  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, AggregatableHistogramContribution::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, AggregatableHistogramContribution::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, AggregatableHistogramContribution::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, AggregatableHistogramContribution::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}






class  Empty {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<Empty, T>::value>;
  using DataView = EmptyDataView;
  using Data_ = internal::Empty_Data;

  template <typename... Args>
  static EmptyPtr New(Args&&... args) {
    return EmptyPtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static EmptyPtr From(const U& u) {
    return mojo::TypeConverter<EmptyPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, Empty>::Convert(*this);
  }


  Empty();


  ~Empty();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = EmptyPtr>
  EmptyPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, Empty::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, Empty::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  size_t Hash(size_t seed) const;
  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        Empty::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        Empty::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::Empty_UnserializedMessageContext<
            UserType, Empty::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<Empty::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return Empty::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::Empty_UnserializedMessageContext<
            UserType, Empty::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<Empty::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }


  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, Empty::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, Empty::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, Empty::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, Empty::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}






class  DebugKey {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<DebugKey, T>::value>;
  using DataView = DebugKeyDataView;
  using Data_ = internal::DebugKey_Data;

  template <typename... Args>
  static DebugKeyPtr New(Args&&... args) {
    return DebugKeyPtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static DebugKeyPtr From(const U& u) {
    return mojo::TypeConverter<DebugKeyPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, DebugKey>::Convert(*this);
  }


  DebugKey();

  explicit DebugKey(
      uint64_t value);


  ~DebugKey();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = DebugKeyPtr>
  DebugKeyPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, DebugKey::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, DebugKey::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  size_t Hash(size_t seed) const;
  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        DebugKey::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        DebugKey::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::DebugKey_UnserializedMessageContext<
            UserType, DebugKey::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<DebugKey::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return DebugKey::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::DebugKey_UnserializedMessageContext<
            UserType, DebugKey::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<DebugKey::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
  uint64_t value;

  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, DebugKey::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, DebugKey::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, DebugKey::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, DebugKey::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}






class  DedupKey {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<DedupKey, T>::value>;
  using DataView = DedupKeyDataView;
  using Data_ = internal::DedupKey_Data;

  template <typename... Args>
  static DedupKeyPtr New(Args&&... args) {
    return DedupKeyPtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static DedupKeyPtr From(const U& u) {
    return mojo::TypeConverter<DedupKeyPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, DedupKey>::Convert(*this);
  }


  DedupKey();

  explicit DedupKey(
      uint64_t value);


  ~DedupKey();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = DedupKeyPtr>
  DedupKeyPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, DedupKey::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, DedupKey::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  size_t Hash(size_t seed) const;
  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        DedupKey::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        DedupKey::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::DedupKey_UnserializedMessageContext<
            UserType, DedupKey::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<DedupKey::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return DedupKey::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::DedupKey_UnserializedMessageContext<
            UserType, DedupKey::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<DedupKey::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
  uint64_t value;

  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, DedupKey::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, DedupKey::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, DedupKey::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, DedupKey::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}








class  ReportID {
 public:
  using DataView = ReportIDDataView;
  using Data_ = internal::ReportID_Data;
  using Tag = Data_::ReportID_Tag;

  template <typename... Args>
  static ReportIDPtr New(Args&&... args) {
    static_assert(
        sizeof...(args) < 0,
        "Do not use Union::New(); to create a union of a given subtype, use "
        "New<SubType>(), not New() followed by set_<sub_type>(). To represent "
        "an empty union, mark the field or parameter as nullable in the mojom "
        "definition.");
  }
  // Construct an instance holding |event_level_id|.
  static ReportIDPtr
  NewEventLevelId(
      const ::content::AttributionReport::EventLevelData::Id& event_level_id) {
    auto result = ReportIDPtr(absl::in_place);
    result->set_event_level_id(std::move(event_level_id));
    return result;
  }
  // Construct an instance holding |aggregatable_attribution_id|.
  static ReportIDPtr
  NewAggregatableAttributionId(
      const ::content::AttributionReport::AggregatableAttributionData::Id& aggregatable_attribution_id) {
    auto result = ReportIDPtr(absl::in_place);
    result->set_aggregatable_attribution_id(std::move(aggregatable_attribution_id));
    return result;
  }

  template <typename U>
  static ReportIDPtr From(const U& u) {
    return mojo::TypeConverter<ReportIDPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, ReportID>::Convert(*this);
  }

  ReportID();
  ~ReportID();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename UnionPtrType = ReportIDPtr>
  ReportIDPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T,
            typename std::enable_if<std::is_same<
                T, ReportID>::value>::type* = nullptr>
  bool Equals(const T& other) const;

  template <typename T,
            typename std::enable_if<std::is_same<
                T, ReportID>::value>::type* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }

  Tag which() const {
    return tag_;
  }


  
  bool is_event_level_id() const { return tag_ == Tag::kEventLevelId; }

  
  ::content::AttributionReport::EventLevelData::Id& get_event_level_id() const {
    CHECK(tag_ == Tag::kEventLevelId);
    return *(data_.event_level_id);
  }

  
  void set_event_level_id(
      const ::content::AttributionReport::EventLevelData::Id& event_level_id);
  
  bool is_aggregatable_attribution_id() const { return tag_ == Tag::kAggregatableAttributionId; }

  
  ::content::AttributionReport::AggregatableAttributionData::Id& get_aggregatable_attribution_id() const {
    CHECK(tag_ == Tag::kAggregatableAttributionId);
    return *(data_.aggregatable_attribution_id);
  }

  
  void set_aggregatable_attribution_id(
      const ::content::AttributionReport::AggregatableAttributionData::Id& aggregatable_attribution_id);

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        ReportID::DataView>(input);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    return mojo::internal::DeserializeImpl<ReportID::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

 private:
  union Union_ {
    Union_() = default;
    ~Union_() = default;
    ::content::AttributionReport::EventLevelData::Id* event_level_id;
    ::content::AttributionReport::AggregatableAttributionData::Id* aggregatable_attribution_id;
  };

  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);

  void DestroyActive();
  Tag tag_;
  Union_ data_;
};



class  WebUIReportData {
 public:
  using DataView = WebUIReportDataDataView;
  using Data_ = internal::WebUIReportData_Data;
  using Tag = Data_::WebUIReportData_Tag;

  template <typename... Args>
  static WebUIReportDataPtr New(Args&&... args) {
    static_assert(
        sizeof...(args) < 0,
        "Do not use Union::New(); to create a union of a given subtype, use "
        "New<SubType>(), not New() followed by set_<sub_type>(). To represent "
        "an empty union, mark the field or parameter as nullable in the mojom "
        "definition.");
  }
  // Construct an instance holding |event_level_data|.
  static WebUIReportDataPtr
  NewEventLevelData(
      WebUIReportEventLevelDataPtr event_level_data) {
    auto result = WebUIReportDataPtr(absl::in_place);
    result->set_event_level_data(std::move(event_level_data));
    return result;
  }
  // Construct an instance holding |aggregatable_attribution_data|.
  static WebUIReportDataPtr
  NewAggregatableAttributionData(
      WebUIReportAggregatableAttributionDataPtr aggregatable_attribution_data) {
    auto result = WebUIReportDataPtr(absl::in_place);
    result->set_aggregatable_attribution_data(std::move(aggregatable_attribution_data));
    return result;
  }

  template <typename U>
  static WebUIReportDataPtr From(const U& u) {
    return mojo::TypeConverter<WebUIReportDataPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, WebUIReportData>::Convert(*this);
  }

  WebUIReportData();
  ~WebUIReportData();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename UnionPtrType = WebUIReportDataPtr>
  WebUIReportDataPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T,
            typename std::enable_if<std::is_same<
                T, WebUIReportData>::value>::type* = nullptr>
  bool Equals(const T& other) const;

  template <typename T,
            typename std::enable_if<std::is_same<
                T, WebUIReportData>::value>::type* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }

  Tag which() const {
    return tag_;
  }


  
  bool is_event_level_data() const { return tag_ == Tag::kEventLevelData; }

  
  WebUIReportEventLevelDataPtr& get_event_level_data() const {
    CHECK(tag_ == Tag::kEventLevelData);
    return *(data_.event_level_data);
  }

  
  void set_event_level_data(
      WebUIReportEventLevelDataPtr event_level_data);
  
  bool is_aggregatable_attribution_data() const { return tag_ == Tag::kAggregatableAttributionData; }

  
  WebUIReportAggregatableAttributionDataPtr& get_aggregatable_attribution_data() const {
    CHECK(tag_ == Tag::kAggregatableAttributionData);
    return *(data_.aggregatable_attribution_data);
  }

  
  void set_aggregatable_attribution_data(
      WebUIReportAggregatableAttributionDataPtr aggregatable_attribution_data);

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        WebUIReportData::DataView>(input);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    return mojo::internal::DeserializeImpl<WebUIReportData::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

 private:
  union Union_ {
    Union_() = default;
    ~Union_() = default;
    WebUIReportEventLevelDataPtr* event_level_data;
    WebUIReportAggregatableAttributionDataPtr* aggregatable_attribution_data;
  };

  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);

  void DestroyActive();
  Tag tag_;
  Union_ data_;
};



class  ReportStatus {
 public:
  using DataView = ReportStatusDataView;
  using Data_ = internal::ReportStatus_Data;
  using Tag = Data_::ReportStatus_Tag;

  template <typename... Args>
  static ReportStatusPtr New(Args&&... args) {
    static_assert(
        sizeof...(args) < 0,
        "Do not use Union::New(); to create a union of a given subtype, use "
        "New<SubType>(), not New() followed by set_<sub_type>(). To represent "
        "an empty union, mark the field or parameter as nullable in the mojom "
        "definition.");
  }
  // Construct an instance holding |pending|.
  static ReportStatusPtr
  NewPending(
      EmptyPtr pending) {
    auto result = ReportStatusPtr(absl::in_place);
    result->set_pending(std::move(pending));
    return result;
  }
  // Construct an instance holding |replaced_by_higher_priority_report|.
  static ReportStatusPtr
  NewReplacedByHigherPriorityReport(
      const std::string& replaced_by_higher_priority_report) {
    auto result = ReportStatusPtr(absl::in_place);
    result->set_replaced_by_higher_priority_report(std::move(replaced_by_higher_priority_report));
    return result;
  }
  // Construct an instance holding |prohibited_by_browser_policy|.
  static ReportStatusPtr
  NewProhibitedByBrowserPolicy(
      EmptyPtr prohibited_by_browser_policy) {
    auto result = ReportStatusPtr(absl::in_place);
    result->set_prohibited_by_browser_policy(std::move(prohibited_by_browser_policy));
    return result;
  }
  // Construct an instance holding |sent|.
  static ReportStatusPtr
  NewSent(
      int32_t sent) {
    auto result = ReportStatusPtr(absl::in_place);
    result->set_sent(std::move(sent));
    return result;
  }
  // Construct an instance holding |network_error|.
  static ReportStatusPtr
  NewNetworkError(
      const std::string& network_error) {
    auto result = ReportStatusPtr(absl::in_place);
    result->set_network_error(std::move(network_error));
    return result;
  }
  // Construct an instance holding |failed_to_assemble|.
  static ReportStatusPtr
  NewFailedToAssemble(
      EmptyPtr failed_to_assemble) {
    auto result = ReportStatusPtr(absl::in_place);
    result->set_failed_to_assemble(std::move(failed_to_assemble));
    return result;
  }

  template <typename U>
  static ReportStatusPtr From(const U& u) {
    return mojo::TypeConverter<ReportStatusPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, ReportStatus>::Convert(*this);
  }

  ReportStatus();
  ~ReportStatus();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename UnionPtrType = ReportStatusPtr>
  ReportStatusPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T,
            typename std::enable_if<std::is_same<
                T, ReportStatus>::value>::type* = nullptr>
  bool Equals(const T& other) const;

  template <typename T,
            typename std::enable_if<std::is_same<
                T, ReportStatus>::value>::type* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  size_t Hash(size_t seed) const;

  Tag which() const {
    return tag_;
  }


  
  bool is_pending() const { return tag_ == Tag::kPending; }

  
  EmptyPtr& get_pending() const {
    CHECK(tag_ == Tag::kPending);
    return *(data_.pending);
  }

  
  void set_pending(
      EmptyPtr pending);
  
  bool is_replaced_by_higher_priority_report() const { return tag_ == Tag::kReplacedByHigherPriorityReport; }

  
  std::string& get_replaced_by_higher_priority_report() const {
    CHECK(tag_ == Tag::kReplacedByHigherPriorityReport);
    return *(data_.replaced_by_higher_priority_report);
  }

  
  void set_replaced_by_higher_priority_report(
      const std::string& replaced_by_higher_priority_report);
  
  bool is_prohibited_by_browser_policy() const { return tag_ == Tag::kProhibitedByBrowserPolicy; }

  
  EmptyPtr& get_prohibited_by_browser_policy() const {
    CHECK(tag_ == Tag::kProhibitedByBrowserPolicy);
    return *(data_.prohibited_by_browser_policy);
  }

  
  void set_prohibited_by_browser_policy(
      EmptyPtr prohibited_by_browser_policy);
  
  bool is_sent() const { return tag_ == Tag::kSent; }

  
  int32_t get_sent() const {
    CHECK(tag_ == Tag::kSent);
    return data_.sent;
  }

  
  void set_sent(
      int32_t sent);
  
  bool is_network_error() const { return tag_ == Tag::kNetworkError; }

  
  std::string& get_network_error() const {
    CHECK(tag_ == Tag::kNetworkError);
    return *(data_.network_error);
  }

  
  void set_network_error(
      const std::string& network_error);
  
  bool is_failed_to_assemble() const { return tag_ == Tag::kFailedToAssemble; }

  
  EmptyPtr& get_failed_to_assemble() const {
    CHECK(tag_ == Tag::kFailedToAssemble);
    return *(data_.failed_to_assemble);
  }

  
  void set_failed_to_assemble(
      EmptyPtr failed_to_assemble);

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        ReportStatus::DataView>(input);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    return mojo::internal::DeserializeImpl<ReportStatus::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

 private:
  union Union_ {
    Union_() = default;
    ~Union_() = default;
    EmptyPtr* pending;
    std::string* replaced_by_higher_priority_report;
    EmptyPtr* prohibited_by_browser_policy;
    int32_t sent;
    std::string* network_error;
    EmptyPtr* failed_to_assemble;
  };

  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);

  void DestroyActive();
  Tag tag_;
  Union_ data_;
};









class  WebUIReportAggregatableAttributionData {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<WebUIReportAggregatableAttributionData, T>::value>;
  using DataView = WebUIReportAggregatableAttributionDataDataView;
  using Data_ = internal::WebUIReportAggregatableAttributionData_Data;

  template <typename... Args>
  static WebUIReportAggregatableAttributionDataPtr New(Args&&... args) {
    return WebUIReportAggregatableAttributionDataPtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static WebUIReportAggregatableAttributionDataPtr From(const U& u) {
    return mojo::TypeConverter<WebUIReportAggregatableAttributionDataPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, WebUIReportAggregatableAttributionData>::Convert(*this);
  }


  WebUIReportAggregatableAttributionData();

  explicit WebUIReportAggregatableAttributionData(
      std::vector<AggregatableHistogramContributionPtr> contributions);

WebUIReportAggregatableAttributionData(const WebUIReportAggregatableAttributionData&) = delete;
WebUIReportAggregatableAttributionData& operator=(const WebUIReportAggregatableAttributionData&) = delete;

  ~WebUIReportAggregatableAttributionData();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = WebUIReportAggregatableAttributionDataPtr>
  WebUIReportAggregatableAttributionDataPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, WebUIReportAggregatableAttributionData::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, WebUIReportAggregatableAttributionData::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        WebUIReportAggregatableAttributionData::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        WebUIReportAggregatableAttributionData::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::WebUIReportAggregatableAttributionData_UnserializedMessageContext<
            UserType, WebUIReportAggregatableAttributionData::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<WebUIReportAggregatableAttributionData::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return WebUIReportAggregatableAttributionData::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::WebUIReportAggregatableAttributionData_UnserializedMessageContext<
            UserType, WebUIReportAggregatableAttributionData::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<WebUIReportAggregatableAttributionData::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
  std::vector<AggregatableHistogramContributionPtr> contributions;

  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, WebUIReportAggregatableAttributionData::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, WebUIReportAggregatableAttributionData::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, WebUIReportAggregatableAttributionData::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, WebUIReportAggregatableAttributionData::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}






class  WebUIReport {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<WebUIReport, T>::value>;
  using DataView = WebUIReportDataView;
  using Data_ = internal::WebUIReport_Data;

  template <typename... Args>
  static WebUIReportPtr New(Args&&... args) {
    return WebUIReportPtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static WebUIReportPtr From(const U& u) {
    return mojo::TypeConverter<WebUIReportPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, WebUIReport>::Convert(*this);
  }


  WebUIReport();

  WebUIReport(
      const ::content::AttributionReport::Id& id,
      const ::GURL& report_url,
      double trigger_time,
      double report_time,
      const std::string& report_body,
      ReportStatusPtr status,
      WebUIReportDataPtr data);

WebUIReport(const WebUIReport&) = delete;
WebUIReport& operator=(const WebUIReport&) = delete;

  ~WebUIReport();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = WebUIReportPtr>
  WebUIReportPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, WebUIReport::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, WebUIReport::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        WebUIReport::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        WebUIReport::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::WebUIReport_UnserializedMessageContext<
            UserType, WebUIReport::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<WebUIReport::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return WebUIReport::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::WebUIReport_UnserializedMessageContext<
            UserType, WebUIReport::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<WebUIReport::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
  ::content::AttributionReport::Id id;
  
  ::GURL report_url;
  
  double trigger_time;
  
  double report_time;
  
  std::string report_body;
  
  ReportStatusPtr status;
  
  WebUIReportDataPtr data;

  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, WebUIReport::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, WebUIReport::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, WebUIReport::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, WebUIReport::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}






class  WebUISource {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<WebUISource, T>::value>;
  using DataView = WebUISourceDataView;
  using Data_ = internal::WebUISource_Data;
  using Attributability = WebUISource_Attributability;

  template <typename... Args>
  static WebUISourcePtr New(Args&&... args) {
    return WebUISourcePtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static WebUISourcePtr From(const U& u) {
    return mojo::TypeConverter<WebUISourcePtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, WebUISource>::Convert(*this);
  }


  WebUISource();

  WebUISource(
      uint64_t source_event_id,
      const ::url::Origin& source_origin,
      const std::string& attribution_destination,
      const ::url::Origin& reporting_origin,
      double source_time,
      double expiry_time,
      ::content::AttributionSourceType source_type,
      int64_t priority,
      DebugKeyPtr debug_key,
      std::vector<uint64_t> dedup_keys,
      const base::flat_map<std::string, std::vector<std::string>>& filter_data,
      const base::flat_map<std::string, std::string>& aggregation_keys,
      WebUISource::Attributability attributability);

WebUISource(const WebUISource&) = delete;
WebUISource& operator=(const WebUISource&) = delete;

  ~WebUISource();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = WebUISourcePtr>
  WebUISourcePtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, WebUISource::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, WebUISource::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        WebUISource::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        WebUISource::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::WebUISource_UnserializedMessageContext<
            UserType, WebUISource::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<WebUISource::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return WebUISource::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::WebUISource_UnserializedMessageContext<
            UserType, WebUISource::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<WebUISource::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
  uint64_t source_event_id;
  
  ::url::Origin source_origin;
  
  std::string attribution_destination;
  
  ::url::Origin reporting_origin;
  
  double source_time;
  
  double expiry_time;
  
  ::content::AttributionSourceType source_type;
  
  int64_t priority;
  
  DebugKeyPtr debug_key;
  
  std::vector<uint64_t> dedup_keys;
  
  base::flat_map<std::string, std::vector<std::string>> filter_data;
  
  base::flat_map<std::string, std::string> aggregation_keys;
  
  WebUISource::Attributability attributability;

  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, WebUISource::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, WebUISource::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, WebUISource::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, WebUISource::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}






class  WebUIEventTriggerData {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<WebUIEventTriggerData, T>::value>;
  using DataView = WebUIEventTriggerDataDataView;
  using Data_ = internal::WebUIEventTriggerData_Data;

  template <typename... Args>
  static WebUIEventTriggerDataPtr New(Args&&... args) {
    return WebUIEventTriggerDataPtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static WebUIEventTriggerDataPtr From(const U& u) {
    return mojo::TypeConverter<WebUIEventTriggerDataPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, WebUIEventTriggerData>::Convert(*this);
  }


  WebUIEventTriggerData();

  WebUIEventTriggerData(
      uint64_t data,
      int64_t priority,
      DedupKeyPtr dedup_key,
      const base::flat_map<std::string, std::vector<std::string>>& filters,
      const base::flat_map<std::string, std::vector<std::string>>& not_filters);

WebUIEventTriggerData(const WebUIEventTriggerData&) = delete;
WebUIEventTriggerData& operator=(const WebUIEventTriggerData&) = delete;

  ~WebUIEventTriggerData();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = WebUIEventTriggerDataPtr>
  WebUIEventTriggerDataPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, WebUIEventTriggerData::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, WebUIEventTriggerData::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        WebUIEventTriggerData::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        WebUIEventTriggerData::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::WebUIEventTriggerData_UnserializedMessageContext<
            UserType, WebUIEventTriggerData::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<WebUIEventTriggerData::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return WebUIEventTriggerData::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::WebUIEventTriggerData_UnserializedMessageContext<
            UserType, WebUIEventTriggerData::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<WebUIEventTriggerData::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
  uint64_t data;
  
  int64_t priority;
  
  DedupKeyPtr dedup_key;
  
  base::flat_map<std::string, std::vector<std::string>> filters;
  
  base::flat_map<std::string, std::vector<std::string>> not_filters;

  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, WebUIEventTriggerData::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, WebUIEventTriggerData::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, WebUIEventTriggerData::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, WebUIEventTriggerData::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





class  WebUIAggregatableTriggerData {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<WebUIAggregatableTriggerData, T>::value>;
  using DataView = WebUIAggregatableTriggerDataDataView;
  using Data_ = internal::WebUIAggregatableTriggerData_Data;

  template <typename... Args>
  static WebUIAggregatableTriggerDataPtr New(Args&&... args) {
    return WebUIAggregatableTriggerDataPtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static WebUIAggregatableTriggerDataPtr From(const U& u) {
    return mojo::TypeConverter<WebUIAggregatableTriggerDataPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, WebUIAggregatableTriggerData>::Convert(*this);
  }


  WebUIAggregatableTriggerData();

  WebUIAggregatableTriggerData(
      const std::string& key_piece,
      std::vector<std::string> source_keys,
      const base::flat_map<std::string, std::vector<std::string>>& filters,
      const base::flat_map<std::string, std::vector<std::string>>& not_filters);


  ~WebUIAggregatableTriggerData();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = WebUIAggregatableTriggerDataPtr>
  WebUIAggregatableTriggerDataPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, WebUIAggregatableTriggerData::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, WebUIAggregatableTriggerData::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        WebUIAggregatableTriggerData::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        WebUIAggregatableTriggerData::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::WebUIAggregatableTriggerData_UnserializedMessageContext<
            UserType, WebUIAggregatableTriggerData::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<WebUIAggregatableTriggerData::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return WebUIAggregatableTriggerData::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::WebUIAggregatableTriggerData_UnserializedMessageContext<
            UserType, WebUIAggregatableTriggerData::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<WebUIAggregatableTriggerData::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
  std::string key_piece;
  
  std::vector<std::string> source_keys;
  
  base::flat_map<std::string, std::vector<std::string>> filters;
  
  base::flat_map<std::string, std::vector<std::string>> not_filters;

  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, WebUIAggregatableTriggerData::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, WebUIAggregatableTriggerData::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, WebUIAggregatableTriggerData::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, WebUIAggregatableTriggerData::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





class  WebUITrigger {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<WebUITrigger, T>::value>;
  using DataView = WebUITriggerDataView;
  using Data_ = internal::WebUITrigger_Data;
  using Status = WebUITrigger_Status;

  template <typename... Args>
  static WebUITriggerPtr New(Args&&... args) {
    return WebUITriggerPtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static WebUITriggerPtr From(const U& u) {
    return mojo::TypeConverter<WebUITriggerPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, WebUITrigger>::Convert(*this);
  }


  WebUITrigger();

  WebUITrigger(
      double trigger_time,
      const ::url::Origin& destination_origin,
      const ::url::Origin& reporting_origin,
      const base::flat_map<std::string, std::vector<std::string>>& filters,
      const base::flat_map<std::string, std::vector<std::string>>& not_filters,
      DebugKeyPtr debug_key,
      std::vector<WebUIEventTriggerDataPtr> event_triggers,
      std::vector<WebUIAggregatableTriggerDataPtr> aggregatable_triggers,
      const base::flat_map<std::string, uint32_t>& aggregatable_values,
      WebUITrigger::Status event_level_status,
      WebUITrigger::Status aggregatable_status);

WebUITrigger(const WebUITrigger&) = delete;
WebUITrigger& operator=(const WebUITrigger&) = delete;

  ~WebUITrigger();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = WebUITriggerPtr>
  WebUITriggerPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, WebUITrigger::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, WebUITrigger::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        WebUITrigger::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        WebUITrigger::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::WebUITrigger_UnserializedMessageContext<
            UserType, WebUITrigger::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<WebUITrigger::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return WebUITrigger::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::WebUITrigger_UnserializedMessageContext<
            UserType, WebUITrigger::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<WebUITrigger::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
  double trigger_time;
  
  ::url::Origin destination_origin;
  
  ::url::Origin reporting_origin;
  
  base::flat_map<std::string, std::vector<std::string>> filters;
  
  base::flat_map<std::string, std::vector<std::string>> not_filters;
  
  DebugKeyPtr debug_key;
  
  std::vector<WebUIEventTriggerDataPtr> event_triggers;
  
  std::vector<WebUIAggregatableTriggerDataPtr> aggregatable_triggers;
  
  base::flat_map<std::string, uint32_t> aggregatable_values;
  
  WebUITrigger::Status event_level_status;
  
  WebUITrigger::Status aggregatable_status;

  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, WebUITrigger::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, WebUITrigger::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, WebUITrigger::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, WebUITrigger::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}

template <typename UnionPtrType>
ReportIDPtr ReportID::Clone() const {
  switch (tag_) {
    case Tag::kEventLevelId:
      return NewEventLevelId(
          mojo::Clone(*data_.event_level_id));
    case Tag::kAggregatableAttributionId:
      return NewAggregatableAttributionId(
          mojo::Clone(*data_.aggregatable_attribution_id));
  }
  return nullptr;
}

template <typename T,
          typename std::enable_if<std::is_same<
              T, ReportID>::value>::type*>
bool ReportID::Equals(const T& other) const {
  if (tag_ != other.which())
    return false;

  switch (tag_) {
    case Tag::kEventLevelId:
      return mojo::Equals(*(data_.event_level_id), *(other.data_.event_level_id));
    case Tag::kAggregatableAttributionId:
      return mojo::Equals(*(data_.aggregatable_attribution_id), *(other.data_.aggregatable_attribution_id));
  }

  return false;
}
template <typename UnionPtrType>
WebUIReportDataPtr WebUIReportData::Clone() const {
  switch (tag_) {
    case Tag::kEventLevelData:
      return NewEventLevelData(
          mojo::Clone(*data_.event_level_data));
    case Tag::kAggregatableAttributionData:
      return NewAggregatableAttributionData(
          mojo::Clone(*data_.aggregatable_attribution_data));
  }
  return nullptr;
}

template <typename T,
          typename std::enable_if<std::is_same<
              T, WebUIReportData>::value>::type*>
bool WebUIReportData::Equals(const T& other) const {
  if (tag_ != other.which())
    return false;

  switch (tag_) {
    case Tag::kEventLevelData:
      return mojo::Equals(*(data_.event_level_data), *(other.data_.event_level_data));
    case Tag::kAggregatableAttributionData:
      return mojo::Equals(*(data_.aggregatable_attribution_data), *(other.data_.aggregatable_attribution_data));
  }

  return false;
}
template <typename UnionPtrType>
ReportStatusPtr ReportStatus::Clone() const {
  switch (tag_) {
    case Tag::kPending:
      return NewPending(
          mojo::Clone(*data_.pending));
    case Tag::kReplacedByHigherPriorityReport:
      return NewReplacedByHigherPriorityReport(
          mojo::Clone(*data_.replaced_by_higher_priority_report));
    case Tag::kProhibitedByBrowserPolicy:
      return NewProhibitedByBrowserPolicy(
          mojo::Clone(*data_.prohibited_by_browser_policy));
    case Tag::kSent:
      return NewSent(
          mojo::Clone(data_.sent));
    case Tag::kNetworkError:
      return NewNetworkError(
          mojo::Clone(*data_.network_error));
    case Tag::kFailedToAssemble:
      return NewFailedToAssemble(
          mojo::Clone(*data_.failed_to_assemble));
  }
  return nullptr;
}

template <typename T,
          typename std::enable_if<std::is_same<
              T, ReportStatus>::value>::type*>
bool ReportStatus::Equals(const T& other) const {
  if (tag_ != other.which())
    return false;

  switch (tag_) {
    case Tag::kPending:
      return mojo::Equals(*(data_.pending), *(other.data_.pending));
    case Tag::kReplacedByHigherPriorityReport:
      return mojo::Equals(*(data_.replaced_by_higher_priority_report), *(other.data_.replaced_by_higher_priority_report));
    case Tag::kProhibitedByBrowserPolicy:
      return mojo::Equals(*(data_.prohibited_by_browser_policy), *(other.data_.prohibited_by_browser_policy));
    case Tag::kSent:
      return mojo::Equals(data_.sent, other.data_.sent);
    case Tag::kNetworkError:
      return mojo::Equals(*(data_.network_error), *(other.data_.network_error));
    case Tag::kFailedToAssemble:
      return mojo::Equals(*(data_.failed_to_assemble), *(other.data_.failed_to_assemble));
  }

  return false;
}
template <typename StructPtrType>
EventLevelReportIDPtr EventLevelReportID::Clone() const {
  return New(
      mojo::Clone(value)
  );
}

template <typename T, EventLevelReportID::EnableIfSame<T>*>
bool EventLevelReportID::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->value, other_struct.value))
    return false;
  return true;
}

template <typename T, EventLevelReportID::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.value < rhs.value)
    return true;
  if (rhs.value < lhs.value)
    return false;
  return false;
}
template <typename StructPtrType>
AggregatableAttributionReportIDPtr AggregatableAttributionReportID::Clone() const {
  return New(
      mojo::Clone(value)
  );
}

template <typename T, AggregatableAttributionReportID::EnableIfSame<T>*>
bool AggregatableAttributionReportID::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->value, other_struct.value))
    return false;
  return true;
}

template <typename T, AggregatableAttributionReportID::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.value < rhs.value)
    return true;
  if (rhs.value < lhs.value)
    return false;
  return false;
}
template <typename StructPtrType>
WebUIReportEventLevelDataPtr WebUIReportEventLevelData::Clone() const {
  return New(
      mojo::Clone(priority),
      mojo::Clone(attributed_truthfully)
  );
}

template <typename T, WebUIReportEventLevelData::EnableIfSame<T>*>
bool WebUIReportEventLevelData::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->priority, other_struct.priority))
    return false;
  if (!mojo::Equals(this->attributed_truthfully, other_struct.attributed_truthfully))
    return false;
  return true;
}

template <typename T, WebUIReportEventLevelData::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.priority < rhs.priority)
    return true;
  if (rhs.priority < lhs.priority)
    return false;
  if (lhs.attributed_truthfully < rhs.attributed_truthfully)
    return true;
  if (rhs.attributed_truthfully < lhs.attributed_truthfully)
    return false;
  return false;
}
template <typename StructPtrType>
AggregatableHistogramContributionPtr AggregatableHistogramContribution::Clone() const {
  return New(
      mojo::Clone(key),
      mojo::Clone(value)
  );
}

template <typename T, AggregatableHistogramContribution::EnableIfSame<T>*>
bool AggregatableHistogramContribution::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->key, other_struct.key))
    return false;
  if (!mojo::Equals(this->value, other_struct.value))
    return false;
  return true;
}

template <typename T, AggregatableHistogramContribution::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.key < rhs.key)
    return true;
  if (rhs.key < lhs.key)
    return false;
  if (lhs.value < rhs.value)
    return true;
  if (rhs.value < lhs.value)
    return false;
  return false;
}
template <typename StructPtrType>
WebUIReportAggregatableAttributionDataPtr WebUIReportAggregatableAttributionData::Clone() const {
  return New(
      mojo::Clone(contributions)
  );
}

template <typename T, WebUIReportAggregatableAttributionData::EnableIfSame<T>*>
bool WebUIReportAggregatableAttributionData::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->contributions, other_struct.contributions))
    return false;
  return true;
}

template <typename T, WebUIReportAggregatableAttributionData::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.contributions < rhs.contributions)
    return true;
  if (rhs.contributions < lhs.contributions)
    return false;
  return false;
}
template <typename StructPtrType>
EmptyPtr Empty::Clone() const {
  return New(
  );
}

template <typename T, Empty::EnableIfSame<T>*>
bool Empty::Equals(const T& other_struct) const {
  return true;
}

template <typename T, Empty::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  return false;
}
template <typename StructPtrType>
WebUIReportPtr WebUIReport::Clone() const {
  return New(
      mojo::Clone(id),
      mojo::Clone(report_url),
      mojo::Clone(trigger_time),
      mojo::Clone(report_time),
      mojo::Clone(report_body),
      mojo::Clone(status),
      mojo::Clone(data)
  );
}

template <typename T, WebUIReport::EnableIfSame<T>*>
bool WebUIReport::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->id, other_struct.id))
    return false;
  if (!mojo::Equals(this->report_url, other_struct.report_url))
    return false;
  if (!mojo::Equals(this->trigger_time, other_struct.trigger_time))
    return false;
  if (!mojo::Equals(this->report_time, other_struct.report_time))
    return false;
  if (!mojo::Equals(this->report_body, other_struct.report_body))
    return false;
  if (!mojo::Equals(this->status, other_struct.status))
    return false;
  if (!mojo::Equals(this->data, other_struct.data))
    return false;
  return true;
}

template <typename T, WebUIReport::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.id < rhs.id)
    return true;
  if (rhs.id < lhs.id)
    return false;
  if (lhs.report_url < rhs.report_url)
    return true;
  if (rhs.report_url < lhs.report_url)
    return false;
  if (lhs.trigger_time < rhs.trigger_time)
    return true;
  if (rhs.trigger_time < lhs.trigger_time)
    return false;
  if (lhs.report_time < rhs.report_time)
    return true;
  if (rhs.report_time < lhs.report_time)
    return false;
  if (lhs.report_body < rhs.report_body)
    return true;
  if (rhs.report_body < lhs.report_body)
    return false;
  if (lhs.status < rhs.status)
    return true;
  if (rhs.status < lhs.status)
    return false;
  if (lhs.data < rhs.data)
    return true;
  if (rhs.data < lhs.data)
    return false;
  return false;
}
template <typename StructPtrType>
DebugKeyPtr DebugKey::Clone() const {
  return New(
      mojo::Clone(value)
  );
}

template <typename T, DebugKey::EnableIfSame<T>*>
bool DebugKey::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->value, other_struct.value))
    return false;
  return true;
}

template <typename T, DebugKey::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.value < rhs.value)
    return true;
  if (rhs.value < lhs.value)
    return false;
  return false;
}
template <typename StructPtrType>
WebUISourcePtr WebUISource::Clone() const {
  return New(
      mojo::Clone(source_event_id),
      mojo::Clone(source_origin),
      mojo::Clone(attribution_destination),
      mojo::Clone(reporting_origin),
      mojo::Clone(source_time),
      mojo::Clone(expiry_time),
      mojo::Clone(source_type),
      mojo::Clone(priority),
      mojo::Clone(debug_key),
      mojo::Clone(dedup_keys),
      mojo::Clone(filter_data),
      mojo::Clone(aggregation_keys),
      mojo::Clone(attributability)
  );
}

template <typename T, WebUISource::EnableIfSame<T>*>
bool WebUISource::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->source_event_id, other_struct.source_event_id))
    return false;
  if (!mojo::Equals(this->source_origin, other_struct.source_origin))
    return false;
  if (!mojo::Equals(this->attribution_destination, other_struct.attribution_destination))
    return false;
  if (!mojo::Equals(this->reporting_origin, other_struct.reporting_origin))
    return false;
  if (!mojo::Equals(this->source_time, other_struct.source_time))
    return false;
  if (!mojo::Equals(this->expiry_time, other_struct.expiry_time))
    return false;
  if (!mojo::Equals(this->source_type, other_struct.source_type))
    return false;
  if (!mojo::Equals(this->priority, other_struct.priority))
    return false;
  if (!mojo::Equals(this->debug_key, other_struct.debug_key))
    return false;
  if (!mojo::Equals(this->dedup_keys, other_struct.dedup_keys))
    return false;
  if (!mojo::Equals(this->filter_data, other_struct.filter_data))
    return false;
  if (!mojo::Equals(this->aggregation_keys, other_struct.aggregation_keys))
    return false;
  if (!mojo::Equals(this->attributability, other_struct.attributability))
    return false;
  return true;
}

template <typename T, WebUISource::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.source_event_id < rhs.source_event_id)
    return true;
  if (rhs.source_event_id < lhs.source_event_id)
    return false;
  if (lhs.source_origin < rhs.source_origin)
    return true;
  if (rhs.source_origin < lhs.source_origin)
    return false;
  if (lhs.attribution_destination < rhs.attribution_destination)
    return true;
  if (rhs.attribution_destination < lhs.attribution_destination)
    return false;
  if (lhs.reporting_origin < rhs.reporting_origin)
    return true;
  if (rhs.reporting_origin < lhs.reporting_origin)
    return false;
  if (lhs.source_time < rhs.source_time)
    return true;
  if (rhs.source_time < lhs.source_time)
    return false;
  if (lhs.expiry_time < rhs.expiry_time)
    return true;
  if (rhs.expiry_time < lhs.expiry_time)
    return false;
  if (lhs.source_type < rhs.source_type)
    return true;
  if (rhs.source_type < lhs.source_type)
    return false;
  if (lhs.priority < rhs.priority)
    return true;
  if (rhs.priority < lhs.priority)
    return false;
  if (lhs.debug_key < rhs.debug_key)
    return true;
  if (rhs.debug_key < lhs.debug_key)
    return false;
  if (lhs.dedup_keys < rhs.dedup_keys)
    return true;
  if (rhs.dedup_keys < lhs.dedup_keys)
    return false;
  if (lhs.filter_data < rhs.filter_data)
    return true;
  if (rhs.filter_data < lhs.filter_data)
    return false;
  if (lhs.aggregation_keys < rhs.aggregation_keys)
    return true;
  if (rhs.aggregation_keys < lhs.aggregation_keys)
    return false;
  if (lhs.attributability < rhs.attributability)
    return true;
  if (rhs.attributability < lhs.attributability)
    return false;
  return false;
}
template <typename StructPtrType>
DedupKeyPtr DedupKey::Clone() const {
  return New(
      mojo::Clone(value)
  );
}

template <typename T, DedupKey::EnableIfSame<T>*>
bool DedupKey::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->value, other_struct.value))
    return false;
  return true;
}

template <typename T, DedupKey::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.value < rhs.value)
    return true;
  if (rhs.value < lhs.value)
    return false;
  return false;
}
template <typename StructPtrType>
WebUIEventTriggerDataPtr WebUIEventTriggerData::Clone() const {
  return New(
      mojo::Clone(data),
      mojo::Clone(priority),
      mojo::Clone(dedup_key),
      mojo::Clone(filters),
      mojo::Clone(not_filters)
  );
}

template <typename T, WebUIEventTriggerData::EnableIfSame<T>*>
bool WebUIEventTriggerData::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->data, other_struct.data))
    return false;
  if (!mojo::Equals(this->priority, other_struct.priority))
    return false;
  if (!mojo::Equals(this->dedup_key, other_struct.dedup_key))
    return false;
  if (!mojo::Equals(this->filters, other_struct.filters))
    return false;
  if (!mojo::Equals(this->not_filters, other_struct.not_filters))
    return false;
  return true;
}

template <typename T, WebUIEventTriggerData::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.data < rhs.data)
    return true;
  if (rhs.data < lhs.data)
    return false;
  if (lhs.priority < rhs.priority)
    return true;
  if (rhs.priority < lhs.priority)
    return false;
  if (lhs.dedup_key < rhs.dedup_key)
    return true;
  if (rhs.dedup_key < lhs.dedup_key)
    return false;
  if (lhs.filters < rhs.filters)
    return true;
  if (rhs.filters < lhs.filters)
    return false;
  if (lhs.not_filters < rhs.not_filters)
    return true;
  if (rhs.not_filters < lhs.not_filters)
    return false;
  return false;
}
template <typename StructPtrType>
WebUIAggregatableTriggerDataPtr WebUIAggregatableTriggerData::Clone() const {
  return New(
      mojo::Clone(key_piece),
      mojo::Clone(source_keys),
      mojo::Clone(filters),
      mojo::Clone(not_filters)
  );
}

template <typename T, WebUIAggregatableTriggerData::EnableIfSame<T>*>
bool WebUIAggregatableTriggerData::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->key_piece, other_struct.key_piece))
    return false;
  if (!mojo::Equals(this->source_keys, other_struct.source_keys))
    return false;
  if (!mojo::Equals(this->filters, other_struct.filters))
    return false;
  if (!mojo::Equals(this->not_filters, other_struct.not_filters))
    return false;
  return true;
}

template <typename T, WebUIAggregatableTriggerData::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.key_piece < rhs.key_piece)
    return true;
  if (rhs.key_piece < lhs.key_piece)
    return false;
  if (lhs.source_keys < rhs.source_keys)
    return true;
  if (rhs.source_keys < lhs.source_keys)
    return false;
  if (lhs.filters < rhs.filters)
    return true;
  if (rhs.filters < lhs.filters)
    return false;
  if (lhs.not_filters < rhs.not_filters)
    return true;
  if (rhs.not_filters < lhs.not_filters)
    return false;
  return false;
}
template <typename StructPtrType>
WebUITriggerPtr WebUITrigger::Clone() const {
  return New(
      mojo::Clone(trigger_time),
      mojo::Clone(destination_origin),
      mojo::Clone(reporting_origin),
      mojo::Clone(filters),
      mojo::Clone(not_filters),
      mojo::Clone(debug_key),
      mojo::Clone(event_triggers),
      mojo::Clone(aggregatable_triggers),
      mojo::Clone(aggregatable_values),
      mojo::Clone(event_level_status),
      mojo::Clone(aggregatable_status)
  );
}

template <typename T, WebUITrigger::EnableIfSame<T>*>
bool WebUITrigger::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->trigger_time, other_struct.trigger_time))
    return false;
  if (!mojo::Equals(this->destination_origin, other_struct.destination_origin))
    return false;
  if (!mojo::Equals(this->reporting_origin, other_struct.reporting_origin))
    return false;
  if (!mojo::Equals(this->filters, other_struct.filters))
    return false;
  if (!mojo::Equals(this->not_filters, other_struct.not_filters))
    return false;
  if (!mojo::Equals(this->debug_key, other_struct.debug_key))
    return false;
  if (!mojo::Equals(this->event_triggers, other_struct.event_triggers))
    return false;
  if (!mojo::Equals(this->aggregatable_triggers, other_struct.aggregatable_triggers))
    return false;
  if (!mojo::Equals(this->aggregatable_values, other_struct.aggregatable_values))
    return false;
  if (!mojo::Equals(this->event_level_status, other_struct.event_level_status))
    return false;
  if (!mojo::Equals(this->aggregatable_status, other_struct.aggregatable_status))
    return false;
  return true;
}

template <typename T, WebUITrigger::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.trigger_time < rhs.trigger_time)
    return true;
  if (rhs.trigger_time < lhs.trigger_time)
    return false;
  if (lhs.destination_origin < rhs.destination_origin)
    return true;
  if (rhs.destination_origin < lhs.destination_origin)
    return false;
  if (lhs.reporting_origin < rhs.reporting_origin)
    return true;
  if (rhs.reporting_origin < lhs.reporting_origin)
    return false;
  if (lhs.filters < rhs.filters)
    return true;
  if (rhs.filters < lhs.filters)
    return false;
  if (lhs.not_filters < rhs.not_filters)
    return true;
  if (rhs.not_filters < lhs.not_filters)
    return false;
  if (lhs.debug_key < rhs.debug_key)
    return true;
  if (rhs.debug_key < lhs.debug_key)
    return false;
  if (lhs.event_triggers < rhs.event_triggers)
    return true;
  if (rhs.event_triggers < lhs.event_triggers)
    return false;
  if (lhs.aggregatable_triggers < rhs.aggregatable_triggers)
    return true;
  if (rhs.aggregatable_triggers < lhs.aggregatable_triggers)
    return false;
  if (lhs.aggregatable_values < rhs.aggregatable_values)
    return true;
  if (rhs.aggregatable_values < lhs.aggregatable_values)
    return false;
  if (lhs.event_level_status < rhs.event_level_status)
    return true;
  if (rhs.event_level_status < lhs.event_level_status)
    return false;
  if (lhs.aggregatable_status < rhs.aggregatable_status)
    return true;
  if (rhs.aggregatable_status < lhs.aggregatable_status)
    return false;
  return false;
}


}  // namespace mojom
}  // namespace attribution_internals

namespace mojo {


template <>
struct  StructTraits<::attribution_internals::mojom::EventLevelReportID::DataView,
                                         ::attribution_internals::mojom::EventLevelReportIDPtr> {
  static bool IsNull(const ::attribution_internals::mojom::EventLevelReportIDPtr& input) { return !input; }
  static void SetToNull(::attribution_internals::mojom::EventLevelReportIDPtr* output) { output->reset(); }

  static decltype(::attribution_internals::mojom::EventLevelReportID::value) value(
      const ::attribution_internals::mojom::EventLevelReportIDPtr& input) {
    return input->value;
  }

  static bool Read(::attribution_internals::mojom::EventLevelReportID::DataView input, ::attribution_internals::mojom::EventLevelReportIDPtr* output);
};


template <>
struct  StructTraits<::attribution_internals::mojom::AggregatableAttributionReportID::DataView,
                                         ::attribution_internals::mojom::AggregatableAttributionReportIDPtr> {
  static bool IsNull(const ::attribution_internals::mojom::AggregatableAttributionReportIDPtr& input) { return !input; }
  static void SetToNull(::attribution_internals::mojom::AggregatableAttributionReportIDPtr* output) { output->reset(); }

  static decltype(::attribution_internals::mojom::AggregatableAttributionReportID::value) value(
      const ::attribution_internals::mojom::AggregatableAttributionReportIDPtr& input) {
    return input->value;
  }

  static bool Read(::attribution_internals::mojom::AggregatableAttributionReportID::DataView input, ::attribution_internals::mojom::AggregatableAttributionReportIDPtr* output);
};


template <>
struct  StructTraits<::attribution_internals::mojom::WebUIReportEventLevelData::DataView,
                                         ::attribution_internals::mojom::WebUIReportEventLevelDataPtr> {
  static bool IsNull(const ::attribution_internals::mojom::WebUIReportEventLevelDataPtr& input) { return !input; }
  static void SetToNull(::attribution_internals::mojom::WebUIReportEventLevelDataPtr* output) { output->reset(); }

  static decltype(::attribution_internals::mojom::WebUIReportEventLevelData::priority) priority(
      const ::attribution_internals::mojom::WebUIReportEventLevelDataPtr& input) {
    return input->priority;
  }

  static decltype(::attribution_internals::mojom::WebUIReportEventLevelData::attributed_truthfully) attributed_truthfully(
      const ::attribution_internals::mojom::WebUIReportEventLevelDataPtr& input) {
    return input->attributed_truthfully;
  }

  static bool Read(::attribution_internals::mojom::WebUIReportEventLevelData::DataView input, ::attribution_internals::mojom::WebUIReportEventLevelDataPtr* output);
};


template <>
struct  StructTraits<::attribution_internals::mojom::AggregatableHistogramContribution::DataView,
                                         ::attribution_internals::mojom::AggregatableHistogramContributionPtr> {
  static bool IsNull(const ::attribution_internals::mojom::AggregatableHistogramContributionPtr& input) { return !input; }
  static void SetToNull(::attribution_internals::mojom::AggregatableHistogramContributionPtr* output) { output->reset(); }

  static const decltype(::attribution_internals::mojom::AggregatableHistogramContribution::key)& key(
      const ::attribution_internals::mojom::AggregatableHistogramContributionPtr& input) {
    return input->key;
  }

  static decltype(::attribution_internals::mojom::AggregatableHistogramContribution::value) value(
      const ::attribution_internals::mojom::AggregatableHistogramContributionPtr& input) {
    return input->value;
  }

  static bool Read(::attribution_internals::mojom::AggregatableHistogramContribution::DataView input, ::attribution_internals::mojom::AggregatableHistogramContributionPtr* output);
};


template <>
struct  StructTraits<::attribution_internals::mojom::WebUIReportAggregatableAttributionData::DataView,
                                         ::attribution_internals::mojom::WebUIReportAggregatableAttributionDataPtr> {
  static bool IsNull(const ::attribution_internals::mojom::WebUIReportAggregatableAttributionDataPtr& input) { return !input; }
  static void SetToNull(::attribution_internals::mojom::WebUIReportAggregatableAttributionDataPtr* output) { output->reset(); }

  static const decltype(::attribution_internals::mojom::WebUIReportAggregatableAttributionData::contributions)& contributions(
      const ::attribution_internals::mojom::WebUIReportAggregatableAttributionDataPtr& input) {
    return input->contributions;
  }

  static bool Read(::attribution_internals::mojom::WebUIReportAggregatableAttributionData::DataView input, ::attribution_internals::mojom::WebUIReportAggregatableAttributionDataPtr* output);
};


template <>
struct  StructTraits<::attribution_internals::mojom::Empty::DataView,
                                         ::attribution_internals::mojom::EmptyPtr> {
  static bool IsNull(const ::attribution_internals::mojom::EmptyPtr& input) { return !input; }
  static void SetToNull(::attribution_internals::mojom::EmptyPtr* output) { output->reset(); }

  static bool Read(::attribution_internals::mojom::Empty::DataView input, ::attribution_internals::mojom::EmptyPtr* output);
};


template <>
struct  StructTraits<::attribution_internals::mojom::WebUIReport::DataView,
                                         ::attribution_internals::mojom::WebUIReportPtr> {
  static bool IsNull(const ::attribution_internals::mojom::WebUIReportPtr& input) { return !input; }
  static void SetToNull(::attribution_internals::mojom::WebUIReportPtr* output) { output->reset(); }

  static const decltype(::attribution_internals::mojom::WebUIReport::id)& id(
      const ::attribution_internals::mojom::WebUIReportPtr& input) {
    return input->id;
  }

  static const decltype(::attribution_internals::mojom::WebUIReport::report_url)& report_url(
      const ::attribution_internals::mojom::WebUIReportPtr& input) {
    return input->report_url;
  }

  static decltype(::attribution_internals::mojom::WebUIReport::trigger_time) trigger_time(
      const ::attribution_internals::mojom::WebUIReportPtr& input) {
    return input->trigger_time;
  }

  static decltype(::attribution_internals::mojom::WebUIReport::report_time) report_time(
      const ::attribution_internals::mojom::WebUIReportPtr& input) {
    return input->report_time;
  }

  static const decltype(::attribution_internals::mojom::WebUIReport::report_body)& report_body(
      const ::attribution_internals::mojom::WebUIReportPtr& input) {
    return input->report_body;
  }

  static const decltype(::attribution_internals::mojom::WebUIReport::status)& status(
      const ::attribution_internals::mojom::WebUIReportPtr& input) {
    return input->status;
  }

  static const decltype(::attribution_internals::mojom::WebUIReport::data)& data(
      const ::attribution_internals::mojom::WebUIReportPtr& input) {
    return input->data;
  }

  static bool Read(::attribution_internals::mojom::WebUIReport::DataView input, ::attribution_internals::mojom::WebUIReportPtr* output);
};


template <>
struct  StructTraits<::attribution_internals::mojom::DebugKey::DataView,
                                         ::attribution_internals::mojom::DebugKeyPtr> {
  static bool IsNull(const ::attribution_internals::mojom::DebugKeyPtr& input) { return !input; }
  static void SetToNull(::attribution_internals::mojom::DebugKeyPtr* output) { output->reset(); }

  static decltype(::attribution_internals::mojom::DebugKey::value) value(
      const ::attribution_internals::mojom::DebugKeyPtr& input) {
    return input->value;
  }

  static bool Read(::attribution_internals::mojom::DebugKey::DataView input, ::attribution_internals::mojom::DebugKeyPtr* output);
};


template <>
struct  StructTraits<::attribution_internals::mojom::WebUISource::DataView,
                                         ::attribution_internals::mojom::WebUISourcePtr> {
  static bool IsNull(const ::attribution_internals::mojom::WebUISourcePtr& input) { return !input; }
  static void SetToNull(::attribution_internals::mojom::WebUISourcePtr* output) { output->reset(); }

  static decltype(::attribution_internals::mojom::WebUISource::source_event_id) source_event_id(
      const ::attribution_internals::mojom::WebUISourcePtr& input) {
    return input->source_event_id;
  }

  static const decltype(::attribution_internals::mojom::WebUISource::source_origin)& source_origin(
      const ::attribution_internals::mojom::WebUISourcePtr& input) {
    return input->source_origin;
  }

  static const decltype(::attribution_internals::mojom::WebUISource::attribution_destination)& attribution_destination(
      const ::attribution_internals::mojom::WebUISourcePtr& input) {
    return input->attribution_destination;
  }

  static const decltype(::attribution_internals::mojom::WebUISource::reporting_origin)& reporting_origin(
      const ::attribution_internals::mojom::WebUISourcePtr& input) {
    return input->reporting_origin;
  }

  static decltype(::attribution_internals::mojom::WebUISource::source_time) source_time(
      const ::attribution_internals::mojom::WebUISourcePtr& input) {
    return input->source_time;
  }

  static decltype(::attribution_internals::mojom::WebUISource::expiry_time) expiry_time(
      const ::attribution_internals::mojom::WebUISourcePtr& input) {
    return input->expiry_time;
  }

  static decltype(::attribution_internals::mojom::WebUISource::source_type) source_type(
      const ::attribution_internals::mojom::WebUISourcePtr& input) {
    return input->source_type;
  }

  static decltype(::attribution_internals::mojom::WebUISource::priority) priority(
      const ::attribution_internals::mojom::WebUISourcePtr& input) {
    return input->priority;
  }

  static const decltype(::attribution_internals::mojom::WebUISource::debug_key)& debug_key(
      const ::attribution_internals::mojom::WebUISourcePtr& input) {
    return input->debug_key;
  }

  static const decltype(::attribution_internals::mojom::WebUISource::dedup_keys)& dedup_keys(
      const ::attribution_internals::mojom::WebUISourcePtr& input) {
    return input->dedup_keys;
  }

  static const decltype(::attribution_internals::mojom::WebUISource::filter_data)& filter_data(
      const ::attribution_internals::mojom::WebUISourcePtr& input) {
    return input->filter_data;
  }

  static const decltype(::attribution_internals::mojom::WebUISource::aggregation_keys)& aggregation_keys(
      const ::attribution_internals::mojom::WebUISourcePtr& input) {
    return input->aggregation_keys;
  }

  static decltype(::attribution_internals::mojom::WebUISource::attributability) attributability(
      const ::attribution_internals::mojom::WebUISourcePtr& input) {
    return input->attributability;
  }

  static bool Read(::attribution_internals::mojom::WebUISource::DataView input, ::attribution_internals::mojom::WebUISourcePtr* output);
};


template <>
struct  StructTraits<::attribution_internals::mojom::DedupKey::DataView,
                                         ::attribution_internals::mojom::DedupKeyPtr> {
  static bool IsNull(const ::attribution_internals::mojom::DedupKeyPtr& input) { return !input; }
  static void SetToNull(::attribution_internals::mojom::DedupKeyPtr* output) { output->reset(); }

  static decltype(::attribution_internals::mojom::DedupKey::value) value(
      const ::attribution_internals::mojom::DedupKeyPtr& input) {
    return input->value;
  }

  static bool Read(::attribution_internals::mojom::DedupKey::DataView input, ::attribution_internals::mojom::DedupKeyPtr* output);
};


template <>
struct  StructTraits<::attribution_internals::mojom::WebUIEventTriggerData::DataView,
                                         ::attribution_internals::mojom::WebUIEventTriggerDataPtr> {
  static bool IsNull(const ::attribution_internals::mojom::WebUIEventTriggerDataPtr& input) { return !input; }
  static void SetToNull(::attribution_internals::mojom::WebUIEventTriggerDataPtr* output) { output->reset(); }

  static decltype(::attribution_internals::mojom::WebUIEventTriggerData::data) data(
      const ::attribution_internals::mojom::WebUIEventTriggerDataPtr& input) {
    return input->data;
  }

  static decltype(::attribution_internals::mojom::WebUIEventTriggerData::priority) priority(
      const ::attribution_internals::mojom::WebUIEventTriggerDataPtr& input) {
    return input->priority;
  }

  static const decltype(::attribution_internals::mojom::WebUIEventTriggerData::dedup_key)& dedup_key(
      const ::attribution_internals::mojom::WebUIEventTriggerDataPtr& input) {
    return input->dedup_key;
  }

  static const decltype(::attribution_internals::mojom::WebUIEventTriggerData::filters)& filters(
      const ::attribution_internals::mojom::WebUIEventTriggerDataPtr& input) {
    return input->filters;
  }

  static const decltype(::attribution_internals::mojom::WebUIEventTriggerData::not_filters)& not_filters(
      const ::attribution_internals::mojom::WebUIEventTriggerDataPtr& input) {
    return input->not_filters;
  }

  static bool Read(::attribution_internals::mojom::WebUIEventTriggerData::DataView input, ::attribution_internals::mojom::WebUIEventTriggerDataPtr* output);
};


template <>
struct  StructTraits<::attribution_internals::mojom::WebUIAggregatableTriggerData::DataView,
                                         ::attribution_internals::mojom::WebUIAggregatableTriggerDataPtr> {
  static bool IsNull(const ::attribution_internals::mojom::WebUIAggregatableTriggerDataPtr& input) { return !input; }
  static void SetToNull(::attribution_internals::mojom::WebUIAggregatableTriggerDataPtr* output) { output->reset(); }

  static const decltype(::attribution_internals::mojom::WebUIAggregatableTriggerData::key_piece)& key_piece(
      const ::attribution_internals::mojom::WebUIAggregatableTriggerDataPtr& input) {
    return input->key_piece;
  }

  static const decltype(::attribution_internals::mojom::WebUIAggregatableTriggerData::source_keys)& source_keys(
      const ::attribution_internals::mojom::WebUIAggregatableTriggerDataPtr& input) {
    return input->source_keys;
  }

  static const decltype(::attribution_internals::mojom::WebUIAggregatableTriggerData::filters)& filters(
      const ::attribution_internals::mojom::WebUIAggregatableTriggerDataPtr& input) {
    return input->filters;
  }

  static const decltype(::attribution_internals::mojom::WebUIAggregatableTriggerData::not_filters)& not_filters(
      const ::attribution_internals::mojom::WebUIAggregatableTriggerDataPtr& input) {
    return input->not_filters;
  }

  static bool Read(::attribution_internals::mojom::WebUIAggregatableTriggerData::DataView input, ::attribution_internals::mojom::WebUIAggregatableTriggerDataPtr* output);
};


template <>
struct  StructTraits<::attribution_internals::mojom::WebUITrigger::DataView,
                                         ::attribution_internals::mojom::WebUITriggerPtr> {
  static bool IsNull(const ::attribution_internals::mojom::WebUITriggerPtr& input) { return !input; }
  static void SetToNull(::attribution_internals::mojom::WebUITriggerPtr* output) { output->reset(); }

  static decltype(::attribution_internals::mojom::WebUITrigger::trigger_time) trigger_time(
      const ::attribution_internals::mojom::WebUITriggerPtr& input) {
    return input->trigger_time;
  }

  static const decltype(::attribution_internals::mojom::WebUITrigger::destination_origin)& destination_origin(
      const ::attribution_internals::mojom::WebUITriggerPtr& input) {
    return input->destination_origin;
  }

  static const decltype(::attribution_internals::mojom::WebUITrigger::reporting_origin)& reporting_origin(
      const ::attribution_internals::mojom::WebUITriggerPtr& input) {
    return input->reporting_origin;
  }

  static const decltype(::attribution_internals::mojom::WebUITrigger::filters)& filters(
      const ::attribution_internals::mojom::WebUITriggerPtr& input) {
    return input->filters;
  }

  static const decltype(::attribution_internals::mojom::WebUITrigger::not_filters)& not_filters(
      const ::attribution_internals::mojom::WebUITriggerPtr& input) {
    return input->not_filters;
  }

  static const decltype(::attribution_internals::mojom::WebUITrigger::debug_key)& debug_key(
      const ::attribution_internals::mojom::WebUITriggerPtr& input) {
    return input->debug_key;
  }

  static const decltype(::attribution_internals::mojom::WebUITrigger::event_triggers)& event_triggers(
      const ::attribution_internals::mojom::WebUITriggerPtr& input) {
    return input->event_triggers;
  }

  static const decltype(::attribution_internals::mojom::WebUITrigger::aggregatable_triggers)& aggregatable_triggers(
      const ::attribution_internals::mojom::WebUITriggerPtr& input) {
    return input->aggregatable_triggers;
  }

  static const decltype(::attribution_internals::mojom::WebUITrigger::aggregatable_values)& aggregatable_values(
      const ::attribution_internals::mojom::WebUITriggerPtr& input) {
    return input->aggregatable_values;
  }

  static decltype(::attribution_internals::mojom::WebUITrigger::event_level_status) event_level_status(
      const ::attribution_internals::mojom::WebUITriggerPtr& input) {
    return input->event_level_status;
  }

  static decltype(::attribution_internals::mojom::WebUITrigger::aggregatable_status) aggregatable_status(
      const ::attribution_internals::mojom::WebUITriggerPtr& input) {
    return input->aggregatable_status;
  }

  static bool Read(::attribution_internals::mojom::WebUITrigger::DataView input, ::attribution_internals::mojom::WebUITriggerPtr* output);
};


template <>
struct  UnionTraits<::attribution_internals::mojom::ReportID::DataView,
                                        ::attribution_internals::mojom::ReportIDPtr> {
  static bool IsNull(const ::attribution_internals::mojom::ReportIDPtr& input) { return !input; }
  static void SetToNull(::attribution_internals::mojom::ReportIDPtr* output) { output->reset(); }

  static ::attribution_internals::mojom::ReportID::Tag GetTag(const ::attribution_internals::mojom::ReportIDPtr& input) {
    return input->which();
  }

  static const ::content::AttributionReport::EventLevelData::Id& event_level_id(const ::attribution_internals::mojom::ReportIDPtr& input) {
    return input->get_event_level_id();
  }

  static const ::content::AttributionReport::AggregatableAttributionData::Id& aggregatable_attribution_id(const ::attribution_internals::mojom::ReportIDPtr& input) {
    return input->get_aggregatable_attribution_id();
  }

  static bool Read(::attribution_internals::mojom::ReportID::DataView input, ::attribution_internals::mojom::ReportIDPtr* output);
};


template <>
struct  UnionTraits<::attribution_internals::mojom::WebUIReportData::DataView,
                                        ::attribution_internals::mojom::WebUIReportDataPtr> {
  static bool IsNull(const ::attribution_internals::mojom::WebUIReportDataPtr& input) { return !input; }
  static void SetToNull(::attribution_internals::mojom::WebUIReportDataPtr* output) { output->reset(); }

  static ::attribution_internals::mojom::WebUIReportData::Tag GetTag(const ::attribution_internals::mojom::WebUIReportDataPtr& input) {
    return input->which();
  }

  static const ::attribution_internals::mojom::WebUIReportEventLevelDataPtr& event_level_data(const ::attribution_internals::mojom::WebUIReportDataPtr& input) {
    return input->get_event_level_data();
  }

  static const ::attribution_internals::mojom::WebUIReportAggregatableAttributionDataPtr& aggregatable_attribution_data(const ::attribution_internals::mojom::WebUIReportDataPtr& input) {
    return input->get_aggregatable_attribution_data();
  }

  static bool Read(::attribution_internals::mojom::WebUIReportData::DataView input, ::attribution_internals::mojom::WebUIReportDataPtr* output);
};


template <>
struct  UnionTraits<::attribution_internals::mojom::ReportStatus::DataView,
                                        ::attribution_internals::mojom::ReportStatusPtr> {
  static bool IsNull(const ::attribution_internals::mojom::ReportStatusPtr& input) { return !input; }
  static void SetToNull(::attribution_internals::mojom::ReportStatusPtr* output) { output->reset(); }

  static ::attribution_internals::mojom::ReportStatus::Tag GetTag(const ::attribution_internals::mojom::ReportStatusPtr& input) {
    return input->which();
  }

  static const ::attribution_internals::mojom::EmptyPtr& pending(const ::attribution_internals::mojom::ReportStatusPtr& input) {
    return input->get_pending();
  }

  static const std::string& replaced_by_higher_priority_report(const ::attribution_internals::mojom::ReportStatusPtr& input) {
    return input->get_replaced_by_higher_priority_report();
  }

  static const ::attribution_internals::mojom::EmptyPtr& prohibited_by_browser_policy(const ::attribution_internals::mojom::ReportStatusPtr& input) {
    return input->get_prohibited_by_browser_policy();
  }

  static  int32_t sent(const ::attribution_internals::mojom::ReportStatusPtr& input) {
    return input->get_sent();
  }

  static const std::string& network_error(const ::attribution_internals::mojom::ReportStatusPtr& input) {
    return input->get_network_error();
  }

  static const ::attribution_internals::mojom::EmptyPtr& failed_to_assemble(const ::attribution_internals::mojom::ReportStatusPtr& input) {
    return input->get_failed_to_assemble();
  }

  static bool Read(::attribution_internals::mojom::ReportStatus::DataView input, ::attribution_internals::mojom::ReportStatusPtr* output);
};

}  // namespace mojo

#endif  // CONTENT_BROWSER_ATTRIBUTION_REPORTING_ATTRIBUTION_INTERNALS_MOJOM_H_