// content/browser/attribution_reporting/attribution_internals.mojom-test-utils.h is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2019 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef CONTENT_BROWSER_ATTRIBUTION_REPORTING_ATTRIBUTION_INTERNALS_MOJOM_TEST_UTILS_H_
#define CONTENT_BROWSER_ATTRIBUTION_REPORTING_ATTRIBUTION_INTERNALS_MOJOM_TEST_UTILS_H_

#include "content/browser/attribution_reporting/attribution_internals.mojom.h"


namespace attribution_internals {
namespace mojom {


class  ObserverInterceptorForTesting : public Observer {
  virtual Observer* GetForwardingInterface() = 0;
  void OnSourcesChanged() override;
  void OnReportsChanged(::content::AttributionReport::ReportType report_type) override;
  void OnSourceRejectedOrDeactivated(WebUISourcePtr source) override;
  void OnReportSent(WebUIReportPtr report) override;
  void OnReportDropped(WebUIReportPtr report) override;
  void OnTriggerHandled(WebUITriggerPtr trigger) override;
};
class  ObserverAsyncWaiter {
 public:
  explicit ObserverAsyncWaiter(Observer* proxy);

  ObserverAsyncWaiter(const ObserverAsyncWaiter&) = delete;
  ObserverAsyncWaiter& operator=(const ObserverAsyncWaiter&) = delete;

  ~ObserverAsyncWaiter();

 private:
  Observer* const proxy_;
};


class  HandlerInterceptorForTesting : public Handler {
  virtual Handler* GetForwardingInterface() = 0;
  void IsAttributionReportingEnabled(IsAttributionReportingEnabledCallback callback) override;
  void GetActiveSources(GetActiveSourcesCallback callback) override;
  void GetReports(::content::AttributionReport::ReportType report_type, GetReportsCallback callback) override;
  void SendReports(const std::vector<::content::AttributionReport::Id>& ids, SendReportsCallback callback) override;
  void ClearStorage(ClearStorageCallback callback) override;
  void AddObserver(::mojo::PendingRemote<Observer> observer, AddObserverCallback callback) override;
};
class  HandlerAsyncWaiter {
 public:
  explicit HandlerAsyncWaiter(Handler* proxy);

  HandlerAsyncWaiter(const HandlerAsyncWaiter&) = delete;
  HandlerAsyncWaiter& operator=(const HandlerAsyncWaiter&) = delete;

  ~HandlerAsyncWaiter();
  void IsAttributionReportingEnabled(
      bool* out_enabled, bool* out_debug_mode);
  void GetActiveSources(
      std::vector<WebUISourcePtr>* out_sources);
  void GetReports(
      ::content::AttributionReport::ReportType report_type, std::vector<WebUIReportPtr>* out_reports);
  void SendReports(
      const std::vector<::content::AttributionReport::Id>& ids);
  void ClearStorage(
      );
  void AddObserver(
      ::mojo::PendingRemote<Observer> observer, bool* out_success);

 private:
  Handler* const proxy_;
};




}  // namespace mojom
}  // namespace attribution_internals

#endif  // CONTENT_BROWSER_ATTRIBUTION_REPORTING_ATTRIBUTION_INTERNALS_MOJOM_TEST_UTILS_H_