// third_party/blink/public/mojom/fetch/fetch_api_request.mojom-shared.h is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2016 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef THIRD_PARTY_BLINK_PUBLIC_MOJOM_FETCH_FETCH_API_REQUEST_MOJOM_SHARED_H_
#define THIRD_PARTY_BLINK_PUBLIC_MOJOM_FETCH_FETCH_API_REQUEST_MOJOM_SHARED_H_

#include <stdint.h>

#include <functional>
#include <iosfwd>
#include <type_traits>
#include <utility>
#include "mojo/public/cpp/bindings/array_data_view.h"
#include "mojo/public/cpp/bindings/enum_traits.h"
#include "mojo/public/cpp/bindings/interface_data_view.h"
#include "mojo/public/cpp/bindings/lib/bindings_internal.h"
#include "mojo/public/cpp/bindings/lib/serialization.h"
#include "mojo/public/cpp/bindings/map_data_view.h"
#include "mojo/public/cpp/bindings/string_data_view.h"

#include "third_party/perfetto/include/perfetto/tracing/traced_value_forward.h"

#include "third_party/blink/public/mojom/fetch/fetch_api_request.mojom-shared-internal.h"
#include "mojo/public/mojom/base/file_path.mojom-shared.h"
#include "mojo/public/mojom/base/time.mojom-shared.h"
#include "mojo/public/mojom/base/unguessable_token.mojom-shared.h"
#include "services/network/public/mojom/ip_address_space.mojom-shared.h"
#include "services/network/public/mojom/chunked_data_pipe_getter.mojom-shared.h"
#include "services/network/public/mojom/fetch_api.mojom-shared.h"
#include "services/network/public/mojom/request_priority.mojom-shared.h"
#include "services/network/public/mojom/trust_tokens.mojom-shared.h"
#include "services/network/public/mojom/url_request.mojom-shared.h"
#include "third_party/blink/public/mojom/blob/serialized_blob.mojom-shared.h"
#include "third_party/blink/public/mojom/loader/request_context_frame_type.mojom-shared.h"
#include "third_party/blink/public/mojom/loader/referrer.mojom-shared.h"
#include "url/mojom/origin.mojom-shared.h"
#include "url/mojom/url.mojom-shared.h"
#include "mojo/public/cpp/bindings/lib/interface_serialization.h"


#include "base/component_export.h"




namespace blink {
namespace mojom {
class FetchAPIRequestHeadersDataView;

class FetchAPIRequestBodyDataView;

class FetchAPIRequestDataView;



}  // namespace mojom
}  // namespace blink

namespace mojo {
namespace internal {

template <>
struct MojomTypeTraits<::blink::mojom::FetchAPIRequestHeadersDataView> {
  using Data = ::blink::mojom::internal::FetchAPIRequestHeaders_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::blink::mojom::FetchAPIRequestBodyDataView> {
  using Data = ::blink::mojom::internal::FetchAPIRequestBody_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::blink::mojom::FetchAPIRequestDataView> {
  using Data = ::blink::mojom::internal::FetchAPIRequest_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

}  // namespace internal
}  // namespace mojo


namespace blink {
namespace mojom {


enum class RequestContextType : int32_t {
  
  UNSPECIFIED = 0,
  
  ATTRIBUTION_SRC = 1,
  
  AUDIO = 2,
  
  BEACON = 3,
  
  CSP_REPORT = 4,
  
  DOWNLOAD = 5,
  
  EMBED = 6,
  
  EVENT_SOURCE = 7,
  
  FAVICON = 8,
  
  FETCH = 9,
  
  FONT = 10,
  
  FORM = 11,
  
  FRAME = 12,
  
  HYPERLINK = 13,
  
  IFRAME = 14,
  
  IMAGE = 15,
  
  IMAGE_SET = 16,
  
  INTERNAL = 17,
  
  LOCATION = 18,
  
  MANIFEST = 19,
  
  OBJECT = 20,
  
  PING = 21,
  
  PLUGIN = 22,
  
  PREFETCH = 23,
  
  SCRIPT = 24,
  
  SERVICE_WORKER = 25,
  
  SHARED_WORKER = 26,
  
  SUBRESOURCE = 27,
  
  SUBRESOURCE_WEBBUNDLE = 28,
  
  STYLE = 29,
  
  TRACK = 30,
  
  VIDEO = 31,
  
  WORKER = 32,
  
  XML_HTTP_REQUEST = 33,
  
  XSLT = 34,
  kMinValue = 0,
  kMaxValue = 34,
};

COMPONENT_EXPORT(MOJOM_SHARED_BLINK_COMMON_EXPORT) std::ostream& operator<<(std::ostream& os, RequestContextType value);
inline bool IsKnownEnumValue(RequestContextType value) {
  return internal::RequestContextType_Data::IsKnownValue(
      static_cast<int32_t>(value));
}


enum class FetchCacheMode : int32_t {
  
  kDefault = 0,
  
  kNoStore = 1,
  
  kBypassCache = 2,
  
  kValidateCache = 3,
  
  kForceCache = 4,
  
  kOnlyIfCached = 5,
  
  kUnspecifiedOnlyIfCachedStrict = 6,
  
  kUnspecifiedForceCacheMiss = 7,
  kMinValue = 0,
  kMaxValue = 7,
};

COMPONENT_EXPORT(MOJOM_SHARED_BLINK_COMMON_EXPORT) std::ostream& operator<<(std::ostream& os, FetchCacheMode value);
inline bool IsKnownEnumValue(FetchCacheMode value) {
  return internal::FetchCacheMode_Data::IsKnownValue(
      static_cast<int32_t>(value));
}


enum class FetchPriorityHint : int32_t {
  
  kLow = 0,
  
  kAuto = 1,
  
  kHigh = 2,
  kMinValue = 0,
  kMaxValue = 2,
};

COMPONENT_EXPORT(MOJOM_SHARED_BLINK_COMMON_EXPORT) std::ostream& operator<<(std::ostream& os, FetchPriorityHint value);
inline bool IsKnownEnumValue(FetchPriorityHint value) {
  return internal::FetchPriorityHint_Data::IsKnownValue(
      static_cast<int32_t>(value));
}


class FetchAPIRequestHeadersDataView {
 public:
  FetchAPIRequestHeadersDataView() = default;

  FetchAPIRequestHeadersDataView(
      internal::FetchAPIRequestHeaders_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  inline void GetHeadersDataView(
      mojo::MapDataView<mojo::StringDataView, mojo::StringDataView>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadHeaders(UserType* output) {
    
    auto* pointer = data_->headers.Get();
    return mojo::internal::Deserialize<mojo::MapDataView<mojo::StringDataView, mojo::StringDataView>>(
        pointer, output, message_);
  }
 private:
  internal::FetchAPIRequestHeaders_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class FetchAPIRequestBodyDataView {
 public:
  FetchAPIRequestBodyDataView() = default;

  FetchAPIRequestBodyDataView(
      internal::FetchAPIRequestBody_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  inline void GetElementsDataView(
      mojo::ArrayDataView<::network::mojom::DataElementDataView>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadElements(UserType* output) {
    
    auto* pointer = data_->elements.Get();
    return mojo::internal::Deserialize<mojo::ArrayDataView<::network::mojom::DataElementDataView>>(
        pointer, output, message_);
  }
  uint64_t identifier() const {
    return data_->identifier;
  }
  bool contains_sensitive_info() const {
    return data_->contains_sensitive_info;
  }
 private:
  internal::FetchAPIRequestBody_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class FetchAPIRequestDataView {
 public:
  FetchAPIRequestDataView() = default;

  FetchAPIRequestDataView(
      internal::FetchAPIRequest_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  template <typename UserType>
  [[nodiscard]] bool ReadMode(UserType* output) const {
    auto data_value = data_->mode;
    return mojo::internal::Deserialize<::network::mojom::RequestMode>(
        data_value, output);
  }
  ::network::mojom::RequestMode mode() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::network::mojom::RequestMode>(data_->mode));
  }
  bool is_main_resource_load() const {
    return data_->is_main_resource_load;
  }
  template <typename UserType>
  [[nodiscard]] bool ReadDestination(UserType* output) const {
    auto data_value = data_->destination;
    return mojo::internal::Deserialize<::network::mojom::RequestDestination>(
        data_value, output);
  }
  ::network::mojom::RequestDestination destination() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::network::mojom::RequestDestination>(data_->destination));
  }
  template <typename UserType>
  [[nodiscard]] bool ReadFrameType(UserType* output) const {
    auto data_value = data_->frame_type;
    return mojo::internal::Deserialize<::blink::mojom::RequestContextFrameType>(
        data_value, output);
  }
  ::blink::mojom::RequestContextFrameType frame_type() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::blink::mojom::RequestContextFrameType>(data_->frame_type));
  }
  inline void GetUrlDataView(
      ::url::mojom::UrlDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadUrl(UserType* output) {
    
    auto* pointer = data_->url.Get();
    return mojo::internal::Deserialize<::url::mojom::UrlDataView>(
        pointer, output, message_);
  }
  inline void GetMethodDataView(
      mojo::StringDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadMethod(UserType* output) {
    
    auto* pointer = data_->method.Get();
    return mojo::internal::Deserialize<mojo::StringDataView>(
        pointer, output, message_);
  }
  inline void GetHeadersDataView(
      FetchAPIRequestHeadersDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadHeaders(UserType* output) {
    
    auto* pointer = data_->headers.Get();
    return mojo::internal::Deserialize<::blink::mojom::FetchAPIRequestHeadersDataView>(
        pointer, output, message_);
  }
  inline void GetBlobDataView(
      ::blink::mojom::SerializedBlobDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadBlob(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::blink::mojom::SerializedBlobDataView, UserType>(),
    "Attempting to read the optional `blob` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadBlob` instead "
    "of `ReadBlob if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->blob.Get();
    return mojo::internal::Deserialize<::blink::mojom::SerializedBlobDataView>(
        pointer, output, message_);
  }
  inline void GetBodyDataView(
      FetchAPIRequestBodyDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadBody(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::blink::mojom::FetchAPIRequestBodyDataView, UserType>(),
    "Attempting to read the optional `body` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadBody` instead "
    "of `ReadBody if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->body.Get();
    return mojo::internal::Deserialize<::blink::mojom::FetchAPIRequestBodyDataView>(
        pointer, output, message_);
  }
  inline void GetRequestInitiatorDataView(
      ::url::mojom::OriginDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadRequestInitiator(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::url::mojom::OriginDataView, UserType>(),
    "Attempting to read the optional `request_initiator` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadRequestInitiator` instead "
    "of `ReadRequestInitiator if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->request_initiator.Get();
    return mojo::internal::Deserialize<::url::mojom::OriginDataView>(
        pointer, output, message_);
  }
  inline void GetNavigationRedirectChainDataView(
      mojo::ArrayDataView<::url::mojom::UrlDataView>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadNavigationRedirectChain(UserType* output) {
    
    auto* pointer = data_->navigation_redirect_chain.Get();
    return mojo::internal::Deserialize<mojo::ArrayDataView<::url::mojom::UrlDataView>>(
        pointer, output, message_);
  }
  inline void GetReferrerDataView(
      ::blink::mojom::ReferrerDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadReferrer(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::blink::mojom::ReferrerDataView, UserType>(),
    "Attempting to read the optional `referrer` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadReferrer` instead "
    "of `ReadReferrer if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->referrer.Get();
    return mojo::internal::Deserialize<::blink::mojom::ReferrerDataView>(
        pointer, output, message_);
  }
  template <typename UserType>
  [[nodiscard]] bool ReadCredentialsMode(UserType* output) const {
    auto data_value = data_->credentials_mode;
    return mojo::internal::Deserialize<::network::mojom::CredentialsMode>(
        data_value, output);
  }
  ::network::mojom::CredentialsMode credentials_mode() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::network::mojom::CredentialsMode>(data_->credentials_mode));
  }
  template <typename UserType>
  [[nodiscard]] bool ReadCacheMode(UserType* output) const {
    auto data_value = data_->cache_mode;
    return mojo::internal::Deserialize<::blink::mojom::FetchCacheMode>(
        data_value, output);
  }
  FetchCacheMode cache_mode() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::blink::mojom::FetchCacheMode>(data_->cache_mode));
  }
  template <typename UserType>
  [[nodiscard]] bool ReadRedirectMode(UserType* output) const {
    auto data_value = data_->redirect_mode;
    return mojo::internal::Deserialize<::network::mojom::RedirectMode>(
        data_value, output);
  }
  ::network::mojom::RedirectMode redirect_mode() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::network::mojom::RedirectMode>(data_->redirect_mode));
  }
  inline void GetIntegrityDataView(
      mojo::StringDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadIntegrity(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        mojo::StringDataView, UserType>(),
    "Attempting to read the optional `integrity` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadIntegrity` instead "
    "of `ReadIntegrity if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->integrity.Get();
    return mojo::internal::Deserialize<mojo::StringDataView>(
        pointer, output, message_);
  }
  template <typename UserType>
  [[nodiscard]] bool ReadPriority(UserType* output) const {
    auto data_value = data_->priority;
    return mojo::internal::Deserialize<::network::mojom::RequestPriority>(
        data_value, output);
  }
  ::network::mojom::RequestPriority priority() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::network::mojom::RequestPriority>(data_->priority));
  }
  inline void GetFetchWindowIdDataView(
      ::mojo_base::mojom::UnguessableTokenDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadFetchWindowId(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::mojo_base::mojom::UnguessableTokenDataView, UserType>(),
    "Attempting to read the optional `fetch_window_id` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadFetchWindowId` instead "
    "of `ReadFetchWindowId if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->fetch_window_id.Get();
    return mojo::internal::Deserialize<::mojo_base::mojom::UnguessableTokenDataView>(
        pointer, output, message_);
  }
  bool keepalive() const {
    return data_->keepalive;
  }
  bool is_reload() const {
    return data_->is_reload;
  }
  bool is_history_navigation() const {
    return data_->is_history_navigation;
  }
  inline void GetDevtoolsStackIdDataView(
      mojo::StringDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadDevtoolsStackId(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        mojo::StringDataView, UserType>(),
    "Attempting to read the optional `devtools_stack_id` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadDevtoolsStackId` instead "
    "of `ReadDevtoolsStackId if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->devtools_stack_id.Get();
    return mojo::internal::Deserialize<mojo::StringDataView>(
        pointer, output, message_);
  }
  inline void GetTrustTokenParamsDataView(
      ::network::mojom::TrustTokenParamsDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadTrustTokenParams(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::network::mojom::TrustTokenParamsDataView, UserType>(),
    "Attempting to read the optional `trust_token_params` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadTrustTokenParams` instead "
    "of `ReadTrustTokenParams if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->trust_token_params.Get();
    return mojo::internal::Deserialize<::network::mojom::TrustTokenParamsDataView>(
        pointer, output, message_);
  }
  template <typename UserType>
  [[nodiscard]] bool ReadTargetAddressSpace(UserType* output) const {
    auto data_value = data_->target_address_space;
    return mojo::internal::Deserialize<::network::mojom::IPAddressSpace>(
        data_value, output);
  }
  ::network::mojom::IPAddressSpace target_address_space() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::network::mojom::IPAddressSpace>(data_->target_address_space));
  }
 private:
  internal::FetchAPIRequest_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



}  // namespace mojom
}  // namespace blink

namespace std {

template <>
struct hash<::blink::mojom::RequestContextType>
    : public mojo::internal::EnumHashImpl<::blink::mojom::RequestContextType> {};

template <>
struct hash<::blink::mojom::FetchCacheMode>
    : public mojo::internal::EnumHashImpl<::blink::mojom::FetchCacheMode> {};

template <>
struct hash<::blink::mojom::FetchPriorityHint>
    : public mojo::internal::EnumHashImpl<::blink::mojom::FetchPriorityHint> {};

}  // namespace std

namespace mojo {


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::blink::mojom::RequestContextType, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::blink::mojom::RequestContextType, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::blink::mojom::RequestContextType>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::blink::mojom::FetchCacheMode, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::blink::mojom::FetchCacheMode, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::blink::mojom::FetchCacheMode>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::blink::mojom::FetchPriorityHint, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::blink::mojom::FetchPriorityHint, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::blink::mojom::FetchPriorityHint>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::blink::mojom::FetchAPIRequestHeadersDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::blink::mojom::FetchAPIRequestHeadersDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::blink::mojom::internal::FetchAPIRequestHeaders_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    decltype(Traits::headers(input)) in_headers = Traits::headers(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->headers)::BaseType>
        headers_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams headers_validate_params(
        new mojo::internal::ContainerValidateParams(0, false, new mojo::internal::ContainerValidateParams(0, false, nullptr)), new mojo::internal::ContainerValidateParams(0, false, new mojo::internal::ContainerValidateParams(0, false, nullptr)));
    mojo::internal::Serialize<mojo::MapDataView<mojo::StringDataView, mojo::StringDataView>>(
        in_headers, headers_fragment, &headers_validate_params);
    fragment->headers.Set(
        headers_fragment.is_null() ? nullptr : headers_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->headers.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null headers in FetchAPIRequestHeaders struct");
  }

  static bool Deserialize(::blink::mojom::internal::FetchAPIRequestHeaders_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::blink::mojom::FetchAPIRequestHeadersDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::blink::mojom::FetchAPIRequestBodyDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::blink::mojom::FetchAPIRequestBodyDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::blink::mojom::internal::FetchAPIRequestBody_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    decltype(Traits::elements(input)) in_elements = Traits::elements(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->elements)::BaseType>
        elements_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams elements_validate_params(
        0, false, nullptr);
    mojo::internal::Serialize<mojo::ArrayDataView<::network::mojom::DataElementDataView>>(
        in_elements, elements_fragment, &elements_validate_params);
    fragment->elements.Set(
        elements_fragment.is_null() ? nullptr : elements_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->elements.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null elements in FetchAPIRequestBody struct");
    fragment->identifier = Traits::identifier(input);
    fragment->contains_sensitive_info = Traits::contains_sensitive_info(input);
  }

  static bool Deserialize(::blink::mojom::internal::FetchAPIRequestBody_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::blink::mojom::FetchAPIRequestBodyDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::blink::mojom::FetchAPIRequestDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::blink::mojom::FetchAPIRequestDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::blink::mojom::internal::FetchAPIRequest_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    mojo::internal::Serialize<::network::mojom::RequestMode>(
        Traits::mode(input), &fragment->mode);
    fragment->is_main_resource_load = Traits::is_main_resource_load(input);
    mojo::internal::Serialize<::network::mojom::RequestDestination>(
        Traits::destination(input), &fragment->destination);
    mojo::internal::Serialize<::blink::mojom::RequestContextFrameType>(
        Traits::frame_type(input), &fragment->frame_type);
    decltype(Traits::url(input)) in_url = Traits::url(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->url)::BaseType> url_fragment(
            fragment.message());
    mojo::internal::Serialize<::url::mojom::UrlDataView>(
        in_url, url_fragment);
    fragment->url.Set(
        url_fragment.is_null() ? nullptr : url_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->url.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null url in FetchAPIRequest struct");
    decltype(Traits::method(input)) in_method = Traits::method(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->method)::BaseType> method_fragment(
            fragment.message());
    mojo::internal::Serialize<mojo::StringDataView>(
        in_method, method_fragment);
    fragment->method.Set(
        method_fragment.is_null() ? nullptr : method_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->method.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null method in FetchAPIRequest struct");
    decltype(Traits::headers(input)) in_headers = Traits::headers(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->headers)::BaseType> headers_fragment(
            fragment.message());
    mojo::internal::Serialize<::blink::mojom::FetchAPIRequestHeadersDataView>(
        in_headers, headers_fragment);
    fragment->headers.Set(
        headers_fragment.is_null() ? nullptr : headers_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->headers.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null headers in FetchAPIRequest struct");
    decltype(Traits::blob(input)) in_blob = Traits::blob(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->blob)::BaseType> blob_fragment(
            fragment.message());
    mojo::internal::Serialize<::blink::mojom::SerializedBlobDataView>(
        in_blob, blob_fragment);
    fragment->blob.Set(
        blob_fragment.is_null() ? nullptr : blob_fragment.data());
    decltype(Traits::body(input)) in_body = Traits::body(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->body)::BaseType> body_fragment(
            fragment.message());
    mojo::internal::Serialize<::blink::mojom::FetchAPIRequestBodyDataView>(
        in_body, body_fragment);
    fragment->body.Set(
        body_fragment.is_null() ? nullptr : body_fragment.data());
    decltype(Traits::request_initiator(input)) in_request_initiator = Traits::request_initiator(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->request_initiator)::BaseType> request_initiator_fragment(
            fragment.message());
    mojo::internal::Serialize<::url::mojom::OriginDataView>(
        in_request_initiator, request_initiator_fragment);
    fragment->request_initiator.Set(
        request_initiator_fragment.is_null() ? nullptr : request_initiator_fragment.data());
    decltype(Traits::navigation_redirect_chain(input)) in_navigation_redirect_chain = Traits::navigation_redirect_chain(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->navigation_redirect_chain)::BaseType>
        navigation_redirect_chain_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams navigation_redirect_chain_validate_params(
        0, false, nullptr);
    mojo::internal::Serialize<mojo::ArrayDataView<::url::mojom::UrlDataView>>(
        in_navigation_redirect_chain, navigation_redirect_chain_fragment, &navigation_redirect_chain_validate_params);
    fragment->navigation_redirect_chain.Set(
        navigation_redirect_chain_fragment.is_null() ? nullptr : navigation_redirect_chain_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->navigation_redirect_chain.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null navigation_redirect_chain in FetchAPIRequest struct");
    decltype(Traits::referrer(input)) in_referrer = Traits::referrer(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->referrer)::BaseType> referrer_fragment(
            fragment.message());
    mojo::internal::Serialize<::blink::mojom::ReferrerDataView>(
        in_referrer, referrer_fragment);
    fragment->referrer.Set(
        referrer_fragment.is_null() ? nullptr : referrer_fragment.data());
    mojo::internal::Serialize<::network::mojom::CredentialsMode>(
        Traits::credentials_mode(input), &fragment->credentials_mode);
    mojo::internal::Serialize<::blink::mojom::FetchCacheMode>(
        Traits::cache_mode(input), &fragment->cache_mode);
    mojo::internal::Serialize<::network::mojom::RedirectMode>(
        Traits::redirect_mode(input), &fragment->redirect_mode);
    decltype(Traits::integrity(input)) in_integrity = Traits::integrity(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->integrity)::BaseType> integrity_fragment(
            fragment.message());
    mojo::internal::Serialize<mojo::StringDataView>(
        in_integrity, integrity_fragment);
    fragment->integrity.Set(
        integrity_fragment.is_null() ? nullptr : integrity_fragment.data());
    mojo::internal::Serialize<::network::mojom::RequestPriority>(
        Traits::priority(input), &fragment->priority);
    decltype(Traits::fetch_window_id(input)) in_fetch_window_id = Traits::fetch_window_id(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->fetch_window_id)::BaseType> fetch_window_id_fragment(
            fragment.message());
    mojo::internal::Serialize<::mojo_base::mojom::UnguessableTokenDataView>(
        in_fetch_window_id, fetch_window_id_fragment);
    fragment->fetch_window_id.Set(
        fetch_window_id_fragment.is_null() ? nullptr : fetch_window_id_fragment.data());
    fragment->keepalive = Traits::keepalive(input);
    fragment->is_reload = Traits::is_reload(input);
    fragment->is_history_navigation = Traits::is_history_navigation(input);
    decltype(Traits::devtools_stack_id(input)) in_devtools_stack_id = Traits::devtools_stack_id(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->devtools_stack_id)::BaseType> devtools_stack_id_fragment(
            fragment.message());
    mojo::internal::Serialize<mojo::StringDataView>(
        in_devtools_stack_id, devtools_stack_id_fragment);
    fragment->devtools_stack_id.Set(
        devtools_stack_id_fragment.is_null() ? nullptr : devtools_stack_id_fragment.data());
    decltype(Traits::trust_token_params(input)) in_trust_token_params = Traits::trust_token_params(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->trust_token_params)::BaseType> trust_token_params_fragment(
            fragment.message());
    mojo::internal::Serialize<::network::mojom::TrustTokenParamsDataView>(
        in_trust_token_params, trust_token_params_fragment);
    fragment->trust_token_params.Set(
        trust_token_params_fragment.is_null() ? nullptr : trust_token_params_fragment.data());
    mojo::internal::Serialize<::network::mojom::IPAddressSpace>(
        Traits::target_address_space(input), &fragment->target_address_space);
  }

  static bool Deserialize(::blink::mojom::internal::FetchAPIRequest_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::blink::mojom::FetchAPIRequestDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal

}  // namespace mojo


namespace blink {
namespace mojom {

inline void FetchAPIRequestHeadersDataView::GetHeadersDataView(
    mojo::MapDataView<mojo::StringDataView, mojo::StringDataView>* output) {
  auto pointer = data_->headers.Get();
  *output = mojo::MapDataView<mojo::StringDataView, mojo::StringDataView>(pointer, message_);
}


inline void FetchAPIRequestBodyDataView::GetElementsDataView(
    mojo::ArrayDataView<::network::mojom::DataElementDataView>* output) {
  auto pointer = data_->elements.Get();
  *output = mojo::ArrayDataView<::network::mojom::DataElementDataView>(pointer, message_);
}


inline void FetchAPIRequestDataView::GetUrlDataView(
    ::url::mojom::UrlDataView* output) {
  auto pointer = data_->url.Get();
  *output = ::url::mojom::UrlDataView(pointer, message_);
}
inline void FetchAPIRequestDataView::GetMethodDataView(
    mojo::StringDataView* output) {
  auto pointer = data_->method.Get();
  *output = mojo::StringDataView(pointer, message_);
}
inline void FetchAPIRequestDataView::GetHeadersDataView(
    FetchAPIRequestHeadersDataView* output) {
  auto pointer = data_->headers.Get();
  *output = FetchAPIRequestHeadersDataView(pointer, message_);
}
inline void FetchAPIRequestDataView::GetBlobDataView(
    ::blink::mojom::SerializedBlobDataView* output) {
  auto pointer = data_->blob.Get();
  *output = ::blink::mojom::SerializedBlobDataView(pointer, message_);
}
inline void FetchAPIRequestDataView::GetBodyDataView(
    FetchAPIRequestBodyDataView* output) {
  auto pointer = data_->body.Get();
  *output = FetchAPIRequestBodyDataView(pointer, message_);
}
inline void FetchAPIRequestDataView::GetRequestInitiatorDataView(
    ::url::mojom::OriginDataView* output) {
  auto pointer = data_->request_initiator.Get();
  *output = ::url::mojom::OriginDataView(pointer, message_);
}
inline void FetchAPIRequestDataView::GetNavigationRedirectChainDataView(
    mojo::ArrayDataView<::url::mojom::UrlDataView>* output) {
  auto pointer = data_->navigation_redirect_chain.Get();
  *output = mojo::ArrayDataView<::url::mojom::UrlDataView>(pointer, message_);
}
inline void FetchAPIRequestDataView::GetReferrerDataView(
    ::blink::mojom::ReferrerDataView* output) {
  auto pointer = data_->referrer.Get();
  *output = ::blink::mojom::ReferrerDataView(pointer, message_);
}
inline void FetchAPIRequestDataView::GetIntegrityDataView(
    mojo::StringDataView* output) {
  auto pointer = data_->integrity.Get();
  *output = mojo::StringDataView(pointer, message_);
}
inline void FetchAPIRequestDataView::GetFetchWindowIdDataView(
    ::mojo_base::mojom::UnguessableTokenDataView* output) {
  auto pointer = data_->fetch_window_id.Get();
  *output = ::mojo_base::mojom::UnguessableTokenDataView(pointer, message_);
}
inline void FetchAPIRequestDataView::GetDevtoolsStackIdDataView(
    mojo::StringDataView* output) {
  auto pointer = data_->devtools_stack_id.Get();
  *output = mojo::StringDataView(pointer, message_);
}
inline void FetchAPIRequestDataView::GetTrustTokenParamsDataView(
    ::network::mojom::TrustTokenParamsDataView* output) {
  auto pointer = data_->trust_token_params.Get();
  *output = ::network::mojom::TrustTokenParamsDataView(pointer, message_);
}



}  // namespace mojom
}  // namespace blink

// Declare TraceFormatTraits for enums, which should be defined in ::perfetto
// namespace.

namespace perfetto {

template <>
struct COMPONENT_EXPORT(MOJOM_SHARED_BLINK_COMMON_EXPORT) TraceFormatTraits<::blink::mojom::RequestContextType> {
 static void WriteIntoTrace(perfetto::TracedValue context, ::blink::mojom::RequestContextType value);
};

} // namespace perfetto

namespace perfetto {

template <>
struct COMPONENT_EXPORT(MOJOM_SHARED_BLINK_COMMON_EXPORT) TraceFormatTraits<::blink::mojom::FetchCacheMode> {
 static void WriteIntoTrace(perfetto::TracedValue context, ::blink::mojom::FetchCacheMode value);
};

} // namespace perfetto

namespace perfetto {

template <>
struct COMPONENT_EXPORT(MOJOM_SHARED_BLINK_COMMON_EXPORT) TraceFormatTraits<::blink::mojom::FetchPriorityHint> {
 static void WriteIntoTrace(perfetto::TracedValue context, ::blink::mojom::FetchPriorityHint value);
};

} // namespace perfetto

#endif  // THIRD_PARTY_BLINK_PUBLIC_MOJOM_FETCH_FETCH_API_REQUEST_MOJOM_SHARED_H_