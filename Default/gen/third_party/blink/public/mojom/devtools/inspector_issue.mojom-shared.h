// third_party/blink/public/mojom/devtools/inspector_issue.mojom-shared.h is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2016 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef THIRD_PARTY_BLINK_PUBLIC_MOJOM_DEVTOOLS_INSPECTOR_ISSUE_MOJOM_SHARED_H_
#define THIRD_PARTY_BLINK_PUBLIC_MOJOM_DEVTOOLS_INSPECTOR_ISSUE_MOJOM_SHARED_H_

#include <stdint.h>

#include <functional>
#include <iosfwd>
#include <type_traits>
#include <utility>
#include "mojo/public/cpp/bindings/array_data_view.h"
#include "mojo/public/cpp/bindings/enum_traits.h"
#include "mojo/public/cpp/bindings/interface_data_view.h"
#include "mojo/public/cpp/bindings/lib/bindings_internal.h"
#include "mojo/public/cpp/bindings/lib/serialization.h"
#include "mojo/public/cpp/bindings/map_data_view.h"
#include "mojo/public/cpp/bindings/string_data_view.h"

#include "third_party/perfetto/include/perfetto/tracing/traced_value_forward.h"

#include "third_party/blink/public/mojom/devtools/inspector_issue.mojom-shared-internal.h"
#include "url/mojom/url.mojom-shared.h"
#include "services/network/public/mojom/cookie_manager.mojom-shared.h"
#include "services/network/public/mojom/blocked_by_response_reason.mojom-shared.h"
#include "third_party/blink/public/mojom/fetch/fetch_api_request.mojom-shared.h"
#include "mojo/public/mojom/base/unguessable_token.mojom-shared.h"



#include "base/component_export.h"




namespace blink {
namespace mojom {
class AffectedCookieDataView;

class AffectedRequestDataView;

class AffectedFrameDataView;

class AffectedLocationDataView;

class BlockedByResponseIssueDetailsDataView;

class HeavyAdIssueDetailsDataView;

class MixedContentIssueDetailsDataView;

class ContentSecurityPolicyIssueDetailsDataView;

class CookieIssueDetailsDataView;

class SharedArrayBufferIssueDetailsDataView;

class TrustedWebActivityIssueDetailsDataView;

class LowTextContrastIssueDataView;

class FederatedAuthRequestIssueDetailsDataView;

class GenericIssueDetailsDataView;

class InspectorIssueDetailsDataView;

class InspectorIssueInfoDataView;



}  // namespace mojom
}  // namespace blink

namespace mojo {
namespace internal {

template <>
struct MojomTypeTraits<::blink::mojom::AffectedCookieDataView> {
  using Data = ::blink::mojom::internal::AffectedCookie_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::blink::mojom::AffectedRequestDataView> {
  using Data = ::blink::mojom::internal::AffectedRequest_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::blink::mojom::AffectedFrameDataView> {
  using Data = ::blink::mojom::internal::AffectedFrame_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::blink::mojom::AffectedLocationDataView> {
  using Data = ::blink::mojom::internal::AffectedLocation_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::blink::mojom::BlockedByResponseIssueDetailsDataView> {
  using Data = ::blink::mojom::internal::BlockedByResponseIssueDetails_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::blink::mojom::HeavyAdIssueDetailsDataView> {
  using Data = ::blink::mojom::internal::HeavyAdIssueDetails_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::blink::mojom::MixedContentIssueDetailsDataView> {
  using Data = ::blink::mojom::internal::MixedContentIssueDetails_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::blink::mojom::ContentSecurityPolicyIssueDetailsDataView> {
  using Data = ::blink::mojom::internal::ContentSecurityPolicyIssueDetails_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::blink::mojom::CookieIssueDetailsDataView> {
  using Data = ::blink::mojom::internal::CookieIssueDetails_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::blink::mojom::SharedArrayBufferIssueDetailsDataView> {
  using Data = ::blink::mojom::internal::SharedArrayBufferIssueDetails_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::blink::mojom::TrustedWebActivityIssueDetailsDataView> {
  using Data = ::blink::mojom::internal::TrustedWebActivityIssueDetails_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::blink::mojom::LowTextContrastIssueDataView> {
  using Data = ::blink::mojom::internal::LowTextContrastIssue_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::blink::mojom::FederatedAuthRequestIssueDetailsDataView> {
  using Data = ::blink::mojom::internal::FederatedAuthRequestIssueDetails_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::blink::mojom::GenericIssueDetailsDataView> {
  using Data = ::blink::mojom::internal::GenericIssueDetails_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::blink::mojom::InspectorIssueDetailsDataView> {
  using Data = ::blink::mojom::internal::InspectorIssueDetails_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::blink::mojom::InspectorIssueInfoDataView> {
  using Data = ::blink::mojom::internal::InspectorIssueInfo_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

}  // namespace internal
}  // namespace mojo


namespace blink {
namespace mojom {


enum class InspectorIssueCode : int32_t {
  
  kCookieIssue = 0,
  
  kMixedContentIssue = 1,
  
  kBlockedByResponseIssue = 2,
  
  kContentSecurityPolicyIssue = 3,
  
  kSharedArrayBufferIssue = 4,
  
  kTrustedWebActivityIssue = 5,
  
  kHeavyAdIssue = 6,
  
  kLowTextContrastIssue = 7,
  
  kFederatedAuthRequestIssue = 8,
  
  kGenericIssue = 9,
  kMinValue = 0,
  kMaxValue = 9,
};

COMPONENT_EXPORT(MOJOM_SHARED_BLINK_COMMON_EXPORT) std::ostream& operator<<(std::ostream& os, InspectorIssueCode value);
inline bool IsKnownEnumValue(InspectorIssueCode value) {
  return internal::InspectorIssueCode_Data::IsKnownValue(
      static_cast<int32_t>(value));
}


enum class HeavyAdResolutionStatus : int32_t {
  
  kHeavyAdBlocked = 0,
  
  kHeavyAdWarning = 1,
  kMinValue = 0,
  kMaxValue = 1,
};

COMPONENT_EXPORT(MOJOM_SHARED_BLINK_COMMON_EXPORT) std::ostream& operator<<(std::ostream& os, HeavyAdResolutionStatus value);
inline bool IsKnownEnumValue(HeavyAdResolutionStatus value) {
  return internal::HeavyAdResolutionStatus_Data::IsKnownValue(
      static_cast<int32_t>(value));
}


enum class HeavyAdReason : int32_t {
  
  kNetworkTotalLimit = 0,
  
  kCpuTotalLimit = 1,
  
  kCpuPeakLimit = 2,
  kMinValue = 0,
  kMaxValue = 2,
};

COMPONENT_EXPORT(MOJOM_SHARED_BLINK_COMMON_EXPORT) std::ostream& operator<<(std::ostream& os, HeavyAdReason value);
inline bool IsKnownEnumValue(HeavyAdReason value) {
  return internal::HeavyAdReason_Data::IsKnownValue(
      static_cast<int32_t>(value));
}


enum class MixedContentResolutionStatus : int32_t {
  
  kMixedContentBlocked = 0,
  
  kMixedContentAutomaticallyUpgraded = 1,
  
  kMixedContentWarning = 2,
  kMinValue = 0,
  kMaxValue = 2,
};

COMPONENT_EXPORT(MOJOM_SHARED_BLINK_COMMON_EXPORT) std::ostream& operator<<(std::ostream& os, MixedContentResolutionStatus value);
inline bool IsKnownEnumValue(MixedContentResolutionStatus value) {
  return internal::MixedContentResolutionStatus_Data::IsKnownValue(
      static_cast<int32_t>(value));
}


enum class ContentSecurityPolicyViolationType : int32_t {
  
  kInlineViolation = 0,
  
  kEvalViolation = 1,
  
  kURLViolation = 2,
  
  kTrustedTypesSinkViolation = 3,
  
  kTrustedTypesPolicyViolation = 4,
  
  kWasmEvalViolation = 5,
  kMinValue = 0,
  kMaxValue = 5,
};

COMPONENT_EXPORT(MOJOM_SHARED_BLINK_COMMON_EXPORT) std::ostream& operator<<(std::ostream& os, ContentSecurityPolicyViolationType value);
inline bool IsKnownEnumValue(ContentSecurityPolicyViolationType value) {
  return internal::ContentSecurityPolicyViolationType_Data::IsKnownValue(
      static_cast<int32_t>(value));
}


enum class CookieOperation : int32_t {
  
  kSetCookie = 0,
  
  kReadCookie = 1,
  kMinValue = 0,
  kMaxValue = 1,
};

COMPONENT_EXPORT(MOJOM_SHARED_BLINK_COMMON_EXPORT) std::ostream& operator<<(std::ostream& os, CookieOperation value);
inline bool IsKnownEnumValue(CookieOperation value) {
  return internal::CookieOperation_Data::IsKnownValue(
      static_cast<int32_t>(value));
}


enum class CookieExclusionReason : int32_t {
  
  kExcludeSameSiteUnspecifiedTreatedAsLax = 0,
  
  kExcludeSameSiteNoneInsecure = 1,
  
  kExcludeSameSiteLax = 2,
  
  kExcludeSameSiteStrict = 3,
  
  kExcludeDomainNonASCII = 4,
  kMinValue = 0,
  kMaxValue = 4,
};

COMPONENT_EXPORT(MOJOM_SHARED_BLINK_COMMON_EXPORT) std::ostream& operator<<(std::ostream& os, CookieExclusionReason value);
inline bool IsKnownEnumValue(CookieExclusionReason value) {
  return internal::CookieExclusionReason_Data::IsKnownValue(
      static_cast<int32_t>(value));
}


enum class CookieWarningReason : int32_t {
  
  kWarnSameSiteUnspecifiedCrossSiteContext = 0,
  
  kWarnSameSiteNoneInsecure = 1,
  
  kWarnSameSiteUnspecifiedLaxAllowUnsafe = 2,
  
  kWarnSameSiteStrictLaxDowngradeStrict = 3,
  
  kWarnSameSiteStrictCrossDowngradeStrict = 4,
  
  kWarnSameSiteStrictCrossDowngradeLax = 5,
  
  kWarnSameSiteLaxCrossDowngradeStrict = 6,
  
  kWarnSameSiteLaxCrossDowngradeLax = 7,
  
  kWarnAttributeValueExceedsMaxSize = 8,
  
  kWarnDomainNonASCII = 9,
  kMinValue = 0,
  kMaxValue = 9,
};

COMPONENT_EXPORT(MOJOM_SHARED_BLINK_COMMON_EXPORT) std::ostream& operator<<(std::ostream& os, CookieWarningReason value);
inline bool IsKnownEnumValue(CookieWarningReason value) {
  return internal::CookieWarningReason_Data::IsKnownValue(
      static_cast<int32_t>(value));
}


enum class SharedArrayBufferIssueType : int32_t {
  
  kTransferIssue = 0,
  
  kCreationIssue = 1,
  kMinValue = 0,
  kMaxValue = 1,
};

COMPONENT_EXPORT(MOJOM_SHARED_BLINK_COMMON_EXPORT) std::ostream& operator<<(std::ostream& os, SharedArrayBufferIssueType value);
inline bool IsKnownEnumValue(SharedArrayBufferIssueType value) {
  return internal::SharedArrayBufferIssueType_Data::IsKnownValue(
      static_cast<int32_t>(value));
}


enum class TwaQualityEnforcementViolationType : int32_t {
  
  kHttpError = 0,
  
  kUnavailableOffline = 1,
  
  kDigitalAssetLinks = 2,
  kMinValue = 0,
  kMaxValue = 2,
};

COMPONENT_EXPORT(MOJOM_SHARED_BLINK_COMMON_EXPORT) std::ostream& operator<<(std::ostream& os, TwaQualityEnforcementViolationType value);
inline bool IsKnownEnumValue(TwaQualityEnforcementViolationType value) {
  return internal::TwaQualityEnforcementViolationType_Data::IsKnownValue(
      static_cast<int32_t>(value));
}


enum class FederatedAuthRequestResult : int32_t {
  
  kSuccess = 0,
  
  kApprovalDeclined = 1,
  
  kErrorDisabledInSettings = 2,
  
  kErrorTooManyRequests = 3,
  
  kErrorFetchingManifestListHttpNotFound = 4,
  
  kErrorFetchingManifestListNoResponse = 5,
  
  kErrorFetchingManifestListInvalidResponse = 6,
  
  kErrorManifestNotInManifestList = 7,
  
  kErrorManifestListTooBig = 8,
  
  kErrorFetchingManifestHttpNotFound = 9,
  
  kErrorFetchingManifestNoResponse = 10,
  
  kErrorFetchingManifestInvalidResponse = 11,
  
  kErrorFetchingClientMetadataHttpNotFound = 12,
  
  kErrorFetchingClientMetadataNoResponse = 13,
  
  kErrorFetchingClientMetadataInvalidResponse = 14,
  
  kErrorFetchingAccountsHttpNotFound = 15,
  
  kErrorFetchingAccountsNoResponse = 16,
  
  kErrorFetchingAccountsInvalidResponse = 17,
  
  kErrorFetchingIdTokenHttpNotFound = 18,
  
  kErrorFetchingIdTokenNoResponse = 19,
  
  kErrorFetchingIdTokenInvalidResponse = 20,
  
  kErrorCanceled = 21,
  
  kError = 22,
  kMinValue = 0,
  kMaxValue = 22,
};

COMPONENT_EXPORT(MOJOM_SHARED_BLINK_COMMON_EXPORT) std::ostream& operator<<(std::ostream& os, FederatedAuthRequestResult value);
inline bool IsKnownEnumValue(FederatedAuthRequestResult value) {
  return internal::FederatedAuthRequestResult_Data::IsKnownValue(
      static_cast<int32_t>(value));
}


enum class GenericIssueErrorType : int32_t {
  
  kCrossOriginPortalPostMessageError = 0,
  kMinValue = 0,
  kMaxValue = 0,
};

COMPONENT_EXPORT(MOJOM_SHARED_BLINK_COMMON_EXPORT) std::ostream& operator<<(std::ostream& os, GenericIssueErrorType value);
inline bool IsKnownEnumValue(GenericIssueErrorType value) {
  return internal::GenericIssueErrorType_Data::IsKnownValue(
      static_cast<int32_t>(value));
}


class AffectedCookieDataView {
 public:
  AffectedCookieDataView() = default;

  AffectedCookieDataView(
      internal::AffectedCookie_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  inline void GetNameDataView(
      mojo::StringDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadName(UserType* output) {
    
    auto* pointer = data_->name.Get();
    return mojo::internal::Deserialize<mojo::StringDataView>(
        pointer, output, message_);
  }
  inline void GetPathDataView(
      mojo::StringDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadPath(UserType* output) {
    
    auto* pointer = data_->path.Get();
    return mojo::internal::Deserialize<mojo::StringDataView>(
        pointer, output, message_);
  }
  inline void GetDomainDataView(
      mojo::StringDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadDomain(UserType* output) {
    
    auto* pointer = data_->domain.Get();
    return mojo::internal::Deserialize<mojo::StringDataView>(
        pointer, output, message_);
  }
 private:
  internal::AffectedCookie_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class AffectedRequestDataView {
 public:
  AffectedRequestDataView() = default;

  AffectedRequestDataView(
      internal::AffectedRequest_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  inline void GetRequestIdDataView(
      mojo::StringDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadRequestId(UserType* output) {
    
    auto* pointer = data_->request_id.Get();
    return mojo::internal::Deserialize<mojo::StringDataView>(
        pointer, output, message_);
  }
  inline void GetUrlDataView(
      mojo::StringDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadUrl(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        mojo::StringDataView, UserType>(),
    "Attempting to read the optional `url` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadUrl` instead "
    "of `ReadUrl if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->url.Get();
    return mojo::internal::Deserialize<mojo::StringDataView>(
        pointer, output, message_);
  }
 private:
  internal::AffectedRequest_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class AffectedFrameDataView {
 public:
  AffectedFrameDataView() = default;

  AffectedFrameDataView(
      internal::AffectedFrame_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  inline void GetFrameIdDataView(
      mojo::StringDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadFrameId(UserType* output) {
    
    auto* pointer = data_->frame_id.Get();
    return mojo::internal::Deserialize<mojo::StringDataView>(
        pointer, output, message_);
  }
 private:
  internal::AffectedFrame_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class AffectedLocationDataView {
 public:
  AffectedLocationDataView() = default;

  AffectedLocationDataView(
      internal::AffectedLocation_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  inline void GetScriptIdDataView(
      mojo::StringDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadScriptId(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        mojo::StringDataView, UserType>(),
    "Attempting to read the optional `script_id` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadScriptId` instead "
    "of `ReadScriptId if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->script_id.Get();
    return mojo::internal::Deserialize<mojo::StringDataView>(
        pointer, output, message_);
  }
  inline void GetUrlDataView(
      mojo::StringDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadUrl(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        mojo::StringDataView, UserType>(),
    "Attempting to read the optional `url` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadUrl` instead "
    "of `ReadUrl if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->url.Get();
    return mojo::internal::Deserialize<mojo::StringDataView>(
        pointer, output, message_);
  }
  uint32_t line() const {
    return data_->line;
  }
  uint32_t column() const {
    return data_->column;
  }
 private:
  internal::AffectedLocation_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class BlockedByResponseIssueDetailsDataView {
 public:
  BlockedByResponseIssueDetailsDataView() = default;

  BlockedByResponseIssueDetailsDataView(
      internal::BlockedByResponseIssueDetails_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  inline void GetRequestDataView(
      AffectedRequestDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadRequest(UserType* output) {
    
    auto* pointer = data_->request.Get();
    return mojo::internal::Deserialize<::blink::mojom::AffectedRequestDataView>(
        pointer, output, message_);
  }
  inline void GetParentFrameDataView(
      AffectedFrameDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadParentFrame(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::blink::mojom::AffectedFrameDataView, UserType>(),
    "Attempting to read the optional `parentFrame` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadParentFrame` instead "
    "of `ReadParentFrame if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->parentFrame.Get();
    return mojo::internal::Deserialize<::blink::mojom::AffectedFrameDataView>(
        pointer, output, message_);
  }
  inline void GetBlockedFrameDataView(
      AffectedFrameDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadBlockedFrame(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::blink::mojom::AffectedFrameDataView, UserType>(),
    "Attempting to read the optional `blockedFrame` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadBlockedFrame` instead "
    "of `ReadBlockedFrame if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->blockedFrame.Get();
    return mojo::internal::Deserialize<::blink::mojom::AffectedFrameDataView>(
        pointer, output, message_);
  }
  template <typename UserType>
  [[nodiscard]] bool ReadReason(UserType* output) const {
    auto data_value = data_->reason;
    return mojo::internal::Deserialize<::network::mojom::BlockedByResponseReason>(
        data_value, output);
  }
  ::network::mojom::BlockedByResponseReason reason() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::network::mojom::BlockedByResponseReason>(data_->reason));
  }
 private:
  internal::BlockedByResponseIssueDetails_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class HeavyAdIssueDetailsDataView {
 public:
  HeavyAdIssueDetailsDataView() = default;

  HeavyAdIssueDetailsDataView(
      internal::HeavyAdIssueDetails_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  template <typename UserType>
  [[nodiscard]] bool ReadResolution(UserType* output) const {
    auto data_value = data_->resolution;
    return mojo::internal::Deserialize<::blink::mojom::HeavyAdResolutionStatus>(
        data_value, output);
  }
  HeavyAdResolutionStatus resolution() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::blink::mojom::HeavyAdResolutionStatus>(data_->resolution));
  }
  template <typename UserType>
  [[nodiscard]] bool ReadReason(UserType* output) const {
    auto data_value = data_->reason;
    return mojo::internal::Deserialize<::blink::mojom::HeavyAdReason>(
        data_value, output);
  }
  HeavyAdReason reason() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::blink::mojom::HeavyAdReason>(data_->reason));
  }
  inline void GetFrameDataView(
      AffectedFrameDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadFrame(UserType* output) {
    
    auto* pointer = data_->frame.Get();
    return mojo::internal::Deserialize<::blink::mojom::AffectedFrameDataView>(
        pointer, output, message_);
  }
 private:
  internal::HeavyAdIssueDetails_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class MixedContentIssueDetailsDataView {
 public:
  MixedContentIssueDetailsDataView() = default;

  MixedContentIssueDetailsDataView(
      internal::MixedContentIssueDetails_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  template <typename UserType>
  [[nodiscard]] bool ReadRequestContext(UserType* output) const {
    auto data_value = data_->request_context;
    return mojo::internal::Deserialize<::blink::mojom::RequestContextType>(
        data_value, output);
  }
  ::blink::mojom::RequestContextType request_context() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::blink::mojom::RequestContextType>(data_->request_context));
  }
  template <typename UserType>
  [[nodiscard]] bool ReadResolutionStatus(UserType* output) const {
    auto data_value = data_->resolution_status;
    return mojo::internal::Deserialize<::blink::mojom::MixedContentResolutionStatus>(
        data_value, output);
  }
  MixedContentResolutionStatus resolution_status() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::blink::mojom::MixedContentResolutionStatus>(data_->resolution_status));
  }
  inline void GetInsecureUrlDataView(
      mojo::StringDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadInsecureUrl(UserType* output) {
    
    auto* pointer = data_->insecure_url.Get();
    return mojo::internal::Deserialize<mojo::StringDataView>(
        pointer, output, message_);
  }
  inline void GetMainResourceUrlDataView(
      mojo::StringDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadMainResourceUrl(UserType* output) {
    
    auto* pointer = data_->main_resource_url.Get();
    return mojo::internal::Deserialize<mojo::StringDataView>(
        pointer, output, message_);
  }
  inline void GetRequestDataView(
      AffectedRequestDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadRequest(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::blink::mojom::AffectedRequestDataView, UserType>(),
    "Attempting to read the optional `request` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadRequest` instead "
    "of `ReadRequest if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->request.Get();
    return mojo::internal::Deserialize<::blink::mojom::AffectedRequestDataView>(
        pointer, output, message_);
  }
  inline void GetFrameDataView(
      AffectedFrameDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadFrame(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::blink::mojom::AffectedFrameDataView, UserType>(),
    "Attempting to read the optional `frame` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadFrame` instead "
    "of `ReadFrame if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->frame.Get();
    return mojo::internal::Deserialize<::blink::mojom::AffectedFrameDataView>(
        pointer, output, message_);
  }
 private:
  internal::MixedContentIssueDetails_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class ContentSecurityPolicyIssueDetailsDataView {
 public:
  ContentSecurityPolicyIssueDetailsDataView() = default;

  ContentSecurityPolicyIssueDetailsDataView(
      internal::ContentSecurityPolicyIssueDetails_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  inline void GetBlockedUrlDataView(
      ::url::mojom::UrlDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadBlockedUrl(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::url::mojom::UrlDataView, UserType>(),
    "Attempting to read the optional `blocked_url` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadBlockedUrl` instead "
    "of `ReadBlockedUrl if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->blocked_url.Get();
    return mojo::internal::Deserialize<::url::mojom::UrlDataView>(
        pointer, output, message_);
  }
  inline void GetViolatedDirectiveDataView(
      mojo::StringDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadViolatedDirective(UserType* output) {
    
    auto* pointer = data_->violated_directive.Get();
    return mojo::internal::Deserialize<mojo::StringDataView>(
        pointer, output, message_);
  }
  bool is_report_only() const {
    return data_->is_report_only;
  }
  template <typename UserType>
  [[nodiscard]] bool ReadContentSecurityPolicyViolationType(UserType* output) const {
    auto data_value = data_->content_security_policy_violation_type;
    return mojo::internal::Deserialize<::blink::mojom::ContentSecurityPolicyViolationType>(
        data_value, output);
  }
  ContentSecurityPolicyViolationType content_security_policy_violation_type() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::blink::mojom::ContentSecurityPolicyViolationType>(data_->content_security_policy_violation_type));
  }
  inline void GetFrameAncestorDataView(
      AffectedFrameDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadFrameAncestor(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::blink::mojom::AffectedFrameDataView, UserType>(),
    "Attempting to read the optional `frame_ancestor` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadFrameAncestor` instead "
    "of `ReadFrameAncestor if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->frame_ancestor.Get();
    return mojo::internal::Deserialize<::blink::mojom::AffectedFrameDataView>(
        pointer, output, message_);
  }
  inline void GetAffectedLocationDataView(
      AffectedLocationDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadAffectedLocation(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::blink::mojom::AffectedLocationDataView, UserType>(),
    "Attempting to read the optional `affected_location` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadAffectedLocation` instead "
    "of `ReadAffectedLocation if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->affected_location.Get();
    return mojo::internal::Deserialize<::blink::mojom::AffectedLocationDataView>(
        pointer, output, message_);
  }
  int32_t violating_node_id() const {
    return data_->violating_node_id;
  }
 private:
  internal::ContentSecurityPolicyIssueDetails_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class CookieIssueDetailsDataView {
 public:
  CookieIssueDetailsDataView() = default;

  CookieIssueDetailsDataView(
      internal::CookieIssueDetails_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  inline void GetCookieDataView(
      AffectedCookieDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadCookie(UserType* output) {
    
    auto* pointer = data_->cookie.Get();
    return mojo::internal::Deserialize<::blink::mojom::AffectedCookieDataView>(
        pointer, output, message_);
  }
  inline void GetExclusionReasonDataView(
      mojo::ArrayDataView<CookieExclusionReason>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadExclusionReason(UserType* output) {
    
    auto* pointer = data_->exclusion_reason.Get();
    return mojo::internal::Deserialize<mojo::ArrayDataView<::blink::mojom::CookieExclusionReason>>(
        pointer, output, message_);
  }
  inline void GetWarningReasonDataView(
      mojo::ArrayDataView<CookieWarningReason>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadWarningReason(UserType* output) {
    
    auto* pointer = data_->warning_reason.Get();
    return mojo::internal::Deserialize<mojo::ArrayDataView<::blink::mojom::CookieWarningReason>>(
        pointer, output, message_);
  }
  template <typename UserType>
  [[nodiscard]] bool ReadOperation(UserType* output) const {
    auto data_value = data_->operation;
    return mojo::internal::Deserialize<::blink::mojom::CookieOperation>(
        data_value, output);
  }
  CookieOperation operation() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::blink::mojom::CookieOperation>(data_->operation));
  }
  inline void GetSiteForCookiesDataView(
      ::url::mojom::UrlDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadSiteForCookies(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::url::mojom::UrlDataView, UserType>(),
    "Attempting to read the optional `site_for_cookies` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadSiteForCookies` instead "
    "of `ReadSiteForCookies if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->site_for_cookies.Get();
    return mojo::internal::Deserialize<::url::mojom::UrlDataView>(
        pointer, output, message_);
  }
  inline void GetCookieUrlDataView(
      ::url::mojom::UrlDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadCookieUrl(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::url::mojom::UrlDataView, UserType>(),
    "Attempting to read the optional `cookie_url` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadCookieUrl` instead "
    "of `ReadCookieUrl if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->cookie_url.Get();
    return mojo::internal::Deserialize<::url::mojom::UrlDataView>(
        pointer, output, message_);
  }
  inline void GetRequestDataView(
      AffectedRequestDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadRequest(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::blink::mojom::AffectedRequestDataView, UserType>(),
    "Attempting to read the optional `request` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadRequest` instead "
    "of `ReadRequest if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->request.Get();
    return mojo::internal::Deserialize<::blink::mojom::AffectedRequestDataView>(
        pointer, output, message_);
  }
 private:
  internal::CookieIssueDetails_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class SharedArrayBufferIssueDetailsDataView {
 public:
  SharedArrayBufferIssueDetailsDataView() = default;

  SharedArrayBufferIssueDetailsDataView(
      internal::SharedArrayBufferIssueDetails_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  inline void GetAffectedLocationDataView(
      AffectedLocationDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadAffectedLocation(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::blink::mojom::AffectedLocationDataView, UserType>(),
    "Attempting to read the optional `affected_location` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadAffectedLocation` instead "
    "of `ReadAffectedLocation if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->affected_location.Get();
    return mojo::internal::Deserialize<::blink::mojom::AffectedLocationDataView>(
        pointer, output, message_);
  }
  bool is_warning() const {
    return data_->is_warning;
  }
  template <typename UserType>
  [[nodiscard]] bool ReadType(UserType* output) const {
    auto data_value = data_->type;
    return mojo::internal::Deserialize<::blink::mojom::SharedArrayBufferIssueType>(
        data_value, output);
  }
  SharedArrayBufferIssueType type() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::blink::mojom::SharedArrayBufferIssueType>(data_->type));
  }
 private:
  internal::SharedArrayBufferIssueDetails_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class TrustedWebActivityIssueDetailsDataView {
 public:
  TrustedWebActivityIssueDetailsDataView() = default;

  TrustedWebActivityIssueDetailsDataView(
      internal::TrustedWebActivityIssueDetails_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  inline void GetUrlDataView(
      ::url::mojom::UrlDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadUrl(UserType* output) {
    
    auto* pointer = data_->url.Get();
    return mojo::internal::Deserialize<::url::mojom::UrlDataView>(
        pointer, output, message_);
  }
  template <typename UserType>
  [[nodiscard]] bool ReadViolationType(UserType* output) const {
    auto data_value = data_->violation_type;
    return mojo::internal::Deserialize<::blink::mojom::TwaQualityEnforcementViolationType>(
        data_value, output);
  }
  TwaQualityEnforcementViolationType violation_type() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::blink::mojom::TwaQualityEnforcementViolationType>(data_->violation_type));
  }
  int32_t http_error_code() const {
    return data_->http_error_code;
  }
  inline void GetPackageNameDataView(
      mojo::StringDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadPackageName(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        mojo::StringDataView, UserType>(),
    "Attempting to read the optional `package_name` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadPackageName` instead "
    "of `ReadPackageName if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->package_name.Get();
    return mojo::internal::Deserialize<mojo::StringDataView>(
        pointer, output, message_);
  }
  inline void GetSignatureDataView(
      mojo::StringDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadSignature(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        mojo::StringDataView, UserType>(),
    "Attempting to read the optional `signature` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadSignature` instead "
    "of `ReadSignature if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->signature.Get();
    return mojo::internal::Deserialize<mojo::StringDataView>(
        pointer, output, message_);
  }
 private:
  internal::TrustedWebActivityIssueDetails_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class LowTextContrastIssueDataView {
 public:
  LowTextContrastIssueDataView() = default;

  LowTextContrastIssueDataView(
      internal::LowTextContrastIssue_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  int32_t violating_node_id() const {
    return data_->violating_node_id;
  }
  inline void GetViolatingNodeSelectorDataView(
      mojo::StringDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadViolatingNodeSelector(UserType* output) {
    
    auto* pointer = data_->violating_node_selector.Get();
    return mojo::internal::Deserialize<mojo::StringDataView>(
        pointer, output, message_);
  }
  float contrast_ratio() const {
    return data_->contrast_ratio;
  }
  float threshold_aa() const {
    return data_->threshold_aa;
  }
  float threshold_aaa() const {
    return data_->threshold_aaa;
  }
  inline void GetFontSizeDataView(
      mojo::StringDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadFontSize(UserType* output) {
    
    auto* pointer = data_->font_size.Get();
    return mojo::internal::Deserialize<mojo::StringDataView>(
        pointer, output, message_);
  }
  inline void GetFontWeightDataView(
      mojo::StringDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadFontWeight(UserType* output) {
    
    auto* pointer = data_->font_weight.Get();
    return mojo::internal::Deserialize<mojo::StringDataView>(
        pointer, output, message_);
  }
 private:
  internal::LowTextContrastIssue_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class FederatedAuthRequestIssueDetailsDataView {
 public:
  FederatedAuthRequestIssueDetailsDataView() = default;

  FederatedAuthRequestIssueDetailsDataView(
      internal::FederatedAuthRequestIssueDetails_Data* data,
      mojo::Message* message)
      : data_(data) {}

  bool is_null() const { return !data_; }
  template <typename UserType>
  [[nodiscard]] bool ReadStatus(UserType* output) const {
    auto data_value = data_->status;
    return mojo::internal::Deserialize<::blink::mojom::FederatedAuthRequestResult>(
        data_value, output);
  }
  FederatedAuthRequestResult status() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::blink::mojom::FederatedAuthRequestResult>(data_->status));
  }
 private:
  internal::FederatedAuthRequestIssueDetails_Data* data_ = nullptr;
};



class GenericIssueDetailsDataView {
 public:
  GenericIssueDetailsDataView() = default;

  GenericIssueDetailsDataView(
      internal::GenericIssueDetails_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  template <typename UserType>
  [[nodiscard]] bool ReadErrorType(UserType* output) const {
    auto data_value = data_->error_type;
    return mojo::internal::Deserialize<::blink::mojom::GenericIssueErrorType>(
        data_value, output);
  }
  GenericIssueErrorType error_type() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::blink::mojom::GenericIssueErrorType>(data_->error_type));
  }
  inline void GetFrameIdDataView(
      mojo::StringDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadFrameId(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        mojo::StringDataView, UserType>(),
    "Attempting to read the optional `frame_id` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadFrameId` instead "
    "of `ReadFrameId if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->frame_id.Get();
    return mojo::internal::Deserialize<mojo::StringDataView>(
        pointer, output, message_);
  }
 private:
  internal::GenericIssueDetails_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class InspectorIssueDetailsDataView {
 public:
  InspectorIssueDetailsDataView() = default;

  InspectorIssueDetailsDataView(
      internal::InspectorIssueDetails_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  inline void GetCookieIssueDetailsDataView(
      CookieIssueDetailsDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadCookieIssueDetails(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::blink::mojom::CookieIssueDetailsDataView, UserType>(),
    "Attempting to read the optional `cookie_issue_details` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadCookieIssueDetails` instead "
    "of `ReadCookieIssueDetails if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->cookie_issue_details.Get();
    return mojo::internal::Deserialize<::blink::mojom::CookieIssueDetailsDataView>(
        pointer, output, message_);
  }
  inline void GetMixedContentIssueDetailsDataView(
      MixedContentIssueDetailsDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadMixedContentIssueDetails(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::blink::mojom::MixedContentIssueDetailsDataView, UserType>(),
    "Attempting to read the optional `mixed_content_issue_details` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadMixedContentIssueDetails` instead "
    "of `ReadMixedContentIssueDetails if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->mixed_content_issue_details.Get();
    return mojo::internal::Deserialize<::blink::mojom::MixedContentIssueDetailsDataView>(
        pointer, output, message_);
  }
  inline void GetBlockedByResponseIssueDetailsDataView(
      BlockedByResponseIssueDetailsDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadBlockedByResponseIssueDetails(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::blink::mojom::BlockedByResponseIssueDetailsDataView, UserType>(),
    "Attempting to read the optional `blocked_by_response_issue_details` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadBlockedByResponseIssueDetails` instead "
    "of `ReadBlockedByResponseIssueDetails if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->blocked_by_response_issue_details.Get();
    return mojo::internal::Deserialize<::blink::mojom::BlockedByResponseIssueDetailsDataView>(
        pointer, output, message_);
  }
  inline void GetCspIssueDetailsDataView(
      ContentSecurityPolicyIssueDetailsDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadCspIssueDetails(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::blink::mojom::ContentSecurityPolicyIssueDetailsDataView, UserType>(),
    "Attempting to read the optional `csp_issue_details` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadCspIssueDetails` instead "
    "of `ReadCspIssueDetails if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->csp_issue_details.Get();
    return mojo::internal::Deserialize<::blink::mojom::ContentSecurityPolicyIssueDetailsDataView>(
        pointer, output, message_);
  }
  inline void GetSabIssueDetailsDataView(
      SharedArrayBufferIssueDetailsDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadSabIssueDetails(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::blink::mojom::SharedArrayBufferIssueDetailsDataView, UserType>(),
    "Attempting to read the optional `sab_issue_details` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadSabIssueDetails` instead "
    "of `ReadSabIssueDetails if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->sab_issue_details.Get();
    return mojo::internal::Deserialize<::blink::mojom::SharedArrayBufferIssueDetailsDataView>(
        pointer, output, message_);
  }
  inline void GetTwaIssueDetailsDataView(
      TrustedWebActivityIssueDetailsDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadTwaIssueDetails(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::blink::mojom::TrustedWebActivityIssueDetailsDataView, UserType>(),
    "Attempting to read the optional `twa_issue_details` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadTwaIssueDetails` instead "
    "of `ReadTwaIssueDetails if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->twa_issue_details.Get();
    return mojo::internal::Deserialize<::blink::mojom::TrustedWebActivityIssueDetailsDataView>(
        pointer, output, message_);
  }
  inline void GetHeavyAdIssueDetailsDataView(
      HeavyAdIssueDetailsDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadHeavyAdIssueDetails(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::blink::mojom::HeavyAdIssueDetailsDataView, UserType>(),
    "Attempting to read the optional `heavy_ad_issue_details` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadHeavyAdIssueDetails` instead "
    "of `ReadHeavyAdIssueDetails if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->heavy_ad_issue_details.Get();
    return mojo::internal::Deserialize<::blink::mojom::HeavyAdIssueDetailsDataView>(
        pointer, output, message_);
  }
  inline void GetLowTextContrastDetailsDataView(
      LowTextContrastIssueDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadLowTextContrastDetails(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::blink::mojom::LowTextContrastIssueDataView, UserType>(),
    "Attempting to read the optional `low_text_contrast_details` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadLowTextContrastDetails` instead "
    "of `ReadLowTextContrastDetails if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->low_text_contrast_details.Get();
    return mojo::internal::Deserialize<::blink::mojom::LowTextContrastIssueDataView>(
        pointer, output, message_);
  }
  inline void GetFederatedAuthRequestDetailsDataView(
      FederatedAuthRequestIssueDetailsDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadFederatedAuthRequestDetails(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::blink::mojom::FederatedAuthRequestIssueDetailsDataView, UserType>(),
    "Attempting to read the optional `federated_auth_request_details` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadFederatedAuthRequestDetails` instead "
    "of `ReadFederatedAuthRequestDetails if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->federated_auth_request_details.Get();
    return mojo::internal::Deserialize<::blink::mojom::FederatedAuthRequestIssueDetailsDataView>(
        pointer, output, message_);
  }
  inline void GetGenericIssueDetailsDataView(
      GenericIssueDetailsDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadGenericIssueDetails(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::blink::mojom::GenericIssueDetailsDataView, UserType>(),
    "Attempting to read the optional `generic_issue_details` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadGenericIssueDetails` instead "
    "of `ReadGenericIssueDetails if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->generic_issue_details.Get();
    return mojo::internal::Deserialize<::blink::mojom::GenericIssueDetailsDataView>(
        pointer, output, message_);
  }
  inline void GetIssueIdDataView(
      ::mojo_base::mojom::UnguessableTokenDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadIssueId(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::mojo_base::mojom::UnguessableTokenDataView, UserType>(),
    "Attempting to read the optional `issue_id` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadIssueId` instead "
    "of `ReadIssueId if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->issue_id.Get();
    return mojo::internal::Deserialize<::mojo_base::mojom::UnguessableTokenDataView>(
        pointer, output, message_);
  }
 private:
  internal::InspectorIssueDetails_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class InspectorIssueInfoDataView {
 public:
  InspectorIssueInfoDataView() = default;

  InspectorIssueInfoDataView(
      internal::InspectorIssueInfo_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  template <typename UserType>
  [[nodiscard]] bool ReadCode(UserType* output) const {
    auto data_value = data_->code;
    return mojo::internal::Deserialize<::blink::mojom::InspectorIssueCode>(
        data_value, output);
  }
  InspectorIssueCode code() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::blink::mojom::InspectorIssueCode>(data_->code));
  }
  inline void GetDetailsDataView(
      InspectorIssueDetailsDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadDetails(UserType* output) {
    
    auto* pointer = data_->details.Get();
    return mojo::internal::Deserialize<::blink::mojom::InspectorIssueDetailsDataView>(
        pointer, output, message_);
  }
 private:
  internal::InspectorIssueInfo_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



}  // namespace mojom
}  // namespace blink

namespace std {

template <>
struct hash<::blink::mojom::InspectorIssueCode>
    : public mojo::internal::EnumHashImpl<::blink::mojom::InspectorIssueCode> {};

template <>
struct hash<::blink::mojom::HeavyAdResolutionStatus>
    : public mojo::internal::EnumHashImpl<::blink::mojom::HeavyAdResolutionStatus> {};

template <>
struct hash<::blink::mojom::HeavyAdReason>
    : public mojo::internal::EnumHashImpl<::blink::mojom::HeavyAdReason> {};

template <>
struct hash<::blink::mojom::MixedContentResolutionStatus>
    : public mojo::internal::EnumHashImpl<::blink::mojom::MixedContentResolutionStatus> {};

template <>
struct hash<::blink::mojom::ContentSecurityPolicyViolationType>
    : public mojo::internal::EnumHashImpl<::blink::mojom::ContentSecurityPolicyViolationType> {};

template <>
struct hash<::blink::mojom::CookieOperation>
    : public mojo::internal::EnumHashImpl<::blink::mojom::CookieOperation> {};

template <>
struct hash<::blink::mojom::CookieExclusionReason>
    : public mojo::internal::EnumHashImpl<::blink::mojom::CookieExclusionReason> {};

template <>
struct hash<::blink::mojom::CookieWarningReason>
    : public mojo::internal::EnumHashImpl<::blink::mojom::CookieWarningReason> {};

template <>
struct hash<::blink::mojom::SharedArrayBufferIssueType>
    : public mojo::internal::EnumHashImpl<::blink::mojom::SharedArrayBufferIssueType> {};

template <>
struct hash<::blink::mojom::TwaQualityEnforcementViolationType>
    : public mojo::internal::EnumHashImpl<::blink::mojom::TwaQualityEnforcementViolationType> {};

template <>
struct hash<::blink::mojom::FederatedAuthRequestResult>
    : public mojo::internal::EnumHashImpl<::blink::mojom::FederatedAuthRequestResult> {};

template <>
struct hash<::blink::mojom::GenericIssueErrorType>
    : public mojo::internal::EnumHashImpl<::blink::mojom::GenericIssueErrorType> {};

}  // namespace std

namespace mojo {


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::blink::mojom::InspectorIssueCode, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::blink::mojom::InspectorIssueCode, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::blink::mojom::InspectorIssueCode>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::blink::mojom::HeavyAdResolutionStatus, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::blink::mojom::HeavyAdResolutionStatus, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::blink::mojom::HeavyAdResolutionStatus>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::blink::mojom::HeavyAdReason, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::blink::mojom::HeavyAdReason, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::blink::mojom::HeavyAdReason>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::blink::mojom::MixedContentResolutionStatus, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::blink::mojom::MixedContentResolutionStatus, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::blink::mojom::MixedContentResolutionStatus>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::blink::mojom::ContentSecurityPolicyViolationType, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::blink::mojom::ContentSecurityPolicyViolationType, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::blink::mojom::ContentSecurityPolicyViolationType>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::blink::mojom::CookieOperation, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::blink::mojom::CookieOperation, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::blink::mojom::CookieOperation>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::blink::mojom::CookieExclusionReason, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::blink::mojom::CookieExclusionReason, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::blink::mojom::CookieExclusionReason>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::blink::mojom::CookieWarningReason, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::blink::mojom::CookieWarningReason, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::blink::mojom::CookieWarningReason>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::blink::mojom::SharedArrayBufferIssueType, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::blink::mojom::SharedArrayBufferIssueType, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::blink::mojom::SharedArrayBufferIssueType>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::blink::mojom::TwaQualityEnforcementViolationType, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::blink::mojom::TwaQualityEnforcementViolationType, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::blink::mojom::TwaQualityEnforcementViolationType>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::blink::mojom::FederatedAuthRequestResult, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::blink::mojom::FederatedAuthRequestResult, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::blink::mojom::FederatedAuthRequestResult>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::blink::mojom::GenericIssueErrorType, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::blink::mojom::GenericIssueErrorType, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::blink::mojom::GenericIssueErrorType>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::blink::mojom::AffectedCookieDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::blink::mojom::AffectedCookieDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::blink::mojom::internal::AffectedCookie_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    decltype(Traits::name(input)) in_name = Traits::name(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->name)::BaseType> name_fragment(
            fragment.message());
    mojo::internal::Serialize<mojo::StringDataView>(
        in_name, name_fragment);
    fragment->name.Set(
        name_fragment.is_null() ? nullptr : name_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->name.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null name in AffectedCookie struct");
    decltype(Traits::path(input)) in_path = Traits::path(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->path)::BaseType> path_fragment(
            fragment.message());
    mojo::internal::Serialize<mojo::StringDataView>(
        in_path, path_fragment);
    fragment->path.Set(
        path_fragment.is_null() ? nullptr : path_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->path.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null path in AffectedCookie struct");
    decltype(Traits::domain(input)) in_domain = Traits::domain(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->domain)::BaseType> domain_fragment(
            fragment.message());
    mojo::internal::Serialize<mojo::StringDataView>(
        in_domain, domain_fragment);
    fragment->domain.Set(
        domain_fragment.is_null() ? nullptr : domain_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->domain.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null domain in AffectedCookie struct");
  }

  static bool Deserialize(::blink::mojom::internal::AffectedCookie_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::blink::mojom::AffectedCookieDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::blink::mojom::AffectedRequestDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::blink::mojom::AffectedRequestDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::blink::mojom::internal::AffectedRequest_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    decltype(Traits::request_id(input)) in_request_id = Traits::request_id(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->request_id)::BaseType> request_id_fragment(
            fragment.message());
    mojo::internal::Serialize<mojo::StringDataView>(
        in_request_id, request_id_fragment);
    fragment->request_id.Set(
        request_id_fragment.is_null() ? nullptr : request_id_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->request_id.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null request_id in AffectedRequest struct");
    decltype(Traits::url(input)) in_url = Traits::url(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->url)::BaseType> url_fragment(
            fragment.message());
    mojo::internal::Serialize<mojo::StringDataView>(
        in_url, url_fragment);
    fragment->url.Set(
        url_fragment.is_null() ? nullptr : url_fragment.data());
  }

  static bool Deserialize(::blink::mojom::internal::AffectedRequest_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::blink::mojom::AffectedRequestDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::blink::mojom::AffectedFrameDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::blink::mojom::AffectedFrameDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::blink::mojom::internal::AffectedFrame_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    decltype(Traits::frame_id(input)) in_frame_id = Traits::frame_id(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->frame_id)::BaseType> frame_id_fragment(
            fragment.message());
    mojo::internal::Serialize<mojo::StringDataView>(
        in_frame_id, frame_id_fragment);
    fragment->frame_id.Set(
        frame_id_fragment.is_null() ? nullptr : frame_id_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->frame_id.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null frame_id in AffectedFrame struct");
  }

  static bool Deserialize(::blink::mojom::internal::AffectedFrame_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::blink::mojom::AffectedFrameDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::blink::mojom::AffectedLocationDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::blink::mojom::AffectedLocationDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::blink::mojom::internal::AffectedLocation_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    decltype(Traits::script_id(input)) in_script_id = Traits::script_id(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->script_id)::BaseType> script_id_fragment(
            fragment.message());
    mojo::internal::Serialize<mojo::StringDataView>(
        in_script_id, script_id_fragment);
    fragment->script_id.Set(
        script_id_fragment.is_null() ? nullptr : script_id_fragment.data());
    decltype(Traits::url(input)) in_url = Traits::url(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->url)::BaseType> url_fragment(
            fragment.message());
    mojo::internal::Serialize<mojo::StringDataView>(
        in_url, url_fragment);
    fragment->url.Set(
        url_fragment.is_null() ? nullptr : url_fragment.data());
    fragment->line = Traits::line(input);
    fragment->column = Traits::column(input);
  }

  static bool Deserialize(::blink::mojom::internal::AffectedLocation_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::blink::mojom::AffectedLocationDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::blink::mojom::BlockedByResponseIssueDetailsDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::blink::mojom::BlockedByResponseIssueDetailsDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::blink::mojom::internal::BlockedByResponseIssueDetails_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    decltype(Traits::request(input)) in_request = Traits::request(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->request)::BaseType> request_fragment(
            fragment.message());
    mojo::internal::Serialize<::blink::mojom::AffectedRequestDataView>(
        in_request, request_fragment);
    fragment->request.Set(
        request_fragment.is_null() ? nullptr : request_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->request.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null request in BlockedByResponseIssueDetails struct");
    decltype(Traits::parentFrame(input)) in_parentFrame = Traits::parentFrame(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->parentFrame)::BaseType> parentFrame_fragment(
            fragment.message());
    mojo::internal::Serialize<::blink::mojom::AffectedFrameDataView>(
        in_parentFrame, parentFrame_fragment);
    fragment->parentFrame.Set(
        parentFrame_fragment.is_null() ? nullptr : parentFrame_fragment.data());
    decltype(Traits::blockedFrame(input)) in_blockedFrame = Traits::blockedFrame(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->blockedFrame)::BaseType> blockedFrame_fragment(
            fragment.message());
    mojo::internal::Serialize<::blink::mojom::AffectedFrameDataView>(
        in_blockedFrame, blockedFrame_fragment);
    fragment->blockedFrame.Set(
        blockedFrame_fragment.is_null() ? nullptr : blockedFrame_fragment.data());
    mojo::internal::Serialize<::network::mojom::BlockedByResponseReason>(
        Traits::reason(input), &fragment->reason);
  }

  static bool Deserialize(::blink::mojom::internal::BlockedByResponseIssueDetails_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::blink::mojom::BlockedByResponseIssueDetailsDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::blink::mojom::HeavyAdIssueDetailsDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::blink::mojom::HeavyAdIssueDetailsDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::blink::mojom::internal::HeavyAdIssueDetails_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    mojo::internal::Serialize<::blink::mojom::HeavyAdResolutionStatus>(
        Traits::resolution(input), &fragment->resolution);
    mojo::internal::Serialize<::blink::mojom::HeavyAdReason>(
        Traits::reason(input), &fragment->reason);
    decltype(Traits::frame(input)) in_frame = Traits::frame(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->frame)::BaseType> frame_fragment(
            fragment.message());
    mojo::internal::Serialize<::blink::mojom::AffectedFrameDataView>(
        in_frame, frame_fragment);
    fragment->frame.Set(
        frame_fragment.is_null() ? nullptr : frame_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->frame.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null frame in HeavyAdIssueDetails struct");
  }

  static bool Deserialize(::blink::mojom::internal::HeavyAdIssueDetails_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::blink::mojom::HeavyAdIssueDetailsDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::blink::mojom::MixedContentIssueDetailsDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::blink::mojom::MixedContentIssueDetailsDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::blink::mojom::internal::MixedContentIssueDetails_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    mojo::internal::Serialize<::blink::mojom::RequestContextType>(
        Traits::request_context(input), &fragment->request_context);
    mojo::internal::Serialize<::blink::mojom::MixedContentResolutionStatus>(
        Traits::resolution_status(input), &fragment->resolution_status);
    decltype(Traits::insecure_url(input)) in_insecure_url = Traits::insecure_url(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->insecure_url)::BaseType> insecure_url_fragment(
            fragment.message());
    mojo::internal::Serialize<mojo::StringDataView>(
        in_insecure_url, insecure_url_fragment);
    fragment->insecure_url.Set(
        insecure_url_fragment.is_null() ? nullptr : insecure_url_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->insecure_url.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null insecure_url in MixedContentIssueDetails struct");
    decltype(Traits::main_resource_url(input)) in_main_resource_url = Traits::main_resource_url(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->main_resource_url)::BaseType> main_resource_url_fragment(
            fragment.message());
    mojo::internal::Serialize<mojo::StringDataView>(
        in_main_resource_url, main_resource_url_fragment);
    fragment->main_resource_url.Set(
        main_resource_url_fragment.is_null() ? nullptr : main_resource_url_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->main_resource_url.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null main_resource_url in MixedContentIssueDetails struct");
    decltype(Traits::request(input)) in_request = Traits::request(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->request)::BaseType> request_fragment(
            fragment.message());
    mojo::internal::Serialize<::blink::mojom::AffectedRequestDataView>(
        in_request, request_fragment);
    fragment->request.Set(
        request_fragment.is_null() ? nullptr : request_fragment.data());
    decltype(Traits::frame(input)) in_frame = Traits::frame(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->frame)::BaseType> frame_fragment(
            fragment.message());
    mojo::internal::Serialize<::blink::mojom::AffectedFrameDataView>(
        in_frame, frame_fragment);
    fragment->frame.Set(
        frame_fragment.is_null() ? nullptr : frame_fragment.data());
  }

  static bool Deserialize(::blink::mojom::internal::MixedContentIssueDetails_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::blink::mojom::MixedContentIssueDetailsDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::blink::mojom::ContentSecurityPolicyIssueDetailsDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::blink::mojom::ContentSecurityPolicyIssueDetailsDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::blink::mojom::internal::ContentSecurityPolicyIssueDetails_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    decltype(Traits::blocked_url(input)) in_blocked_url = Traits::blocked_url(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->blocked_url)::BaseType> blocked_url_fragment(
            fragment.message());
    mojo::internal::Serialize<::url::mojom::UrlDataView>(
        in_blocked_url, blocked_url_fragment);
    fragment->blocked_url.Set(
        blocked_url_fragment.is_null() ? nullptr : blocked_url_fragment.data());
    decltype(Traits::violated_directive(input)) in_violated_directive = Traits::violated_directive(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->violated_directive)::BaseType> violated_directive_fragment(
            fragment.message());
    mojo::internal::Serialize<mojo::StringDataView>(
        in_violated_directive, violated_directive_fragment);
    fragment->violated_directive.Set(
        violated_directive_fragment.is_null() ? nullptr : violated_directive_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->violated_directive.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null violated_directive in ContentSecurityPolicyIssueDetails struct");
    fragment->is_report_only = Traits::is_report_only(input);
    mojo::internal::Serialize<::blink::mojom::ContentSecurityPolicyViolationType>(
        Traits::content_security_policy_violation_type(input), &fragment->content_security_policy_violation_type);
    decltype(Traits::frame_ancestor(input)) in_frame_ancestor = Traits::frame_ancestor(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->frame_ancestor)::BaseType> frame_ancestor_fragment(
            fragment.message());
    mojo::internal::Serialize<::blink::mojom::AffectedFrameDataView>(
        in_frame_ancestor, frame_ancestor_fragment);
    fragment->frame_ancestor.Set(
        frame_ancestor_fragment.is_null() ? nullptr : frame_ancestor_fragment.data());
    decltype(Traits::affected_location(input)) in_affected_location = Traits::affected_location(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->affected_location)::BaseType> affected_location_fragment(
            fragment.message());
    mojo::internal::Serialize<::blink::mojom::AffectedLocationDataView>(
        in_affected_location, affected_location_fragment);
    fragment->affected_location.Set(
        affected_location_fragment.is_null() ? nullptr : affected_location_fragment.data());
    fragment->violating_node_id = Traits::violating_node_id(input);
  }

  static bool Deserialize(::blink::mojom::internal::ContentSecurityPolicyIssueDetails_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::blink::mojom::ContentSecurityPolicyIssueDetailsDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::blink::mojom::CookieIssueDetailsDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::blink::mojom::CookieIssueDetailsDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::blink::mojom::internal::CookieIssueDetails_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    decltype(Traits::cookie(input)) in_cookie = Traits::cookie(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->cookie)::BaseType> cookie_fragment(
            fragment.message());
    mojo::internal::Serialize<::blink::mojom::AffectedCookieDataView>(
        in_cookie, cookie_fragment);
    fragment->cookie.Set(
        cookie_fragment.is_null() ? nullptr : cookie_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->cookie.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null cookie in CookieIssueDetails struct");
    decltype(Traits::exclusion_reason(input)) in_exclusion_reason = Traits::exclusion_reason(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->exclusion_reason)::BaseType>
        exclusion_reason_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams exclusion_reason_validate_params(
        0, ::blink::mojom::internal::CookieExclusionReason_Data::Validate);
    mojo::internal::Serialize<mojo::ArrayDataView<::blink::mojom::CookieExclusionReason>>(
        in_exclusion_reason, exclusion_reason_fragment, &exclusion_reason_validate_params);
    fragment->exclusion_reason.Set(
        exclusion_reason_fragment.is_null() ? nullptr : exclusion_reason_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->exclusion_reason.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null exclusion_reason in CookieIssueDetails struct");
    decltype(Traits::warning_reason(input)) in_warning_reason = Traits::warning_reason(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->warning_reason)::BaseType>
        warning_reason_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams warning_reason_validate_params(
        0, ::blink::mojom::internal::CookieWarningReason_Data::Validate);
    mojo::internal::Serialize<mojo::ArrayDataView<::blink::mojom::CookieWarningReason>>(
        in_warning_reason, warning_reason_fragment, &warning_reason_validate_params);
    fragment->warning_reason.Set(
        warning_reason_fragment.is_null() ? nullptr : warning_reason_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->warning_reason.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null warning_reason in CookieIssueDetails struct");
    mojo::internal::Serialize<::blink::mojom::CookieOperation>(
        Traits::operation(input), &fragment->operation);
    decltype(Traits::site_for_cookies(input)) in_site_for_cookies = Traits::site_for_cookies(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->site_for_cookies)::BaseType> site_for_cookies_fragment(
            fragment.message());
    mojo::internal::Serialize<::url::mojom::UrlDataView>(
        in_site_for_cookies, site_for_cookies_fragment);
    fragment->site_for_cookies.Set(
        site_for_cookies_fragment.is_null() ? nullptr : site_for_cookies_fragment.data());
    decltype(Traits::cookie_url(input)) in_cookie_url = Traits::cookie_url(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->cookie_url)::BaseType> cookie_url_fragment(
            fragment.message());
    mojo::internal::Serialize<::url::mojom::UrlDataView>(
        in_cookie_url, cookie_url_fragment);
    fragment->cookie_url.Set(
        cookie_url_fragment.is_null() ? nullptr : cookie_url_fragment.data());
    decltype(Traits::request(input)) in_request = Traits::request(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->request)::BaseType> request_fragment(
            fragment.message());
    mojo::internal::Serialize<::blink::mojom::AffectedRequestDataView>(
        in_request, request_fragment);
    fragment->request.Set(
        request_fragment.is_null() ? nullptr : request_fragment.data());
  }

  static bool Deserialize(::blink::mojom::internal::CookieIssueDetails_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::blink::mojom::CookieIssueDetailsDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::blink::mojom::SharedArrayBufferIssueDetailsDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::blink::mojom::SharedArrayBufferIssueDetailsDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::blink::mojom::internal::SharedArrayBufferIssueDetails_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    decltype(Traits::affected_location(input)) in_affected_location = Traits::affected_location(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->affected_location)::BaseType> affected_location_fragment(
            fragment.message());
    mojo::internal::Serialize<::blink::mojom::AffectedLocationDataView>(
        in_affected_location, affected_location_fragment);
    fragment->affected_location.Set(
        affected_location_fragment.is_null() ? nullptr : affected_location_fragment.data());
    fragment->is_warning = Traits::is_warning(input);
    mojo::internal::Serialize<::blink::mojom::SharedArrayBufferIssueType>(
        Traits::type(input), &fragment->type);
  }

  static bool Deserialize(::blink::mojom::internal::SharedArrayBufferIssueDetails_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::blink::mojom::SharedArrayBufferIssueDetailsDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::blink::mojom::TrustedWebActivityIssueDetailsDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::blink::mojom::TrustedWebActivityIssueDetailsDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::blink::mojom::internal::TrustedWebActivityIssueDetails_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    decltype(Traits::url(input)) in_url = Traits::url(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->url)::BaseType> url_fragment(
            fragment.message());
    mojo::internal::Serialize<::url::mojom::UrlDataView>(
        in_url, url_fragment);
    fragment->url.Set(
        url_fragment.is_null() ? nullptr : url_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->url.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null url in TrustedWebActivityIssueDetails struct");
    mojo::internal::Serialize<::blink::mojom::TwaQualityEnforcementViolationType>(
        Traits::violation_type(input), &fragment->violation_type);
    fragment->http_error_code = Traits::http_error_code(input);
    decltype(Traits::package_name(input)) in_package_name = Traits::package_name(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->package_name)::BaseType> package_name_fragment(
            fragment.message());
    mojo::internal::Serialize<mojo::StringDataView>(
        in_package_name, package_name_fragment);
    fragment->package_name.Set(
        package_name_fragment.is_null() ? nullptr : package_name_fragment.data());
    decltype(Traits::signature(input)) in_signature = Traits::signature(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->signature)::BaseType> signature_fragment(
            fragment.message());
    mojo::internal::Serialize<mojo::StringDataView>(
        in_signature, signature_fragment);
    fragment->signature.Set(
        signature_fragment.is_null() ? nullptr : signature_fragment.data());
  }

  static bool Deserialize(::blink::mojom::internal::TrustedWebActivityIssueDetails_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::blink::mojom::TrustedWebActivityIssueDetailsDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::blink::mojom::LowTextContrastIssueDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::blink::mojom::LowTextContrastIssueDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::blink::mojom::internal::LowTextContrastIssue_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    fragment->violating_node_id = Traits::violating_node_id(input);
    decltype(Traits::violating_node_selector(input)) in_violating_node_selector = Traits::violating_node_selector(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->violating_node_selector)::BaseType> violating_node_selector_fragment(
            fragment.message());
    mojo::internal::Serialize<mojo::StringDataView>(
        in_violating_node_selector, violating_node_selector_fragment);
    fragment->violating_node_selector.Set(
        violating_node_selector_fragment.is_null() ? nullptr : violating_node_selector_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->violating_node_selector.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null violating_node_selector in LowTextContrastIssue struct");
    fragment->contrast_ratio = Traits::contrast_ratio(input);
    fragment->threshold_aa = Traits::threshold_aa(input);
    fragment->threshold_aaa = Traits::threshold_aaa(input);
    decltype(Traits::font_size(input)) in_font_size = Traits::font_size(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->font_size)::BaseType> font_size_fragment(
            fragment.message());
    mojo::internal::Serialize<mojo::StringDataView>(
        in_font_size, font_size_fragment);
    fragment->font_size.Set(
        font_size_fragment.is_null() ? nullptr : font_size_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->font_size.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null font_size in LowTextContrastIssue struct");
    decltype(Traits::font_weight(input)) in_font_weight = Traits::font_weight(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->font_weight)::BaseType> font_weight_fragment(
            fragment.message());
    mojo::internal::Serialize<mojo::StringDataView>(
        in_font_weight, font_weight_fragment);
    fragment->font_weight.Set(
        font_weight_fragment.is_null() ? nullptr : font_weight_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->font_weight.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null font_weight in LowTextContrastIssue struct");
  }

  static bool Deserialize(::blink::mojom::internal::LowTextContrastIssue_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::blink::mojom::LowTextContrastIssueDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::blink::mojom::FederatedAuthRequestIssueDetailsDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::blink::mojom::FederatedAuthRequestIssueDetailsDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::blink::mojom::internal::FederatedAuthRequestIssueDetails_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    mojo::internal::Serialize<::blink::mojom::FederatedAuthRequestResult>(
        Traits::status(input), &fragment->status);
  }

  static bool Deserialize(::blink::mojom::internal::FederatedAuthRequestIssueDetails_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::blink::mojom::FederatedAuthRequestIssueDetailsDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::blink::mojom::GenericIssueDetailsDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::blink::mojom::GenericIssueDetailsDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::blink::mojom::internal::GenericIssueDetails_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    mojo::internal::Serialize<::blink::mojom::GenericIssueErrorType>(
        Traits::error_type(input), &fragment->error_type);
    decltype(Traits::frame_id(input)) in_frame_id = Traits::frame_id(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->frame_id)::BaseType> frame_id_fragment(
            fragment.message());
    mojo::internal::Serialize<mojo::StringDataView>(
        in_frame_id, frame_id_fragment);
    fragment->frame_id.Set(
        frame_id_fragment.is_null() ? nullptr : frame_id_fragment.data());
  }

  static bool Deserialize(::blink::mojom::internal::GenericIssueDetails_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::blink::mojom::GenericIssueDetailsDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::blink::mojom::InspectorIssueDetailsDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::blink::mojom::InspectorIssueDetailsDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::blink::mojom::internal::InspectorIssueDetails_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    decltype(Traits::cookie_issue_details(input)) in_cookie_issue_details = Traits::cookie_issue_details(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->cookie_issue_details)::BaseType> cookie_issue_details_fragment(
            fragment.message());
    mojo::internal::Serialize<::blink::mojom::CookieIssueDetailsDataView>(
        in_cookie_issue_details, cookie_issue_details_fragment);
    fragment->cookie_issue_details.Set(
        cookie_issue_details_fragment.is_null() ? nullptr : cookie_issue_details_fragment.data());
    decltype(Traits::mixed_content_issue_details(input)) in_mixed_content_issue_details = Traits::mixed_content_issue_details(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->mixed_content_issue_details)::BaseType> mixed_content_issue_details_fragment(
            fragment.message());
    mojo::internal::Serialize<::blink::mojom::MixedContentIssueDetailsDataView>(
        in_mixed_content_issue_details, mixed_content_issue_details_fragment);
    fragment->mixed_content_issue_details.Set(
        mixed_content_issue_details_fragment.is_null() ? nullptr : mixed_content_issue_details_fragment.data());
    decltype(Traits::blocked_by_response_issue_details(input)) in_blocked_by_response_issue_details = Traits::blocked_by_response_issue_details(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->blocked_by_response_issue_details)::BaseType> blocked_by_response_issue_details_fragment(
            fragment.message());
    mojo::internal::Serialize<::blink::mojom::BlockedByResponseIssueDetailsDataView>(
        in_blocked_by_response_issue_details, blocked_by_response_issue_details_fragment);
    fragment->blocked_by_response_issue_details.Set(
        blocked_by_response_issue_details_fragment.is_null() ? nullptr : blocked_by_response_issue_details_fragment.data());
    decltype(Traits::csp_issue_details(input)) in_csp_issue_details = Traits::csp_issue_details(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->csp_issue_details)::BaseType> csp_issue_details_fragment(
            fragment.message());
    mojo::internal::Serialize<::blink::mojom::ContentSecurityPolicyIssueDetailsDataView>(
        in_csp_issue_details, csp_issue_details_fragment);
    fragment->csp_issue_details.Set(
        csp_issue_details_fragment.is_null() ? nullptr : csp_issue_details_fragment.data());
    decltype(Traits::sab_issue_details(input)) in_sab_issue_details = Traits::sab_issue_details(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->sab_issue_details)::BaseType> sab_issue_details_fragment(
            fragment.message());
    mojo::internal::Serialize<::blink::mojom::SharedArrayBufferIssueDetailsDataView>(
        in_sab_issue_details, sab_issue_details_fragment);
    fragment->sab_issue_details.Set(
        sab_issue_details_fragment.is_null() ? nullptr : sab_issue_details_fragment.data());
    decltype(Traits::twa_issue_details(input)) in_twa_issue_details = Traits::twa_issue_details(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->twa_issue_details)::BaseType> twa_issue_details_fragment(
            fragment.message());
    mojo::internal::Serialize<::blink::mojom::TrustedWebActivityIssueDetailsDataView>(
        in_twa_issue_details, twa_issue_details_fragment);
    fragment->twa_issue_details.Set(
        twa_issue_details_fragment.is_null() ? nullptr : twa_issue_details_fragment.data());
    decltype(Traits::heavy_ad_issue_details(input)) in_heavy_ad_issue_details = Traits::heavy_ad_issue_details(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->heavy_ad_issue_details)::BaseType> heavy_ad_issue_details_fragment(
            fragment.message());
    mojo::internal::Serialize<::blink::mojom::HeavyAdIssueDetailsDataView>(
        in_heavy_ad_issue_details, heavy_ad_issue_details_fragment);
    fragment->heavy_ad_issue_details.Set(
        heavy_ad_issue_details_fragment.is_null() ? nullptr : heavy_ad_issue_details_fragment.data());
    decltype(Traits::low_text_contrast_details(input)) in_low_text_contrast_details = Traits::low_text_contrast_details(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->low_text_contrast_details)::BaseType> low_text_contrast_details_fragment(
            fragment.message());
    mojo::internal::Serialize<::blink::mojom::LowTextContrastIssueDataView>(
        in_low_text_contrast_details, low_text_contrast_details_fragment);
    fragment->low_text_contrast_details.Set(
        low_text_contrast_details_fragment.is_null() ? nullptr : low_text_contrast_details_fragment.data());
    decltype(Traits::federated_auth_request_details(input)) in_federated_auth_request_details = Traits::federated_auth_request_details(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->federated_auth_request_details)::BaseType> federated_auth_request_details_fragment(
            fragment.message());
    mojo::internal::Serialize<::blink::mojom::FederatedAuthRequestIssueDetailsDataView>(
        in_federated_auth_request_details, federated_auth_request_details_fragment);
    fragment->federated_auth_request_details.Set(
        federated_auth_request_details_fragment.is_null() ? nullptr : federated_auth_request_details_fragment.data());
    decltype(Traits::generic_issue_details(input)) in_generic_issue_details = Traits::generic_issue_details(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->generic_issue_details)::BaseType> generic_issue_details_fragment(
            fragment.message());
    mojo::internal::Serialize<::blink::mojom::GenericIssueDetailsDataView>(
        in_generic_issue_details, generic_issue_details_fragment);
    fragment->generic_issue_details.Set(
        generic_issue_details_fragment.is_null() ? nullptr : generic_issue_details_fragment.data());
    decltype(Traits::issue_id(input)) in_issue_id = Traits::issue_id(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->issue_id)::BaseType> issue_id_fragment(
            fragment.message());
    mojo::internal::Serialize<::mojo_base::mojom::UnguessableTokenDataView>(
        in_issue_id, issue_id_fragment);
    fragment->issue_id.Set(
        issue_id_fragment.is_null() ? nullptr : issue_id_fragment.data());
  }

  static bool Deserialize(::blink::mojom::internal::InspectorIssueDetails_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::blink::mojom::InspectorIssueDetailsDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::blink::mojom::InspectorIssueInfoDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::blink::mojom::InspectorIssueInfoDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::blink::mojom::internal::InspectorIssueInfo_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    mojo::internal::Serialize<::blink::mojom::InspectorIssueCode>(
        Traits::code(input), &fragment->code);
    decltype(Traits::details(input)) in_details = Traits::details(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->details)::BaseType> details_fragment(
            fragment.message());
    mojo::internal::Serialize<::blink::mojom::InspectorIssueDetailsDataView>(
        in_details, details_fragment);
    fragment->details.Set(
        details_fragment.is_null() ? nullptr : details_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->details.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null details in InspectorIssueInfo struct");
  }

  static bool Deserialize(::blink::mojom::internal::InspectorIssueInfo_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::blink::mojom::InspectorIssueInfoDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal

}  // namespace mojo


namespace blink {
namespace mojom {

inline void AffectedCookieDataView::GetNameDataView(
    mojo::StringDataView* output) {
  auto pointer = data_->name.Get();
  *output = mojo::StringDataView(pointer, message_);
}
inline void AffectedCookieDataView::GetPathDataView(
    mojo::StringDataView* output) {
  auto pointer = data_->path.Get();
  *output = mojo::StringDataView(pointer, message_);
}
inline void AffectedCookieDataView::GetDomainDataView(
    mojo::StringDataView* output) {
  auto pointer = data_->domain.Get();
  *output = mojo::StringDataView(pointer, message_);
}


inline void AffectedRequestDataView::GetRequestIdDataView(
    mojo::StringDataView* output) {
  auto pointer = data_->request_id.Get();
  *output = mojo::StringDataView(pointer, message_);
}
inline void AffectedRequestDataView::GetUrlDataView(
    mojo::StringDataView* output) {
  auto pointer = data_->url.Get();
  *output = mojo::StringDataView(pointer, message_);
}


inline void AffectedFrameDataView::GetFrameIdDataView(
    mojo::StringDataView* output) {
  auto pointer = data_->frame_id.Get();
  *output = mojo::StringDataView(pointer, message_);
}


inline void AffectedLocationDataView::GetScriptIdDataView(
    mojo::StringDataView* output) {
  auto pointer = data_->script_id.Get();
  *output = mojo::StringDataView(pointer, message_);
}
inline void AffectedLocationDataView::GetUrlDataView(
    mojo::StringDataView* output) {
  auto pointer = data_->url.Get();
  *output = mojo::StringDataView(pointer, message_);
}


inline void BlockedByResponseIssueDetailsDataView::GetRequestDataView(
    AffectedRequestDataView* output) {
  auto pointer = data_->request.Get();
  *output = AffectedRequestDataView(pointer, message_);
}
inline void BlockedByResponseIssueDetailsDataView::GetParentFrameDataView(
    AffectedFrameDataView* output) {
  auto pointer = data_->parentFrame.Get();
  *output = AffectedFrameDataView(pointer, message_);
}
inline void BlockedByResponseIssueDetailsDataView::GetBlockedFrameDataView(
    AffectedFrameDataView* output) {
  auto pointer = data_->blockedFrame.Get();
  *output = AffectedFrameDataView(pointer, message_);
}


inline void HeavyAdIssueDetailsDataView::GetFrameDataView(
    AffectedFrameDataView* output) {
  auto pointer = data_->frame.Get();
  *output = AffectedFrameDataView(pointer, message_);
}


inline void MixedContentIssueDetailsDataView::GetInsecureUrlDataView(
    mojo::StringDataView* output) {
  auto pointer = data_->insecure_url.Get();
  *output = mojo::StringDataView(pointer, message_);
}
inline void MixedContentIssueDetailsDataView::GetMainResourceUrlDataView(
    mojo::StringDataView* output) {
  auto pointer = data_->main_resource_url.Get();
  *output = mojo::StringDataView(pointer, message_);
}
inline void MixedContentIssueDetailsDataView::GetRequestDataView(
    AffectedRequestDataView* output) {
  auto pointer = data_->request.Get();
  *output = AffectedRequestDataView(pointer, message_);
}
inline void MixedContentIssueDetailsDataView::GetFrameDataView(
    AffectedFrameDataView* output) {
  auto pointer = data_->frame.Get();
  *output = AffectedFrameDataView(pointer, message_);
}


inline void ContentSecurityPolicyIssueDetailsDataView::GetBlockedUrlDataView(
    ::url::mojom::UrlDataView* output) {
  auto pointer = data_->blocked_url.Get();
  *output = ::url::mojom::UrlDataView(pointer, message_);
}
inline void ContentSecurityPolicyIssueDetailsDataView::GetViolatedDirectiveDataView(
    mojo::StringDataView* output) {
  auto pointer = data_->violated_directive.Get();
  *output = mojo::StringDataView(pointer, message_);
}
inline void ContentSecurityPolicyIssueDetailsDataView::GetFrameAncestorDataView(
    AffectedFrameDataView* output) {
  auto pointer = data_->frame_ancestor.Get();
  *output = AffectedFrameDataView(pointer, message_);
}
inline void ContentSecurityPolicyIssueDetailsDataView::GetAffectedLocationDataView(
    AffectedLocationDataView* output) {
  auto pointer = data_->affected_location.Get();
  *output = AffectedLocationDataView(pointer, message_);
}


inline void CookieIssueDetailsDataView::GetCookieDataView(
    AffectedCookieDataView* output) {
  auto pointer = data_->cookie.Get();
  *output = AffectedCookieDataView(pointer, message_);
}
inline void CookieIssueDetailsDataView::GetExclusionReasonDataView(
    mojo::ArrayDataView<CookieExclusionReason>* output) {
  auto pointer = data_->exclusion_reason.Get();
  *output = mojo::ArrayDataView<CookieExclusionReason>(pointer, message_);
}
inline void CookieIssueDetailsDataView::GetWarningReasonDataView(
    mojo::ArrayDataView<CookieWarningReason>* output) {
  auto pointer = data_->warning_reason.Get();
  *output = mojo::ArrayDataView<CookieWarningReason>(pointer, message_);
}
inline void CookieIssueDetailsDataView::GetSiteForCookiesDataView(
    ::url::mojom::UrlDataView* output) {
  auto pointer = data_->site_for_cookies.Get();
  *output = ::url::mojom::UrlDataView(pointer, message_);
}
inline void CookieIssueDetailsDataView::GetCookieUrlDataView(
    ::url::mojom::UrlDataView* output) {
  auto pointer = data_->cookie_url.Get();
  *output = ::url::mojom::UrlDataView(pointer, message_);
}
inline void CookieIssueDetailsDataView::GetRequestDataView(
    AffectedRequestDataView* output) {
  auto pointer = data_->request.Get();
  *output = AffectedRequestDataView(pointer, message_);
}


inline void SharedArrayBufferIssueDetailsDataView::GetAffectedLocationDataView(
    AffectedLocationDataView* output) {
  auto pointer = data_->affected_location.Get();
  *output = AffectedLocationDataView(pointer, message_);
}


inline void TrustedWebActivityIssueDetailsDataView::GetUrlDataView(
    ::url::mojom::UrlDataView* output) {
  auto pointer = data_->url.Get();
  *output = ::url::mojom::UrlDataView(pointer, message_);
}
inline void TrustedWebActivityIssueDetailsDataView::GetPackageNameDataView(
    mojo::StringDataView* output) {
  auto pointer = data_->package_name.Get();
  *output = mojo::StringDataView(pointer, message_);
}
inline void TrustedWebActivityIssueDetailsDataView::GetSignatureDataView(
    mojo::StringDataView* output) {
  auto pointer = data_->signature.Get();
  *output = mojo::StringDataView(pointer, message_);
}


inline void LowTextContrastIssueDataView::GetViolatingNodeSelectorDataView(
    mojo::StringDataView* output) {
  auto pointer = data_->violating_node_selector.Get();
  *output = mojo::StringDataView(pointer, message_);
}
inline void LowTextContrastIssueDataView::GetFontSizeDataView(
    mojo::StringDataView* output) {
  auto pointer = data_->font_size.Get();
  *output = mojo::StringDataView(pointer, message_);
}
inline void LowTextContrastIssueDataView::GetFontWeightDataView(
    mojo::StringDataView* output) {
  auto pointer = data_->font_weight.Get();
  *output = mojo::StringDataView(pointer, message_);
}




inline void GenericIssueDetailsDataView::GetFrameIdDataView(
    mojo::StringDataView* output) {
  auto pointer = data_->frame_id.Get();
  *output = mojo::StringDataView(pointer, message_);
}


inline void InspectorIssueDetailsDataView::GetCookieIssueDetailsDataView(
    CookieIssueDetailsDataView* output) {
  auto pointer = data_->cookie_issue_details.Get();
  *output = CookieIssueDetailsDataView(pointer, message_);
}
inline void InspectorIssueDetailsDataView::GetMixedContentIssueDetailsDataView(
    MixedContentIssueDetailsDataView* output) {
  auto pointer = data_->mixed_content_issue_details.Get();
  *output = MixedContentIssueDetailsDataView(pointer, message_);
}
inline void InspectorIssueDetailsDataView::GetBlockedByResponseIssueDetailsDataView(
    BlockedByResponseIssueDetailsDataView* output) {
  auto pointer = data_->blocked_by_response_issue_details.Get();
  *output = BlockedByResponseIssueDetailsDataView(pointer, message_);
}
inline void InspectorIssueDetailsDataView::GetCspIssueDetailsDataView(
    ContentSecurityPolicyIssueDetailsDataView* output) {
  auto pointer = data_->csp_issue_details.Get();
  *output = ContentSecurityPolicyIssueDetailsDataView(pointer, message_);
}
inline void InspectorIssueDetailsDataView::GetSabIssueDetailsDataView(
    SharedArrayBufferIssueDetailsDataView* output) {
  auto pointer = data_->sab_issue_details.Get();
  *output = SharedArrayBufferIssueDetailsDataView(pointer, message_);
}
inline void InspectorIssueDetailsDataView::GetTwaIssueDetailsDataView(
    TrustedWebActivityIssueDetailsDataView* output) {
  auto pointer = data_->twa_issue_details.Get();
  *output = TrustedWebActivityIssueDetailsDataView(pointer, message_);
}
inline void InspectorIssueDetailsDataView::GetHeavyAdIssueDetailsDataView(
    HeavyAdIssueDetailsDataView* output) {
  auto pointer = data_->heavy_ad_issue_details.Get();
  *output = HeavyAdIssueDetailsDataView(pointer, message_);
}
inline void InspectorIssueDetailsDataView::GetLowTextContrastDetailsDataView(
    LowTextContrastIssueDataView* output) {
  auto pointer = data_->low_text_contrast_details.Get();
  *output = LowTextContrastIssueDataView(pointer, message_);
}
inline void InspectorIssueDetailsDataView::GetFederatedAuthRequestDetailsDataView(
    FederatedAuthRequestIssueDetailsDataView* output) {
  auto pointer = data_->federated_auth_request_details.Get();
  *output = FederatedAuthRequestIssueDetailsDataView(pointer, message_);
}
inline void InspectorIssueDetailsDataView::GetGenericIssueDetailsDataView(
    GenericIssueDetailsDataView* output) {
  auto pointer = data_->generic_issue_details.Get();
  *output = GenericIssueDetailsDataView(pointer, message_);
}
inline void InspectorIssueDetailsDataView::GetIssueIdDataView(
    ::mojo_base::mojom::UnguessableTokenDataView* output) {
  auto pointer = data_->issue_id.Get();
  *output = ::mojo_base::mojom::UnguessableTokenDataView(pointer, message_);
}


inline void InspectorIssueInfoDataView::GetDetailsDataView(
    InspectorIssueDetailsDataView* output) {
  auto pointer = data_->details.Get();
  *output = InspectorIssueDetailsDataView(pointer, message_);
}



}  // namespace mojom
}  // namespace blink

// Declare TraceFormatTraits for enums, which should be defined in ::perfetto
// namespace.

namespace perfetto {

template <>
struct COMPONENT_EXPORT(MOJOM_SHARED_BLINK_COMMON_EXPORT) TraceFormatTraits<::blink::mojom::InspectorIssueCode> {
 static void WriteIntoTrace(perfetto::TracedValue context, ::blink::mojom::InspectorIssueCode value);
};

} // namespace perfetto

namespace perfetto {

template <>
struct COMPONENT_EXPORT(MOJOM_SHARED_BLINK_COMMON_EXPORT) TraceFormatTraits<::blink::mojom::HeavyAdResolutionStatus> {
 static void WriteIntoTrace(perfetto::TracedValue context, ::blink::mojom::HeavyAdResolutionStatus value);
};

} // namespace perfetto

namespace perfetto {

template <>
struct COMPONENT_EXPORT(MOJOM_SHARED_BLINK_COMMON_EXPORT) TraceFormatTraits<::blink::mojom::HeavyAdReason> {
 static void WriteIntoTrace(perfetto::TracedValue context, ::blink::mojom::HeavyAdReason value);
};

} // namespace perfetto

namespace perfetto {

template <>
struct COMPONENT_EXPORT(MOJOM_SHARED_BLINK_COMMON_EXPORT) TraceFormatTraits<::blink::mojom::MixedContentResolutionStatus> {
 static void WriteIntoTrace(perfetto::TracedValue context, ::blink::mojom::MixedContentResolutionStatus value);
};

} // namespace perfetto

namespace perfetto {

template <>
struct COMPONENT_EXPORT(MOJOM_SHARED_BLINK_COMMON_EXPORT) TraceFormatTraits<::blink::mojom::ContentSecurityPolicyViolationType> {
 static void WriteIntoTrace(perfetto::TracedValue context, ::blink::mojom::ContentSecurityPolicyViolationType value);
};

} // namespace perfetto

namespace perfetto {

template <>
struct COMPONENT_EXPORT(MOJOM_SHARED_BLINK_COMMON_EXPORT) TraceFormatTraits<::blink::mojom::CookieOperation> {
 static void WriteIntoTrace(perfetto::TracedValue context, ::blink::mojom::CookieOperation value);
};

} // namespace perfetto

namespace perfetto {

template <>
struct COMPONENT_EXPORT(MOJOM_SHARED_BLINK_COMMON_EXPORT) TraceFormatTraits<::blink::mojom::CookieExclusionReason> {
 static void WriteIntoTrace(perfetto::TracedValue context, ::blink::mojom::CookieExclusionReason value);
};

} // namespace perfetto

namespace perfetto {

template <>
struct COMPONENT_EXPORT(MOJOM_SHARED_BLINK_COMMON_EXPORT) TraceFormatTraits<::blink::mojom::CookieWarningReason> {
 static void WriteIntoTrace(perfetto::TracedValue context, ::blink::mojom::CookieWarningReason value);
};

} // namespace perfetto

namespace perfetto {

template <>
struct COMPONENT_EXPORT(MOJOM_SHARED_BLINK_COMMON_EXPORT) TraceFormatTraits<::blink::mojom::SharedArrayBufferIssueType> {
 static void WriteIntoTrace(perfetto::TracedValue context, ::blink::mojom::SharedArrayBufferIssueType value);
};

} // namespace perfetto

namespace perfetto {

template <>
struct COMPONENT_EXPORT(MOJOM_SHARED_BLINK_COMMON_EXPORT) TraceFormatTraits<::blink::mojom::TwaQualityEnforcementViolationType> {
 static void WriteIntoTrace(perfetto::TracedValue context, ::blink::mojom::TwaQualityEnforcementViolationType value);
};

} // namespace perfetto

namespace perfetto {

template <>
struct COMPONENT_EXPORT(MOJOM_SHARED_BLINK_COMMON_EXPORT) TraceFormatTraits<::blink::mojom::FederatedAuthRequestResult> {
 static void WriteIntoTrace(perfetto::TracedValue context, ::blink::mojom::FederatedAuthRequestResult value);
};

} // namespace perfetto

namespace perfetto {

template <>
struct COMPONENT_EXPORT(MOJOM_SHARED_BLINK_COMMON_EXPORT) TraceFormatTraits<::blink::mojom::GenericIssueErrorType> {
 static void WriteIntoTrace(perfetto::TracedValue context, ::blink::mojom::GenericIssueErrorType value);
};

} // namespace perfetto

#endif  // THIRD_PARTY_BLINK_PUBLIC_MOJOM_DEVTOOLS_INSPECTOR_ISSUE_MOJOM_SHARED_H_