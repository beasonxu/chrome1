// third_party/blink/public/mojom/conversions/attribution_data_host.mojom-shared.h is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2016 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef THIRD_PARTY_BLINK_PUBLIC_MOJOM_CONVERSIONS_ATTRIBUTION_DATA_HOST_MOJOM_SHARED_H_
#define THIRD_PARTY_BLINK_PUBLIC_MOJOM_CONVERSIONS_ATTRIBUTION_DATA_HOST_MOJOM_SHARED_H_

#include <stdint.h>

#include <functional>
#include <iosfwd>
#include <type_traits>
#include <utility>
#include "mojo/public/cpp/bindings/array_data_view.h"
#include "mojo/public/cpp/bindings/enum_traits.h"
#include "mojo/public/cpp/bindings/interface_data_view.h"
#include "mojo/public/cpp/bindings/lib/bindings_internal.h"
#include "mojo/public/cpp/bindings/lib/serialization.h"
#include "mojo/public/cpp/bindings/map_data_view.h"
#include "mojo/public/cpp/bindings/string_data_view.h"

#include "third_party/perfetto/include/perfetto/tracing/traced_value_forward.h"

#include "third_party/blink/public/mojom/conversions/attribution_data_host.mojom-shared-internal.h"
#include "mojo/public/mojom/base/int128.mojom-shared.h"
#include "mojo/public/mojom/base/time.mojom-shared.h"
#include "url/mojom/origin.mojom-shared.h"
#include "mojo/public/cpp/bindings/lib/interface_serialization.h"


#include "base/component_export.h"




namespace blink {
namespace mojom {
class AttributionDebugKeyDataView;

class AttributionFilterDataDataView;

class AttributionAggregatableTriggerDataDataView;

class AttributionSourceDataDataView;

class AttributionTriggerDedupKeyDataView;

class EventTriggerDataDataView;

class AttributionTriggerDataDataView;



}  // namespace mojom
}  // namespace blink

namespace mojo {
namespace internal {

template <>
struct MojomTypeTraits<::blink::mojom::AttributionDebugKeyDataView> {
  using Data = ::blink::mojom::internal::AttributionDebugKey_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::blink::mojom::AttributionFilterDataDataView> {
  using Data = ::blink::mojom::internal::AttributionFilterData_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::blink::mojom::AttributionAggregatableTriggerDataDataView> {
  using Data = ::blink::mojom::internal::AttributionAggregatableTriggerData_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::blink::mojom::AttributionSourceDataDataView> {
  using Data = ::blink::mojom::internal::AttributionSourceData_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::blink::mojom::AttributionTriggerDedupKeyDataView> {
  using Data = ::blink::mojom::internal::AttributionTriggerDedupKey_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::blink::mojom::EventTriggerDataDataView> {
  using Data = ::blink::mojom::internal::EventTriggerData_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::blink::mojom::AttributionTriggerDataDataView> {
  using Data = ::blink::mojom::internal::AttributionTriggerData_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

}  // namespace internal
}  // namespace mojo


namespace blink {
namespace mojom {
// Interface base classes. They are used for type safety check.
class AttributionDataHostInterfaceBase {};

using AttributionDataHostPtrDataView =
    mojo::InterfacePtrDataView<AttributionDataHostInterfaceBase>;
using AttributionDataHostRequestDataView =
    mojo::InterfaceRequestDataView<AttributionDataHostInterfaceBase>;
using AttributionDataHostAssociatedPtrInfoDataView =
    mojo::AssociatedInterfacePtrInfoDataView<AttributionDataHostInterfaceBase>;
using AttributionDataHostAssociatedRequestDataView =
    mojo::AssociatedInterfaceRequestDataView<AttributionDataHostInterfaceBase>;


class AttributionDebugKeyDataView {
 public:
  AttributionDebugKeyDataView() = default;

  AttributionDebugKeyDataView(
      internal::AttributionDebugKey_Data* data,
      mojo::Message* message)
      : data_(data) {}

  bool is_null() const { return !data_; }
  uint64_t value() const {
    return data_->value;
  }
 private:
  internal::AttributionDebugKey_Data* data_ = nullptr;
};



class AttributionFilterDataDataView {
 public:
  AttributionFilterDataDataView() = default;

  AttributionFilterDataDataView(
      internal::AttributionFilterData_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  inline void GetFilterValuesDataView(
      mojo::MapDataView<mojo::StringDataView, mojo::ArrayDataView<mojo::StringDataView>>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadFilterValues(UserType* output) {
    
    auto* pointer = data_->filter_values.Get();
    return mojo::internal::Deserialize<mojo::MapDataView<mojo::StringDataView, mojo::ArrayDataView<mojo::StringDataView>>>(
        pointer, output, message_);
  }
 private:
  internal::AttributionFilterData_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class AttributionAggregatableTriggerDataDataView {
 public:
  AttributionAggregatableTriggerDataDataView() = default;

  AttributionAggregatableTriggerDataDataView(
      internal::AttributionAggregatableTriggerData_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  inline void GetKeyPieceDataView(
      ::mojo_base::mojom::Uint128DataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadKeyPiece(UserType* output) {
    
    auto* pointer = data_->key_piece.Get();
    return mojo::internal::Deserialize<::mojo_base::mojom::Uint128DataView>(
        pointer, output, message_);
  }
  inline void GetSourceKeysDataView(
      mojo::ArrayDataView<mojo::StringDataView>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadSourceKeys(UserType* output) {
    
    auto* pointer = data_->source_keys.Get();
    return mojo::internal::Deserialize<mojo::ArrayDataView<mojo::StringDataView>>(
        pointer, output, message_);
  }
  inline void GetFiltersDataView(
      AttributionFilterDataDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadFilters(UserType* output) {
    
    auto* pointer = data_->filters.Get();
    return mojo::internal::Deserialize<::blink::mojom::AttributionFilterDataDataView>(
        pointer, output, message_);
  }
  inline void GetNotFiltersDataView(
      AttributionFilterDataDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadNotFilters(UserType* output) {
    
    auto* pointer = data_->not_filters.Get();
    return mojo::internal::Deserialize<::blink::mojom::AttributionFilterDataDataView>(
        pointer, output, message_);
  }
 private:
  internal::AttributionAggregatableTriggerData_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class AttributionSourceDataDataView {
 public:
  AttributionSourceDataDataView() = default;

  AttributionSourceDataDataView(
      internal::AttributionSourceData_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  inline void GetDestinationDataView(
      ::url::mojom::OriginDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadDestination(UserType* output) {
    
    auto* pointer = data_->destination.Get();
    return mojo::internal::Deserialize<::url::mojom::OriginDataView>(
        pointer, output, message_);
  }
  inline void GetReportingOriginDataView(
      ::url::mojom::OriginDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadReportingOrigin(UserType* output) {
    
    auto* pointer = data_->reporting_origin.Get();
    return mojo::internal::Deserialize<::url::mojom::OriginDataView>(
        pointer, output, message_);
  }
  uint64_t source_event_id() const {
    return data_->source_event_id;
  }
  inline void GetExpiryDataView(
      ::mojo_base::mojom::TimeDeltaDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadExpiry(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::mojo_base::mojom::TimeDeltaDataView, UserType>(),
    "Attempting to read the optional `expiry` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadExpiry` instead "
    "of `ReadExpiry if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->expiry.Get();
    return mojo::internal::Deserialize<::mojo_base::mojom::TimeDeltaDataView>(
        pointer, output, message_);
  }
  int64_t priority() const {
    return data_->priority;
  }
  inline void GetDebugKeyDataView(
      AttributionDebugKeyDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadDebugKey(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::blink::mojom::AttributionDebugKeyDataView, UserType>(),
    "Attempting to read the optional `debug_key` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadDebugKey` instead "
    "of `ReadDebugKey if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->debug_key.Get();
    return mojo::internal::Deserialize<::blink::mojom::AttributionDebugKeyDataView>(
        pointer, output, message_);
  }
  inline void GetFilterDataDataView(
      AttributionFilterDataDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadFilterData(UserType* output) {
    
    auto* pointer = data_->filter_data.Get();
    return mojo::internal::Deserialize<::blink::mojom::AttributionFilterDataDataView>(
        pointer, output, message_);
  }
  inline void GetAggregationKeysDataView(
      mojo::MapDataView<mojo::StringDataView, ::mojo_base::mojom::Uint128DataView>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadAggregationKeys(UserType* output) {
    
    auto* pointer = data_->aggregation_keys.Get();
    return mojo::internal::Deserialize<mojo::MapDataView<mojo::StringDataView, ::mojo_base::mojom::Uint128DataView>>(
        pointer, output, message_);
  }
 private:
  internal::AttributionSourceData_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class AttributionTriggerDedupKeyDataView {
 public:
  AttributionTriggerDedupKeyDataView() = default;

  AttributionTriggerDedupKeyDataView(
      internal::AttributionTriggerDedupKey_Data* data,
      mojo::Message* message)
      : data_(data) {}

  bool is_null() const { return !data_; }
  uint64_t value() const {
    return data_->value;
  }
 private:
  internal::AttributionTriggerDedupKey_Data* data_ = nullptr;
};



class EventTriggerDataDataView {
 public:
  EventTriggerDataDataView() = default;

  EventTriggerDataDataView(
      internal::EventTriggerData_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  uint64_t data() const {
    return data_->data;
  }
  int64_t priority() const {
    return data_->priority;
  }
  inline void GetDedupKeyDataView(
      AttributionTriggerDedupKeyDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadDedupKey(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::blink::mojom::AttributionTriggerDedupKeyDataView, UserType>(),
    "Attempting to read the optional `dedup_key` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadDedupKey` instead "
    "of `ReadDedupKey if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->dedup_key.Get();
    return mojo::internal::Deserialize<::blink::mojom::AttributionTriggerDedupKeyDataView>(
        pointer, output, message_);
  }
  inline void GetFiltersDataView(
      AttributionFilterDataDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadFilters(UserType* output) {
    
    auto* pointer = data_->filters.Get();
    return mojo::internal::Deserialize<::blink::mojom::AttributionFilterDataDataView>(
        pointer, output, message_);
  }
  inline void GetNotFiltersDataView(
      AttributionFilterDataDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadNotFilters(UserType* output) {
    
    auto* pointer = data_->not_filters.Get();
    return mojo::internal::Deserialize<::blink::mojom::AttributionFilterDataDataView>(
        pointer, output, message_);
  }
 private:
  internal::EventTriggerData_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class AttributionTriggerDataDataView {
 public:
  AttributionTriggerDataDataView() = default;

  AttributionTriggerDataDataView(
      internal::AttributionTriggerData_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  inline void GetReportingOriginDataView(
      ::url::mojom::OriginDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadReportingOrigin(UserType* output) {
    
    auto* pointer = data_->reporting_origin.Get();
    return mojo::internal::Deserialize<::url::mojom::OriginDataView>(
        pointer, output, message_);
  }
  inline void GetEventTriggersDataView(
      mojo::ArrayDataView<EventTriggerDataDataView>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadEventTriggers(UserType* output) {
    
    auto* pointer = data_->event_triggers.Get();
    return mojo::internal::Deserialize<mojo::ArrayDataView<::blink::mojom::EventTriggerDataDataView>>(
        pointer, output, message_);
  }
  inline void GetFiltersDataView(
      AttributionFilterDataDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadFilters(UserType* output) {
    
    auto* pointer = data_->filters.Get();
    return mojo::internal::Deserialize<::blink::mojom::AttributionFilterDataDataView>(
        pointer, output, message_);
  }
  inline void GetNotFiltersDataView(
      AttributionFilterDataDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadNotFilters(UserType* output) {
    
    auto* pointer = data_->not_filters.Get();
    return mojo::internal::Deserialize<::blink::mojom::AttributionFilterDataDataView>(
        pointer, output, message_);
  }
  inline void GetAggregatableTriggerDataDataView(
      mojo::ArrayDataView<AttributionAggregatableTriggerDataDataView>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadAggregatableTriggerData(UserType* output) {
    
    auto* pointer = data_->aggregatable_trigger_data.Get();
    return mojo::internal::Deserialize<mojo::ArrayDataView<::blink::mojom::AttributionAggregatableTriggerDataDataView>>(
        pointer, output, message_);
  }
  inline void GetAggregatableValuesDataView(
      mojo::MapDataView<mojo::StringDataView, uint32_t>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadAggregatableValues(UserType* output) {
    
    auto* pointer = data_->aggregatable_values.Get();
    return mojo::internal::Deserialize<mojo::MapDataView<mojo::StringDataView, uint32_t>>(
        pointer, output, message_);
  }
  inline void GetDebugKeyDataView(
      AttributionDebugKeyDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadDebugKey(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::blink::mojom::AttributionDebugKeyDataView, UserType>(),
    "Attempting to read the optional `debug_key` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadDebugKey` instead "
    "of `ReadDebugKey if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->debug_key.Get();
    return mojo::internal::Deserialize<::blink::mojom::AttributionDebugKeyDataView>(
        pointer, output, message_);
  }
 private:
  internal::AttributionTriggerData_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



}  // namespace mojom
}  // namespace blink

namespace std {

}  // namespace std

namespace mojo {


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::blink::mojom::AttributionDebugKeyDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::blink::mojom::AttributionDebugKeyDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::blink::mojom::internal::AttributionDebugKey_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    fragment->value = Traits::value(input);
  }

  static bool Deserialize(::blink::mojom::internal::AttributionDebugKey_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::blink::mojom::AttributionDebugKeyDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::blink::mojom::AttributionFilterDataDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::blink::mojom::AttributionFilterDataDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::blink::mojom::internal::AttributionFilterData_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    decltype(Traits::filter_values(input)) in_filter_values = Traits::filter_values(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->filter_values)::BaseType>
        filter_values_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams filter_values_validate_params(
        new mojo::internal::ContainerValidateParams(0, false, new mojo::internal::ContainerValidateParams(0, false, nullptr)), new mojo::internal::ContainerValidateParams(0, false, new mojo::internal::ContainerValidateParams(0, false, new mojo::internal::ContainerValidateParams(0, false, nullptr))));
    mojo::internal::Serialize<mojo::MapDataView<mojo::StringDataView, mojo::ArrayDataView<mojo::StringDataView>>>(
        in_filter_values, filter_values_fragment, &filter_values_validate_params);
    fragment->filter_values.Set(
        filter_values_fragment.is_null() ? nullptr : filter_values_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->filter_values.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null filter_values in AttributionFilterData struct");
  }

  static bool Deserialize(::blink::mojom::internal::AttributionFilterData_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::blink::mojom::AttributionFilterDataDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::blink::mojom::AttributionAggregatableTriggerDataDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::blink::mojom::AttributionAggregatableTriggerDataDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::blink::mojom::internal::AttributionAggregatableTriggerData_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    decltype(Traits::key_piece(input)) in_key_piece = Traits::key_piece(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->key_piece)::BaseType> key_piece_fragment(
            fragment.message());
    mojo::internal::Serialize<::mojo_base::mojom::Uint128DataView>(
        in_key_piece, key_piece_fragment);
    fragment->key_piece.Set(
        key_piece_fragment.is_null() ? nullptr : key_piece_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->key_piece.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null key_piece in AttributionAggregatableTriggerData struct");
    decltype(Traits::source_keys(input)) in_source_keys = Traits::source_keys(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->source_keys)::BaseType>
        source_keys_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams source_keys_validate_params(
        0, false, new mojo::internal::ContainerValidateParams(0, false, nullptr));
    mojo::internal::Serialize<mojo::ArrayDataView<mojo::StringDataView>>(
        in_source_keys, source_keys_fragment, &source_keys_validate_params);
    fragment->source_keys.Set(
        source_keys_fragment.is_null() ? nullptr : source_keys_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->source_keys.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null source_keys in AttributionAggregatableTriggerData struct");
    decltype(Traits::filters(input)) in_filters = Traits::filters(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->filters)::BaseType> filters_fragment(
            fragment.message());
    mojo::internal::Serialize<::blink::mojom::AttributionFilterDataDataView>(
        in_filters, filters_fragment);
    fragment->filters.Set(
        filters_fragment.is_null() ? nullptr : filters_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->filters.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null filters in AttributionAggregatableTriggerData struct");
    decltype(Traits::not_filters(input)) in_not_filters = Traits::not_filters(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->not_filters)::BaseType> not_filters_fragment(
            fragment.message());
    mojo::internal::Serialize<::blink::mojom::AttributionFilterDataDataView>(
        in_not_filters, not_filters_fragment);
    fragment->not_filters.Set(
        not_filters_fragment.is_null() ? nullptr : not_filters_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->not_filters.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null not_filters in AttributionAggregatableTriggerData struct");
  }

  static bool Deserialize(::blink::mojom::internal::AttributionAggregatableTriggerData_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::blink::mojom::AttributionAggregatableTriggerDataDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::blink::mojom::AttributionSourceDataDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::blink::mojom::AttributionSourceDataDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::blink::mojom::internal::AttributionSourceData_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    decltype(Traits::destination(input)) in_destination = Traits::destination(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->destination)::BaseType> destination_fragment(
            fragment.message());
    mojo::internal::Serialize<::url::mojom::OriginDataView>(
        in_destination, destination_fragment);
    fragment->destination.Set(
        destination_fragment.is_null() ? nullptr : destination_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->destination.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null destination in AttributionSourceData struct");
    decltype(Traits::reporting_origin(input)) in_reporting_origin = Traits::reporting_origin(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->reporting_origin)::BaseType> reporting_origin_fragment(
            fragment.message());
    mojo::internal::Serialize<::url::mojom::OriginDataView>(
        in_reporting_origin, reporting_origin_fragment);
    fragment->reporting_origin.Set(
        reporting_origin_fragment.is_null() ? nullptr : reporting_origin_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->reporting_origin.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null reporting_origin in AttributionSourceData struct");
    fragment->source_event_id = Traits::source_event_id(input);
    decltype(Traits::expiry(input)) in_expiry = Traits::expiry(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->expiry)::BaseType> expiry_fragment(
            fragment.message());
    mojo::internal::Serialize<::mojo_base::mojom::TimeDeltaDataView>(
        in_expiry, expiry_fragment);
    fragment->expiry.Set(
        expiry_fragment.is_null() ? nullptr : expiry_fragment.data());
    fragment->priority = Traits::priority(input);
    decltype(Traits::debug_key(input)) in_debug_key = Traits::debug_key(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->debug_key)::BaseType> debug_key_fragment(
            fragment.message());
    mojo::internal::Serialize<::blink::mojom::AttributionDebugKeyDataView>(
        in_debug_key, debug_key_fragment);
    fragment->debug_key.Set(
        debug_key_fragment.is_null() ? nullptr : debug_key_fragment.data());
    decltype(Traits::filter_data(input)) in_filter_data = Traits::filter_data(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->filter_data)::BaseType> filter_data_fragment(
            fragment.message());
    mojo::internal::Serialize<::blink::mojom::AttributionFilterDataDataView>(
        in_filter_data, filter_data_fragment);
    fragment->filter_data.Set(
        filter_data_fragment.is_null() ? nullptr : filter_data_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->filter_data.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null filter_data in AttributionSourceData struct");
    decltype(Traits::aggregation_keys(input)) in_aggregation_keys = Traits::aggregation_keys(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->aggregation_keys)::BaseType>
        aggregation_keys_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams aggregation_keys_validate_params(
        new mojo::internal::ContainerValidateParams(0, false, new mojo::internal::ContainerValidateParams(0, false, nullptr)), new mojo::internal::ContainerValidateParams(0, false, nullptr));
    mojo::internal::Serialize<mojo::MapDataView<mojo::StringDataView, ::mojo_base::mojom::Uint128DataView>>(
        in_aggregation_keys, aggregation_keys_fragment, &aggregation_keys_validate_params);
    fragment->aggregation_keys.Set(
        aggregation_keys_fragment.is_null() ? nullptr : aggregation_keys_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->aggregation_keys.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null aggregation_keys in AttributionSourceData struct");
  }

  static bool Deserialize(::blink::mojom::internal::AttributionSourceData_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::blink::mojom::AttributionSourceDataDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::blink::mojom::AttributionTriggerDedupKeyDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::blink::mojom::AttributionTriggerDedupKeyDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::blink::mojom::internal::AttributionTriggerDedupKey_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    fragment->value = Traits::value(input);
  }

  static bool Deserialize(::blink::mojom::internal::AttributionTriggerDedupKey_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::blink::mojom::AttributionTriggerDedupKeyDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::blink::mojom::EventTriggerDataDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::blink::mojom::EventTriggerDataDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::blink::mojom::internal::EventTriggerData_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    fragment->data = Traits::data(input);
    fragment->priority = Traits::priority(input);
    decltype(Traits::dedup_key(input)) in_dedup_key = Traits::dedup_key(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->dedup_key)::BaseType> dedup_key_fragment(
            fragment.message());
    mojo::internal::Serialize<::blink::mojom::AttributionTriggerDedupKeyDataView>(
        in_dedup_key, dedup_key_fragment);
    fragment->dedup_key.Set(
        dedup_key_fragment.is_null() ? nullptr : dedup_key_fragment.data());
    decltype(Traits::filters(input)) in_filters = Traits::filters(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->filters)::BaseType> filters_fragment(
            fragment.message());
    mojo::internal::Serialize<::blink::mojom::AttributionFilterDataDataView>(
        in_filters, filters_fragment);
    fragment->filters.Set(
        filters_fragment.is_null() ? nullptr : filters_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->filters.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null filters in EventTriggerData struct");
    decltype(Traits::not_filters(input)) in_not_filters = Traits::not_filters(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->not_filters)::BaseType> not_filters_fragment(
            fragment.message());
    mojo::internal::Serialize<::blink::mojom::AttributionFilterDataDataView>(
        in_not_filters, not_filters_fragment);
    fragment->not_filters.Set(
        not_filters_fragment.is_null() ? nullptr : not_filters_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->not_filters.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null not_filters in EventTriggerData struct");
  }

  static bool Deserialize(::blink::mojom::internal::EventTriggerData_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::blink::mojom::EventTriggerDataDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::blink::mojom::AttributionTriggerDataDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::blink::mojom::AttributionTriggerDataDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::blink::mojom::internal::AttributionTriggerData_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    decltype(Traits::reporting_origin(input)) in_reporting_origin = Traits::reporting_origin(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->reporting_origin)::BaseType> reporting_origin_fragment(
            fragment.message());
    mojo::internal::Serialize<::url::mojom::OriginDataView>(
        in_reporting_origin, reporting_origin_fragment);
    fragment->reporting_origin.Set(
        reporting_origin_fragment.is_null() ? nullptr : reporting_origin_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->reporting_origin.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null reporting_origin in AttributionTriggerData struct");
    decltype(Traits::event_triggers(input)) in_event_triggers = Traits::event_triggers(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->event_triggers)::BaseType>
        event_triggers_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams event_triggers_validate_params(
        0, false, nullptr);
    mojo::internal::Serialize<mojo::ArrayDataView<::blink::mojom::EventTriggerDataDataView>>(
        in_event_triggers, event_triggers_fragment, &event_triggers_validate_params);
    fragment->event_triggers.Set(
        event_triggers_fragment.is_null() ? nullptr : event_triggers_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->event_triggers.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null event_triggers in AttributionTriggerData struct");
    decltype(Traits::filters(input)) in_filters = Traits::filters(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->filters)::BaseType> filters_fragment(
            fragment.message());
    mojo::internal::Serialize<::blink::mojom::AttributionFilterDataDataView>(
        in_filters, filters_fragment);
    fragment->filters.Set(
        filters_fragment.is_null() ? nullptr : filters_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->filters.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null filters in AttributionTriggerData struct");
    decltype(Traits::not_filters(input)) in_not_filters = Traits::not_filters(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->not_filters)::BaseType> not_filters_fragment(
            fragment.message());
    mojo::internal::Serialize<::blink::mojom::AttributionFilterDataDataView>(
        in_not_filters, not_filters_fragment);
    fragment->not_filters.Set(
        not_filters_fragment.is_null() ? nullptr : not_filters_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->not_filters.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null not_filters in AttributionTriggerData struct");
    decltype(Traits::aggregatable_trigger_data(input)) in_aggregatable_trigger_data = Traits::aggregatable_trigger_data(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->aggregatable_trigger_data)::BaseType>
        aggregatable_trigger_data_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams aggregatable_trigger_data_validate_params(
        0, false, nullptr);
    mojo::internal::Serialize<mojo::ArrayDataView<::blink::mojom::AttributionAggregatableTriggerDataDataView>>(
        in_aggregatable_trigger_data, aggregatable_trigger_data_fragment, &aggregatable_trigger_data_validate_params);
    fragment->aggregatable_trigger_data.Set(
        aggregatable_trigger_data_fragment.is_null() ? nullptr : aggregatable_trigger_data_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->aggregatable_trigger_data.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null aggregatable_trigger_data in AttributionTriggerData struct");
    decltype(Traits::aggregatable_values(input)) in_aggregatable_values = Traits::aggregatable_values(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->aggregatable_values)::BaseType>
        aggregatable_values_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams aggregatable_values_validate_params(
        new mojo::internal::ContainerValidateParams(0, false, new mojo::internal::ContainerValidateParams(0, false, nullptr)), new mojo::internal::ContainerValidateParams(0, false, nullptr));
    mojo::internal::Serialize<mojo::MapDataView<mojo::StringDataView, uint32_t>>(
        in_aggregatable_values, aggregatable_values_fragment, &aggregatable_values_validate_params);
    fragment->aggregatable_values.Set(
        aggregatable_values_fragment.is_null() ? nullptr : aggregatable_values_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->aggregatable_values.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null aggregatable_values in AttributionTriggerData struct");
    decltype(Traits::debug_key(input)) in_debug_key = Traits::debug_key(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->debug_key)::BaseType> debug_key_fragment(
            fragment.message());
    mojo::internal::Serialize<::blink::mojom::AttributionDebugKeyDataView>(
        in_debug_key, debug_key_fragment);
    fragment->debug_key.Set(
        debug_key_fragment.is_null() ? nullptr : debug_key_fragment.data());
  }

  static bool Deserialize(::blink::mojom::internal::AttributionTriggerData_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::blink::mojom::AttributionTriggerDataDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal

}  // namespace mojo


namespace blink {
namespace mojom {



inline void AttributionFilterDataDataView::GetFilterValuesDataView(
    mojo::MapDataView<mojo::StringDataView, mojo::ArrayDataView<mojo::StringDataView>>* output) {
  auto pointer = data_->filter_values.Get();
  *output = mojo::MapDataView<mojo::StringDataView, mojo::ArrayDataView<mojo::StringDataView>>(pointer, message_);
}


inline void AttributionAggregatableTriggerDataDataView::GetKeyPieceDataView(
    ::mojo_base::mojom::Uint128DataView* output) {
  auto pointer = data_->key_piece.Get();
  *output = ::mojo_base::mojom::Uint128DataView(pointer, message_);
}
inline void AttributionAggregatableTriggerDataDataView::GetSourceKeysDataView(
    mojo::ArrayDataView<mojo::StringDataView>* output) {
  auto pointer = data_->source_keys.Get();
  *output = mojo::ArrayDataView<mojo::StringDataView>(pointer, message_);
}
inline void AttributionAggregatableTriggerDataDataView::GetFiltersDataView(
    AttributionFilterDataDataView* output) {
  auto pointer = data_->filters.Get();
  *output = AttributionFilterDataDataView(pointer, message_);
}
inline void AttributionAggregatableTriggerDataDataView::GetNotFiltersDataView(
    AttributionFilterDataDataView* output) {
  auto pointer = data_->not_filters.Get();
  *output = AttributionFilterDataDataView(pointer, message_);
}


inline void AttributionSourceDataDataView::GetDestinationDataView(
    ::url::mojom::OriginDataView* output) {
  auto pointer = data_->destination.Get();
  *output = ::url::mojom::OriginDataView(pointer, message_);
}
inline void AttributionSourceDataDataView::GetReportingOriginDataView(
    ::url::mojom::OriginDataView* output) {
  auto pointer = data_->reporting_origin.Get();
  *output = ::url::mojom::OriginDataView(pointer, message_);
}
inline void AttributionSourceDataDataView::GetExpiryDataView(
    ::mojo_base::mojom::TimeDeltaDataView* output) {
  auto pointer = data_->expiry.Get();
  *output = ::mojo_base::mojom::TimeDeltaDataView(pointer, message_);
}
inline void AttributionSourceDataDataView::GetDebugKeyDataView(
    AttributionDebugKeyDataView* output) {
  auto pointer = data_->debug_key.Get();
  *output = AttributionDebugKeyDataView(pointer, message_);
}
inline void AttributionSourceDataDataView::GetFilterDataDataView(
    AttributionFilterDataDataView* output) {
  auto pointer = data_->filter_data.Get();
  *output = AttributionFilterDataDataView(pointer, message_);
}
inline void AttributionSourceDataDataView::GetAggregationKeysDataView(
    mojo::MapDataView<mojo::StringDataView, ::mojo_base::mojom::Uint128DataView>* output) {
  auto pointer = data_->aggregation_keys.Get();
  *output = mojo::MapDataView<mojo::StringDataView, ::mojo_base::mojom::Uint128DataView>(pointer, message_);
}




inline void EventTriggerDataDataView::GetDedupKeyDataView(
    AttributionTriggerDedupKeyDataView* output) {
  auto pointer = data_->dedup_key.Get();
  *output = AttributionTriggerDedupKeyDataView(pointer, message_);
}
inline void EventTriggerDataDataView::GetFiltersDataView(
    AttributionFilterDataDataView* output) {
  auto pointer = data_->filters.Get();
  *output = AttributionFilterDataDataView(pointer, message_);
}
inline void EventTriggerDataDataView::GetNotFiltersDataView(
    AttributionFilterDataDataView* output) {
  auto pointer = data_->not_filters.Get();
  *output = AttributionFilterDataDataView(pointer, message_);
}


inline void AttributionTriggerDataDataView::GetReportingOriginDataView(
    ::url::mojom::OriginDataView* output) {
  auto pointer = data_->reporting_origin.Get();
  *output = ::url::mojom::OriginDataView(pointer, message_);
}
inline void AttributionTriggerDataDataView::GetEventTriggersDataView(
    mojo::ArrayDataView<EventTriggerDataDataView>* output) {
  auto pointer = data_->event_triggers.Get();
  *output = mojo::ArrayDataView<EventTriggerDataDataView>(pointer, message_);
}
inline void AttributionTriggerDataDataView::GetFiltersDataView(
    AttributionFilterDataDataView* output) {
  auto pointer = data_->filters.Get();
  *output = AttributionFilterDataDataView(pointer, message_);
}
inline void AttributionTriggerDataDataView::GetNotFiltersDataView(
    AttributionFilterDataDataView* output) {
  auto pointer = data_->not_filters.Get();
  *output = AttributionFilterDataDataView(pointer, message_);
}
inline void AttributionTriggerDataDataView::GetAggregatableTriggerDataDataView(
    mojo::ArrayDataView<AttributionAggregatableTriggerDataDataView>* output) {
  auto pointer = data_->aggregatable_trigger_data.Get();
  *output = mojo::ArrayDataView<AttributionAggregatableTriggerDataDataView>(pointer, message_);
}
inline void AttributionTriggerDataDataView::GetAggregatableValuesDataView(
    mojo::MapDataView<mojo::StringDataView, uint32_t>* output) {
  auto pointer = data_->aggregatable_values.Get();
  *output = mojo::MapDataView<mojo::StringDataView, uint32_t>(pointer, message_);
}
inline void AttributionTriggerDataDataView::GetDebugKeyDataView(
    AttributionDebugKeyDataView* output) {
  auto pointer = data_->debug_key.Get();
  *output = AttributionDebugKeyDataView(pointer, message_);
}



}  // namespace mojom
}  // namespace blink

// Declare TraceFormatTraits for enums, which should be defined in ::perfetto
// namespace.

#endif  // THIRD_PARTY_BLINK_PUBLIC_MOJOM_CONVERSIONS_ATTRIBUTION_DATA_HOST_MOJOM_SHARED_H_