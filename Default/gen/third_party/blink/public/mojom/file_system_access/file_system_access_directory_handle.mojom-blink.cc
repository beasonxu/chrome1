// third_party/blink/public/mojom/file_system_access/file_system_access_directory_handle.mojom-blink.cc is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2013 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#if defined(__clang__)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-private-field"
#endif

#include "third_party/blink/public/mojom/file_system_access/file_system_access_directory_handle.mojom-blink.h"

#include <math.h>
#include <stdint.h>
#include <utility>

#include "base/debug/alias.h"
#include "base/hash/md5_constexpr.h"
#include "base/run_loop.h"
#include "base/strings/string_number_conversions.h"
#include "base/trace_event/trace_event.h"
#include "base/trace_event/typed_macros.h"
#include "mojo/public/cpp/bindings/lib/generated_code_util.h"
#include "mojo/public/cpp/bindings/lib/message_internal.h"
#include "mojo/public/cpp/bindings/lib/send_message_helper.h"
#include "mojo/public/cpp/bindings/lib/proxy_to_responder.h"
#include "mojo/public/cpp/bindings/lib/serialization_util.h"
#include "mojo/public/cpp/bindings/lib/unserialized_message_context.h"
#include "mojo/public/cpp/bindings/lib/validate_params.h"
#include "mojo/public/cpp/bindings/lib/validation_errors.h"
#include "mojo/public/cpp/bindings/mojo_buildflags.h"
#include "mojo/public/interfaces/bindings/interface_control_messages.mojom.h"
#include "third_party/perfetto/include/perfetto/tracing/traced_value.h"

#include "third_party/blink/public/mojom/file_system_access/file_system_access_directory_handle.mojom-params-data.h"
#include "third_party/blink/public/mojom/file_system_access/file_system_access_directory_handle.mojom-shared-message-ids.h"

#include "third_party/blink/public/mojom/file_system_access/file_system_access_directory_handle.mojom-blink-import-headers.h"
#include "third_party/blink/public/mojom/file_system_access/file_system_access_directory_handle.mojom-blink-test-utils.h"
#include "mojo/public/cpp/bindings/lib/wtf_serialization.h"


#ifndef THIRD_PARTY_BLINK_PUBLIC_MOJOM_FILE_SYSTEM_ACCESS_FILE_SYSTEM_ACCESS_DIRECTORY_HANDLE_MOJOM_BLINK_JUMBO_H_
#define THIRD_PARTY_BLINK_PUBLIC_MOJOM_FILE_SYSTEM_ACCESS_FILE_SYSTEM_ACCESS_DIRECTORY_HANDLE_MOJOM_BLINK_JUMBO_H_
#endif



namespace blink {
namespace mojom {
namespace blink {
FileSystemAccessEntry::FileSystemAccessEntry()
    : entry_handle(),
      name() {}

FileSystemAccessEntry::FileSystemAccessEntry(
    FileSystemAccessHandlePtr entry_handle_in,
    const WTF::String& name_in)
    : entry_handle(std::move(entry_handle_in)),
      name(std::move(name_in)) {}

FileSystemAccessEntry::~FileSystemAccessEntry() = default;

void FileSystemAccessEntry::WriteIntoTrace(
    perfetto::TracedValue traced_context) const {
  [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "entry_handle"), this->entry_handle,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type FileSystemAccessHandlePtr>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "name"), this->name,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const WTF::String&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool FileSystemAccessEntry::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
FileSystemAccessHandle::FileSystemAccessHandle() : tag_(Tag::kFile) {
  data_.file = new ::mojo::PendingRemote<::blink::mojom::blink::FileSystemAccessFileHandle>;
}

FileSystemAccessHandle::~FileSystemAccessHandle() {
  DestroyActive();
}


void FileSystemAccessHandle::set_file(
    ::mojo::PendingRemote<::blink::mojom::blink::FileSystemAccessFileHandle> file) {
  if (tag_ == Tag::kFile) {
    *(data_.file) = std::move(file);
  } else {
    DestroyActive();
    tag_ = Tag::kFile;
    data_.file = new ::mojo::PendingRemote<::blink::mojom::blink::FileSystemAccessFileHandle>(
        std::move(file));
  }
}
void FileSystemAccessHandle::set_directory(
    ::mojo::PendingRemote<FileSystemAccessDirectoryHandle> directory) {
  if (tag_ == Tag::kDirectory) {
    *(data_.directory) = std::move(directory);
  } else {
    DestroyActive();
    tag_ = Tag::kDirectory;
    data_.directory = new ::mojo::PendingRemote<FileSystemAccessDirectoryHandle>(
        std::move(directory));
  }
}

void FileSystemAccessHandle::DestroyActive() {
  switch (tag_) {

    case Tag::kFile:

      delete data_.file;
      break;
    case Tag::kDirectory:

      delete data_.directory;
      break;
  }
}

bool FileSystemAccessHandle::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context, false);
}
const char FileSystemAccessDirectoryEntriesListener::Name_[] = "blink.mojom.FileSystemAccessDirectoryEntriesListener";

FileSystemAccessDirectoryEntriesListener::IPCStableHashFunction FileSystemAccessDirectoryEntriesListener::MessageToMethodInfo_(mojo::Message& message) {
#if !BUILDFLAG(IS_FUCHSIA)
  switch (message.name()) {
    case internal::kFileSystemAccessDirectoryEntriesListener_DidReadDirectory_Name: {
      return &FileSystemAccessDirectoryEntriesListener::DidReadDirectory_Sym::IPCStableHash;
    }
  }
#endif  // !BUILDFLAG(IS_FUCHSIA)
  return nullptr;
}


const char* FileSystemAccessDirectoryEntriesListener::MessageToMethodName_(mojo::Message& message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  bool is_response = message.has_flag(mojo::Message::kFlagIsResponse);
  if (!is_response) {
    switch (message.name()) {
      case internal::kFileSystemAccessDirectoryEntriesListener_DidReadDirectory_Name:
            return "Receive blink::mojom::FileSystemAccessDirectoryEntriesListener::DidReadDirectory";
    }
  } else {
    switch (message.name()) {
      case internal::kFileSystemAccessDirectoryEntriesListener_DidReadDirectory_Name:
            return "Receive reply blink::mojom::FileSystemAccessDirectoryEntriesListener::DidReadDirectory";
    }
  }
  return "Receive unknown mojo message";
#else
  bool is_response = message.has_flag(mojo::Message::kFlagIsResponse);
  if (is_response) {
    return "Receive mojo reply";
  } else {
    return "Receive mojo message";
  }
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
}

#if !BUILDFLAG(IS_FUCHSIA)
uint32_t FileSystemAccessDirectoryEntriesListener::DidReadDirectory_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::FileSystemAccessDirectoryEntriesListener::DidReadDirectory");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
# endif // !BUILDFLAG(IS_FUCHSIA)

FileSystemAccessDirectoryEntriesListenerProxy::FileSystemAccessDirectoryEntriesListenerProxy(mojo::MessageReceiverWithResponder* receiver)
    : receiver_(receiver) {
}

void FileSystemAccessDirectoryEntriesListenerProxy::DidReadDirectory(
    ::blink::mojom::blink::FileSystemAccessErrorPtr in_result, WTF::Vector<FileSystemAccessEntryPtr> in_entries, bool in_has_more_entries) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::FileSystemAccessDirectoryEntriesListener::DidReadDirectory", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("result"), in_result,
                        "<value of type ::blink::mojom::blink::FileSystemAccessErrorPtr>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("entries"), in_entries,
                        "<value of type WTF::Vector<FileSystemAccessEntryPtr>>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("has_more_entries"), in_has_more_entries,
                        "<value of type bool>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kFileSystemAccessDirectoryEntriesListener_DidReadDirectory_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::FileSystemAccessDirectoryEntriesListener_DidReadDirectory_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->result)::BaseType> result_fragment(
          params.message());
  mojo::internal::Serialize<::blink::mojom::FileSystemAccessErrorDataView>(
      in_result, result_fragment);
  params->result.Set(
      result_fragment.is_null() ? nullptr : result_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->result.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null result in FileSystemAccessDirectoryEntriesListener.DidReadDirectory request");
  mojo::internal::MessageFragment<
      typename decltype(params->entries)::BaseType>
      entries_fragment(params.message());
  const mojo::internal::ContainerValidateParams entries_validate_params(
      0, false, nullptr);
  mojo::internal::Serialize<mojo::ArrayDataView<::blink::mojom::FileSystemAccessEntryDataView>>(
      in_entries, entries_fragment, &entries_validate_params);
  params->entries.Set(
      entries_fragment.is_null() ? nullptr : entries_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->entries.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null entries in FileSystemAccessDirectoryEntriesListener.DidReadDirectory request");
  params->has_more_entries = in_has_more_entries;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(FileSystemAccessDirectoryEntriesListener::Name_);
  message.set_method_name("DidReadDirectory");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

// static
bool FileSystemAccessDirectoryEntriesListenerStubDispatch::Accept(
    FileSystemAccessDirectoryEntriesListener* impl,
    mojo::Message* message) {
  switch (message->header()->name) {
    case internal::kFileSystemAccessDirectoryEntriesListener_DidReadDirectory_Name: {

      DCHECK(message->is_serialized());
      internal::FileSystemAccessDirectoryEntriesListener_DidReadDirectory_Params_Data* params =
          reinterpret_cast<internal::FileSystemAccessDirectoryEntriesListener_DidReadDirectory_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::blink::mojom::blink::FileSystemAccessErrorPtr p_result{};
      WTF::Vector<FileSystemAccessEntryPtr> p_entries{};
      bool p_has_more_entries{};
      FileSystemAccessDirectoryEntriesListener_DidReadDirectory_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadResult(&p_result))
        success = false;
      if (success && !input_data_view.ReadEntries(&p_entries))
        success = false;
      if (success)
        p_has_more_entries = input_data_view.has_more_entries();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            FileSystemAccessDirectoryEntriesListener::Name_, 0, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->DidReadDirectory(
std::move(p_result), 
std::move(p_entries), 
std::move(p_has_more_entries));
      return true;
    }
  }
  return false;
}

// static
bool FileSystemAccessDirectoryEntriesListenerStubDispatch::AcceptWithResponder(
    FileSystemAccessDirectoryEntriesListener* impl,
    mojo::Message* message,
    std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
  [[maybe_unused]] const bool message_is_sync =
      message->has_flag(mojo::Message::kFlagIsSync);
  [[maybe_unused]] const uint64_t request_id = message->request_id();
  switch (message->header()->name) {
    case internal::kFileSystemAccessDirectoryEntriesListener_DidReadDirectory_Name: {
      break;
    }
  }
  return false;
}


static const mojo::internal::GenericValidationInfo kFileSystemAccessDirectoryEntriesListenerValidationInfo[] = {
    {&internal::FileSystemAccessDirectoryEntriesListener_DidReadDirectory_Params_Data::Validate,
     nullptr /* no response */},
};

bool FileSystemAccessDirectoryEntriesListenerRequestValidator::Accept(mojo::Message* message) {
  const char* name = ::blink::mojom::blink::FileSystemAccessDirectoryEntriesListener::Name_;
  return mojo::internal::ValidateRequestGenericPacked(message, name, kFileSystemAccessDirectoryEntriesListenerValidationInfo);
}

const char FileSystemAccessDirectoryHandle::Name_[] = "blink.mojom.FileSystemAccessDirectoryHandle";

FileSystemAccessDirectoryHandle::IPCStableHashFunction FileSystemAccessDirectoryHandle::MessageToMethodInfo_(mojo::Message& message) {
#if !BUILDFLAG(IS_FUCHSIA)
  switch (message.name()) {
    case internal::kFileSystemAccessDirectoryHandle_GetPermissionStatus_Name: {
      return &FileSystemAccessDirectoryHandle::GetPermissionStatus_Sym::IPCStableHash;
    }
    case internal::kFileSystemAccessDirectoryHandle_RequestPermission_Name: {
      return &FileSystemAccessDirectoryHandle::RequestPermission_Sym::IPCStableHash;
    }
    case internal::kFileSystemAccessDirectoryHandle_GetFile_Name: {
      return &FileSystemAccessDirectoryHandle::GetFile_Sym::IPCStableHash;
    }
    case internal::kFileSystemAccessDirectoryHandle_GetDirectory_Name: {
      return &FileSystemAccessDirectoryHandle::GetDirectory_Sym::IPCStableHash;
    }
    case internal::kFileSystemAccessDirectoryHandle_GetEntries_Name: {
      return &FileSystemAccessDirectoryHandle::GetEntries_Sym::IPCStableHash;
    }
    case internal::kFileSystemAccessDirectoryHandle_Rename_Name: {
      return &FileSystemAccessDirectoryHandle::Rename_Sym::IPCStableHash;
    }
    case internal::kFileSystemAccessDirectoryHandle_Move_Name: {
      return &FileSystemAccessDirectoryHandle::Move_Sym::IPCStableHash;
    }
    case internal::kFileSystemAccessDirectoryHandle_Remove_Name: {
      return &FileSystemAccessDirectoryHandle::Remove_Sym::IPCStableHash;
    }
    case internal::kFileSystemAccessDirectoryHandle_RemoveEntry_Name: {
      return &FileSystemAccessDirectoryHandle::RemoveEntry_Sym::IPCStableHash;
    }
    case internal::kFileSystemAccessDirectoryHandle_Resolve_Name: {
      return &FileSystemAccessDirectoryHandle::Resolve_Sym::IPCStableHash;
    }
    case internal::kFileSystemAccessDirectoryHandle_Transfer_Name: {
      return &FileSystemAccessDirectoryHandle::Transfer_Sym::IPCStableHash;
    }
  }
#endif  // !BUILDFLAG(IS_FUCHSIA)
  return nullptr;
}


const char* FileSystemAccessDirectoryHandle::MessageToMethodName_(mojo::Message& message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  bool is_response = message.has_flag(mojo::Message::kFlagIsResponse);
  if (!is_response) {
    switch (message.name()) {
      case internal::kFileSystemAccessDirectoryHandle_GetPermissionStatus_Name:
            return "Receive blink::mojom::FileSystemAccessDirectoryHandle::GetPermissionStatus";
      case internal::kFileSystemAccessDirectoryHandle_RequestPermission_Name:
            return "Receive blink::mojom::FileSystemAccessDirectoryHandle::RequestPermission";
      case internal::kFileSystemAccessDirectoryHandle_GetFile_Name:
            return "Receive blink::mojom::FileSystemAccessDirectoryHandle::GetFile";
      case internal::kFileSystemAccessDirectoryHandle_GetDirectory_Name:
            return "Receive blink::mojom::FileSystemAccessDirectoryHandle::GetDirectory";
      case internal::kFileSystemAccessDirectoryHandle_GetEntries_Name:
            return "Receive blink::mojom::FileSystemAccessDirectoryHandle::GetEntries";
      case internal::kFileSystemAccessDirectoryHandle_Rename_Name:
            return "Receive blink::mojom::FileSystemAccessDirectoryHandle::Rename";
      case internal::kFileSystemAccessDirectoryHandle_Move_Name:
            return "Receive blink::mojom::FileSystemAccessDirectoryHandle::Move";
      case internal::kFileSystemAccessDirectoryHandle_Remove_Name:
            return "Receive blink::mojom::FileSystemAccessDirectoryHandle::Remove";
      case internal::kFileSystemAccessDirectoryHandle_RemoveEntry_Name:
            return "Receive blink::mojom::FileSystemAccessDirectoryHandle::RemoveEntry";
      case internal::kFileSystemAccessDirectoryHandle_Resolve_Name:
            return "Receive blink::mojom::FileSystemAccessDirectoryHandle::Resolve";
      case internal::kFileSystemAccessDirectoryHandle_Transfer_Name:
            return "Receive blink::mojom::FileSystemAccessDirectoryHandle::Transfer";
    }
  } else {
    switch (message.name()) {
      case internal::kFileSystemAccessDirectoryHandle_GetPermissionStatus_Name:
            return "Receive reply blink::mojom::FileSystemAccessDirectoryHandle::GetPermissionStatus";
      case internal::kFileSystemAccessDirectoryHandle_RequestPermission_Name:
            return "Receive reply blink::mojom::FileSystemAccessDirectoryHandle::RequestPermission";
      case internal::kFileSystemAccessDirectoryHandle_GetFile_Name:
            return "Receive reply blink::mojom::FileSystemAccessDirectoryHandle::GetFile";
      case internal::kFileSystemAccessDirectoryHandle_GetDirectory_Name:
            return "Receive reply blink::mojom::FileSystemAccessDirectoryHandle::GetDirectory";
      case internal::kFileSystemAccessDirectoryHandle_GetEntries_Name:
            return "Receive reply blink::mojom::FileSystemAccessDirectoryHandle::GetEntries";
      case internal::kFileSystemAccessDirectoryHandle_Rename_Name:
            return "Receive reply blink::mojom::FileSystemAccessDirectoryHandle::Rename";
      case internal::kFileSystemAccessDirectoryHandle_Move_Name:
            return "Receive reply blink::mojom::FileSystemAccessDirectoryHandle::Move";
      case internal::kFileSystemAccessDirectoryHandle_Remove_Name:
            return "Receive reply blink::mojom::FileSystemAccessDirectoryHandle::Remove";
      case internal::kFileSystemAccessDirectoryHandle_RemoveEntry_Name:
            return "Receive reply blink::mojom::FileSystemAccessDirectoryHandle::RemoveEntry";
      case internal::kFileSystemAccessDirectoryHandle_Resolve_Name:
            return "Receive reply blink::mojom::FileSystemAccessDirectoryHandle::Resolve";
      case internal::kFileSystemAccessDirectoryHandle_Transfer_Name:
            return "Receive reply blink::mojom::FileSystemAccessDirectoryHandle::Transfer";
    }
  }
  return "Receive unknown mojo message";
#else
  bool is_response = message.has_flag(mojo::Message::kFlagIsResponse);
  if (is_response) {
    return "Receive mojo reply";
  } else {
    return "Receive mojo message";
  }
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
}

#if !BUILDFLAG(IS_FUCHSIA)
uint32_t FileSystemAccessDirectoryHandle::GetPermissionStatus_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::FileSystemAccessDirectoryHandle::GetPermissionStatus");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t FileSystemAccessDirectoryHandle::RequestPermission_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::FileSystemAccessDirectoryHandle::RequestPermission");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t FileSystemAccessDirectoryHandle::GetFile_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::FileSystemAccessDirectoryHandle::GetFile");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t FileSystemAccessDirectoryHandle::GetDirectory_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::FileSystemAccessDirectoryHandle::GetDirectory");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t FileSystemAccessDirectoryHandle::GetEntries_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::FileSystemAccessDirectoryHandle::GetEntries");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t FileSystemAccessDirectoryHandle::Rename_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::FileSystemAccessDirectoryHandle::Rename");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t FileSystemAccessDirectoryHandle::Move_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::FileSystemAccessDirectoryHandle::Move");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t FileSystemAccessDirectoryHandle::Remove_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::FileSystemAccessDirectoryHandle::Remove");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t FileSystemAccessDirectoryHandle::RemoveEntry_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::FileSystemAccessDirectoryHandle::RemoveEntry");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t FileSystemAccessDirectoryHandle::Resolve_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::FileSystemAccessDirectoryHandle::Resolve");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t FileSystemAccessDirectoryHandle::Transfer_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::FileSystemAccessDirectoryHandle::Transfer");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
# endif // !BUILDFLAG(IS_FUCHSIA)

class FileSystemAccessDirectoryHandle_GetPermissionStatus_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  FileSystemAccessDirectoryHandle_GetPermissionStatus_ForwardToCallback(
      FileSystemAccessDirectoryHandle::GetPermissionStatusCallback callback
      ) : callback_(std::move(callback)) {
  }

  FileSystemAccessDirectoryHandle_GetPermissionStatus_ForwardToCallback(const FileSystemAccessDirectoryHandle_GetPermissionStatus_ForwardToCallback&) = delete;
  FileSystemAccessDirectoryHandle_GetPermissionStatus_ForwardToCallback& operator=(const FileSystemAccessDirectoryHandle_GetPermissionStatus_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  FileSystemAccessDirectoryHandle::GetPermissionStatusCallback callback_;
};

class FileSystemAccessDirectoryHandle_RequestPermission_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  FileSystemAccessDirectoryHandle_RequestPermission_ForwardToCallback(
      FileSystemAccessDirectoryHandle::RequestPermissionCallback callback
      ) : callback_(std::move(callback)) {
  }

  FileSystemAccessDirectoryHandle_RequestPermission_ForwardToCallback(const FileSystemAccessDirectoryHandle_RequestPermission_ForwardToCallback&) = delete;
  FileSystemAccessDirectoryHandle_RequestPermission_ForwardToCallback& operator=(const FileSystemAccessDirectoryHandle_RequestPermission_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  FileSystemAccessDirectoryHandle::RequestPermissionCallback callback_;
};

class FileSystemAccessDirectoryHandle_GetFile_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  FileSystemAccessDirectoryHandle_GetFile_ForwardToCallback(
      FileSystemAccessDirectoryHandle::GetFileCallback callback
      ) : callback_(std::move(callback)) {
  }

  FileSystemAccessDirectoryHandle_GetFile_ForwardToCallback(const FileSystemAccessDirectoryHandle_GetFile_ForwardToCallback&) = delete;
  FileSystemAccessDirectoryHandle_GetFile_ForwardToCallback& operator=(const FileSystemAccessDirectoryHandle_GetFile_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  FileSystemAccessDirectoryHandle::GetFileCallback callback_;
};

class FileSystemAccessDirectoryHandle_GetDirectory_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  FileSystemAccessDirectoryHandle_GetDirectory_ForwardToCallback(
      FileSystemAccessDirectoryHandle::GetDirectoryCallback callback
      ) : callback_(std::move(callback)) {
  }

  FileSystemAccessDirectoryHandle_GetDirectory_ForwardToCallback(const FileSystemAccessDirectoryHandle_GetDirectory_ForwardToCallback&) = delete;
  FileSystemAccessDirectoryHandle_GetDirectory_ForwardToCallback& operator=(const FileSystemAccessDirectoryHandle_GetDirectory_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  FileSystemAccessDirectoryHandle::GetDirectoryCallback callback_;
};

class FileSystemAccessDirectoryHandle_Rename_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  FileSystemAccessDirectoryHandle_Rename_ForwardToCallback(
      FileSystemAccessDirectoryHandle::RenameCallback callback
      ) : callback_(std::move(callback)) {
  }

  FileSystemAccessDirectoryHandle_Rename_ForwardToCallback(const FileSystemAccessDirectoryHandle_Rename_ForwardToCallback&) = delete;
  FileSystemAccessDirectoryHandle_Rename_ForwardToCallback& operator=(const FileSystemAccessDirectoryHandle_Rename_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  FileSystemAccessDirectoryHandle::RenameCallback callback_;
};

class FileSystemAccessDirectoryHandle_Move_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  FileSystemAccessDirectoryHandle_Move_ForwardToCallback(
      FileSystemAccessDirectoryHandle::MoveCallback callback
      ) : callback_(std::move(callback)) {
  }

  FileSystemAccessDirectoryHandle_Move_ForwardToCallback(const FileSystemAccessDirectoryHandle_Move_ForwardToCallback&) = delete;
  FileSystemAccessDirectoryHandle_Move_ForwardToCallback& operator=(const FileSystemAccessDirectoryHandle_Move_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  FileSystemAccessDirectoryHandle::MoveCallback callback_;
};

class FileSystemAccessDirectoryHandle_Remove_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  FileSystemAccessDirectoryHandle_Remove_ForwardToCallback(
      FileSystemAccessDirectoryHandle::RemoveCallback callback
      ) : callback_(std::move(callback)) {
  }

  FileSystemAccessDirectoryHandle_Remove_ForwardToCallback(const FileSystemAccessDirectoryHandle_Remove_ForwardToCallback&) = delete;
  FileSystemAccessDirectoryHandle_Remove_ForwardToCallback& operator=(const FileSystemAccessDirectoryHandle_Remove_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  FileSystemAccessDirectoryHandle::RemoveCallback callback_;
};

class FileSystemAccessDirectoryHandle_RemoveEntry_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  FileSystemAccessDirectoryHandle_RemoveEntry_ForwardToCallback(
      FileSystemAccessDirectoryHandle::RemoveEntryCallback callback
      ) : callback_(std::move(callback)) {
  }

  FileSystemAccessDirectoryHandle_RemoveEntry_ForwardToCallback(const FileSystemAccessDirectoryHandle_RemoveEntry_ForwardToCallback&) = delete;
  FileSystemAccessDirectoryHandle_RemoveEntry_ForwardToCallback& operator=(const FileSystemAccessDirectoryHandle_RemoveEntry_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  FileSystemAccessDirectoryHandle::RemoveEntryCallback callback_;
};

class FileSystemAccessDirectoryHandle_Resolve_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  FileSystemAccessDirectoryHandle_Resolve_ForwardToCallback(
      FileSystemAccessDirectoryHandle::ResolveCallback callback
      ) : callback_(std::move(callback)) {
  }

  FileSystemAccessDirectoryHandle_Resolve_ForwardToCallback(const FileSystemAccessDirectoryHandle_Resolve_ForwardToCallback&) = delete;
  FileSystemAccessDirectoryHandle_Resolve_ForwardToCallback& operator=(const FileSystemAccessDirectoryHandle_Resolve_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  FileSystemAccessDirectoryHandle::ResolveCallback callback_;
};

FileSystemAccessDirectoryHandleProxy::FileSystemAccessDirectoryHandleProxy(mojo::MessageReceiverWithResponder* receiver)
    : receiver_(receiver) {
}

void FileSystemAccessDirectoryHandleProxy::GetPermissionStatus(
    bool in_writable, GetPermissionStatusCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::FileSystemAccessDirectoryHandle::GetPermissionStatus", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("writable"), in_writable,
                        "<value of type bool>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kFileSystemAccessDirectoryHandle_GetPermissionStatus_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::FileSystemAccessDirectoryHandle_GetPermissionStatus_Params_Data> params(
          message);
  params.Allocate();
  params->writable = in_writable;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(FileSystemAccessDirectoryHandle::Name_);
  message.set_method_name("GetPermissionStatus");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new FileSystemAccessDirectoryHandle_GetPermissionStatus_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void FileSystemAccessDirectoryHandleProxy::RequestPermission(
    bool in_writable, RequestPermissionCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::FileSystemAccessDirectoryHandle::RequestPermission", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("writable"), in_writable,
                        "<value of type bool>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kFileSystemAccessDirectoryHandle_RequestPermission_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::FileSystemAccessDirectoryHandle_RequestPermission_Params_Data> params(
          message);
  params.Allocate();
  params->writable = in_writable;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(FileSystemAccessDirectoryHandle::Name_);
  message.set_method_name("RequestPermission");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new FileSystemAccessDirectoryHandle_RequestPermission_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void FileSystemAccessDirectoryHandleProxy::GetFile(
    const WTF::String& in_basename, bool in_create, GetFileCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::FileSystemAccessDirectoryHandle::GetFile", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("basename"), in_basename,
                        "<value of type const WTF::String&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("create"), in_create,
                        "<value of type bool>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kFileSystemAccessDirectoryHandle_GetFile_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::FileSystemAccessDirectoryHandle_GetFile_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->basename)::BaseType> basename_fragment(
          params.message());
  mojo::internal::Serialize<mojo::StringDataView>(
      in_basename, basename_fragment);
  params->basename.Set(
      basename_fragment.is_null() ? nullptr : basename_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->basename.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null basename in FileSystemAccessDirectoryHandle.GetFile request");
  params->create = in_create;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(FileSystemAccessDirectoryHandle::Name_);
  message.set_method_name("GetFile");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new FileSystemAccessDirectoryHandle_GetFile_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void FileSystemAccessDirectoryHandleProxy::GetDirectory(
    const WTF::String& in_basename, bool in_create, GetDirectoryCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::FileSystemAccessDirectoryHandle::GetDirectory", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("basename"), in_basename,
                        "<value of type const WTF::String&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("create"), in_create,
                        "<value of type bool>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kFileSystemAccessDirectoryHandle_GetDirectory_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::FileSystemAccessDirectoryHandle_GetDirectory_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->basename)::BaseType> basename_fragment(
          params.message());
  mojo::internal::Serialize<mojo::StringDataView>(
      in_basename, basename_fragment);
  params->basename.Set(
      basename_fragment.is_null() ? nullptr : basename_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->basename.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null basename in FileSystemAccessDirectoryHandle.GetDirectory request");
  params->create = in_create;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(FileSystemAccessDirectoryHandle::Name_);
  message.set_method_name("GetDirectory");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new FileSystemAccessDirectoryHandle_GetDirectory_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void FileSystemAccessDirectoryHandleProxy::GetEntries(
    ::mojo::PendingRemote<FileSystemAccessDirectoryEntriesListener> in_listener) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::FileSystemAccessDirectoryHandle::GetEntries", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("listener"), in_listener,
                        "<value of type ::mojo::PendingRemote<FileSystemAccessDirectoryEntriesListener>>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kFileSystemAccessDirectoryHandle_GetEntries_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::FileSystemAccessDirectoryHandle_GetEntries_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::Serialize<mojo::InterfacePtrDataView<::blink::mojom::FileSystemAccessDirectoryEntriesListenerInterfaceBase>>(
      in_listener, &params->listener, &params.message());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      !mojo::internal::IsHandleOrInterfaceValid(params->listener),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_INVALID_HANDLE,
      "invalid listener in FileSystemAccessDirectoryHandle.GetEntries request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(FileSystemAccessDirectoryHandle::Name_);
  message.set_method_name("GetEntries");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void FileSystemAccessDirectoryHandleProxy::Rename(
    const WTF::String& in_new_entry_name, RenameCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::FileSystemAccessDirectoryHandle::Rename", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("new_entry_name"), in_new_entry_name,
                        "<value of type const WTF::String&>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kFileSystemAccessDirectoryHandle_Rename_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::FileSystemAccessDirectoryHandle_Rename_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->new_entry_name)::BaseType> new_entry_name_fragment(
          params.message());
  mojo::internal::Serialize<mojo::StringDataView>(
      in_new_entry_name, new_entry_name_fragment);
  params->new_entry_name.Set(
      new_entry_name_fragment.is_null() ? nullptr : new_entry_name_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->new_entry_name.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null new_entry_name in FileSystemAccessDirectoryHandle.Rename request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(FileSystemAccessDirectoryHandle::Name_);
  message.set_method_name("Rename");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new FileSystemAccessDirectoryHandle_Rename_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void FileSystemAccessDirectoryHandleProxy::Move(
    ::mojo::PendingRemote<::blink::mojom::blink::FileSystemAccessTransferToken> in_destination_directory, const WTF::String& in_new_entry_name, MoveCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::FileSystemAccessDirectoryHandle::Move", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("destination_directory"), in_destination_directory,
                        "<value of type ::mojo::PendingRemote<::blink::mojom::blink::FileSystemAccessTransferToken>>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("new_entry_name"), in_new_entry_name,
                        "<value of type const WTF::String&>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kFileSystemAccessDirectoryHandle_Move_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::FileSystemAccessDirectoryHandle_Move_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::Serialize<mojo::InterfacePtrDataView<::blink::mojom::FileSystemAccessTransferTokenInterfaceBase>>(
      in_destination_directory, &params->destination_directory, &params.message());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      !mojo::internal::IsHandleOrInterfaceValid(params->destination_directory),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_INVALID_HANDLE,
      "invalid destination_directory in FileSystemAccessDirectoryHandle.Move request");
  mojo::internal::MessageFragment<
      typename decltype(params->new_entry_name)::BaseType> new_entry_name_fragment(
          params.message());
  mojo::internal::Serialize<mojo::StringDataView>(
      in_new_entry_name, new_entry_name_fragment);
  params->new_entry_name.Set(
      new_entry_name_fragment.is_null() ? nullptr : new_entry_name_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->new_entry_name.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null new_entry_name in FileSystemAccessDirectoryHandle.Move request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(FileSystemAccessDirectoryHandle::Name_);
  message.set_method_name("Move");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new FileSystemAccessDirectoryHandle_Move_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void FileSystemAccessDirectoryHandleProxy::Remove(
    bool in_recurse, RemoveCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::FileSystemAccessDirectoryHandle::Remove", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("recurse"), in_recurse,
                        "<value of type bool>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kFileSystemAccessDirectoryHandle_Remove_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::FileSystemAccessDirectoryHandle_Remove_Params_Data> params(
          message);
  params.Allocate();
  params->recurse = in_recurse;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(FileSystemAccessDirectoryHandle::Name_);
  message.set_method_name("Remove");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new FileSystemAccessDirectoryHandle_Remove_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void FileSystemAccessDirectoryHandleProxy::RemoveEntry(
    const WTF::String& in_basename, bool in_recurse, RemoveEntryCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::FileSystemAccessDirectoryHandle::RemoveEntry", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("basename"), in_basename,
                        "<value of type const WTF::String&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("recurse"), in_recurse,
                        "<value of type bool>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kFileSystemAccessDirectoryHandle_RemoveEntry_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::FileSystemAccessDirectoryHandle_RemoveEntry_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->basename)::BaseType> basename_fragment(
          params.message());
  mojo::internal::Serialize<mojo::StringDataView>(
      in_basename, basename_fragment);
  params->basename.Set(
      basename_fragment.is_null() ? nullptr : basename_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->basename.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null basename in FileSystemAccessDirectoryHandle.RemoveEntry request");
  params->recurse = in_recurse;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(FileSystemAccessDirectoryHandle::Name_);
  message.set_method_name("RemoveEntry");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new FileSystemAccessDirectoryHandle_RemoveEntry_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void FileSystemAccessDirectoryHandleProxy::Resolve(
    ::mojo::PendingRemote<::blink::mojom::blink::FileSystemAccessTransferToken> in_possible_child, ResolveCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::FileSystemAccessDirectoryHandle::Resolve", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("possible_child"), in_possible_child,
                        "<value of type ::mojo::PendingRemote<::blink::mojom::blink::FileSystemAccessTransferToken>>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kFileSystemAccessDirectoryHandle_Resolve_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::FileSystemAccessDirectoryHandle_Resolve_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::Serialize<mojo::InterfacePtrDataView<::blink::mojom::FileSystemAccessTransferTokenInterfaceBase>>(
      in_possible_child, &params->possible_child, &params.message());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      !mojo::internal::IsHandleOrInterfaceValid(params->possible_child),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_INVALID_HANDLE,
      "invalid possible_child in FileSystemAccessDirectoryHandle.Resolve request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(FileSystemAccessDirectoryHandle::Name_);
  message.set_method_name("Resolve");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new FileSystemAccessDirectoryHandle_Resolve_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void FileSystemAccessDirectoryHandleProxy::Transfer(
    ::mojo::PendingReceiver<::blink::mojom::blink::FileSystemAccessTransferToken> in_token) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::FileSystemAccessDirectoryHandle::Transfer", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("token"), in_token,
                        "<value of type ::mojo::PendingReceiver<::blink::mojom::blink::FileSystemAccessTransferToken>>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kFileSystemAccessDirectoryHandle_Transfer_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::FileSystemAccessDirectoryHandle_Transfer_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::Serialize<mojo::InterfaceRequestDataView<::blink::mojom::FileSystemAccessTransferTokenInterfaceBase>>(
      in_token, &params->token, &params.message());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      !mojo::internal::IsHandleOrInterfaceValid(params->token),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_INVALID_HANDLE,
      "invalid token in FileSystemAccessDirectoryHandle.Transfer request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(FileSystemAccessDirectoryHandle::Name_);
  message.set_method_name("Transfer");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}
class FileSystemAccessDirectoryHandle_GetPermissionStatus_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static FileSystemAccessDirectoryHandle::GetPermissionStatusCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<FileSystemAccessDirectoryHandle_GetPermissionStatus_ProxyToResponder> proxy(
        new FileSystemAccessDirectoryHandle_GetPermissionStatus_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&FileSystemAccessDirectoryHandle_GetPermissionStatus_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~FileSystemAccessDirectoryHandle_GetPermissionStatus_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  FileSystemAccessDirectoryHandle_GetPermissionStatus_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "FileSystemAccessDirectoryHandle::GetPermissionStatusCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      ::blink::mojom::blink::PermissionStatus in_status);
};

bool FileSystemAccessDirectoryHandle_GetPermissionStatus_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::FileSystemAccessDirectoryHandle_GetPermissionStatus_ResponseParams_Data* params =
      reinterpret_cast<
          internal::FileSystemAccessDirectoryHandle_GetPermissionStatus_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  ::blink::mojom::blink::PermissionStatus p_status{};
  FileSystemAccessDirectoryHandle_GetPermissionStatus_ResponseParamsDataView input_data_view(params, message);
  
  if (success && !input_data_view.ReadStatus(&p_status))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        FileSystemAccessDirectoryHandle::Name_, 0, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_status));
  return true;
}

void FileSystemAccessDirectoryHandle_GetPermissionStatus_ProxyToResponder::Run(
    ::blink::mojom::blink::PermissionStatus in_status) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send reply blink::mojom::FileSystemAccessDirectoryHandle::GetPermissionStatus", "async_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("status"), in_status,
                        "<value of type ::blink::mojom::blink::PermissionStatus>");
   });
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kFileSystemAccessDirectoryHandle_GetPermissionStatus_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::FileSystemAccessDirectoryHandle_GetPermissionStatus_ResponseParams_Data> params(
          message);
  params.Allocate();
  mojo::internal::Serialize<::blink::mojom::PermissionStatus>(
      in_status, &params->status);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(FileSystemAccessDirectoryHandle::Name_);
  message.set_method_name("GetPermissionStatus");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class FileSystemAccessDirectoryHandle_RequestPermission_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static FileSystemAccessDirectoryHandle::RequestPermissionCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<FileSystemAccessDirectoryHandle_RequestPermission_ProxyToResponder> proxy(
        new FileSystemAccessDirectoryHandle_RequestPermission_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&FileSystemAccessDirectoryHandle_RequestPermission_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~FileSystemAccessDirectoryHandle_RequestPermission_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  FileSystemAccessDirectoryHandle_RequestPermission_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "FileSystemAccessDirectoryHandle::RequestPermissionCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      ::blink::mojom::blink::FileSystemAccessErrorPtr in_result, ::blink::mojom::blink::PermissionStatus in_status);
};

bool FileSystemAccessDirectoryHandle_RequestPermission_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::FileSystemAccessDirectoryHandle_RequestPermission_ResponseParams_Data* params =
      reinterpret_cast<
          internal::FileSystemAccessDirectoryHandle_RequestPermission_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  ::blink::mojom::blink::FileSystemAccessErrorPtr p_result{};
  ::blink::mojom::blink::PermissionStatus p_status{};
  FileSystemAccessDirectoryHandle_RequestPermission_ResponseParamsDataView input_data_view(params, message);
  
  if (success && !input_data_view.ReadResult(&p_result))
    success = false;
  if (success && !input_data_view.ReadStatus(&p_status))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        FileSystemAccessDirectoryHandle::Name_, 1, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_result), 
std::move(p_status));
  return true;
}

void FileSystemAccessDirectoryHandle_RequestPermission_ProxyToResponder::Run(
    ::blink::mojom::blink::FileSystemAccessErrorPtr in_result, ::blink::mojom::blink::PermissionStatus in_status) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send reply blink::mojom::FileSystemAccessDirectoryHandle::RequestPermission", "async_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("result"), in_result,
                        "<value of type ::blink::mojom::blink::FileSystemAccessErrorPtr>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("status"), in_status,
                        "<value of type ::blink::mojom::blink::PermissionStatus>");
   });
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kFileSystemAccessDirectoryHandle_RequestPermission_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::FileSystemAccessDirectoryHandle_RequestPermission_ResponseParams_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->result)::BaseType> result_fragment(
          params.message());
  mojo::internal::Serialize<::blink::mojom::FileSystemAccessErrorDataView>(
      in_result, result_fragment);
  params->result.Set(
      result_fragment.is_null() ? nullptr : result_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->result.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null result in ");
  mojo::internal::Serialize<::blink::mojom::PermissionStatus>(
      in_status, &params->status);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(FileSystemAccessDirectoryHandle::Name_);
  message.set_method_name("RequestPermission");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class FileSystemAccessDirectoryHandle_GetFile_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static FileSystemAccessDirectoryHandle::GetFileCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<FileSystemAccessDirectoryHandle_GetFile_ProxyToResponder> proxy(
        new FileSystemAccessDirectoryHandle_GetFile_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&FileSystemAccessDirectoryHandle_GetFile_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~FileSystemAccessDirectoryHandle_GetFile_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  FileSystemAccessDirectoryHandle_GetFile_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "FileSystemAccessDirectoryHandle::GetFileCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      ::blink::mojom::blink::FileSystemAccessErrorPtr in_result, ::mojo::PendingRemote<::blink::mojom::blink::FileSystemAccessFileHandle> in_file);
};

bool FileSystemAccessDirectoryHandle_GetFile_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::FileSystemAccessDirectoryHandle_GetFile_ResponseParams_Data* params =
      reinterpret_cast<
          internal::FileSystemAccessDirectoryHandle_GetFile_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  ::blink::mojom::blink::FileSystemAccessErrorPtr p_result{};
  ::mojo::PendingRemote<::blink::mojom::blink::FileSystemAccessFileHandle> p_file{};
  FileSystemAccessDirectoryHandle_GetFile_ResponseParamsDataView input_data_view(params, message);
  
  if (success && !input_data_view.ReadResult(&p_result))
    success = false;
  if (success) {
    p_file =
        input_data_view.TakeFile<decltype(p_file)>();
  }
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        FileSystemAccessDirectoryHandle::Name_, 2, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_result), 
std::move(p_file));
  return true;
}

void FileSystemAccessDirectoryHandle_GetFile_ProxyToResponder::Run(
    ::blink::mojom::blink::FileSystemAccessErrorPtr in_result, ::mojo::PendingRemote<::blink::mojom::blink::FileSystemAccessFileHandle> in_file) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send reply blink::mojom::FileSystemAccessDirectoryHandle::GetFile", "async_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("result"), in_result,
                        "<value of type ::blink::mojom::blink::FileSystemAccessErrorPtr>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("file"), in_file,
                        "<value of type ::mojo::PendingRemote<::blink::mojom::blink::FileSystemAccessFileHandle>>");
   });
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kFileSystemAccessDirectoryHandle_GetFile_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::FileSystemAccessDirectoryHandle_GetFile_ResponseParams_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->result)::BaseType> result_fragment(
          params.message());
  mojo::internal::Serialize<::blink::mojom::FileSystemAccessErrorDataView>(
      in_result, result_fragment);
  params->result.Set(
      result_fragment.is_null() ? nullptr : result_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->result.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null result in ");
  mojo::internal::Serialize<mojo::InterfacePtrDataView<::blink::mojom::FileSystemAccessFileHandleInterfaceBase>>(
      in_file, &params->file, &params.message());

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(FileSystemAccessDirectoryHandle::Name_);
  message.set_method_name("GetFile");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class FileSystemAccessDirectoryHandle_GetDirectory_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static FileSystemAccessDirectoryHandle::GetDirectoryCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<FileSystemAccessDirectoryHandle_GetDirectory_ProxyToResponder> proxy(
        new FileSystemAccessDirectoryHandle_GetDirectory_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&FileSystemAccessDirectoryHandle_GetDirectory_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~FileSystemAccessDirectoryHandle_GetDirectory_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  FileSystemAccessDirectoryHandle_GetDirectory_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "FileSystemAccessDirectoryHandle::GetDirectoryCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      ::blink::mojom::blink::FileSystemAccessErrorPtr in_result, ::mojo::PendingRemote<FileSystemAccessDirectoryHandle> in_directory);
};

bool FileSystemAccessDirectoryHandle_GetDirectory_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::FileSystemAccessDirectoryHandle_GetDirectory_ResponseParams_Data* params =
      reinterpret_cast<
          internal::FileSystemAccessDirectoryHandle_GetDirectory_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  ::blink::mojom::blink::FileSystemAccessErrorPtr p_result{};
  ::mojo::PendingRemote<FileSystemAccessDirectoryHandle> p_directory{};
  FileSystemAccessDirectoryHandle_GetDirectory_ResponseParamsDataView input_data_view(params, message);
  
  if (success && !input_data_view.ReadResult(&p_result))
    success = false;
  if (success) {
    p_directory =
        input_data_view.TakeDirectory<decltype(p_directory)>();
  }
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        FileSystemAccessDirectoryHandle::Name_, 3, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_result), 
std::move(p_directory));
  return true;
}

void FileSystemAccessDirectoryHandle_GetDirectory_ProxyToResponder::Run(
    ::blink::mojom::blink::FileSystemAccessErrorPtr in_result, ::mojo::PendingRemote<FileSystemAccessDirectoryHandle> in_directory) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send reply blink::mojom::FileSystemAccessDirectoryHandle::GetDirectory", "async_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("result"), in_result,
                        "<value of type ::blink::mojom::blink::FileSystemAccessErrorPtr>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("directory"), in_directory,
                        "<value of type ::mojo::PendingRemote<FileSystemAccessDirectoryHandle>>");
   });
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kFileSystemAccessDirectoryHandle_GetDirectory_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::FileSystemAccessDirectoryHandle_GetDirectory_ResponseParams_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->result)::BaseType> result_fragment(
          params.message());
  mojo::internal::Serialize<::blink::mojom::FileSystemAccessErrorDataView>(
      in_result, result_fragment);
  params->result.Set(
      result_fragment.is_null() ? nullptr : result_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->result.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null result in ");
  mojo::internal::Serialize<mojo::InterfacePtrDataView<::blink::mojom::FileSystemAccessDirectoryHandleInterfaceBase>>(
      in_directory, &params->directory, &params.message());

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(FileSystemAccessDirectoryHandle::Name_);
  message.set_method_name("GetDirectory");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class FileSystemAccessDirectoryHandle_Rename_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static FileSystemAccessDirectoryHandle::RenameCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<FileSystemAccessDirectoryHandle_Rename_ProxyToResponder> proxy(
        new FileSystemAccessDirectoryHandle_Rename_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&FileSystemAccessDirectoryHandle_Rename_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~FileSystemAccessDirectoryHandle_Rename_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  FileSystemAccessDirectoryHandle_Rename_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "FileSystemAccessDirectoryHandle::RenameCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      ::blink::mojom::blink::FileSystemAccessErrorPtr in_result);
};

bool FileSystemAccessDirectoryHandle_Rename_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::FileSystemAccessDirectoryHandle_Rename_ResponseParams_Data* params =
      reinterpret_cast<
          internal::FileSystemAccessDirectoryHandle_Rename_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  ::blink::mojom::blink::FileSystemAccessErrorPtr p_result{};
  FileSystemAccessDirectoryHandle_Rename_ResponseParamsDataView input_data_view(params, message);
  
  if (success && !input_data_view.ReadResult(&p_result))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        FileSystemAccessDirectoryHandle::Name_, 5, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_result));
  return true;
}

void FileSystemAccessDirectoryHandle_Rename_ProxyToResponder::Run(
    ::blink::mojom::blink::FileSystemAccessErrorPtr in_result) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send reply blink::mojom::FileSystemAccessDirectoryHandle::Rename", "async_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("result"), in_result,
                        "<value of type ::blink::mojom::blink::FileSystemAccessErrorPtr>");
   });
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kFileSystemAccessDirectoryHandle_Rename_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::FileSystemAccessDirectoryHandle_Rename_ResponseParams_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->result)::BaseType> result_fragment(
          params.message());
  mojo::internal::Serialize<::blink::mojom::FileSystemAccessErrorDataView>(
      in_result, result_fragment);
  params->result.Set(
      result_fragment.is_null() ? nullptr : result_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->result.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null result in ");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(FileSystemAccessDirectoryHandle::Name_);
  message.set_method_name("Rename");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class FileSystemAccessDirectoryHandle_Move_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static FileSystemAccessDirectoryHandle::MoveCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<FileSystemAccessDirectoryHandle_Move_ProxyToResponder> proxy(
        new FileSystemAccessDirectoryHandle_Move_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&FileSystemAccessDirectoryHandle_Move_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~FileSystemAccessDirectoryHandle_Move_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  FileSystemAccessDirectoryHandle_Move_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "FileSystemAccessDirectoryHandle::MoveCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      ::blink::mojom::blink::FileSystemAccessErrorPtr in_result);
};

bool FileSystemAccessDirectoryHandle_Move_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::FileSystemAccessDirectoryHandle_Move_ResponseParams_Data* params =
      reinterpret_cast<
          internal::FileSystemAccessDirectoryHandle_Move_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  ::blink::mojom::blink::FileSystemAccessErrorPtr p_result{};
  FileSystemAccessDirectoryHandle_Move_ResponseParamsDataView input_data_view(params, message);
  
  if (success && !input_data_view.ReadResult(&p_result))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        FileSystemAccessDirectoryHandle::Name_, 6, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_result));
  return true;
}

void FileSystemAccessDirectoryHandle_Move_ProxyToResponder::Run(
    ::blink::mojom::blink::FileSystemAccessErrorPtr in_result) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send reply blink::mojom::FileSystemAccessDirectoryHandle::Move", "async_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("result"), in_result,
                        "<value of type ::blink::mojom::blink::FileSystemAccessErrorPtr>");
   });
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kFileSystemAccessDirectoryHandle_Move_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::FileSystemAccessDirectoryHandle_Move_ResponseParams_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->result)::BaseType> result_fragment(
          params.message());
  mojo::internal::Serialize<::blink::mojom::FileSystemAccessErrorDataView>(
      in_result, result_fragment);
  params->result.Set(
      result_fragment.is_null() ? nullptr : result_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->result.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null result in ");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(FileSystemAccessDirectoryHandle::Name_);
  message.set_method_name("Move");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class FileSystemAccessDirectoryHandle_Remove_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static FileSystemAccessDirectoryHandle::RemoveCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<FileSystemAccessDirectoryHandle_Remove_ProxyToResponder> proxy(
        new FileSystemAccessDirectoryHandle_Remove_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&FileSystemAccessDirectoryHandle_Remove_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~FileSystemAccessDirectoryHandle_Remove_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  FileSystemAccessDirectoryHandle_Remove_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "FileSystemAccessDirectoryHandle::RemoveCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      ::blink::mojom::blink::FileSystemAccessErrorPtr in_result);
};

bool FileSystemAccessDirectoryHandle_Remove_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::FileSystemAccessDirectoryHandle_Remove_ResponseParams_Data* params =
      reinterpret_cast<
          internal::FileSystemAccessDirectoryHandle_Remove_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  ::blink::mojom::blink::FileSystemAccessErrorPtr p_result{};
  FileSystemAccessDirectoryHandle_Remove_ResponseParamsDataView input_data_view(params, message);
  
  if (success && !input_data_view.ReadResult(&p_result))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        FileSystemAccessDirectoryHandle::Name_, 7, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_result));
  return true;
}

void FileSystemAccessDirectoryHandle_Remove_ProxyToResponder::Run(
    ::blink::mojom::blink::FileSystemAccessErrorPtr in_result) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send reply blink::mojom::FileSystemAccessDirectoryHandle::Remove", "async_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("result"), in_result,
                        "<value of type ::blink::mojom::blink::FileSystemAccessErrorPtr>");
   });
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kFileSystemAccessDirectoryHandle_Remove_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::FileSystemAccessDirectoryHandle_Remove_ResponseParams_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->result)::BaseType> result_fragment(
          params.message());
  mojo::internal::Serialize<::blink::mojom::FileSystemAccessErrorDataView>(
      in_result, result_fragment);
  params->result.Set(
      result_fragment.is_null() ? nullptr : result_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->result.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null result in ");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(FileSystemAccessDirectoryHandle::Name_);
  message.set_method_name("Remove");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class FileSystemAccessDirectoryHandle_RemoveEntry_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static FileSystemAccessDirectoryHandle::RemoveEntryCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<FileSystemAccessDirectoryHandle_RemoveEntry_ProxyToResponder> proxy(
        new FileSystemAccessDirectoryHandle_RemoveEntry_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&FileSystemAccessDirectoryHandle_RemoveEntry_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~FileSystemAccessDirectoryHandle_RemoveEntry_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  FileSystemAccessDirectoryHandle_RemoveEntry_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "FileSystemAccessDirectoryHandle::RemoveEntryCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      ::blink::mojom::blink::FileSystemAccessErrorPtr in_result);
};

bool FileSystemAccessDirectoryHandle_RemoveEntry_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::FileSystemAccessDirectoryHandle_RemoveEntry_ResponseParams_Data* params =
      reinterpret_cast<
          internal::FileSystemAccessDirectoryHandle_RemoveEntry_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  ::blink::mojom::blink::FileSystemAccessErrorPtr p_result{};
  FileSystemAccessDirectoryHandle_RemoveEntry_ResponseParamsDataView input_data_view(params, message);
  
  if (success && !input_data_view.ReadResult(&p_result))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        FileSystemAccessDirectoryHandle::Name_, 8, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_result));
  return true;
}

void FileSystemAccessDirectoryHandle_RemoveEntry_ProxyToResponder::Run(
    ::blink::mojom::blink::FileSystemAccessErrorPtr in_result) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send reply blink::mojom::FileSystemAccessDirectoryHandle::RemoveEntry", "async_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("result"), in_result,
                        "<value of type ::blink::mojom::blink::FileSystemAccessErrorPtr>");
   });
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kFileSystemAccessDirectoryHandle_RemoveEntry_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::FileSystemAccessDirectoryHandle_RemoveEntry_ResponseParams_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->result)::BaseType> result_fragment(
          params.message());
  mojo::internal::Serialize<::blink::mojom::FileSystemAccessErrorDataView>(
      in_result, result_fragment);
  params->result.Set(
      result_fragment.is_null() ? nullptr : result_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->result.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null result in ");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(FileSystemAccessDirectoryHandle::Name_);
  message.set_method_name("RemoveEntry");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class FileSystemAccessDirectoryHandle_Resolve_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static FileSystemAccessDirectoryHandle::ResolveCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<FileSystemAccessDirectoryHandle_Resolve_ProxyToResponder> proxy(
        new FileSystemAccessDirectoryHandle_Resolve_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&FileSystemAccessDirectoryHandle_Resolve_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~FileSystemAccessDirectoryHandle_Resolve_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  FileSystemAccessDirectoryHandle_Resolve_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "FileSystemAccessDirectoryHandle::ResolveCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      ::blink::mojom::blink::FileSystemAccessErrorPtr in_result, const absl::optional<WTF::Vector<WTF::String>>& in_path);
};

bool FileSystemAccessDirectoryHandle_Resolve_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::FileSystemAccessDirectoryHandle_Resolve_ResponseParams_Data* params =
      reinterpret_cast<
          internal::FileSystemAccessDirectoryHandle_Resolve_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  ::blink::mojom::blink::FileSystemAccessErrorPtr p_result{};
  absl::optional<WTF::Vector<WTF::String>> p_path{};
  FileSystemAccessDirectoryHandle_Resolve_ResponseParamsDataView input_data_view(params, message);
  
  if (success && !input_data_view.ReadResult(&p_result))
    success = false;
  if (success && !input_data_view.ReadPath(&p_path))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        FileSystemAccessDirectoryHandle::Name_, 9, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_result), 
std::move(p_path));
  return true;
}

void FileSystemAccessDirectoryHandle_Resolve_ProxyToResponder::Run(
    ::blink::mojom::blink::FileSystemAccessErrorPtr in_result, const absl::optional<WTF::Vector<WTF::String>>& in_path) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send reply blink::mojom::FileSystemAccessDirectoryHandle::Resolve", "async_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("result"), in_result,
                        "<value of type ::blink::mojom::blink::FileSystemAccessErrorPtr>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("path"), in_path,
                        "<value of type const absl::optional<WTF::Vector<WTF::String>>&>");
   });
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kFileSystemAccessDirectoryHandle_Resolve_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::FileSystemAccessDirectoryHandle_Resolve_ResponseParams_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->result)::BaseType> result_fragment(
          params.message());
  mojo::internal::Serialize<::blink::mojom::FileSystemAccessErrorDataView>(
      in_result, result_fragment);
  params->result.Set(
      result_fragment.is_null() ? nullptr : result_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->result.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null result in ");
  mojo::internal::MessageFragment<
      typename decltype(params->path)::BaseType>
      path_fragment(params.message());
  const mojo::internal::ContainerValidateParams path_validate_params(
      0, false, new mojo::internal::ContainerValidateParams(0, false, nullptr));
  mojo::internal::Serialize<mojo::ArrayDataView<mojo::StringDataView>>(
      in_path, path_fragment, &path_validate_params);
  params->path.Set(
      path_fragment.is_null() ? nullptr : path_fragment.data());

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(FileSystemAccessDirectoryHandle::Name_);
  message.set_method_name("Resolve");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}

// static
bool FileSystemAccessDirectoryHandleStubDispatch::Accept(
    FileSystemAccessDirectoryHandle* impl,
    mojo::Message* message) {
  switch (message->header()->name) {
    case internal::kFileSystemAccessDirectoryHandle_GetPermissionStatus_Name: {
      break;
    }
    case internal::kFileSystemAccessDirectoryHandle_RequestPermission_Name: {
      break;
    }
    case internal::kFileSystemAccessDirectoryHandle_GetFile_Name: {
      break;
    }
    case internal::kFileSystemAccessDirectoryHandle_GetDirectory_Name: {
      break;
    }
    case internal::kFileSystemAccessDirectoryHandle_GetEntries_Name: {

      DCHECK(message->is_serialized());
      internal::FileSystemAccessDirectoryHandle_GetEntries_Params_Data* params =
          reinterpret_cast<internal::FileSystemAccessDirectoryHandle_GetEntries_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::mojo::PendingRemote<FileSystemAccessDirectoryEntriesListener> p_listener{};
      FileSystemAccessDirectoryHandle_GetEntries_ParamsDataView input_data_view(params, message);
      
      if (success) {
        p_listener =
            input_data_view.TakeListener<decltype(p_listener)>();
      }
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            FileSystemAccessDirectoryHandle::Name_, 4, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->GetEntries(
std::move(p_listener));
      return true;
    }
    case internal::kFileSystemAccessDirectoryHandle_Rename_Name: {
      break;
    }
    case internal::kFileSystemAccessDirectoryHandle_Move_Name: {
      break;
    }
    case internal::kFileSystemAccessDirectoryHandle_Remove_Name: {
      break;
    }
    case internal::kFileSystemAccessDirectoryHandle_RemoveEntry_Name: {
      break;
    }
    case internal::kFileSystemAccessDirectoryHandle_Resolve_Name: {
      break;
    }
    case internal::kFileSystemAccessDirectoryHandle_Transfer_Name: {

      DCHECK(message->is_serialized());
      internal::FileSystemAccessDirectoryHandle_Transfer_Params_Data* params =
          reinterpret_cast<internal::FileSystemAccessDirectoryHandle_Transfer_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::mojo::PendingReceiver<::blink::mojom::blink::FileSystemAccessTransferToken> p_token{};
      FileSystemAccessDirectoryHandle_Transfer_ParamsDataView input_data_view(params, message);
      
      if (success) {
        p_token =
            input_data_view.TakeToken<decltype(p_token)>();
      }
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            FileSystemAccessDirectoryHandle::Name_, 10, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->Transfer(
std::move(p_token));
      return true;
    }
  }
  return false;
}

// static
bool FileSystemAccessDirectoryHandleStubDispatch::AcceptWithResponder(
    FileSystemAccessDirectoryHandle* impl,
    mojo::Message* message,
    std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
  [[maybe_unused]] const bool message_is_sync =
      message->has_flag(mojo::Message::kFlagIsSync);
  [[maybe_unused]] const uint64_t request_id = message->request_id();
  switch (message->header()->name) {
    case internal::kFileSystemAccessDirectoryHandle_GetPermissionStatus_Name: {

      internal::FileSystemAccessDirectoryHandle_GetPermissionStatus_Params_Data* params =
          reinterpret_cast<
              internal::FileSystemAccessDirectoryHandle_GetPermissionStatus_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      bool p_writable{};
      FileSystemAccessDirectoryHandle_GetPermissionStatus_ParamsDataView input_data_view(params, message);
      
      if (success)
        p_writable = input_data_view.writable();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            FileSystemAccessDirectoryHandle::Name_, 0, false);
        return false;
      }
      FileSystemAccessDirectoryHandle::GetPermissionStatusCallback callback =
          FileSystemAccessDirectoryHandle_GetPermissionStatus_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->GetPermissionStatus(
std::move(p_writable), std::move(callback));
      return true;
    }
    case internal::kFileSystemAccessDirectoryHandle_RequestPermission_Name: {

      internal::FileSystemAccessDirectoryHandle_RequestPermission_Params_Data* params =
          reinterpret_cast<
              internal::FileSystemAccessDirectoryHandle_RequestPermission_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      bool p_writable{};
      FileSystemAccessDirectoryHandle_RequestPermission_ParamsDataView input_data_view(params, message);
      
      if (success)
        p_writable = input_data_view.writable();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            FileSystemAccessDirectoryHandle::Name_, 1, false);
        return false;
      }
      FileSystemAccessDirectoryHandle::RequestPermissionCallback callback =
          FileSystemAccessDirectoryHandle_RequestPermission_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->RequestPermission(
std::move(p_writable), std::move(callback));
      return true;
    }
    case internal::kFileSystemAccessDirectoryHandle_GetFile_Name: {

      internal::FileSystemAccessDirectoryHandle_GetFile_Params_Data* params =
          reinterpret_cast<
              internal::FileSystemAccessDirectoryHandle_GetFile_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      WTF::String p_basename{};
      bool p_create{};
      FileSystemAccessDirectoryHandle_GetFile_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadBasename(&p_basename))
        success = false;
      if (success)
        p_create = input_data_view.create();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            FileSystemAccessDirectoryHandle::Name_, 2, false);
        return false;
      }
      FileSystemAccessDirectoryHandle::GetFileCallback callback =
          FileSystemAccessDirectoryHandle_GetFile_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->GetFile(
std::move(p_basename), 
std::move(p_create), std::move(callback));
      return true;
    }
    case internal::kFileSystemAccessDirectoryHandle_GetDirectory_Name: {

      internal::FileSystemAccessDirectoryHandle_GetDirectory_Params_Data* params =
          reinterpret_cast<
              internal::FileSystemAccessDirectoryHandle_GetDirectory_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      WTF::String p_basename{};
      bool p_create{};
      FileSystemAccessDirectoryHandle_GetDirectory_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadBasename(&p_basename))
        success = false;
      if (success)
        p_create = input_data_view.create();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            FileSystemAccessDirectoryHandle::Name_, 3, false);
        return false;
      }
      FileSystemAccessDirectoryHandle::GetDirectoryCallback callback =
          FileSystemAccessDirectoryHandle_GetDirectory_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->GetDirectory(
std::move(p_basename), 
std::move(p_create), std::move(callback));
      return true;
    }
    case internal::kFileSystemAccessDirectoryHandle_GetEntries_Name: {
      break;
    }
    case internal::kFileSystemAccessDirectoryHandle_Rename_Name: {

      internal::FileSystemAccessDirectoryHandle_Rename_Params_Data* params =
          reinterpret_cast<
              internal::FileSystemAccessDirectoryHandle_Rename_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      WTF::String p_new_entry_name{};
      FileSystemAccessDirectoryHandle_Rename_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadNewEntryName(&p_new_entry_name))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            FileSystemAccessDirectoryHandle::Name_, 5, false);
        return false;
      }
      FileSystemAccessDirectoryHandle::RenameCallback callback =
          FileSystemAccessDirectoryHandle_Rename_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->Rename(
std::move(p_new_entry_name), std::move(callback));
      return true;
    }
    case internal::kFileSystemAccessDirectoryHandle_Move_Name: {

      internal::FileSystemAccessDirectoryHandle_Move_Params_Data* params =
          reinterpret_cast<
              internal::FileSystemAccessDirectoryHandle_Move_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      ::mojo::PendingRemote<::blink::mojom::blink::FileSystemAccessTransferToken> p_destination_directory{};
      WTF::String p_new_entry_name{};
      FileSystemAccessDirectoryHandle_Move_ParamsDataView input_data_view(params, message);
      
      if (success) {
        p_destination_directory =
            input_data_view.TakeDestinationDirectory<decltype(p_destination_directory)>();
      }
      if (success && !input_data_view.ReadNewEntryName(&p_new_entry_name))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            FileSystemAccessDirectoryHandle::Name_, 6, false);
        return false;
      }
      FileSystemAccessDirectoryHandle::MoveCallback callback =
          FileSystemAccessDirectoryHandle_Move_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->Move(
std::move(p_destination_directory), 
std::move(p_new_entry_name), std::move(callback));
      return true;
    }
    case internal::kFileSystemAccessDirectoryHandle_Remove_Name: {

      internal::FileSystemAccessDirectoryHandle_Remove_Params_Data* params =
          reinterpret_cast<
              internal::FileSystemAccessDirectoryHandle_Remove_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      bool p_recurse{};
      FileSystemAccessDirectoryHandle_Remove_ParamsDataView input_data_view(params, message);
      
      if (success)
        p_recurse = input_data_view.recurse();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            FileSystemAccessDirectoryHandle::Name_, 7, false);
        return false;
      }
      FileSystemAccessDirectoryHandle::RemoveCallback callback =
          FileSystemAccessDirectoryHandle_Remove_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->Remove(
std::move(p_recurse), std::move(callback));
      return true;
    }
    case internal::kFileSystemAccessDirectoryHandle_RemoveEntry_Name: {

      internal::FileSystemAccessDirectoryHandle_RemoveEntry_Params_Data* params =
          reinterpret_cast<
              internal::FileSystemAccessDirectoryHandle_RemoveEntry_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      WTF::String p_basename{};
      bool p_recurse{};
      FileSystemAccessDirectoryHandle_RemoveEntry_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadBasename(&p_basename))
        success = false;
      if (success)
        p_recurse = input_data_view.recurse();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            FileSystemAccessDirectoryHandle::Name_, 8, false);
        return false;
      }
      FileSystemAccessDirectoryHandle::RemoveEntryCallback callback =
          FileSystemAccessDirectoryHandle_RemoveEntry_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->RemoveEntry(
std::move(p_basename), 
std::move(p_recurse), std::move(callback));
      return true;
    }
    case internal::kFileSystemAccessDirectoryHandle_Resolve_Name: {

      internal::FileSystemAccessDirectoryHandle_Resolve_Params_Data* params =
          reinterpret_cast<
              internal::FileSystemAccessDirectoryHandle_Resolve_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      ::mojo::PendingRemote<::blink::mojom::blink::FileSystemAccessTransferToken> p_possible_child{};
      FileSystemAccessDirectoryHandle_Resolve_ParamsDataView input_data_view(params, message);
      
      if (success) {
        p_possible_child =
            input_data_view.TakePossibleChild<decltype(p_possible_child)>();
      }
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            FileSystemAccessDirectoryHandle::Name_, 9, false);
        return false;
      }
      FileSystemAccessDirectoryHandle::ResolveCallback callback =
          FileSystemAccessDirectoryHandle_Resolve_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->Resolve(
std::move(p_possible_child), std::move(callback));
      return true;
    }
    case internal::kFileSystemAccessDirectoryHandle_Transfer_Name: {
      break;
    }
  }
  return false;
}


static const mojo::internal::GenericValidationInfo kFileSystemAccessDirectoryHandleValidationInfo[] = {
    {&internal::FileSystemAccessDirectoryHandle_GetPermissionStatus_Params_Data::Validate,
     &internal::FileSystemAccessDirectoryHandle_GetPermissionStatus_ResponseParams_Data::Validate},
    {&internal::FileSystemAccessDirectoryHandle_RequestPermission_Params_Data::Validate,
     &internal::FileSystemAccessDirectoryHandle_RequestPermission_ResponseParams_Data::Validate},
    {&internal::FileSystemAccessDirectoryHandle_GetFile_Params_Data::Validate,
     &internal::FileSystemAccessDirectoryHandle_GetFile_ResponseParams_Data::Validate},
    {&internal::FileSystemAccessDirectoryHandle_GetDirectory_Params_Data::Validate,
     &internal::FileSystemAccessDirectoryHandle_GetDirectory_ResponseParams_Data::Validate},
    {&internal::FileSystemAccessDirectoryHandle_GetEntries_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::FileSystemAccessDirectoryHandle_Rename_Params_Data::Validate,
     &internal::FileSystemAccessDirectoryHandle_Rename_ResponseParams_Data::Validate},
    {&internal::FileSystemAccessDirectoryHandle_Move_Params_Data::Validate,
     &internal::FileSystemAccessDirectoryHandle_Move_ResponseParams_Data::Validate},
    {&internal::FileSystemAccessDirectoryHandle_Remove_Params_Data::Validate,
     &internal::FileSystemAccessDirectoryHandle_Remove_ResponseParams_Data::Validate},
    {&internal::FileSystemAccessDirectoryHandle_RemoveEntry_Params_Data::Validate,
     &internal::FileSystemAccessDirectoryHandle_RemoveEntry_ResponseParams_Data::Validate},
    {&internal::FileSystemAccessDirectoryHandle_Resolve_Params_Data::Validate,
     &internal::FileSystemAccessDirectoryHandle_Resolve_ResponseParams_Data::Validate},
    {&internal::FileSystemAccessDirectoryHandle_Transfer_Params_Data::Validate,
     nullptr /* no response */},
};

bool FileSystemAccessDirectoryHandleRequestValidator::Accept(mojo::Message* message) {
  const char* name = ::blink::mojom::blink::FileSystemAccessDirectoryHandle::Name_;
  return mojo::internal::ValidateRequestGenericPacked(message, name, kFileSystemAccessDirectoryHandleValidationInfo);
}

bool FileSystemAccessDirectoryHandleResponseValidator::Accept(mojo::Message* message) {
  const char* name = ::blink::mojom::blink::FileSystemAccessDirectoryHandle::Name_;
  return mojo::internal::ValidateResponseGenericPacked(message, name, kFileSystemAccessDirectoryHandleValidationInfo);
}


}  // namespace blink
}  // namespace mojom
}  // namespace blink


namespace mojo {


// static
bool StructTraits<::blink::mojom::blink::FileSystemAccessEntry::DataView, ::blink::mojom::blink::FileSystemAccessEntryPtr>::Read(
    ::blink::mojom::blink::FileSystemAccessEntry::DataView input,
    ::blink::mojom::blink::FileSystemAccessEntryPtr* output) {
  bool success = true;
  ::blink::mojom::blink::FileSystemAccessEntryPtr result(::blink::mojom::blink::FileSystemAccessEntry::New());
  
      if (success && !input.ReadEntryHandle(&result->entry_handle))
        success = false;
      if (success && !input.ReadName(&result->name))
        success = false;
  *output = std::move(result);
  return success;
}

// static
bool UnionTraits<::blink::mojom::blink::FileSystemAccessHandle::DataView, ::blink::mojom::blink::FileSystemAccessHandlePtr>::Read(
    ::blink::mojom::blink::FileSystemAccessHandle::DataView input,
    ::blink::mojom::blink::FileSystemAccessHandlePtr* output) {
  using UnionType = ::blink::mojom::blink::FileSystemAccessHandle;
  using Tag = UnionType::Tag;

  switch (input.tag()) {
    case Tag::kFile: {
      *output = UnionType::NewFile(
          input.TakeFile<::mojo::PendingRemote<::blink::mojom::blink::FileSystemAccessFileHandle>>());
      break;
    }
    case Tag::kDirectory: {
      *output = UnionType::NewDirectory(
          input.TakeDirectory<::mojo::PendingRemote<::blink::mojom::blink::FileSystemAccessDirectoryHandle>>());
      break;
    }
    default:

      return false;
  }
  return true;
}

}  // namespace mojo


// Symbols declared in the -test-utils.h header are defined here instead of a
// separate .cc file to save compile time.


namespace blink {
namespace mojom {
namespace blink {


void FileSystemAccessDirectoryEntriesListenerInterceptorForTesting::DidReadDirectory(::blink::mojom::blink::FileSystemAccessErrorPtr result, WTF::Vector<FileSystemAccessEntryPtr> entries, bool has_more_entries) {
  GetForwardingInterface()->DidReadDirectory(std::move(result), std::move(entries), std::move(has_more_entries));
}
FileSystemAccessDirectoryEntriesListenerAsyncWaiter::FileSystemAccessDirectoryEntriesListenerAsyncWaiter(
    FileSystemAccessDirectoryEntriesListener* proxy) : proxy_(proxy) {}

FileSystemAccessDirectoryEntriesListenerAsyncWaiter::~FileSystemAccessDirectoryEntriesListenerAsyncWaiter() = default;




void FileSystemAccessDirectoryHandleInterceptorForTesting::GetPermissionStatus(bool writable, GetPermissionStatusCallback callback) {
  GetForwardingInterface()->GetPermissionStatus(std::move(writable), std::move(callback));
}
void FileSystemAccessDirectoryHandleInterceptorForTesting::RequestPermission(bool writable, RequestPermissionCallback callback) {
  GetForwardingInterface()->RequestPermission(std::move(writable), std::move(callback));
}
void FileSystemAccessDirectoryHandleInterceptorForTesting::GetFile(const WTF::String& basename, bool create, GetFileCallback callback) {
  GetForwardingInterface()->GetFile(std::move(basename), std::move(create), std::move(callback));
}
void FileSystemAccessDirectoryHandleInterceptorForTesting::GetDirectory(const WTF::String& basename, bool create, GetDirectoryCallback callback) {
  GetForwardingInterface()->GetDirectory(std::move(basename), std::move(create), std::move(callback));
}
void FileSystemAccessDirectoryHandleInterceptorForTesting::GetEntries(::mojo::PendingRemote<FileSystemAccessDirectoryEntriesListener> listener) {
  GetForwardingInterface()->GetEntries(std::move(listener));
}
void FileSystemAccessDirectoryHandleInterceptorForTesting::Rename(const WTF::String& new_entry_name, RenameCallback callback) {
  GetForwardingInterface()->Rename(std::move(new_entry_name), std::move(callback));
}
void FileSystemAccessDirectoryHandleInterceptorForTesting::Move(::mojo::PendingRemote<::blink::mojom::blink::FileSystemAccessTransferToken> destination_directory, const WTF::String& new_entry_name, MoveCallback callback) {
  GetForwardingInterface()->Move(std::move(destination_directory), std::move(new_entry_name), std::move(callback));
}
void FileSystemAccessDirectoryHandleInterceptorForTesting::Remove(bool recurse, RemoveCallback callback) {
  GetForwardingInterface()->Remove(std::move(recurse), std::move(callback));
}
void FileSystemAccessDirectoryHandleInterceptorForTesting::RemoveEntry(const WTF::String& basename, bool recurse, RemoveEntryCallback callback) {
  GetForwardingInterface()->RemoveEntry(std::move(basename), std::move(recurse), std::move(callback));
}
void FileSystemAccessDirectoryHandleInterceptorForTesting::Resolve(::mojo::PendingRemote<::blink::mojom::blink::FileSystemAccessTransferToken> possible_child, ResolveCallback callback) {
  GetForwardingInterface()->Resolve(std::move(possible_child), std::move(callback));
}
void FileSystemAccessDirectoryHandleInterceptorForTesting::Transfer(::mojo::PendingReceiver<::blink::mojom::blink::FileSystemAccessTransferToken> token) {
  GetForwardingInterface()->Transfer(std::move(token));
}
FileSystemAccessDirectoryHandleAsyncWaiter::FileSystemAccessDirectoryHandleAsyncWaiter(
    FileSystemAccessDirectoryHandle* proxy) : proxy_(proxy) {}

FileSystemAccessDirectoryHandleAsyncWaiter::~FileSystemAccessDirectoryHandleAsyncWaiter() = default;

void FileSystemAccessDirectoryHandleAsyncWaiter::GetPermissionStatus(
    bool writable, ::blink::mojom::blink::PermissionStatus* out_status) {
  base::RunLoop loop;
  proxy_->GetPermissionStatus(std::move(writable),
      base::BindOnce(
          [](base::RunLoop* loop,
             ::blink::mojom::blink::PermissionStatus* out_status
,
             ::blink::mojom::blink::PermissionStatus status) {*out_status = std::move(status);
            loop->Quit();
          },
          &loop,
          out_status));
  loop.Run();
}
void FileSystemAccessDirectoryHandleAsyncWaiter::RequestPermission(
    bool writable, ::blink::mojom::blink::FileSystemAccessErrorPtr* out_result, ::blink::mojom::blink::PermissionStatus* out_status) {
  base::RunLoop loop;
  proxy_->RequestPermission(std::move(writable),
      base::BindOnce(
          [](base::RunLoop* loop,
             ::blink::mojom::blink::FileSystemAccessErrorPtr* out_result
,
             ::blink::mojom::blink::PermissionStatus* out_status
,
             ::blink::mojom::blink::FileSystemAccessErrorPtr result,
             ::blink::mojom::blink::PermissionStatus status) {*out_result = std::move(result);*out_status = std::move(status);
            loop->Quit();
          },
          &loop,
          out_result,
          out_status));
  loop.Run();
}
void FileSystemAccessDirectoryHandleAsyncWaiter::GetFile(
    const WTF::String& basename, bool create, ::blink::mojom::blink::FileSystemAccessErrorPtr* out_result, ::mojo::PendingRemote<::blink::mojom::blink::FileSystemAccessFileHandle>* out_file) {
  base::RunLoop loop;
  proxy_->GetFile(std::move(basename),std::move(create),
      base::BindOnce(
          [](base::RunLoop* loop,
             ::blink::mojom::blink::FileSystemAccessErrorPtr* out_result
,
             ::mojo::PendingRemote<::blink::mojom::blink::FileSystemAccessFileHandle>* out_file
,
             ::blink::mojom::blink::FileSystemAccessErrorPtr result,
             ::mojo::PendingRemote<::blink::mojom::blink::FileSystemAccessFileHandle> file) {*out_result = std::move(result);*out_file = std::move(file);
            loop->Quit();
          },
          &loop,
          out_result,
          out_file));
  loop.Run();
}
void FileSystemAccessDirectoryHandleAsyncWaiter::GetDirectory(
    const WTF::String& basename, bool create, ::blink::mojom::blink::FileSystemAccessErrorPtr* out_result, ::mojo::PendingRemote<FileSystemAccessDirectoryHandle>* out_directory) {
  base::RunLoop loop;
  proxy_->GetDirectory(std::move(basename),std::move(create),
      base::BindOnce(
          [](base::RunLoop* loop,
             ::blink::mojom::blink::FileSystemAccessErrorPtr* out_result
,
             ::mojo::PendingRemote<FileSystemAccessDirectoryHandle>* out_directory
,
             ::blink::mojom::blink::FileSystemAccessErrorPtr result,
             ::mojo::PendingRemote<FileSystemAccessDirectoryHandle> directory) {*out_result = std::move(result);*out_directory = std::move(directory);
            loop->Quit();
          },
          &loop,
          out_result,
          out_directory));
  loop.Run();
}
void FileSystemAccessDirectoryHandleAsyncWaiter::Rename(
    const WTF::String& new_entry_name, ::blink::mojom::blink::FileSystemAccessErrorPtr* out_result) {
  base::RunLoop loop;
  proxy_->Rename(std::move(new_entry_name),
      base::BindOnce(
          [](base::RunLoop* loop,
             ::blink::mojom::blink::FileSystemAccessErrorPtr* out_result
,
             ::blink::mojom::blink::FileSystemAccessErrorPtr result) {*out_result = std::move(result);
            loop->Quit();
          },
          &loop,
          out_result));
  loop.Run();
}
void FileSystemAccessDirectoryHandleAsyncWaiter::Move(
    ::mojo::PendingRemote<::blink::mojom::blink::FileSystemAccessTransferToken> destination_directory, const WTF::String& new_entry_name, ::blink::mojom::blink::FileSystemAccessErrorPtr* out_result) {
  base::RunLoop loop;
  proxy_->Move(std::move(destination_directory),std::move(new_entry_name),
      base::BindOnce(
          [](base::RunLoop* loop,
             ::blink::mojom::blink::FileSystemAccessErrorPtr* out_result
,
             ::blink::mojom::blink::FileSystemAccessErrorPtr result) {*out_result = std::move(result);
            loop->Quit();
          },
          &loop,
          out_result));
  loop.Run();
}
void FileSystemAccessDirectoryHandleAsyncWaiter::Remove(
    bool recurse, ::blink::mojom::blink::FileSystemAccessErrorPtr* out_result) {
  base::RunLoop loop;
  proxy_->Remove(std::move(recurse),
      base::BindOnce(
          [](base::RunLoop* loop,
             ::blink::mojom::blink::FileSystemAccessErrorPtr* out_result
,
             ::blink::mojom::blink::FileSystemAccessErrorPtr result) {*out_result = std::move(result);
            loop->Quit();
          },
          &loop,
          out_result));
  loop.Run();
}
void FileSystemAccessDirectoryHandleAsyncWaiter::RemoveEntry(
    const WTF::String& basename, bool recurse, ::blink::mojom::blink::FileSystemAccessErrorPtr* out_result) {
  base::RunLoop loop;
  proxy_->RemoveEntry(std::move(basename),std::move(recurse),
      base::BindOnce(
          [](base::RunLoop* loop,
             ::blink::mojom::blink::FileSystemAccessErrorPtr* out_result
,
             ::blink::mojom::blink::FileSystemAccessErrorPtr result) {*out_result = std::move(result);
            loop->Quit();
          },
          &loop,
          out_result));
  loop.Run();
}
void FileSystemAccessDirectoryHandleAsyncWaiter::Resolve(
    ::mojo::PendingRemote<::blink::mojom::blink::FileSystemAccessTransferToken> possible_child, ::blink::mojom::blink::FileSystemAccessErrorPtr* out_result, absl::optional<WTF::Vector<WTF::String>>* out_path) {
  base::RunLoop loop;
  proxy_->Resolve(std::move(possible_child),
      base::BindOnce(
          [](base::RunLoop* loop,
             ::blink::mojom::blink::FileSystemAccessErrorPtr* out_result
,
             absl::optional<WTF::Vector<WTF::String>>* out_path
,
             ::blink::mojom::blink::FileSystemAccessErrorPtr result,
             const absl::optional<WTF::Vector<WTF::String>>& path) {*out_result = std::move(result);*out_path = std::move(path);
            loop->Quit();
          },
          &loop,
          out_result,
          out_path));
  loop.Run();
}





}  // namespace blink
}  // namespace mojom
}  // namespace blink


#if defined(__clang__)
#pragma clang diagnostic pop
#endif