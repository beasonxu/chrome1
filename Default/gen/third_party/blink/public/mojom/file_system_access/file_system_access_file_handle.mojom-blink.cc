// third_party/blink/public/mojom/file_system_access/file_system_access_file_handle.mojom-blink.cc is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2013 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#if defined(__clang__)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-private-field"
#endif

#include "third_party/blink/public/mojom/file_system_access/file_system_access_file_handle.mojom-blink.h"

#include <math.h>
#include <stdint.h>
#include <utility>

#include "base/debug/alias.h"
#include "base/hash/md5_constexpr.h"
#include "base/run_loop.h"
#include "base/strings/string_number_conversions.h"
#include "base/trace_event/trace_event.h"
#include "base/trace_event/typed_macros.h"
#include "mojo/public/cpp/bindings/lib/generated_code_util.h"
#include "mojo/public/cpp/bindings/lib/message_internal.h"
#include "mojo/public/cpp/bindings/lib/send_message_helper.h"
#include "mojo/public/cpp/bindings/lib/proxy_to_responder.h"
#include "mojo/public/cpp/bindings/lib/serialization_util.h"
#include "mojo/public/cpp/bindings/lib/unserialized_message_context.h"
#include "mojo/public/cpp/bindings/lib/validate_params.h"
#include "mojo/public/cpp/bindings/lib/validation_errors.h"
#include "mojo/public/cpp/bindings/mojo_buildflags.h"
#include "mojo/public/interfaces/bindings/interface_control_messages.mojom.h"
#include "third_party/perfetto/include/perfetto/tracing/traced_value.h"

#include "third_party/blink/public/mojom/file_system_access/file_system_access_file_handle.mojom-params-data.h"
#include "third_party/blink/public/mojom/file_system_access/file_system_access_file_handle.mojom-shared-message-ids.h"

#include "third_party/blink/public/mojom/file_system_access/file_system_access_file_handle.mojom-blink-import-headers.h"
#include "third_party/blink/public/mojom/file_system_access/file_system_access_file_handle.mojom-blink-test-utils.h"
#include "mojo/public/cpp/bindings/lib/wtf_serialization.h"


#ifndef THIRD_PARTY_BLINK_PUBLIC_MOJOM_FILE_SYSTEM_ACCESS_FILE_SYSTEM_ACCESS_FILE_HANDLE_MOJOM_BLINK_JUMBO_H_
#define THIRD_PARTY_BLINK_PUBLIC_MOJOM_FILE_SYSTEM_ACCESS_FILE_SYSTEM_ACCESS_FILE_HANDLE_MOJOM_BLINK_JUMBO_H_
#endif



namespace blink {
namespace mojom {
namespace blink {
FileSystemAccessRegularFile::FileSystemAccessRegularFile()
    : os_file(),
      file_size(),
      capacity_allocation_host() {}

FileSystemAccessRegularFile::FileSystemAccessRegularFile(
    ::base::File os_file_in,
    int64_t file_size_in,
    ::mojo::PendingRemote<::blink::mojom::blink::FileSystemAccessCapacityAllocationHost> capacity_allocation_host_in)
    : os_file(std::move(os_file_in)),
      file_size(std::move(file_size_in)),
      capacity_allocation_host(std::move(capacity_allocation_host_in)) {}

FileSystemAccessRegularFile::~FileSystemAccessRegularFile() = default;

void FileSystemAccessRegularFile::WriteIntoTrace(
    perfetto::TracedValue traced_context) const {
  [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "os_file"), this->os_file,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type ::base::File>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "file_size"), this->file_size,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type int64_t>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "capacity_allocation_host"), this->capacity_allocation_host,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type ::mojo::PendingRemote<::blink::mojom::blink::FileSystemAccessCapacityAllocationHost>>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool FileSystemAccessRegularFile::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
FileSystemAccessAccessHandleFile::FileSystemAccessAccessHandleFile() : tag_(Tag::kRegularFile) {
  data_.regular_file = new FileSystemAccessRegularFilePtr;
}

FileSystemAccessAccessHandleFile::~FileSystemAccessAccessHandleFile() {
  DestroyActive();
}


void FileSystemAccessAccessHandleFile::set_regular_file(
    FileSystemAccessRegularFilePtr regular_file) {
  if (tag_ == Tag::kRegularFile) {
    *(data_.regular_file) = std::move(regular_file);
  } else {
    DestroyActive();
    tag_ = Tag::kRegularFile;
    data_.regular_file = new FileSystemAccessRegularFilePtr(
        std::move(regular_file));
  }
}
void FileSystemAccessAccessHandleFile::set_incognito_file_delegate(
    ::mojo::PendingRemote<::blink::mojom::blink::FileSystemAccessFileDelegateHost> incognito_file_delegate) {
  if (tag_ == Tag::kIncognitoFileDelegate) {
    *(data_.incognito_file_delegate) = std::move(incognito_file_delegate);
  } else {
    DestroyActive();
    tag_ = Tag::kIncognitoFileDelegate;
    data_.incognito_file_delegate = new ::mojo::PendingRemote<::blink::mojom::blink::FileSystemAccessFileDelegateHost>(
        std::move(incognito_file_delegate));
  }
}

void FileSystemAccessAccessHandleFile::DestroyActive() {
  switch (tag_) {

    case Tag::kRegularFile:

      delete data_.regular_file;
      break;
    case Tag::kIncognitoFileDelegate:

      delete data_.incognito_file_delegate;
      break;
  }
}

bool FileSystemAccessAccessHandleFile::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context, false);
}
const char FileSystemAccessFileHandle::Name_[] = "blink.mojom.FileSystemAccessFileHandle";

FileSystemAccessFileHandle::IPCStableHashFunction FileSystemAccessFileHandle::MessageToMethodInfo_(mojo::Message& message) {
#if !BUILDFLAG(IS_FUCHSIA)
  switch (message.name()) {
    case internal::kFileSystemAccessFileHandle_GetPermissionStatus_Name: {
      return &FileSystemAccessFileHandle::GetPermissionStatus_Sym::IPCStableHash;
    }
    case internal::kFileSystemAccessFileHandle_RequestPermission_Name: {
      return &FileSystemAccessFileHandle::RequestPermission_Sym::IPCStableHash;
    }
    case internal::kFileSystemAccessFileHandle_AsBlob_Name: {
      return &FileSystemAccessFileHandle::AsBlob_Sym::IPCStableHash;
    }
    case internal::kFileSystemAccessFileHandle_CreateFileWriter_Name: {
      return &FileSystemAccessFileHandle::CreateFileWriter_Sym::IPCStableHash;
    }
    case internal::kFileSystemAccessFileHandle_Rename_Name: {
      return &FileSystemAccessFileHandle::Rename_Sym::IPCStableHash;
    }
    case internal::kFileSystemAccessFileHandle_Move_Name: {
      return &FileSystemAccessFileHandle::Move_Sym::IPCStableHash;
    }
    case internal::kFileSystemAccessFileHandle_Remove_Name: {
      return &FileSystemAccessFileHandle::Remove_Sym::IPCStableHash;
    }
    case internal::kFileSystemAccessFileHandle_OpenAccessHandle_Name: {
      return &FileSystemAccessFileHandle::OpenAccessHandle_Sym::IPCStableHash;
    }
    case internal::kFileSystemAccessFileHandle_IsSameEntry_Name: {
      return &FileSystemAccessFileHandle::IsSameEntry_Sym::IPCStableHash;
    }
    case internal::kFileSystemAccessFileHandle_Transfer_Name: {
      return &FileSystemAccessFileHandle::Transfer_Sym::IPCStableHash;
    }
  }
#endif  // !BUILDFLAG(IS_FUCHSIA)
  return nullptr;
}


const char* FileSystemAccessFileHandle::MessageToMethodName_(mojo::Message& message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  bool is_response = message.has_flag(mojo::Message::kFlagIsResponse);
  if (!is_response) {
    switch (message.name()) {
      case internal::kFileSystemAccessFileHandle_GetPermissionStatus_Name:
            return "Receive blink::mojom::FileSystemAccessFileHandle::GetPermissionStatus";
      case internal::kFileSystemAccessFileHandle_RequestPermission_Name:
            return "Receive blink::mojom::FileSystemAccessFileHandle::RequestPermission";
      case internal::kFileSystemAccessFileHandle_AsBlob_Name:
            return "Receive blink::mojom::FileSystemAccessFileHandle::AsBlob";
      case internal::kFileSystemAccessFileHandle_CreateFileWriter_Name:
            return "Receive blink::mojom::FileSystemAccessFileHandle::CreateFileWriter";
      case internal::kFileSystemAccessFileHandle_Rename_Name:
            return "Receive blink::mojom::FileSystemAccessFileHandle::Rename";
      case internal::kFileSystemAccessFileHandle_Move_Name:
            return "Receive blink::mojom::FileSystemAccessFileHandle::Move";
      case internal::kFileSystemAccessFileHandle_Remove_Name:
            return "Receive blink::mojom::FileSystemAccessFileHandle::Remove";
      case internal::kFileSystemAccessFileHandle_OpenAccessHandle_Name:
            return "Receive blink::mojom::FileSystemAccessFileHandle::OpenAccessHandle";
      case internal::kFileSystemAccessFileHandle_IsSameEntry_Name:
            return "Receive blink::mojom::FileSystemAccessFileHandle::IsSameEntry";
      case internal::kFileSystemAccessFileHandle_Transfer_Name:
            return "Receive blink::mojom::FileSystemAccessFileHandle::Transfer";
    }
  } else {
    switch (message.name()) {
      case internal::kFileSystemAccessFileHandle_GetPermissionStatus_Name:
            return "Receive reply blink::mojom::FileSystemAccessFileHandle::GetPermissionStatus";
      case internal::kFileSystemAccessFileHandle_RequestPermission_Name:
            return "Receive reply blink::mojom::FileSystemAccessFileHandle::RequestPermission";
      case internal::kFileSystemAccessFileHandle_AsBlob_Name:
            return "Receive reply blink::mojom::FileSystemAccessFileHandle::AsBlob";
      case internal::kFileSystemAccessFileHandle_CreateFileWriter_Name:
            return "Receive reply blink::mojom::FileSystemAccessFileHandle::CreateFileWriter";
      case internal::kFileSystemAccessFileHandle_Rename_Name:
            return "Receive reply blink::mojom::FileSystemAccessFileHandle::Rename";
      case internal::kFileSystemAccessFileHandle_Move_Name:
            return "Receive reply blink::mojom::FileSystemAccessFileHandle::Move";
      case internal::kFileSystemAccessFileHandle_Remove_Name:
            return "Receive reply blink::mojom::FileSystemAccessFileHandle::Remove";
      case internal::kFileSystemAccessFileHandle_OpenAccessHandle_Name:
            return "Receive reply blink::mojom::FileSystemAccessFileHandle::OpenAccessHandle";
      case internal::kFileSystemAccessFileHandle_IsSameEntry_Name:
            return "Receive reply blink::mojom::FileSystemAccessFileHandle::IsSameEntry";
      case internal::kFileSystemAccessFileHandle_Transfer_Name:
            return "Receive reply blink::mojom::FileSystemAccessFileHandle::Transfer";
    }
  }
  return "Receive unknown mojo message";
#else
  bool is_response = message.has_flag(mojo::Message::kFlagIsResponse);
  if (is_response) {
    return "Receive mojo reply";
  } else {
    return "Receive mojo message";
  }
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
}

#if !BUILDFLAG(IS_FUCHSIA)
uint32_t FileSystemAccessFileHandle::GetPermissionStatus_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::FileSystemAccessFileHandle::GetPermissionStatus");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t FileSystemAccessFileHandle::RequestPermission_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::FileSystemAccessFileHandle::RequestPermission");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t FileSystemAccessFileHandle::AsBlob_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::FileSystemAccessFileHandle::AsBlob");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t FileSystemAccessFileHandle::CreateFileWriter_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::FileSystemAccessFileHandle::CreateFileWriter");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t FileSystemAccessFileHandle::Rename_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::FileSystemAccessFileHandle::Rename");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t FileSystemAccessFileHandle::Move_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::FileSystemAccessFileHandle::Move");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t FileSystemAccessFileHandle::Remove_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::FileSystemAccessFileHandle::Remove");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t FileSystemAccessFileHandle::OpenAccessHandle_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::FileSystemAccessFileHandle::OpenAccessHandle");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t FileSystemAccessFileHandle::IsSameEntry_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::FileSystemAccessFileHandle::IsSameEntry");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t FileSystemAccessFileHandle::Transfer_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::FileSystemAccessFileHandle::Transfer");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
# endif // !BUILDFLAG(IS_FUCHSIA)

class FileSystemAccessFileHandle_GetPermissionStatus_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  FileSystemAccessFileHandle_GetPermissionStatus_ForwardToCallback(
      FileSystemAccessFileHandle::GetPermissionStatusCallback callback
      ) : callback_(std::move(callback)) {
  }

  FileSystemAccessFileHandle_GetPermissionStatus_ForwardToCallback(const FileSystemAccessFileHandle_GetPermissionStatus_ForwardToCallback&) = delete;
  FileSystemAccessFileHandle_GetPermissionStatus_ForwardToCallback& operator=(const FileSystemAccessFileHandle_GetPermissionStatus_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  FileSystemAccessFileHandle::GetPermissionStatusCallback callback_;
};

class FileSystemAccessFileHandle_RequestPermission_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  FileSystemAccessFileHandle_RequestPermission_ForwardToCallback(
      FileSystemAccessFileHandle::RequestPermissionCallback callback
      ) : callback_(std::move(callback)) {
  }

  FileSystemAccessFileHandle_RequestPermission_ForwardToCallback(const FileSystemAccessFileHandle_RequestPermission_ForwardToCallback&) = delete;
  FileSystemAccessFileHandle_RequestPermission_ForwardToCallback& operator=(const FileSystemAccessFileHandle_RequestPermission_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  FileSystemAccessFileHandle::RequestPermissionCallback callback_;
};

class FileSystemAccessFileHandle_AsBlob_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  FileSystemAccessFileHandle_AsBlob_ForwardToCallback(
      FileSystemAccessFileHandle::AsBlobCallback callback
      ) : callback_(std::move(callback)) {
  }

  FileSystemAccessFileHandle_AsBlob_ForwardToCallback(const FileSystemAccessFileHandle_AsBlob_ForwardToCallback&) = delete;
  FileSystemAccessFileHandle_AsBlob_ForwardToCallback& operator=(const FileSystemAccessFileHandle_AsBlob_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  FileSystemAccessFileHandle::AsBlobCallback callback_;
};

class FileSystemAccessFileHandle_CreateFileWriter_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  FileSystemAccessFileHandle_CreateFileWriter_ForwardToCallback(
      FileSystemAccessFileHandle::CreateFileWriterCallback callback
      ) : callback_(std::move(callback)) {
  }

  FileSystemAccessFileHandle_CreateFileWriter_ForwardToCallback(const FileSystemAccessFileHandle_CreateFileWriter_ForwardToCallback&) = delete;
  FileSystemAccessFileHandle_CreateFileWriter_ForwardToCallback& operator=(const FileSystemAccessFileHandle_CreateFileWriter_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  FileSystemAccessFileHandle::CreateFileWriterCallback callback_;
};

class FileSystemAccessFileHandle_Rename_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  FileSystemAccessFileHandle_Rename_ForwardToCallback(
      FileSystemAccessFileHandle::RenameCallback callback
      ) : callback_(std::move(callback)) {
  }

  FileSystemAccessFileHandle_Rename_ForwardToCallback(const FileSystemAccessFileHandle_Rename_ForwardToCallback&) = delete;
  FileSystemAccessFileHandle_Rename_ForwardToCallback& operator=(const FileSystemAccessFileHandle_Rename_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  FileSystemAccessFileHandle::RenameCallback callback_;
};

class FileSystemAccessFileHandle_Move_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  FileSystemAccessFileHandle_Move_ForwardToCallback(
      FileSystemAccessFileHandle::MoveCallback callback
      ) : callback_(std::move(callback)) {
  }

  FileSystemAccessFileHandle_Move_ForwardToCallback(const FileSystemAccessFileHandle_Move_ForwardToCallback&) = delete;
  FileSystemAccessFileHandle_Move_ForwardToCallback& operator=(const FileSystemAccessFileHandle_Move_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  FileSystemAccessFileHandle::MoveCallback callback_;
};

class FileSystemAccessFileHandle_Remove_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  FileSystemAccessFileHandle_Remove_ForwardToCallback(
      FileSystemAccessFileHandle::RemoveCallback callback
      ) : callback_(std::move(callback)) {
  }

  FileSystemAccessFileHandle_Remove_ForwardToCallback(const FileSystemAccessFileHandle_Remove_ForwardToCallback&) = delete;
  FileSystemAccessFileHandle_Remove_ForwardToCallback& operator=(const FileSystemAccessFileHandle_Remove_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  FileSystemAccessFileHandle::RemoveCallback callback_;
};

class FileSystemAccessFileHandle_OpenAccessHandle_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  FileSystemAccessFileHandle_OpenAccessHandle_ForwardToCallback(
      FileSystemAccessFileHandle::OpenAccessHandleCallback callback
      ) : callback_(std::move(callback)) {
  }

  FileSystemAccessFileHandle_OpenAccessHandle_ForwardToCallback(const FileSystemAccessFileHandle_OpenAccessHandle_ForwardToCallback&) = delete;
  FileSystemAccessFileHandle_OpenAccessHandle_ForwardToCallback& operator=(const FileSystemAccessFileHandle_OpenAccessHandle_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  FileSystemAccessFileHandle::OpenAccessHandleCallback callback_;
};

class FileSystemAccessFileHandle_IsSameEntry_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  FileSystemAccessFileHandle_IsSameEntry_ForwardToCallback(
      FileSystemAccessFileHandle::IsSameEntryCallback callback
      ) : callback_(std::move(callback)) {
  }

  FileSystemAccessFileHandle_IsSameEntry_ForwardToCallback(const FileSystemAccessFileHandle_IsSameEntry_ForwardToCallback&) = delete;
  FileSystemAccessFileHandle_IsSameEntry_ForwardToCallback& operator=(const FileSystemAccessFileHandle_IsSameEntry_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  FileSystemAccessFileHandle::IsSameEntryCallback callback_;
};

FileSystemAccessFileHandleProxy::FileSystemAccessFileHandleProxy(mojo::MessageReceiverWithResponder* receiver)
    : receiver_(receiver) {
}

void FileSystemAccessFileHandleProxy::GetPermissionStatus(
    bool in_writable, GetPermissionStatusCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::FileSystemAccessFileHandle::GetPermissionStatus", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("writable"), in_writable,
                        "<value of type bool>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kFileSystemAccessFileHandle_GetPermissionStatus_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::FileSystemAccessFileHandle_GetPermissionStatus_Params_Data> params(
          message);
  params.Allocate();
  params->writable = in_writable;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(FileSystemAccessFileHandle::Name_);
  message.set_method_name("GetPermissionStatus");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new FileSystemAccessFileHandle_GetPermissionStatus_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void FileSystemAccessFileHandleProxy::RequestPermission(
    bool in_writable, RequestPermissionCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::FileSystemAccessFileHandle::RequestPermission", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("writable"), in_writable,
                        "<value of type bool>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kFileSystemAccessFileHandle_RequestPermission_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::FileSystemAccessFileHandle_RequestPermission_Params_Data> params(
          message);
  params.Allocate();
  params->writable = in_writable;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(FileSystemAccessFileHandle::Name_);
  message.set_method_name("RequestPermission");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new FileSystemAccessFileHandle_RequestPermission_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void FileSystemAccessFileHandleProxy::AsBlob(
    AsBlobCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send blink::mojom::FileSystemAccessFileHandle::AsBlob");
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kFileSystemAccessFileHandle_AsBlob_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::FileSystemAccessFileHandle_AsBlob_Params_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(FileSystemAccessFileHandle::Name_);
  message.set_method_name("AsBlob");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new FileSystemAccessFileHandle_AsBlob_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void FileSystemAccessFileHandleProxy::CreateFileWriter(
    bool in_keep_existing_data, bool in_auto_close, CreateFileWriterCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::FileSystemAccessFileHandle::CreateFileWriter", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("keep_existing_data"), in_keep_existing_data,
                        "<value of type bool>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("auto_close"), in_auto_close,
                        "<value of type bool>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kFileSystemAccessFileHandle_CreateFileWriter_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::FileSystemAccessFileHandle_CreateFileWriter_Params_Data> params(
          message);
  params.Allocate();
  params->keep_existing_data = in_keep_existing_data;
  params->auto_close = in_auto_close;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(FileSystemAccessFileHandle::Name_);
  message.set_method_name("CreateFileWriter");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new FileSystemAccessFileHandle_CreateFileWriter_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void FileSystemAccessFileHandleProxy::Rename(
    const WTF::String& in_new_entry_name, RenameCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::FileSystemAccessFileHandle::Rename", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("new_entry_name"), in_new_entry_name,
                        "<value of type const WTF::String&>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kFileSystemAccessFileHandle_Rename_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::FileSystemAccessFileHandle_Rename_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->new_entry_name)::BaseType> new_entry_name_fragment(
          params.message());
  mojo::internal::Serialize<mojo::StringDataView>(
      in_new_entry_name, new_entry_name_fragment);
  params->new_entry_name.Set(
      new_entry_name_fragment.is_null() ? nullptr : new_entry_name_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->new_entry_name.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null new_entry_name in FileSystemAccessFileHandle.Rename request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(FileSystemAccessFileHandle::Name_);
  message.set_method_name("Rename");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new FileSystemAccessFileHandle_Rename_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void FileSystemAccessFileHandleProxy::Move(
    ::mojo::PendingRemote<::blink::mojom::blink::FileSystemAccessTransferToken> in_destination_directory, const WTF::String& in_new_entry_name, MoveCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::FileSystemAccessFileHandle::Move", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("destination_directory"), in_destination_directory,
                        "<value of type ::mojo::PendingRemote<::blink::mojom::blink::FileSystemAccessTransferToken>>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("new_entry_name"), in_new_entry_name,
                        "<value of type const WTF::String&>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kFileSystemAccessFileHandle_Move_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::FileSystemAccessFileHandle_Move_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::Serialize<mojo::InterfacePtrDataView<::blink::mojom::FileSystemAccessTransferTokenInterfaceBase>>(
      in_destination_directory, &params->destination_directory, &params.message());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      !mojo::internal::IsHandleOrInterfaceValid(params->destination_directory),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_INVALID_HANDLE,
      "invalid destination_directory in FileSystemAccessFileHandle.Move request");
  mojo::internal::MessageFragment<
      typename decltype(params->new_entry_name)::BaseType> new_entry_name_fragment(
          params.message());
  mojo::internal::Serialize<mojo::StringDataView>(
      in_new_entry_name, new_entry_name_fragment);
  params->new_entry_name.Set(
      new_entry_name_fragment.is_null() ? nullptr : new_entry_name_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->new_entry_name.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null new_entry_name in FileSystemAccessFileHandle.Move request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(FileSystemAccessFileHandle::Name_);
  message.set_method_name("Move");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new FileSystemAccessFileHandle_Move_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void FileSystemAccessFileHandleProxy::Remove(
    RemoveCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send blink::mojom::FileSystemAccessFileHandle::Remove");
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kFileSystemAccessFileHandle_Remove_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::FileSystemAccessFileHandle_Remove_Params_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(FileSystemAccessFileHandle::Name_);
  message.set_method_name("Remove");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new FileSystemAccessFileHandle_Remove_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void FileSystemAccessFileHandleProxy::OpenAccessHandle(
    OpenAccessHandleCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send blink::mojom::FileSystemAccessFileHandle::OpenAccessHandle");
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kFileSystemAccessFileHandle_OpenAccessHandle_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::FileSystemAccessFileHandle_OpenAccessHandle_Params_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(FileSystemAccessFileHandle::Name_);
  message.set_method_name("OpenAccessHandle");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new FileSystemAccessFileHandle_OpenAccessHandle_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void FileSystemAccessFileHandleProxy::IsSameEntry(
    ::mojo::PendingRemote<::blink::mojom::blink::FileSystemAccessTransferToken> in_other, IsSameEntryCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::FileSystemAccessFileHandle::IsSameEntry", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("other"), in_other,
                        "<value of type ::mojo::PendingRemote<::blink::mojom::blink::FileSystemAccessTransferToken>>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kFileSystemAccessFileHandle_IsSameEntry_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::FileSystemAccessFileHandle_IsSameEntry_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::Serialize<mojo::InterfacePtrDataView<::blink::mojom::FileSystemAccessTransferTokenInterfaceBase>>(
      in_other, &params->other, &params.message());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      !mojo::internal::IsHandleOrInterfaceValid(params->other),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_INVALID_HANDLE,
      "invalid other in FileSystemAccessFileHandle.IsSameEntry request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(FileSystemAccessFileHandle::Name_);
  message.set_method_name("IsSameEntry");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new FileSystemAccessFileHandle_IsSameEntry_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void FileSystemAccessFileHandleProxy::Transfer(
    ::mojo::PendingReceiver<::blink::mojom::blink::FileSystemAccessTransferToken> in_token) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::FileSystemAccessFileHandle::Transfer", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("token"), in_token,
                        "<value of type ::mojo::PendingReceiver<::blink::mojom::blink::FileSystemAccessTransferToken>>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kFileSystemAccessFileHandle_Transfer_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::FileSystemAccessFileHandle_Transfer_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::Serialize<mojo::InterfaceRequestDataView<::blink::mojom::FileSystemAccessTransferTokenInterfaceBase>>(
      in_token, &params->token, &params.message());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      !mojo::internal::IsHandleOrInterfaceValid(params->token),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_INVALID_HANDLE,
      "invalid token in FileSystemAccessFileHandle.Transfer request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(FileSystemAccessFileHandle::Name_);
  message.set_method_name("Transfer");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}
class FileSystemAccessFileHandle_GetPermissionStatus_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static FileSystemAccessFileHandle::GetPermissionStatusCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<FileSystemAccessFileHandle_GetPermissionStatus_ProxyToResponder> proxy(
        new FileSystemAccessFileHandle_GetPermissionStatus_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&FileSystemAccessFileHandle_GetPermissionStatus_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~FileSystemAccessFileHandle_GetPermissionStatus_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  FileSystemAccessFileHandle_GetPermissionStatus_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "FileSystemAccessFileHandle::GetPermissionStatusCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      ::blink::mojom::blink::PermissionStatus in_status);
};

bool FileSystemAccessFileHandle_GetPermissionStatus_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::FileSystemAccessFileHandle_GetPermissionStatus_ResponseParams_Data* params =
      reinterpret_cast<
          internal::FileSystemAccessFileHandle_GetPermissionStatus_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  ::blink::mojom::blink::PermissionStatus p_status{};
  FileSystemAccessFileHandle_GetPermissionStatus_ResponseParamsDataView input_data_view(params, message);
  
  if (success && !input_data_view.ReadStatus(&p_status))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        FileSystemAccessFileHandle::Name_, 0, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_status));
  return true;
}

void FileSystemAccessFileHandle_GetPermissionStatus_ProxyToResponder::Run(
    ::blink::mojom::blink::PermissionStatus in_status) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send reply blink::mojom::FileSystemAccessFileHandle::GetPermissionStatus", "async_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("status"), in_status,
                        "<value of type ::blink::mojom::blink::PermissionStatus>");
   });
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kFileSystemAccessFileHandle_GetPermissionStatus_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::FileSystemAccessFileHandle_GetPermissionStatus_ResponseParams_Data> params(
          message);
  params.Allocate();
  mojo::internal::Serialize<::blink::mojom::PermissionStatus>(
      in_status, &params->status);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(FileSystemAccessFileHandle::Name_);
  message.set_method_name("GetPermissionStatus");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class FileSystemAccessFileHandle_RequestPermission_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static FileSystemAccessFileHandle::RequestPermissionCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<FileSystemAccessFileHandle_RequestPermission_ProxyToResponder> proxy(
        new FileSystemAccessFileHandle_RequestPermission_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&FileSystemAccessFileHandle_RequestPermission_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~FileSystemAccessFileHandle_RequestPermission_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  FileSystemAccessFileHandle_RequestPermission_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "FileSystemAccessFileHandle::RequestPermissionCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      ::blink::mojom::blink::FileSystemAccessErrorPtr in_result, ::blink::mojom::blink::PermissionStatus in_status);
};

bool FileSystemAccessFileHandle_RequestPermission_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::FileSystemAccessFileHandle_RequestPermission_ResponseParams_Data* params =
      reinterpret_cast<
          internal::FileSystemAccessFileHandle_RequestPermission_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  ::blink::mojom::blink::FileSystemAccessErrorPtr p_result{};
  ::blink::mojom::blink::PermissionStatus p_status{};
  FileSystemAccessFileHandle_RequestPermission_ResponseParamsDataView input_data_view(params, message);
  
  if (success && !input_data_view.ReadResult(&p_result))
    success = false;
  if (success && !input_data_view.ReadStatus(&p_status))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        FileSystemAccessFileHandle::Name_, 1, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_result), 
std::move(p_status));
  return true;
}

void FileSystemAccessFileHandle_RequestPermission_ProxyToResponder::Run(
    ::blink::mojom::blink::FileSystemAccessErrorPtr in_result, ::blink::mojom::blink::PermissionStatus in_status) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send reply blink::mojom::FileSystemAccessFileHandle::RequestPermission", "async_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("result"), in_result,
                        "<value of type ::blink::mojom::blink::FileSystemAccessErrorPtr>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("status"), in_status,
                        "<value of type ::blink::mojom::blink::PermissionStatus>");
   });
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kFileSystemAccessFileHandle_RequestPermission_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::FileSystemAccessFileHandle_RequestPermission_ResponseParams_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->result)::BaseType> result_fragment(
          params.message());
  mojo::internal::Serialize<::blink::mojom::FileSystemAccessErrorDataView>(
      in_result, result_fragment);
  params->result.Set(
      result_fragment.is_null() ? nullptr : result_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->result.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null result in ");
  mojo::internal::Serialize<::blink::mojom::PermissionStatus>(
      in_status, &params->status);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(FileSystemAccessFileHandle::Name_);
  message.set_method_name("RequestPermission");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class FileSystemAccessFileHandle_AsBlob_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static FileSystemAccessFileHandle::AsBlobCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<FileSystemAccessFileHandle_AsBlob_ProxyToResponder> proxy(
        new FileSystemAccessFileHandle_AsBlob_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&FileSystemAccessFileHandle_AsBlob_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~FileSystemAccessFileHandle_AsBlob_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  FileSystemAccessFileHandle_AsBlob_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "FileSystemAccessFileHandle::AsBlobCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      ::blink::mojom::blink::FileSystemAccessErrorPtr in_result, const ::base::File::Info& in_info, const ::scoped_refptr<::blink::BlobDataHandle>& in_blob);
};

bool FileSystemAccessFileHandle_AsBlob_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::FileSystemAccessFileHandle_AsBlob_ResponseParams_Data* params =
      reinterpret_cast<
          internal::FileSystemAccessFileHandle_AsBlob_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  ::blink::mojom::blink::FileSystemAccessErrorPtr p_result{};
  ::base::File::Info p_info{};
  ::scoped_refptr<::blink::BlobDataHandle> p_blob{};
  FileSystemAccessFileHandle_AsBlob_ResponseParamsDataView input_data_view(params, message);
  
  if (success && !input_data_view.ReadResult(&p_result))
    success = false;
  if (success && !input_data_view.ReadInfo(&p_info))
    success = false;
  if (success && !input_data_view.ReadBlob(&p_blob))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        FileSystemAccessFileHandle::Name_, 2, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_result), 
std::move(p_info), 
std::move(p_blob));
  return true;
}

void FileSystemAccessFileHandle_AsBlob_ProxyToResponder::Run(
    ::blink::mojom::blink::FileSystemAccessErrorPtr in_result, const ::base::File::Info& in_info, const ::scoped_refptr<::blink::BlobDataHandle>& in_blob) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send reply blink::mojom::FileSystemAccessFileHandle::AsBlob", "async_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("result"), in_result,
                        "<value of type ::blink::mojom::blink::FileSystemAccessErrorPtr>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("info"), in_info,
                        "<value of type const ::base::File::Info&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("blob"), in_blob,
                        "<value of type const ::scoped_refptr<::blink::BlobDataHandle>&>");
   });
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kFileSystemAccessFileHandle_AsBlob_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::FileSystemAccessFileHandle_AsBlob_ResponseParams_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->result)::BaseType> result_fragment(
          params.message());
  mojo::internal::Serialize<::blink::mojom::FileSystemAccessErrorDataView>(
      in_result, result_fragment);
  params->result.Set(
      result_fragment.is_null() ? nullptr : result_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->result.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null result in ");
  mojo::internal::MessageFragment<
      typename decltype(params->info)::BaseType> info_fragment(
          params.message());
  mojo::internal::Serialize<::mojo_base::mojom::FileInfoDataView>(
      in_info, info_fragment);
  params->info.Set(
      info_fragment.is_null() ? nullptr : info_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->info.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null info in ");
  mojo::internal::MessageFragment<
      typename decltype(params->blob)::BaseType> blob_fragment(
          params.message());
  mojo::internal::Serialize<::blink::mojom::SerializedBlobDataView>(
      in_blob, blob_fragment);
  params->blob.Set(
      blob_fragment.is_null() ? nullptr : blob_fragment.data());

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(FileSystemAccessFileHandle::Name_);
  message.set_method_name("AsBlob");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class FileSystemAccessFileHandle_CreateFileWriter_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static FileSystemAccessFileHandle::CreateFileWriterCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<FileSystemAccessFileHandle_CreateFileWriter_ProxyToResponder> proxy(
        new FileSystemAccessFileHandle_CreateFileWriter_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&FileSystemAccessFileHandle_CreateFileWriter_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~FileSystemAccessFileHandle_CreateFileWriter_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  FileSystemAccessFileHandle_CreateFileWriter_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "FileSystemAccessFileHandle::CreateFileWriterCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      ::blink::mojom::blink::FileSystemAccessErrorPtr in_result, ::mojo::PendingRemote<::blink::mojom::blink::FileSystemAccessFileWriter> in_writer);
};

bool FileSystemAccessFileHandle_CreateFileWriter_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::FileSystemAccessFileHandle_CreateFileWriter_ResponseParams_Data* params =
      reinterpret_cast<
          internal::FileSystemAccessFileHandle_CreateFileWriter_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  ::blink::mojom::blink::FileSystemAccessErrorPtr p_result{};
  ::mojo::PendingRemote<::blink::mojom::blink::FileSystemAccessFileWriter> p_writer{};
  FileSystemAccessFileHandle_CreateFileWriter_ResponseParamsDataView input_data_view(params, message);
  
  if (success && !input_data_view.ReadResult(&p_result))
    success = false;
  if (success) {
    p_writer =
        input_data_view.TakeWriter<decltype(p_writer)>();
  }
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        FileSystemAccessFileHandle::Name_, 3, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_result), 
std::move(p_writer));
  return true;
}

void FileSystemAccessFileHandle_CreateFileWriter_ProxyToResponder::Run(
    ::blink::mojom::blink::FileSystemAccessErrorPtr in_result, ::mojo::PendingRemote<::blink::mojom::blink::FileSystemAccessFileWriter> in_writer) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send reply blink::mojom::FileSystemAccessFileHandle::CreateFileWriter", "async_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("result"), in_result,
                        "<value of type ::blink::mojom::blink::FileSystemAccessErrorPtr>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("writer"), in_writer,
                        "<value of type ::mojo::PendingRemote<::blink::mojom::blink::FileSystemAccessFileWriter>>");
   });
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kFileSystemAccessFileHandle_CreateFileWriter_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::FileSystemAccessFileHandle_CreateFileWriter_ResponseParams_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->result)::BaseType> result_fragment(
          params.message());
  mojo::internal::Serialize<::blink::mojom::FileSystemAccessErrorDataView>(
      in_result, result_fragment);
  params->result.Set(
      result_fragment.is_null() ? nullptr : result_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->result.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null result in ");
  mojo::internal::Serialize<mojo::InterfacePtrDataView<::blink::mojom::FileSystemAccessFileWriterInterfaceBase>>(
      in_writer, &params->writer, &params.message());

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(FileSystemAccessFileHandle::Name_);
  message.set_method_name("CreateFileWriter");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class FileSystemAccessFileHandle_Rename_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static FileSystemAccessFileHandle::RenameCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<FileSystemAccessFileHandle_Rename_ProxyToResponder> proxy(
        new FileSystemAccessFileHandle_Rename_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&FileSystemAccessFileHandle_Rename_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~FileSystemAccessFileHandle_Rename_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  FileSystemAccessFileHandle_Rename_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "FileSystemAccessFileHandle::RenameCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      ::blink::mojom::blink::FileSystemAccessErrorPtr in_result);
};

bool FileSystemAccessFileHandle_Rename_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::FileSystemAccessFileHandle_Rename_ResponseParams_Data* params =
      reinterpret_cast<
          internal::FileSystemAccessFileHandle_Rename_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  ::blink::mojom::blink::FileSystemAccessErrorPtr p_result{};
  FileSystemAccessFileHandle_Rename_ResponseParamsDataView input_data_view(params, message);
  
  if (success && !input_data_view.ReadResult(&p_result))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        FileSystemAccessFileHandle::Name_, 4, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_result));
  return true;
}

void FileSystemAccessFileHandle_Rename_ProxyToResponder::Run(
    ::blink::mojom::blink::FileSystemAccessErrorPtr in_result) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send reply blink::mojom::FileSystemAccessFileHandle::Rename", "async_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("result"), in_result,
                        "<value of type ::blink::mojom::blink::FileSystemAccessErrorPtr>");
   });
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kFileSystemAccessFileHandle_Rename_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::FileSystemAccessFileHandle_Rename_ResponseParams_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->result)::BaseType> result_fragment(
          params.message());
  mojo::internal::Serialize<::blink::mojom::FileSystemAccessErrorDataView>(
      in_result, result_fragment);
  params->result.Set(
      result_fragment.is_null() ? nullptr : result_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->result.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null result in ");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(FileSystemAccessFileHandle::Name_);
  message.set_method_name("Rename");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class FileSystemAccessFileHandle_Move_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static FileSystemAccessFileHandle::MoveCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<FileSystemAccessFileHandle_Move_ProxyToResponder> proxy(
        new FileSystemAccessFileHandle_Move_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&FileSystemAccessFileHandle_Move_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~FileSystemAccessFileHandle_Move_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  FileSystemAccessFileHandle_Move_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "FileSystemAccessFileHandle::MoveCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      ::blink::mojom::blink::FileSystemAccessErrorPtr in_result);
};

bool FileSystemAccessFileHandle_Move_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::FileSystemAccessFileHandle_Move_ResponseParams_Data* params =
      reinterpret_cast<
          internal::FileSystemAccessFileHandle_Move_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  ::blink::mojom::blink::FileSystemAccessErrorPtr p_result{};
  FileSystemAccessFileHandle_Move_ResponseParamsDataView input_data_view(params, message);
  
  if (success && !input_data_view.ReadResult(&p_result))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        FileSystemAccessFileHandle::Name_, 5, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_result));
  return true;
}

void FileSystemAccessFileHandle_Move_ProxyToResponder::Run(
    ::blink::mojom::blink::FileSystemAccessErrorPtr in_result) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send reply blink::mojom::FileSystemAccessFileHandle::Move", "async_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("result"), in_result,
                        "<value of type ::blink::mojom::blink::FileSystemAccessErrorPtr>");
   });
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kFileSystemAccessFileHandle_Move_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::FileSystemAccessFileHandle_Move_ResponseParams_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->result)::BaseType> result_fragment(
          params.message());
  mojo::internal::Serialize<::blink::mojom::FileSystemAccessErrorDataView>(
      in_result, result_fragment);
  params->result.Set(
      result_fragment.is_null() ? nullptr : result_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->result.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null result in ");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(FileSystemAccessFileHandle::Name_);
  message.set_method_name("Move");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class FileSystemAccessFileHandle_Remove_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static FileSystemAccessFileHandle::RemoveCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<FileSystemAccessFileHandle_Remove_ProxyToResponder> proxy(
        new FileSystemAccessFileHandle_Remove_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&FileSystemAccessFileHandle_Remove_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~FileSystemAccessFileHandle_Remove_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  FileSystemAccessFileHandle_Remove_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "FileSystemAccessFileHandle::RemoveCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      ::blink::mojom::blink::FileSystemAccessErrorPtr in_result);
};

bool FileSystemAccessFileHandle_Remove_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::FileSystemAccessFileHandle_Remove_ResponseParams_Data* params =
      reinterpret_cast<
          internal::FileSystemAccessFileHandle_Remove_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  ::blink::mojom::blink::FileSystemAccessErrorPtr p_result{};
  FileSystemAccessFileHandle_Remove_ResponseParamsDataView input_data_view(params, message);
  
  if (success && !input_data_view.ReadResult(&p_result))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        FileSystemAccessFileHandle::Name_, 6, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_result));
  return true;
}

void FileSystemAccessFileHandle_Remove_ProxyToResponder::Run(
    ::blink::mojom::blink::FileSystemAccessErrorPtr in_result) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send reply blink::mojom::FileSystemAccessFileHandle::Remove", "async_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("result"), in_result,
                        "<value of type ::blink::mojom::blink::FileSystemAccessErrorPtr>");
   });
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kFileSystemAccessFileHandle_Remove_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::FileSystemAccessFileHandle_Remove_ResponseParams_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->result)::BaseType> result_fragment(
          params.message());
  mojo::internal::Serialize<::blink::mojom::FileSystemAccessErrorDataView>(
      in_result, result_fragment);
  params->result.Set(
      result_fragment.is_null() ? nullptr : result_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->result.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null result in ");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(FileSystemAccessFileHandle::Name_);
  message.set_method_name("Remove");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class FileSystemAccessFileHandle_OpenAccessHandle_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static FileSystemAccessFileHandle::OpenAccessHandleCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<FileSystemAccessFileHandle_OpenAccessHandle_ProxyToResponder> proxy(
        new FileSystemAccessFileHandle_OpenAccessHandle_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&FileSystemAccessFileHandle_OpenAccessHandle_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~FileSystemAccessFileHandle_OpenAccessHandle_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  FileSystemAccessFileHandle_OpenAccessHandle_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "FileSystemAccessFileHandle::OpenAccessHandleCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      ::blink::mojom::blink::FileSystemAccessErrorPtr in_result, FileSystemAccessAccessHandleFilePtr in_file, ::mojo::PendingRemote<::blink::mojom::blink::FileSystemAccessAccessHandleHost> in_access_handle_host);
};

bool FileSystemAccessFileHandle_OpenAccessHandle_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::FileSystemAccessFileHandle_OpenAccessHandle_ResponseParams_Data* params =
      reinterpret_cast<
          internal::FileSystemAccessFileHandle_OpenAccessHandle_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  ::blink::mojom::blink::FileSystemAccessErrorPtr p_result{};
  FileSystemAccessAccessHandleFilePtr p_file{};
  ::mojo::PendingRemote<::blink::mojom::blink::FileSystemAccessAccessHandleHost> p_access_handle_host{};
  FileSystemAccessFileHandle_OpenAccessHandle_ResponseParamsDataView input_data_view(params, message);
  
  if (success && !input_data_view.ReadResult(&p_result))
    success = false;
  if (success && !input_data_view.ReadFile(&p_file))
    success = false;
  if (success) {
    p_access_handle_host =
        input_data_view.TakeAccessHandleHost<decltype(p_access_handle_host)>();
  }
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        FileSystemAccessFileHandle::Name_, 7, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_result), 
std::move(p_file), 
std::move(p_access_handle_host));
  return true;
}

void FileSystemAccessFileHandle_OpenAccessHandle_ProxyToResponder::Run(
    ::blink::mojom::blink::FileSystemAccessErrorPtr in_result, FileSystemAccessAccessHandleFilePtr in_file, ::mojo::PendingRemote<::blink::mojom::blink::FileSystemAccessAccessHandleHost> in_access_handle_host) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send reply blink::mojom::FileSystemAccessFileHandle::OpenAccessHandle", "async_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("result"), in_result,
                        "<value of type ::blink::mojom::blink::FileSystemAccessErrorPtr>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("file"), in_file,
                        "<value of type FileSystemAccessAccessHandleFilePtr>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("access_handle_host"), in_access_handle_host,
                        "<value of type ::mojo::PendingRemote<::blink::mojom::blink::FileSystemAccessAccessHandleHost>>");
   });
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kFileSystemAccessFileHandle_OpenAccessHandle_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::FileSystemAccessFileHandle_OpenAccessHandle_ResponseParams_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->result)::BaseType> result_fragment(
          params.message());
  mojo::internal::Serialize<::blink::mojom::FileSystemAccessErrorDataView>(
      in_result, result_fragment);
  params->result.Set(
      result_fragment.is_null() ? nullptr : result_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->result.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null result in ");
  mojo::internal::MessageFragment<decltype(params->file)>
      file_fragment(params.message());
  file_fragment.Claim(&params->file);
  mojo::internal::Serialize<::blink::mojom::FileSystemAccessAccessHandleFileDataView>(
      in_file, file_fragment, true);
  mojo::internal::Serialize<mojo::InterfacePtrDataView<::blink::mojom::FileSystemAccessAccessHandleHostInterfaceBase>>(
      in_access_handle_host, &params->access_handle_host, &params.message());

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(FileSystemAccessFileHandle::Name_);
  message.set_method_name("OpenAccessHandle");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class FileSystemAccessFileHandle_IsSameEntry_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static FileSystemAccessFileHandle::IsSameEntryCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<FileSystemAccessFileHandle_IsSameEntry_ProxyToResponder> proxy(
        new FileSystemAccessFileHandle_IsSameEntry_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&FileSystemAccessFileHandle_IsSameEntry_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~FileSystemAccessFileHandle_IsSameEntry_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  FileSystemAccessFileHandle_IsSameEntry_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "FileSystemAccessFileHandle::IsSameEntryCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      ::blink::mojom::blink::FileSystemAccessErrorPtr in_result, bool in_is_same);
};

bool FileSystemAccessFileHandle_IsSameEntry_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::FileSystemAccessFileHandle_IsSameEntry_ResponseParams_Data* params =
      reinterpret_cast<
          internal::FileSystemAccessFileHandle_IsSameEntry_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  ::blink::mojom::blink::FileSystemAccessErrorPtr p_result{};
  bool p_is_same{};
  FileSystemAccessFileHandle_IsSameEntry_ResponseParamsDataView input_data_view(params, message);
  
  if (success && !input_data_view.ReadResult(&p_result))
    success = false;
  if (success)
    p_is_same = input_data_view.is_same();
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        FileSystemAccessFileHandle::Name_, 8, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_result), 
std::move(p_is_same));
  return true;
}

void FileSystemAccessFileHandle_IsSameEntry_ProxyToResponder::Run(
    ::blink::mojom::blink::FileSystemAccessErrorPtr in_result, bool in_is_same) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send reply blink::mojom::FileSystemAccessFileHandle::IsSameEntry", "async_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("result"), in_result,
                        "<value of type ::blink::mojom::blink::FileSystemAccessErrorPtr>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("is_same"), in_is_same,
                        "<value of type bool>");
   });
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kFileSystemAccessFileHandle_IsSameEntry_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::FileSystemAccessFileHandle_IsSameEntry_ResponseParams_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->result)::BaseType> result_fragment(
          params.message());
  mojo::internal::Serialize<::blink::mojom::FileSystemAccessErrorDataView>(
      in_result, result_fragment);
  params->result.Set(
      result_fragment.is_null() ? nullptr : result_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->result.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null result in ");
  params->is_same = in_is_same;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(FileSystemAccessFileHandle::Name_);
  message.set_method_name("IsSameEntry");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}

// static
bool FileSystemAccessFileHandleStubDispatch::Accept(
    FileSystemAccessFileHandle* impl,
    mojo::Message* message) {
  switch (message->header()->name) {
    case internal::kFileSystemAccessFileHandle_GetPermissionStatus_Name: {
      break;
    }
    case internal::kFileSystemAccessFileHandle_RequestPermission_Name: {
      break;
    }
    case internal::kFileSystemAccessFileHandle_AsBlob_Name: {
      break;
    }
    case internal::kFileSystemAccessFileHandle_CreateFileWriter_Name: {
      break;
    }
    case internal::kFileSystemAccessFileHandle_Rename_Name: {
      break;
    }
    case internal::kFileSystemAccessFileHandle_Move_Name: {
      break;
    }
    case internal::kFileSystemAccessFileHandle_Remove_Name: {
      break;
    }
    case internal::kFileSystemAccessFileHandle_OpenAccessHandle_Name: {
      break;
    }
    case internal::kFileSystemAccessFileHandle_IsSameEntry_Name: {
      break;
    }
    case internal::kFileSystemAccessFileHandle_Transfer_Name: {

      DCHECK(message->is_serialized());
      internal::FileSystemAccessFileHandle_Transfer_Params_Data* params =
          reinterpret_cast<internal::FileSystemAccessFileHandle_Transfer_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::mojo::PendingReceiver<::blink::mojom::blink::FileSystemAccessTransferToken> p_token{};
      FileSystemAccessFileHandle_Transfer_ParamsDataView input_data_view(params, message);
      
      if (success) {
        p_token =
            input_data_view.TakeToken<decltype(p_token)>();
      }
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            FileSystemAccessFileHandle::Name_, 9, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->Transfer(
std::move(p_token));
      return true;
    }
  }
  return false;
}

// static
bool FileSystemAccessFileHandleStubDispatch::AcceptWithResponder(
    FileSystemAccessFileHandle* impl,
    mojo::Message* message,
    std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
  [[maybe_unused]] const bool message_is_sync =
      message->has_flag(mojo::Message::kFlagIsSync);
  [[maybe_unused]] const uint64_t request_id = message->request_id();
  switch (message->header()->name) {
    case internal::kFileSystemAccessFileHandle_GetPermissionStatus_Name: {

      internal::FileSystemAccessFileHandle_GetPermissionStatus_Params_Data* params =
          reinterpret_cast<
              internal::FileSystemAccessFileHandle_GetPermissionStatus_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      bool p_writable{};
      FileSystemAccessFileHandle_GetPermissionStatus_ParamsDataView input_data_view(params, message);
      
      if (success)
        p_writable = input_data_view.writable();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            FileSystemAccessFileHandle::Name_, 0, false);
        return false;
      }
      FileSystemAccessFileHandle::GetPermissionStatusCallback callback =
          FileSystemAccessFileHandle_GetPermissionStatus_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->GetPermissionStatus(
std::move(p_writable), std::move(callback));
      return true;
    }
    case internal::kFileSystemAccessFileHandle_RequestPermission_Name: {

      internal::FileSystemAccessFileHandle_RequestPermission_Params_Data* params =
          reinterpret_cast<
              internal::FileSystemAccessFileHandle_RequestPermission_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      bool p_writable{};
      FileSystemAccessFileHandle_RequestPermission_ParamsDataView input_data_view(params, message);
      
      if (success)
        p_writable = input_data_view.writable();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            FileSystemAccessFileHandle::Name_, 1, false);
        return false;
      }
      FileSystemAccessFileHandle::RequestPermissionCallback callback =
          FileSystemAccessFileHandle_RequestPermission_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->RequestPermission(
std::move(p_writable), std::move(callback));
      return true;
    }
    case internal::kFileSystemAccessFileHandle_AsBlob_Name: {

      internal::FileSystemAccessFileHandle_AsBlob_Params_Data* params =
          reinterpret_cast<
              internal::FileSystemAccessFileHandle_AsBlob_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      FileSystemAccessFileHandle_AsBlob_ParamsDataView input_data_view(params, message);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            FileSystemAccessFileHandle::Name_, 2, false);
        return false;
      }
      FileSystemAccessFileHandle::AsBlobCallback callback =
          FileSystemAccessFileHandle_AsBlob_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->AsBlob(std::move(callback));
      return true;
    }
    case internal::kFileSystemAccessFileHandle_CreateFileWriter_Name: {

      internal::FileSystemAccessFileHandle_CreateFileWriter_Params_Data* params =
          reinterpret_cast<
              internal::FileSystemAccessFileHandle_CreateFileWriter_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      bool p_keep_existing_data{};
      bool p_auto_close{};
      FileSystemAccessFileHandle_CreateFileWriter_ParamsDataView input_data_view(params, message);
      
      if (success)
        p_keep_existing_data = input_data_view.keep_existing_data();
      if (success)
        p_auto_close = input_data_view.auto_close();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            FileSystemAccessFileHandle::Name_, 3, false);
        return false;
      }
      FileSystemAccessFileHandle::CreateFileWriterCallback callback =
          FileSystemAccessFileHandle_CreateFileWriter_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->CreateFileWriter(
std::move(p_keep_existing_data), 
std::move(p_auto_close), std::move(callback));
      return true;
    }
    case internal::kFileSystemAccessFileHandle_Rename_Name: {

      internal::FileSystemAccessFileHandle_Rename_Params_Data* params =
          reinterpret_cast<
              internal::FileSystemAccessFileHandle_Rename_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      WTF::String p_new_entry_name{};
      FileSystemAccessFileHandle_Rename_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadNewEntryName(&p_new_entry_name))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            FileSystemAccessFileHandle::Name_, 4, false);
        return false;
      }
      FileSystemAccessFileHandle::RenameCallback callback =
          FileSystemAccessFileHandle_Rename_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->Rename(
std::move(p_new_entry_name), std::move(callback));
      return true;
    }
    case internal::kFileSystemAccessFileHandle_Move_Name: {

      internal::FileSystemAccessFileHandle_Move_Params_Data* params =
          reinterpret_cast<
              internal::FileSystemAccessFileHandle_Move_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      ::mojo::PendingRemote<::blink::mojom::blink::FileSystemAccessTransferToken> p_destination_directory{};
      WTF::String p_new_entry_name{};
      FileSystemAccessFileHandle_Move_ParamsDataView input_data_view(params, message);
      
      if (success) {
        p_destination_directory =
            input_data_view.TakeDestinationDirectory<decltype(p_destination_directory)>();
      }
      if (success && !input_data_view.ReadNewEntryName(&p_new_entry_name))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            FileSystemAccessFileHandle::Name_, 5, false);
        return false;
      }
      FileSystemAccessFileHandle::MoveCallback callback =
          FileSystemAccessFileHandle_Move_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->Move(
std::move(p_destination_directory), 
std::move(p_new_entry_name), std::move(callback));
      return true;
    }
    case internal::kFileSystemAccessFileHandle_Remove_Name: {

      internal::FileSystemAccessFileHandle_Remove_Params_Data* params =
          reinterpret_cast<
              internal::FileSystemAccessFileHandle_Remove_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      FileSystemAccessFileHandle_Remove_ParamsDataView input_data_view(params, message);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            FileSystemAccessFileHandle::Name_, 6, false);
        return false;
      }
      FileSystemAccessFileHandle::RemoveCallback callback =
          FileSystemAccessFileHandle_Remove_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->Remove(std::move(callback));
      return true;
    }
    case internal::kFileSystemAccessFileHandle_OpenAccessHandle_Name: {

      internal::FileSystemAccessFileHandle_OpenAccessHandle_Params_Data* params =
          reinterpret_cast<
              internal::FileSystemAccessFileHandle_OpenAccessHandle_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      FileSystemAccessFileHandle_OpenAccessHandle_ParamsDataView input_data_view(params, message);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            FileSystemAccessFileHandle::Name_, 7, false);
        return false;
      }
      FileSystemAccessFileHandle::OpenAccessHandleCallback callback =
          FileSystemAccessFileHandle_OpenAccessHandle_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->OpenAccessHandle(std::move(callback));
      return true;
    }
    case internal::kFileSystemAccessFileHandle_IsSameEntry_Name: {

      internal::FileSystemAccessFileHandle_IsSameEntry_Params_Data* params =
          reinterpret_cast<
              internal::FileSystemAccessFileHandle_IsSameEntry_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      ::mojo::PendingRemote<::blink::mojom::blink::FileSystemAccessTransferToken> p_other{};
      FileSystemAccessFileHandle_IsSameEntry_ParamsDataView input_data_view(params, message);
      
      if (success) {
        p_other =
            input_data_view.TakeOther<decltype(p_other)>();
      }
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            FileSystemAccessFileHandle::Name_, 8, false);
        return false;
      }
      FileSystemAccessFileHandle::IsSameEntryCallback callback =
          FileSystemAccessFileHandle_IsSameEntry_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->IsSameEntry(
std::move(p_other), std::move(callback));
      return true;
    }
    case internal::kFileSystemAccessFileHandle_Transfer_Name: {
      break;
    }
  }
  return false;
}


static const mojo::internal::GenericValidationInfo kFileSystemAccessFileHandleValidationInfo[] = {
    {&internal::FileSystemAccessFileHandle_GetPermissionStatus_Params_Data::Validate,
     &internal::FileSystemAccessFileHandle_GetPermissionStatus_ResponseParams_Data::Validate},
    {&internal::FileSystemAccessFileHandle_RequestPermission_Params_Data::Validate,
     &internal::FileSystemAccessFileHandle_RequestPermission_ResponseParams_Data::Validate},
    {&internal::FileSystemAccessFileHandle_AsBlob_Params_Data::Validate,
     &internal::FileSystemAccessFileHandle_AsBlob_ResponseParams_Data::Validate},
    {&internal::FileSystemAccessFileHandle_CreateFileWriter_Params_Data::Validate,
     &internal::FileSystemAccessFileHandle_CreateFileWriter_ResponseParams_Data::Validate},
    {&internal::FileSystemAccessFileHandle_Rename_Params_Data::Validate,
     &internal::FileSystemAccessFileHandle_Rename_ResponseParams_Data::Validate},
    {&internal::FileSystemAccessFileHandle_Move_Params_Data::Validate,
     &internal::FileSystemAccessFileHandle_Move_ResponseParams_Data::Validate},
    {&internal::FileSystemAccessFileHandle_Remove_Params_Data::Validate,
     &internal::FileSystemAccessFileHandle_Remove_ResponseParams_Data::Validate},
    {&internal::FileSystemAccessFileHandle_OpenAccessHandle_Params_Data::Validate,
     &internal::FileSystemAccessFileHandle_OpenAccessHandle_ResponseParams_Data::Validate},
    {&internal::FileSystemAccessFileHandle_IsSameEntry_Params_Data::Validate,
     &internal::FileSystemAccessFileHandle_IsSameEntry_ResponseParams_Data::Validate},
    {&internal::FileSystemAccessFileHandle_Transfer_Params_Data::Validate,
     nullptr /* no response */},
};

bool FileSystemAccessFileHandleRequestValidator::Accept(mojo::Message* message) {
  const char* name = ::blink::mojom::blink::FileSystemAccessFileHandle::Name_;
  return mojo::internal::ValidateRequestGenericPacked(message, name, kFileSystemAccessFileHandleValidationInfo);
}

bool FileSystemAccessFileHandleResponseValidator::Accept(mojo::Message* message) {
  const char* name = ::blink::mojom::blink::FileSystemAccessFileHandle::Name_;
  return mojo::internal::ValidateResponseGenericPacked(message, name, kFileSystemAccessFileHandleValidationInfo);
}


}  // namespace blink
}  // namespace mojom
}  // namespace blink


namespace mojo {


// static
bool StructTraits<::blink::mojom::blink::FileSystemAccessRegularFile::DataView, ::blink::mojom::blink::FileSystemAccessRegularFilePtr>::Read(
    ::blink::mojom::blink::FileSystemAccessRegularFile::DataView input,
    ::blink::mojom::blink::FileSystemAccessRegularFilePtr* output) {
  bool success = true;
  ::blink::mojom::blink::FileSystemAccessRegularFilePtr result(::blink::mojom::blink::FileSystemAccessRegularFile::New());
  
      if (success && !input.ReadOsFile(&result->os_file))
        success = false;
      if (success)
        result->file_size = input.file_size();
      if (success) {
        result->capacity_allocation_host =
            input.TakeCapacityAllocationHost<decltype(result->capacity_allocation_host)>();
      }
  *output = std::move(result);
  return success;
}

// static
bool UnionTraits<::blink::mojom::blink::FileSystemAccessAccessHandleFile::DataView, ::blink::mojom::blink::FileSystemAccessAccessHandleFilePtr>::Read(
    ::blink::mojom::blink::FileSystemAccessAccessHandleFile::DataView input,
    ::blink::mojom::blink::FileSystemAccessAccessHandleFilePtr* output) {
  using UnionType = ::blink::mojom::blink::FileSystemAccessAccessHandleFile;
  using Tag = UnionType::Tag;

  switch (input.tag()) {
    case Tag::kRegularFile: {
      ::blink::mojom::blink::FileSystemAccessRegularFilePtr result_regular_file;
      if (!input.ReadRegularFile(&result_regular_file))
        return false;

      *output = UnionType::NewRegularFile(
          std::move(result_regular_file));
      break;
    }
    case Tag::kIncognitoFileDelegate: {
      *output = UnionType::NewIncognitoFileDelegate(
          input.TakeIncognitoFileDelegate<::mojo::PendingRemote<::blink::mojom::blink::FileSystemAccessFileDelegateHost>>());
      break;
    }
    default:

      return false;
  }
  return true;
}

}  // namespace mojo


// Symbols declared in the -test-utils.h header are defined here instead of a
// separate .cc file to save compile time.


namespace blink {
namespace mojom {
namespace blink {


void FileSystemAccessFileHandleInterceptorForTesting::GetPermissionStatus(bool writable, GetPermissionStatusCallback callback) {
  GetForwardingInterface()->GetPermissionStatus(std::move(writable), std::move(callback));
}
void FileSystemAccessFileHandleInterceptorForTesting::RequestPermission(bool writable, RequestPermissionCallback callback) {
  GetForwardingInterface()->RequestPermission(std::move(writable), std::move(callback));
}
void FileSystemAccessFileHandleInterceptorForTesting::AsBlob(AsBlobCallback callback) {
  GetForwardingInterface()->AsBlob(std::move(callback));
}
void FileSystemAccessFileHandleInterceptorForTesting::CreateFileWriter(bool keep_existing_data, bool auto_close, CreateFileWriterCallback callback) {
  GetForwardingInterface()->CreateFileWriter(std::move(keep_existing_data), std::move(auto_close), std::move(callback));
}
void FileSystemAccessFileHandleInterceptorForTesting::Rename(const WTF::String& new_entry_name, RenameCallback callback) {
  GetForwardingInterface()->Rename(std::move(new_entry_name), std::move(callback));
}
void FileSystemAccessFileHandleInterceptorForTesting::Move(::mojo::PendingRemote<::blink::mojom::blink::FileSystemAccessTransferToken> destination_directory, const WTF::String& new_entry_name, MoveCallback callback) {
  GetForwardingInterface()->Move(std::move(destination_directory), std::move(new_entry_name), std::move(callback));
}
void FileSystemAccessFileHandleInterceptorForTesting::Remove(RemoveCallback callback) {
  GetForwardingInterface()->Remove(std::move(callback));
}
void FileSystemAccessFileHandleInterceptorForTesting::OpenAccessHandle(OpenAccessHandleCallback callback) {
  GetForwardingInterface()->OpenAccessHandle(std::move(callback));
}
void FileSystemAccessFileHandleInterceptorForTesting::IsSameEntry(::mojo::PendingRemote<::blink::mojom::blink::FileSystemAccessTransferToken> other, IsSameEntryCallback callback) {
  GetForwardingInterface()->IsSameEntry(std::move(other), std::move(callback));
}
void FileSystemAccessFileHandleInterceptorForTesting::Transfer(::mojo::PendingReceiver<::blink::mojom::blink::FileSystemAccessTransferToken> token) {
  GetForwardingInterface()->Transfer(std::move(token));
}
FileSystemAccessFileHandleAsyncWaiter::FileSystemAccessFileHandleAsyncWaiter(
    FileSystemAccessFileHandle* proxy) : proxy_(proxy) {}

FileSystemAccessFileHandleAsyncWaiter::~FileSystemAccessFileHandleAsyncWaiter() = default;

void FileSystemAccessFileHandleAsyncWaiter::GetPermissionStatus(
    bool writable, ::blink::mojom::blink::PermissionStatus* out_status) {
  base::RunLoop loop;
  proxy_->GetPermissionStatus(std::move(writable),
      base::BindOnce(
          [](base::RunLoop* loop,
             ::blink::mojom::blink::PermissionStatus* out_status
,
             ::blink::mojom::blink::PermissionStatus status) {*out_status = std::move(status);
            loop->Quit();
          },
          &loop,
          out_status));
  loop.Run();
}
void FileSystemAccessFileHandleAsyncWaiter::RequestPermission(
    bool writable, ::blink::mojom::blink::FileSystemAccessErrorPtr* out_result, ::blink::mojom::blink::PermissionStatus* out_status) {
  base::RunLoop loop;
  proxy_->RequestPermission(std::move(writable),
      base::BindOnce(
          [](base::RunLoop* loop,
             ::blink::mojom::blink::FileSystemAccessErrorPtr* out_result
,
             ::blink::mojom::blink::PermissionStatus* out_status
,
             ::blink::mojom::blink::FileSystemAccessErrorPtr result,
             ::blink::mojom::blink::PermissionStatus status) {*out_result = std::move(result);*out_status = std::move(status);
            loop->Quit();
          },
          &loop,
          out_result,
          out_status));
  loop.Run();
}
void FileSystemAccessFileHandleAsyncWaiter::AsBlob(
    ::blink::mojom::blink::FileSystemAccessErrorPtr* out_result, ::base::File::Info* out_info, ::scoped_refptr<::blink::BlobDataHandle>* out_blob) {
  base::RunLoop loop;
  proxy_->AsBlob(
      base::BindOnce(
          [](base::RunLoop* loop,
             ::blink::mojom::blink::FileSystemAccessErrorPtr* out_result
,
             ::base::File::Info* out_info
,
             ::scoped_refptr<::blink::BlobDataHandle>* out_blob
,
             ::blink::mojom::blink::FileSystemAccessErrorPtr result,
             const ::base::File::Info& info,
             const ::scoped_refptr<::blink::BlobDataHandle>& blob) {*out_result = std::move(result);*out_info = std::move(info);*out_blob = std::move(blob);
            loop->Quit();
          },
          &loop,
          out_result,
          out_info,
          out_blob));
  loop.Run();
}
void FileSystemAccessFileHandleAsyncWaiter::CreateFileWriter(
    bool keep_existing_data, bool auto_close, ::blink::mojom::blink::FileSystemAccessErrorPtr* out_result, ::mojo::PendingRemote<::blink::mojom::blink::FileSystemAccessFileWriter>* out_writer) {
  base::RunLoop loop;
  proxy_->CreateFileWriter(std::move(keep_existing_data),std::move(auto_close),
      base::BindOnce(
          [](base::RunLoop* loop,
             ::blink::mojom::blink::FileSystemAccessErrorPtr* out_result
,
             ::mojo::PendingRemote<::blink::mojom::blink::FileSystemAccessFileWriter>* out_writer
,
             ::blink::mojom::blink::FileSystemAccessErrorPtr result,
             ::mojo::PendingRemote<::blink::mojom::blink::FileSystemAccessFileWriter> writer) {*out_result = std::move(result);*out_writer = std::move(writer);
            loop->Quit();
          },
          &loop,
          out_result,
          out_writer));
  loop.Run();
}
void FileSystemAccessFileHandleAsyncWaiter::Rename(
    const WTF::String& new_entry_name, ::blink::mojom::blink::FileSystemAccessErrorPtr* out_result) {
  base::RunLoop loop;
  proxy_->Rename(std::move(new_entry_name),
      base::BindOnce(
          [](base::RunLoop* loop,
             ::blink::mojom::blink::FileSystemAccessErrorPtr* out_result
,
             ::blink::mojom::blink::FileSystemAccessErrorPtr result) {*out_result = std::move(result);
            loop->Quit();
          },
          &loop,
          out_result));
  loop.Run();
}
void FileSystemAccessFileHandleAsyncWaiter::Move(
    ::mojo::PendingRemote<::blink::mojom::blink::FileSystemAccessTransferToken> destination_directory, const WTF::String& new_entry_name, ::blink::mojom::blink::FileSystemAccessErrorPtr* out_result) {
  base::RunLoop loop;
  proxy_->Move(std::move(destination_directory),std::move(new_entry_name),
      base::BindOnce(
          [](base::RunLoop* loop,
             ::blink::mojom::blink::FileSystemAccessErrorPtr* out_result
,
             ::blink::mojom::blink::FileSystemAccessErrorPtr result) {*out_result = std::move(result);
            loop->Quit();
          },
          &loop,
          out_result));
  loop.Run();
}
void FileSystemAccessFileHandleAsyncWaiter::Remove(
    ::blink::mojom::blink::FileSystemAccessErrorPtr* out_result) {
  base::RunLoop loop;
  proxy_->Remove(
      base::BindOnce(
          [](base::RunLoop* loop,
             ::blink::mojom::blink::FileSystemAccessErrorPtr* out_result
,
             ::blink::mojom::blink::FileSystemAccessErrorPtr result) {*out_result = std::move(result);
            loop->Quit();
          },
          &loop,
          out_result));
  loop.Run();
}
void FileSystemAccessFileHandleAsyncWaiter::OpenAccessHandle(
    ::blink::mojom::blink::FileSystemAccessErrorPtr* out_result, FileSystemAccessAccessHandleFilePtr* out_file, ::mojo::PendingRemote<::blink::mojom::blink::FileSystemAccessAccessHandleHost>* out_access_handle_host) {
  base::RunLoop loop;
  proxy_->OpenAccessHandle(
      base::BindOnce(
          [](base::RunLoop* loop,
             ::blink::mojom::blink::FileSystemAccessErrorPtr* out_result
,
             FileSystemAccessAccessHandleFilePtr* out_file
,
             ::mojo::PendingRemote<::blink::mojom::blink::FileSystemAccessAccessHandleHost>* out_access_handle_host
,
             ::blink::mojom::blink::FileSystemAccessErrorPtr result,
             FileSystemAccessAccessHandleFilePtr file,
             ::mojo::PendingRemote<::blink::mojom::blink::FileSystemAccessAccessHandleHost> access_handle_host) {*out_result = std::move(result);*out_file = std::move(file);*out_access_handle_host = std::move(access_handle_host);
            loop->Quit();
          },
          &loop,
          out_result,
          out_file,
          out_access_handle_host));
  loop.Run();
}
void FileSystemAccessFileHandleAsyncWaiter::IsSameEntry(
    ::mojo::PendingRemote<::blink::mojom::blink::FileSystemAccessTransferToken> other, ::blink::mojom::blink::FileSystemAccessErrorPtr* out_result, bool* out_is_same) {
  base::RunLoop loop;
  proxy_->IsSameEntry(std::move(other),
      base::BindOnce(
          [](base::RunLoop* loop,
             ::blink::mojom::blink::FileSystemAccessErrorPtr* out_result
,
             bool* out_is_same
,
             ::blink::mojom::blink::FileSystemAccessErrorPtr result,
             bool is_same) {*out_result = std::move(result);*out_is_same = std::move(is_same);
            loop->Quit();
          },
          &loop,
          out_result,
          out_is_same));
  loop.Run();
}





}  // namespace blink
}  // namespace mojom
}  // namespace blink


#if defined(__clang__)
#pragma clang diagnostic pop
#endif