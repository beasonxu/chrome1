// third_party/blink/public/mojom/interest_group/interest_group_types.mojom-shared.h is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2016 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef THIRD_PARTY_BLINK_PUBLIC_MOJOM_INTEREST_GROUP_INTEREST_GROUP_TYPES_MOJOM_SHARED_H_
#define THIRD_PARTY_BLINK_PUBLIC_MOJOM_INTEREST_GROUP_INTEREST_GROUP_TYPES_MOJOM_SHARED_H_

#include <stdint.h>

#include <functional>
#include <iosfwd>
#include <type_traits>
#include <utility>
#include "mojo/public/cpp/bindings/array_data_view.h"
#include "mojo/public/cpp/bindings/enum_traits.h"
#include "mojo/public/cpp/bindings/interface_data_view.h"
#include "mojo/public/cpp/bindings/lib/bindings_internal.h"
#include "mojo/public/cpp/bindings/lib/serialization.h"
#include "mojo/public/cpp/bindings/map_data_view.h"
#include "mojo/public/cpp/bindings/string_data_view.h"

#include "third_party/perfetto/include/perfetto/tracing/traced_value_forward.h"

#include "third_party/blink/public/mojom/interest_group/interest_group_types.mojom-shared-internal.h"
#include "mojo/public/mojom/base/time.mojom-shared.h"
#include "url/mojom/origin.mojom-shared.h"
#include "url/mojom/url.mojom-shared.h"



#include "base/component_export.h"




namespace blink {
namespace mojom {
class InterestGroupAdDataView;

class InterestGroupDataView;

class AuctionAdConfigNonSharedParamsDataView;

class AuctionAdConfigDataView;



}  // namespace mojom
}  // namespace blink

namespace mojo {
namespace internal {

template <>
struct MojomTypeTraits<::blink::mojom::InterestGroupAdDataView> {
  using Data = ::blink::mojom::internal::InterestGroupAd_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::blink::mojom::InterestGroupDataView> {
  using Data = ::blink::mojom::internal::InterestGroup_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::blink::mojom::AuctionAdConfigNonSharedParamsDataView> {
  using Data = ::blink::mojom::internal::AuctionAdConfigNonSharedParams_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::blink::mojom::AuctionAdConfigDataView> {
  using Data = ::blink::mojom::internal::AuctionAdConfig_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

}  // namespace internal
}  // namespace mojo


namespace blink {
namespace mojom {


enum class InterestGroup_ExecutionMode : int32_t {
  
  kCompatibilityMode = 0,
  
  kGroupedByOriginMode = 1,
  
  kFrozenContext = 2,
  kMinValue = 0,
  kMaxValue = 2,
};

COMPONENT_EXPORT(MOJOM_SHARED_BLINK_COMMON_EXPORT) std::ostream& operator<<(std::ostream& os, InterestGroup_ExecutionMode value);
inline bool IsKnownEnumValue(InterestGroup_ExecutionMode value) {
  return internal::InterestGroup_ExecutionMode_Data::IsKnownValue(
      static_cast<int32_t>(value));
}


class InterestGroupAdDataView {
 public:
  InterestGroupAdDataView() = default;

  InterestGroupAdDataView(
      internal::InterestGroupAd_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  inline void GetRenderUrlDataView(
      ::url::mojom::UrlDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadRenderUrl(UserType* output) {
    
    auto* pointer = data_->render_url.Get();
    return mojo::internal::Deserialize<::url::mojom::UrlDataView>(
        pointer, output, message_);
  }
  inline void GetMetadataDataView(
      mojo::StringDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadMetadata(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        mojo::StringDataView, UserType>(),
    "Attempting to read the optional `metadata` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadMetadata` instead "
    "of `ReadMetadata if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->metadata.Get();
    return mojo::internal::Deserialize<mojo::StringDataView>(
        pointer, output, message_);
  }
 private:
  internal::InterestGroupAd_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class InterestGroupDataView {
 public:
  InterestGroupDataView() = default;

  InterestGroupDataView(
      internal::InterestGroup_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  inline void GetExpiryDataView(
      ::mojo_base::mojom::TimeDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadExpiry(UserType* output) {
    
    auto* pointer = data_->expiry.Get();
    return mojo::internal::Deserialize<::mojo_base::mojom::TimeDataView>(
        pointer, output, message_);
  }
  inline void GetOwnerDataView(
      ::url::mojom::OriginDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadOwner(UserType* output) {
    
    auto* pointer = data_->owner.Get();
    return mojo::internal::Deserialize<::url::mojom::OriginDataView>(
        pointer, output, message_);
  }
  inline void GetNameDataView(
      mojo::StringDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadName(UserType* output) {
    
    auto* pointer = data_->name.Get();
    return mojo::internal::Deserialize<mojo::StringDataView>(
        pointer, output, message_);
  }
  double priority() const {
    return data_->priority;
  }
  template <typename UserType>
  [[nodiscard]] bool ReadExecutionMode(UserType* output) const {
    auto data_value = data_->execution_mode;
    return mojo::internal::Deserialize<::blink::mojom::InterestGroup_ExecutionMode>(
        data_value, output);
  }
  InterestGroup_ExecutionMode execution_mode() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::blink::mojom::InterestGroup_ExecutionMode>(data_->execution_mode));
  }
  inline void GetBiddingUrlDataView(
      ::url::mojom::UrlDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadBiddingUrl(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::url::mojom::UrlDataView, UserType>(),
    "Attempting to read the optional `bidding_url` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadBiddingUrl` instead "
    "of `ReadBiddingUrl if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->bidding_url.Get();
    return mojo::internal::Deserialize<::url::mojom::UrlDataView>(
        pointer, output, message_);
  }
  inline void GetBiddingWasmHelperUrlDataView(
      ::url::mojom::UrlDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadBiddingWasmHelperUrl(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::url::mojom::UrlDataView, UserType>(),
    "Attempting to read the optional `bidding_wasm_helper_url` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadBiddingWasmHelperUrl` instead "
    "of `ReadBiddingWasmHelperUrl if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->bidding_wasm_helper_url.Get();
    return mojo::internal::Deserialize<::url::mojom::UrlDataView>(
        pointer, output, message_);
  }
  inline void GetDailyUpdateUrlDataView(
      ::url::mojom::UrlDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadDailyUpdateUrl(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::url::mojom::UrlDataView, UserType>(),
    "Attempting to read the optional `daily_update_url` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadDailyUpdateUrl` instead "
    "of `ReadDailyUpdateUrl if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->daily_update_url.Get();
    return mojo::internal::Deserialize<::url::mojom::UrlDataView>(
        pointer, output, message_);
  }
  inline void GetTrustedBiddingSignalsUrlDataView(
      ::url::mojom::UrlDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadTrustedBiddingSignalsUrl(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::url::mojom::UrlDataView, UserType>(),
    "Attempting to read the optional `trusted_bidding_signals_url` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadTrustedBiddingSignalsUrl` instead "
    "of `ReadTrustedBiddingSignalsUrl if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->trusted_bidding_signals_url.Get();
    return mojo::internal::Deserialize<::url::mojom::UrlDataView>(
        pointer, output, message_);
  }
  inline void GetTrustedBiddingSignalsKeysDataView(
      mojo::ArrayDataView<mojo::StringDataView>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadTrustedBiddingSignalsKeys(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        mojo::ArrayDataView<mojo::StringDataView>, UserType>(),
    "Attempting to read the optional `trusted_bidding_signals_keys` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadTrustedBiddingSignalsKeys` instead "
    "of `ReadTrustedBiddingSignalsKeys if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->trusted_bidding_signals_keys.Get();
    return mojo::internal::Deserialize<mojo::ArrayDataView<mojo::StringDataView>>(
        pointer, output, message_);
  }
  inline void GetUserBiddingSignalsDataView(
      mojo::StringDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadUserBiddingSignals(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        mojo::StringDataView, UserType>(),
    "Attempting to read the optional `user_bidding_signals` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadUserBiddingSignals` instead "
    "of `ReadUserBiddingSignals if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->user_bidding_signals.Get();
    return mojo::internal::Deserialize<mojo::StringDataView>(
        pointer, output, message_);
  }
  inline void GetAdsDataView(
      mojo::ArrayDataView<InterestGroupAdDataView>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadAds(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        mojo::ArrayDataView<::blink::mojom::InterestGroupAdDataView>, UserType>(),
    "Attempting to read the optional `ads` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadAds` instead "
    "of `ReadAds if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->ads.Get();
    return mojo::internal::Deserialize<mojo::ArrayDataView<::blink::mojom::InterestGroupAdDataView>>(
        pointer, output, message_);
  }
  inline void GetAdComponentsDataView(
      mojo::ArrayDataView<InterestGroupAdDataView>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadAdComponents(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        mojo::ArrayDataView<::blink::mojom::InterestGroupAdDataView>, UserType>(),
    "Attempting to read the optional `ad_components` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadAdComponents` instead "
    "of `ReadAdComponents if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->ad_components.Get();
    return mojo::internal::Deserialize<mojo::ArrayDataView<::blink::mojom::InterestGroupAdDataView>>(
        pointer, output, message_);
  }
 private:
  internal::InterestGroup_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class AuctionAdConfigNonSharedParamsDataView {
 public:
  AuctionAdConfigNonSharedParamsDataView() = default;

  AuctionAdConfigNonSharedParamsDataView(
      internal::AuctionAdConfigNonSharedParams_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  inline void GetInterestGroupBuyersDataView(
      mojo::ArrayDataView<::url::mojom::OriginDataView>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadInterestGroupBuyers(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        mojo::ArrayDataView<::url::mojom::OriginDataView>, UserType>(),
    "Attempting to read the optional `interest_group_buyers` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadInterestGroupBuyers` instead "
    "of `ReadInterestGroupBuyers if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->interest_group_buyers.Get();
    return mojo::internal::Deserialize<mojo::ArrayDataView<::url::mojom::OriginDataView>>(
        pointer, output, message_);
  }
  inline void GetAuctionSignalsDataView(
      mojo::StringDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadAuctionSignals(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        mojo::StringDataView, UserType>(),
    "Attempting to read the optional `auction_signals` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadAuctionSignals` instead "
    "of `ReadAuctionSignals if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->auction_signals.Get();
    return mojo::internal::Deserialize<mojo::StringDataView>(
        pointer, output, message_);
  }
  inline void GetSellerSignalsDataView(
      mojo::StringDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadSellerSignals(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        mojo::StringDataView, UserType>(),
    "Attempting to read the optional `seller_signals` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadSellerSignals` instead "
    "of `ReadSellerSignals if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->seller_signals.Get();
    return mojo::internal::Deserialize<mojo::StringDataView>(
        pointer, output, message_);
  }
  inline void GetSellerTimeoutDataView(
      ::mojo_base::mojom::TimeDeltaDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadSellerTimeout(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::mojo_base::mojom::TimeDeltaDataView, UserType>(),
    "Attempting to read the optional `seller_timeout` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadSellerTimeout` instead "
    "of `ReadSellerTimeout if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->seller_timeout.Get();
    return mojo::internal::Deserialize<::mojo_base::mojom::TimeDeltaDataView>(
        pointer, output, message_);
  }
  inline void GetPerBuyerSignalsDataView(
      mojo::MapDataView<::url::mojom::OriginDataView, mojo::StringDataView>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadPerBuyerSignals(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        mojo::MapDataView<::url::mojom::OriginDataView, mojo::StringDataView>, UserType>(),
    "Attempting to read the optional `per_buyer_signals` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadPerBuyerSignals` instead "
    "of `ReadPerBuyerSignals if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->per_buyer_signals.Get();
    return mojo::internal::Deserialize<mojo::MapDataView<::url::mojom::OriginDataView, mojo::StringDataView>>(
        pointer, output, message_);
  }
  inline void GetPerBuyerTimeoutsDataView(
      mojo::MapDataView<::url::mojom::OriginDataView, ::mojo_base::mojom::TimeDeltaDataView>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadPerBuyerTimeouts(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        mojo::MapDataView<::url::mojom::OriginDataView, ::mojo_base::mojom::TimeDeltaDataView>, UserType>(),
    "Attempting to read the optional `per_buyer_timeouts` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadPerBuyerTimeouts` instead "
    "of `ReadPerBuyerTimeouts if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->per_buyer_timeouts.Get();
    return mojo::internal::Deserialize<mojo::MapDataView<::url::mojom::OriginDataView, ::mojo_base::mojom::TimeDeltaDataView>>(
        pointer, output, message_);
  }
  inline void GetAllBuyersTimeoutDataView(
      ::mojo_base::mojom::TimeDeltaDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadAllBuyersTimeout(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::mojo_base::mojom::TimeDeltaDataView, UserType>(),
    "Attempting to read the optional `all_buyers_timeout` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadAllBuyersTimeout` instead "
    "of `ReadAllBuyersTimeout if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->all_buyers_timeout.Get();
    return mojo::internal::Deserialize<::mojo_base::mojom::TimeDeltaDataView>(
        pointer, output, message_);
  }
  inline void GetPerBuyerGroupLimitsDataView(
      mojo::MapDataView<::url::mojom::OriginDataView, uint16_t>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadPerBuyerGroupLimits(UserType* output) {
    
    auto* pointer = data_->per_buyer_group_limits.Get();
    return mojo::internal::Deserialize<mojo::MapDataView<::url::mojom::OriginDataView, uint16_t>>(
        pointer, output, message_);
  }
  uint16_t all_buyers_group_limit() const {
    return data_->all_buyers_group_limit;
  }
  inline void GetComponentAuctionsDataView(
      mojo::ArrayDataView<AuctionAdConfigDataView>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadComponentAuctions(UserType* output) {
    
    auto* pointer = data_->component_auctions.Get();
    return mojo::internal::Deserialize<mojo::ArrayDataView<::blink::mojom::AuctionAdConfigDataView>>(
        pointer, output, message_);
  }
 private:
  internal::AuctionAdConfigNonSharedParams_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class AuctionAdConfigDataView {
 public:
  AuctionAdConfigDataView() = default;

  AuctionAdConfigDataView(
      internal::AuctionAdConfig_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  inline void GetSellerDataView(
      ::url::mojom::OriginDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadSeller(UserType* output) {
    
    auto* pointer = data_->seller.Get();
    return mojo::internal::Deserialize<::url::mojom::OriginDataView>(
        pointer, output, message_);
  }
  inline void GetDecisionLogicUrlDataView(
      ::url::mojom::UrlDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadDecisionLogicUrl(UserType* output) {
    
    auto* pointer = data_->decision_logic_url.Get();
    return mojo::internal::Deserialize<::url::mojom::UrlDataView>(
        pointer, output, message_);
  }
  inline void GetTrustedScoringSignalsUrlDataView(
      ::url::mojom::UrlDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadTrustedScoringSignalsUrl(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::url::mojom::UrlDataView, UserType>(),
    "Attempting to read the optional `trusted_scoring_signals_url` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadTrustedScoringSignalsUrl` instead "
    "of `ReadTrustedScoringSignalsUrl if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->trusted_scoring_signals_url.Get();
    return mojo::internal::Deserialize<::url::mojom::UrlDataView>(
        pointer, output, message_);
  }
  inline void GetAuctionAdConfigNonSharedParamsDataView(
      AuctionAdConfigNonSharedParamsDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadAuctionAdConfigNonSharedParams(UserType* output) {
    
    auto* pointer = data_->auction_ad_config_non_shared_params.Get();
    return mojo::internal::Deserialize<::blink::mojom::AuctionAdConfigNonSharedParamsDataView>(
        pointer, output, message_);
  }
  bool has_seller_experiment_group_id() const {
    return data_->has_seller_experiment_group_id;
  }
  uint16_t seller_experiment_group_id() const {
    return data_->seller_experiment_group_id;
  }
  bool has_all_buyer_experiment_group_id() const {
    return data_->has_all_buyer_experiment_group_id;
  }
  int16_t all_buyer_experiment_group_id() const {
    return data_->all_buyer_experiment_group_id;
  }
  inline void GetPerBuyerExperimentGroupIdsDataView(
      mojo::MapDataView<::url::mojom::OriginDataView, uint16_t>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadPerBuyerExperimentGroupIds(UserType* output) {
    
    auto* pointer = data_->per_buyer_experiment_group_ids.Get();
    return mojo::internal::Deserialize<mojo::MapDataView<::url::mojom::OriginDataView, uint16_t>>(
        pointer, output, message_);
  }
 private:
  internal::AuctionAdConfig_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



}  // namespace mojom
}  // namespace blink

namespace std {

template <>
struct hash<::blink::mojom::InterestGroup_ExecutionMode>
    : public mojo::internal::EnumHashImpl<::blink::mojom::InterestGroup_ExecutionMode> {};

}  // namespace std

namespace mojo {


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::blink::mojom::InterestGroup_ExecutionMode, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::blink::mojom::InterestGroup_ExecutionMode, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::blink::mojom::InterestGroup_ExecutionMode>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::blink::mojom::InterestGroupAdDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::blink::mojom::InterestGroupAdDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::blink::mojom::internal::InterestGroupAd_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    decltype(Traits::render_url(input)) in_render_url = Traits::render_url(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->render_url)::BaseType> render_url_fragment(
            fragment.message());
    mojo::internal::Serialize<::url::mojom::UrlDataView>(
        in_render_url, render_url_fragment);
    fragment->render_url.Set(
        render_url_fragment.is_null() ? nullptr : render_url_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->render_url.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null render_url in InterestGroupAd struct");
    decltype(Traits::metadata(input)) in_metadata = Traits::metadata(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->metadata)::BaseType> metadata_fragment(
            fragment.message());
    mojo::internal::Serialize<mojo::StringDataView>(
        in_metadata, metadata_fragment);
    fragment->metadata.Set(
        metadata_fragment.is_null() ? nullptr : metadata_fragment.data());
  }

  static bool Deserialize(::blink::mojom::internal::InterestGroupAd_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::blink::mojom::InterestGroupAdDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::blink::mojom::InterestGroupDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::blink::mojom::InterestGroupDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::blink::mojom::internal::InterestGroup_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    decltype(Traits::expiry(input)) in_expiry = Traits::expiry(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->expiry)::BaseType> expiry_fragment(
            fragment.message());
    mojo::internal::Serialize<::mojo_base::mojom::TimeDataView>(
        in_expiry, expiry_fragment);
    fragment->expiry.Set(
        expiry_fragment.is_null() ? nullptr : expiry_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->expiry.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null expiry in InterestGroup struct");
    decltype(Traits::owner(input)) in_owner = Traits::owner(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->owner)::BaseType> owner_fragment(
            fragment.message());
    mojo::internal::Serialize<::url::mojom::OriginDataView>(
        in_owner, owner_fragment);
    fragment->owner.Set(
        owner_fragment.is_null() ? nullptr : owner_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->owner.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null owner in InterestGroup struct");
    decltype(Traits::name(input)) in_name = Traits::name(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->name)::BaseType> name_fragment(
            fragment.message());
    mojo::internal::Serialize<mojo::StringDataView>(
        in_name, name_fragment);
    fragment->name.Set(
        name_fragment.is_null() ? nullptr : name_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->name.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null name in InterestGroup struct");
    fragment->priority = Traits::priority(input);
    mojo::internal::Serialize<::blink::mojom::InterestGroup_ExecutionMode>(
        Traits::execution_mode(input), &fragment->execution_mode);
    decltype(Traits::bidding_url(input)) in_bidding_url = Traits::bidding_url(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->bidding_url)::BaseType> bidding_url_fragment(
            fragment.message());
    mojo::internal::Serialize<::url::mojom::UrlDataView>(
        in_bidding_url, bidding_url_fragment);
    fragment->bidding_url.Set(
        bidding_url_fragment.is_null() ? nullptr : bidding_url_fragment.data());
    decltype(Traits::bidding_wasm_helper_url(input)) in_bidding_wasm_helper_url = Traits::bidding_wasm_helper_url(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->bidding_wasm_helper_url)::BaseType> bidding_wasm_helper_url_fragment(
            fragment.message());
    mojo::internal::Serialize<::url::mojom::UrlDataView>(
        in_bidding_wasm_helper_url, bidding_wasm_helper_url_fragment);
    fragment->bidding_wasm_helper_url.Set(
        bidding_wasm_helper_url_fragment.is_null() ? nullptr : bidding_wasm_helper_url_fragment.data());
    decltype(Traits::daily_update_url(input)) in_daily_update_url = Traits::daily_update_url(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->daily_update_url)::BaseType> daily_update_url_fragment(
            fragment.message());
    mojo::internal::Serialize<::url::mojom::UrlDataView>(
        in_daily_update_url, daily_update_url_fragment);
    fragment->daily_update_url.Set(
        daily_update_url_fragment.is_null() ? nullptr : daily_update_url_fragment.data());
    decltype(Traits::trusted_bidding_signals_url(input)) in_trusted_bidding_signals_url = Traits::trusted_bidding_signals_url(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->trusted_bidding_signals_url)::BaseType> trusted_bidding_signals_url_fragment(
            fragment.message());
    mojo::internal::Serialize<::url::mojom::UrlDataView>(
        in_trusted_bidding_signals_url, trusted_bidding_signals_url_fragment);
    fragment->trusted_bidding_signals_url.Set(
        trusted_bidding_signals_url_fragment.is_null() ? nullptr : trusted_bidding_signals_url_fragment.data());
    decltype(Traits::trusted_bidding_signals_keys(input)) in_trusted_bidding_signals_keys = Traits::trusted_bidding_signals_keys(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->trusted_bidding_signals_keys)::BaseType>
        trusted_bidding_signals_keys_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams trusted_bidding_signals_keys_validate_params(
        0, false, new mojo::internal::ContainerValidateParams(0, false, nullptr));
    mojo::internal::Serialize<mojo::ArrayDataView<mojo::StringDataView>>(
        in_trusted_bidding_signals_keys, trusted_bidding_signals_keys_fragment, &trusted_bidding_signals_keys_validate_params);
    fragment->trusted_bidding_signals_keys.Set(
        trusted_bidding_signals_keys_fragment.is_null() ? nullptr : trusted_bidding_signals_keys_fragment.data());
    decltype(Traits::user_bidding_signals(input)) in_user_bidding_signals = Traits::user_bidding_signals(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->user_bidding_signals)::BaseType> user_bidding_signals_fragment(
            fragment.message());
    mojo::internal::Serialize<mojo::StringDataView>(
        in_user_bidding_signals, user_bidding_signals_fragment);
    fragment->user_bidding_signals.Set(
        user_bidding_signals_fragment.is_null() ? nullptr : user_bidding_signals_fragment.data());
    decltype(Traits::ads(input)) in_ads = Traits::ads(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->ads)::BaseType>
        ads_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams ads_validate_params(
        0, false, nullptr);
    mojo::internal::Serialize<mojo::ArrayDataView<::blink::mojom::InterestGroupAdDataView>>(
        in_ads, ads_fragment, &ads_validate_params);
    fragment->ads.Set(
        ads_fragment.is_null() ? nullptr : ads_fragment.data());
    decltype(Traits::ad_components(input)) in_ad_components = Traits::ad_components(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->ad_components)::BaseType>
        ad_components_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams ad_components_validate_params(
        0, false, nullptr);
    mojo::internal::Serialize<mojo::ArrayDataView<::blink::mojom::InterestGroupAdDataView>>(
        in_ad_components, ad_components_fragment, &ad_components_validate_params);
    fragment->ad_components.Set(
        ad_components_fragment.is_null() ? nullptr : ad_components_fragment.data());
  }

  static bool Deserialize(::blink::mojom::internal::InterestGroup_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::blink::mojom::InterestGroupDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::blink::mojom::AuctionAdConfigNonSharedParamsDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::blink::mojom::AuctionAdConfigNonSharedParamsDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::blink::mojom::internal::AuctionAdConfigNonSharedParams_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    decltype(Traits::interest_group_buyers(input)) in_interest_group_buyers = Traits::interest_group_buyers(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->interest_group_buyers)::BaseType>
        interest_group_buyers_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams interest_group_buyers_validate_params(
        0, false, nullptr);
    mojo::internal::Serialize<mojo::ArrayDataView<::url::mojom::OriginDataView>>(
        in_interest_group_buyers, interest_group_buyers_fragment, &interest_group_buyers_validate_params);
    fragment->interest_group_buyers.Set(
        interest_group_buyers_fragment.is_null() ? nullptr : interest_group_buyers_fragment.data());
    decltype(Traits::auction_signals(input)) in_auction_signals = Traits::auction_signals(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->auction_signals)::BaseType> auction_signals_fragment(
            fragment.message());
    mojo::internal::Serialize<mojo::StringDataView>(
        in_auction_signals, auction_signals_fragment);
    fragment->auction_signals.Set(
        auction_signals_fragment.is_null() ? nullptr : auction_signals_fragment.data());
    decltype(Traits::seller_signals(input)) in_seller_signals = Traits::seller_signals(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->seller_signals)::BaseType> seller_signals_fragment(
            fragment.message());
    mojo::internal::Serialize<mojo::StringDataView>(
        in_seller_signals, seller_signals_fragment);
    fragment->seller_signals.Set(
        seller_signals_fragment.is_null() ? nullptr : seller_signals_fragment.data());
    decltype(Traits::seller_timeout(input)) in_seller_timeout = Traits::seller_timeout(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->seller_timeout)::BaseType> seller_timeout_fragment(
            fragment.message());
    mojo::internal::Serialize<::mojo_base::mojom::TimeDeltaDataView>(
        in_seller_timeout, seller_timeout_fragment);
    fragment->seller_timeout.Set(
        seller_timeout_fragment.is_null() ? nullptr : seller_timeout_fragment.data());
    decltype(Traits::per_buyer_signals(input)) in_per_buyer_signals = Traits::per_buyer_signals(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->per_buyer_signals)::BaseType>
        per_buyer_signals_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams per_buyer_signals_validate_params(
        new mojo::internal::ContainerValidateParams(0, false, nullptr), new mojo::internal::ContainerValidateParams(0, false, new mojo::internal::ContainerValidateParams(0, false, nullptr)));
    mojo::internal::Serialize<mojo::MapDataView<::url::mojom::OriginDataView, mojo::StringDataView>>(
        in_per_buyer_signals, per_buyer_signals_fragment, &per_buyer_signals_validate_params);
    fragment->per_buyer_signals.Set(
        per_buyer_signals_fragment.is_null() ? nullptr : per_buyer_signals_fragment.data());
    decltype(Traits::per_buyer_timeouts(input)) in_per_buyer_timeouts = Traits::per_buyer_timeouts(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->per_buyer_timeouts)::BaseType>
        per_buyer_timeouts_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams per_buyer_timeouts_validate_params(
        new mojo::internal::ContainerValidateParams(0, false, nullptr), new mojo::internal::ContainerValidateParams(0, false, nullptr));
    mojo::internal::Serialize<mojo::MapDataView<::url::mojom::OriginDataView, ::mojo_base::mojom::TimeDeltaDataView>>(
        in_per_buyer_timeouts, per_buyer_timeouts_fragment, &per_buyer_timeouts_validate_params);
    fragment->per_buyer_timeouts.Set(
        per_buyer_timeouts_fragment.is_null() ? nullptr : per_buyer_timeouts_fragment.data());
    decltype(Traits::all_buyers_timeout(input)) in_all_buyers_timeout = Traits::all_buyers_timeout(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->all_buyers_timeout)::BaseType> all_buyers_timeout_fragment(
            fragment.message());
    mojo::internal::Serialize<::mojo_base::mojom::TimeDeltaDataView>(
        in_all_buyers_timeout, all_buyers_timeout_fragment);
    fragment->all_buyers_timeout.Set(
        all_buyers_timeout_fragment.is_null() ? nullptr : all_buyers_timeout_fragment.data());
    decltype(Traits::per_buyer_group_limits(input)) in_per_buyer_group_limits = Traits::per_buyer_group_limits(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->per_buyer_group_limits)::BaseType>
        per_buyer_group_limits_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams per_buyer_group_limits_validate_params(
        new mojo::internal::ContainerValidateParams(0, false, nullptr), new mojo::internal::ContainerValidateParams(0, false, nullptr));
    mojo::internal::Serialize<mojo::MapDataView<::url::mojom::OriginDataView, uint16_t>>(
        in_per_buyer_group_limits, per_buyer_group_limits_fragment, &per_buyer_group_limits_validate_params);
    fragment->per_buyer_group_limits.Set(
        per_buyer_group_limits_fragment.is_null() ? nullptr : per_buyer_group_limits_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->per_buyer_group_limits.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null per_buyer_group_limits in AuctionAdConfigNonSharedParams struct");
    fragment->all_buyers_group_limit = Traits::all_buyers_group_limit(input);
    decltype(Traits::component_auctions(input)) in_component_auctions = Traits::component_auctions(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->component_auctions)::BaseType>
        component_auctions_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams component_auctions_validate_params(
        0, false, nullptr);
    mojo::internal::Serialize<mojo::ArrayDataView<::blink::mojom::AuctionAdConfigDataView>>(
        in_component_auctions, component_auctions_fragment, &component_auctions_validate_params);
    fragment->component_auctions.Set(
        component_auctions_fragment.is_null() ? nullptr : component_auctions_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->component_auctions.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null component_auctions in AuctionAdConfigNonSharedParams struct");
  }

  static bool Deserialize(::blink::mojom::internal::AuctionAdConfigNonSharedParams_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::blink::mojom::AuctionAdConfigNonSharedParamsDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::blink::mojom::AuctionAdConfigDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::blink::mojom::AuctionAdConfigDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::blink::mojom::internal::AuctionAdConfig_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    decltype(Traits::seller(input)) in_seller = Traits::seller(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->seller)::BaseType> seller_fragment(
            fragment.message());
    mojo::internal::Serialize<::url::mojom::OriginDataView>(
        in_seller, seller_fragment);
    fragment->seller.Set(
        seller_fragment.is_null() ? nullptr : seller_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->seller.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null seller in AuctionAdConfig struct");
    decltype(Traits::decision_logic_url(input)) in_decision_logic_url = Traits::decision_logic_url(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->decision_logic_url)::BaseType> decision_logic_url_fragment(
            fragment.message());
    mojo::internal::Serialize<::url::mojom::UrlDataView>(
        in_decision_logic_url, decision_logic_url_fragment);
    fragment->decision_logic_url.Set(
        decision_logic_url_fragment.is_null() ? nullptr : decision_logic_url_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->decision_logic_url.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null decision_logic_url in AuctionAdConfig struct");
    decltype(Traits::trusted_scoring_signals_url(input)) in_trusted_scoring_signals_url = Traits::trusted_scoring_signals_url(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->trusted_scoring_signals_url)::BaseType> trusted_scoring_signals_url_fragment(
            fragment.message());
    mojo::internal::Serialize<::url::mojom::UrlDataView>(
        in_trusted_scoring_signals_url, trusted_scoring_signals_url_fragment);
    fragment->trusted_scoring_signals_url.Set(
        trusted_scoring_signals_url_fragment.is_null() ? nullptr : trusted_scoring_signals_url_fragment.data());
    decltype(Traits::auction_ad_config_non_shared_params(input)) in_auction_ad_config_non_shared_params = Traits::auction_ad_config_non_shared_params(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->auction_ad_config_non_shared_params)::BaseType> auction_ad_config_non_shared_params_fragment(
            fragment.message());
    mojo::internal::Serialize<::blink::mojom::AuctionAdConfigNonSharedParamsDataView>(
        in_auction_ad_config_non_shared_params, auction_ad_config_non_shared_params_fragment);
    fragment->auction_ad_config_non_shared_params.Set(
        auction_ad_config_non_shared_params_fragment.is_null() ? nullptr : auction_ad_config_non_shared_params_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->auction_ad_config_non_shared_params.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null auction_ad_config_non_shared_params in AuctionAdConfig struct");
    fragment->has_seller_experiment_group_id = Traits::has_seller_experiment_group_id(input);
    fragment->seller_experiment_group_id = Traits::seller_experiment_group_id(input);
    fragment->has_all_buyer_experiment_group_id = Traits::has_all_buyer_experiment_group_id(input);
    fragment->all_buyer_experiment_group_id = Traits::all_buyer_experiment_group_id(input);
    decltype(Traits::per_buyer_experiment_group_ids(input)) in_per_buyer_experiment_group_ids = Traits::per_buyer_experiment_group_ids(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->per_buyer_experiment_group_ids)::BaseType>
        per_buyer_experiment_group_ids_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams per_buyer_experiment_group_ids_validate_params(
        new mojo::internal::ContainerValidateParams(0, false, nullptr), new mojo::internal::ContainerValidateParams(0, false, nullptr));
    mojo::internal::Serialize<mojo::MapDataView<::url::mojom::OriginDataView, uint16_t>>(
        in_per_buyer_experiment_group_ids, per_buyer_experiment_group_ids_fragment, &per_buyer_experiment_group_ids_validate_params);
    fragment->per_buyer_experiment_group_ids.Set(
        per_buyer_experiment_group_ids_fragment.is_null() ? nullptr : per_buyer_experiment_group_ids_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->per_buyer_experiment_group_ids.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null per_buyer_experiment_group_ids in AuctionAdConfig struct");
  }

  static bool Deserialize(::blink::mojom::internal::AuctionAdConfig_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::blink::mojom::AuctionAdConfigDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal

}  // namespace mojo


namespace blink {
namespace mojom {

inline void InterestGroupAdDataView::GetRenderUrlDataView(
    ::url::mojom::UrlDataView* output) {
  auto pointer = data_->render_url.Get();
  *output = ::url::mojom::UrlDataView(pointer, message_);
}
inline void InterestGroupAdDataView::GetMetadataDataView(
    mojo::StringDataView* output) {
  auto pointer = data_->metadata.Get();
  *output = mojo::StringDataView(pointer, message_);
}


inline void InterestGroupDataView::GetExpiryDataView(
    ::mojo_base::mojom::TimeDataView* output) {
  auto pointer = data_->expiry.Get();
  *output = ::mojo_base::mojom::TimeDataView(pointer, message_);
}
inline void InterestGroupDataView::GetOwnerDataView(
    ::url::mojom::OriginDataView* output) {
  auto pointer = data_->owner.Get();
  *output = ::url::mojom::OriginDataView(pointer, message_);
}
inline void InterestGroupDataView::GetNameDataView(
    mojo::StringDataView* output) {
  auto pointer = data_->name.Get();
  *output = mojo::StringDataView(pointer, message_);
}
inline void InterestGroupDataView::GetBiddingUrlDataView(
    ::url::mojom::UrlDataView* output) {
  auto pointer = data_->bidding_url.Get();
  *output = ::url::mojom::UrlDataView(pointer, message_);
}
inline void InterestGroupDataView::GetBiddingWasmHelperUrlDataView(
    ::url::mojom::UrlDataView* output) {
  auto pointer = data_->bidding_wasm_helper_url.Get();
  *output = ::url::mojom::UrlDataView(pointer, message_);
}
inline void InterestGroupDataView::GetDailyUpdateUrlDataView(
    ::url::mojom::UrlDataView* output) {
  auto pointer = data_->daily_update_url.Get();
  *output = ::url::mojom::UrlDataView(pointer, message_);
}
inline void InterestGroupDataView::GetTrustedBiddingSignalsUrlDataView(
    ::url::mojom::UrlDataView* output) {
  auto pointer = data_->trusted_bidding_signals_url.Get();
  *output = ::url::mojom::UrlDataView(pointer, message_);
}
inline void InterestGroupDataView::GetTrustedBiddingSignalsKeysDataView(
    mojo::ArrayDataView<mojo::StringDataView>* output) {
  auto pointer = data_->trusted_bidding_signals_keys.Get();
  *output = mojo::ArrayDataView<mojo::StringDataView>(pointer, message_);
}
inline void InterestGroupDataView::GetUserBiddingSignalsDataView(
    mojo::StringDataView* output) {
  auto pointer = data_->user_bidding_signals.Get();
  *output = mojo::StringDataView(pointer, message_);
}
inline void InterestGroupDataView::GetAdsDataView(
    mojo::ArrayDataView<InterestGroupAdDataView>* output) {
  auto pointer = data_->ads.Get();
  *output = mojo::ArrayDataView<InterestGroupAdDataView>(pointer, message_);
}
inline void InterestGroupDataView::GetAdComponentsDataView(
    mojo::ArrayDataView<InterestGroupAdDataView>* output) {
  auto pointer = data_->ad_components.Get();
  *output = mojo::ArrayDataView<InterestGroupAdDataView>(pointer, message_);
}


inline void AuctionAdConfigNonSharedParamsDataView::GetInterestGroupBuyersDataView(
    mojo::ArrayDataView<::url::mojom::OriginDataView>* output) {
  auto pointer = data_->interest_group_buyers.Get();
  *output = mojo::ArrayDataView<::url::mojom::OriginDataView>(pointer, message_);
}
inline void AuctionAdConfigNonSharedParamsDataView::GetAuctionSignalsDataView(
    mojo::StringDataView* output) {
  auto pointer = data_->auction_signals.Get();
  *output = mojo::StringDataView(pointer, message_);
}
inline void AuctionAdConfigNonSharedParamsDataView::GetSellerSignalsDataView(
    mojo::StringDataView* output) {
  auto pointer = data_->seller_signals.Get();
  *output = mojo::StringDataView(pointer, message_);
}
inline void AuctionAdConfigNonSharedParamsDataView::GetSellerTimeoutDataView(
    ::mojo_base::mojom::TimeDeltaDataView* output) {
  auto pointer = data_->seller_timeout.Get();
  *output = ::mojo_base::mojom::TimeDeltaDataView(pointer, message_);
}
inline void AuctionAdConfigNonSharedParamsDataView::GetPerBuyerSignalsDataView(
    mojo::MapDataView<::url::mojom::OriginDataView, mojo::StringDataView>* output) {
  auto pointer = data_->per_buyer_signals.Get();
  *output = mojo::MapDataView<::url::mojom::OriginDataView, mojo::StringDataView>(pointer, message_);
}
inline void AuctionAdConfigNonSharedParamsDataView::GetPerBuyerTimeoutsDataView(
    mojo::MapDataView<::url::mojom::OriginDataView, ::mojo_base::mojom::TimeDeltaDataView>* output) {
  auto pointer = data_->per_buyer_timeouts.Get();
  *output = mojo::MapDataView<::url::mojom::OriginDataView, ::mojo_base::mojom::TimeDeltaDataView>(pointer, message_);
}
inline void AuctionAdConfigNonSharedParamsDataView::GetAllBuyersTimeoutDataView(
    ::mojo_base::mojom::TimeDeltaDataView* output) {
  auto pointer = data_->all_buyers_timeout.Get();
  *output = ::mojo_base::mojom::TimeDeltaDataView(pointer, message_);
}
inline void AuctionAdConfigNonSharedParamsDataView::GetPerBuyerGroupLimitsDataView(
    mojo::MapDataView<::url::mojom::OriginDataView, uint16_t>* output) {
  auto pointer = data_->per_buyer_group_limits.Get();
  *output = mojo::MapDataView<::url::mojom::OriginDataView, uint16_t>(pointer, message_);
}
inline void AuctionAdConfigNonSharedParamsDataView::GetComponentAuctionsDataView(
    mojo::ArrayDataView<AuctionAdConfigDataView>* output) {
  auto pointer = data_->component_auctions.Get();
  *output = mojo::ArrayDataView<AuctionAdConfigDataView>(pointer, message_);
}


inline void AuctionAdConfigDataView::GetSellerDataView(
    ::url::mojom::OriginDataView* output) {
  auto pointer = data_->seller.Get();
  *output = ::url::mojom::OriginDataView(pointer, message_);
}
inline void AuctionAdConfigDataView::GetDecisionLogicUrlDataView(
    ::url::mojom::UrlDataView* output) {
  auto pointer = data_->decision_logic_url.Get();
  *output = ::url::mojom::UrlDataView(pointer, message_);
}
inline void AuctionAdConfigDataView::GetTrustedScoringSignalsUrlDataView(
    ::url::mojom::UrlDataView* output) {
  auto pointer = data_->trusted_scoring_signals_url.Get();
  *output = ::url::mojom::UrlDataView(pointer, message_);
}
inline void AuctionAdConfigDataView::GetAuctionAdConfigNonSharedParamsDataView(
    AuctionAdConfigNonSharedParamsDataView* output) {
  auto pointer = data_->auction_ad_config_non_shared_params.Get();
  *output = AuctionAdConfigNonSharedParamsDataView(pointer, message_);
}
inline void AuctionAdConfigDataView::GetPerBuyerExperimentGroupIdsDataView(
    mojo::MapDataView<::url::mojom::OriginDataView, uint16_t>* output) {
  auto pointer = data_->per_buyer_experiment_group_ids.Get();
  *output = mojo::MapDataView<::url::mojom::OriginDataView, uint16_t>(pointer, message_);
}



}  // namespace mojom
}  // namespace blink

// Declare TraceFormatTraits for enums, which should be defined in ::perfetto
// namespace.

namespace perfetto {

template <>
struct COMPONENT_EXPORT(MOJOM_SHARED_BLINK_COMMON_EXPORT) TraceFormatTraits<::blink::mojom::InterestGroup_ExecutionMode> {
 static void WriteIntoTrace(perfetto::TracedValue context, ::blink::mojom::InterestGroup_ExecutionMode value);
};

} // namespace perfetto

#endif  // THIRD_PARTY_BLINK_PUBLIC_MOJOM_INTEREST_GROUP_INTEREST_GROUP_TYPES_MOJOM_SHARED_H_