// third_party/blink/public/mojom/manifest/manifest.mojom-blink.h is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2013 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef THIRD_PARTY_BLINK_PUBLIC_MOJOM_MANIFEST_MANIFEST_MOJOM_BLINK_H_
#define THIRD_PARTY_BLINK_PUBLIC_MOJOM_MANIFEST_MANIFEST_MOJOM_BLINK_H_

#include <stdint.h>

#include <limits>
#include <type_traits>
#include <utility>

#include "third_party/abseil-cpp/absl/types/optional.h"
#include "mojo/public/cpp/bindings/clone_traits.h"
#include "mojo/public/cpp/bindings/equals_traits.h"
#include "mojo/public/cpp/bindings/lib/serialization.h"
#include "mojo/public/cpp/bindings/struct_ptr.h"
#include "mojo/public/cpp/bindings/struct_traits.h"
#include "mojo/public/cpp/bindings/union_traits.h"

#include "third_party/perfetto/include/perfetto/tracing/traced_value_forward.h"

#include "third_party/blink/public/mojom/manifest/manifest.mojom-shared.h"
#include "third_party/blink/public/mojom/manifest/manifest.mojom-blink-forward.h"
#include "services/device/public/mojom/screen_orientation_lock_types.mojom-blink-forward.h"
#include "mojo/public/mojom/base/string16.mojom-blink.h"
#include "third_party/blink/public/mojom/manifest/display_mode.mojom-blink-forward.h"
#include "third_party/blink/public/mojom/manifest/capture_links.mojom-blink-forward.h"
#include "third_party/blink/public/mojom/manifest/manifest_launch_handler.mojom-blink.h"
#include "third_party/blink/public/mojom/permissions_policy/permissions_policy.mojom-blink.h"
#include "ui/gfx/geometry/mojom/geometry.mojom-blink.h"
#include "url/mojom/url.mojom-blink.h"
#include "url/mojom/origin.mojom-blink.h"

#include "mojo/public/cpp/bindings/lib/wtf_clone_equals_util.h"
#include "mojo/public/cpp/bindings/lib/wtf_hash_util.h"
#include "third_party/blink/renderer/platform/wtf/hash_functions.h"
#include "third_party/blink/renderer/platform/wtf/text/wtf_string.h"




#include "third_party/blink/renderer/platform/platform_export.h"




namespace WTF {
struct blink_mojom_internal_TabStripMemberVisibility_DataHashFn {
  static unsigned GetHash(const ::blink::mojom::TabStripMemberVisibility& value) {
    using utype = std::underlying_type<::blink::mojom::TabStripMemberVisibility>::type;
    return DefaultHash<utype>::Hash().GetHash(static_cast<utype>(value));
  }
  static bool Equal(const ::blink::mojom::TabStripMemberVisibility& left, const ::blink::mojom::TabStripMemberVisibility& right) {
    return left == right;
  }
  static const bool safe_to_compare_to_empty_or_deleted = true;
};

template <>
struct HashTraits<::blink::mojom::TabStripMemberVisibility>
    : public GenericHashTraits<::blink::mojom::TabStripMemberVisibility> {
  static_assert(true,
                "-1000000 is a reserved enum value");
  static_assert(true,
                "-1000001 is a reserved enum value");
  static const bool kEmptyValueIsZero = false;
  static ::blink::mojom::TabStripMemberVisibility EmptyValue() { return static_cast<::blink::mojom::TabStripMemberVisibility>(-1000000); }
  static void ConstructDeletedValue(::blink::mojom::TabStripMemberVisibility& slot, bool) {
    slot = static_cast<::blink::mojom::TabStripMemberVisibility>(-1000001);
  }
  static bool IsDeletedValue(const ::blink::mojom::TabStripMemberVisibility& value) {
    return value == static_cast<::blink::mojom::TabStripMemberVisibility>(-1000001);
  }
};
}  // namespace WTF


namespace WTF {
struct blink_mojom_internal_ManifestImageResource_Purpose_DataHashFn {
  static unsigned GetHash(const ::blink::mojom::ManifestImageResource_Purpose& value) {
    using utype = std::underlying_type<::blink::mojom::ManifestImageResource_Purpose>::type;
    return DefaultHash<utype>::Hash().GetHash(static_cast<utype>(value));
  }
  static bool Equal(const ::blink::mojom::ManifestImageResource_Purpose& left, const ::blink::mojom::ManifestImageResource_Purpose& right) {
    return left == right;
  }
  static const bool safe_to_compare_to_empty_or_deleted = true;
};

template <>
struct HashTraits<::blink::mojom::ManifestImageResource_Purpose>
    : public GenericHashTraits<::blink::mojom::ManifestImageResource_Purpose> {
  static_assert(true,
                "-1000000 is a reserved enum value");
  static_assert(true,
                "-1000001 is a reserved enum value");
  static const bool kEmptyValueIsZero = false;
  static ::blink::mojom::ManifestImageResource_Purpose EmptyValue() { return static_cast<::blink::mojom::ManifestImageResource_Purpose>(-1000000); }
  static void ConstructDeletedValue(::blink::mojom::ManifestImageResource_Purpose& slot, bool) {
    slot = static_cast<::blink::mojom::ManifestImageResource_Purpose>(-1000001);
  }
  static bool IsDeletedValue(const ::blink::mojom::ManifestImageResource_Purpose& value) {
    return value == static_cast<::blink::mojom::ManifestImageResource_Purpose>(-1000001);
  }
};
}  // namespace WTF


namespace WTF {
struct blink_mojom_internal_ManifestScreenshot_Platform_DataHashFn {
  static unsigned GetHash(const ::blink::mojom::ManifestScreenshot_Platform& value) {
    using utype = std::underlying_type<::blink::mojom::ManifestScreenshot_Platform>::type;
    return DefaultHash<utype>::Hash().GetHash(static_cast<utype>(value));
  }
  static bool Equal(const ::blink::mojom::ManifestScreenshot_Platform& left, const ::blink::mojom::ManifestScreenshot_Platform& right) {
    return left == right;
  }
  static const bool safe_to_compare_to_empty_or_deleted = true;
};

template <>
struct HashTraits<::blink::mojom::ManifestScreenshot_Platform>
    : public GenericHashTraits<::blink::mojom::ManifestScreenshot_Platform> {
  static_assert(true,
                "-1000000 is a reserved enum value");
  static_assert(true,
                "-1000001 is a reserved enum value");
  static const bool kEmptyValueIsZero = false;
  static ::blink::mojom::ManifestScreenshot_Platform EmptyValue() { return static_cast<::blink::mojom::ManifestScreenshot_Platform>(-1000000); }
  static void ConstructDeletedValue(::blink::mojom::ManifestScreenshot_Platform& slot, bool) {
    slot = static_cast<::blink::mojom::ManifestScreenshot_Platform>(-1000001);
  }
  static bool IsDeletedValue(const ::blink::mojom::ManifestScreenshot_Platform& value) {
    return value == static_cast<::blink::mojom::ManifestScreenshot_Platform>(-1000001);
  }
};
}  // namespace WTF


namespace WTF {
struct blink_mojom_internal_ManifestShareTarget_Method_DataHashFn {
  static unsigned GetHash(const ::blink::mojom::ManifestShareTarget_Method& value) {
    using utype = std::underlying_type<::blink::mojom::ManifestShareTarget_Method>::type;
    return DefaultHash<utype>::Hash().GetHash(static_cast<utype>(value));
  }
  static bool Equal(const ::blink::mojom::ManifestShareTarget_Method& left, const ::blink::mojom::ManifestShareTarget_Method& right) {
    return left == right;
  }
  static const bool safe_to_compare_to_empty_or_deleted = true;
};

template <>
struct HashTraits<::blink::mojom::ManifestShareTarget_Method>
    : public GenericHashTraits<::blink::mojom::ManifestShareTarget_Method> {
  static_assert(true,
                "-1000000 is a reserved enum value");
  static_assert(true,
                "-1000001 is a reserved enum value");
  static const bool kEmptyValueIsZero = false;
  static ::blink::mojom::ManifestShareTarget_Method EmptyValue() { return static_cast<::blink::mojom::ManifestShareTarget_Method>(-1000000); }
  static void ConstructDeletedValue(::blink::mojom::ManifestShareTarget_Method& slot, bool) {
    slot = static_cast<::blink::mojom::ManifestShareTarget_Method>(-1000001);
  }
  static bool IsDeletedValue(const ::blink::mojom::ManifestShareTarget_Method& value) {
    return value == static_cast<::blink::mojom::ManifestShareTarget_Method>(-1000001);
  }
};
}  // namespace WTF


namespace WTF {
struct blink_mojom_internal_ManifestShareTarget_Enctype_DataHashFn {
  static unsigned GetHash(const ::blink::mojom::ManifestShareTarget_Enctype& value) {
    using utype = std::underlying_type<::blink::mojom::ManifestShareTarget_Enctype>::type;
    return DefaultHash<utype>::Hash().GetHash(static_cast<utype>(value));
  }
  static bool Equal(const ::blink::mojom::ManifestShareTarget_Enctype& left, const ::blink::mojom::ManifestShareTarget_Enctype& right) {
    return left == right;
  }
  static const bool safe_to_compare_to_empty_or_deleted = true;
};

template <>
struct HashTraits<::blink::mojom::ManifestShareTarget_Enctype>
    : public GenericHashTraits<::blink::mojom::ManifestShareTarget_Enctype> {
  static_assert(true,
                "-1000000 is a reserved enum value");
  static_assert(true,
                "-1000001 is a reserved enum value");
  static const bool kEmptyValueIsZero = false;
  static ::blink::mojom::ManifestShareTarget_Enctype EmptyValue() { return static_cast<::blink::mojom::ManifestShareTarget_Enctype>(-1000000); }
  static void ConstructDeletedValue(::blink::mojom::ManifestShareTarget_Enctype& slot, bool) {
    slot = static_cast<::blink::mojom::ManifestShareTarget_Enctype>(-1000001);
  }
  static bool IsDeletedValue(const ::blink::mojom::ManifestShareTarget_Enctype& value) {
    return value == static_cast<::blink::mojom::ManifestShareTarget_Enctype>(-1000001);
  }
};
}  // namespace WTF


namespace WTF {
struct blink_mojom_internal_ManifestFileHandler_LaunchType_DataHashFn {
  static unsigned GetHash(const ::blink::mojom::ManifestFileHandler_LaunchType& value) {
    using utype = std::underlying_type<::blink::mojom::ManifestFileHandler_LaunchType>::type;
    return DefaultHash<utype>::Hash().GetHash(static_cast<utype>(value));
  }
  static bool Equal(const ::blink::mojom::ManifestFileHandler_LaunchType& left, const ::blink::mojom::ManifestFileHandler_LaunchType& right) {
    return left == right;
  }
  static const bool safe_to_compare_to_empty_or_deleted = true;
};

template <>
struct HashTraits<::blink::mojom::ManifestFileHandler_LaunchType>
    : public GenericHashTraits<::blink::mojom::ManifestFileHandler_LaunchType> {
  static_assert(true,
                "-1000000 is a reserved enum value");
  static_assert(true,
                "-1000001 is a reserved enum value");
  static const bool kEmptyValueIsZero = false;
  static ::blink::mojom::ManifestFileHandler_LaunchType EmptyValue() { return static_cast<::blink::mojom::ManifestFileHandler_LaunchType>(-1000000); }
  static void ConstructDeletedValue(::blink::mojom::ManifestFileHandler_LaunchType& slot, bool) {
    slot = static_cast<::blink::mojom::ManifestFileHandler_LaunchType>(-1000001);
  }
  static bool IsDeletedValue(const ::blink::mojom::ManifestFileHandler_LaunchType& value) {
    return value == static_cast<::blink::mojom::ManifestFileHandler_LaunchType>(-1000001);
  }
};
}  // namespace WTF


namespace blink {
namespace mojom {
namespace blink {




















class PLATFORM_EXPORT ManifestUserPreferenceOverrides {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<ManifestUserPreferenceOverrides, T>::value>;
  using DataView = ManifestUserPreferenceOverridesDataView;
  using Data_ = internal::ManifestUserPreferenceOverrides_Data;

  template <typename... Args>
  static ManifestUserPreferenceOverridesPtr New(Args&&... args) {
    return ManifestUserPreferenceOverridesPtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static ManifestUserPreferenceOverridesPtr From(const U& u) {
    return mojo::TypeConverter<ManifestUserPreferenceOverridesPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, ManifestUserPreferenceOverrides>::Convert(*this);
  }


  ManifestUserPreferenceOverrides();

  ManifestUserPreferenceOverrides(
      bool has_theme_color,
      uint32_t theme_color,
      bool has_background_color,
      uint32_t background_color);


  ~ManifestUserPreferenceOverrides();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = ManifestUserPreferenceOverridesPtr>
  ManifestUserPreferenceOverridesPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, ManifestUserPreferenceOverrides::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, ManifestUserPreferenceOverrides::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  size_t Hash(size_t seed) const;
  template <typename UserType>
  static WTF::Vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        ManifestUserPreferenceOverrides::DataView, WTF::Vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        ManifestUserPreferenceOverrides::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::ManifestUserPreferenceOverrides_UnserializedMessageContext<
            UserType, ManifestUserPreferenceOverrides::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<ManifestUserPreferenceOverrides::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const WTF::Vector<uint8_t>& input,
                          UserType* output) {
    return ManifestUserPreferenceOverrides::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::ManifestUserPreferenceOverrides_UnserializedMessageContext<
            UserType, ManifestUserPreferenceOverrides::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<ManifestUserPreferenceOverrides::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
  bool has_theme_color;
  
  uint32_t theme_color;
  
  bool has_background_color;
  
  uint32_t background_color;

  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, ManifestUserPreferenceOverrides::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, ManifestUserPreferenceOverrides::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, ManifestUserPreferenceOverrides::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, ManifestUserPreferenceOverrides::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}









class PLATFORM_EXPORT ManifestError {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<ManifestError, T>::value>;
  using DataView = ManifestErrorDataView;
  using Data_ = internal::ManifestError_Data;

  template <typename... Args>
  static ManifestErrorPtr New(Args&&... args) {
    return ManifestErrorPtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static ManifestErrorPtr From(const U& u) {
    return mojo::TypeConverter<ManifestErrorPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, ManifestError>::Convert(*this);
  }


  ManifestError();

  ManifestError(
      const WTF::String& message,
      bool critical,
      uint32_t line,
      uint32_t column);


  ~ManifestError();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = ManifestErrorPtr>
  ManifestErrorPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, ManifestError::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, ManifestError::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  size_t Hash(size_t seed) const;
  template <typename UserType>
  static WTF::Vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        ManifestError::DataView, WTF::Vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        ManifestError::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::ManifestError_UnserializedMessageContext<
            UserType, ManifestError::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<ManifestError::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const WTF::Vector<uint8_t>& input,
                          UserType* output) {
    return ManifestError::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::ManifestError_UnserializedMessageContext<
            UserType, ManifestError::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<ManifestError::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
  WTF::String message;
  
  bool critical;
  
  uint32_t line;
  
  uint32_t column;

  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, ManifestError::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, ManifestError::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, ManifestError::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, ManifestError::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





class PLATFORM_EXPORT HomeTabUnion {
 public:
  using DataView = HomeTabUnionDataView;
  using Data_ = internal::HomeTabUnion_Data;
  using Tag = Data_::HomeTabUnion_Tag;

  template <typename... Args>
  static HomeTabUnionPtr New(Args&&... args) {
    static_assert(
        sizeof...(args) < 0,
        "Do not use Union::New(); to create a union of a given subtype, use "
        "New<SubType>(), not New() followed by set_<sub_type>(). To represent "
        "an empty union, mark the field or parameter as nullable in the mojom "
        "definition.");
  }
  // Construct an instance holding |visibility|.
  static HomeTabUnionPtr
  NewVisibility(
      TabStripMemberVisibility visibility) {
    auto result = HomeTabUnionPtr(absl::in_place);
    result->set_visibility(std::move(visibility));
    return result;
  }
  // Construct an instance holding |params|.
  static HomeTabUnionPtr
  NewParams(
      HomeTabParamsPtr params) {
    auto result = HomeTabUnionPtr(absl::in_place);
    result->set_params(std::move(params));
    return result;
  }

  template <typename U>
  static HomeTabUnionPtr From(const U& u) {
    return mojo::TypeConverter<HomeTabUnionPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, HomeTabUnion>::Convert(*this);
  }

  HomeTabUnion();
  ~HomeTabUnion();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename UnionPtrType = HomeTabUnionPtr>
  HomeTabUnionPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T,
            typename std::enable_if<std::is_same<
                T, HomeTabUnion>::value>::type* = nullptr>
  bool Equals(const T& other) const;

  template <typename T,
            typename std::enable_if<std::is_same<
                T, HomeTabUnion>::value>::type* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }

  Tag which() const {
    return tag_;
  }


  
  bool is_visibility() const { return tag_ == Tag::kVisibility; }

  
  TabStripMemberVisibility get_visibility() const {
    CHECK(tag_ == Tag::kVisibility);
    return data_.visibility;
  }

  
  void set_visibility(
      TabStripMemberVisibility visibility);
  
  bool is_params() const { return tag_ == Tag::kParams; }

  
  HomeTabParamsPtr& get_params() const {
    CHECK(tag_ == Tag::kParams);
    return *(data_.params);
  }

  
  void set_params(
      HomeTabParamsPtr params);

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        HomeTabUnion::DataView>(input);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    return mojo::internal::DeserializeImpl<HomeTabUnion::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

 private:
  union Union_ {
    Union_() = default;
    ~Union_() = default;
    TabStripMemberVisibility visibility;
    HomeTabParamsPtr* params;
  };

  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);

  void DestroyActive();
  Tag tag_;
  Union_ data_;
};



class PLATFORM_EXPORT NewTabButtonUnion {
 public:
  using DataView = NewTabButtonUnionDataView;
  using Data_ = internal::NewTabButtonUnion_Data;
  using Tag = Data_::NewTabButtonUnion_Tag;

  template <typename... Args>
  static NewTabButtonUnionPtr New(Args&&... args) {
    static_assert(
        sizeof...(args) < 0,
        "Do not use Union::New(); to create a union of a given subtype, use "
        "New<SubType>(), not New() followed by set_<sub_type>(). To represent "
        "an empty union, mark the field or parameter as nullable in the mojom "
        "definition.");
  }
  // Construct an instance holding |visibility|.
  static NewTabButtonUnionPtr
  NewVisibility(
      TabStripMemberVisibility visibility) {
    auto result = NewTabButtonUnionPtr(absl::in_place);
    result->set_visibility(std::move(visibility));
    return result;
  }
  // Construct an instance holding |params|.
  static NewTabButtonUnionPtr
  NewParams(
      NewTabButtonParamsPtr params) {
    auto result = NewTabButtonUnionPtr(absl::in_place);
    result->set_params(std::move(params));
    return result;
  }

  template <typename U>
  static NewTabButtonUnionPtr From(const U& u) {
    return mojo::TypeConverter<NewTabButtonUnionPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, NewTabButtonUnion>::Convert(*this);
  }

  NewTabButtonUnion();
  ~NewTabButtonUnion();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename UnionPtrType = NewTabButtonUnionPtr>
  NewTabButtonUnionPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T,
            typename std::enable_if<std::is_same<
                T, NewTabButtonUnion>::value>::type* = nullptr>
  bool Equals(const T& other) const;

  template <typename T,
            typename std::enable_if<std::is_same<
                T, NewTabButtonUnion>::value>::type* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }

  Tag which() const {
    return tag_;
  }


  
  bool is_visibility() const { return tag_ == Tag::kVisibility; }

  
  TabStripMemberVisibility get_visibility() const {
    CHECK(tag_ == Tag::kVisibility);
    return data_.visibility;
  }

  
  void set_visibility(
      TabStripMemberVisibility visibility);
  
  bool is_params() const { return tag_ == Tag::kParams; }

  
  NewTabButtonParamsPtr& get_params() const {
    CHECK(tag_ == Tag::kParams);
    return *(data_.params);
  }

  
  void set_params(
      NewTabButtonParamsPtr params);

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        NewTabButtonUnion::DataView>(input);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    return mojo::internal::DeserializeImpl<NewTabButtonUnion::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

 private:
  union Union_ {
    Union_() = default;
    ~Union_() = default;
    TabStripMemberVisibility visibility;
    NewTabButtonParamsPtr* params;
  };

  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);

  void DestroyActive();
  Tag tag_;
  Union_ data_;
};





class PLATFORM_EXPORT Manifest {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<Manifest, T>::value>;
  using DataView = ManifestDataView;
  using Data_ = internal::Manifest_Data;

  template <typename... Args>
  static ManifestPtr New(Args&&... args) {
    return ManifestPtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static ManifestPtr From(const U& u) {
    return mojo::TypeConverter<ManifestPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, Manifest>::Convert(*this);
  }


  Manifest();

  Manifest(
      const ::WTF::String& name,
      const ::WTF::String& short_name,
      const ::WTF::String& description,
      const ::WTF::String& id,
      const ::blink::KURL& start_url,
      ::blink::mojom::blink::DisplayMode display,
      WTF::Vector<::blink::mojom::blink::DisplayMode> display_override,
      ::device::mojom::blink::ScreenOrientationLockType orientation,
      WTF::Vector<ManifestImageResourcePtr> icons,
      WTF::Vector<ManifestScreenshotPtr> screenshots,
      WTF::Vector<ManifestShortcutItemPtr> shortcuts,
      ManifestShareTargetPtr share_target,
      WTF::Vector<ManifestFileHandlerPtr> file_handlers,
      WTF::Vector<ManifestProtocolHandlerPtr> protocol_handlers,
      WTF::Vector<ManifestUrlHandlerPtr> url_handlers,
      ManifestLockScreenPtr lock_screen,
      ManifestNoteTakingPtr note_taking,
      WTF::Vector<ManifestRelatedApplicationPtr> related_applications,
      bool prefer_related_applications,
      bool has_theme_color,
      uint32_t theme_color,
      bool has_background_color,
      uint32_t background_color,
      const ::WTF::String& gcm_sender_id,
      const ::blink::KURL& scope,
      ::blink::mojom::blink::CaptureLinks capture_links,
      bool isolated_storage,
      WTF::Vector<::blink::ParsedPermissionsPolicyDeclaration> permissions_policy,
      ::blink::mojom::blink::ManifestLaunchHandlerPtr launch_handler,
      WTF::HashMap<::WTF::String, ManifestTranslationItemPtr> translations,
      ManifestUserPreferencesPtr user_preferences,
      ManifestTabStripPtr tab_strip);

Manifest(const Manifest&) = delete;
Manifest& operator=(const Manifest&) = delete;

  ~Manifest();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = ManifestPtr>
  ManifestPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, Manifest::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, Manifest::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  template <typename UserType>
  static WTF::Vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        Manifest::DataView, WTF::Vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        Manifest::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::Manifest_UnserializedMessageContext<
            UserType, Manifest::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<Manifest::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const WTF::Vector<uint8_t>& input,
                          UserType* output) {
    return Manifest::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::Manifest_UnserializedMessageContext<
            UserType, Manifest::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<Manifest::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
  ::WTF::String name;
  
  ::WTF::String short_name;
  
  ::WTF::String description;
  
  ::WTF::String id;
  
  ::blink::KURL start_url;
  
  ::blink::mojom::blink::DisplayMode display;
  
  WTF::Vector<::blink::mojom::blink::DisplayMode> display_override;
  
  ::device::mojom::blink::ScreenOrientationLockType orientation;
  
  WTF::Vector<ManifestImageResourcePtr> icons;
  
  WTF::Vector<ManifestScreenshotPtr> screenshots;
  
  WTF::Vector<ManifestShortcutItemPtr> shortcuts;
  
  ManifestShareTargetPtr share_target;
  
  WTF::Vector<ManifestFileHandlerPtr> file_handlers;
  
  WTF::Vector<ManifestProtocolHandlerPtr> protocol_handlers;
  
  WTF::Vector<ManifestUrlHandlerPtr> url_handlers;
  
  ManifestLockScreenPtr lock_screen;
  
  ManifestNoteTakingPtr note_taking;
  
  WTF::Vector<ManifestRelatedApplicationPtr> related_applications;
  
  bool prefer_related_applications;
  
  bool has_theme_color;
  
  uint32_t theme_color;
  
  bool has_background_color;
  
  uint32_t background_color;
  
  ::WTF::String gcm_sender_id;
  
  ::blink::KURL scope;
  
  ::blink::mojom::blink::CaptureLinks capture_links;
  
  bool isolated_storage;
  
  WTF::Vector<::blink::ParsedPermissionsPolicyDeclaration> permissions_policy;
  
  ::blink::mojom::blink::ManifestLaunchHandlerPtr launch_handler;
  
  WTF::HashMap<::WTF::String, ManifestTranslationItemPtr> translations;
  
  ManifestUserPreferencesPtr user_preferences;
  
  ManifestTabStripPtr tab_strip;

  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, Manifest::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, Manifest::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, Manifest::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, Manifest::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





class PLATFORM_EXPORT ManifestShortcutItem {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<ManifestShortcutItem, T>::value>;
  using DataView = ManifestShortcutItemDataView;
  using Data_ = internal::ManifestShortcutItem_Data;

  template <typename... Args>
  static ManifestShortcutItemPtr New(Args&&... args) {
    return ManifestShortcutItemPtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static ManifestShortcutItemPtr From(const U& u) {
    return mojo::TypeConverter<ManifestShortcutItemPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, ManifestShortcutItem>::Convert(*this);
  }


  ManifestShortcutItem();

  ManifestShortcutItem(
      const ::WTF::String& name,
      const ::WTF::String& short_name,
      const ::WTF::String& description,
      const ::blink::KURL& url,
      WTF::Vector<ManifestImageResourcePtr> icons);

ManifestShortcutItem(const ManifestShortcutItem&) = delete;
ManifestShortcutItem& operator=(const ManifestShortcutItem&) = delete;

  ~ManifestShortcutItem();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = ManifestShortcutItemPtr>
  ManifestShortcutItemPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, ManifestShortcutItem::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, ManifestShortcutItem::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  template <typename UserType>
  static WTF::Vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        ManifestShortcutItem::DataView, WTF::Vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        ManifestShortcutItem::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::ManifestShortcutItem_UnserializedMessageContext<
            UserType, ManifestShortcutItem::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<ManifestShortcutItem::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const WTF::Vector<uint8_t>& input,
                          UserType* output) {
    return ManifestShortcutItem::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::ManifestShortcutItem_UnserializedMessageContext<
            UserType, ManifestShortcutItem::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<ManifestShortcutItem::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
  ::WTF::String name;
  
  ::WTF::String short_name;
  
  ::WTF::String description;
  
  ::blink::KURL url;
  
  WTF::Vector<ManifestImageResourcePtr> icons;

  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, ManifestShortcutItem::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, ManifestShortcutItem::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, ManifestShortcutItem::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, ManifestShortcutItem::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





class PLATFORM_EXPORT ManifestImageResource {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<ManifestImageResource, T>::value>;
  using DataView = ManifestImageResourceDataView;
  using Data_ = internal::ManifestImageResource_Data;
  using Purpose = ManifestImageResource_Purpose;

  template <typename... Args>
  static ManifestImageResourcePtr New(Args&&... args) {
    return ManifestImageResourcePtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static ManifestImageResourcePtr From(const U& u) {
    return mojo::TypeConverter<ManifestImageResourcePtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, ManifestImageResource>::Convert(*this);
  }


  ManifestImageResource();

  ManifestImageResource(
      const ::blink::KURL& src,
      const ::WTF::String& type,
      WTF::Vector<::gfx::Size> sizes,
      WTF::Vector<ManifestImageResource::Purpose> purpose);


  ~ManifestImageResource();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = ManifestImageResourcePtr>
  ManifestImageResourcePtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, ManifestImageResource::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, ManifestImageResource::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  template <typename UserType>
  static WTF::Vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        ManifestImageResource::DataView, WTF::Vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        ManifestImageResource::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::ManifestImageResource_UnserializedMessageContext<
            UserType, ManifestImageResource::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<ManifestImageResource::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const WTF::Vector<uint8_t>& input,
                          UserType* output) {
    return ManifestImageResource::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::ManifestImageResource_UnserializedMessageContext<
            UserType, ManifestImageResource::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<ManifestImageResource::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
  ::blink::KURL src;
  
  ::WTF::String type;
  
  WTF::Vector<::gfx::Size> sizes;
  
  WTF::Vector<ManifestImageResource::Purpose> purpose;

  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, ManifestImageResource::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, ManifestImageResource::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, ManifestImageResource::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, ManifestImageResource::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





class PLATFORM_EXPORT ManifestScreenshot {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<ManifestScreenshot, T>::value>;
  using DataView = ManifestScreenshotDataView;
  using Data_ = internal::ManifestScreenshot_Data;
  using Platform = ManifestScreenshot_Platform;

  template <typename... Args>
  static ManifestScreenshotPtr New(Args&&... args) {
    return ManifestScreenshotPtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static ManifestScreenshotPtr From(const U& u) {
    return mojo::TypeConverter<ManifestScreenshotPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, ManifestScreenshot>::Convert(*this);
  }


  ManifestScreenshot();

  ManifestScreenshot(
      ManifestImageResourcePtr image,
      ManifestScreenshot::Platform platform);

ManifestScreenshot(const ManifestScreenshot&) = delete;
ManifestScreenshot& operator=(const ManifestScreenshot&) = delete;

  ~ManifestScreenshot();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = ManifestScreenshotPtr>
  ManifestScreenshotPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, ManifestScreenshot::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, ManifestScreenshot::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  template <typename UserType>
  static WTF::Vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        ManifestScreenshot::DataView, WTF::Vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        ManifestScreenshot::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::ManifestScreenshot_UnserializedMessageContext<
            UserType, ManifestScreenshot::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<ManifestScreenshot::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const WTF::Vector<uint8_t>& input,
                          UserType* output) {
    return ManifestScreenshot::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::ManifestScreenshot_UnserializedMessageContext<
            UserType, ManifestScreenshot::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<ManifestScreenshot::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
  ManifestImageResourcePtr image;
  
  ManifestScreenshot::Platform platform;

  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, ManifestScreenshot::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, ManifestScreenshot::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, ManifestScreenshot::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, ManifestScreenshot::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





class PLATFORM_EXPORT ManifestFileFilter {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<ManifestFileFilter, T>::value>;
  using DataView = ManifestFileFilterDataView;
  using Data_ = internal::ManifestFileFilter_Data;

  template <typename... Args>
  static ManifestFileFilterPtr New(Args&&... args) {
    return ManifestFileFilterPtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static ManifestFileFilterPtr From(const U& u) {
    return mojo::TypeConverter<ManifestFileFilterPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, ManifestFileFilter>::Convert(*this);
  }


  ManifestFileFilter();

  ManifestFileFilter(
      const ::WTF::String& name,
      WTF::Vector<::WTF::String> accept);


  ~ManifestFileFilter();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = ManifestFileFilterPtr>
  ManifestFileFilterPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, ManifestFileFilter::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, ManifestFileFilter::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  template <typename UserType>
  static WTF::Vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        ManifestFileFilter::DataView, WTF::Vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        ManifestFileFilter::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::ManifestFileFilter_UnserializedMessageContext<
            UserType, ManifestFileFilter::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<ManifestFileFilter::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const WTF::Vector<uint8_t>& input,
                          UserType* output) {
    return ManifestFileFilter::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::ManifestFileFilter_UnserializedMessageContext<
            UserType, ManifestFileFilter::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<ManifestFileFilter::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
  ::WTF::String name;
  
  WTF::Vector<::WTF::String> accept;

  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, ManifestFileFilter::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, ManifestFileFilter::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, ManifestFileFilter::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, ManifestFileFilter::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





class PLATFORM_EXPORT ManifestProtocolHandler {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<ManifestProtocolHandler, T>::value>;
  using DataView = ManifestProtocolHandlerDataView;
  using Data_ = internal::ManifestProtocolHandler_Data;

  template <typename... Args>
  static ManifestProtocolHandlerPtr New(Args&&... args) {
    return ManifestProtocolHandlerPtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static ManifestProtocolHandlerPtr From(const U& u) {
    return mojo::TypeConverter<ManifestProtocolHandlerPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, ManifestProtocolHandler>::Convert(*this);
  }


  ManifestProtocolHandler();

  ManifestProtocolHandler(
      const ::WTF::String& protocol,
      const ::blink::KURL& url);


  ~ManifestProtocolHandler();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = ManifestProtocolHandlerPtr>
  ManifestProtocolHandlerPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, ManifestProtocolHandler::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, ManifestProtocolHandler::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  template <typename UserType>
  static WTF::Vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        ManifestProtocolHandler::DataView, WTF::Vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        ManifestProtocolHandler::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::ManifestProtocolHandler_UnserializedMessageContext<
            UserType, ManifestProtocolHandler::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<ManifestProtocolHandler::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const WTF::Vector<uint8_t>& input,
                          UserType* output) {
    return ManifestProtocolHandler::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::ManifestProtocolHandler_UnserializedMessageContext<
            UserType, ManifestProtocolHandler::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<ManifestProtocolHandler::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
  ::WTF::String protocol;
  
  ::blink::KURL url;

  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, ManifestProtocolHandler::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, ManifestProtocolHandler::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, ManifestProtocolHandler::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, ManifestProtocolHandler::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





class PLATFORM_EXPORT ManifestUrlHandler {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<ManifestUrlHandler, T>::value>;
  using DataView = ManifestUrlHandlerDataView;
  using Data_ = internal::ManifestUrlHandler_Data;

  template <typename... Args>
  static ManifestUrlHandlerPtr New(Args&&... args) {
    return ManifestUrlHandlerPtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static ManifestUrlHandlerPtr From(const U& u) {
    return mojo::TypeConverter<ManifestUrlHandlerPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, ManifestUrlHandler>::Convert(*this);
  }


  ManifestUrlHandler();

  ManifestUrlHandler(
      const ::scoped_refptr<const ::blink::SecurityOrigin>& origin,
      bool has_origin_wildcard);


  ~ManifestUrlHandler();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = ManifestUrlHandlerPtr>
  ManifestUrlHandlerPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, ManifestUrlHandler::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, ManifestUrlHandler::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  template <typename UserType>
  static WTF::Vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        ManifestUrlHandler::DataView, WTF::Vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        ManifestUrlHandler::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::ManifestUrlHandler_UnserializedMessageContext<
            UserType, ManifestUrlHandler::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<ManifestUrlHandler::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const WTF::Vector<uint8_t>& input,
                          UserType* output) {
    return ManifestUrlHandler::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::ManifestUrlHandler_UnserializedMessageContext<
            UserType, ManifestUrlHandler::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<ManifestUrlHandler::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
  ::scoped_refptr<const ::blink::SecurityOrigin> origin;
  
  bool has_origin_wildcard;

  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, ManifestUrlHandler::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, ManifestUrlHandler::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, ManifestUrlHandler::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, ManifestUrlHandler::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





class PLATFORM_EXPORT ManifestLockScreen {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<ManifestLockScreen, T>::value>;
  using DataView = ManifestLockScreenDataView;
  using Data_ = internal::ManifestLockScreen_Data;

  template <typename... Args>
  static ManifestLockScreenPtr New(Args&&... args) {
    return ManifestLockScreenPtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static ManifestLockScreenPtr From(const U& u) {
    return mojo::TypeConverter<ManifestLockScreenPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, ManifestLockScreen>::Convert(*this);
  }


  ManifestLockScreen();

  explicit ManifestLockScreen(
      const ::blink::KURL& start_url);


  ~ManifestLockScreen();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = ManifestLockScreenPtr>
  ManifestLockScreenPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, ManifestLockScreen::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, ManifestLockScreen::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  template <typename UserType>
  static WTF::Vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        ManifestLockScreen::DataView, WTF::Vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        ManifestLockScreen::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::ManifestLockScreen_UnserializedMessageContext<
            UserType, ManifestLockScreen::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<ManifestLockScreen::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const WTF::Vector<uint8_t>& input,
                          UserType* output) {
    return ManifestLockScreen::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::ManifestLockScreen_UnserializedMessageContext<
            UserType, ManifestLockScreen::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<ManifestLockScreen::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
  ::blink::KURL start_url;

  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, ManifestLockScreen::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, ManifestLockScreen::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, ManifestLockScreen::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, ManifestLockScreen::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





class PLATFORM_EXPORT ManifestNoteTaking {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<ManifestNoteTaking, T>::value>;
  using DataView = ManifestNoteTakingDataView;
  using Data_ = internal::ManifestNoteTaking_Data;

  template <typename... Args>
  static ManifestNoteTakingPtr New(Args&&... args) {
    return ManifestNoteTakingPtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static ManifestNoteTakingPtr From(const U& u) {
    return mojo::TypeConverter<ManifestNoteTakingPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, ManifestNoteTaking>::Convert(*this);
  }


  ManifestNoteTaking();

  explicit ManifestNoteTaking(
      const ::blink::KURL& new_note_url);


  ~ManifestNoteTaking();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = ManifestNoteTakingPtr>
  ManifestNoteTakingPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, ManifestNoteTaking::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, ManifestNoteTaking::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  template <typename UserType>
  static WTF::Vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        ManifestNoteTaking::DataView, WTF::Vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        ManifestNoteTaking::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::ManifestNoteTaking_UnserializedMessageContext<
            UserType, ManifestNoteTaking::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<ManifestNoteTaking::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const WTF::Vector<uint8_t>& input,
                          UserType* output) {
    return ManifestNoteTaking::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::ManifestNoteTaking_UnserializedMessageContext<
            UserType, ManifestNoteTaking::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<ManifestNoteTaking::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
  ::blink::KURL new_note_url;

  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, ManifestNoteTaking::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, ManifestNoteTaking::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, ManifestNoteTaking::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, ManifestNoteTaking::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





class PLATFORM_EXPORT ManifestRelatedApplication {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<ManifestRelatedApplication, T>::value>;
  using DataView = ManifestRelatedApplicationDataView;
  using Data_ = internal::ManifestRelatedApplication_Data;

  template <typename... Args>
  static ManifestRelatedApplicationPtr New(Args&&... args) {
    return ManifestRelatedApplicationPtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static ManifestRelatedApplicationPtr From(const U& u) {
    return mojo::TypeConverter<ManifestRelatedApplicationPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, ManifestRelatedApplication>::Convert(*this);
  }


  ManifestRelatedApplication();

  ManifestRelatedApplication(
      const ::WTF::String& platform,
      const absl::optional<::blink::KURL>& url,
      const ::WTF::String& id);


  ~ManifestRelatedApplication();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = ManifestRelatedApplicationPtr>
  ManifestRelatedApplicationPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, ManifestRelatedApplication::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, ManifestRelatedApplication::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  template <typename UserType>
  static WTF::Vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        ManifestRelatedApplication::DataView, WTF::Vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        ManifestRelatedApplication::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::ManifestRelatedApplication_UnserializedMessageContext<
            UserType, ManifestRelatedApplication::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<ManifestRelatedApplication::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const WTF::Vector<uint8_t>& input,
                          UserType* output) {
    return ManifestRelatedApplication::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::ManifestRelatedApplication_UnserializedMessageContext<
            UserType, ManifestRelatedApplication::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<ManifestRelatedApplication::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
  ::WTF::String platform;
  
  absl::optional<::blink::KURL> url;
  
  ::WTF::String id;

  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, ManifestRelatedApplication::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, ManifestRelatedApplication::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, ManifestRelatedApplication::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, ManifestRelatedApplication::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





class PLATFORM_EXPORT ManifestShareTargetParams {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<ManifestShareTargetParams, T>::value>;
  using DataView = ManifestShareTargetParamsDataView;
  using Data_ = internal::ManifestShareTargetParams_Data;

  template <typename... Args>
  static ManifestShareTargetParamsPtr New(Args&&... args) {
    return ManifestShareTargetParamsPtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static ManifestShareTargetParamsPtr From(const U& u) {
    return mojo::TypeConverter<ManifestShareTargetParamsPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, ManifestShareTargetParams>::Convert(*this);
  }


  ManifestShareTargetParams();

  ManifestShareTargetParams(
      const ::WTF::String& title,
      const ::WTF::String& text,
      const ::WTF::String& url,
      absl::optional<WTF::Vector<ManifestFileFilterPtr>> files);

ManifestShareTargetParams(const ManifestShareTargetParams&) = delete;
ManifestShareTargetParams& operator=(const ManifestShareTargetParams&) = delete;

  ~ManifestShareTargetParams();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = ManifestShareTargetParamsPtr>
  ManifestShareTargetParamsPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, ManifestShareTargetParams::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, ManifestShareTargetParams::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  template <typename UserType>
  static WTF::Vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        ManifestShareTargetParams::DataView, WTF::Vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        ManifestShareTargetParams::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::ManifestShareTargetParams_UnserializedMessageContext<
            UserType, ManifestShareTargetParams::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<ManifestShareTargetParams::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const WTF::Vector<uint8_t>& input,
                          UserType* output) {
    return ManifestShareTargetParams::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::ManifestShareTargetParams_UnserializedMessageContext<
            UserType, ManifestShareTargetParams::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<ManifestShareTargetParams::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
  ::WTF::String title;
  
  ::WTF::String text;
  
  ::WTF::String url;
  
  absl::optional<WTF::Vector<ManifestFileFilterPtr>> files;

  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, ManifestShareTargetParams::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, ManifestShareTargetParams::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, ManifestShareTargetParams::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, ManifestShareTargetParams::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





class PLATFORM_EXPORT ManifestShareTarget {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<ManifestShareTarget, T>::value>;
  using DataView = ManifestShareTargetDataView;
  using Data_ = internal::ManifestShareTarget_Data;
  using Method = ManifestShareTarget_Method;
  using Enctype = ManifestShareTarget_Enctype;

  template <typename... Args>
  static ManifestShareTargetPtr New(Args&&... args) {
    return ManifestShareTargetPtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static ManifestShareTargetPtr From(const U& u) {
    return mojo::TypeConverter<ManifestShareTargetPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, ManifestShareTarget>::Convert(*this);
  }


  ManifestShareTarget();

  ManifestShareTarget(
      const ::blink::KURL& action,
      ManifestShareTarget::Method method,
      ManifestShareTarget::Enctype enctype,
      ManifestShareTargetParamsPtr params);

ManifestShareTarget(const ManifestShareTarget&) = delete;
ManifestShareTarget& operator=(const ManifestShareTarget&) = delete;

  ~ManifestShareTarget();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = ManifestShareTargetPtr>
  ManifestShareTargetPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, ManifestShareTarget::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, ManifestShareTarget::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  template <typename UserType>
  static WTF::Vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        ManifestShareTarget::DataView, WTF::Vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        ManifestShareTarget::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::ManifestShareTarget_UnserializedMessageContext<
            UserType, ManifestShareTarget::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<ManifestShareTarget::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const WTF::Vector<uint8_t>& input,
                          UserType* output) {
    return ManifestShareTarget::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::ManifestShareTarget_UnserializedMessageContext<
            UserType, ManifestShareTarget::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<ManifestShareTarget::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
  ::blink::KURL action;
  
  ManifestShareTarget::Method method;
  
  ManifestShareTarget::Enctype enctype;
  
  ManifestShareTargetParamsPtr params;

  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, ManifestShareTarget::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, ManifestShareTarget::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, ManifestShareTarget::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, ManifestShareTarget::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





class PLATFORM_EXPORT ManifestFileHandler {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<ManifestFileHandler, T>::value>;
  using DataView = ManifestFileHandlerDataView;
  using Data_ = internal::ManifestFileHandler_Data;
  using LaunchType = ManifestFileHandler_LaunchType;

  template <typename... Args>
  static ManifestFileHandlerPtr New(Args&&... args) {
    return ManifestFileHandlerPtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static ManifestFileHandlerPtr From(const U& u) {
    return mojo::TypeConverter<ManifestFileHandlerPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, ManifestFileHandler>::Convert(*this);
  }


  ManifestFileHandler();

  ManifestFileHandler(
      const ::blink::KURL& action,
      const ::WTF::String& name,
      WTF::Vector<ManifestImageResourcePtr> icons,
      const WTF::HashMap<::WTF::String, WTF::Vector<::WTF::String>>& accept,
      ManifestFileHandler::LaunchType launch_type);

ManifestFileHandler(const ManifestFileHandler&) = delete;
ManifestFileHandler& operator=(const ManifestFileHandler&) = delete;

  ~ManifestFileHandler();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = ManifestFileHandlerPtr>
  ManifestFileHandlerPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, ManifestFileHandler::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, ManifestFileHandler::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  template <typename UserType>
  static WTF::Vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        ManifestFileHandler::DataView, WTF::Vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        ManifestFileHandler::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::ManifestFileHandler_UnserializedMessageContext<
            UserType, ManifestFileHandler::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<ManifestFileHandler::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const WTF::Vector<uint8_t>& input,
                          UserType* output) {
    return ManifestFileHandler::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::ManifestFileHandler_UnserializedMessageContext<
            UserType, ManifestFileHandler::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<ManifestFileHandler::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
  ::blink::KURL action;
  
  ::WTF::String name;
  
  WTF::Vector<ManifestImageResourcePtr> icons;
  
  WTF::HashMap<::WTF::String, WTF::Vector<::WTF::String>> accept;
  
  ManifestFileHandler::LaunchType launch_type;

  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, ManifestFileHandler::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, ManifestFileHandler::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, ManifestFileHandler::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, ManifestFileHandler::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





class PLATFORM_EXPORT ManifestTranslationItem {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<ManifestTranslationItem, T>::value>;
  using DataView = ManifestTranslationItemDataView;
  using Data_ = internal::ManifestTranslationItem_Data;

  template <typename... Args>
  static ManifestTranslationItemPtr New(Args&&... args) {
    return ManifestTranslationItemPtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static ManifestTranslationItemPtr From(const U& u) {
    return mojo::TypeConverter<ManifestTranslationItemPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, ManifestTranslationItem>::Convert(*this);
  }


  ManifestTranslationItem();

  ManifestTranslationItem(
      const ::WTF::String& name,
      const ::WTF::String& short_name,
      const ::WTF::String& description);


  ~ManifestTranslationItem();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = ManifestTranslationItemPtr>
  ManifestTranslationItemPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, ManifestTranslationItem::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, ManifestTranslationItem::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  template <typename UserType>
  static WTF::Vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        ManifestTranslationItem::DataView, WTF::Vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        ManifestTranslationItem::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::ManifestTranslationItem_UnserializedMessageContext<
            UserType, ManifestTranslationItem::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<ManifestTranslationItem::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const WTF::Vector<uint8_t>& input,
                          UserType* output) {
    return ManifestTranslationItem::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::ManifestTranslationItem_UnserializedMessageContext<
            UserType, ManifestTranslationItem::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<ManifestTranslationItem::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
  ::WTF::String name;
  
  ::WTF::String short_name;
  
  ::WTF::String description;

  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, ManifestTranslationItem::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, ManifestTranslationItem::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, ManifestTranslationItem::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, ManifestTranslationItem::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





class PLATFORM_EXPORT ManifestUserPreferences {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<ManifestUserPreferences, T>::value>;
  using DataView = ManifestUserPreferencesDataView;
  using Data_ = internal::ManifestUserPreferences_Data;

  template <typename... Args>
  static ManifestUserPreferencesPtr New(Args&&... args) {
    return ManifestUserPreferencesPtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static ManifestUserPreferencesPtr From(const U& u) {
    return mojo::TypeConverter<ManifestUserPreferencesPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, ManifestUserPreferences>::Convert(*this);
  }


  ManifestUserPreferences();

  explicit ManifestUserPreferences(
      ManifestUserPreferenceOverridesPtr color_scheme_dark);

ManifestUserPreferences(const ManifestUserPreferences&) = delete;
ManifestUserPreferences& operator=(const ManifestUserPreferences&) = delete;

  ~ManifestUserPreferences();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = ManifestUserPreferencesPtr>
  ManifestUserPreferencesPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, ManifestUserPreferences::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, ManifestUserPreferences::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  template <typename UserType>
  static WTF::Vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        ManifestUserPreferences::DataView, WTF::Vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        ManifestUserPreferences::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::ManifestUserPreferences_UnserializedMessageContext<
            UserType, ManifestUserPreferences::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<ManifestUserPreferences::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const WTF::Vector<uint8_t>& input,
                          UserType* output) {
    return ManifestUserPreferences::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::ManifestUserPreferences_UnserializedMessageContext<
            UserType, ManifestUserPreferences::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<ManifestUserPreferences::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
  ManifestUserPreferenceOverridesPtr color_scheme_dark;

  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, ManifestUserPreferences::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, ManifestUserPreferences::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, ManifestUserPreferences::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, ManifestUserPreferences::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}






class PLATFORM_EXPORT ManifestTabStrip {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<ManifestTabStrip, T>::value>;
  using DataView = ManifestTabStripDataView;
  using Data_ = internal::ManifestTabStrip_Data;

  template <typename... Args>
  static ManifestTabStripPtr New(Args&&... args) {
    return ManifestTabStripPtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static ManifestTabStripPtr From(const U& u) {
    return mojo::TypeConverter<ManifestTabStripPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, ManifestTabStrip>::Convert(*this);
  }


  ManifestTabStrip();

  ManifestTabStrip(
      HomeTabUnionPtr home_tab,
      NewTabButtonUnionPtr new_tab_button);

ManifestTabStrip(const ManifestTabStrip&) = delete;
ManifestTabStrip& operator=(const ManifestTabStrip&) = delete;

  ~ManifestTabStrip();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = ManifestTabStripPtr>
  ManifestTabStripPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, ManifestTabStrip::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, ManifestTabStrip::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  template <typename UserType>
  static WTF::Vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        ManifestTabStrip::DataView, WTF::Vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        ManifestTabStrip::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::ManifestTabStrip_UnserializedMessageContext<
            UserType, ManifestTabStrip::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<ManifestTabStrip::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const WTF::Vector<uint8_t>& input,
                          UserType* output) {
    return ManifestTabStrip::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::ManifestTabStrip_UnserializedMessageContext<
            UserType, ManifestTabStrip::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<ManifestTabStrip::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
  HomeTabUnionPtr home_tab;
  
  NewTabButtonUnionPtr new_tab_button;

  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, ManifestTabStrip::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, ManifestTabStrip::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, ManifestTabStrip::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, ManifestTabStrip::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





class PLATFORM_EXPORT HomeTabParams {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<HomeTabParams, T>::value>;
  using DataView = HomeTabParamsDataView;
  using Data_ = internal::HomeTabParams_Data;

  template <typename... Args>
  static HomeTabParamsPtr New(Args&&... args) {
    return HomeTabParamsPtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static HomeTabParamsPtr From(const U& u) {
    return mojo::TypeConverter<HomeTabParamsPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, HomeTabParams>::Convert(*this);
  }


  HomeTabParams();

  explicit HomeTabParams(
      WTF::Vector<ManifestImageResourcePtr> icons);

HomeTabParams(const HomeTabParams&) = delete;
HomeTabParams& operator=(const HomeTabParams&) = delete;

  ~HomeTabParams();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = HomeTabParamsPtr>
  HomeTabParamsPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, HomeTabParams::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, HomeTabParams::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  template <typename UserType>
  static WTF::Vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        HomeTabParams::DataView, WTF::Vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        HomeTabParams::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::HomeTabParams_UnserializedMessageContext<
            UserType, HomeTabParams::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<HomeTabParams::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const WTF::Vector<uint8_t>& input,
                          UserType* output) {
    return HomeTabParams::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::HomeTabParams_UnserializedMessageContext<
            UserType, HomeTabParams::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<HomeTabParams::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
  WTF::Vector<ManifestImageResourcePtr> icons;

  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, HomeTabParams::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, HomeTabParams::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, HomeTabParams::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, HomeTabParams::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





class PLATFORM_EXPORT NewTabButtonParams {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<NewTabButtonParams, T>::value>;
  using DataView = NewTabButtonParamsDataView;
  using Data_ = internal::NewTabButtonParams_Data;

  template <typename... Args>
  static NewTabButtonParamsPtr New(Args&&... args) {
    return NewTabButtonParamsPtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static NewTabButtonParamsPtr From(const U& u) {
    return mojo::TypeConverter<NewTabButtonParamsPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, NewTabButtonParams>::Convert(*this);
  }


  NewTabButtonParams();

  explicit NewTabButtonParams(
      const absl::optional<::blink::KURL>& url);


  ~NewTabButtonParams();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = NewTabButtonParamsPtr>
  NewTabButtonParamsPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, NewTabButtonParams::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, NewTabButtonParams::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  template <typename UserType>
  static WTF::Vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        NewTabButtonParams::DataView, WTF::Vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        NewTabButtonParams::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::NewTabButtonParams_UnserializedMessageContext<
            UserType, NewTabButtonParams::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<NewTabButtonParams::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const WTF::Vector<uint8_t>& input,
                          UserType* output) {
    return NewTabButtonParams::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::NewTabButtonParams_UnserializedMessageContext<
            UserType, NewTabButtonParams::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<NewTabButtonParams::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
  absl::optional<::blink::KURL> url;

  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, NewTabButtonParams::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, NewTabButtonParams::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, NewTabButtonParams::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, NewTabButtonParams::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





class PLATFORM_EXPORT ManifestDebugInfo {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<ManifestDebugInfo, T>::value>;
  using DataView = ManifestDebugInfoDataView;
  using Data_ = internal::ManifestDebugInfo_Data;

  template <typename... Args>
  static ManifestDebugInfoPtr New(Args&&... args) {
    return ManifestDebugInfoPtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static ManifestDebugInfoPtr From(const U& u) {
    return mojo::TypeConverter<ManifestDebugInfoPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, ManifestDebugInfo>::Convert(*this);
  }


  ManifestDebugInfo();

  ManifestDebugInfo(
      WTF::Vector<ManifestErrorPtr> errors,
      const WTF::String& raw_manifest);

ManifestDebugInfo(const ManifestDebugInfo&) = delete;
ManifestDebugInfo& operator=(const ManifestDebugInfo&) = delete;

  ~ManifestDebugInfo();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = ManifestDebugInfoPtr>
  ManifestDebugInfoPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, ManifestDebugInfo::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, ManifestDebugInfo::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  template <typename UserType>
  static WTF::Vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        ManifestDebugInfo::DataView, WTF::Vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        ManifestDebugInfo::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::ManifestDebugInfo_UnserializedMessageContext<
            UserType, ManifestDebugInfo::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<ManifestDebugInfo::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const WTF::Vector<uint8_t>& input,
                          UserType* output) {
    return ManifestDebugInfo::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::ManifestDebugInfo_UnserializedMessageContext<
            UserType, ManifestDebugInfo::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<ManifestDebugInfo::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
  WTF::Vector<ManifestErrorPtr> errors;
  
  WTF::String raw_manifest;

  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, ManifestDebugInfo::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, ManifestDebugInfo::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, ManifestDebugInfo::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, ManifestDebugInfo::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}


template <typename UnionPtrType>
HomeTabUnionPtr HomeTabUnion::Clone() const {
  switch (tag_) {
    case Tag::kVisibility:
      return NewVisibility(
          mojo::Clone(data_.visibility));
    case Tag::kParams:
      return NewParams(
          mojo::Clone(*data_.params));
  }
  return nullptr;
}

template <typename T,
          typename std::enable_if<std::is_same<
              T, HomeTabUnion>::value>::type*>
bool HomeTabUnion::Equals(const T& other) const {
  if (tag_ != other.which())
    return false;

  switch (tag_) {
    case Tag::kVisibility:
      return mojo::Equals(data_.visibility, other.data_.visibility);
    case Tag::kParams:
      return mojo::Equals(*(data_.params), *(other.data_.params));
  }

  return false;
}
template <typename UnionPtrType>
NewTabButtonUnionPtr NewTabButtonUnion::Clone() const {
  switch (tag_) {
    case Tag::kVisibility:
      return NewVisibility(
          mojo::Clone(data_.visibility));
    case Tag::kParams:
      return NewParams(
          mojo::Clone(*data_.params));
  }
  return nullptr;
}

template <typename T,
          typename std::enable_if<std::is_same<
              T, NewTabButtonUnion>::value>::type*>
bool NewTabButtonUnion::Equals(const T& other) const {
  if (tag_ != other.which())
    return false;

  switch (tag_) {
    case Tag::kVisibility:
      return mojo::Equals(data_.visibility, other.data_.visibility);
    case Tag::kParams:
      return mojo::Equals(*(data_.params), *(other.data_.params));
  }

  return false;
}
template <typename StructPtrType>
ManifestPtr Manifest::Clone() const {
  return New(
      mojo::Clone(name),
      mojo::Clone(short_name),
      mojo::Clone(description),
      mojo::Clone(id),
      mojo::Clone(start_url),
      mojo::Clone(display),
      mojo::Clone(display_override),
      mojo::Clone(orientation),
      mojo::Clone(icons),
      mojo::Clone(screenshots),
      mojo::Clone(shortcuts),
      mojo::Clone(share_target),
      mojo::Clone(file_handlers),
      mojo::Clone(protocol_handlers),
      mojo::Clone(url_handlers),
      mojo::Clone(lock_screen),
      mojo::Clone(note_taking),
      mojo::Clone(related_applications),
      mojo::Clone(prefer_related_applications),
      mojo::Clone(has_theme_color),
      mojo::Clone(theme_color),
      mojo::Clone(has_background_color),
      mojo::Clone(background_color),
      mojo::Clone(gcm_sender_id),
      mojo::Clone(scope),
      mojo::Clone(capture_links),
      mojo::Clone(isolated_storage),
      mojo::Clone(permissions_policy),
      mojo::Clone(launch_handler),
      mojo::Clone(translations),
      mojo::Clone(user_preferences),
      mojo::Clone(tab_strip)
  );
}

template <typename T, Manifest::EnableIfSame<T>*>
bool Manifest::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->name, other_struct.name))
    return false;
  if (!mojo::Equals(this->short_name, other_struct.short_name))
    return false;
  if (!mojo::Equals(this->description, other_struct.description))
    return false;
  if (!mojo::Equals(this->id, other_struct.id))
    return false;
  if (!mojo::Equals(this->start_url, other_struct.start_url))
    return false;
  if (!mojo::Equals(this->display, other_struct.display))
    return false;
  if (!mojo::Equals(this->display_override, other_struct.display_override))
    return false;
  if (!mojo::Equals(this->orientation, other_struct.orientation))
    return false;
  if (!mojo::Equals(this->icons, other_struct.icons))
    return false;
  if (!mojo::Equals(this->screenshots, other_struct.screenshots))
    return false;
  if (!mojo::Equals(this->shortcuts, other_struct.shortcuts))
    return false;
  if (!mojo::Equals(this->share_target, other_struct.share_target))
    return false;
  if (!mojo::Equals(this->file_handlers, other_struct.file_handlers))
    return false;
  if (!mojo::Equals(this->protocol_handlers, other_struct.protocol_handlers))
    return false;
  if (!mojo::Equals(this->url_handlers, other_struct.url_handlers))
    return false;
  if (!mojo::Equals(this->lock_screen, other_struct.lock_screen))
    return false;
  if (!mojo::Equals(this->note_taking, other_struct.note_taking))
    return false;
  if (!mojo::Equals(this->related_applications, other_struct.related_applications))
    return false;
  if (!mojo::Equals(this->prefer_related_applications, other_struct.prefer_related_applications))
    return false;
  if (!mojo::Equals(this->has_theme_color, other_struct.has_theme_color))
    return false;
  if (!mojo::Equals(this->theme_color, other_struct.theme_color))
    return false;
  if (!mojo::Equals(this->has_background_color, other_struct.has_background_color))
    return false;
  if (!mojo::Equals(this->background_color, other_struct.background_color))
    return false;
  if (!mojo::Equals(this->gcm_sender_id, other_struct.gcm_sender_id))
    return false;
  if (!mojo::Equals(this->scope, other_struct.scope))
    return false;
  if (!mojo::Equals(this->capture_links, other_struct.capture_links))
    return false;
  if (!mojo::Equals(this->isolated_storage, other_struct.isolated_storage))
    return false;
  if (!mojo::Equals(this->permissions_policy, other_struct.permissions_policy))
    return false;
  if (!mojo::Equals(this->launch_handler, other_struct.launch_handler))
    return false;
  if (!mojo::Equals(this->translations, other_struct.translations))
    return false;
  if (!mojo::Equals(this->user_preferences, other_struct.user_preferences))
    return false;
  if (!mojo::Equals(this->tab_strip, other_struct.tab_strip))
    return false;
  return true;
}

template <typename T, Manifest::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.name < rhs.name)
    return true;
  if (rhs.name < lhs.name)
    return false;
  if (lhs.short_name < rhs.short_name)
    return true;
  if (rhs.short_name < lhs.short_name)
    return false;
  if (lhs.description < rhs.description)
    return true;
  if (rhs.description < lhs.description)
    return false;
  if (lhs.id < rhs.id)
    return true;
  if (rhs.id < lhs.id)
    return false;
  if (lhs.start_url < rhs.start_url)
    return true;
  if (rhs.start_url < lhs.start_url)
    return false;
  if (lhs.display < rhs.display)
    return true;
  if (rhs.display < lhs.display)
    return false;
  if (lhs.display_override < rhs.display_override)
    return true;
  if (rhs.display_override < lhs.display_override)
    return false;
  if (lhs.orientation < rhs.orientation)
    return true;
  if (rhs.orientation < lhs.orientation)
    return false;
  if (lhs.icons < rhs.icons)
    return true;
  if (rhs.icons < lhs.icons)
    return false;
  if (lhs.screenshots < rhs.screenshots)
    return true;
  if (rhs.screenshots < lhs.screenshots)
    return false;
  if (lhs.shortcuts < rhs.shortcuts)
    return true;
  if (rhs.shortcuts < lhs.shortcuts)
    return false;
  if (lhs.share_target < rhs.share_target)
    return true;
  if (rhs.share_target < lhs.share_target)
    return false;
  if (lhs.file_handlers < rhs.file_handlers)
    return true;
  if (rhs.file_handlers < lhs.file_handlers)
    return false;
  if (lhs.protocol_handlers < rhs.protocol_handlers)
    return true;
  if (rhs.protocol_handlers < lhs.protocol_handlers)
    return false;
  if (lhs.url_handlers < rhs.url_handlers)
    return true;
  if (rhs.url_handlers < lhs.url_handlers)
    return false;
  if (lhs.lock_screen < rhs.lock_screen)
    return true;
  if (rhs.lock_screen < lhs.lock_screen)
    return false;
  if (lhs.note_taking < rhs.note_taking)
    return true;
  if (rhs.note_taking < lhs.note_taking)
    return false;
  if (lhs.related_applications < rhs.related_applications)
    return true;
  if (rhs.related_applications < lhs.related_applications)
    return false;
  if (lhs.prefer_related_applications < rhs.prefer_related_applications)
    return true;
  if (rhs.prefer_related_applications < lhs.prefer_related_applications)
    return false;
  if (lhs.has_theme_color < rhs.has_theme_color)
    return true;
  if (rhs.has_theme_color < lhs.has_theme_color)
    return false;
  if (lhs.theme_color < rhs.theme_color)
    return true;
  if (rhs.theme_color < lhs.theme_color)
    return false;
  if (lhs.has_background_color < rhs.has_background_color)
    return true;
  if (rhs.has_background_color < lhs.has_background_color)
    return false;
  if (lhs.background_color < rhs.background_color)
    return true;
  if (rhs.background_color < lhs.background_color)
    return false;
  if (lhs.gcm_sender_id < rhs.gcm_sender_id)
    return true;
  if (rhs.gcm_sender_id < lhs.gcm_sender_id)
    return false;
  if (lhs.scope < rhs.scope)
    return true;
  if (rhs.scope < lhs.scope)
    return false;
  if (lhs.capture_links < rhs.capture_links)
    return true;
  if (rhs.capture_links < lhs.capture_links)
    return false;
  if (lhs.isolated_storage < rhs.isolated_storage)
    return true;
  if (rhs.isolated_storage < lhs.isolated_storage)
    return false;
  if (lhs.permissions_policy < rhs.permissions_policy)
    return true;
  if (rhs.permissions_policy < lhs.permissions_policy)
    return false;
  if (lhs.launch_handler < rhs.launch_handler)
    return true;
  if (rhs.launch_handler < lhs.launch_handler)
    return false;
  if (lhs.translations < rhs.translations)
    return true;
  if (rhs.translations < lhs.translations)
    return false;
  if (lhs.user_preferences < rhs.user_preferences)
    return true;
  if (rhs.user_preferences < lhs.user_preferences)
    return false;
  if (lhs.tab_strip < rhs.tab_strip)
    return true;
  if (rhs.tab_strip < lhs.tab_strip)
    return false;
  return false;
}
template <typename StructPtrType>
ManifestShortcutItemPtr ManifestShortcutItem::Clone() const {
  return New(
      mojo::Clone(name),
      mojo::Clone(short_name),
      mojo::Clone(description),
      mojo::Clone(url),
      mojo::Clone(icons)
  );
}

template <typename T, ManifestShortcutItem::EnableIfSame<T>*>
bool ManifestShortcutItem::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->name, other_struct.name))
    return false;
  if (!mojo::Equals(this->short_name, other_struct.short_name))
    return false;
  if (!mojo::Equals(this->description, other_struct.description))
    return false;
  if (!mojo::Equals(this->url, other_struct.url))
    return false;
  if (!mojo::Equals(this->icons, other_struct.icons))
    return false;
  return true;
}

template <typename T, ManifestShortcutItem::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.name < rhs.name)
    return true;
  if (rhs.name < lhs.name)
    return false;
  if (lhs.short_name < rhs.short_name)
    return true;
  if (rhs.short_name < lhs.short_name)
    return false;
  if (lhs.description < rhs.description)
    return true;
  if (rhs.description < lhs.description)
    return false;
  if (lhs.url < rhs.url)
    return true;
  if (rhs.url < lhs.url)
    return false;
  if (lhs.icons < rhs.icons)
    return true;
  if (rhs.icons < lhs.icons)
    return false;
  return false;
}
template <typename StructPtrType>
ManifestImageResourcePtr ManifestImageResource::Clone() const {
  return New(
      mojo::Clone(src),
      mojo::Clone(type),
      mojo::Clone(sizes),
      mojo::Clone(purpose)
  );
}

template <typename T, ManifestImageResource::EnableIfSame<T>*>
bool ManifestImageResource::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->src, other_struct.src))
    return false;
  if (!mojo::Equals(this->type, other_struct.type))
    return false;
  if (!mojo::Equals(this->sizes, other_struct.sizes))
    return false;
  if (!mojo::Equals(this->purpose, other_struct.purpose))
    return false;
  return true;
}

template <typename T, ManifestImageResource::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.src < rhs.src)
    return true;
  if (rhs.src < lhs.src)
    return false;
  if (lhs.type < rhs.type)
    return true;
  if (rhs.type < lhs.type)
    return false;
  if (lhs.sizes < rhs.sizes)
    return true;
  if (rhs.sizes < lhs.sizes)
    return false;
  if (lhs.purpose < rhs.purpose)
    return true;
  if (rhs.purpose < lhs.purpose)
    return false;
  return false;
}
template <typename StructPtrType>
ManifestScreenshotPtr ManifestScreenshot::Clone() const {
  return New(
      mojo::Clone(image),
      mojo::Clone(platform)
  );
}

template <typename T, ManifestScreenshot::EnableIfSame<T>*>
bool ManifestScreenshot::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->image, other_struct.image))
    return false;
  if (!mojo::Equals(this->platform, other_struct.platform))
    return false;
  return true;
}

template <typename T, ManifestScreenshot::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.image < rhs.image)
    return true;
  if (rhs.image < lhs.image)
    return false;
  if (lhs.platform < rhs.platform)
    return true;
  if (rhs.platform < lhs.platform)
    return false;
  return false;
}
template <typename StructPtrType>
ManifestFileFilterPtr ManifestFileFilter::Clone() const {
  return New(
      mojo::Clone(name),
      mojo::Clone(accept)
  );
}

template <typename T, ManifestFileFilter::EnableIfSame<T>*>
bool ManifestFileFilter::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->name, other_struct.name))
    return false;
  if (!mojo::Equals(this->accept, other_struct.accept))
    return false;
  return true;
}

template <typename T, ManifestFileFilter::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.name < rhs.name)
    return true;
  if (rhs.name < lhs.name)
    return false;
  if (lhs.accept < rhs.accept)
    return true;
  if (rhs.accept < lhs.accept)
    return false;
  return false;
}
template <typename StructPtrType>
ManifestProtocolHandlerPtr ManifestProtocolHandler::Clone() const {
  return New(
      mojo::Clone(protocol),
      mojo::Clone(url)
  );
}

template <typename T, ManifestProtocolHandler::EnableIfSame<T>*>
bool ManifestProtocolHandler::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->protocol, other_struct.protocol))
    return false;
  if (!mojo::Equals(this->url, other_struct.url))
    return false;
  return true;
}

template <typename T, ManifestProtocolHandler::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.protocol < rhs.protocol)
    return true;
  if (rhs.protocol < lhs.protocol)
    return false;
  if (lhs.url < rhs.url)
    return true;
  if (rhs.url < lhs.url)
    return false;
  return false;
}
template <typename StructPtrType>
ManifestUrlHandlerPtr ManifestUrlHandler::Clone() const {
  return New(
      mojo::Clone(origin),
      mojo::Clone(has_origin_wildcard)
  );
}

template <typename T, ManifestUrlHandler::EnableIfSame<T>*>
bool ManifestUrlHandler::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->origin, other_struct.origin))
    return false;
  if (!mojo::Equals(this->has_origin_wildcard, other_struct.has_origin_wildcard))
    return false;
  return true;
}

template <typename T, ManifestUrlHandler::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.origin < rhs.origin)
    return true;
  if (rhs.origin < lhs.origin)
    return false;
  if (lhs.has_origin_wildcard < rhs.has_origin_wildcard)
    return true;
  if (rhs.has_origin_wildcard < lhs.has_origin_wildcard)
    return false;
  return false;
}
template <typename StructPtrType>
ManifestLockScreenPtr ManifestLockScreen::Clone() const {
  return New(
      mojo::Clone(start_url)
  );
}

template <typename T, ManifestLockScreen::EnableIfSame<T>*>
bool ManifestLockScreen::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->start_url, other_struct.start_url))
    return false;
  return true;
}

template <typename T, ManifestLockScreen::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.start_url < rhs.start_url)
    return true;
  if (rhs.start_url < lhs.start_url)
    return false;
  return false;
}
template <typename StructPtrType>
ManifestNoteTakingPtr ManifestNoteTaking::Clone() const {
  return New(
      mojo::Clone(new_note_url)
  );
}

template <typename T, ManifestNoteTaking::EnableIfSame<T>*>
bool ManifestNoteTaking::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->new_note_url, other_struct.new_note_url))
    return false;
  return true;
}

template <typename T, ManifestNoteTaking::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.new_note_url < rhs.new_note_url)
    return true;
  if (rhs.new_note_url < lhs.new_note_url)
    return false;
  return false;
}
template <typename StructPtrType>
ManifestRelatedApplicationPtr ManifestRelatedApplication::Clone() const {
  return New(
      mojo::Clone(platform),
      mojo::Clone(url),
      mojo::Clone(id)
  );
}

template <typename T, ManifestRelatedApplication::EnableIfSame<T>*>
bool ManifestRelatedApplication::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->platform, other_struct.platform))
    return false;
  if (!mojo::Equals(this->url, other_struct.url))
    return false;
  if (!mojo::Equals(this->id, other_struct.id))
    return false;
  return true;
}

template <typename T, ManifestRelatedApplication::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.platform < rhs.platform)
    return true;
  if (rhs.platform < lhs.platform)
    return false;
  if (lhs.url < rhs.url)
    return true;
  if (rhs.url < lhs.url)
    return false;
  if (lhs.id < rhs.id)
    return true;
  if (rhs.id < lhs.id)
    return false;
  return false;
}
template <typename StructPtrType>
ManifestShareTargetParamsPtr ManifestShareTargetParams::Clone() const {
  return New(
      mojo::Clone(title),
      mojo::Clone(text),
      mojo::Clone(url),
      mojo::Clone(files)
  );
}

template <typename T, ManifestShareTargetParams::EnableIfSame<T>*>
bool ManifestShareTargetParams::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->title, other_struct.title))
    return false;
  if (!mojo::Equals(this->text, other_struct.text))
    return false;
  if (!mojo::Equals(this->url, other_struct.url))
    return false;
  if (!mojo::Equals(this->files, other_struct.files))
    return false;
  return true;
}

template <typename T, ManifestShareTargetParams::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.title < rhs.title)
    return true;
  if (rhs.title < lhs.title)
    return false;
  if (lhs.text < rhs.text)
    return true;
  if (rhs.text < lhs.text)
    return false;
  if (lhs.url < rhs.url)
    return true;
  if (rhs.url < lhs.url)
    return false;
  if (lhs.files < rhs.files)
    return true;
  if (rhs.files < lhs.files)
    return false;
  return false;
}
template <typename StructPtrType>
ManifestShareTargetPtr ManifestShareTarget::Clone() const {
  return New(
      mojo::Clone(action),
      mojo::Clone(method),
      mojo::Clone(enctype),
      mojo::Clone(params)
  );
}

template <typename T, ManifestShareTarget::EnableIfSame<T>*>
bool ManifestShareTarget::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->action, other_struct.action))
    return false;
  if (!mojo::Equals(this->method, other_struct.method))
    return false;
  if (!mojo::Equals(this->enctype, other_struct.enctype))
    return false;
  if (!mojo::Equals(this->params, other_struct.params))
    return false;
  return true;
}

template <typename T, ManifestShareTarget::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.action < rhs.action)
    return true;
  if (rhs.action < lhs.action)
    return false;
  if (lhs.method < rhs.method)
    return true;
  if (rhs.method < lhs.method)
    return false;
  if (lhs.enctype < rhs.enctype)
    return true;
  if (rhs.enctype < lhs.enctype)
    return false;
  if (lhs.params < rhs.params)
    return true;
  if (rhs.params < lhs.params)
    return false;
  return false;
}
template <typename StructPtrType>
ManifestFileHandlerPtr ManifestFileHandler::Clone() const {
  return New(
      mojo::Clone(action),
      mojo::Clone(name),
      mojo::Clone(icons),
      mojo::Clone(accept),
      mojo::Clone(launch_type)
  );
}

template <typename T, ManifestFileHandler::EnableIfSame<T>*>
bool ManifestFileHandler::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->action, other_struct.action))
    return false;
  if (!mojo::Equals(this->name, other_struct.name))
    return false;
  if (!mojo::Equals(this->icons, other_struct.icons))
    return false;
  if (!mojo::Equals(this->accept, other_struct.accept))
    return false;
  if (!mojo::Equals(this->launch_type, other_struct.launch_type))
    return false;
  return true;
}

template <typename T, ManifestFileHandler::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.action < rhs.action)
    return true;
  if (rhs.action < lhs.action)
    return false;
  if (lhs.name < rhs.name)
    return true;
  if (rhs.name < lhs.name)
    return false;
  if (lhs.icons < rhs.icons)
    return true;
  if (rhs.icons < lhs.icons)
    return false;
  if (lhs.accept < rhs.accept)
    return true;
  if (rhs.accept < lhs.accept)
    return false;
  if (lhs.launch_type < rhs.launch_type)
    return true;
  if (rhs.launch_type < lhs.launch_type)
    return false;
  return false;
}
template <typename StructPtrType>
ManifestTranslationItemPtr ManifestTranslationItem::Clone() const {
  return New(
      mojo::Clone(name),
      mojo::Clone(short_name),
      mojo::Clone(description)
  );
}

template <typename T, ManifestTranslationItem::EnableIfSame<T>*>
bool ManifestTranslationItem::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->name, other_struct.name))
    return false;
  if (!mojo::Equals(this->short_name, other_struct.short_name))
    return false;
  if (!mojo::Equals(this->description, other_struct.description))
    return false;
  return true;
}

template <typename T, ManifestTranslationItem::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.name < rhs.name)
    return true;
  if (rhs.name < lhs.name)
    return false;
  if (lhs.short_name < rhs.short_name)
    return true;
  if (rhs.short_name < lhs.short_name)
    return false;
  if (lhs.description < rhs.description)
    return true;
  if (rhs.description < lhs.description)
    return false;
  return false;
}
template <typename StructPtrType>
ManifestUserPreferencesPtr ManifestUserPreferences::Clone() const {
  return New(
      mojo::Clone(color_scheme_dark)
  );
}

template <typename T, ManifestUserPreferences::EnableIfSame<T>*>
bool ManifestUserPreferences::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->color_scheme_dark, other_struct.color_scheme_dark))
    return false;
  return true;
}

template <typename T, ManifestUserPreferences::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.color_scheme_dark < rhs.color_scheme_dark)
    return true;
  if (rhs.color_scheme_dark < lhs.color_scheme_dark)
    return false;
  return false;
}
template <typename StructPtrType>
ManifestUserPreferenceOverridesPtr ManifestUserPreferenceOverrides::Clone() const {
  return New(
      mojo::Clone(has_theme_color),
      mojo::Clone(theme_color),
      mojo::Clone(has_background_color),
      mojo::Clone(background_color)
  );
}

template <typename T, ManifestUserPreferenceOverrides::EnableIfSame<T>*>
bool ManifestUserPreferenceOverrides::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->has_theme_color, other_struct.has_theme_color))
    return false;
  if (!mojo::Equals(this->theme_color, other_struct.theme_color))
    return false;
  if (!mojo::Equals(this->has_background_color, other_struct.has_background_color))
    return false;
  if (!mojo::Equals(this->background_color, other_struct.background_color))
    return false;
  return true;
}

template <typename T, ManifestUserPreferenceOverrides::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.has_theme_color < rhs.has_theme_color)
    return true;
  if (rhs.has_theme_color < lhs.has_theme_color)
    return false;
  if (lhs.theme_color < rhs.theme_color)
    return true;
  if (rhs.theme_color < lhs.theme_color)
    return false;
  if (lhs.has_background_color < rhs.has_background_color)
    return true;
  if (rhs.has_background_color < lhs.has_background_color)
    return false;
  if (lhs.background_color < rhs.background_color)
    return true;
  if (rhs.background_color < lhs.background_color)
    return false;
  return false;
}
template <typename StructPtrType>
ManifestTabStripPtr ManifestTabStrip::Clone() const {
  return New(
      mojo::Clone(home_tab),
      mojo::Clone(new_tab_button)
  );
}

template <typename T, ManifestTabStrip::EnableIfSame<T>*>
bool ManifestTabStrip::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->home_tab, other_struct.home_tab))
    return false;
  if (!mojo::Equals(this->new_tab_button, other_struct.new_tab_button))
    return false;
  return true;
}

template <typename T, ManifestTabStrip::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.home_tab < rhs.home_tab)
    return true;
  if (rhs.home_tab < lhs.home_tab)
    return false;
  if (lhs.new_tab_button < rhs.new_tab_button)
    return true;
  if (rhs.new_tab_button < lhs.new_tab_button)
    return false;
  return false;
}
template <typename StructPtrType>
HomeTabParamsPtr HomeTabParams::Clone() const {
  return New(
      mojo::Clone(icons)
  );
}

template <typename T, HomeTabParams::EnableIfSame<T>*>
bool HomeTabParams::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->icons, other_struct.icons))
    return false;
  return true;
}

template <typename T, HomeTabParams::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.icons < rhs.icons)
    return true;
  if (rhs.icons < lhs.icons)
    return false;
  return false;
}
template <typename StructPtrType>
NewTabButtonParamsPtr NewTabButtonParams::Clone() const {
  return New(
      mojo::Clone(url)
  );
}

template <typename T, NewTabButtonParams::EnableIfSame<T>*>
bool NewTabButtonParams::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->url, other_struct.url))
    return false;
  return true;
}

template <typename T, NewTabButtonParams::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.url < rhs.url)
    return true;
  if (rhs.url < lhs.url)
    return false;
  return false;
}
template <typename StructPtrType>
ManifestDebugInfoPtr ManifestDebugInfo::Clone() const {
  return New(
      mojo::Clone(errors),
      mojo::Clone(raw_manifest)
  );
}

template <typename T, ManifestDebugInfo::EnableIfSame<T>*>
bool ManifestDebugInfo::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->errors, other_struct.errors))
    return false;
  if (!mojo::Equals(this->raw_manifest, other_struct.raw_manifest))
    return false;
  return true;
}

template <typename T, ManifestDebugInfo::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.errors < rhs.errors)
    return true;
  if (rhs.errors < lhs.errors)
    return false;
  if (lhs.raw_manifest < rhs.raw_manifest)
    return true;
  if (rhs.raw_manifest < lhs.raw_manifest)
    return false;
  return false;
}
template <typename StructPtrType>
ManifestErrorPtr ManifestError::Clone() const {
  return New(
      mojo::Clone(message),
      mojo::Clone(critical),
      mojo::Clone(line),
      mojo::Clone(column)
  );
}

template <typename T, ManifestError::EnableIfSame<T>*>
bool ManifestError::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->message, other_struct.message))
    return false;
  if (!mojo::Equals(this->critical, other_struct.critical))
    return false;
  if (!mojo::Equals(this->line, other_struct.line))
    return false;
  if (!mojo::Equals(this->column, other_struct.column))
    return false;
  return true;
}

template <typename T, ManifestError::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.message < rhs.message)
    return true;
  if (rhs.message < lhs.message)
    return false;
  if (lhs.critical < rhs.critical)
    return true;
  if (rhs.critical < lhs.critical)
    return false;
  if (lhs.line < rhs.line)
    return true;
  if (rhs.line < lhs.line)
    return false;
  if (lhs.column < rhs.column)
    return true;
  if (rhs.column < lhs.column)
    return false;
  return false;
}


}  // namespace blink
}  // namespace mojom
}  // namespace blink

namespace mojo {


template <>
struct PLATFORM_EXPORT StructTraits<::blink::mojom::blink::Manifest::DataView,
                                         ::blink::mojom::blink::ManifestPtr> {
  static bool IsNull(const ::blink::mojom::blink::ManifestPtr& input) { return !input; }
  static void SetToNull(::blink::mojom::blink::ManifestPtr* output) { output->reset(); }

  static const decltype(::blink::mojom::blink::Manifest::name)& name(
      const ::blink::mojom::blink::ManifestPtr& input) {
    return input->name;
  }

  static const decltype(::blink::mojom::blink::Manifest::short_name)& short_name(
      const ::blink::mojom::blink::ManifestPtr& input) {
    return input->short_name;
  }

  static const decltype(::blink::mojom::blink::Manifest::description)& description(
      const ::blink::mojom::blink::ManifestPtr& input) {
    return input->description;
  }

  static const decltype(::blink::mojom::blink::Manifest::id)& id(
      const ::blink::mojom::blink::ManifestPtr& input) {
    return input->id;
  }

  static const decltype(::blink::mojom::blink::Manifest::start_url)& start_url(
      const ::blink::mojom::blink::ManifestPtr& input) {
    return input->start_url;
  }

  static decltype(::blink::mojom::blink::Manifest::display) display(
      const ::blink::mojom::blink::ManifestPtr& input) {
    return input->display;
  }

  static const decltype(::blink::mojom::blink::Manifest::display_override)& display_override(
      const ::blink::mojom::blink::ManifestPtr& input) {
    return input->display_override;
  }

  static decltype(::blink::mojom::blink::Manifest::orientation) orientation(
      const ::blink::mojom::blink::ManifestPtr& input) {
    return input->orientation;
  }

  static const decltype(::blink::mojom::blink::Manifest::icons)& icons(
      const ::blink::mojom::blink::ManifestPtr& input) {
    return input->icons;
  }

  static const decltype(::blink::mojom::blink::Manifest::screenshots)& screenshots(
      const ::blink::mojom::blink::ManifestPtr& input) {
    return input->screenshots;
  }

  static const decltype(::blink::mojom::blink::Manifest::shortcuts)& shortcuts(
      const ::blink::mojom::blink::ManifestPtr& input) {
    return input->shortcuts;
  }

  static const decltype(::blink::mojom::blink::Manifest::share_target)& share_target(
      const ::blink::mojom::blink::ManifestPtr& input) {
    return input->share_target;
  }

  static const decltype(::blink::mojom::blink::Manifest::file_handlers)& file_handlers(
      const ::blink::mojom::blink::ManifestPtr& input) {
    return input->file_handlers;
  }

  static const decltype(::blink::mojom::blink::Manifest::protocol_handlers)& protocol_handlers(
      const ::blink::mojom::blink::ManifestPtr& input) {
    return input->protocol_handlers;
  }

  static const decltype(::blink::mojom::blink::Manifest::url_handlers)& url_handlers(
      const ::blink::mojom::blink::ManifestPtr& input) {
    return input->url_handlers;
  }

  static const decltype(::blink::mojom::blink::Manifest::lock_screen)& lock_screen(
      const ::blink::mojom::blink::ManifestPtr& input) {
    return input->lock_screen;
  }

  static const decltype(::blink::mojom::blink::Manifest::note_taking)& note_taking(
      const ::blink::mojom::blink::ManifestPtr& input) {
    return input->note_taking;
  }

  static const decltype(::blink::mojom::blink::Manifest::related_applications)& related_applications(
      const ::blink::mojom::blink::ManifestPtr& input) {
    return input->related_applications;
  }

  static decltype(::blink::mojom::blink::Manifest::prefer_related_applications) prefer_related_applications(
      const ::blink::mojom::blink::ManifestPtr& input) {
    return input->prefer_related_applications;
  }

  static decltype(::blink::mojom::blink::Manifest::has_theme_color) has_theme_color(
      const ::blink::mojom::blink::ManifestPtr& input) {
    return input->has_theme_color;
  }

  static decltype(::blink::mojom::blink::Manifest::theme_color) theme_color(
      const ::blink::mojom::blink::ManifestPtr& input) {
    return input->theme_color;
  }

  static decltype(::blink::mojom::blink::Manifest::has_background_color) has_background_color(
      const ::blink::mojom::blink::ManifestPtr& input) {
    return input->has_background_color;
  }

  static decltype(::blink::mojom::blink::Manifest::background_color) background_color(
      const ::blink::mojom::blink::ManifestPtr& input) {
    return input->background_color;
  }

  static const decltype(::blink::mojom::blink::Manifest::gcm_sender_id)& gcm_sender_id(
      const ::blink::mojom::blink::ManifestPtr& input) {
    return input->gcm_sender_id;
  }

  static const decltype(::blink::mojom::blink::Manifest::scope)& scope(
      const ::blink::mojom::blink::ManifestPtr& input) {
    return input->scope;
  }

  static decltype(::blink::mojom::blink::Manifest::capture_links) capture_links(
      const ::blink::mojom::blink::ManifestPtr& input) {
    return input->capture_links;
  }

  static decltype(::blink::mojom::blink::Manifest::isolated_storage) isolated_storage(
      const ::blink::mojom::blink::ManifestPtr& input) {
    return input->isolated_storage;
  }

  static const decltype(::blink::mojom::blink::Manifest::permissions_policy)& permissions_policy(
      const ::blink::mojom::blink::ManifestPtr& input) {
    return input->permissions_policy;
  }

  static const decltype(::blink::mojom::blink::Manifest::launch_handler)& launch_handler(
      const ::blink::mojom::blink::ManifestPtr& input) {
    return input->launch_handler;
  }

  static const decltype(::blink::mojom::blink::Manifest::translations)& translations(
      const ::blink::mojom::blink::ManifestPtr& input) {
    return input->translations;
  }

  static const decltype(::blink::mojom::blink::Manifest::user_preferences)& user_preferences(
      const ::blink::mojom::blink::ManifestPtr& input) {
    return input->user_preferences;
  }

  static const decltype(::blink::mojom::blink::Manifest::tab_strip)& tab_strip(
      const ::blink::mojom::blink::ManifestPtr& input) {
    return input->tab_strip;
  }

  static bool Read(::blink::mojom::blink::Manifest::DataView input, ::blink::mojom::blink::ManifestPtr* output);
};


template <>
struct PLATFORM_EXPORT StructTraits<::blink::mojom::blink::ManifestShortcutItem::DataView,
                                         ::blink::mojom::blink::ManifestShortcutItemPtr> {
  static bool IsNull(const ::blink::mojom::blink::ManifestShortcutItemPtr& input) { return !input; }
  static void SetToNull(::blink::mojom::blink::ManifestShortcutItemPtr* output) { output->reset(); }

  static const decltype(::blink::mojom::blink::ManifestShortcutItem::name)& name(
      const ::blink::mojom::blink::ManifestShortcutItemPtr& input) {
    return input->name;
  }

  static const decltype(::blink::mojom::blink::ManifestShortcutItem::short_name)& short_name(
      const ::blink::mojom::blink::ManifestShortcutItemPtr& input) {
    return input->short_name;
  }

  static const decltype(::blink::mojom::blink::ManifestShortcutItem::description)& description(
      const ::blink::mojom::blink::ManifestShortcutItemPtr& input) {
    return input->description;
  }

  static const decltype(::blink::mojom::blink::ManifestShortcutItem::url)& url(
      const ::blink::mojom::blink::ManifestShortcutItemPtr& input) {
    return input->url;
  }

  static const decltype(::blink::mojom::blink::ManifestShortcutItem::icons)& icons(
      const ::blink::mojom::blink::ManifestShortcutItemPtr& input) {
    return input->icons;
  }

  static bool Read(::blink::mojom::blink::ManifestShortcutItem::DataView input, ::blink::mojom::blink::ManifestShortcutItemPtr* output);
};


template <>
struct PLATFORM_EXPORT StructTraits<::blink::mojom::blink::ManifestImageResource::DataView,
                                         ::blink::mojom::blink::ManifestImageResourcePtr> {
  static bool IsNull(const ::blink::mojom::blink::ManifestImageResourcePtr& input) { return !input; }
  static void SetToNull(::blink::mojom::blink::ManifestImageResourcePtr* output) { output->reset(); }

  static const decltype(::blink::mojom::blink::ManifestImageResource::src)& src(
      const ::blink::mojom::blink::ManifestImageResourcePtr& input) {
    return input->src;
  }

  static const decltype(::blink::mojom::blink::ManifestImageResource::type)& type(
      const ::blink::mojom::blink::ManifestImageResourcePtr& input) {
    return input->type;
  }

  static const decltype(::blink::mojom::blink::ManifestImageResource::sizes)& sizes(
      const ::blink::mojom::blink::ManifestImageResourcePtr& input) {
    return input->sizes;
  }

  static const decltype(::blink::mojom::blink::ManifestImageResource::purpose)& purpose(
      const ::blink::mojom::blink::ManifestImageResourcePtr& input) {
    return input->purpose;
  }

  static bool Read(::blink::mojom::blink::ManifestImageResource::DataView input, ::blink::mojom::blink::ManifestImageResourcePtr* output);
};


template <>
struct PLATFORM_EXPORT StructTraits<::blink::mojom::blink::ManifestScreenshot::DataView,
                                         ::blink::mojom::blink::ManifestScreenshotPtr> {
  static bool IsNull(const ::blink::mojom::blink::ManifestScreenshotPtr& input) { return !input; }
  static void SetToNull(::blink::mojom::blink::ManifestScreenshotPtr* output) { output->reset(); }

  static const decltype(::blink::mojom::blink::ManifestScreenshot::image)& image(
      const ::blink::mojom::blink::ManifestScreenshotPtr& input) {
    return input->image;
  }

  static decltype(::blink::mojom::blink::ManifestScreenshot::platform) platform(
      const ::blink::mojom::blink::ManifestScreenshotPtr& input) {
    return input->platform;
  }

  static bool Read(::blink::mojom::blink::ManifestScreenshot::DataView input, ::blink::mojom::blink::ManifestScreenshotPtr* output);
};


template <>
struct PLATFORM_EXPORT StructTraits<::blink::mojom::blink::ManifestFileFilter::DataView,
                                         ::blink::mojom::blink::ManifestFileFilterPtr> {
  static bool IsNull(const ::blink::mojom::blink::ManifestFileFilterPtr& input) { return !input; }
  static void SetToNull(::blink::mojom::blink::ManifestFileFilterPtr* output) { output->reset(); }

  static const decltype(::blink::mojom::blink::ManifestFileFilter::name)& name(
      const ::blink::mojom::blink::ManifestFileFilterPtr& input) {
    return input->name;
  }

  static const decltype(::blink::mojom::blink::ManifestFileFilter::accept)& accept(
      const ::blink::mojom::blink::ManifestFileFilterPtr& input) {
    return input->accept;
  }

  static bool Read(::blink::mojom::blink::ManifestFileFilter::DataView input, ::blink::mojom::blink::ManifestFileFilterPtr* output);
};


template <>
struct PLATFORM_EXPORT StructTraits<::blink::mojom::blink::ManifestProtocolHandler::DataView,
                                         ::blink::mojom::blink::ManifestProtocolHandlerPtr> {
  static bool IsNull(const ::blink::mojom::blink::ManifestProtocolHandlerPtr& input) { return !input; }
  static void SetToNull(::blink::mojom::blink::ManifestProtocolHandlerPtr* output) { output->reset(); }

  static const decltype(::blink::mojom::blink::ManifestProtocolHandler::protocol)& protocol(
      const ::blink::mojom::blink::ManifestProtocolHandlerPtr& input) {
    return input->protocol;
  }

  static const decltype(::blink::mojom::blink::ManifestProtocolHandler::url)& url(
      const ::blink::mojom::blink::ManifestProtocolHandlerPtr& input) {
    return input->url;
  }

  static bool Read(::blink::mojom::blink::ManifestProtocolHandler::DataView input, ::blink::mojom::blink::ManifestProtocolHandlerPtr* output);
};


template <>
struct PLATFORM_EXPORT StructTraits<::blink::mojom::blink::ManifestUrlHandler::DataView,
                                         ::blink::mojom::blink::ManifestUrlHandlerPtr> {
  static bool IsNull(const ::blink::mojom::blink::ManifestUrlHandlerPtr& input) { return !input; }
  static void SetToNull(::blink::mojom::blink::ManifestUrlHandlerPtr* output) { output->reset(); }

  static const decltype(::blink::mojom::blink::ManifestUrlHandler::origin)& origin(
      const ::blink::mojom::blink::ManifestUrlHandlerPtr& input) {
    return input->origin;
  }

  static decltype(::blink::mojom::blink::ManifestUrlHandler::has_origin_wildcard) has_origin_wildcard(
      const ::blink::mojom::blink::ManifestUrlHandlerPtr& input) {
    return input->has_origin_wildcard;
  }

  static bool Read(::blink::mojom::blink::ManifestUrlHandler::DataView input, ::blink::mojom::blink::ManifestUrlHandlerPtr* output);
};


template <>
struct PLATFORM_EXPORT StructTraits<::blink::mojom::blink::ManifestLockScreen::DataView,
                                         ::blink::mojom::blink::ManifestLockScreenPtr> {
  static bool IsNull(const ::blink::mojom::blink::ManifestLockScreenPtr& input) { return !input; }
  static void SetToNull(::blink::mojom::blink::ManifestLockScreenPtr* output) { output->reset(); }

  static const decltype(::blink::mojom::blink::ManifestLockScreen::start_url)& start_url(
      const ::blink::mojom::blink::ManifestLockScreenPtr& input) {
    return input->start_url;
  }

  static bool Read(::blink::mojom::blink::ManifestLockScreen::DataView input, ::blink::mojom::blink::ManifestLockScreenPtr* output);
};


template <>
struct PLATFORM_EXPORT StructTraits<::blink::mojom::blink::ManifestNoteTaking::DataView,
                                         ::blink::mojom::blink::ManifestNoteTakingPtr> {
  static bool IsNull(const ::blink::mojom::blink::ManifestNoteTakingPtr& input) { return !input; }
  static void SetToNull(::blink::mojom::blink::ManifestNoteTakingPtr* output) { output->reset(); }

  static const decltype(::blink::mojom::blink::ManifestNoteTaking::new_note_url)& new_note_url(
      const ::blink::mojom::blink::ManifestNoteTakingPtr& input) {
    return input->new_note_url;
  }

  static bool Read(::blink::mojom::blink::ManifestNoteTaking::DataView input, ::blink::mojom::blink::ManifestNoteTakingPtr* output);
};


template <>
struct PLATFORM_EXPORT StructTraits<::blink::mojom::blink::ManifestRelatedApplication::DataView,
                                         ::blink::mojom::blink::ManifestRelatedApplicationPtr> {
  static bool IsNull(const ::blink::mojom::blink::ManifestRelatedApplicationPtr& input) { return !input; }
  static void SetToNull(::blink::mojom::blink::ManifestRelatedApplicationPtr* output) { output->reset(); }

  static const decltype(::blink::mojom::blink::ManifestRelatedApplication::platform)& platform(
      const ::blink::mojom::blink::ManifestRelatedApplicationPtr& input) {
    return input->platform;
  }

  static const decltype(::blink::mojom::blink::ManifestRelatedApplication::url)& url(
      const ::blink::mojom::blink::ManifestRelatedApplicationPtr& input) {
    return input->url;
  }

  static const decltype(::blink::mojom::blink::ManifestRelatedApplication::id)& id(
      const ::blink::mojom::blink::ManifestRelatedApplicationPtr& input) {
    return input->id;
  }

  static bool Read(::blink::mojom::blink::ManifestRelatedApplication::DataView input, ::blink::mojom::blink::ManifestRelatedApplicationPtr* output);
};


template <>
struct PLATFORM_EXPORT StructTraits<::blink::mojom::blink::ManifestShareTargetParams::DataView,
                                         ::blink::mojom::blink::ManifestShareTargetParamsPtr> {
  static bool IsNull(const ::blink::mojom::blink::ManifestShareTargetParamsPtr& input) { return !input; }
  static void SetToNull(::blink::mojom::blink::ManifestShareTargetParamsPtr* output) { output->reset(); }

  static const decltype(::blink::mojom::blink::ManifestShareTargetParams::title)& title(
      const ::blink::mojom::blink::ManifestShareTargetParamsPtr& input) {
    return input->title;
  }

  static const decltype(::blink::mojom::blink::ManifestShareTargetParams::text)& text(
      const ::blink::mojom::blink::ManifestShareTargetParamsPtr& input) {
    return input->text;
  }

  static const decltype(::blink::mojom::blink::ManifestShareTargetParams::url)& url(
      const ::blink::mojom::blink::ManifestShareTargetParamsPtr& input) {
    return input->url;
  }

  static const decltype(::blink::mojom::blink::ManifestShareTargetParams::files)& files(
      const ::blink::mojom::blink::ManifestShareTargetParamsPtr& input) {
    return input->files;
  }

  static bool Read(::blink::mojom::blink::ManifestShareTargetParams::DataView input, ::blink::mojom::blink::ManifestShareTargetParamsPtr* output);
};


template <>
struct PLATFORM_EXPORT StructTraits<::blink::mojom::blink::ManifestShareTarget::DataView,
                                         ::blink::mojom::blink::ManifestShareTargetPtr> {
  static bool IsNull(const ::blink::mojom::blink::ManifestShareTargetPtr& input) { return !input; }
  static void SetToNull(::blink::mojom::blink::ManifestShareTargetPtr* output) { output->reset(); }

  static const decltype(::blink::mojom::blink::ManifestShareTarget::action)& action(
      const ::blink::mojom::blink::ManifestShareTargetPtr& input) {
    return input->action;
  }

  static decltype(::blink::mojom::blink::ManifestShareTarget::method) method(
      const ::blink::mojom::blink::ManifestShareTargetPtr& input) {
    return input->method;
  }

  static decltype(::blink::mojom::blink::ManifestShareTarget::enctype) enctype(
      const ::blink::mojom::blink::ManifestShareTargetPtr& input) {
    return input->enctype;
  }

  static const decltype(::blink::mojom::blink::ManifestShareTarget::params)& params(
      const ::blink::mojom::blink::ManifestShareTargetPtr& input) {
    return input->params;
  }

  static bool Read(::blink::mojom::blink::ManifestShareTarget::DataView input, ::blink::mojom::blink::ManifestShareTargetPtr* output);
};


template <>
struct PLATFORM_EXPORT StructTraits<::blink::mojom::blink::ManifestFileHandler::DataView,
                                         ::blink::mojom::blink::ManifestFileHandlerPtr> {
  static bool IsNull(const ::blink::mojom::blink::ManifestFileHandlerPtr& input) { return !input; }
  static void SetToNull(::blink::mojom::blink::ManifestFileHandlerPtr* output) { output->reset(); }

  static const decltype(::blink::mojom::blink::ManifestFileHandler::action)& action(
      const ::blink::mojom::blink::ManifestFileHandlerPtr& input) {
    return input->action;
  }

  static const decltype(::blink::mojom::blink::ManifestFileHandler::name)& name(
      const ::blink::mojom::blink::ManifestFileHandlerPtr& input) {
    return input->name;
  }

  static const decltype(::blink::mojom::blink::ManifestFileHandler::icons)& icons(
      const ::blink::mojom::blink::ManifestFileHandlerPtr& input) {
    return input->icons;
  }

  static const decltype(::blink::mojom::blink::ManifestFileHandler::accept)& accept(
      const ::blink::mojom::blink::ManifestFileHandlerPtr& input) {
    return input->accept;
  }

  static decltype(::blink::mojom::blink::ManifestFileHandler::launch_type) launch_type(
      const ::blink::mojom::blink::ManifestFileHandlerPtr& input) {
    return input->launch_type;
  }

  static bool Read(::blink::mojom::blink::ManifestFileHandler::DataView input, ::blink::mojom::blink::ManifestFileHandlerPtr* output);
};


template <>
struct PLATFORM_EXPORT StructTraits<::blink::mojom::blink::ManifestTranslationItem::DataView,
                                         ::blink::mojom::blink::ManifestTranslationItemPtr> {
  static bool IsNull(const ::blink::mojom::blink::ManifestTranslationItemPtr& input) { return !input; }
  static void SetToNull(::blink::mojom::blink::ManifestTranslationItemPtr* output) { output->reset(); }

  static const decltype(::blink::mojom::blink::ManifestTranslationItem::name)& name(
      const ::blink::mojom::blink::ManifestTranslationItemPtr& input) {
    return input->name;
  }

  static const decltype(::blink::mojom::blink::ManifestTranslationItem::short_name)& short_name(
      const ::blink::mojom::blink::ManifestTranslationItemPtr& input) {
    return input->short_name;
  }

  static const decltype(::blink::mojom::blink::ManifestTranslationItem::description)& description(
      const ::blink::mojom::blink::ManifestTranslationItemPtr& input) {
    return input->description;
  }

  static bool Read(::blink::mojom::blink::ManifestTranslationItem::DataView input, ::blink::mojom::blink::ManifestTranslationItemPtr* output);
};


template <>
struct PLATFORM_EXPORT StructTraits<::blink::mojom::blink::ManifestUserPreferences::DataView,
                                         ::blink::mojom::blink::ManifestUserPreferencesPtr> {
  static bool IsNull(const ::blink::mojom::blink::ManifestUserPreferencesPtr& input) { return !input; }
  static void SetToNull(::blink::mojom::blink::ManifestUserPreferencesPtr* output) { output->reset(); }

  static const decltype(::blink::mojom::blink::ManifestUserPreferences::color_scheme_dark)& color_scheme_dark(
      const ::blink::mojom::blink::ManifestUserPreferencesPtr& input) {
    return input->color_scheme_dark;
  }

  static bool Read(::blink::mojom::blink::ManifestUserPreferences::DataView input, ::blink::mojom::blink::ManifestUserPreferencesPtr* output);
};


template <>
struct PLATFORM_EXPORT StructTraits<::blink::mojom::blink::ManifestUserPreferenceOverrides::DataView,
                                         ::blink::mojom::blink::ManifestUserPreferenceOverridesPtr> {
  static bool IsNull(const ::blink::mojom::blink::ManifestUserPreferenceOverridesPtr& input) { return !input; }
  static void SetToNull(::blink::mojom::blink::ManifestUserPreferenceOverridesPtr* output) { output->reset(); }

  static decltype(::blink::mojom::blink::ManifestUserPreferenceOverrides::has_theme_color) has_theme_color(
      const ::blink::mojom::blink::ManifestUserPreferenceOverridesPtr& input) {
    return input->has_theme_color;
  }

  static decltype(::blink::mojom::blink::ManifestUserPreferenceOverrides::theme_color) theme_color(
      const ::blink::mojom::blink::ManifestUserPreferenceOverridesPtr& input) {
    return input->theme_color;
  }

  static decltype(::blink::mojom::blink::ManifestUserPreferenceOverrides::has_background_color) has_background_color(
      const ::blink::mojom::blink::ManifestUserPreferenceOverridesPtr& input) {
    return input->has_background_color;
  }

  static decltype(::blink::mojom::blink::ManifestUserPreferenceOverrides::background_color) background_color(
      const ::blink::mojom::blink::ManifestUserPreferenceOverridesPtr& input) {
    return input->background_color;
  }

  static bool Read(::blink::mojom::blink::ManifestUserPreferenceOverrides::DataView input, ::blink::mojom::blink::ManifestUserPreferenceOverridesPtr* output);
};


template <>
struct PLATFORM_EXPORT StructTraits<::blink::mojom::blink::ManifestTabStrip::DataView,
                                         ::blink::mojom::blink::ManifestTabStripPtr> {
  static bool IsNull(const ::blink::mojom::blink::ManifestTabStripPtr& input) { return !input; }
  static void SetToNull(::blink::mojom::blink::ManifestTabStripPtr* output) { output->reset(); }

  static const decltype(::blink::mojom::blink::ManifestTabStrip::home_tab)& home_tab(
      const ::blink::mojom::blink::ManifestTabStripPtr& input) {
    return input->home_tab;
  }

  static const decltype(::blink::mojom::blink::ManifestTabStrip::new_tab_button)& new_tab_button(
      const ::blink::mojom::blink::ManifestTabStripPtr& input) {
    return input->new_tab_button;
  }

  static bool Read(::blink::mojom::blink::ManifestTabStrip::DataView input, ::blink::mojom::blink::ManifestTabStripPtr* output);
};


template <>
struct PLATFORM_EXPORT StructTraits<::blink::mojom::blink::HomeTabParams::DataView,
                                         ::blink::mojom::blink::HomeTabParamsPtr> {
  static bool IsNull(const ::blink::mojom::blink::HomeTabParamsPtr& input) { return !input; }
  static void SetToNull(::blink::mojom::blink::HomeTabParamsPtr* output) { output->reset(); }

  static const decltype(::blink::mojom::blink::HomeTabParams::icons)& icons(
      const ::blink::mojom::blink::HomeTabParamsPtr& input) {
    return input->icons;
  }

  static bool Read(::blink::mojom::blink::HomeTabParams::DataView input, ::blink::mojom::blink::HomeTabParamsPtr* output);
};


template <>
struct PLATFORM_EXPORT StructTraits<::blink::mojom::blink::NewTabButtonParams::DataView,
                                         ::blink::mojom::blink::NewTabButtonParamsPtr> {
  static bool IsNull(const ::blink::mojom::blink::NewTabButtonParamsPtr& input) { return !input; }
  static void SetToNull(::blink::mojom::blink::NewTabButtonParamsPtr* output) { output->reset(); }

  static const decltype(::blink::mojom::blink::NewTabButtonParams::url)& url(
      const ::blink::mojom::blink::NewTabButtonParamsPtr& input) {
    return input->url;
  }

  static bool Read(::blink::mojom::blink::NewTabButtonParams::DataView input, ::blink::mojom::blink::NewTabButtonParamsPtr* output);
};


template <>
struct PLATFORM_EXPORT StructTraits<::blink::mojom::blink::ManifestDebugInfo::DataView,
                                         ::blink::mojom::blink::ManifestDebugInfoPtr> {
  static bool IsNull(const ::blink::mojom::blink::ManifestDebugInfoPtr& input) { return !input; }
  static void SetToNull(::blink::mojom::blink::ManifestDebugInfoPtr* output) { output->reset(); }

  static const decltype(::blink::mojom::blink::ManifestDebugInfo::errors)& errors(
      const ::blink::mojom::blink::ManifestDebugInfoPtr& input) {
    return input->errors;
  }

  static const decltype(::blink::mojom::blink::ManifestDebugInfo::raw_manifest)& raw_manifest(
      const ::blink::mojom::blink::ManifestDebugInfoPtr& input) {
    return input->raw_manifest;
  }

  static bool Read(::blink::mojom::blink::ManifestDebugInfo::DataView input, ::blink::mojom::blink::ManifestDebugInfoPtr* output);
};


template <>
struct PLATFORM_EXPORT StructTraits<::blink::mojom::blink::ManifestError::DataView,
                                         ::blink::mojom::blink::ManifestErrorPtr> {
  static bool IsNull(const ::blink::mojom::blink::ManifestErrorPtr& input) { return !input; }
  static void SetToNull(::blink::mojom::blink::ManifestErrorPtr* output) { output->reset(); }

  static const decltype(::blink::mojom::blink::ManifestError::message)& message(
      const ::blink::mojom::blink::ManifestErrorPtr& input) {
    return input->message;
  }

  static decltype(::blink::mojom::blink::ManifestError::critical) critical(
      const ::blink::mojom::blink::ManifestErrorPtr& input) {
    return input->critical;
  }

  static decltype(::blink::mojom::blink::ManifestError::line) line(
      const ::blink::mojom::blink::ManifestErrorPtr& input) {
    return input->line;
  }

  static decltype(::blink::mojom::blink::ManifestError::column) column(
      const ::blink::mojom::blink::ManifestErrorPtr& input) {
    return input->column;
  }

  static bool Read(::blink::mojom::blink::ManifestError::DataView input, ::blink::mojom::blink::ManifestErrorPtr* output);
};


template <>
struct PLATFORM_EXPORT UnionTraits<::blink::mojom::blink::HomeTabUnion::DataView,
                                        ::blink::mojom::blink::HomeTabUnionPtr> {
  static bool IsNull(const ::blink::mojom::blink::HomeTabUnionPtr& input) { return !input; }
  static void SetToNull(::blink::mojom::blink::HomeTabUnionPtr* output) { output->reset(); }

  static ::blink::mojom::blink::HomeTabUnion::Tag GetTag(const ::blink::mojom::blink::HomeTabUnionPtr& input) {
    return input->which();
  }

  static  ::blink::mojom::blink::TabStripMemberVisibility visibility(const ::blink::mojom::blink::HomeTabUnionPtr& input) {
    return input->get_visibility();
  }

  static const ::blink::mojom::blink::HomeTabParamsPtr& params(const ::blink::mojom::blink::HomeTabUnionPtr& input) {
    return input->get_params();
  }

  static bool Read(::blink::mojom::blink::HomeTabUnion::DataView input, ::blink::mojom::blink::HomeTabUnionPtr* output);
};


template <>
struct PLATFORM_EXPORT UnionTraits<::blink::mojom::blink::NewTabButtonUnion::DataView,
                                        ::blink::mojom::blink::NewTabButtonUnionPtr> {
  static bool IsNull(const ::blink::mojom::blink::NewTabButtonUnionPtr& input) { return !input; }
  static void SetToNull(::blink::mojom::blink::NewTabButtonUnionPtr* output) { output->reset(); }

  static ::blink::mojom::blink::NewTabButtonUnion::Tag GetTag(const ::blink::mojom::blink::NewTabButtonUnionPtr& input) {
    return input->which();
  }

  static  ::blink::mojom::blink::TabStripMemberVisibility visibility(const ::blink::mojom::blink::NewTabButtonUnionPtr& input) {
    return input->get_visibility();
  }

  static const ::blink::mojom::blink::NewTabButtonParamsPtr& params(const ::blink::mojom::blink::NewTabButtonUnionPtr& input) {
    return input->get_params();
  }

  static bool Read(::blink::mojom::blink::NewTabButtonUnion::DataView input, ::blink::mojom::blink::NewTabButtonUnionPtr* output);
};

}  // namespace mojo

#endif  // THIRD_PARTY_BLINK_PUBLIC_MOJOM_MANIFEST_MANIFEST_MOJOM_BLINK_H_