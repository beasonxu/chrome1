// third_party/blink/public/mojom/frame/remote_frame.mojom.cc is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2013 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#if defined(__clang__)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-private-field"
#endif

#include "third_party/blink/public/mojom/frame/remote_frame.mojom.h"

#include <math.h>
#include <stdint.h>
#include <utility>

#include "base/debug/alias.h"
#include "base/hash/md5_constexpr.h"
#include "base/run_loop.h"
#include "base/strings/string_number_conversions.h"
#include "base/trace_event/trace_event.h"
#include "base/trace_event/typed_macros.h"
#include "mojo/public/cpp/bindings/lib/generated_code_util.h"
#include "mojo/public/cpp/bindings/lib/message_internal.h"
#include "mojo/public/cpp/bindings/lib/send_message_helper.h"
#include "mojo/public/cpp/bindings/lib/proxy_to_responder.h"
#include "mojo/public/cpp/bindings/lib/serialization_util.h"
#include "mojo/public/cpp/bindings/lib/unserialized_message_context.h"
#include "mojo/public/cpp/bindings/lib/validate_params.h"
#include "mojo/public/cpp/bindings/lib/validation_errors.h"
#include "mojo/public/cpp/bindings/mojo_buildflags.h"
#include "mojo/public/interfaces/bindings/interface_control_messages.mojom.h"
#include "third_party/perfetto/include/perfetto/tracing/traced_value.h"

#include "third_party/blink/public/mojom/frame/remote_frame.mojom-params-data.h"
#include "third_party/blink/public/mojom/frame/remote_frame.mojom-shared-message-ids.h"

#include "third_party/blink/public/mojom/frame/remote_frame.mojom-import-headers.h"
#include "third_party/blink/public/mojom/frame/remote_frame.mojom-test-utils.h"


#ifndef THIRD_PARTY_BLINK_PUBLIC_MOJOM_FRAME_REMOTE_FRAME_MOJOM_JUMBO_H_
#define THIRD_PARTY_BLINK_PUBLIC_MOJOM_FRAME_REMOTE_FRAME_MOJOM_JUMBO_H_
#include "services/network/public/mojom/cookie_access_observer.mojom.h"
#include "services/network/public/mojom/devtools_observer.mojom.h"
#include "third_party/blink/common/permissions_policy/permissions_policy_mojom_traits.h"
#include "third_party/blink/public/common/messaging/cloneable_message_mojom_traits.h"
#include "third_party/blink/public/common/messaging/transferable_message_mojom_traits.h"
#endif



namespace blink {
namespace mojom {
RemoteMainFrameInterfaces::RemoteMainFrameInterfaces()
    : main_frame_host(),
      main_frame() {}

RemoteMainFrameInterfaces::RemoteMainFrameInterfaces(
    ::mojo::PendingAssociatedRemote<RemoteMainFrameHost> main_frame_host_in,
    ::mojo::PendingAssociatedReceiver<RemoteMainFrame> main_frame_in)
    : main_frame_host(std::move(main_frame_host_in)),
      main_frame(std::move(main_frame_in)) {}

RemoteMainFrameInterfaces::~RemoteMainFrameInterfaces() = default;

void RemoteMainFrameInterfaces::WriteIntoTrace(
    perfetto::TracedValue traced_context) const {
  [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "main_frame_host"), this->main_frame_host,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type ::mojo::PendingAssociatedRemote<RemoteMainFrameHost>>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "main_frame"), this->main_frame,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type ::mojo::PendingAssociatedReceiver<RemoteMainFrame>>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool RemoteMainFrameInterfaces::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
RemoteFrameInterfacesFromRenderer::RemoteFrameInterfacesFromRenderer()
    : frame(),
      frame_host_receiver() {}

RemoteFrameInterfacesFromRenderer::RemoteFrameInterfacesFromRenderer(
    ::mojo::PendingAssociatedRemote<RemoteFrame> frame_in,
    ::mojo::PendingAssociatedReceiver<RemoteFrameHost> frame_host_receiver_in)
    : frame(std::move(frame_in)),
      frame_host_receiver(std::move(frame_host_receiver_in)) {}

RemoteFrameInterfacesFromRenderer::~RemoteFrameInterfacesFromRenderer() = default;

void RemoteFrameInterfacesFromRenderer::WriteIntoTrace(
    perfetto::TracedValue traced_context) const {
  [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "frame"), this->frame,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type ::mojo::PendingAssociatedRemote<RemoteFrame>>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "frame_host_receiver"), this->frame_host_receiver,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type ::mojo::PendingAssociatedReceiver<RemoteFrameHost>>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool RemoteFrameInterfacesFromRenderer::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
RemoteFrameInterfacesFromBrowser::RemoteFrameInterfacesFromBrowser()
    : frame_receiver(),
      frame_host() {}

RemoteFrameInterfacesFromBrowser::RemoteFrameInterfacesFromBrowser(
    ::mojo::PendingAssociatedReceiver<RemoteFrame> frame_receiver_in,
    ::mojo::PendingAssociatedRemote<RemoteFrameHost> frame_host_in)
    : frame_receiver(std::move(frame_receiver_in)),
      frame_host(std::move(frame_host_in)) {}

RemoteFrameInterfacesFromBrowser::~RemoteFrameInterfacesFromBrowser() = default;

void RemoteFrameInterfacesFromBrowser::WriteIntoTrace(
    perfetto::TracedValue traced_context) const {
  [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "frame_receiver"), this->frame_receiver,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type ::mojo::PendingAssociatedReceiver<RemoteFrame>>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "frame_host"), this->frame_host,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type ::mojo::PendingAssociatedRemote<RemoteFrameHost>>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool RemoteFrameInterfacesFromBrowser::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
OpenURLParams::OpenURLParams()
    : url(),
      initiator_origin(),
      initiator_frame_token(),
      post_body(),
      extra_headers(),
      referrer(),
      is_form_submission(),
      disposition(),
      should_replace_current_entry(),
      user_gesture(),
      is_unfenced_top_navigation(false),
      triggering_event_info(),
      blob_url_token(),
      href_translate(),
      impression(),
      download_policy(),
      source_location(),
      initiator_policy_container_keep_alive_handle() {}

OpenURLParams::OpenURLParams(
    const ::GURL& url_in,
    const ::url::Origin& initiator_origin_in,
    const absl::optional<::blink::LocalFrameToken>& initiator_frame_token_in,
    ::scoped_refptr<::network::ResourceRequestBody> post_body_in,
    const std::string& extra_headers_in,
    ::blink::mojom::ReferrerPtr referrer_in,
    bool is_form_submission_in,
    ::WindowOpenDisposition disposition_in,
    bool should_replace_current_entry_in,
    bool user_gesture_in,
    bool is_unfenced_top_navigation_in,
    ::blink::mojom::TriggeringEventInfo triggering_event_info_in,
    ::mojo::PendingRemote<::blink::mojom::BlobURLToken> blob_url_token_in,
    const std::string& href_translate_in,
    const absl::optional<::blink::Impression>& impression_in,
    const ::blink::NavigationDownloadPolicy& download_policy_in,
    ::network::mojom::SourceLocationPtr source_location_in,
    ::mojo::PendingRemote<::blink::mojom::PolicyContainerHostKeepAliveHandle> initiator_policy_container_keep_alive_handle_in)
    : url(std::move(url_in)),
      initiator_origin(std::move(initiator_origin_in)),
      initiator_frame_token(std::move(initiator_frame_token_in)),
      post_body(std::move(post_body_in)),
      extra_headers(std::move(extra_headers_in)),
      referrer(std::move(referrer_in)),
      is_form_submission(std::move(is_form_submission_in)),
      disposition(std::move(disposition_in)),
      should_replace_current_entry(std::move(should_replace_current_entry_in)),
      user_gesture(std::move(user_gesture_in)),
      is_unfenced_top_navigation(std::move(is_unfenced_top_navigation_in)),
      triggering_event_info(std::move(triggering_event_info_in)),
      blob_url_token(std::move(blob_url_token_in)),
      href_translate(std::move(href_translate_in)),
      impression(std::move(impression_in)),
      download_policy(std::move(download_policy_in)),
      source_location(std::move(source_location_in)),
      initiator_policy_container_keep_alive_handle(std::move(initiator_policy_container_keep_alive_handle_in)) {}

OpenURLParams::~OpenURLParams() = default;

void OpenURLParams::WriteIntoTrace(
    perfetto::TracedValue traced_context) const {
  [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "url"), this->url,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const ::GURL&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "initiator_origin"), this->initiator_origin,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const ::url::Origin&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "initiator_frame_token"), this->initiator_frame_token,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const absl::optional<::blink::LocalFrameToken>&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "post_body"), this->post_body,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type ::scoped_refptr<::network::ResourceRequestBody>>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "extra_headers"), this->extra_headers,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const std::string&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "referrer"), this->referrer,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type ::blink::mojom::ReferrerPtr>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "is_form_submission"), this->is_form_submission,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type bool>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "disposition"), this->disposition,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type ::WindowOpenDisposition>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "should_replace_current_entry"), this->should_replace_current_entry,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type bool>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "user_gesture"), this->user_gesture,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type bool>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "is_unfenced_top_navigation"), this->is_unfenced_top_navigation,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type bool>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "triggering_event_info"), this->triggering_event_info,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type ::blink::mojom::TriggeringEventInfo>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "blob_url_token"), this->blob_url_token,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type ::mojo::PendingRemote<::blink::mojom::BlobURLToken>>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "href_translate"), this->href_translate,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const std::string&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "impression"), this->impression,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const absl::optional<::blink::Impression>&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "download_policy"), this->download_policy,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const ::blink::NavigationDownloadPolicy&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "source_location"), this->source_location,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type ::network::mojom::SourceLocationPtr>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "initiator_policy_container_keep_alive_handle"), this->initiator_policy_container_keep_alive_handle,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type ::mojo::PendingRemote<::blink::mojom::PolicyContainerHostKeepAliveHandle>>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool OpenURLParams::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
const char RemoteFrameHost::Name_[] = "blink.mojom.RemoteFrameHost";

RemoteFrameHost::IPCStableHashFunction RemoteFrameHost::MessageToMethodInfo_(mojo::Message& message) {
#if !BUILDFLAG(IS_FUCHSIA)
  switch (message.name()) {
    case internal::kRemoteFrameHost_SetInheritedEffectiveTouchAction_Name: {
      return &RemoteFrameHost::SetInheritedEffectiveTouchAction_Sym::IPCStableHash;
    }
    case internal::kRemoteFrameHost_UpdateRenderThrottlingStatus_Name: {
      return &RemoteFrameHost::UpdateRenderThrottlingStatus_Sym::IPCStableHash;
    }
    case internal::kRemoteFrameHost_VisibilityChanged_Name: {
      return &RemoteFrameHost::VisibilityChanged_Sym::IPCStableHash;
    }
    case internal::kRemoteFrameHost_DidFocusFrame_Name: {
      return &RemoteFrameHost::DidFocusFrame_Sym::IPCStableHash;
    }
    case internal::kRemoteFrameHost_CheckCompleted_Name: {
      return &RemoteFrameHost::CheckCompleted_Sym::IPCStableHash;
    }
    case internal::kRemoteFrameHost_CapturePaintPreviewOfCrossProcessSubframe_Name: {
      return &RemoteFrameHost::CapturePaintPreviewOfCrossProcessSubframe_Sym::IPCStableHash;
    }
    case internal::kRemoteFrameHost_SetIsInert_Name: {
      return &RemoteFrameHost::SetIsInert_Sym::IPCStableHash;
    }
    case internal::kRemoteFrameHost_DidChangeOpener_Name: {
      return &RemoteFrameHost::DidChangeOpener_Sym::IPCStableHash;
    }
    case internal::kRemoteFrameHost_AdvanceFocus_Name: {
      return &RemoteFrameHost::AdvanceFocus_Sym::IPCStableHash;
    }
    case internal::kRemoteFrameHost_RouteMessageEvent_Name: {
      return &RemoteFrameHost::RouteMessageEvent_Sym::IPCStableHash;
    }
    case internal::kRemoteFrameHost_PrintCrossProcessSubframe_Name: {
      return &RemoteFrameHost::PrintCrossProcessSubframe_Sym::IPCStableHash;
    }
    case internal::kRemoteFrameHost_Detach_Name: {
      return &RemoteFrameHost::Detach_Sym::IPCStableHash;
    }
    case internal::kRemoteFrameHost_UpdateViewportIntersection_Name: {
      return &RemoteFrameHost::UpdateViewportIntersection_Sym::IPCStableHash;
    }
    case internal::kRemoteFrameHost_SynchronizeVisualProperties_Name: {
      return &RemoteFrameHost::SynchronizeVisualProperties_Sym::IPCStableHash;
    }
    case internal::kRemoteFrameHost_OpenURL_Name: {
      return &RemoteFrameHost::OpenURL_Sym::IPCStableHash;
    }
  }
#endif  // !BUILDFLAG(IS_FUCHSIA)
  return nullptr;
}


const char* RemoteFrameHost::MessageToMethodName_(mojo::Message& message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  bool is_response = message.has_flag(mojo::Message::kFlagIsResponse);
  if (!is_response) {
    switch (message.name()) {
      case internal::kRemoteFrameHost_SetInheritedEffectiveTouchAction_Name:
            return "Receive blink::mojom::RemoteFrameHost::SetInheritedEffectiveTouchAction";
      case internal::kRemoteFrameHost_UpdateRenderThrottlingStatus_Name:
            return "Receive blink::mojom::RemoteFrameHost::UpdateRenderThrottlingStatus";
      case internal::kRemoteFrameHost_VisibilityChanged_Name:
            return "Receive blink::mojom::RemoteFrameHost::VisibilityChanged";
      case internal::kRemoteFrameHost_DidFocusFrame_Name:
            return "Receive blink::mojom::RemoteFrameHost::DidFocusFrame";
      case internal::kRemoteFrameHost_CheckCompleted_Name:
            return "Receive blink::mojom::RemoteFrameHost::CheckCompleted";
      case internal::kRemoteFrameHost_CapturePaintPreviewOfCrossProcessSubframe_Name:
            return "Receive blink::mojom::RemoteFrameHost::CapturePaintPreviewOfCrossProcessSubframe";
      case internal::kRemoteFrameHost_SetIsInert_Name:
            return "Receive blink::mojom::RemoteFrameHost::SetIsInert";
      case internal::kRemoteFrameHost_DidChangeOpener_Name:
            return "Receive blink::mojom::RemoteFrameHost::DidChangeOpener";
      case internal::kRemoteFrameHost_AdvanceFocus_Name:
            return "Receive blink::mojom::RemoteFrameHost::AdvanceFocus";
      case internal::kRemoteFrameHost_RouteMessageEvent_Name:
            return "Receive blink::mojom::RemoteFrameHost::RouteMessageEvent";
      case internal::kRemoteFrameHost_PrintCrossProcessSubframe_Name:
            return "Receive blink::mojom::RemoteFrameHost::PrintCrossProcessSubframe";
      case internal::kRemoteFrameHost_Detach_Name:
            return "Receive blink::mojom::RemoteFrameHost::Detach";
      case internal::kRemoteFrameHost_UpdateViewportIntersection_Name:
            return "Receive blink::mojom::RemoteFrameHost::UpdateViewportIntersection";
      case internal::kRemoteFrameHost_SynchronizeVisualProperties_Name:
            return "Receive blink::mojom::RemoteFrameHost::SynchronizeVisualProperties";
      case internal::kRemoteFrameHost_OpenURL_Name:
            return "Receive blink::mojom::RemoteFrameHost::OpenURL";
    }
  } else {
    switch (message.name()) {
      case internal::kRemoteFrameHost_SetInheritedEffectiveTouchAction_Name:
            return "Receive reply blink::mojom::RemoteFrameHost::SetInheritedEffectiveTouchAction";
      case internal::kRemoteFrameHost_UpdateRenderThrottlingStatus_Name:
            return "Receive reply blink::mojom::RemoteFrameHost::UpdateRenderThrottlingStatus";
      case internal::kRemoteFrameHost_VisibilityChanged_Name:
            return "Receive reply blink::mojom::RemoteFrameHost::VisibilityChanged";
      case internal::kRemoteFrameHost_DidFocusFrame_Name:
            return "Receive reply blink::mojom::RemoteFrameHost::DidFocusFrame";
      case internal::kRemoteFrameHost_CheckCompleted_Name:
            return "Receive reply blink::mojom::RemoteFrameHost::CheckCompleted";
      case internal::kRemoteFrameHost_CapturePaintPreviewOfCrossProcessSubframe_Name:
            return "Receive reply blink::mojom::RemoteFrameHost::CapturePaintPreviewOfCrossProcessSubframe";
      case internal::kRemoteFrameHost_SetIsInert_Name:
            return "Receive reply blink::mojom::RemoteFrameHost::SetIsInert";
      case internal::kRemoteFrameHost_DidChangeOpener_Name:
            return "Receive reply blink::mojom::RemoteFrameHost::DidChangeOpener";
      case internal::kRemoteFrameHost_AdvanceFocus_Name:
            return "Receive reply blink::mojom::RemoteFrameHost::AdvanceFocus";
      case internal::kRemoteFrameHost_RouteMessageEvent_Name:
            return "Receive reply blink::mojom::RemoteFrameHost::RouteMessageEvent";
      case internal::kRemoteFrameHost_PrintCrossProcessSubframe_Name:
            return "Receive reply blink::mojom::RemoteFrameHost::PrintCrossProcessSubframe";
      case internal::kRemoteFrameHost_Detach_Name:
            return "Receive reply blink::mojom::RemoteFrameHost::Detach";
      case internal::kRemoteFrameHost_UpdateViewportIntersection_Name:
            return "Receive reply blink::mojom::RemoteFrameHost::UpdateViewportIntersection";
      case internal::kRemoteFrameHost_SynchronizeVisualProperties_Name:
            return "Receive reply blink::mojom::RemoteFrameHost::SynchronizeVisualProperties";
      case internal::kRemoteFrameHost_OpenURL_Name:
            return "Receive reply blink::mojom::RemoteFrameHost::OpenURL";
    }
  }
  return "Receive unknown mojo message";
#else
  bool is_response = message.has_flag(mojo::Message::kFlagIsResponse);
  if (is_response) {
    return "Receive mojo reply";
  } else {
    return "Receive mojo message";
  }
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
}

#if !BUILDFLAG(IS_FUCHSIA)
uint32_t RemoteFrameHost::SetInheritedEffectiveTouchAction_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::RemoteFrameHost::SetInheritedEffectiveTouchAction");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t RemoteFrameHost::UpdateRenderThrottlingStatus_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::RemoteFrameHost::UpdateRenderThrottlingStatus");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t RemoteFrameHost::VisibilityChanged_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::RemoteFrameHost::VisibilityChanged");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t RemoteFrameHost::DidFocusFrame_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::RemoteFrameHost::DidFocusFrame");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t RemoteFrameHost::CheckCompleted_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::RemoteFrameHost::CheckCompleted");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t RemoteFrameHost::CapturePaintPreviewOfCrossProcessSubframe_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::RemoteFrameHost::CapturePaintPreviewOfCrossProcessSubframe");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t RemoteFrameHost::SetIsInert_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::RemoteFrameHost::SetIsInert");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t RemoteFrameHost::DidChangeOpener_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::RemoteFrameHost::DidChangeOpener");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t RemoteFrameHost::AdvanceFocus_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::RemoteFrameHost::AdvanceFocus");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t RemoteFrameHost::RouteMessageEvent_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::RemoteFrameHost::RouteMessageEvent");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t RemoteFrameHost::PrintCrossProcessSubframe_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::RemoteFrameHost::PrintCrossProcessSubframe");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t RemoteFrameHost::Detach_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::RemoteFrameHost::Detach");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t RemoteFrameHost::UpdateViewportIntersection_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::RemoteFrameHost::UpdateViewportIntersection");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t RemoteFrameHost::SynchronizeVisualProperties_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::RemoteFrameHost::SynchronizeVisualProperties");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t RemoteFrameHost::OpenURL_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::RemoteFrameHost::OpenURL");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
# endif // !BUILDFLAG(IS_FUCHSIA)

RemoteFrameHostProxy::RemoteFrameHostProxy(mojo::MessageReceiverWithResponder* receiver)
    : receiver_(receiver) {
}

void RemoteFrameHostProxy::SetInheritedEffectiveTouchAction(
    ::cc::TouchAction in_touch_action) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::RemoteFrameHost::SetInheritedEffectiveTouchAction", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("touch_action"), in_touch_action,
                        "<value of type ::cc::TouchAction>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kRemoteFrameHost_SetInheritedEffectiveTouchAction_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::RemoteFrameHost_SetInheritedEffectiveTouchAction_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::Serialize<::cc::mojom::TouchAction>(
      in_touch_action, &params->touch_action);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(RemoteFrameHost::Name_);
  message.set_method_name("SetInheritedEffectiveTouchAction");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void RemoteFrameHostProxy::UpdateRenderThrottlingStatus(
    bool in_is_throttled, bool in_subtree_throttled, bool in_display_locked) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::RemoteFrameHost::UpdateRenderThrottlingStatus", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("is_throttled"), in_is_throttled,
                        "<value of type bool>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("subtree_throttled"), in_subtree_throttled,
                        "<value of type bool>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("display_locked"), in_display_locked,
                        "<value of type bool>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kRemoteFrameHost_UpdateRenderThrottlingStatus_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::RemoteFrameHost_UpdateRenderThrottlingStatus_Params_Data> params(
          message);
  params.Allocate();
  params->is_throttled = in_is_throttled;
  params->subtree_throttled = in_subtree_throttled;
  params->display_locked = in_display_locked;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(RemoteFrameHost::Name_);
  message.set_method_name("UpdateRenderThrottlingStatus");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void RemoteFrameHostProxy::VisibilityChanged(
    ::blink::mojom::FrameVisibility in_visibility) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::RemoteFrameHost::VisibilityChanged", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("visibility"), in_visibility,
                        "<value of type ::blink::mojom::FrameVisibility>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kRemoteFrameHost_VisibilityChanged_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::RemoteFrameHost_VisibilityChanged_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::Serialize<::blink::mojom::FrameVisibility>(
      in_visibility, &params->visibility);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(RemoteFrameHost::Name_);
  message.set_method_name("VisibilityChanged");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void RemoteFrameHostProxy::DidFocusFrame(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send blink::mojom::RemoteFrameHost::DidFocusFrame");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kRemoteFrameHost_DidFocusFrame_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::RemoteFrameHost_DidFocusFrame_Params_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(RemoteFrameHost::Name_);
  message.set_method_name("DidFocusFrame");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void RemoteFrameHostProxy::CheckCompleted(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send blink::mojom::RemoteFrameHost::CheckCompleted");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kRemoteFrameHost_CheckCompleted_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::RemoteFrameHost_CheckCompleted_Params_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(RemoteFrameHost::Name_);
  message.set_method_name("CheckCompleted");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void RemoteFrameHostProxy::CapturePaintPreviewOfCrossProcessSubframe(
    const ::gfx::Rect& in_clip_rect, const ::base::UnguessableToken& in_guid) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::RemoteFrameHost::CapturePaintPreviewOfCrossProcessSubframe", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("clip_rect"), in_clip_rect,
                        "<value of type const ::gfx::Rect&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("guid"), in_guid,
                        "<value of type const ::base::UnguessableToken&>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kRemoteFrameHost_CapturePaintPreviewOfCrossProcessSubframe_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::RemoteFrameHost_CapturePaintPreviewOfCrossProcessSubframe_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->clip_rect)::BaseType> clip_rect_fragment(
          params.message());
  mojo::internal::Serialize<::gfx::mojom::RectDataView>(
      in_clip_rect, clip_rect_fragment);
  params->clip_rect.Set(
      clip_rect_fragment.is_null() ? nullptr : clip_rect_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->clip_rect.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null clip_rect in RemoteFrameHost.CapturePaintPreviewOfCrossProcessSubframe request");
  mojo::internal::MessageFragment<
      typename decltype(params->guid)::BaseType> guid_fragment(
          params.message());
  mojo::internal::Serialize<::mojo_base::mojom::UnguessableTokenDataView>(
      in_guid, guid_fragment);
  params->guid.Set(
      guid_fragment.is_null() ? nullptr : guid_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->guid.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null guid in RemoteFrameHost.CapturePaintPreviewOfCrossProcessSubframe request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(RemoteFrameHost::Name_);
  message.set_method_name("CapturePaintPreviewOfCrossProcessSubframe");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void RemoteFrameHostProxy::SetIsInert(
    bool in_inert) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::RemoteFrameHost::SetIsInert", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("inert"), in_inert,
                        "<value of type bool>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kRemoteFrameHost_SetIsInert_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::RemoteFrameHost_SetIsInert_Params_Data> params(
          message);
  params.Allocate();
  params->inert = in_inert;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(RemoteFrameHost::Name_);
  message.set_method_name("SetIsInert");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void RemoteFrameHostProxy::DidChangeOpener(
    const absl::optional<::blink::LocalFrameToken>& in_opener_frame) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::RemoteFrameHost::DidChangeOpener", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("opener_frame"), in_opener_frame,
                        "<value of type const absl::optional<::blink::LocalFrameToken>&>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kRemoteFrameHost_DidChangeOpener_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::RemoteFrameHost_DidChangeOpener_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->opener_frame)::BaseType> opener_frame_fragment(
          params.message());
  mojo::internal::Serialize<::blink::mojom::LocalFrameTokenDataView>(
      in_opener_frame, opener_frame_fragment);
  params->opener_frame.Set(
      opener_frame_fragment.is_null() ? nullptr : opener_frame_fragment.data());

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(RemoteFrameHost::Name_);
  message.set_method_name("DidChangeOpener");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void RemoteFrameHostProxy::AdvanceFocus(
    ::blink::mojom::FocusType in_focus_type, const ::blink::LocalFrameToken& in_source_frame_token) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::RemoteFrameHost::AdvanceFocus", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("focus_type"), in_focus_type,
                        "<value of type ::blink::mojom::FocusType>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("source_frame_token"), in_source_frame_token,
                        "<value of type const ::blink::LocalFrameToken&>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kRemoteFrameHost_AdvanceFocus_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::RemoteFrameHost_AdvanceFocus_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::Serialize<::blink::mojom::FocusType>(
      in_focus_type, &params->focus_type);
  mojo::internal::MessageFragment<
      typename decltype(params->source_frame_token)::BaseType> source_frame_token_fragment(
          params.message());
  mojo::internal::Serialize<::blink::mojom::LocalFrameTokenDataView>(
      in_source_frame_token, source_frame_token_fragment);
  params->source_frame_token.Set(
      source_frame_token_fragment.is_null() ? nullptr : source_frame_token_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->source_frame_token.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null source_frame_token in RemoteFrameHost.AdvanceFocus request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(RemoteFrameHost::Name_);
  message.set_method_name("AdvanceFocus");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void RemoteFrameHostProxy::RouteMessageEvent(
    const absl::optional<::blink::LocalFrameToken>& in_source_frame_token, const ::std::u16string& in_source_origin, const ::std::u16string& in_target_origin, ::blink::TransferableMessage in_message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::RemoteFrameHost::RouteMessageEvent", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("source_frame_token"), in_source_frame_token,
                        "<value of type const absl::optional<::blink::LocalFrameToken>&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("source_origin"), in_source_origin,
                        "<value of type const ::std::u16string&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("target_origin"), in_target_origin,
                        "<value of type const ::std::u16string&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("message"), in_message,
                        "<value of type ::blink::TransferableMessage>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kRemoteFrameHost_RouteMessageEvent_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::RemoteFrameHost_RouteMessageEvent_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->source_frame_token)::BaseType> source_frame_token_fragment(
          params.message());
  mojo::internal::Serialize<::blink::mojom::LocalFrameTokenDataView>(
      in_source_frame_token, source_frame_token_fragment);
  params->source_frame_token.Set(
      source_frame_token_fragment.is_null() ? nullptr : source_frame_token_fragment.data());
  mojo::internal::MessageFragment<
      typename decltype(params->source_origin)::BaseType> source_origin_fragment(
          params.message());
  mojo::internal::Serialize<::mojo_base::mojom::String16DataView>(
      in_source_origin, source_origin_fragment);
  params->source_origin.Set(
      source_origin_fragment.is_null() ? nullptr : source_origin_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->source_origin.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null source_origin in RemoteFrameHost.RouteMessageEvent request");
  mojo::internal::MessageFragment<
      typename decltype(params->target_origin)::BaseType> target_origin_fragment(
          params.message());
  mojo::internal::Serialize<::mojo_base::mojom::String16DataView>(
      in_target_origin, target_origin_fragment);
  params->target_origin.Set(
      target_origin_fragment.is_null() ? nullptr : target_origin_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->target_origin.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null target_origin in RemoteFrameHost.RouteMessageEvent request");
  mojo::internal::MessageFragment<
      typename decltype(params->message)::BaseType> message_fragment(
          params.message());
  mojo::internal::Serialize<::blink::mojom::TransferableMessageDataView>(
      in_message, message_fragment);
  params->message.Set(
      message_fragment.is_null() ? nullptr : message_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->message.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null message in RemoteFrameHost.RouteMessageEvent request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(RemoteFrameHost::Name_);
  message.set_method_name("RouteMessageEvent");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void RemoteFrameHostProxy::PrintCrossProcessSubframe(
    const ::gfx::Rect& in_frame_content_rect, int32_t in_document_cookie) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::RemoteFrameHost::PrintCrossProcessSubframe", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("frame_content_rect"), in_frame_content_rect,
                        "<value of type const ::gfx::Rect&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("document_cookie"), in_document_cookie,
                        "<value of type int32_t>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kRemoteFrameHost_PrintCrossProcessSubframe_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::RemoteFrameHost_PrintCrossProcessSubframe_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->frame_content_rect)::BaseType> frame_content_rect_fragment(
          params.message());
  mojo::internal::Serialize<::gfx::mojom::RectDataView>(
      in_frame_content_rect, frame_content_rect_fragment);
  params->frame_content_rect.Set(
      frame_content_rect_fragment.is_null() ? nullptr : frame_content_rect_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->frame_content_rect.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null frame_content_rect in RemoteFrameHost.PrintCrossProcessSubframe request");
  params->document_cookie = in_document_cookie;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(RemoteFrameHost::Name_);
  message.set_method_name("PrintCrossProcessSubframe");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void RemoteFrameHostProxy::Detach(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send blink::mojom::RemoteFrameHost::Detach");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kRemoteFrameHost_Detach_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::RemoteFrameHost_Detach_Params_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(RemoteFrameHost::Name_);
  message.set_method_name("Detach");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void RemoteFrameHostProxy::UpdateViewportIntersection(
    ::blink::mojom::ViewportIntersectionStatePtr in_intersection_state, const absl::optional<::blink::FrameVisualProperties>& in_visual_properties) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::RemoteFrameHost::UpdateViewportIntersection", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("intersection_state"), in_intersection_state,
                        "<value of type ::blink::mojom::ViewportIntersectionStatePtr>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("visual_properties"), in_visual_properties,
                        "<value of type const absl::optional<::blink::FrameVisualProperties>&>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kRemoteFrameHost_UpdateViewportIntersection_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::RemoteFrameHost_UpdateViewportIntersection_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->intersection_state)::BaseType> intersection_state_fragment(
          params.message());
  mojo::internal::Serialize<::blink::mojom::ViewportIntersectionStateDataView>(
      in_intersection_state, intersection_state_fragment);
  params->intersection_state.Set(
      intersection_state_fragment.is_null() ? nullptr : intersection_state_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->intersection_state.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null intersection_state in RemoteFrameHost.UpdateViewportIntersection request");
  mojo::internal::MessageFragment<
      typename decltype(params->visual_properties)::BaseType> visual_properties_fragment(
          params.message());
  mojo::internal::Serialize<::blink::mojom::FrameVisualPropertiesDataView>(
      in_visual_properties, visual_properties_fragment);
  params->visual_properties.Set(
      visual_properties_fragment.is_null() ? nullptr : visual_properties_fragment.data());

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(RemoteFrameHost::Name_);
  message.set_method_name("UpdateViewportIntersection");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void RemoteFrameHostProxy::SynchronizeVisualProperties(
    const ::blink::FrameVisualProperties& in_properties) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::RemoteFrameHost::SynchronizeVisualProperties", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("properties"), in_properties,
                        "<value of type const ::blink::FrameVisualProperties&>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kRemoteFrameHost_SynchronizeVisualProperties_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::RemoteFrameHost_SynchronizeVisualProperties_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->properties)::BaseType> properties_fragment(
          params.message());
  mojo::internal::Serialize<::blink::mojom::FrameVisualPropertiesDataView>(
      in_properties, properties_fragment);
  params->properties.Set(
      properties_fragment.is_null() ? nullptr : properties_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->properties.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null properties in RemoteFrameHost.SynchronizeVisualProperties request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(RemoteFrameHost::Name_);
  message.set_method_name("SynchronizeVisualProperties");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void RemoteFrameHostProxy::OpenURL(
    OpenURLParamsPtr in_params) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::RemoteFrameHost::OpenURL", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("params"), in_params,
                        "<value of type OpenURLParamsPtr>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kRemoteFrameHost_OpenURL_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::RemoteFrameHost_OpenURL_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->params)::BaseType> params_fragment(
          params.message());
  mojo::internal::Serialize<::blink::mojom::OpenURLParamsDataView>(
      in_params, params_fragment);
  params->params.Set(
      params_fragment.is_null() ? nullptr : params_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->params.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null params in RemoteFrameHost.OpenURL request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(RemoteFrameHost::Name_);
  message.set_method_name("OpenURL");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

// static
bool RemoteFrameHostStubDispatch::Accept(
    RemoteFrameHost* impl,
    mojo::Message* message) {
  switch (message->header()->name) {
    case internal::kRemoteFrameHost_SetInheritedEffectiveTouchAction_Name: {

      DCHECK(message->is_serialized());
      internal::RemoteFrameHost_SetInheritedEffectiveTouchAction_Params_Data* params =
          reinterpret_cast<internal::RemoteFrameHost_SetInheritedEffectiveTouchAction_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::cc::TouchAction p_touch_action{};
      RemoteFrameHost_SetInheritedEffectiveTouchAction_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadTouchAction(&p_touch_action))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            RemoteFrameHost::Name_, 0, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SetInheritedEffectiveTouchAction(
std::move(p_touch_action));
      return true;
    }
    case internal::kRemoteFrameHost_UpdateRenderThrottlingStatus_Name: {

      DCHECK(message->is_serialized());
      internal::RemoteFrameHost_UpdateRenderThrottlingStatus_Params_Data* params =
          reinterpret_cast<internal::RemoteFrameHost_UpdateRenderThrottlingStatus_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      bool p_is_throttled{};
      bool p_subtree_throttled{};
      bool p_display_locked{};
      RemoteFrameHost_UpdateRenderThrottlingStatus_ParamsDataView input_data_view(params, message);
      
      if (success)
        p_is_throttled = input_data_view.is_throttled();
      if (success)
        p_subtree_throttled = input_data_view.subtree_throttled();
      if (success)
        p_display_locked = input_data_view.display_locked();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            RemoteFrameHost::Name_, 1, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->UpdateRenderThrottlingStatus(
std::move(p_is_throttled), 
std::move(p_subtree_throttled), 
std::move(p_display_locked));
      return true;
    }
    case internal::kRemoteFrameHost_VisibilityChanged_Name: {

      DCHECK(message->is_serialized());
      internal::RemoteFrameHost_VisibilityChanged_Params_Data* params =
          reinterpret_cast<internal::RemoteFrameHost_VisibilityChanged_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::blink::mojom::FrameVisibility p_visibility{};
      RemoteFrameHost_VisibilityChanged_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadVisibility(&p_visibility))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            RemoteFrameHost::Name_, 2, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->VisibilityChanged(
std::move(p_visibility));
      return true;
    }
    case internal::kRemoteFrameHost_DidFocusFrame_Name: {

      DCHECK(message->is_serialized());
      internal::RemoteFrameHost_DidFocusFrame_Params_Data* params =
          reinterpret_cast<internal::RemoteFrameHost_DidFocusFrame_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      RemoteFrameHost_DidFocusFrame_ParamsDataView input_data_view(params, message);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            RemoteFrameHost::Name_, 3, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->DidFocusFrame();
      return true;
    }
    case internal::kRemoteFrameHost_CheckCompleted_Name: {

      DCHECK(message->is_serialized());
      internal::RemoteFrameHost_CheckCompleted_Params_Data* params =
          reinterpret_cast<internal::RemoteFrameHost_CheckCompleted_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      RemoteFrameHost_CheckCompleted_ParamsDataView input_data_view(params, message);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            RemoteFrameHost::Name_, 4, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->CheckCompleted();
      return true;
    }
    case internal::kRemoteFrameHost_CapturePaintPreviewOfCrossProcessSubframe_Name: {

      DCHECK(message->is_serialized());
      internal::RemoteFrameHost_CapturePaintPreviewOfCrossProcessSubframe_Params_Data* params =
          reinterpret_cast<internal::RemoteFrameHost_CapturePaintPreviewOfCrossProcessSubframe_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::gfx::Rect p_clip_rect{};
      ::base::UnguessableToken p_guid{};
      RemoteFrameHost_CapturePaintPreviewOfCrossProcessSubframe_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadClipRect(&p_clip_rect))
        success = false;
      if (success && !input_data_view.ReadGuid(&p_guid))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            RemoteFrameHost::Name_, 5, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->CapturePaintPreviewOfCrossProcessSubframe(
std::move(p_clip_rect), 
std::move(p_guid));
      return true;
    }
    case internal::kRemoteFrameHost_SetIsInert_Name: {

      DCHECK(message->is_serialized());
      internal::RemoteFrameHost_SetIsInert_Params_Data* params =
          reinterpret_cast<internal::RemoteFrameHost_SetIsInert_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      bool p_inert{};
      RemoteFrameHost_SetIsInert_ParamsDataView input_data_view(params, message);
      
      if (success)
        p_inert = input_data_view.inert();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            RemoteFrameHost::Name_, 6, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SetIsInert(
std::move(p_inert));
      return true;
    }
    case internal::kRemoteFrameHost_DidChangeOpener_Name: {

      DCHECK(message->is_serialized());
      internal::RemoteFrameHost_DidChangeOpener_Params_Data* params =
          reinterpret_cast<internal::RemoteFrameHost_DidChangeOpener_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      absl::optional<::blink::LocalFrameToken> p_opener_frame{};
      RemoteFrameHost_DidChangeOpener_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadOpenerFrame(&p_opener_frame))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            RemoteFrameHost::Name_, 7, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->DidChangeOpener(
std::move(p_opener_frame));
      return true;
    }
    case internal::kRemoteFrameHost_AdvanceFocus_Name: {

      DCHECK(message->is_serialized());
      internal::RemoteFrameHost_AdvanceFocus_Params_Data* params =
          reinterpret_cast<internal::RemoteFrameHost_AdvanceFocus_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::blink::mojom::FocusType p_focus_type{};
      ::blink::LocalFrameToken p_source_frame_token{};
      RemoteFrameHost_AdvanceFocus_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadFocusType(&p_focus_type))
        success = false;
      if (success && !input_data_view.ReadSourceFrameToken(&p_source_frame_token))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            RemoteFrameHost::Name_, 8, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->AdvanceFocus(
std::move(p_focus_type), 
std::move(p_source_frame_token));
      return true;
    }
    case internal::kRemoteFrameHost_RouteMessageEvent_Name: {

      DCHECK(message->is_serialized());
      internal::RemoteFrameHost_RouteMessageEvent_Params_Data* params =
          reinterpret_cast<internal::RemoteFrameHost_RouteMessageEvent_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      absl::optional<::blink::LocalFrameToken> p_source_frame_token{};
      ::std::u16string p_source_origin{};
      ::std::u16string p_target_origin{};
      ::blink::TransferableMessage p_message{};
      RemoteFrameHost_RouteMessageEvent_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadSourceFrameToken(&p_source_frame_token))
        success = false;
      if (success && !input_data_view.ReadSourceOrigin(&p_source_origin))
        success = false;
      if (success && !input_data_view.ReadTargetOrigin(&p_target_origin))
        success = false;
      if (success && !input_data_view.ReadMessage(&p_message))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            RemoteFrameHost::Name_, 9, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->RouteMessageEvent(
std::move(p_source_frame_token), 
std::move(p_source_origin), 
std::move(p_target_origin), 
std::move(p_message));
      return true;
    }
    case internal::kRemoteFrameHost_PrintCrossProcessSubframe_Name: {

      DCHECK(message->is_serialized());
      internal::RemoteFrameHost_PrintCrossProcessSubframe_Params_Data* params =
          reinterpret_cast<internal::RemoteFrameHost_PrintCrossProcessSubframe_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::gfx::Rect p_frame_content_rect{};
      int32_t p_document_cookie{};
      RemoteFrameHost_PrintCrossProcessSubframe_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadFrameContentRect(&p_frame_content_rect))
        success = false;
      if (success)
        p_document_cookie = input_data_view.document_cookie();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            RemoteFrameHost::Name_, 10, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->PrintCrossProcessSubframe(
std::move(p_frame_content_rect), 
std::move(p_document_cookie));
      return true;
    }
    case internal::kRemoteFrameHost_Detach_Name: {

      DCHECK(message->is_serialized());
      internal::RemoteFrameHost_Detach_Params_Data* params =
          reinterpret_cast<internal::RemoteFrameHost_Detach_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      RemoteFrameHost_Detach_ParamsDataView input_data_view(params, message);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            RemoteFrameHost::Name_, 11, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->Detach();
      return true;
    }
    case internal::kRemoteFrameHost_UpdateViewportIntersection_Name: {

      DCHECK(message->is_serialized());
      internal::RemoteFrameHost_UpdateViewportIntersection_Params_Data* params =
          reinterpret_cast<internal::RemoteFrameHost_UpdateViewportIntersection_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::blink::mojom::ViewportIntersectionStatePtr p_intersection_state{};
      absl::optional<::blink::FrameVisualProperties> p_visual_properties{};
      RemoteFrameHost_UpdateViewportIntersection_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadIntersectionState(&p_intersection_state))
        success = false;
      if (success && !input_data_view.ReadVisualProperties(&p_visual_properties))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            RemoteFrameHost::Name_, 12, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->UpdateViewportIntersection(
std::move(p_intersection_state), 
std::move(p_visual_properties));
      return true;
    }
    case internal::kRemoteFrameHost_SynchronizeVisualProperties_Name: {

      DCHECK(message->is_serialized());
      internal::RemoteFrameHost_SynchronizeVisualProperties_Params_Data* params =
          reinterpret_cast<internal::RemoteFrameHost_SynchronizeVisualProperties_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::blink::FrameVisualProperties p_properties{};
      RemoteFrameHost_SynchronizeVisualProperties_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadProperties(&p_properties))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            RemoteFrameHost::Name_, 13, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SynchronizeVisualProperties(
std::move(p_properties));
      return true;
    }
    case internal::kRemoteFrameHost_OpenURL_Name: {

      DCHECK(message->is_serialized());
      internal::RemoteFrameHost_OpenURL_Params_Data* params =
          reinterpret_cast<internal::RemoteFrameHost_OpenURL_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      OpenURLParamsPtr p_params{};
      RemoteFrameHost_OpenURL_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadParams(&p_params))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            RemoteFrameHost::Name_, 14, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->OpenURL(
std::move(p_params));
      return true;
    }
  }
  return false;
}

// static
bool RemoteFrameHostStubDispatch::AcceptWithResponder(
    RemoteFrameHost* impl,
    mojo::Message* message,
    std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
  [[maybe_unused]] const bool message_is_sync =
      message->has_flag(mojo::Message::kFlagIsSync);
  [[maybe_unused]] const uint64_t request_id = message->request_id();
  switch (message->header()->name) {
    case internal::kRemoteFrameHost_SetInheritedEffectiveTouchAction_Name: {
      break;
    }
    case internal::kRemoteFrameHost_UpdateRenderThrottlingStatus_Name: {
      break;
    }
    case internal::kRemoteFrameHost_VisibilityChanged_Name: {
      break;
    }
    case internal::kRemoteFrameHost_DidFocusFrame_Name: {
      break;
    }
    case internal::kRemoteFrameHost_CheckCompleted_Name: {
      break;
    }
    case internal::kRemoteFrameHost_CapturePaintPreviewOfCrossProcessSubframe_Name: {
      break;
    }
    case internal::kRemoteFrameHost_SetIsInert_Name: {
      break;
    }
    case internal::kRemoteFrameHost_DidChangeOpener_Name: {
      break;
    }
    case internal::kRemoteFrameHost_AdvanceFocus_Name: {
      break;
    }
    case internal::kRemoteFrameHost_RouteMessageEvent_Name: {
      break;
    }
    case internal::kRemoteFrameHost_PrintCrossProcessSubframe_Name: {
      break;
    }
    case internal::kRemoteFrameHost_Detach_Name: {
      break;
    }
    case internal::kRemoteFrameHost_UpdateViewportIntersection_Name: {
      break;
    }
    case internal::kRemoteFrameHost_SynchronizeVisualProperties_Name: {
      break;
    }
    case internal::kRemoteFrameHost_OpenURL_Name: {
      break;
    }
  }
  return false;
}


static const mojo::internal::GenericValidationInfo kRemoteFrameHostValidationInfo[] = {
    {&internal::RemoteFrameHost_SetInheritedEffectiveTouchAction_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::RemoteFrameHost_UpdateRenderThrottlingStatus_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::RemoteFrameHost_VisibilityChanged_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::RemoteFrameHost_DidFocusFrame_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::RemoteFrameHost_CheckCompleted_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::RemoteFrameHost_CapturePaintPreviewOfCrossProcessSubframe_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::RemoteFrameHost_SetIsInert_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::RemoteFrameHost_DidChangeOpener_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::RemoteFrameHost_AdvanceFocus_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::RemoteFrameHost_RouteMessageEvent_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::RemoteFrameHost_PrintCrossProcessSubframe_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::RemoteFrameHost_Detach_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::RemoteFrameHost_UpdateViewportIntersection_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::RemoteFrameHost_SynchronizeVisualProperties_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::RemoteFrameHost_OpenURL_Params_Data::Validate,
     nullptr /* no response */},
};

bool RemoteFrameHostRequestValidator::Accept(mojo::Message* message) {
  const char* name = ::blink::mojom::RemoteFrameHost::Name_;
  return mojo::internal::ValidateRequestGenericPacked(message, name, kRemoteFrameHostValidationInfo);
}

const char RemoteFrame::Name_[] = "blink.mojom.RemoteFrame";

RemoteFrame::IPCStableHashFunction RemoteFrame::MessageToMethodInfo_(mojo::Message& message) {
#if !BUILDFLAG(IS_FUCHSIA)
  switch (message.name()) {
    case internal::kRemoteFrame_WillEnterFullscreen_Name: {
      return &RemoteFrame::WillEnterFullscreen_Sym::IPCStableHash;
    }
    case internal::kRemoteFrame_EnforceInsecureNavigationsSet_Name: {
      return &RemoteFrame::EnforceInsecureNavigationsSet_Sym::IPCStableHash;
    }
    case internal::kRemoteFrame_SetFrameOwnerProperties_Name: {
      return &RemoteFrame::SetFrameOwnerProperties_Sym::IPCStableHash;
    }
    case internal::kRemoteFrame_EnforceInsecureRequestPolicy_Name: {
      return &RemoteFrame::EnforceInsecureRequestPolicy_Sym::IPCStableHash;
    }
    case internal::kRemoteFrame_SetReplicatedOrigin_Name: {
      return &RemoteFrame::SetReplicatedOrigin_Sym::IPCStableHash;
    }
    case internal::kRemoteFrame_SetReplicatedIsAdFrame_Name: {
      return &RemoteFrame::SetReplicatedIsAdFrame_Sym::IPCStableHash;
    }
    case internal::kRemoteFrame_SetReplicatedName_Name: {
      return &RemoteFrame::SetReplicatedName_Sym::IPCStableHash;
    }
    case internal::kRemoteFrame_DispatchLoadEventForFrameOwner_Name: {
      return &RemoteFrame::DispatchLoadEventForFrameOwner_Sym::IPCStableHash;
    }
    case internal::kRemoteFrame_SetNeedsOcclusionTracking_Name: {
      return &RemoteFrame::SetNeedsOcclusionTracking_Sym::IPCStableHash;
    }
    case internal::kRemoteFrame_Collapse_Name: {
      return &RemoteFrame::Collapse_Sym::IPCStableHash;
    }
    case internal::kRemoteFrame_Focus_Name: {
      return &RemoteFrame::Focus_Sym::IPCStableHash;
    }
    case internal::kRemoteFrame_SetHadStickyUserActivationBeforeNavigation_Name: {
      return &RemoteFrame::SetHadStickyUserActivationBeforeNavigation_Sym::IPCStableHash;
    }
    case internal::kRemoteFrame_BubbleLogicalScroll_Name: {
      return &RemoteFrame::BubbleLogicalScroll_Sym::IPCStableHash;
    }
    case internal::kRemoteFrame_UpdateUserActivationState_Name: {
      return &RemoteFrame::UpdateUserActivationState_Sym::IPCStableHash;
    }
    case internal::kRemoteFrame_SetEmbeddingToken_Name: {
      return &RemoteFrame::SetEmbeddingToken_Sym::IPCStableHash;
    }
    case internal::kRemoteFrame_SetPageFocus_Name: {
      return &RemoteFrame::SetPageFocus_Sym::IPCStableHash;
    }
    case internal::kRemoteFrame_RenderFallbackContent_Name: {
      return &RemoteFrame::RenderFallbackContent_Sym::IPCStableHash;
    }
    case internal::kRemoteFrame_RenderFallbackContentWithResourceTiming_Name: {
      return &RemoteFrame::RenderFallbackContentWithResourceTiming_Sym::IPCStableHash;
    }
    case internal::kRemoteFrame_AddResourceTimingFromChild_Name: {
      return &RemoteFrame::AddResourceTimingFromChild_Sym::IPCStableHash;
    }
    case internal::kRemoteFrame_ScrollRectToVisible_Name: {
      return &RemoteFrame::ScrollRectToVisible_Sym::IPCStableHash;
    }
    case internal::kRemoteFrame_DidStartLoading_Name: {
      return &RemoteFrame::DidStartLoading_Sym::IPCStableHash;
    }
    case internal::kRemoteFrame_DidStopLoading_Name: {
      return &RemoteFrame::DidStopLoading_Sym::IPCStableHash;
    }
    case internal::kRemoteFrame_IntrinsicSizingInfoOfChildChanged_Name: {
      return &RemoteFrame::IntrinsicSizingInfoOfChildChanged_Sym::IPCStableHash;
    }
    case internal::kRemoteFrame_DidSetFramePolicyHeaders_Name: {
      return &RemoteFrame::DidSetFramePolicyHeaders_Sym::IPCStableHash;
    }
    case internal::kRemoteFrame_DidUpdateFramePolicy_Name: {
      return &RemoteFrame::DidUpdateFramePolicy_Sym::IPCStableHash;
    }
    case internal::kRemoteFrame_UpdateOpener_Name: {
      return &RemoteFrame::UpdateOpener_Sym::IPCStableHash;
    }
    case internal::kRemoteFrame_DetachAndDispose_Name: {
      return &RemoteFrame::DetachAndDispose_Sym::IPCStableHash;
    }
    case internal::kRemoteFrame_EnableAutoResize_Name: {
      return &RemoteFrame::EnableAutoResize_Sym::IPCStableHash;
    }
    case internal::kRemoteFrame_DisableAutoResize_Name: {
      return &RemoteFrame::DisableAutoResize_Sym::IPCStableHash;
    }
    case internal::kRemoteFrame_DidUpdateVisualProperties_Name: {
      return &RemoteFrame::DidUpdateVisualProperties_Sym::IPCStableHash;
    }
    case internal::kRemoteFrame_SetFrameSinkId_Name: {
      return &RemoteFrame::SetFrameSinkId_Sym::IPCStableHash;
    }
    case internal::kRemoteFrame_ChildProcessGone_Name: {
      return &RemoteFrame::ChildProcessGone_Sym::IPCStableHash;
    }
    case internal::kRemoteFrame_CreateRemoteChild_Name: {
      return &RemoteFrame::CreateRemoteChild_Sym::IPCStableHash;
    }
  }
#endif  // !BUILDFLAG(IS_FUCHSIA)
  return nullptr;
}


const char* RemoteFrame::MessageToMethodName_(mojo::Message& message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  bool is_response = message.has_flag(mojo::Message::kFlagIsResponse);
  if (!is_response) {
    switch (message.name()) {
      case internal::kRemoteFrame_WillEnterFullscreen_Name:
            return "Receive blink::mojom::RemoteFrame::WillEnterFullscreen";
      case internal::kRemoteFrame_EnforceInsecureNavigationsSet_Name:
            return "Receive blink::mojom::RemoteFrame::EnforceInsecureNavigationsSet";
      case internal::kRemoteFrame_SetFrameOwnerProperties_Name:
            return "Receive blink::mojom::RemoteFrame::SetFrameOwnerProperties";
      case internal::kRemoteFrame_EnforceInsecureRequestPolicy_Name:
            return "Receive blink::mojom::RemoteFrame::EnforceInsecureRequestPolicy";
      case internal::kRemoteFrame_SetReplicatedOrigin_Name:
            return "Receive blink::mojom::RemoteFrame::SetReplicatedOrigin";
      case internal::kRemoteFrame_SetReplicatedIsAdFrame_Name:
            return "Receive blink::mojom::RemoteFrame::SetReplicatedIsAdFrame";
      case internal::kRemoteFrame_SetReplicatedName_Name:
            return "Receive blink::mojom::RemoteFrame::SetReplicatedName";
      case internal::kRemoteFrame_DispatchLoadEventForFrameOwner_Name:
            return "Receive blink::mojom::RemoteFrame::DispatchLoadEventForFrameOwner";
      case internal::kRemoteFrame_SetNeedsOcclusionTracking_Name:
            return "Receive blink::mojom::RemoteFrame::SetNeedsOcclusionTracking";
      case internal::kRemoteFrame_Collapse_Name:
            return "Receive blink::mojom::RemoteFrame::Collapse";
      case internal::kRemoteFrame_Focus_Name:
            return "Receive blink::mojom::RemoteFrame::Focus";
      case internal::kRemoteFrame_SetHadStickyUserActivationBeforeNavigation_Name:
            return "Receive blink::mojom::RemoteFrame::SetHadStickyUserActivationBeforeNavigation";
      case internal::kRemoteFrame_BubbleLogicalScroll_Name:
            return "Receive blink::mojom::RemoteFrame::BubbleLogicalScroll";
      case internal::kRemoteFrame_UpdateUserActivationState_Name:
            return "Receive blink::mojom::RemoteFrame::UpdateUserActivationState";
      case internal::kRemoteFrame_SetEmbeddingToken_Name:
            return "Receive blink::mojom::RemoteFrame::SetEmbeddingToken";
      case internal::kRemoteFrame_SetPageFocus_Name:
            return "Receive blink::mojom::RemoteFrame::SetPageFocus";
      case internal::kRemoteFrame_RenderFallbackContent_Name:
            return "Receive blink::mojom::RemoteFrame::RenderFallbackContent";
      case internal::kRemoteFrame_RenderFallbackContentWithResourceTiming_Name:
            return "Receive blink::mojom::RemoteFrame::RenderFallbackContentWithResourceTiming";
      case internal::kRemoteFrame_AddResourceTimingFromChild_Name:
            return "Receive blink::mojom::RemoteFrame::AddResourceTimingFromChild";
      case internal::kRemoteFrame_ScrollRectToVisible_Name:
            return "Receive blink::mojom::RemoteFrame::ScrollRectToVisible";
      case internal::kRemoteFrame_DidStartLoading_Name:
            return "Receive blink::mojom::RemoteFrame::DidStartLoading";
      case internal::kRemoteFrame_DidStopLoading_Name:
            return "Receive blink::mojom::RemoteFrame::DidStopLoading";
      case internal::kRemoteFrame_IntrinsicSizingInfoOfChildChanged_Name:
            return "Receive blink::mojom::RemoteFrame::IntrinsicSizingInfoOfChildChanged";
      case internal::kRemoteFrame_DidSetFramePolicyHeaders_Name:
            return "Receive blink::mojom::RemoteFrame::DidSetFramePolicyHeaders";
      case internal::kRemoteFrame_DidUpdateFramePolicy_Name:
            return "Receive blink::mojom::RemoteFrame::DidUpdateFramePolicy";
      case internal::kRemoteFrame_UpdateOpener_Name:
            return "Receive blink::mojom::RemoteFrame::UpdateOpener";
      case internal::kRemoteFrame_DetachAndDispose_Name:
            return "Receive blink::mojom::RemoteFrame::DetachAndDispose";
      case internal::kRemoteFrame_EnableAutoResize_Name:
            return "Receive blink::mojom::RemoteFrame::EnableAutoResize";
      case internal::kRemoteFrame_DisableAutoResize_Name:
            return "Receive blink::mojom::RemoteFrame::DisableAutoResize";
      case internal::kRemoteFrame_DidUpdateVisualProperties_Name:
            return "Receive blink::mojom::RemoteFrame::DidUpdateVisualProperties";
      case internal::kRemoteFrame_SetFrameSinkId_Name:
            return "Receive blink::mojom::RemoteFrame::SetFrameSinkId";
      case internal::kRemoteFrame_ChildProcessGone_Name:
            return "Receive blink::mojom::RemoteFrame::ChildProcessGone";
      case internal::kRemoteFrame_CreateRemoteChild_Name:
            return "Receive blink::mojom::RemoteFrame::CreateRemoteChild";
    }
  } else {
    switch (message.name()) {
      case internal::kRemoteFrame_WillEnterFullscreen_Name:
            return "Receive reply blink::mojom::RemoteFrame::WillEnterFullscreen";
      case internal::kRemoteFrame_EnforceInsecureNavigationsSet_Name:
            return "Receive reply blink::mojom::RemoteFrame::EnforceInsecureNavigationsSet";
      case internal::kRemoteFrame_SetFrameOwnerProperties_Name:
            return "Receive reply blink::mojom::RemoteFrame::SetFrameOwnerProperties";
      case internal::kRemoteFrame_EnforceInsecureRequestPolicy_Name:
            return "Receive reply blink::mojom::RemoteFrame::EnforceInsecureRequestPolicy";
      case internal::kRemoteFrame_SetReplicatedOrigin_Name:
            return "Receive reply blink::mojom::RemoteFrame::SetReplicatedOrigin";
      case internal::kRemoteFrame_SetReplicatedIsAdFrame_Name:
            return "Receive reply blink::mojom::RemoteFrame::SetReplicatedIsAdFrame";
      case internal::kRemoteFrame_SetReplicatedName_Name:
            return "Receive reply blink::mojom::RemoteFrame::SetReplicatedName";
      case internal::kRemoteFrame_DispatchLoadEventForFrameOwner_Name:
            return "Receive reply blink::mojom::RemoteFrame::DispatchLoadEventForFrameOwner";
      case internal::kRemoteFrame_SetNeedsOcclusionTracking_Name:
            return "Receive reply blink::mojom::RemoteFrame::SetNeedsOcclusionTracking";
      case internal::kRemoteFrame_Collapse_Name:
            return "Receive reply blink::mojom::RemoteFrame::Collapse";
      case internal::kRemoteFrame_Focus_Name:
            return "Receive reply blink::mojom::RemoteFrame::Focus";
      case internal::kRemoteFrame_SetHadStickyUserActivationBeforeNavigation_Name:
            return "Receive reply blink::mojom::RemoteFrame::SetHadStickyUserActivationBeforeNavigation";
      case internal::kRemoteFrame_BubbleLogicalScroll_Name:
            return "Receive reply blink::mojom::RemoteFrame::BubbleLogicalScroll";
      case internal::kRemoteFrame_UpdateUserActivationState_Name:
            return "Receive reply blink::mojom::RemoteFrame::UpdateUserActivationState";
      case internal::kRemoteFrame_SetEmbeddingToken_Name:
            return "Receive reply blink::mojom::RemoteFrame::SetEmbeddingToken";
      case internal::kRemoteFrame_SetPageFocus_Name:
            return "Receive reply blink::mojom::RemoteFrame::SetPageFocus";
      case internal::kRemoteFrame_RenderFallbackContent_Name:
            return "Receive reply blink::mojom::RemoteFrame::RenderFallbackContent";
      case internal::kRemoteFrame_RenderFallbackContentWithResourceTiming_Name:
            return "Receive reply blink::mojom::RemoteFrame::RenderFallbackContentWithResourceTiming";
      case internal::kRemoteFrame_AddResourceTimingFromChild_Name:
            return "Receive reply blink::mojom::RemoteFrame::AddResourceTimingFromChild";
      case internal::kRemoteFrame_ScrollRectToVisible_Name:
            return "Receive reply blink::mojom::RemoteFrame::ScrollRectToVisible";
      case internal::kRemoteFrame_DidStartLoading_Name:
            return "Receive reply blink::mojom::RemoteFrame::DidStartLoading";
      case internal::kRemoteFrame_DidStopLoading_Name:
            return "Receive reply blink::mojom::RemoteFrame::DidStopLoading";
      case internal::kRemoteFrame_IntrinsicSizingInfoOfChildChanged_Name:
            return "Receive reply blink::mojom::RemoteFrame::IntrinsicSizingInfoOfChildChanged";
      case internal::kRemoteFrame_DidSetFramePolicyHeaders_Name:
            return "Receive reply blink::mojom::RemoteFrame::DidSetFramePolicyHeaders";
      case internal::kRemoteFrame_DidUpdateFramePolicy_Name:
            return "Receive reply blink::mojom::RemoteFrame::DidUpdateFramePolicy";
      case internal::kRemoteFrame_UpdateOpener_Name:
            return "Receive reply blink::mojom::RemoteFrame::UpdateOpener";
      case internal::kRemoteFrame_DetachAndDispose_Name:
            return "Receive reply blink::mojom::RemoteFrame::DetachAndDispose";
      case internal::kRemoteFrame_EnableAutoResize_Name:
            return "Receive reply blink::mojom::RemoteFrame::EnableAutoResize";
      case internal::kRemoteFrame_DisableAutoResize_Name:
            return "Receive reply blink::mojom::RemoteFrame::DisableAutoResize";
      case internal::kRemoteFrame_DidUpdateVisualProperties_Name:
            return "Receive reply blink::mojom::RemoteFrame::DidUpdateVisualProperties";
      case internal::kRemoteFrame_SetFrameSinkId_Name:
            return "Receive reply blink::mojom::RemoteFrame::SetFrameSinkId";
      case internal::kRemoteFrame_ChildProcessGone_Name:
            return "Receive reply blink::mojom::RemoteFrame::ChildProcessGone";
      case internal::kRemoteFrame_CreateRemoteChild_Name:
            return "Receive reply blink::mojom::RemoteFrame::CreateRemoteChild";
    }
  }
  return "Receive unknown mojo message";
#else
  bool is_response = message.has_flag(mojo::Message::kFlagIsResponse);
  if (is_response) {
    return "Receive mojo reply";
  } else {
    return "Receive mojo message";
  }
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
}

#if !BUILDFLAG(IS_FUCHSIA)
uint32_t RemoteFrame::WillEnterFullscreen_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::RemoteFrame::WillEnterFullscreen");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t RemoteFrame::EnforceInsecureNavigationsSet_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::RemoteFrame::EnforceInsecureNavigationsSet");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t RemoteFrame::SetFrameOwnerProperties_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::RemoteFrame::SetFrameOwnerProperties");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t RemoteFrame::EnforceInsecureRequestPolicy_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::RemoteFrame::EnforceInsecureRequestPolicy");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t RemoteFrame::SetReplicatedOrigin_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::RemoteFrame::SetReplicatedOrigin");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t RemoteFrame::SetReplicatedIsAdFrame_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::RemoteFrame::SetReplicatedIsAdFrame");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t RemoteFrame::SetReplicatedName_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::RemoteFrame::SetReplicatedName");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t RemoteFrame::DispatchLoadEventForFrameOwner_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::RemoteFrame::DispatchLoadEventForFrameOwner");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t RemoteFrame::SetNeedsOcclusionTracking_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::RemoteFrame::SetNeedsOcclusionTracking");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t RemoteFrame::Collapse_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::RemoteFrame::Collapse");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t RemoteFrame::Focus_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::RemoteFrame::Focus");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t RemoteFrame::SetHadStickyUserActivationBeforeNavigation_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::RemoteFrame::SetHadStickyUserActivationBeforeNavigation");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t RemoteFrame::BubbleLogicalScroll_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::RemoteFrame::BubbleLogicalScroll");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t RemoteFrame::UpdateUserActivationState_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::RemoteFrame::UpdateUserActivationState");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t RemoteFrame::SetEmbeddingToken_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::RemoteFrame::SetEmbeddingToken");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t RemoteFrame::SetPageFocus_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::RemoteFrame::SetPageFocus");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t RemoteFrame::RenderFallbackContent_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::RemoteFrame::RenderFallbackContent");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t RemoteFrame::RenderFallbackContentWithResourceTiming_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::RemoteFrame::RenderFallbackContentWithResourceTiming");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t RemoteFrame::AddResourceTimingFromChild_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::RemoteFrame::AddResourceTimingFromChild");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t RemoteFrame::ScrollRectToVisible_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::RemoteFrame::ScrollRectToVisible");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t RemoteFrame::DidStartLoading_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::RemoteFrame::DidStartLoading");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t RemoteFrame::DidStopLoading_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::RemoteFrame::DidStopLoading");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t RemoteFrame::IntrinsicSizingInfoOfChildChanged_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::RemoteFrame::IntrinsicSizingInfoOfChildChanged");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t RemoteFrame::DidSetFramePolicyHeaders_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::RemoteFrame::DidSetFramePolicyHeaders");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t RemoteFrame::DidUpdateFramePolicy_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::RemoteFrame::DidUpdateFramePolicy");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t RemoteFrame::UpdateOpener_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::RemoteFrame::UpdateOpener");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t RemoteFrame::DetachAndDispose_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::RemoteFrame::DetachAndDispose");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t RemoteFrame::EnableAutoResize_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::RemoteFrame::EnableAutoResize");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t RemoteFrame::DisableAutoResize_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::RemoteFrame::DisableAutoResize");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t RemoteFrame::DidUpdateVisualProperties_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::RemoteFrame::DidUpdateVisualProperties");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t RemoteFrame::SetFrameSinkId_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::RemoteFrame::SetFrameSinkId");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t RemoteFrame::ChildProcessGone_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::RemoteFrame::ChildProcessGone");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t RemoteFrame::CreateRemoteChild_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::RemoteFrame::CreateRemoteChild");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
# endif // !BUILDFLAG(IS_FUCHSIA)

RemoteFrameProxy::RemoteFrameProxy(mojo::MessageReceiverWithResponder* receiver)
    : receiver_(receiver) {
}

void RemoteFrameProxy::WillEnterFullscreen(
    ::blink::mojom::FullscreenOptionsPtr in_options) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::RemoteFrame::WillEnterFullscreen", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("options"), in_options,
                        "<value of type ::blink::mojom::FullscreenOptionsPtr>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kRemoteFrame_WillEnterFullscreen_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::RemoteFrame_WillEnterFullscreen_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->options)::BaseType> options_fragment(
          params.message());
  mojo::internal::Serialize<::blink::mojom::FullscreenOptionsDataView>(
      in_options, options_fragment);
  params->options.Set(
      options_fragment.is_null() ? nullptr : options_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->options.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null options in RemoteFrame.WillEnterFullscreen request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(RemoteFrame::Name_);
  message.set_method_name("WillEnterFullscreen");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void RemoteFrameProxy::EnforceInsecureNavigationsSet(
    const std::vector<uint32_t>& in_set) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::RemoteFrame::EnforceInsecureNavigationsSet", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("set"), in_set,
                        "<value of type const std::vector<uint32_t>&>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kRemoteFrame_EnforceInsecureNavigationsSet_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::RemoteFrame_EnforceInsecureNavigationsSet_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->set)::BaseType>
      set_fragment(params.message());
  const mojo::internal::ContainerValidateParams set_validate_params(
      0, false, nullptr);
  mojo::internal::Serialize<mojo::ArrayDataView<uint32_t>>(
      in_set, set_fragment, &set_validate_params);
  params->set.Set(
      set_fragment.is_null() ? nullptr : set_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->set.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null set in RemoteFrame.EnforceInsecureNavigationsSet request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(RemoteFrame::Name_);
  message.set_method_name("EnforceInsecureNavigationsSet");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void RemoteFrameProxy::SetFrameOwnerProperties(
    ::blink::mojom::FrameOwnerPropertiesPtr in_properties) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::RemoteFrame::SetFrameOwnerProperties", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("properties"), in_properties,
                        "<value of type ::blink::mojom::FrameOwnerPropertiesPtr>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kRemoteFrame_SetFrameOwnerProperties_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::RemoteFrame_SetFrameOwnerProperties_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->properties)::BaseType> properties_fragment(
          params.message());
  mojo::internal::Serialize<::blink::mojom::FrameOwnerPropertiesDataView>(
      in_properties, properties_fragment);
  params->properties.Set(
      properties_fragment.is_null() ? nullptr : properties_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->properties.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null properties in RemoteFrame.SetFrameOwnerProperties request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(RemoteFrame::Name_);
  message.set_method_name("SetFrameOwnerProperties");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void RemoteFrameProxy::EnforceInsecureRequestPolicy(
    ::blink::mojom::InsecureRequestPolicy in_policy) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::RemoteFrame::EnforceInsecureRequestPolicy", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("policy"), in_policy,
                        "<value of type ::blink::mojom::InsecureRequestPolicy>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kRemoteFrame_EnforceInsecureRequestPolicy_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::RemoteFrame_EnforceInsecureRequestPolicy_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::Serialize<::blink::mojom::InsecureRequestPolicy>(
      in_policy, &params->policy);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(RemoteFrame::Name_);
  message.set_method_name("EnforceInsecureRequestPolicy");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void RemoteFrameProxy::SetReplicatedOrigin(
    const ::url::Origin& in_origin, bool in_is_potentially_trustworthy_unique_origin) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::RemoteFrame::SetReplicatedOrigin", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("origin"), in_origin,
                        "<value of type const ::url::Origin&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("is_potentially_trustworthy_unique_origin"), in_is_potentially_trustworthy_unique_origin,
                        "<value of type bool>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kRemoteFrame_SetReplicatedOrigin_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::RemoteFrame_SetReplicatedOrigin_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->origin)::BaseType> origin_fragment(
          params.message());
  mojo::internal::Serialize<::url::mojom::OriginDataView>(
      in_origin, origin_fragment);
  params->origin.Set(
      origin_fragment.is_null() ? nullptr : origin_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->origin.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null origin in RemoteFrame.SetReplicatedOrigin request");
  params->is_potentially_trustworthy_unique_origin = in_is_potentially_trustworthy_unique_origin;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(RemoteFrame::Name_);
  message.set_method_name("SetReplicatedOrigin");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void RemoteFrameProxy::SetReplicatedIsAdFrame(
    bool in_is_ad_frame) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::RemoteFrame::SetReplicatedIsAdFrame", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("is_ad_frame"), in_is_ad_frame,
                        "<value of type bool>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kRemoteFrame_SetReplicatedIsAdFrame_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::RemoteFrame_SetReplicatedIsAdFrame_Params_Data> params(
          message);
  params.Allocate();
  params->is_ad_frame = in_is_ad_frame;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(RemoteFrame::Name_);
  message.set_method_name("SetReplicatedIsAdFrame");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void RemoteFrameProxy::SetReplicatedName(
    const std::string& in_name, const std::string& in_unique_name) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::RemoteFrame::SetReplicatedName", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("name"), in_name,
                        "<value of type const std::string&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("unique_name"), in_unique_name,
                        "<value of type const std::string&>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kRemoteFrame_SetReplicatedName_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::RemoteFrame_SetReplicatedName_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->name)::BaseType> name_fragment(
          params.message());
  mojo::internal::Serialize<mojo::StringDataView>(
      in_name, name_fragment);
  params->name.Set(
      name_fragment.is_null() ? nullptr : name_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->name.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null name in RemoteFrame.SetReplicatedName request");
  mojo::internal::MessageFragment<
      typename decltype(params->unique_name)::BaseType> unique_name_fragment(
          params.message());
  mojo::internal::Serialize<mojo::StringDataView>(
      in_unique_name, unique_name_fragment);
  params->unique_name.Set(
      unique_name_fragment.is_null() ? nullptr : unique_name_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->unique_name.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null unique_name in RemoteFrame.SetReplicatedName request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(RemoteFrame::Name_);
  message.set_method_name("SetReplicatedName");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void RemoteFrameProxy::DispatchLoadEventForFrameOwner(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send blink::mojom::RemoteFrame::DispatchLoadEventForFrameOwner");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kRemoteFrame_DispatchLoadEventForFrameOwner_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::RemoteFrame_DispatchLoadEventForFrameOwner_Params_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(RemoteFrame::Name_);
  message.set_method_name("DispatchLoadEventForFrameOwner");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void RemoteFrameProxy::SetNeedsOcclusionTracking(
    bool in_needs_tracking) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::RemoteFrame::SetNeedsOcclusionTracking", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("needs_tracking"), in_needs_tracking,
                        "<value of type bool>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kRemoteFrame_SetNeedsOcclusionTracking_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::RemoteFrame_SetNeedsOcclusionTracking_Params_Data> params(
          message);
  params.Allocate();
  params->needs_tracking = in_needs_tracking;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(RemoteFrame::Name_);
  message.set_method_name("SetNeedsOcclusionTracking");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void RemoteFrameProxy::Collapse(
    bool in_collapsed) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::RemoteFrame::Collapse", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("collapsed"), in_collapsed,
                        "<value of type bool>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kRemoteFrame_Collapse_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::RemoteFrame_Collapse_Params_Data> params(
          message);
  params.Allocate();
  params->collapsed = in_collapsed;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(RemoteFrame::Name_);
  message.set_method_name("Collapse");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void RemoteFrameProxy::Focus(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send blink::mojom::RemoteFrame::Focus");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kRemoteFrame_Focus_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::RemoteFrame_Focus_Params_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(RemoteFrame::Name_);
  message.set_method_name("Focus");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void RemoteFrameProxy::SetHadStickyUserActivationBeforeNavigation(
    bool in_has_gesture) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::RemoteFrame::SetHadStickyUserActivationBeforeNavigation", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("has_gesture"), in_has_gesture,
                        "<value of type bool>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kRemoteFrame_SetHadStickyUserActivationBeforeNavigation_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::RemoteFrame_SetHadStickyUserActivationBeforeNavigation_Params_Data> params(
          message);
  params.Allocate();
  params->has_gesture = in_has_gesture;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(RemoteFrame::Name_);
  message.set_method_name("SetHadStickyUserActivationBeforeNavigation");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void RemoteFrameProxy::BubbleLogicalScroll(
    ::blink::mojom::ScrollDirection in_direction, ::ui::ScrollGranularity in_granularity) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::RemoteFrame::BubbleLogicalScroll", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("direction"), in_direction,
                        "<value of type ::blink::mojom::ScrollDirection>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("granularity"), in_granularity,
                        "<value of type ::ui::ScrollGranularity>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kRemoteFrame_BubbleLogicalScroll_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::RemoteFrame_BubbleLogicalScroll_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::Serialize<::blink::mojom::ScrollDirection>(
      in_direction, &params->direction);
  mojo::internal::Serialize<::ui::mojom::ScrollGranularity>(
      in_granularity, &params->granularity);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(RemoteFrame::Name_);
  message.set_method_name("BubbleLogicalScroll");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void RemoteFrameProxy::UpdateUserActivationState(
    ::blink::mojom::UserActivationUpdateType in_state_update_type, ::blink::mojom::UserActivationNotificationType in_notification_type) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::RemoteFrame::UpdateUserActivationState", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("state_update_type"), in_state_update_type,
                        "<value of type ::blink::mojom::UserActivationUpdateType>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("notification_type"), in_notification_type,
                        "<value of type ::blink::mojom::UserActivationNotificationType>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kRemoteFrame_UpdateUserActivationState_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::RemoteFrame_UpdateUserActivationState_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::Serialize<::blink::mojom::UserActivationUpdateType>(
      in_state_update_type, &params->state_update_type);
  mojo::internal::Serialize<::blink::mojom::UserActivationNotificationType>(
      in_notification_type, &params->notification_type);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(RemoteFrame::Name_);
  message.set_method_name("UpdateUserActivationState");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void RemoteFrameProxy::SetEmbeddingToken(
    const ::base::UnguessableToken& in_embedding_token) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::RemoteFrame::SetEmbeddingToken", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("embedding_token"), in_embedding_token,
                        "<value of type const ::base::UnguessableToken&>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kRemoteFrame_SetEmbeddingToken_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::RemoteFrame_SetEmbeddingToken_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->embedding_token)::BaseType> embedding_token_fragment(
          params.message());
  mojo::internal::Serialize<::mojo_base::mojom::UnguessableTokenDataView>(
      in_embedding_token, embedding_token_fragment);
  params->embedding_token.Set(
      embedding_token_fragment.is_null() ? nullptr : embedding_token_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->embedding_token.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null embedding_token in RemoteFrame.SetEmbeddingToken request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(RemoteFrame::Name_);
  message.set_method_name("SetEmbeddingToken");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void RemoteFrameProxy::SetPageFocus(
    bool in_is_focused) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::RemoteFrame::SetPageFocus", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("is_focused"), in_is_focused,
                        "<value of type bool>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kRemoteFrame_SetPageFocus_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::RemoteFrame_SetPageFocus_Params_Data> params(
          message);
  params.Allocate();
  params->is_focused = in_is_focused;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(RemoteFrame::Name_);
  message.set_method_name("SetPageFocus");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void RemoteFrameProxy::RenderFallbackContent(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send blink::mojom::RemoteFrame::RenderFallbackContent");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kRemoteFrame_RenderFallbackContent_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::RemoteFrame_RenderFallbackContent_Params_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(RemoteFrame::Name_);
  message.set_method_name("RenderFallbackContent");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void RemoteFrameProxy::RenderFallbackContentWithResourceTiming(
    ::blink::mojom::ResourceTimingInfoPtr in_timing, const std::string& in_server_timing_value) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::RemoteFrame::RenderFallbackContentWithResourceTiming", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("timing"), in_timing,
                        "<value of type ::blink::mojom::ResourceTimingInfoPtr>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("server_timing_value"), in_server_timing_value,
                        "<value of type const std::string&>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kRemoteFrame_RenderFallbackContentWithResourceTiming_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::RemoteFrame_RenderFallbackContentWithResourceTiming_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->timing)::BaseType> timing_fragment(
          params.message());
  mojo::internal::Serialize<::blink::mojom::ResourceTimingInfoDataView>(
      in_timing, timing_fragment);
  params->timing.Set(
      timing_fragment.is_null() ? nullptr : timing_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->timing.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null timing in RemoteFrame.RenderFallbackContentWithResourceTiming request");
  mojo::internal::MessageFragment<
      typename decltype(params->server_timing_value)::BaseType> server_timing_value_fragment(
          params.message());
  mojo::internal::Serialize<mojo::StringDataView>(
      in_server_timing_value, server_timing_value_fragment);
  params->server_timing_value.Set(
      server_timing_value_fragment.is_null() ? nullptr : server_timing_value_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->server_timing_value.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null server_timing_value in RemoteFrame.RenderFallbackContentWithResourceTiming request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(RemoteFrame::Name_);
  message.set_method_name("RenderFallbackContentWithResourceTiming");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void RemoteFrameProxy::AddResourceTimingFromChild(
    ::blink::mojom::ResourceTimingInfoPtr in_timing) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::RemoteFrame::AddResourceTimingFromChild", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("timing"), in_timing,
                        "<value of type ::blink::mojom::ResourceTimingInfoPtr>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kRemoteFrame_AddResourceTimingFromChild_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::RemoteFrame_AddResourceTimingFromChild_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->timing)::BaseType> timing_fragment(
          params.message());
  mojo::internal::Serialize<::blink::mojom::ResourceTimingInfoDataView>(
      in_timing, timing_fragment);
  params->timing.Set(
      timing_fragment.is_null() ? nullptr : timing_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->timing.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null timing in RemoteFrame.AddResourceTimingFromChild request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(RemoteFrame::Name_);
  message.set_method_name("AddResourceTimingFromChild");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void RemoteFrameProxy::ScrollRectToVisible(
    const ::gfx::RectF& in_rect, ::blink::mojom::ScrollIntoViewParamsPtr in_params) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::RemoteFrame::ScrollRectToVisible", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("rect"), in_rect,
                        "<value of type const ::gfx::RectF&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("params"), in_params,
                        "<value of type ::blink::mojom::ScrollIntoViewParamsPtr>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kRemoteFrame_ScrollRectToVisible_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::RemoteFrame_ScrollRectToVisible_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->rect)::BaseType> rect_fragment(
          params.message());
  mojo::internal::Serialize<::gfx::mojom::RectFDataView>(
      in_rect, rect_fragment);
  params->rect.Set(
      rect_fragment.is_null() ? nullptr : rect_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->rect.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null rect in RemoteFrame.ScrollRectToVisible request");
  mojo::internal::MessageFragment<
      typename decltype(params->params)::BaseType> params_fragment(
          params.message());
  mojo::internal::Serialize<::blink::mojom::ScrollIntoViewParamsDataView>(
      in_params, params_fragment);
  params->params.Set(
      params_fragment.is_null() ? nullptr : params_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->params.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null params in RemoteFrame.ScrollRectToVisible request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(RemoteFrame::Name_);
  message.set_method_name("ScrollRectToVisible");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void RemoteFrameProxy::DidStartLoading(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send blink::mojom::RemoteFrame::DidStartLoading");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kRemoteFrame_DidStartLoading_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::RemoteFrame_DidStartLoading_Params_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(RemoteFrame::Name_);
  message.set_method_name("DidStartLoading");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void RemoteFrameProxy::DidStopLoading(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send blink::mojom::RemoteFrame::DidStopLoading");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kRemoteFrame_DidStopLoading_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::RemoteFrame_DidStopLoading_Params_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(RemoteFrame::Name_);
  message.set_method_name("DidStopLoading");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void RemoteFrameProxy::IntrinsicSizingInfoOfChildChanged(
    ::blink::mojom::IntrinsicSizingInfoPtr in_sizing_info) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::RemoteFrame::IntrinsicSizingInfoOfChildChanged", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("sizing_info"), in_sizing_info,
                        "<value of type ::blink::mojom::IntrinsicSizingInfoPtr>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kRemoteFrame_IntrinsicSizingInfoOfChildChanged_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::RemoteFrame_IntrinsicSizingInfoOfChildChanged_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->sizing_info)::BaseType> sizing_info_fragment(
          params.message());
  mojo::internal::Serialize<::blink::mojom::IntrinsicSizingInfoDataView>(
      in_sizing_info, sizing_info_fragment);
  params->sizing_info.Set(
      sizing_info_fragment.is_null() ? nullptr : sizing_info_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->sizing_info.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null sizing_info in RemoteFrame.IntrinsicSizingInfoOfChildChanged request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(RemoteFrame::Name_);
  message.set_method_name("IntrinsicSizingInfoOfChildChanged");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void RemoteFrameProxy::DidSetFramePolicyHeaders(
    ::network::mojom::WebSandboxFlags in_sandbox_flags, const std::vector<::blink::ParsedPermissionsPolicyDeclaration>& in_parsed_permissions_policy) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::RemoteFrame::DidSetFramePolicyHeaders", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("sandbox_flags"), in_sandbox_flags,
                        "<value of type ::network::mojom::WebSandboxFlags>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("parsed_permissions_policy"), in_parsed_permissions_policy,
                        "<value of type const std::vector<::blink::ParsedPermissionsPolicyDeclaration>&>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kRemoteFrame_DidSetFramePolicyHeaders_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::RemoteFrame_DidSetFramePolicyHeaders_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::Serialize<::network::mojom::WebSandboxFlags>(
      in_sandbox_flags, &params->sandbox_flags);
  mojo::internal::MessageFragment<
      typename decltype(params->parsed_permissions_policy)::BaseType>
      parsed_permissions_policy_fragment(params.message());
  const mojo::internal::ContainerValidateParams parsed_permissions_policy_validate_params(
      0, false, nullptr);
  mojo::internal::Serialize<mojo::ArrayDataView<::blink::mojom::ParsedPermissionsPolicyDeclarationDataView>>(
      in_parsed_permissions_policy, parsed_permissions_policy_fragment, &parsed_permissions_policy_validate_params);
  params->parsed_permissions_policy.Set(
      parsed_permissions_policy_fragment.is_null() ? nullptr : parsed_permissions_policy_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->parsed_permissions_policy.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null parsed_permissions_policy in RemoteFrame.DidSetFramePolicyHeaders request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(RemoteFrame::Name_);
  message.set_method_name("DidSetFramePolicyHeaders");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void RemoteFrameProxy::DidUpdateFramePolicy(
    const ::blink::FramePolicy& in_frame_policy) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::RemoteFrame::DidUpdateFramePolicy", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("frame_policy"), in_frame_policy,
                        "<value of type const ::blink::FramePolicy&>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kRemoteFrame_DidUpdateFramePolicy_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::RemoteFrame_DidUpdateFramePolicy_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->frame_policy)::BaseType> frame_policy_fragment(
          params.message());
  mojo::internal::Serialize<::blink::mojom::FramePolicyDataView>(
      in_frame_policy, frame_policy_fragment);
  params->frame_policy.Set(
      frame_policy_fragment.is_null() ? nullptr : frame_policy_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->frame_policy.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null frame_policy in RemoteFrame.DidUpdateFramePolicy request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(RemoteFrame::Name_);
  message.set_method_name("DidUpdateFramePolicy");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void RemoteFrameProxy::UpdateOpener(
    const absl::optional<::blink::FrameToken>& in_opener_frame_token) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::RemoteFrame::UpdateOpener", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("opener_frame_token"), in_opener_frame_token,
                        "<value of type const absl::optional<::blink::FrameToken>&>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kRemoteFrame_UpdateOpener_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::RemoteFrame_UpdateOpener_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<decltype(params->opener_frame_token)>
      opener_frame_token_fragment(params.message());
  opener_frame_token_fragment.Claim(&params->opener_frame_token);
  mojo::internal::Serialize<::blink::mojom::FrameTokenDataView>(
      in_opener_frame_token, opener_frame_token_fragment, true);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(RemoteFrame::Name_);
  message.set_method_name("UpdateOpener");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void RemoteFrameProxy::DetachAndDispose(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send blink::mojom::RemoteFrame::DetachAndDispose");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kRemoteFrame_DetachAndDispose_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::RemoteFrame_DetachAndDispose_Params_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(RemoteFrame::Name_);
  message.set_method_name("DetachAndDispose");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void RemoteFrameProxy::EnableAutoResize(
    const ::gfx::Size& in_min_size, const ::gfx::Size& in_max_size) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::RemoteFrame::EnableAutoResize", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("min_size"), in_min_size,
                        "<value of type const ::gfx::Size&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("max_size"), in_max_size,
                        "<value of type const ::gfx::Size&>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kRemoteFrame_EnableAutoResize_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::RemoteFrame_EnableAutoResize_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->min_size)::BaseType> min_size_fragment(
          params.message());
  mojo::internal::Serialize<::gfx::mojom::SizeDataView>(
      in_min_size, min_size_fragment);
  params->min_size.Set(
      min_size_fragment.is_null() ? nullptr : min_size_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->min_size.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null min_size in RemoteFrame.EnableAutoResize request");
  mojo::internal::MessageFragment<
      typename decltype(params->max_size)::BaseType> max_size_fragment(
          params.message());
  mojo::internal::Serialize<::gfx::mojom::SizeDataView>(
      in_max_size, max_size_fragment);
  params->max_size.Set(
      max_size_fragment.is_null() ? nullptr : max_size_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->max_size.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null max_size in RemoteFrame.EnableAutoResize request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(RemoteFrame::Name_);
  message.set_method_name("EnableAutoResize");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void RemoteFrameProxy::DisableAutoResize(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send blink::mojom::RemoteFrame::DisableAutoResize");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kRemoteFrame_DisableAutoResize_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::RemoteFrame_DisableAutoResize_Params_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(RemoteFrame::Name_);
  message.set_method_name("DisableAutoResize");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void RemoteFrameProxy::DidUpdateVisualProperties(
    const ::cc::RenderFrameMetadata& in_metadata) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::RemoteFrame::DidUpdateVisualProperties", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("metadata"), in_metadata,
                        "<value of type const ::cc::RenderFrameMetadata&>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kRemoteFrame_DidUpdateVisualProperties_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::RemoteFrame_DidUpdateVisualProperties_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->metadata)::BaseType> metadata_fragment(
          params.message());
  mojo::internal::Serialize<::cc::mojom::RenderFrameMetadataDataView>(
      in_metadata, metadata_fragment);
  params->metadata.Set(
      metadata_fragment.is_null() ? nullptr : metadata_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->metadata.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null metadata in RemoteFrame.DidUpdateVisualProperties request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(RemoteFrame::Name_);
  message.set_method_name("DidUpdateVisualProperties");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void RemoteFrameProxy::SetFrameSinkId(
    const ::viz::FrameSinkId& in_frame_sink_id) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::RemoteFrame::SetFrameSinkId", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("frame_sink_id"), in_frame_sink_id,
                        "<value of type const ::viz::FrameSinkId&>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kRemoteFrame_SetFrameSinkId_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::RemoteFrame_SetFrameSinkId_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->frame_sink_id)::BaseType> frame_sink_id_fragment(
          params.message());
  mojo::internal::Serialize<::viz::mojom::FrameSinkIdDataView>(
      in_frame_sink_id, frame_sink_id_fragment);
  params->frame_sink_id.Set(
      frame_sink_id_fragment.is_null() ? nullptr : frame_sink_id_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->frame_sink_id.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null frame_sink_id in RemoteFrame.SetFrameSinkId request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(RemoteFrame::Name_);
  message.set_method_name("SetFrameSinkId");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void RemoteFrameProxy::ChildProcessGone(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send blink::mojom::RemoteFrame::ChildProcessGone");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kRemoteFrame_ChildProcessGone_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::RemoteFrame_ChildProcessGone_Params_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(RemoteFrame::Name_);
  message.set_method_name("ChildProcessGone");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void RemoteFrameProxy::CreateRemoteChild(
    const ::blink::RemoteFrameToken& in_token, const absl::optional<::blink::FrameToken>& in_opener_frame_token, ::blink::mojom::TreeScopeType in_tree_scope_type, ::blink::mojom::FrameReplicationStatePtr in_replication_state, const ::base::UnguessableToken& in_devtools_frame_token, RemoteFrameInterfacesFromBrowserPtr in_remote_frame_interfaces) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::RemoteFrame::CreateRemoteChild", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("token"), in_token,
                        "<value of type const ::blink::RemoteFrameToken&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("opener_frame_token"), in_opener_frame_token,
                        "<value of type const absl::optional<::blink::FrameToken>&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("tree_scope_type"), in_tree_scope_type,
                        "<value of type ::blink::mojom::TreeScopeType>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("replication_state"), in_replication_state,
                        "<value of type ::blink::mojom::FrameReplicationStatePtr>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("devtools_frame_token"), in_devtools_frame_token,
                        "<value of type const ::base::UnguessableToken&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("remote_frame_interfaces"), in_remote_frame_interfaces,
                        "<value of type RemoteFrameInterfacesFromBrowserPtr>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kRemoteFrame_CreateRemoteChild_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::RemoteFrame_CreateRemoteChild_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->token)::BaseType> token_fragment(
          params.message());
  mojo::internal::Serialize<::blink::mojom::RemoteFrameTokenDataView>(
      in_token, token_fragment);
  params->token.Set(
      token_fragment.is_null() ? nullptr : token_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->token.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null token in RemoteFrame.CreateRemoteChild request");
  mojo::internal::MessageFragment<decltype(params->opener_frame_token)>
      opener_frame_token_fragment(params.message());
  opener_frame_token_fragment.Claim(&params->opener_frame_token);
  mojo::internal::Serialize<::blink::mojom::FrameTokenDataView>(
      in_opener_frame_token, opener_frame_token_fragment, true);
  mojo::internal::Serialize<::blink::mojom::TreeScopeType>(
      in_tree_scope_type, &params->tree_scope_type);
  mojo::internal::MessageFragment<
      typename decltype(params->replication_state)::BaseType> replication_state_fragment(
          params.message());
  mojo::internal::Serialize<::blink::mojom::FrameReplicationStateDataView>(
      in_replication_state, replication_state_fragment);
  params->replication_state.Set(
      replication_state_fragment.is_null() ? nullptr : replication_state_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->replication_state.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null replication_state in RemoteFrame.CreateRemoteChild request");
  mojo::internal::MessageFragment<
      typename decltype(params->devtools_frame_token)::BaseType> devtools_frame_token_fragment(
          params.message());
  mojo::internal::Serialize<::mojo_base::mojom::UnguessableTokenDataView>(
      in_devtools_frame_token, devtools_frame_token_fragment);
  params->devtools_frame_token.Set(
      devtools_frame_token_fragment.is_null() ? nullptr : devtools_frame_token_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->devtools_frame_token.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null devtools_frame_token in RemoteFrame.CreateRemoteChild request");
  mojo::internal::MessageFragment<
      typename decltype(params->remote_frame_interfaces)::BaseType> remote_frame_interfaces_fragment(
          params.message());
  mojo::internal::Serialize<::blink::mojom::RemoteFrameInterfacesFromBrowserDataView>(
      in_remote_frame_interfaces, remote_frame_interfaces_fragment);
  params->remote_frame_interfaces.Set(
      remote_frame_interfaces_fragment.is_null() ? nullptr : remote_frame_interfaces_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->remote_frame_interfaces.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null remote_frame_interfaces in RemoteFrame.CreateRemoteChild request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(RemoteFrame::Name_);
  message.set_method_name("CreateRemoteChild");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

// static
bool RemoteFrameStubDispatch::Accept(
    RemoteFrame* impl,
    mojo::Message* message) {
  switch (message->header()->name) {
    case internal::kRemoteFrame_WillEnterFullscreen_Name: {

      DCHECK(message->is_serialized());
      internal::RemoteFrame_WillEnterFullscreen_Params_Data* params =
          reinterpret_cast<internal::RemoteFrame_WillEnterFullscreen_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::blink::mojom::FullscreenOptionsPtr p_options{};
      RemoteFrame_WillEnterFullscreen_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadOptions(&p_options))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            RemoteFrame::Name_, 0, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->WillEnterFullscreen(
std::move(p_options));
      return true;
    }
    case internal::kRemoteFrame_EnforceInsecureNavigationsSet_Name: {

      DCHECK(message->is_serialized());
      internal::RemoteFrame_EnforceInsecureNavigationsSet_Params_Data* params =
          reinterpret_cast<internal::RemoteFrame_EnforceInsecureNavigationsSet_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      std::vector<uint32_t> p_set{};
      RemoteFrame_EnforceInsecureNavigationsSet_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadSet(&p_set))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            RemoteFrame::Name_, 1, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->EnforceInsecureNavigationsSet(
std::move(p_set));
      return true;
    }
    case internal::kRemoteFrame_SetFrameOwnerProperties_Name: {

      DCHECK(message->is_serialized());
      internal::RemoteFrame_SetFrameOwnerProperties_Params_Data* params =
          reinterpret_cast<internal::RemoteFrame_SetFrameOwnerProperties_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::blink::mojom::FrameOwnerPropertiesPtr p_properties{};
      RemoteFrame_SetFrameOwnerProperties_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadProperties(&p_properties))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            RemoteFrame::Name_, 2, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SetFrameOwnerProperties(
std::move(p_properties));
      return true;
    }
    case internal::kRemoteFrame_EnforceInsecureRequestPolicy_Name: {

      DCHECK(message->is_serialized());
      internal::RemoteFrame_EnforceInsecureRequestPolicy_Params_Data* params =
          reinterpret_cast<internal::RemoteFrame_EnforceInsecureRequestPolicy_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::blink::mojom::InsecureRequestPolicy p_policy{};
      RemoteFrame_EnforceInsecureRequestPolicy_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadPolicy(&p_policy))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            RemoteFrame::Name_, 3, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->EnforceInsecureRequestPolicy(
std::move(p_policy));
      return true;
    }
    case internal::kRemoteFrame_SetReplicatedOrigin_Name: {

      DCHECK(message->is_serialized());
      internal::RemoteFrame_SetReplicatedOrigin_Params_Data* params =
          reinterpret_cast<internal::RemoteFrame_SetReplicatedOrigin_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::url::Origin p_origin{};
      bool p_is_potentially_trustworthy_unique_origin{};
      RemoteFrame_SetReplicatedOrigin_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadOrigin(&p_origin))
        success = false;
      if (success)
        p_is_potentially_trustworthy_unique_origin = input_data_view.is_potentially_trustworthy_unique_origin();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            RemoteFrame::Name_, 4, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SetReplicatedOrigin(
std::move(p_origin), 
std::move(p_is_potentially_trustworthy_unique_origin));
      return true;
    }
    case internal::kRemoteFrame_SetReplicatedIsAdFrame_Name: {

      DCHECK(message->is_serialized());
      internal::RemoteFrame_SetReplicatedIsAdFrame_Params_Data* params =
          reinterpret_cast<internal::RemoteFrame_SetReplicatedIsAdFrame_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      bool p_is_ad_frame{};
      RemoteFrame_SetReplicatedIsAdFrame_ParamsDataView input_data_view(params, message);
      
      if (success)
        p_is_ad_frame = input_data_view.is_ad_frame();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            RemoteFrame::Name_, 5, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SetReplicatedIsAdFrame(
std::move(p_is_ad_frame));
      return true;
    }
    case internal::kRemoteFrame_SetReplicatedName_Name: {

      DCHECK(message->is_serialized());
      internal::RemoteFrame_SetReplicatedName_Params_Data* params =
          reinterpret_cast<internal::RemoteFrame_SetReplicatedName_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      std::string p_name{};
      std::string p_unique_name{};
      RemoteFrame_SetReplicatedName_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadName(&p_name))
        success = false;
      if (success && !input_data_view.ReadUniqueName(&p_unique_name))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            RemoteFrame::Name_, 6, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SetReplicatedName(
std::move(p_name), 
std::move(p_unique_name));
      return true;
    }
    case internal::kRemoteFrame_DispatchLoadEventForFrameOwner_Name: {

      DCHECK(message->is_serialized());
      internal::RemoteFrame_DispatchLoadEventForFrameOwner_Params_Data* params =
          reinterpret_cast<internal::RemoteFrame_DispatchLoadEventForFrameOwner_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      RemoteFrame_DispatchLoadEventForFrameOwner_ParamsDataView input_data_view(params, message);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            RemoteFrame::Name_, 7, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->DispatchLoadEventForFrameOwner();
      return true;
    }
    case internal::kRemoteFrame_SetNeedsOcclusionTracking_Name: {

      DCHECK(message->is_serialized());
      internal::RemoteFrame_SetNeedsOcclusionTracking_Params_Data* params =
          reinterpret_cast<internal::RemoteFrame_SetNeedsOcclusionTracking_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      bool p_needs_tracking{};
      RemoteFrame_SetNeedsOcclusionTracking_ParamsDataView input_data_view(params, message);
      
      if (success)
        p_needs_tracking = input_data_view.needs_tracking();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            RemoteFrame::Name_, 8, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SetNeedsOcclusionTracking(
std::move(p_needs_tracking));
      return true;
    }
    case internal::kRemoteFrame_Collapse_Name: {

      DCHECK(message->is_serialized());
      internal::RemoteFrame_Collapse_Params_Data* params =
          reinterpret_cast<internal::RemoteFrame_Collapse_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      bool p_collapsed{};
      RemoteFrame_Collapse_ParamsDataView input_data_view(params, message);
      
      if (success)
        p_collapsed = input_data_view.collapsed();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            RemoteFrame::Name_, 9, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->Collapse(
std::move(p_collapsed));
      return true;
    }
    case internal::kRemoteFrame_Focus_Name: {

      DCHECK(message->is_serialized());
      internal::RemoteFrame_Focus_Params_Data* params =
          reinterpret_cast<internal::RemoteFrame_Focus_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      RemoteFrame_Focus_ParamsDataView input_data_view(params, message);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            RemoteFrame::Name_, 10, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->Focus();
      return true;
    }
    case internal::kRemoteFrame_SetHadStickyUserActivationBeforeNavigation_Name: {

      DCHECK(message->is_serialized());
      internal::RemoteFrame_SetHadStickyUserActivationBeforeNavigation_Params_Data* params =
          reinterpret_cast<internal::RemoteFrame_SetHadStickyUserActivationBeforeNavigation_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      bool p_has_gesture{};
      RemoteFrame_SetHadStickyUserActivationBeforeNavigation_ParamsDataView input_data_view(params, message);
      
      if (success)
        p_has_gesture = input_data_view.has_gesture();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            RemoteFrame::Name_, 11, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SetHadStickyUserActivationBeforeNavigation(
std::move(p_has_gesture));
      return true;
    }
    case internal::kRemoteFrame_BubbleLogicalScroll_Name: {

      DCHECK(message->is_serialized());
      internal::RemoteFrame_BubbleLogicalScroll_Params_Data* params =
          reinterpret_cast<internal::RemoteFrame_BubbleLogicalScroll_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::blink::mojom::ScrollDirection p_direction{};
      ::ui::ScrollGranularity p_granularity{};
      RemoteFrame_BubbleLogicalScroll_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadDirection(&p_direction))
        success = false;
      if (success && !input_data_view.ReadGranularity(&p_granularity))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            RemoteFrame::Name_, 12, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->BubbleLogicalScroll(
std::move(p_direction), 
std::move(p_granularity));
      return true;
    }
    case internal::kRemoteFrame_UpdateUserActivationState_Name: {

      DCHECK(message->is_serialized());
      internal::RemoteFrame_UpdateUserActivationState_Params_Data* params =
          reinterpret_cast<internal::RemoteFrame_UpdateUserActivationState_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::blink::mojom::UserActivationUpdateType p_state_update_type{};
      ::blink::mojom::UserActivationNotificationType p_notification_type{};
      RemoteFrame_UpdateUserActivationState_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadStateUpdateType(&p_state_update_type))
        success = false;
      if (success && !input_data_view.ReadNotificationType(&p_notification_type))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            RemoteFrame::Name_, 13, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->UpdateUserActivationState(
std::move(p_state_update_type), 
std::move(p_notification_type));
      return true;
    }
    case internal::kRemoteFrame_SetEmbeddingToken_Name: {

      DCHECK(message->is_serialized());
      internal::RemoteFrame_SetEmbeddingToken_Params_Data* params =
          reinterpret_cast<internal::RemoteFrame_SetEmbeddingToken_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::base::UnguessableToken p_embedding_token{};
      RemoteFrame_SetEmbeddingToken_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadEmbeddingToken(&p_embedding_token))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            RemoteFrame::Name_, 14, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SetEmbeddingToken(
std::move(p_embedding_token));
      return true;
    }
    case internal::kRemoteFrame_SetPageFocus_Name: {

      DCHECK(message->is_serialized());
      internal::RemoteFrame_SetPageFocus_Params_Data* params =
          reinterpret_cast<internal::RemoteFrame_SetPageFocus_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      bool p_is_focused{};
      RemoteFrame_SetPageFocus_ParamsDataView input_data_view(params, message);
      
      if (success)
        p_is_focused = input_data_view.is_focused();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            RemoteFrame::Name_, 15, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SetPageFocus(
std::move(p_is_focused));
      return true;
    }
    case internal::kRemoteFrame_RenderFallbackContent_Name: {

      DCHECK(message->is_serialized());
      internal::RemoteFrame_RenderFallbackContent_Params_Data* params =
          reinterpret_cast<internal::RemoteFrame_RenderFallbackContent_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      RemoteFrame_RenderFallbackContent_ParamsDataView input_data_view(params, message);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            RemoteFrame::Name_, 16, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->RenderFallbackContent();
      return true;
    }
    case internal::kRemoteFrame_RenderFallbackContentWithResourceTiming_Name: {

      DCHECK(message->is_serialized());
      internal::RemoteFrame_RenderFallbackContentWithResourceTiming_Params_Data* params =
          reinterpret_cast<internal::RemoteFrame_RenderFallbackContentWithResourceTiming_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::blink::mojom::ResourceTimingInfoPtr p_timing{};
      std::string p_server_timing_value{};
      RemoteFrame_RenderFallbackContentWithResourceTiming_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadTiming(&p_timing))
        success = false;
      if (success && !input_data_view.ReadServerTimingValue(&p_server_timing_value))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            RemoteFrame::Name_, 17, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->RenderFallbackContentWithResourceTiming(
std::move(p_timing), 
std::move(p_server_timing_value));
      return true;
    }
    case internal::kRemoteFrame_AddResourceTimingFromChild_Name: {

      DCHECK(message->is_serialized());
      internal::RemoteFrame_AddResourceTimingFromChild_Params_Data* params =
          reinterpret_cast<internal::RemoteFrame_AddResourceTimingFromChild_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::blink::mojom::ResourceTimingInfoPtr p_timing{};
      RemoteFrame_AddResourceTimingFromChild_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadTiming(&p_timing))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            RemoteFrame::Name_, 18, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->AddResourceTimingFromChild(
std::move(p_timing));
      return true;
    }
    case internal::kRemoteFrame_ScrollRectToVisible_Name: {

      DCHECK(message->is_serialized());
      internal::RemoteFrame_ScrollRectToVisible_Params_Data* params =
          reinterpret_cast<internal::RemoteFrame_ScrollRectToVisible_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::gfx::RectF p_rect{};
      ::blink::mojom::ScrollIntoViewParamsPtr p_params{};
      RemoteFrame_ScrollRectToVisible_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadRect(&p_rect))
        success = false;
      if (success && !input_data_view.ReadParams(&p_params))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            RemoteFrame::Name_, 19, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->ScrollRectToVisible(
std::move(p_rect), 
std::move(p_params));
      return true;
    }
    case internal::kRemoteFrame_DidStartLoading_Name: {

      DCHECK(message->is_serialized());
      internal::RemoteFrame_DidStartLoading_Params_Data* params =
          reinterpret_cast<internal::RemoteFrame_DidStartLoading_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      RemoteFrame_DidStartLoading_ParamsDataView input_data_view(params, message);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            RemoteFrame::Name_, 20, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->DidStartLoading();
      return true;
    }
    case internal::kRemoteFrame_DidStopLoading_Name: {

      DCHECK(message->is_serialized());
      internal::RemoteFrame_DidStopLoading_Params_Data* params =
          reinterpret_cast<internal::RemoteFrame_DidStopLoading_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      RemoteFrame_DidStopLoading_ParamsDataView input_data_view(params, message);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            RemoteFrame::Name_, 21, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->DidStopLoading();
      return true;
    }
    case internal::kRemoteFrame_IntrinsicSizingInfoOfChildChanged_Name: {

      DCHECK(message->is_serialized());
      internal::RemoteFrame_IntrinsicSizingInfoOfChildChanged_Params_Data* params =
          reinterpret_cast<internal::RemoteFrame_IntrinsicSizingInfoOfChildChanged_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::blink::mojom::IntrinsicSizingInfoPtr p_sizing_info{};
      RemoteFrame_IntrinsicSizingInfoOfChildChanged_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadSizingInfo(&p_sizing_info))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            RemoteFrame::Name_, 22, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->IntrinsicSizingInfoOfChildChanged(
std::move(p_sizing_info));
      return true;
    }
    case internal::kRemoteFrame_DidSetFramePolicyHeaders_Name: {

      DCHECK(message->is_serialized());
      internal::RemoteFrame_DidSetFramePolicyHeaders_Params_Data* params =
          reinterpret_cast<internal::RemoteFrame_DidSetFramePolicyHeaders_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::network::mojom::WebSandboxFlags p_sandbox_flags{};
      std::vector<::blink::ParsedPermissionsPolicyDeclaration> p_parsed_permissions_policy{};
      RemoteFrame_DidSetFramePolicyHeaders_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadSandboxFlags(&p_sandbox_flags))
        success = false;
      if (success && !input_data_view.ReadParsedPermissionsPolicy(&p_parsed_permissions_policy))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            RemoteFrame::Name_, 23, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->DidSetFramePolicyHeaders(
std::move(p_sandbox_flags), 
std::move(p_parsed_permissions_policy));
      return true;
    }
    case internal::kRemoteFrame_DidUpdateFramePolicy_Name: {

      DCHECK(message->is_serialized());
      internal::RemoteFrame_DidUpdateFramePolicy_Params_Data* params =
          reinterpret_cast<internal::RemoteFrame_DidUpdateFramePolicy_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::blink::FramePolicy p_frame_policy{};
      RemoteFrame_DidUpdateFramePolicy_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadFramePolicy(&p_frame_policy))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            RemoteFrame::Name_, 24, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->DidUpdateFramePolicy(
std::move(p_frame_policy));
      return true;
    }
    case internal::kRemoteFrame_UpdateOpener_Name: {

      DCHECK(message->is_serialized());
      internal::RemoteFrame_UpdateOpener_Params_Data* params =
          reinterpret_cast<internal::RemoteFrame_UpdateOpener_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      absl::optional<::blink::FrameToken> p_opener_frame_token{};
      RemoteFrame_UpdateOpener_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadOpenerFrameToken(&p_opener_frame_token))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            RemoteFrame::Name_, 25, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->UpdateOpener(
std::move(p_opener_frame_token));
      return true;
    }
    case internal::kRemoteFrame_DetachAndDispose_Name: {

      DCHECK(message->is_serialized());
      internal::RemoteFrame_DetachAndDispose_Params_Data* params =
          reinterpret_cast<internal::RemoteFrame_DetachAndDispose_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      RemoteFrame_DetachAndDispose_ParamsDataView input_data_view(params, message);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            RemoteFrame::Name_, 26, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->DetachAndDispose();
      return true;
    }
    case internal::kRemoteFrame_EnableAutoResize_Name: {

      DCHECK(message->is_serialized());
      internal::RemoteFrame_EnableAutoResize_Params_Data* params =
          reinterpret_cast<internal::RemoteFrame_EnableAutoResize_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::gfx::Size p_min_size{};
      ::gfx::Size p_max_size{};
      RemoteFrame_EnableAutoResize_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadMinSize(&p_min_size))
        success = false;
      if (success && !input_data_view.ReadMaxSize(&p_max_size))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            RemoteFrame::Name_, 27, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->EnableAutoResize(
std::move(p_min_size), 
std::move(p_max_size));
      return true;
    }
    case internal::kRemoteFrame_DisableAutoResize_Name: {

      DCHECK(message->is_serialized());
      internal::RemoteFrame_DisableAutoResize_Params_Data* params =
          reinterpret_cast<internal::RemoteFrame_DisableAutoResize_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      RemoteFrame_DisableAutoResize_ParamsDataView input_data_view(params, message);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            RemoteFrame::Name_, 28, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->DisableAutoResize();
      return true;
    }
    case internal::kRemoteFrame_DidUpdateVisualProperties_Name: {

      DCHECK(message->is_serialized());
      internal::RemoteFrame_DidUpdateVisualProperties_Params_Data* params =
          reinterpret_cast<internal::RemoteFrame_DidUpdateVisualProperties_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::cc::RenderFrameMetadata p_metadata{};
      RemoteFrame_DidUpdateVisualProperties_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadMetadata(&p_metadata))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            RemoteFrame::Name_, 29, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->DidUpdateVisualProperties(
std::move(p_metadata));
      return true;
    }
    case internal::kRemoteFrame_SetFrameSinkId_Name: {

      DCHECK(message->is_serialized());
      internal::RemoteFrame_SetFrameSinkId_Params_Data* params =
          reinterpret_cast<internal::RemoteFrame_SetFrameSinkId_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::viz::FrameSinkId p_frame_sink_id{};
      RemoteFrame_SetFrameSinkId_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadFrameSinkId(&p_frame_sink_id))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            RemoteFrame::Name_, 30, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SetFrameSinkId(
std::move(p_frame_sink_id));
      return true;
    }
    case internal::kRemoteFrame_ChildProcessGone_Name: {

      DCHECK(message->is_serialized());
      internal::RemoteFrame_ChildProcessGone_Params_Data* params =
          reinterpret_cast<internal::RemoteFrame_ChildProcessGone_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      RemoteFrame_ChildProcessGone_ParamsDataView input_data_view(params, message);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            RemoteFrame::Name_, 31, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->ChildProcessGone();
      return true;
    }
    case internal::kRemoteFrame_CreateRemoteChild_Name: {

      DCHECK(message->is_serialized());
      internal::RemoteFrame_CreateRemoteChild_Params_Data* params =
          reinterpret_cast<internal::RemoteFrame_CreateRemoteChild_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::blink::RemoteFrameToken p_token{};
      absl::optional<::blink::FrameToken> p_opener_frame_token{};
      ::blink::mojom::TreeScopeType p_tree_scope_type{};
      ::blink::mojom::FrameReplicationStatePtr p_replication_state{};
      ::base::UnguessableToken p_devtools_frame_token{};
      RemoteFrameInterfacesFromBrowserPtr p_remote_frame_interfaces{};
      RemoteFrame_CreateRemoteChild_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadToken(&p_token))
        success = false;
      if (success && !input_data_view.ReadOpenerFrameToken(&p_opener_frame_token))
        success = false;
      if (success && !input_data_view.ReadTreeScopeType(&p_tree_scope_type))
        success = false;
      if (success && !input_data_view.ReadReplicationState(&p_replication_state))
        success = false;
      if (success && !input_data_view.ReadDevtoolsFrameToken(&p_devtools_frame_token))
        success = false;
      if (success && !input_data_view.ReadRemoteFrameInterfaces(&p_remote_frame_interfaces))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            RemoteFrame::Name_, 32, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->CreateRemoteChild(
std::move(p_token), 
std::move(p_opener_frame_token), 
std::move(p_tree_scope_type), 
std::move(p_replication_state), 
std::move(p_devtools_frame_token), 
std::move(p_remote_frame_interfaces));
      return true;
    }
  }
  return false;
}

// static
bool RemoteFrameStubDispatch::AcceptWithResponder(
    RemoteFrame* impl,
    mojo::Message* message,
    std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
  [[maybe_unused]] const bool message_is_sync =
      message->has_flag(mojo::Message::kFlagIsSync);
  [[maybe_unused]] const uint64_t request_id = message->request_id();
  switch (message->header()->name) {
    case internal::kRemoteFrame_WillEnterFullscreen_Name: {
      break;
    }
    case internal::kRemoteFrame_EnforceInsecureNavigationsSet_Name: {
      break;
    }
    case internal::kRemoteFrame_SetFrameOwnerProperties_Name: {
      break;
    }
    case internal::kRemoteFrame_EnforceInsecureRequestPolicy_Name: {
      break;
    }
    case internal::kRemoteFrame_SetReplicatedOrigin_Name: {
      break;
    }
    case internal::kRemoteFrame_SetReplicatedIsAdFrame_Name: {
      break;
    }
    case internal::kRemoteFrame_SetReplicatedName_Name: {
      break;
    }
    case internal::kRemoteFrame_DispatchLoadEventForFrameOwner_Name: {
      break;
    }
    case internal::kRemoteFrame_SetNeedsOcclusionTracking_Name: {
      break;
    }
    case internal::kRemoteFrame_Collapse_Name: {
      break;
    }
    case internal::kRemoteFrame_Focus_Name: {
      break;
    }
    case internal::kRemoteFrame_SetHadStickyUserActivationBeforeNavigation_Name: {
      break;
    }
    case internal::kRemoteFrame_BubbleLogicalScroll_Name: {
      break;
    }
    case internal::kRemoteFrame_UpdateUserActivationState_Name: {
      break;
    }
    case internal::kRemoteFrame_SetEmbeddingToken_Name: {
      break;
    }
    case internal::kRemoteFrame_SetPageFocus_Name: {
      break;
    }
    case internal::kRemoteFrame_RenderFallbackContent_Name: {
      break;
    }
    case internal::kRemoteFrame_RenderFallbackContentWithResourceTiming_Name: {
      break;
    }
    case internal::kRemoteFrame_AddResourceTimingFromChild_Name: {
      break;
    }
    case internal::kRemoteFrame_ScrollRectToVisible_Name: {
      break;
    }
    case internal::kRemoteFrame_DidStartLoading_Name: {
      break;
    }
    case internal::kRemoteFrame_DidStopLoading_Name: {
      break;
    }
    case internal::kRemoteFrame_IntrinsicSizingInfoOfChildChanged_Name: {
      break;
    }
    case internal::kRemoteFrame_DidSetFramePolicyHeaders_Name: {
      break;
    }
    case internal::kRemoteFrame_DidUpdateFramePolicy_Name: {
      break;
    }
    case internal::kRemoteFrame_UpdateOpener_Name: {
      break;
    }
    case internal::kRemoteFrame_DetachAndDispose_Name: {
      break;
    }
    case internal::kRemoteFrame_EnableAutoResize_Name: {
      break;
    }
    case internal::kRemoteFrame_DisableAutoResize_Name: {
      break;
    }
    case internal::kRemoteFrame_DidUpdateVisualProperties_Name: {
      break;
    }
    case internal::kRemoteFrame_SetFrameSinkId_Name: {
      break;
    }
    case internal::kRemoteFrame_ChildProcessGone_Name: {
      break;
    }
    case internal::kRemoteFrame_CreateRemoteChild_Name: {
      break;
    }
  }
  return false;
}


static const mojo::internal::GenericValidationInfo kRemoteFrameValidationInfo[] = {
    {&internal::RemoteFrame_WillEnterFullscreen_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::RemoteFrame_EnforceInsecureNavigationsSet_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::RemoteFrame_SetFrameOwnerProperties_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::RemoteFrame_EnforceInsecureRequestPolicy_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::RemoteFrame_SetReplicatedOrigin_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::RemoteFrame_SetReplicatedIsAdFrame_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::RemoteFrame_SetReplicatedName_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::RemoteFrame_DispatchLoadEventForFrameOwner_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::RemoteFrame_SetNeedsOcclusionTracking_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::RemoteFrame_Collapse_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::RemoteFrame_Focus_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::RemoteFrame_SetHadStickyUserActivationBeforeNavigation_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::RemoteFrame_BubbleLogicalScroll_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::RemoteFrame_UpdateUserActivationState_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::RemoteFrame_SetEmbeddingToken_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::RemoteFrame_SetPageFocus_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::RemoteFrame_RenderFallbackContent_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::RemoteFrame_RenderFallbackContentWithResourceTiming_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::RemoteFrame_AddResourceTimingFromChild_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::RemoteFrame_ScrollRectToVisible_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::RemoteFrame_DidStartLoading_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::RemoteFrame_DidStopLoading_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::RemoteFrame_IntrinsicSizingInfoOfChildChanged_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::RemoteFrame_DidSetFramePolicyHeaders_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::RemoteFrame_DidUpdateFramePolicy_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::RemoteFrame_UpdateOpener_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::RemoteFrame_DetachAndDispose_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::RemoteFrame_EnableAutoResize_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::RemoteFrame_DisableAutoResize_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::RemoteFrame_DidUpdateVisualProperties_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::RemoteFrame_SetFrameSinkId_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::RemoteFrame_ChildProcessGone_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::RemoteFrame_CreateRemoteChild_Params_Data::Validate,
     nullptr /* no response */},
};

bool RemoteFrameRequestValidator::Accept(mojo::Message* message) {
  const char* name = ::blink::mojom::RemoteFrame::Name_;
  return mojo::internal::ValidateRequestGenericPacked(message, name, kRemoteFrameValidationInfo);
}

const char RemoteMainFrame::Name_[] = "blink.mojom.RemoteMainFrame";

RemoteMainFrame::IPCStableHashFunction RemoteMainFrame::MessageToMethodInfo_(mojo::Message& message) {
#if !BUILDFLAG(IS_FUCHSIA)
  switch (message.name()) {
    case internal::kRemoteMainFrame_UpdateTextAutosizerPageInfo_Name: {
      return &RemoteMainFrame::UpdateTextAutosizerPageInfo_Sym::IPCStableHash;
    }
  }
#endif  // !BUILDFLAG(IS_FUCHSIA)
  return nullptr;
}


const char* RemoteMainFrame::MessageToMethodName_(mojo::Message& message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  bool is_response = message.has_flag(mojo::Message::kFlagIsResponse);
  if (!is_response) {
    switch (message.name()) {
      case internal::kRemoteMainFrame_UpdateTextAutosizerPageInfo_Name:
            return "Receive blink::mojom::RemoteMainFrame::UpdateTextAutosizerPageInfo";
    }
  } else {
    switch (message.name()) {
      case internal::kRemoteMainFrame_UpdateTextAutosizerPageInfo_Name:
            return "Receive reply blink::mojom::RemoteMainFrame::UpdateTextAutosizerPageInfo";
    }
  }
  return "Receive unknown mojo message";
#else
  bool is_response = message.has_flag(mojo::Message::kFlagIsResponse);
  if (is_response) {
    return "Receive mojo reply";
  } else {
    return "Receive mojo message";
  }
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
}

#if !BUILDFLAG(IS_FUCHSIA)
uint32_t RemoteMainFrame::UpdateTextAutosizerPageInfo_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::RemoteMainFrame::UpdateTextAutosizerPageInfo");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
# endif // !BUILDFLAG(IS_FUCHSIA)

RemoteMainFrameProxy::RemoteMainFrameProxy(mojo::MessageReceiverWithResponder* receiver)
    : receiver_(receiver) {
}

void RemoteMainFrameProxy::UpdateTextAutosizerPageInfo(
    ::blink::mojom::TextAutosizerPageInfoPtr in_page_info) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::RemoteMainFrame::UpdateTextAutosizerPageInfo", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("page_info"), in_page_info,
                        "<value of type ::blink::mojom::TextAutosizerPageInfoPtr>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kRemoteMainFrame_UpdateTextAutosizerPageInfo_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::RemoteMainFrame_UpdateTextAutosizerPageInfo_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->page_info)::BaseType> page_info_fragment(
          params.message());
  mojo::internal::Serialize<::blink::mojom::TextAutosizerPageInfoDataView>(
      in_page_info, page_info_fragment);
  params->page_info.Set(
      page_info_fragment.is_null() ? nullptr : page_info_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->page_info.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null page_info in RemoteMainFrame.UpdateTextAutosizerPageInfo request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(RemoteMainFrame::Name_);
  message.set_method_name("UpdateTextAutosizerPageInfo");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

// static
bool RemoteMainFrameStubDispatch::Accept(
    RemoteMainFrame* impl,
    mojo::Message* message) {
  switch (message->header()->name) {
    case internal::kRemoteMainFrame_UpdateTextAutosizerPageInfo_Name: {

      DCHECK(message->is_serialized());
      internal::RemoteMainFrame_UpdateTextAutosizerPageInfo_Params_Data* params =
          reinterpret_cast<internal::RemoteMainFrame_UpdateTextAutosizerPageInfo_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::blink::mojom::TextAutosizerPageInfoPtr p_page_info{};
      RemoteMainFrame_UpdateTextAutosizerPageInfo_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadPageInfo(&p_page_info))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            RemoteMainFrame::Name_, 0, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->UpdateTextAutosizerPageInfo(
std::move(p_page_info));
      return true;
    }
  }
  return false;
}

// static
bool RemoteMainFrameStubDispatch::AcceptWithResponder(
    RemoteMainFrame* impl,
    mojo::Message* message,
    std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
  [[maybe_unused]] const bool message_is_sync =
      message->has_flag(mojo::Message::kFlagIsSync);
  [[maybe_unused]] const uint64_t request_id = message->request_id();
  switch (message->header()->name) {
    case internal::kRemoteMainFrame_UpdateTextAutosizerPageInfo_Name: {
      break;
    }
  }
  return false;
}


static const mojo::internal::GenericValidationInfo kRemoteMainFrameValidationInfo[] = {
    {&internal::RemoteMainFrame_UpdateTextAutosizerPageInfo_Params_Data::Validate,
     nullptr /* no response */},
};

bool RemoteMainFrameRequestValidator::Accept(mojo::Message* message) {
  const char* name = ::blink::mojom::RemoteMainFrame::Name_;
  return mojo::internal::ValidateRequestGenericPacked(message, name, kRemoteMainFrameValidationInfo);
}

const char RemoteMainFrameHost::Name_[] = "blink.mojom.RemoteMainFrameHost";

RemoteMainFrameHost::IPCStableHashFunction RemoteMainFrameHost::MessageToMethodInfo_(mojo::Message& message) {
#if !BUILDFLAG(IS_FUCHSIA)
  switch (message.name()) {
    case internal::kRemoteMainFrameHost_FocusPage_Name: {
      return &RemoteMainFrameHost::FocusPage_Sym::IPCStableHash;
    }
    case internal::kRemoteMainFrameHost_TakeFocus_Name: {
      return &RemoteMainFrameHost::TakeFocus_Sym::IPCStableHash;
    }
    case internal::kRemoteMainFrameHost_UpdateTargetURL_Name: {
      return &RemoteMainFrameHost::UpdateTargetURL_Sym::IPCStableHash;
    }
    case internal::kRemoteMainFrameHost_RouteCloseEvent_Name: {
      return &RemoteMainFrameHost::RouteCloseEvent_Sym::IPCStableHash;
    }
  }
#endif  // !BUILDFLAG(IS_FUCHSIA)
  return nullptr;
}


const char* RemoteMainFrameHost::MessageToMethodName_(mojo::Message& message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  bool is_response = message.has_flag(mojo::Message::kFlagIsResponse);
  if (!is_response) {
    switch (message.name()) {
      case internal::kRemoteMainFrameHost_FocusPage_Name:
            return "Receive blink::mojom::RemoteMainFrameHost::FocusPage";
      case internal::kRemoteMainFrameHost_TakeFocus_Name:
            return "Receive blink::mojom::RemoteMainFrameHost::TakeFocus";
      case internal::kRemoteMainFrameHost_UpdateTargetURL_Name:
            return "Receive blink::mojom::RemoteMainFrameHost::UpdateTargetURL";
      case internal::kRemoteMainFrameHost_RouteCloseEvent_Name:
            return "Receive blink::mojom::RemoteMainFrameHost::RouteCloseEvent";
    }
  } else {
    switch (message.name()) {
      case internal::kRemoteMainFrameHost_FocusPage_Name:
            return "Receive reply blink::mojom::RemoteMainFrameHost::FocusPage";
      case internal::kRemoteMainFrameHost_TakeFocus_Name:
            return "Receive reply blink::mojom::RemoteMainFrameHost::TakeFocus";
      case internal::kRemoteMainFrameHost_UpdateTargetURL_Name:
            return "Receive reply blink::mojom::RemoteMainFrameHost::UpdateTargetURL";
      case internal::kRemoteMainFrameHost_RouteCloseEvent_Name:
            return "Receive reply blink::mojom::RemoteMainFrameHost::RouteCloseEvent";
    }
  }
  return "Receive unknown mojo message";
#else
  bool is_response = message.has_flag(mojo::Message::kFlagIsResponse);
  if (is_response) {
    return "Receive mojo reply";
  } else {
    return "Receive mojo message";
  }
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
}

#if !BUILDFLAG(IS_FUCHSIA)
uint32_t RemoteMainFrameHost::FocusPage_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::RemoteMainFrameHost::FocusPage");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t RemoteMainFrameHost::TakeFocus_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::RemoteMainFrameHost::TakeFocus");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t RemoteMainFrameHost::UpdateTargetURL_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::RemoteMainFrameHost::UpdateTargetURL");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t RemoteMainFrameHost::RouteCloseEvent_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::RemoteMainFrameHost::RouteCloseEvent");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
# endif // !BUILDFLAG(IS_FUCHSIA)

class RemoteMainFrameHost_UpdateTargetURL_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  RemoteMainFrameHost_UpdateTargetURL_ForwardToCallback(
      RemoteMainFrameHost::UpdateTargetURLCallback callback
      ) : callback_(std::move(callback)) {
  }

  RemoteMainFrameHost_UpdateTargetURL_ForwardToCallback(const RemoteMainFrameHost_UpdateTargetURL_ForwardToCallback&) = delete;
  RemoteMainFrameHost_UpdateTargetURL_ForwardToCallback& operator=(const RemoteMainFrameHost_UpdateTargetURL_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  RemoteMainFrameHost::UpdateTargetURLCallback callback_;
};

RemoteMainFrameHostProxy::RemoteMainFrameHostProxy(mojo::MessageReceiverWithResponder* receiver)
    : receiver_(receiver) {
}

void RemoteMainFrameHostProxy::FocusPage(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send blink::mojom::RemoteMainFrameHost::FocusPage");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kRemoteMainFrameHost_FocusPage_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::RemoteMainFrameHost_FocusPage_Params_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(RemoteMainFrameHost::Name_);
  message.set_method_name("FocusPage");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void RemoteMainFrameHostProxy::TakeFocus(
    bool in_reverse) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::RemoteMainFrameHost::TakeFocus", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("reverse"), in_reverse,
                        "<value of type bool>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kRemoteMainFrameHost_TakeFocus_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::RemoteMainFrameHost_TakeFocus_Params_Data> params(
          message);
  params.Allocate();
  params->reverse = in_reverse;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(RemoteMainFrameHost::Name_);
  message.set_method_name("TakeFocus");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void RemoteMainFrameHostProxy::UpdateTargetURL(
    const ::GURL& in_url, UpdateTargetURLCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::RemoteMainFrameHost::UpdateTargetURL", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("url"), in_url,
                        "<value of type const ::GURL&>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kRemoteMainFrameHost_UpdateTargetURL_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::RemoteMainFrameHost_UpdateTargetURL_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->url)::BaseType> url_fragment(
          params.message());
  mojo::internal::Serialize<::url::mojom::UrlDataView>(
      in_url, url_fragment);
  params->url.Set(
      url_fragment.is_null() ? nullptr : url_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->url.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null url in RemoteMainFrameHost.UpdateTargetURL request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(RemoteMainFrameHost::Name_);
  message.set_method_name("UpdateTargetURL");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new RemoteMainFrameHost_UpdateTargetURL_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void RemoteMainFrameHostProxy::RouteCloseEvent(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send blink::mojom::RemoteMainFrameHost::RouteCloseEvent");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kRemoteMainFrameHost_RouteCloseEvent_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::RemoteMainFrameHost_RouteCloseEvent_Params_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(RemoteMainFrameHost::Name_);
  message.set_method_name("RouteCloseEvent");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}
class RemoteMainFrameHost_UpdateTargetURL_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static RemoteMainFrameHost::UpdateTargetURLCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<RemoteMainFrameHost_UpdateTargetURL_ProxyToResponder> proxy(
        new RemoteMainFrameHost_UpdateTargetURL_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&RemoteMainFrameHost_UpdateTargetURL_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~RemoteMainFrameHost_UpdateTargetURL_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  RemoteMainFrameHost_UpdateTargetURL_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "RemoteMainFrameHost::UpdateTargetURLCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      );
};

bool RemoteMainFrameHost_UpdateTargetURL_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::RemoteMainFrameHost_UpdateTargetURL_ResponseParams_Data* params =
      reinterpret_cast<
          internal::RemoteMainFrameHost_UpdateTargetURL_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  RemoteMainFrameHost_UpdateTargetURL_ResponseParamsDataView input_data_view(params, message);
  
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        RemoteMainFrameHost::Name_, 2, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run();
  return true;
}

void RemoteMainFrameHost_UpdateTargetURL_ProxyToResponder::Run(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send reply blink::mojom::RemoteMainFrameHost::UpdateTargetURL");
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kRemoteMainFrameHost_UpdateTargetURL_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::RemoteMainFrameHost_UpdateTargetURL_ResponseParams_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(RemoteMainFrameHost::Name_);
  message.set_method_name("UpdateTargetURL");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}

// static
bool RemoteMainFrameHostStubDispatch::Accept(
    RemoteMainFrameHost* impl,
    mojo::Message* message) {
  switch (message->header()->name) {
    case internal::kRemoteMainFrameHost_FocusPage_Name: {

      DCHECK(message->is_serialized());
      internal::RemoteMainFrameHost_FocusPage_Params_Data* params =
          reinterpret_cast<internal::RemoteMainFrameHost_FocusPage_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      RemoteMainFrameHost_FocusPage_ParamsDataView input_data_view(params, message);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            RemoteMainFrameHost::Name_, 0, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->FocusPage();
      return true;
    }
    case internal::kRemoteMainFrameHost_TakeFocus_Name: {

      DCHECK(message->is_serialized());
      internal::RemoteMainFrameHost_TakeFocus_Params_Data* params =
          reinterpret_cast<internal::RemoteMainFrameHost_TakeFocus_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      bool p_reverse{};
      RemoteMainFrameHost_TakeFocus_ParamsDataView input_data_view(params, message);
      
      if (success)
        p_reverse = input_data_view.reverse();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            RemoteMainFrameHost::Name_, 1, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->TakeFocus(
std::move(p_reverse));
      return true;
    }
    case internal::kRemoteMainFrameHost_UpdateTargetURL_Name: {
      break;
    }
    case internal::kRemoteMainFrameHost_RouteCloseEvent_Name: {

      DCHECK(message->is_serialized());
      internal::RemoteMainFrameHost_RouteCloseEvent_Params_Data* params =
          reinterpret_cast<internal::RemoteMainFrameHost_RouteCloseEvent_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      RemoteMainFrameHost_RouteCloseEvent_ParamsDataView input_data_view(params, message);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            RemoteMainFrameHost::Name_, 3, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->RouteCloseEvent();
      return true;
    }
  }
  return false;
}

// static
bool RemoteMainFrameHostStubDispatch::AcceptWithResponder(
    RemoteMainFrameHost* impl,
    mojo::Message* message,
    std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
  [[maybe_unused]] const bool message_is_sync =
      message->has_flag(mojo::Message::kFlagIsSync);
  [[maybe_unused]] const uint64_t request_id = message->request_id();
  switch (message->header()->name) {
    case internal::kRemoteMainFrameHost_FocusPage_Name: {
      break;
    }
    case internal::kRemoteMainFrameHost_TakeFocus_Name: {
      break;
    }
    case internal::kRemoteMainFrameHost_UpdateTargetURL_Name: {

      internal::RemoteMainFrameHost_UpdateTargetURL_Params_Data* params =
          reinterpret_cast<
              internal::RemoteMainFrameHost_UpdateTargetURL_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      ::GURL p_url{};
      RemoteMainFrameHost_UpdateTargetURL_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadUrl(&p_url))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            RemoteMainFrameHost::Name_, 2, false);
        return false;
      }
      RemoteMainFrameHost::UpdateTargetURLCallback callback =
          RemoteMainFrameHost_UpdateTargetURL_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->UpdateTargetURL(
std::move(p_url), std::move(callback));
      return true;
    }
    case internal::kRemoteMainFrameHost_RouteCloseEvent_Name: {
      break;
    }
  }
  return false;
}


static const mojo::internal::GenericValidationInfo kRemoteMainFrameHostValidationInfo[] = {
    {&internal::RemoteMainFrameHost_FocusPage_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::RemoteMainFrameHost_TakeFocus_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::RemoteMainFrameHost_UpdateTargetURL_Params_Data::Validate,
     &internal::RemoteMainFrameHost_UpdateTargetURL_ResponseParams_Data::Validate},
    {&internal::RemoteMainFrameHost_RouteCloseEvent_Params_Data::Validate,
     nullptr /* no response */},
};

bool RemoteMainFrameHostRequestValidator::Accept(mojo::Message* message) {
  const char* name = ::blink::mojom::RemoteMainFrameHost::Name_;
  return mojo::internal::ValidateRequestGenericPacked(message, name, kRemoteMainFrameHostValidationInfo);
}

bool RemoteMainFrameHostResponseValidator::Accept(mojo::Message* message) {
  const char* name = ::blink::mojom::RemoteMainFrameHost::Name_;
  return mojo::internal::ValidateResponseGenericPacked(message, name, kRemoteMainFrameHostValidationInfo);
}


}  // namespace mojom
}  // namespace blink


namespace mojo {


// static
bool StructTraits<::blink::mojom::RemoteMainFrameInterfaces::DataView, ::blink::mojom::RemoteMainFrameInterfacesPtr>::Read(
    ::blink::mojom::RemoteMainFrameInterfaces::DataView input,
    ::blink::mojom::RemoteMainFrameInterfacesPtr* output) {
  bool success = true;
  ::blink::mojom::RemoteMainFrameInterfacesPtr result(::blink::mojom::RemoteMainFrameInterfaces::New());
  
      if (success) {
        result->main_frame_host =
            input.TakeMainFrameHost<decltype(result->main_frame_host)>();
      }
      if (success) {
        result->main_frame =
            input.TakeMainFrame<decltype(result->main_frame)>();
      }
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::blink::mojom::RemoteFrameInterfacesFromRenderer::DataView, ::blink::mojom::RemoteFrameInterfacesFromRendererPtr>::Read(
    ::blink::mojom::RemoteFrameInterfacesFromRenderer::DataView input,
    ::blink::mojom::RemoteFrameInterfacesFromRendererPtr* output) {
  bool success = true;
  ::blink::mojom::RemoteFrameInterfacesFromRendererPtr result(::blink::mojom::RemoteFrameInterfacesFromRenderer::New());
  
      if (success) {
        result->frame =
            input.TakeFrame<decltype(result->frame)>();
      }
      if (success) {
        result->frame_host_receiver =
            input.TakeFrameHostReceiver<decltype(result->frame_host_receiver)>();
      }
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::blink::mojom::RemoteFrameInterfacesFromBrowser::DataView, ::blink::mojom::RemoteFrameInterfacesFromBrowserPtr>::Read(
    ::blink::mojom::RemoteFrameInterfacesFromBrowser::DataView input,
    ::blink::mojom::RemoteFrameInterfacesFromBrowserPtr* output) {
  bool success = true;
  ::blink::mojom::RemoteFrameInterfacesFromBrowserPtr result(::blink::mojom::RemoteFrameInterfacesFromBrowser::New());
  
      if (success) {
        result->frame_receiver =
            input.TakeFrameReceiver<decltype(result->frame_receiver)>();
      }
      if (success) {
        result->frame_host =
            input.TakeFrameHost<decltype(result->frame_host)>();
      }
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::blink::mojom::OpenURLParams::DataView, ::blink::mojom::OpenURLParamsPtr>::Read(
    ::blink::mojom::OpenURLParams::DataView input,
    ::blink::mojom::OpenURLParamsPtr* output) {
  bool success = true;
  ::blink::mojom::OpenURLParamsPtr result(::blink::mojom::OpenURLParams::New());
  
      if (success && !input.ReadUrl(&result->url))
        success = false;
      if (success && !input.ReadInitiatorOrigin(&result->initiator_origin))
        success = false;
      if (success && !input.ReadInitiatorFrameToken(&result->initiator_frame_token))
        success = false;
      if (success && !input.ReadPostBody(&result->post_body))
        success = false;
      if (success && !input.ReadExtraHeaders(&result->extra_headers))
        success = false;
      if (success && !input.ReadReferrer(&result->referrer))
        success = false;
      if (success)
        result->is_form_submission = input.is_form_submission();
      if (success && !input.ReadDisposition(&result->disposition))
        success = false;
      if (success)
        result->should_replace_current_entry = input.should_replace_current_entry();
      if (success)
        result->user_gesture = input.user_gesture();
      if (success)
        result->is_unfenced_top_navigation = input.is_unfenced_top_navigation();
      if (success && !input.ReadTriggeringEventInfo(&result->triggering_event_info))
        success = false;
      if (success) {
        result->blob_url_token =
            input.TakeBlobUrlToken<decltype(result->blob_url_token)>();
      }
      if (success && !input.ReadHrefTranslate(&result->href_translate))
        success = false;
      if (success && !input.ReadImpression(&result->impression))
        success = false;
      if (success && !input.ReadDownloadPolicy(&result->download_policy))
        success = false;
      if (success && !input.ReadSourceLocation(&result->source_location))
        success = false;
      if (success) {
        result->initiator_policy_container_keep_alive_handle =
            input.TakeInitiatorPolicyContainerKeepAliveHandle<decltype(result->initiator_policy_container_keep_alive_handle)>();
      }
  *output = std::move(result);
  return success;
}

}  // namespace mojo


// Symbols declared in the -test-utils.h header are defined here instead of a
// separate .cc file to save compile time.


namespace blink {
namespace mojom {


void RemoteFrameHostInterceptorForTesting::SetInheritedEffectiveTouchAction(::cc::TouchAction touch_action) {
  GetForwardingInterface()->SetInheritedEffectiveTouchAction(std::move(touch_action));
}
void RemoteFrameHostInterceptorForTesting::UpdateRenderThrottlingStatus(bool is_throttled, bool subtree_throttled, bool display_locked) {
  GetForwardingInterface()->UpdateRenderThrottlingStatus(std::move(is_throttled), std::move(subtree_throttled), std::move(display_locked));
}
void RemoteFrameHostInterceptorForTesting::VisibilityChanged(::blink::mojom::FrameVisibility visibility) {
  GetForwardingInterface()->VisibilityChanged(std::move(visibility));
}
void RemoteFrameHostInterceptorForTesting::DidFocusFrame() {
  GetForwardingInterface()->DidFocusFrame();
}
void RemoteFrameHostInterceptorForTesting::CheckCompleted() {
  GetForwardingInterface()->CheckCompleted();
}
void RemoteFrameHostInterceptorForTesting::CapturePaintPreviewOfCrossProcessSubframe(const ::gfx::Rect& clip_rect, const ::base::UnguessableToken& guid) {
  GetForwardingInterface()->CapturePaintPreviewOfCrossProcessSubframe(std::move(clip_rect), std::move(guid));
}
void RemoteFrameHostInterceptorForTesting::SetIsInert(bool inert) {
  GetForwardingInterface()->SetIsInert(std::move(inert));
}
void RemoteFrameHostInterceptorForTesting::DidChangeOpener(const absl::optional<::blink::LocalFrameToken>& opener_frame) {
  GetForwardingInterface()->DidChangeOpener(std::move(opener_frame));
}
void RemoteFrameHostInterceptorForTesting::AdvanceFocus(::blink::mojom::FocusType focus_type, const ::blink::LocalFrameToken& source_frame_token) {
  GetForwardingInterface()->AdvanceFocus(std::move(focus_type), std::move(source_frame_token));
}
void RemoteFrameHostInterceptorForTesting::RouteMessageEvent(const absl::optional<::blink::LocalFrameToken>& source_frame_token, const ::std::u16string& source_origin, const ::std::u16string& target_origin, ::blink::TransferableMessage message) {
  GetForwardingInterface()->RouteMessageEvent(std::move(source_frame_token), std::move(source_origin), std::move(target_origin), std::move(message));
}
void RemoteFrameHostInterceptorForTesting::PrintCrossProcessSubframe(const ::gfx::Rect& frame_content_rect, int32_t document_cookie) {
  GetForwardingInterface()->PrintCrossProcessSubframe(std::move(frame_content_rect), std::move(document_cookie));
}
void RemoteFrameHostInterceptorForTesting::Detach() {
  GetForwardingInterface()->Detach();
}
void RemoteFrameHostInterceptorForTesting::UpdateViewportIntersection(::blink::mojom::ViewportIntersectionStatePtr intersection_state, const absl::optional<::blink::FrameVisualProperties>& visual_properties) {
  GetForwardingInterface()->UpdateViewportIntersection(std::move(intersection_state), std::move(visual_properties));
}
void RemoteFrameHostInterceptorForTesting::SynchronizeVisualProperties(const ::blink::FrameVisualProperties& properties) {
  GetForwardingInterface()->SynchronizeVisualProperties(std::move(properties));
}
void RemoteFrameHostInterceptorForTesting::OpenURL(OpenURLParamsPtr params) {
  GetForwardingInterface()->OpenURL(std::move(params));
}
RemoteFrameHostAsyncWaiter::RemoteFrameHostAsyncWaiter(
    RemoteFrameHost* proxy) : proxy_(proxy) {}

RemoteFrameHostAsyncWaiter::~RemoteFrameHostAsyncWaiter() = default;




void RemoteFrameInterceptorForTesting::WillEnterFullscreen(::blink::mojom::FullscreenOptionsPtr options) {
  GetForwardingInterface()->WillEnterFullscreen(std::move(options));
}
void RemoteFrameInterceptorForTesting::EnforceInsecureNavigationsSet(const std::vector<uint32_t>& set) {
  GetForwardingInterface()->EnforceInsecureNavigationsSet(std::move(set));
}
void RemoteFrameInterceptorForTesting::SetFrameOwnerProperties(::blink::mojom::FrameOwnerPropertiesPtr properties) {
  GetForwardingInterface()->SetFrameOwnerProperties(std::move(properties));
}
void RemoteFrameInterceptorForTesting::EnforceInsecureRequestPolicy(::blink::mojom::InsecureRequestPolicy policy) {
  GetForwardingInterface()->EnforceInsecureRequestPolicy(std::move(policy));
}
void RemoteFrameInterceptorForTesting::SetReplicatedOrigin(const ::url::Origin& origin, bool is_potentially_trustworthy_unique_origin) {
  GetForwardingInterface()->SetReplicatedOrigin(std::move(origin), std::move(is_potentially_trustworthy_unique_origin));
}
void RemoteFrameInterceptorForTesting::SetReplicatedIsAdFrame(bool is_ad_frame) {
  GetForwardingInterface()->SetReplicatedIsAdFrame(std::move(is_ad_frame));
}
void RemoteFrameInterceptorForTesting::SetReplicatedName(const std::string& name, const std::string& unique_name) {
  GetForwardingInterface()->SetReplicatedName(std::move(name), std::move(unique_name));
}
void RemoteFrameInterceptorForTesting::DispatchLoadEventForFrameOwner() {
  GetForwardingInterface()->DispatchLoadEventForFrameOwner();
}
void RemoteFrameInterceptorForTesting::SetNeedsOcclusionTracking(bool needs_tracking) {
  GetForwardingInterface()->SetNeedsOcclusionTracking(std::move(needs_tracking));
}
void RemoteFrameInterceptorForTesting::Collapse(bool collapsed) {
  GetForwardingInterface()->Collapse(std::move(collapsed));
}
void RemoteFrameInterceptorForTesting::Focus() {
  GetForwardingInterface()->Focus();
}
void RemoteFrameInterceptorForTesting::SetHadStickyUserActivationBeforeNavigation(bool has_gesture) {
  GetForwardingInterface()->SetHadStickyUserActivationBeforeNavigation(std::move(has_gesture));
}
void RemoteFrameInterceptorForTesting::BubbleLogicalScroll(::blink::mojom::ScrollDirection direction, ::ui::ScrollGranularity granularity) {
  GetForwardingInterface()->BubbleLogicalScroll(std::move(direction), std::move(granularity));
}
void RemoteFrameInterceptorForTesting::UpdateUserActivationState(::blink::mojom::UserActivationUpdateType state_update_type, ::blink::mojom::UserActivationNotificationType notification_type) {
  GetForwardingInterface()->UpdateUserActivationState(std::move(state_update_type), std::move(notification_type));
}
void RemoteFrameInterceptorForTesting::SetEmbeddingToken(const ::base::UnguessableToken& embedding_token) {
  GetForwardingInterface()->SetEmbeddingToken(std::move(embedding_token));
}
void RemoteFrameInterceptorForTesting::SetPageFocus(bool is_focused) {
  GetForwardingInterface()->SetPageFocus(std::move(is_focused));
}
void RemoteFrameInterceptorForTesting::RenderFallbackContent() {
  GetForwardingInterface()->RenderFallbackContent();
}
void RemoteFrameInterceptorForTesting::RenderFallbackContentWithResourceTiming(::blink::mojom::ResourceTimingInfoPtr timing, const std::string& server_timing_value) {
  GetForwardingInterface()->RenderFallbackContentWithResourceTiming(std::move(timing), std::move(server_timing_value));
}
void RemoteFrameInterceptorForTesting::AddResourceTimingFromChild(::blink::mojom::ResourceTimingInfoPtr timing) {
  GetForwardingInterface()->AddResourceTimingFromChild(std::move(timing));
}
void RemoteFrameInterceptorForTesting::ScrollRectToVisible(const ::gfx::RectF& rect, ::blink::mojom::ScrollIntoViewParamsPtr params) {
  GetForwardingInterface()->ScrollRectToVisible(std::move(rect), std::move(params));
}
void RemoteFrameInterceptorForTesting::DidStartLoading() {
  GetForwardingInterface()->DidStartLoading();
}
void RemoteFrameInterceptorForTesting::DidStopLoading() {
  GetForwardingInterface()->DidStopLoading();
}
void RemoteFrameInterceptorForTesting::IntrinsicSizingInfoOfChildChanged(::blink::mojom::IntrinsicSizingInfoPtr sizing_info) {
  GetForwardingInterface()->IntrinsicSizingInfoOfChildChanged(std::move(sizing_info));
}
void RemoteFrameInterceptorForTesting::DidSetFramePolicyHeaders(::network::mojom::WebSandboxFlags sandbox_flags, const std::vector<::blink::ParsedPermissionsPolicyDeclaration>& parsed_permissions_policy) {
  GetForwardingInterface()->DidSetFramePolicyHeaders(std::move(sandbox_flags), std::move(parsed_permissions_policy));
}
void RemoteFrameInterceptorForTesting::DidUpdateFramePolicy(const ::blink::FramePolicy& frame_policy) {
  GetForwardingInterface()->DidUpdateFramePolicy(std::move(frame_policy));
}
void RemoteFrameInterceptorForTesting::UpdateOpener(const absl::optional<::blink::FrameToken>& opener_frame_token) {
  GetForwardingInterface()->UpdateOpener(std::move(opener_frame_token));
}
void RemoteFrameInterceptorForTesting::DetachAndDispose() {
  GetForwardingInterface()->DetachAndDispose();
}
void RemoteFrameInterceptorForTesting::EnableAutoResize(const ::gfx::Size& min_size, const ::gfx::Size& max_size) {
  GetForwardingInterface()->EnableAutoResize(std::move(min_size), std::move(max_size));
}
void RemoteFrameInterceptorForTesting::DisableAutoResize() {
  GetForwardingInterface()->DisableAutoResize();
}
void RemoteFrameInterceptorForTesting::DidUpdateVisualProperties(const ::cc::RenderFrameMetadata& metadata) {
  GetForwardingInterface()->DidUpdateVisualProperties(std::move(metadata));
}
void RemoteFrameInterceptorForTesting::SetFrameSinkId(const ::viz::FrameSinkId& frame_sink_id) {
  GetForwardingInterface()->SetFrameSinkId(std::move(frame_sink_id));
}
void RemoteFrameInterceptorForTesting::ChildProcessGone() {
  GetForwardingInterface()->ChildProcessGone();
}
void RemoteFrameInterceptorForTesting::CreateRemoteChild(const ::blink::RemoteFrameToken& token, const absl::optional<::blink::FrameToken>& opener_frame_token, ::blink::mojom::TreeScopeType tree_scope_type, ::blink::mojom::FrameReplicationStatePtr replication_state, const ::base::UnguessableToken& devtools_frame_token, RemoteFrameInterfacesFromBrowserPtr remote_frame_interfaces) {
  GetForwardingInterface()->CreateRemoteChild(std::move(token), std::move(opener_frame_token), std::move(tree_scope_type), std::move(replication_state), std::move(devtools_frame_token), std::move(remote_frame_interfaces));
}
RemoteFrameAsyncWaiter::RemoteFrameAsyncWaiter(
    RemoteFrame* proxy) : proxy_(proxy) {}

RemoteFrameAsyncWaiter::~RemoteFrameAsyncWaiter() = default;




void RemoteMainFrameInterceptorForTesting::UpdateTextAutosizerPageInfo(::blink::mojom::TextAutosizerPageInfoPtr page_info) {
  GetForwardingInterface()->UpdateTextAutosizerPageInfo(std::move(page_info));
}
RemoteMainFrameAsyncWaiter::RemoteMainFrameAsyncWaiter(
    RemoteMainFrame* proxy) : proxy_(proxy) {}

RemoteMainFrameAsyncWaiter::~RemoteMainFrameAsyncWaiter() = default;




void RemoteMainFrameHostInterceptorForTesting::FocusPage() {
  GetForwardingInterface()->FocusPage();
}
void RemoteMainFrameHostInterceptorForTesting::TakeFocus(bool reverse) {
  GetForwardingInterface()->TakeFocus(std::move(reverse));
}
void RemoteMainFrameHostInterceptorForTesting::UpdateTargetURL(const ::GURL& url, UpdateTargetURLCallback callback) {
  GetForwardingInterface()->UpdateTargetURL(std::move(url), std::move(callback));
}
void RemoteMainFrameHostInterceptorForTesting::RouteCloseEvent() {
  GetForwardingInterface()->RouteCloseEvent();
}
RemoteMainFrameHostAsyncWaiter::RemoteMainFrameHostAsyncWaiter(
    RemoteMainFrameHost* proxy) : proxy_(proxy) {}

RemoteMainFrameHostAsyncWaiter::~RemoteMainFrameHostAsyncWaiter() = default;

void RemoteMainFrameHostAsyncWaiter::UpdateTargetURL(
    const ::GURL& url) {
  base::RunLoop loop;
  proxy_->UpdateTargetURL(std::move(url),
      base::BindOnce(
          [](base::RunLoop* loop) {
            loop->Quit();
          },
          &loop));
  loop.Run();
}





}  // namespace mojom
}  // namespace blink


#if defined(__clang__)
#pragma clang diagnostic pop
#endif