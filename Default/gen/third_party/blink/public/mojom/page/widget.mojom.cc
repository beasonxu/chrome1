// third_party/blink/public/mojom/page/widget.mojom.cc is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2013 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#if defined(__clang__)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-private-field"
#endif

#include "third_party/blink/public/mojom/page/widget.mojom.h"

#include <math.h>
#include <stdint.h>
#include <utility>

#include "base/debug/alias.h"
#include "base/hash/md5_constexpr.h"
#include "base/run_loop.h"
#include "base/strings/string_number_conversions.h"
#include "base/trace_event/trace_event.h"
#include "base/trace_event/typed_macros.h"
#include "mojo/public/cpp/bindings/lib/generated_code_util.h"
#include "mojo/public/cpp/bindings/lib/message_internal.h"
#include "mojo/public/cpp/bindings/lib/send_message_helper.h"
#include "mojo/public/cpp/bindings/lib/proxy_to_responder.h"
#include "mojo/public/cpp/bindings/lib/serialization_util.h"
#include "mojo/public/cpp/bindings/lib/unserialized_message_context.h"
#include "mojo/public/cpp/bindings/lib/validate_params.h"
#include "mojo/public/cpp/bindings/lib/validation_errors.h"
#include "mojo/public/cpp/bindings/mojo_buildflags.h"
#include "mojo/public/interfaces/bindings/interface_control_messages.mojom.h"
#include "third_party/perfetto/include/perfetto/tracing/traced_value.h"

#include "third_party/blink/public/mojom/page/widget.mojom-params-data.h"
#include "third_party/blink/public/mojom/page/widget.mojom-shared-message-ids.h"

#include "third_party/blink/public/mojom/page/widget.mojom-import-headers.h"
#include "third_party/blink/public/mojom/page/widget.mojom-test-utils.h"


#ifndef THIRD_PARTY_BLINK_PUBLIC_MOJOM_PAGE_WIDGET_MOJOM_JUMBO_H_
#define THIRD_PARTY_BLINK_PUBLIC_MOJOM_PAGE_WIDGET_MOJOM_JUMBO_H_
#endif



namespace blink {
namespace mojom {
const char FrameWidget::Name_[] = "blink.mojom.FrameWidget";

FrameWidget::IPCStableHashFunction FrameWidget::MessageToMethodInfo_(mojo::Message& message) {
#if !BUILDFLAG(IS_FUCHSIA)
  switch (message.name()) {
    case internal::kFrameWidget_DragTargetDragEnter_Name: {
      return &FrameWidget::DragTargetDragEnter_Sym::IPCStableHash;
    }
    case internal::kFrameWidget_DragTargetDragOver_Name: {
      return &FrameWidget::DragTargetDragOver_Sym::IPCStableHash;
    }
    case internal::kFrameWidget_DragTargetDragLeave_Name: {
      return &FrameWidget::DragTargetDragLeave_Sym::IPCStableHash;
    }
    case internal::kFrameWidget_DragTargetDrop_Name: {
      return &FrameWidget::DragTargetDrop_Sym::IPCStableHash;
    }
    case internal::kFrameWidget_DragSourceEndedAt_Name: {
      return &FrameWidget::DragSourceEndedAt_Sym::IPCStableHash;
    }
    case internal::kFrameWidget_DragSourceSystemDragEnded_Name: {
      return &FrameWidget::DragSourceSystemDragEnded_Sym::IPCStableHash;
    }
    case internal::kFrameWidget_OnStartStylusWriting_Name: {
      return &FrameWidget::OnStartStylusWriting_Sym::IPCStableHash;
    }
    case internal::kFrameWidget_SetBackgroundOpaque_Name: {
      return &FrameWidget::SetBackgroundOpaque_Sym::IPCStableHash;
    }
    case internal::kFrameWidget_SetTextDirection_Name: {
      return &FrameWidget::SetTextDirection_Sym::IPCStableHash;
    }
    case internal::kFrameWidget_SetActive_Name: {
      return &FrameWidget::SetActive_Sym::IPCStableHash;
    }
    case internal::kFrameWidget_SetInheritedEffectiveTouchActionForSubFrame_Name: {
      return &FrameWidget::SetInheritedEffectiveTouchActionForSubFrame_Sym::IPCStableHash;
    }
    case internal::kFrameWidget_UpdateRenderThrottlingStatusForSubFrame_Name: {
      return &FrameWidget::UpdateRenderThrottlingStatusForSubFrame_Sym::IPCStableHash;
    }
    case internal::kFrameWidget_SetIsInertForSubFrame_Name: {
      return &FrameWidget::SetIsInertForSubFrame_Sym::IPCStableHash;
    }
    case internal::kFrameWidget_ShowContextMenu_Name: {
      return &FrameWidget::ShowContextMenu_Sym::IPCStableHash;
    }
    case internal::kFrameWidget_EnableDeviceEmulation_Name: {
      return &FrameWidget::EnableDeviceEmulation_Sym::IPCStableHash;
    }
    case internal::kFrameWidget_DisableDeviceEmulation_Name: {
      return &FrameWidget::DisableDeviceEmulation_Sym::IPCStableHash;
    }
    case internal::kFrameWidget_BindWidgetCompositor_Name: {
      return &FrameWidget::BindWidgetCompositor_Sym::IPCStableHash;
    }
    case internal::kFrameWidget_BindInputTargetClient_Name: {
      return &FrameWidget::BindInputTargetClient_Sym::IPCStableHash;
    }
    case internal::kFrameWidget_SetViewportIntersection_Name: {
      return &FrameWidget::SetViewportIntersection_Sym::IPCStableHash;
    }
  }
#endif  // !BUILDFLAG(IS_FUCHSIA)
  return nullptr;
}


const char* FrameWidget::MessageToMethodName_(mojo::Message& message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  bool is_response = message.has_flag(mojo::Message::kFlagIsResponse);
  if (!is_response) {
    switch (message.name()) {
      case internal::kFrameWidget_DragTargetDragEnter_Name:
            return "Receive blink::mojom::FrameWidget::DragTargetDragEnter";
      case internal::kFrameWidget_DragTargetDragOver_Name:
            return "Receive blink::mojom::FrameWidget::DragTargetDragOver";
      case internal::kFrameWidget_DragTargetDragLeave_Name:
            return "Receive blink::mojom::FrameWidget::DragTargetDragLeave";
      case internal::kFrameWidget_DragTargetDrop_Name:
            return "Receive blink::mojom::FrameWidget::DragTargetDrop";
      case internal::kFrameWidget_DragSourceEndedAt_Name:
            return "Receive blink::mojom::FrameWidget::DragSourceEndedAt";
      case internal::kFrameWidget_DragSourceSystemDragEnded_Name:
            return "Receive blink::mojom::FrameWidget::DragSourceSystemDragEnded";
      case internal::kFrameWidget_OnStartStylusWriting_Name:
            return "Receive blink::mojom::FrameWidget::OnStartStylusWriting";
      case internal::kFrameWidget_SetBackgroundOpaque_Name:
            return "Receive blink::mojom::FrameWidget::SetBackgroundOpaque";
      case internal::kFrameWidget_SetTextDirection_Name:
            return "Receive blink::mojom::FrameWidget::SetTextDirection";
      case internal::kFrameWidget_SetActive_Name:
            return "Receive blink::mojom::FrameWidget::SetActive";
      case internal::kFrameWidget_SetInheritedEffectiveTouchActionForSubFrame_Name:
            return "Receive blink::mojom::FrameWidget::SetInheritedEffectiveTouchActionForSubFrame";
      case internal::kFrameWidget_UpdateRenderThrottlingStatusForSubFrame_Name:
            return "Receive blink::mojom::FrameWidget::UpdateRenderThrottlingStatusForSubFrame";
      case internal::kFrameWidget_SetIsInertForSubFrame_Name:
            return "Receive blink::mojom::FrameWidget::SetIsInertForSubFrame";
      case internal::kFrameWidget_ShowContextMenu_Name:
            return "Receive blink::mojom::FrameWidget::ShowContextMenu";
      case internal::kFrameWidget_EnableDeviceEmulation_Name:
            return "Receive blink::mojom::FrameWidget::EnableDeviceEmulation";
      case internal::kFrameWidget_DisableDeviceEmulation_Name:
            return "Receive blink::mojom::FrameWidget::DisableDeviceEmulation";
      case internal::kFrameWidget_BindWidgetCompositor_Name:
            return "Receive blink::mojom::FrameWidget::BindWidgetCompositor";
      case internal::kFrameWidget_BindInputTargetClient_Name:
            return "Receive blink::mojom::FrameWidget::BindInputTargetClient";
      case internal::kFrameWidget_SetViewportIntersection_Name:
            return "Receive blink::mojom::FrameWidget::SetViewportIntersection";
    }
  } else {
    switch (message.name()) {
      case internal::kFrameWidget_DragTargetDragEnter_Name:
            return "Receive reply blink::mojom::FrameWidget::DragTargetDragEnter";
      case internal::kFrameWidget_DragTargetDragOver_Name:
            return "Receive reply blink::mojom::FrameWidget::DragTargetDragOver";
      case internal::kFrameWidget_DragTargetDragLeave_Name:
            return "Receive reply blink::mojom::FrameWidget::DragTargetDragLeave";
      case internal::kFrameWidget_DragTargetDrop_Name:
            return "Receive reply blink::mojom::FrameWidget::DragTargetDrop";
      case internal::kFrameWidget_DragSourceEndedAt_Name:
            return "Receive reply blink::mojom::FrameWidget::DragSourceEndedAt";
      case internal::kFrameWidget_DragSourceSystemDragEnded_Name:
            return "Receive reply blink::mojom::FrameWidget::DragSourceSystemDragEnded";
      case internal::kFrameWidget_OnStartStylusWriting_Name:
            return "Receive reply blink::mojom::FrameWidget::OnStartStylusWriting";
      case internal::kFrameWidget_SetBackgroundOpaque_Name:
            return "Receive reply blink::mojom::FrameWidget::SetBackgroundOpaque";
      case internal::kFrameWidget_SetTextDirection_Name:
            return "Receive reply blink::mojom::FrameWidget::SetTextDirection";
      case internal::kFrameWidget_SetActive_Name:
            return "Receive reply blink::mojom::FrameWidget::SetActive";
      case internal::kFrameWidget_SetInheritedEffectiveTouchActionForSubFrame_Name:
            return "Receive reply blink::mojom::FrameWidget::SetInheritedEffectiveTouchActionForSubFrame";
      case internal::kFrameWidget_UpdateRenderThrottlingStatusForSubFrame_Name:
            return "Receive reply blink::mojom::FrameWidget::UpdateRenderThrottlingStatusForSubFrame";
      case internal::kFrameWidget_SetIsInertForSubFrame_Name:
            return "Receive reply blink::mojom::FrameWidget::SetIsInertForSubFrame";
      case internal::kFrameWidget_ShowContextMenu_Name:
            return "Receive reply blink::mojom::FrameWidget::ShowContextMenu";
      case internal::kFrameWidget_EnableDeviceEmulation_Name:
            return "Receive reply blink::mojom::FrameWidget::EnableDeviceEmulation";
      case internal::kFrameWidget_DisableDeviceEmulation_Name:
            return "Receive reply blink::mojom::FrameWidget::DisableDeviceEmulation";
      case internal::kFrameWidget_BindWidgetCompositor_Name:
            return "Receive reply blink::mojom::FrameWidget::BindWidgetCompositor";
      case internal::kFrameWidget_BindInputTargetClient_Name:
            return "Receive reply blink::mojom::FrameWidget::BindInputTargetClient";
      case internal::kFrameWidget_SetViewportIntersection_Name:
            return "Receive reply blink::mojom::FrameWidget::SetViewportIntersection";
    }
  }
  return "Receive unknown mojo message";
#else
  bool is_response = message.has_flag(mojo::Message::kFlagIsResponse);
  if (is_response) {
    return "Receive mojo reply";
  } else {
    return "Receive mojo message";
  }
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
}

#if !BUILDFLAG(IS_FUCHSIA)
uint32_t FrameWidget::DragTargetDragEnter_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::FrameWidget::DragTargetDragEnter");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t FrameWidget::DragTargetDragOver_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::FrameWidget::DragTargetDragOver");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t FrameWidget::DragTargetDragLeave_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::FrameWidget::DragTargetDragLeave");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t FrameWidget::DragTargetDrop_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::FrameWidget::DragTargetDrop");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t FrameWidget::DragSourceEndedAt_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::FrameWidget::DragSourceEndedAt");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t FrameWidget::DragSourceSystemDragEnded_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::FrameWidget::DragSourceSystemDragEnded");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t FrameWidget::OnStartStylusWriting_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::FrameWidget::OnStartStylusWriting");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t FrameWidget::SetBackgroundOpaque_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::FrameWidget::SetBackgroundOpaque");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t FrameWidget::SetTextDirection_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::FrameWidget::SetTextDirection");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t FrameWidget::SetActive_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::FrameWidget::SetActive");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t FrameWidget::SetInheritedEffectiveTouchActionForSubFrame_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::FrameWidget::SetInheritedEffectiveTouchActionForSubFrame");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t FrameWidget::UpdateRenderThrottlingStatusForSubFrame_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::FrameWidget::UpdateRenderThrottlingStatusForSubFrame");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t FrameWidget::SetIsInertForSubFrame_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::FrameWidget::SetIsInertForSubFrame");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t FrameWidget::ShowContextMenu_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::FrameWidget::ShowContextMenu");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t FrameWidget::EnableDeviceEmulation_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::FrameWidget::EnableDeviceEmulation");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t FrameWidget::DisableDeviceEmulation_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::FrameWidget::DisableDeviceEmulation");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t FrameWidget::BindWidgetCompositor_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::FrameWidget::BindWidgetCompositor");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t FrameWidget::BindInputTargetClient_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::FrameWidget::BindInputTargetClient");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t FrameWidget::SetViewportIntersection_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::FrameWidget::SetViewportIntersection");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
# endif // !BUILDFLAG(IS_FUCHSIA)

class FrameWidget_DragTargetDragEnter_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  FrameWidget_DragTargetDragEnter_ForwardToCallback(
      FrameWidget::DragTargetDragEnterCallback callback
      ) : callback_(std::move(callback)) {
  }

  FrameWidget_DragTargetDragEnter_ForwardToCallback(const FrameWidget_DragTargetDragEnter_ForwardToCallback&) = delete;
  FrameWidget_DragTargetDragEnter_ForwardToCallback& operator=(const FrameWidget_DragTargetDragEnter_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  FrameWidget::DragTargetDragEnterCallback callback_;
};

class FrameWidget_DragTargetDragOver_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  FrameWidget_DragTargetDragOver_ForwardToCallback(
      FrameWidget::DragTargetDragOverCallback callback
      ) : callback_(std::move(callback)) {
  }

  FrameWidget_DragTargetDragOver_ForwardToCallback(const FrameWidget_DragTargetDragOver_ForwardToCallback&) = delete;
  FrameWidget_DragTargetDragOver_ForwardToCallback& operator=(const FrameWidget_DragTargetDragOver_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  FrameWidget::DragTargetDragOverCallback callback_;
};

class FrameWidget_DragTargetDrop_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  FrameWidget_DragTargetDrop_ForwardToCallback(
      FrameWidget::DragTargetDropCallback callback
      ) : callback_(std::move(callback)) {
  }

  FrameWidget_DragTargetDrop_ForwardToCallback(const FrameWidget_DragTargetDrop_ForwardToCallback&) = delete;
  FrameWidget_DragTargetDrop_ForwardToCallback& operator=(const FrameWidget_DragTargetDrop_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  FrameWidget::DragTargetDropCallback callback_;
};

class FrameWidget_DragSourceEndedAt_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  FrameWidget_DragSourceEndedAt_ForwardToCallback(
      FrameWidget::DragSourceEndedAtCallback callback
      ) : callback_(std::move(callback)) {
  }

  FrameWidget_DragSourceEndedAt_ForwardToCallback(const FrameWidget_DragSourceEndedAt_ForwardToCallback&) = delete;
  FrameWidget_DragSourceEndedAt_ForwardToCallback& operator=(const FrameWidget_DragSourceEndedAt_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  FrameWidget::DragSourceEndedAtCallback callback_;
};

class FrameWidget_OnStartStylusWriting_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  FrameWidget_OnStartStylusWriting_ForwardToCallback(
      FrameWidget::OnStartStylusWritingCallback callback
      ) : callback_(std::move(callback)) {
  }

  FrameWidget_OnStartStylusWriting_ForwardToCallback(const FrameWidget_OnStartStylusWriting_ForwardToCallback&) = delete;
  FrameWidget_OnStartStylusWriting_ForwardToCallback& operator=(const FrameWidget_OnStartStylusWriting_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  FrameWidget::OnStartStylusWritingCallback callback_;
};

FrameWidgetProxy::FrameWidgetProxy(mojo::MessageReceiverWithResponder* receiver)
    : receiver_(receiver) {
}

void FrameWidgetProxy::DragTargetDragEnter(
    ::blink::mojom::DragDataPtr in_drag_data, const ::gfx::PointF& in_point_in_viewport, const ::gfx::PointF& in_screen_point, ::blink::DragOperationsMask in_operations_allowed, uint32_t in_key_modifiers, DragTargetDragEnterCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::FrameWidget::DragTargetDragEnter", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("drag_data"), in_drag_data,
                        "<value of type ::blink::mojom::DragDataPtr>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("point_in_viewport"), in_point_in_viewport,
                        "<value of type const ::gfx::PointF&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("screen_point"), in_screen_point,
                        "<value of type const ::gfx::PointF&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("operations_allowed"), in_operations_allowed,
                        "<value of type ::blink::DragOperationsMask>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("key_modifiers"), in_key_modifiers,
                        "<value of type uint32_t>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kFrameWidget_DragTargetDragEnter_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::FrameWidget_DragTargetDragEnter_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->drag_data)::BaseType> drag_data_fragment(
          params.message());
  mojo::internal::Serialize<::blink::mojom::DragDataDataView>(
      in_drag_data, drag_data_fragment);
  params->drag_data.Set(
      drag_data_fragment.is_null() ? nullptr : drag_data_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->drag_data.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null drag_data in FrameWidget.DragTargetDragEnter request");
  mojo::internal::MessageFragment<
      typename decltype(params->point_in_viewport)::BaseType> point_in_viewport_fragment(
          params.message());
  mojo::internal::Serialize<::gfx::mojom::PointFDataView>(
      in_point_in_viewport, point_in_viewport_fragment);
  params->point_in_viewport.Set(
      point_in_viewport_fragment.is_null() ? nullptr : point_in_viewport_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->point_in_viewport.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null point_in_viewport in FrameWidget.DragTargetDragEnter request");
  mojo::internal::MessageFragment<
      typename decltype(params->screen_point)::BaseType> screen_point_fragment(
          params.message());
  mojo::internal::Serialize<::gfx::mojom::PointFDataView>(
      in_screen_point, screen_point_fragment);
  params->screen_point.Set(
      screen_point_fragment.is_null() ? nullptr : screen_point_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->screen_point.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null screen_point in FrameWidget.DragTargetDragEnter request");
  mojo::internal::MessageFragment<
      typename decltype(params->operations_allowed)::BaseType> operations_allowed_fragment(
          params.message());
  mojo::internal::Serialize<::blink::mojom::AllowedDragOperationsDataView>(
      in_operations_allowed, operations_allowed_fragment);
  params->operations_allowed.Set(
      operations_allowed_fragment.is_null() ? nullptr : operations_allowed_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->operations_allowed.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null operations_allowed in FrameWidget.DragTargetDragEnter request");
  params->key_modifiers = in_key_modifiers;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(FrameWidget::Name_);
  message.set_method_name("DragTargetDragEnter");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new FrameWidget_DragTargetDragEnter_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void FrameWidgetProxy::DragTargetDragOver(
    const ::gfx::PointF& in_point_in_viewport, const ::gfx::PointF& in_screen_point, ::blink::DragOperationsMask in_operations_allowed, uint32_t in_key_modifiers, DragTargetDragOverCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::FrameWidget::DragTargetDragOver", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("point_in_viewport"), in_point_in_viewport,
                        "<value of type const ::gfx::PointF&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("screen_point"), in_screen_point,
                        "<value of type const ::gfx::PointF&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("operations_allowed"), in_operations_allowed,
                        "<value of type ::blink::DragOperationsMask>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("key_modifiers"), in_key_modifiers,
                        "<value of type uint32_t>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kFrameWidget_DragTargetDragOver_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::FrameWidget_DragTargetDragOver_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->point_in_viewport)::BaseType> point_in_viewport_fragment(
          params.message());
  mojo::internal::Serialize<::gfx::mojom::PointFDataView>(
      in_point_in_viewport, point_in_viewport_fragment);
  params->point_in_viewport.Set(
      point_in_viewport_fragment.is_null() ? nullptr : point_in_viewport_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->point_in_viewport.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null point_in_viewport in FrameWidget.DragTargetDragOver request");
  mojo::internal::MessageFragment<
      typename decltype(params->screen_point)::BaseType> screen_point_fragment(
          params.message());
  mojo::internal::Serialize<::gfx::mojom::PointFDataView>(
      in_screen_point, screen_point_fragment);
  params->screen_point.Set(
      screen_point_fragment.is_null() ? nullptr : screen_point_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->screen_point.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null screen_point in FrameWidget.DragTargetDragOver request");
  mojo::internal::MessageFragment<
      typename decltype(params->operations_allowed)::BaseType> operations_allowed_fragment(
          params.message());
  mojo::internal::Serialize<::blink::mojom::AllowedDragOperationsDataView>(
      in_operations_allowed, operations_allowed_fragment);
  params->operations_allowed.Set(
      operations_allowed_fragment.is_null() ? nullptr : operations_allowed_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->operations_allowed.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null operations_allowed in FrameWidget.DragTargetDragOver request");
  params->key_modifiers = in_key_modifiers;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(FrameWidget::Name_);
  message.set_method_name("DragTargetDragOver");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new FrameWidget_DragTargetDragOver_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void FrameWidgetProxy::DragTargetDragLeave(
    const ::gfx::PointF& in_point_in_viewport, const ::gfx::PointF& in_screen_point) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::FrameWidget::DragTargetDragLeave", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("point_in_viewport"), in_point_in_viewport,
                        "<value of type const ::gfx::PointF&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("screen_point"), in_screen_point,
                        "<value of type const ::gfx::PointF&>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kFrameWidget_DragTargetDragLeave_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::FrameWidget_DragTargetDragLeave_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->point_in_viewport)::BaseType> point_in_viewport_fragment(
          params.message());
  mojo::internal::Serialize<::gfx::mojom::PointFDataView>(
      in_point_in_viewport, point_in_viewport_fragment);
  params->point_in_viewport.Set(
      point_in_viewport_fragment.is_null() ? nullptr : point_in_viewport_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->point_in_viewport.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null point_in_viewport in FrameWidget.DragTargetDragLeave request");
  mojo::internal::MessageFragment<
      typename decltype(params->screen_point)::BaseType> screen_point_fragment(
          params.message());
  mojo::internal::Serialize<::gfx::mojom::PointFDataView>(
      in_screen_point, screen_point_fragment);
  params->screen_point.Set(
      screen_point_fragment.is_null() ? nullptr : screen_point_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->screen_point.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null screen_point in FrameWidget.DragTargetDragLeave request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(FrameWidget::Name_);
  message.set_method_name("DragTargetDragLeave");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void FrameWidgetProxy::DragTargetDrop(
    ::blink::mojom::DragDataPtr in_drag_data, const ::gfx::PointF& in_point_in_viewport, const ::gfx::PointF& in_screen_point, uint32_t in_key_modifiers, DragTargetDropCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::FrameWidget::DragTargetDrop", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("drag_data"), in_drag_data,
                        "<value of type ::blink::mojom::DragDataPtr>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("point_in_viewport"), in_point_in_viewport,
                        "<value of type const ::gfx::PointF&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("screen_point"), in_screen_point,
                        "<value of type const ::gfx::PointF&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("key_modifiers"), in_key_modifiers,
                        "<value of type uint32_t>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kFrameWidget_DragTargetDrop_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::FrameWidget_DragTargetDrop_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->drag_data)::BaseType> drag_data_fragment(
          params.message());
  mojo::internal::Serialize<::blink::mojom::DragDataDataView>(
      in_drag_data, drag_data_fragment);
  params->drag_data.Set(
      drag_data_fragment.is_null() ? nullptr : drag_data_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->drag_data.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null drag_data in FrameWidget.DragTargetDrop request");
  mojo::internal::MessageFragment<
      typename decltype(params->point_in_viewport)::BaseType> point_in_viewport_fragment(
          params.message());
  mojo::internal::Serialize<::gfx::mojom::PointFDataView>(
      in_point_in_viewport, point_in_viewport_fragment);
  params->point_in_viewport.Set(
      point_in_viewport_fragment.is_null() ? nullptr : point_in_viewport_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->point_in_viewport.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null point_in_viewport in FrameWidget.DragTargetDrop request");
  mojo::internal::MessageFragment<
      typename decltype(params->screen_point)::BaseType> screen_point_fragment(
          params.message());
  mojo::internal::Serialize<::gfx::mojom::PointFDataView>(
      in_screen_point, screen_point_fragment);
  params->screen_point.Set(
      screen_point_fragment.is_null() ? nullptr : screen_point_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->screen_point.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null screen_point in FrameWidget.DragTargetDrop request");
  params->key_modifiers = in_key_modifiers;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(FrameWidget::Name_);
  message.set_method_name("DragTargetDrop");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new FrameWidget_DragTargetDrop_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void FrameWidgetProxy::DragSourceEndedAt(
    const ::gfx::PointF& in_point_in_viewport, const ::gfx::PointF& in_screen_point, ::ui::mojom::DragOperation in_drag_operation, DragSourceEndedAtCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::FrameWidget::DragSourceEndedAt", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("point_in_viewport"), in_point_in_viewport,
                        "<value of type const ::gfx::PointF&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("screen_point"), in_screen_point,
                        "<value of type const ::gfx::PointF&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("drag_operation"), in_drag_operation,
                        "<value of type ::ui::mojom::DragOperation>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kFrameWidget_DragSourceEndedAt_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::FrameWidget_DragSourceEndedAt_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->point_in_viewport)::BaseType> point_in_viewport_fragment(
          params.message());
  mojo::internal::Serialize<::gfx::mojom::PointFDataView>(
      in_point_in_viewport, point_in_viewport_fragment);
  params->point_in_viewport.Set(
      point_in_viewport_fragment.is_null() ? nullptr : point_in_viewport_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->point_in_viewport.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null point_in_viewport in FrameWidget.DragSourceEndedAt request");
  mojo::internal::MessageFragment<
      typename decltype(params->screen_point)::BaseType> screen_point_fragment(
          params.message());
  mojo::internal::Serialize<::gfx::mojom::PointFDataView>(
      in_screen_point, screen_point_fragment);
  params->screen_point.Set(
      screen_point_fragment.is_null() ? nullptr : screen_point_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->screen_point.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null screen_point in FrameWidget.DragSourceEndedAt request");
  mojo::internal::Serialize<::ui::mojom::DragOperation>(
      in_drag_operation, &params->drag_operation);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(FrameWidget::Name_);
  message.set_method_name("DragSourceEndedAt");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new FrameWidget_DragSourceEndedAt_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void FrameWidgetProxy::DragSourceSystemDragEnded(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send blink::mojom::FrameWidget::DragSourceSystemDragEnded");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kFrameWidget_DragSourceSystemDragEnded_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::FrameWidget_DragSourceSystemDragEnded_Params_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(FrameWidget::Name_);
  message.set_method_name("DragSourceSystemDragEnded");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void FrameWidgetProxy::OnStartStylusWriting(
    OnStartStylusWritingCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send blink::mojom::FrameWidget::OnStartStylusWriting");
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kFrameWidget_OnStartStylusWriting_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::FrameWidget_OnStartStylusWriting_Params_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(FrameWidget::Name_);
  message.set_method_name("OnStartStylusWriting");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new FrameWidget_OnStartStylusWriting_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void FrameWidgetProxy::SetBackgroundOpaque(
    bool in_opaque) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::FrameWidget::SetBackgroundOpaque", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("opaque"), in_opaque,
                        "<value of type bool>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kFrameWidget_SetBackgroundOpaque_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::FrameWidget_SetBackgroundOpaque_Params_Data> params(
          message);
  params.Allocate();
  params->opaque = in_opaque;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(FrameWidget::Name_);
  message.set_method_name("SetBackgroundOpaque");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void FrameWidgetProxy::SetTextDirection(
    ::base::i18n::TextDirection in_direction) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::FrameWidget::SetTextDirection", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("direction"), in_direction,
                        "<value of type ::base::i18n::TextDirection>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kFrameWidget_SetTextDirection_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::FrameWidget_SetTextDirection_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::Serialize<::mojo_base::mojom::TextDirection>(
      in_direction, &params->direction);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(FrameWidget::Name_);
  message.set_method_name("SetTextDirection");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void FrameWidgetProxy::SetActive(
    bool in_active) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::FrameWidget::SetActive", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("active"), in_active,
                        "<value of type bool>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kFrameWidget_SetActive_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::FrameWidget_SetActive_Params_Data> params(
          message);
  params.Allocate();
  params->active = in_active;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(FrameWidget::Name_);
  message.set_method_name("SetActive");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void FrameWidgetProxy::SetInheritedEffectiveTouchActionForSubFrame(
    ::cc::TouchAction in_touch_action) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::FrameWidget::SetInheritedEffectiveTouchActionForSubFrame", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("touch_action"), in_touch_action,
                        "<value of type ::cc::TouchAction>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kFrameWidget_SetInheritedEffectiveTouchActionForSubFrame_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::FrameWidget_SetInheritedEffectiveTouchActionForSubFrame_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::Serialize<::cc::mojom::TouchAction>(
      in_touch_action, &params->touch_action);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(FrameWidget::Name_);
  message.set_method_name("SetInheritedEffectiveTouchActionForSubFrame");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void FrameWidgetProxy::UpdateRenderThrottlingStatusForSubFrame(
    bool in_is_throttled, bool in_subtree_throttled, bool in_display_locked) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::FrameWidget::UpdateRenderThrottlingStatusForSubFrame", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("is_throttled"), in_is_throttled,
                        "<value of type bool>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("subtree_throttled"), in_subtree_throttled,
                        "<value of type bool>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("display_locked"), in_display_locked,
                        "<value of type bool>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kFrameWidget_UpdateRenderThrottlingStatusForSubFrame_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::FrameWidget_UpdateRenderThrottlingStatusForSubFrame_Params_Data> params(
          message);
  params.Allocate();
  params->is_throttled = in_is_throttled;
  params->subtree_throttled = in_subtree_throttled;
  params->display_locked = in_display_locked;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(FrameWidget::Name_);
  message.set_method_name("UpdateRenderThrottlingStatusForSubFrame");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void FrameWidgetProxy::SetIsInertForSubFrame(
    bool in_inert) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::FrameWidget::SetIsInertForSubFrame", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("inert"), in_inert,
                        "<value of type bool>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kFrameWidget_SetIsInertForSubFrame_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::FrameWidget_SetIsInertForSubFrame_Params_Data> params(
          message);
  params.Allocate();
  params->inert = in_inert;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(FrameWidget::Name_);
  message.set_method_name("SetIsInertForSubFrame");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void FrameWidgetProxy::ShowContextMenu(
    ::ui::MenuSourceType in_source_type, const ::gfx::Point& in_location) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::FrameWidget::ShowContextMenu", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("source_type"), in_source_type,
                        "<value of type ::ui::MenuSourceType>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("location"), in_location,
                        "<value of type const ::gfx::Point&>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kFrameWidget_ShowContextMenu_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::FrameWidget_ShowContextMenu_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::Serialize<::ui::mojom::MenuSourceType>(
      in_source_type, &params->source_type);
  mojo::internal::MessageFragment<
      typename decltype(params->location)::BaseType> location_fragment(
          params.message());
  mojo::internal::Serialize<::gfx::mojom::PointDataView>(
      in_location, location_fragment);
  params->location.Set(
      location_fragment.is_null() ? nullptr : location_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->location.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null location in FrameWidget.ShowContextMenu request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(FrameWidget::Name_);
  message.set_method_name("ShowContextMenu");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void FrameWidgetProxy::EnableDeviceEmulation(
    const ::blink::DeviceEmulationParams& in_parameters) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::FrameWidget::EnableDeviceEmulation", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("parameters"), in_parameters,
                        "<value of type const ::blink::DeviceEmulationParams&>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kFrameWidget_EnableDeviceEmulation_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::FrameWidget_EnableDeviceEmulation_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->parameters)::BaseType> parameters_fragment(
          params.message());
  mojo::internal::Serialize<::blink::mojom::DeviceEmulationParamsDataView>(
      in_parameters, parameters_fragment);
  params->parameters.Set(
      parameters_fragment.is_null() ? nullptr : parameters_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->parameters.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null parameters in FrameWidget.EnableDeviceEmulation request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(FrameWidget::Name_);
  message.set_method_name("EnableDeviceEmulation");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void FrameWidgetProxy::DisableDeviceEmulation(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send blink::mojom::FrameWidget::DisableDeviceEmulation");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kFrameWidget_DisableDeviceEmulation_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::FrameWidget_DisableDeviceEmulation_Params_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(FrameWidget::Name_);
  message.set_method_name("DisableDeviceEmulation");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void FrameWidgetProxy::BindWidgetCompositor(
    ::mojo::PendingReceiver<::blink::mojom::WidgetCompositor> in_host) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::FrameWidget::BindWidgetCompositor", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("host"), in_host,
                        "<value of type ::mojo::PendingReceiver<::blink::mojom::WidgetCompositor>>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kFrameWidget_BindWidgetCompositor_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::FrameWidget_BindWidgetCompositor_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::Serialize<mojo::InterfaceRequestDataView<::blink::mojom::WidgetCompositorInterfaceBase>>(
      in_host, &params->host, &params.message());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      !mojo::internal::IsHandleOrInterfaceValid(params->host),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_INVALID_HANDLE,
      "invalid host in FrameWidget.BindWidgetCompositor request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(FrameWidget::Name_);
  message.set_method_name("BindWidgetCompositor");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void FrameWidgetProxy::BindInputTargetClient(
    ::mojo::PendingReceiver<::viz::mojom::InputTargetClient> in_host) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::FrameWidget::BindInputTargetClient", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("host"), in_host,
                        "<value of type ::mojo::PendingReceiver<::viz::mojom::InputTargetClient>>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kFrameWidget_BindInputTargetClient_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::FrameWidget_BindInputTargetClient_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::Serialize<mojo::InterfaceRequestDataView<::viz::mojom::InputTargetClientInterfaceBase>>(
      in_host, &params->host, &params.message());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      !mojo::internal::IsHandleOrInterfaceValid(params->host),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_INVALID_HANDLE,
      "invalid host in FrameWidget.BindInputTargetClient request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(FrameWidget::Name_);
  message.set_method_name("BindInputTargetClient");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void FrameWidgetProxy::SetViewportIntersection(
    ::blink::mojom::ViewportIntersectionStatePtr in_intersection_state, const absl::optional<::blink::VisualProperties>& in_visual_properties) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::FrameWidget::SetViewportIntersection", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("intersection_state"), in_intersection_state,
                        "<value of type ::blink::mojom::ViewportIntersectionStatePtr>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("visual_properties"), in_visual_properties,
                        "<value of type const absl::optional<::blink::VisualProperties>&>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kFrameWidget_SetViewportIntersection_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::FrameWidget_SetViewportIntersection_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->intersection_state)::BaseType> intersection_state_fragment(
          params.message());
  mojo::internal::Serialize<::blink::mojom::ViewportIntersectionStateDataView>(
      in_intersection_state, intersection_state_fragment);
  params->intersection_state.Set(
      intersection_state_fragment.is_null() ? nullptr : intersection_state_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->intersection_state.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null intersection_state in FrameWidget.SetViewportIntersection request");
  mojo::internal::MessageFragment<
      typename decltype(params->visual_properties)::BaseType> visual_properties_fragment(
          params.message());
  mojo::internal::Serialize<::blink::mojom::VisualPropertiesDataView>(
      in_visual_properties, visual_properties_fragment);
  params->visual_properties.Set(
      visual_properties_fragment.is_null() ? nullptr : visual_properties_fragment.data());

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(FrameWidget::Name_);
  message.set_method_name("SetViewportIntersection");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}
class FrameWidget_DragTargetDragEnter_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static FrameWidget::DragTargetDragEnterCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<FrameWidget_DragTargetDragEnter_ProxyToResponder> proxy(
        new FrameWidget_DragTargetDragEnter_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&FrameWidget_DragTargetDragEnter_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~FrameWidget_DragTargetDragEnter_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  FrameWidget_DragTargetDragEnter_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "FrameWidget::DragTargetDragEnterCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      ::ui::mojom::DragOperation in_operation);
};

bool FrameWidget_DragTargetDragEnter_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::FrameWidget_DragTargetDragEnter_ResponseParams_Data* params =
      reinterpret_cast<
          internal::FrameWidget_DragTargetDragEnter_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  ::ui::mojom::DragOperation p_operation{};
  FrameWidget_DragTargetDragEnter_ResponseParamsDataView input_data_view(params, message);
  
  if (success && !input_data_view.ReadOperation(&p_operation))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        FrameWidget::Name_, 0, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_operation));
  return true;
}

void FrameWidget_DragTargetDragEnter_ProxyToResponder::Run(
    ::ui::mojom::DragOperation in_operation) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send reply blink::mojom::FrameWidget::DragTargetDragEnter", "async_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("operation"), in_operation,
                        "<value of type ::ui::mojom::DragOperation>");
   });
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kFrameWidget_DragTargetDragEnter_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::FrameWidget_DragTargetDragEnter_ResponseParams_Data> params(
          message);
  params.Allocate();
  mojo::internal::Serialize<::ui::mojom::DragOperation>(
      in_operation, &params->operation);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(FrameWidget::Name_);
  message.set_method_name("DragTargetDragEnter");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class FrameWidget_DragTargetDragOver_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static FrameWidget::DragTargetDragOverCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<FrameWidget_DragTargetDragOver_ProxyToResponder> proxy(
        new FrameWidget_DragTargetDragOver_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&FrameWidget_DragTargetDragOver_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~FrameWidget_DragTargetDragOver_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  FrameWidget_DragTargetDragOver_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "FrameWidget::DragTargetDragOverCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      ::ui::mojom::DragOperation in_operation);
};

bool FrameWidget_DragTargetDragOver_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::FrameWidget_DragTargetDragOver_ResponseParams_Data* params =
      reinterpret_cast<
          internal::FrameWidget_DragTargetDragOver_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  ::ui::mojom::DragOperation p_operation{};
  FrameWidget_DragTargetDragOver_ResponseParamsDataView input_data_view(params, message);
  
  if (success && !input_data_view.ReadOperation(&p_operation))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        FrameWidget::Name_, 1, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_operation));
  return true;
}

void FrameWidget_DragTargetDragOver_ProxyToResponder::Run(
    ::ui::mojom::DragOperation in_operation) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send reply blink::mojom::FrameWidget::DragTargetDragOver", "async_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("operation"), in_operation,
                        "<value of type ::ui::mojom::DragOperation>");
   });
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kFrameWidget_DragTargetDragOver_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::FrameWidget_DragTargetDragOver_ResponseParams_Data> params(
          message);
  params.Allocate();
  mojo::internal::Serialize<::ui::mojom::DragOperation>(
      in_operation, &params->operation);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(FrameWidget::Name_);
  message.set_method_name("DragTargetDragOver");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class FrameWidget_DragTargetDrop_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static FrameWidget::DragTargetDropCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<FrameWidget_DragTargetDrop_ProxyToResponder> proxy(
        new FrameWidget_DragTargetDrop_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&FrameWidget_DragTargetDrop_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~FrameWidget_DragTargetDrop_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  FrameWidget_DragTargetDrop_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "FrameWidget::DragTargetDropCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      );
};

bool FrameWidget_DragTargetDrop_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::FrameWidget_DragTargetDrop_ResponseParams_Data* params =
      reinterpret_cast<
          internal::FrameWidget_DragTargetDrop_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  FrameWidget_DragTargetDrop_ResponseParamsDataView input_data_view(params, message);
  
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        FrameWidget::Name_, 3, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run();
  return true;
}

void FrameWidget_DragTargetDrop_ProxyToResponder::Run(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send reply blink::mojom::FrameWidget::DragTargetDrop");
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kFrameWidget_DragTargetDrop_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::FrameWidget_DragTargetDrop_ResponseParams_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(FrameWidget::Name_);
  message.set_method_name("DragTargetDrop");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class FrameWidget_DragSourceEndedAt_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static FrameWidget::DragSourceEndedAtCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<FrameWidget_DragSourceEndedAt_ProxyToResponder> proxy(
        new FrameWidget_DragSourceEndedAt_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&FrameWidget_DragSourceEndedAt_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~FrameWidget_DragSourceEndedAt_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  FrameWidget_DragSourceEndedAt_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "FrameWidget::DragSourceEndedAtCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      );
};

bool FrameWidget_DragSourceEndedAt_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::FrameWidget_DragSourceEndedAt_ResponseParams_Data* params =
      reinterpret_cast<
          internal::FrameWidget_DragSourceEndedAt_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  FrameWidget_DragSourceEndedAt_ResponseParamsDataView input_data_view(params, message);
  
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        FrameWidget::Name_, 4, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run();
  return true;
}

void FrameWidget_DragSourceEndedAt_ProxyToResponder::Run(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send reply blink::mojom::FrameWidget::DragSourceEndedAt");
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kFrameWidget_DragSourceEndedAt_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::FrameWidget_DragSourceEndedAt_ResponseParams_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(FrameWidget::Name_);
  message.set_method_name("DragSourceEndedAt");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class FrameWidget_OnStartStylusWriting_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static FrameWidget::OnStartStylusWritingCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<FrameWidget_OnStartStylusWriting_ProxyToResponder> proxy(
        new FrameWidget_OnStartStylusWriting_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&FrameWidget_OnStartStylusWriting_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~FrameWidget_OnStartStylusWriting_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  FrameWidget_OnStartStylusWriting_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "FrameWidget::OnStartStylusWritingCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      const absl::optional<::gfx::Rect>& in_focused_edit_bounds, const absl::optional<::gfx::Rect>& in_caret_bounds);
};

bool FrameWidget_OnStartStylusWriting_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::FrameWidget_OnStartStylusWriting_ResponseParams_Data* params =
      reinterpret_cast<
          internal::FrameWidget_OnStartStylusWriting_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  absl::optional<::gfx::Rect> p_focused_edit_bounds{};
  absl::optional<::gfx::Rect> p_caret_bounds{};
  FrameWidget_OnStartStylusWriting_ResponseParamsDataView input_data_view(params, message);
  
  if (success && !input_data_view.ReadFocusedEditBounds(&p_focused_edit_bounds))
    success = false;
  if (success && !input_data_view.ReadCaretBounds(&p_caret_bounds))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        FrameWidget::Name_, 6, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_focused_edit_bounds), 
std::move(p_caret_bounds));
  return true;
}

void FrameWidget_OnStartStylusWriting_ProxyToResponder::Run(
    const absl::optional<::gfx::Rect>& in_focused_edit_bounds, const absl::optional<::gfx::Rect>& in_caret_bounds) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send reply blink::mojom::FrameWidget::OnStartStylusWriting", "async_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("focused_edit_bounds"), in_focused_edit_bounds,
                        "<value of type const absl::optional<::gfx::Rect>&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("caret_bounds"), in_caret_bounds,
                        "<value of type const absl::optional<::gfx::Rect>&>");
   });
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kFrameWidget_OnStartStylusWriting_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::FrameWidget_OnStartStylusWriting_ResponseParams_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->focused_edit_bounds)::BaseType> focused_edit_bounds_fragment(
          params.message());
  mojo::internal::Serialize<::gfx::mojom::RectDataView>(
      in_focused_edit_bounds, focused_edit_bounds_fragment);
  params->focused_edit_bounds.Set(
      focused_edit_bounds_fragment.is_null() ? nullptr : focused_edit_bounds_fragment.data());
  mojo::internal::MessageFragment<
      typename decltype(params->caret_bounds)::BaseType> caret_bounds_fragment(
          params.message());
  mojo::internal::Serialize<::gfx::mojom::RectDataView>(
      in_caret_bounds, caret_bounds_fragment);
  params->caret_bounds.Set(
      caret_bounds_fragment.is_null() ? nullptr : caret_bounds_fragment.data());

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(FrameWidget::Name_);
  message.set_method_name("OnStartStylusWriting");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}

// static
bool FrameWidgetStubDispatch::Accept(
    FrameWidget* impl,
    mojo::Message* message) {
  switch (message->header()->name) {
    case internal::kFrameWidget_DragTargetDragEnter_Name: {
      break;
    }
    case internal::kFrameWidget_DragTargetDragOver_Name: {
      break;
    }
    case internal::kFrameWidget_DragTargetDragLeave_Name: {

      DCHECK(message->is_serialized());
      internal::FrameWidget_DragTargetDragLeave_Params_Data* params =
          reinterpret_cast<internal::FrameWidget_DragTargetDragLeave_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::gfx::PointF p_point_in_viewport{};
      ::gfx::PointF p_screen_point{};
      FrameWidget_DragTargetDragLeave_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadPointInViewport(&p_point_in_viewport))
        success = false;
      if (success && !input_data_view.ReadScreenPoint(&p_screen_point))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            FrameWidget::Name_, 2, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->DragTargetDragLeave(
std::move(p_point_in_viewport), 
std::move(p_screen_point));
      return true;
    }
    case internal::kFrameWidget_DragTargetDrop_Name: {
      break;
    }
    case internal::kFrameWidget_DragSourceEndedAt_Name: {
      break;
    }
    case internal::kFrameWidget_DragSourceSystemDragEnded_Name: {

      DCHECK(message->is_serialized());
      internal::FrameWidget_DragSourceSystemDragEnded_Params_Data* params =
          reinterpret_cast<internal::FrameWidget_DragSourceSystemDragEnded_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      FrameWidget_DragSourceSystemDragEnded_ParamsDataView input_data_view(params, message);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            FrameWidget::Name_, 5, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->DragSourceSystemDragEnded();
      return true;
    }
    case internal::kFrameWidget_OnStartStylusWriting_Name: {
      break;
    }
    case internal::kFrameWidget_SetBackgroundOpaque_Name: {

      DCHECK(message->is_serialized());
      internal::FrameWidget_SetBackgroundOpaque_Params_Data* params =
          reinterpret_cast<internal::FrameWidget_SetBackgroundOpaque_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      bool p_opaque{};
      FrameWidget_SetBackgroundOpaque_ParamsDataView input_data_view(params, message);
      
      if (success)
        p_opaque = input_data_view.opaque();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            FrameWidget::Name_, 7, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SetBackgroundOpaque(
std::move(p_opaque));
      return true;
    }
    case internal::kFrameWidget_SetTextDirection_Name: {

      DCHECK(message->is_serialized());
      internal::FrameWidget_SetTextDirection_Params_Data* params =
          reinterpret_cast<internal::FrameWidget_SetTextDirection_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::base::i18n::TextDirection p_direction{};
      FrameWidget_SetTextDirection_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadDirection(&p_direction))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            FrameWidget::Name_, 8, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SetTextDirection(
std::move(p_direction));
      return true;
    }
    case internal::kFrameWidget_SetActive_Name: {

      DCHECK(message->is_serialized());
      internal::FrameWidget_SetActive_Params_Data* params =
          reinterpret_cast<internal::FrameWidget_SetActive_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      bool p_active{};
      FrameWidget_SetActive_ParamsDataView input_data_view(params, message);
      
      if (success)
        p_active = input_data_view.active();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            FrameWidget::Name_, 9, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SetActive(
std::move(p_active));
      return true;
    }
    case internal::kFrameWidget_SetInheritedEffectiveTouchActionForSubFrame_Name: {

      DCHECK(message->is_serialized());
      internal::FrameWidget_SetInheritedEffectiveTouchActionForSubFrame_Params_Data* params =
          reinterpret_cast<internal::FrameWidget_SetInheritedEffectiveTouchActionForSubFrame_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::cc::TouchAction p_touch_action{};
      FrameWidget_SetInheritedEffectiveTouchActionForSubFrame_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadTouchAction(&p_touch_action))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            FrameWidget::Name_, 10, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SetInheritedEffectiveTouchActionForSubFrame(
std::move(p_touch_action));
      return true;
    }
    case internal::kFrameWidget_UpdateRenderThrottlingStatusForSubFrame_Name: {

      DCHECK(message->is_serialized());
      internal::FrameWidget_UpdateRenderThrottlingStatusForSubFrame_Params_Data* params =
          reinterpret_cast<internal::FrameWidget_UpdateRenderThrottlingStatusForSubFrame_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      bool p_is_throttled{};
      bool p_subtree_throttled{};
      bool p_display_locked{};
      FrameWidget_UpdateRenderThrottlingStatusForSubFrame_ParamsDataView input_data_view(params, message);
      
      if (success)
        p_is_throttled = input_data_view.is_throttled();
      if (success)
        p_subtree_throttled = input_data_view.subtree_throttled();
      if (success)
        p_display_locked = input_data_view.display_locked();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            FrameWidget::Name_, 11, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->UpdateRenderThrottlingStatusForSubFrame(
std::move(p_is_throttled), 
std::move(p_subtree_throttled), 
std::move(p_display_locked));
      return true;
    }
    case internal::kFrameWidget_SetIsInertForSubFrame_Name: {

      DCHECK(message->is_serialized());
      internal::FrameWidget_SetIsInertForSubFrame_Params_Data* params =
          reinterpret_cast<internal::FrameWidget_SetIsInertForSubFrame_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      bool p_inert{};
      FrameWidget_SetIsInertForSubFrame_ParamsDataView input_data_view(params, message);
      
      if (success)
        p_inert = input_data_view.inert();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            FrameWidget::Name_, 12, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SetIsInertForSubFrame(
std::move(p_inert));
      return true;
    }
    case internal::kFrameWidget_ShowContextMenu_Name: {

      DCHECK(message->is_serialized());
      internal::FrameWidget_ShowContextMenu_Params_Data* params =
          reinterpret_cast<internal::FrameWidget_ShowContextMenu_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::ui::MenuSourceType p_source_type{};
      ::gfx::Point p_location{};
      FrameWidget_ShowContextMenu_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadSourceType(&p_source_type))
        success = false;
      if (success && !input_data_view.ReadLocation(&p_location))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            FrameWidget::Name_, 13, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->ShowContextMenu(
std::move(p_source_type), 
std::move(p_location));
      return true;
    }
    case internal::kFrameWidget_EnableDeviceEmulation_Name: {

      DCHECK(message->is_serialized());
      internal::FrameWidget_EnableDeviceEmulation_Params_Data* params =
          reinterpret_cast<internal::FrameWidget_EnableDeviceEmulation_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::blink::DeviceEmulationParams p_parameters{};
      FrameWidget_EnableDeviceEmulation_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadParameters(&p_parameters))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            FrameWidget::Name_, 14, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->EnableDeviceEmulation(
std::move(p_parameters));
      return true;
    }
    case internal::kFrameWidget_DisableDeviceEmulation_Name: {

      DCHECK(message->is_serialized());
      internal::FrameWidget_DisableDeviceEmulation_Params_Data* params =
          reinterpret_cast<internal::FrameWidget_DisableDeviceEmulation_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      FrameWidget_DisableDeviceEmulation_ParamsDataView input_data_view(params, message);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            FrameWidget::Name_, 15, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->DisableDeviceEmulation();
      return true;
    }
    case internal::kFrameWidget_BindWidgetCompositor_Name: {

      DCHECK(message->is_serialized());
      internal::FrameWidget_BindWidgetCompositor_Params_Data* params =
          reinterpret_cast<internal::FrameWidget_BindWidgetCompositor_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::mojo::PendingReceiver<::blink::mojom::WidgetCompositor> p_host{};
      FrameWidget_BindWidgetCompositor_ParamsDataView input_data_view(params, message);
      
      if (success) {
        p_host =
            input_data_view.TakeHost<decltype(p_host)>();
      }
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            FrameWidget::Name_, 16, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->BindWidgetCompositor(
std::move(p_host));
      return true;
    }
    case internal::kFrameWidget_BindInputTargetClient_Name: {

      DCHECK(message->is_serialized());
      internal::FrameWidget_BindInputTargetClient_Params_Data* params =
          reinterpret_cast<internal::FrameWidget_BindInputTargetClient_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::mojo::PendingReceiver<::viz::mojom::InputTargetClient> p_host{};
      FrameWidget_BindInputTargetClient_ParamsDataView input_data_view(params, message);
      
      if (success) {
        p_host =
            input_data_view.TakeHost<decltype(p_host)>();
      }
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            FrameWidget::Name_, 17, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->BindInputTargetClient(
std::move(p_host));
      return true;
    }
    case internal::kFrameWidget_SetViewportIntersection_Name: {

      DCHECK(message->is_serialized());
      internal::FrameWidget_SetViewportIntersection_Params_Data* params =
          reinterpret_cast<internal::FrameWidget_SetViewportIntersection_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::blink::mojom::ViewportIntersectionStatePtr p_intersection_state{};
      absl::optional<::blink::VisualProperties> p_visual_properties{};
      FrameWidget_SetViewportIntersection_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadIntersectionState(&p_intersection_state))
        success = false;
      if (success && !input_data_view.ReadVisualProperties(&p_visual_properties))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            FrameWidget::Name_, 18, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SetViewportIntersection(
std::move(p_intersection_state), 
std::move(p_visual_properties));
      return true;
    }
  }
  return false;
}

// static
bool FrameWidgetStubDispatch::AcceptWithResponder(
    FrameWidget* impl,
    mojo::Message* message,
    std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
  [[maybe_unused]] const bool message_is_sync =
      message->has_flag(mojo::Message::kFlagIsSync);
  [[maybe_unused]] const uint64_t request_id = message->request_id();
  switch (message->header()->name) {
    case internal::kFrameWidget_DragTargetDragEnter_Name: {

      internal::FrameWidget_DragTargetDragEnter_Params_Data* params =
          reinterpret_cast<
              internal::FrameWidget_DragTargetDragEnter_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      ::blink::mojom::DragDataPtr p_drag_data{};
      ::gfx::PointF p_point_in_viewport{};
      ::gfx::PointF p_screen_point{};
      ::blink::DragOperationsMask p_operations_allowed{};
      uint32_t p_key_modifiers{};
      FrameWidget_DragTargetDragEnter_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadDragData(&p_drag_data))
        success = false;
      if (success && !input_data_view.ReadPointInViewport(&p_point_in_viewport))
        success = false;
      if (success && !input_data_view.ReadScreenPoint(&p_screen_point))
        success = false;
      if (success && !input_data_view.ReadOperationsAllowed(&p_operations_allowed))
        success = false;
      if (success)
        p_key_modifiers = input_data_view.key_modifiers();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            FrameWidget::Name_, 0, false);
        return false;
      }
      FrameWidget::DragTargetDragEnterCallback callback =
          FrameWidget_DragTargetDragEnter_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->DragTargetDragEnter(
std::move(p_drag_data), 
std::move(p_point_in_viewport), 
std::move(p_screen_point), 
std::move(p_operations_allowed), 
std::move(p_key_modifiers), std::move(callback));
      return true;
    }
    case internal::kFrameWidget_DragTargetDragOver_Name: {

      internal::FrameWidget_DragTargetDragOver_Params_Data* params =
          reinterpret_cast<
              internal::FrameWidget_DragTargetDragOver_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      ::gfx::PointF p_point_in_viewport{};
      ::gfx::PointF p_screen_point{};
      ::blink::DragOperationsMask p_operations_allowed{};
      uint32_t p_key_modifiers{};
      FrameWidget_DragTargetDragOver_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadPointInViewport(&p_point_in_viewport))
        success = false;
      if (success && !input_data_view.ReadScreenPoint(&p_screen_point))
        success = false;
      if (success && !input_data_view.ReadOperationsAllowed(&p_operations_allowed))
        success = false;
      if (success)
        p_key_modifiers = input_data_view.key_modifiers();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            FrameWidget::Name_, 1, false);
        return false;
      }
      FrameWidget::DragTargetDragOverCallback callback =
          FrameWidget_DragTargetDragOver_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->DragTargetDragOver(
std::move(p_point_in_viewport), 
std::move(p_screen_point), 
std::move(p_operations_allowed), 
std::move(p_key_modifiers), std::move(callback));
      return true;
    }
    case internal::kFrameWidget_DragTargetDragLeave_Name: {
      break;
    }
    case internal::kFrameWidget_DragTargetDrop_Name: {

      internal::FrameWidget_DragTargetDrop_Params_Data* params =
          reinterpret_cast<
              internal::FrameWidget_DragTargetDrop_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      ::blink::mojom::DragDataPtr p_drag_data{};
      ::gfx::PointF p_point_in_viewport{};
      ::gfx::PointF p_screen_point{};
      uint32_t p_key_modifiers{};
      FrameWidget_DragTargetDrop_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadDragData(&p_drag_data))
        success = false;
      if (success && !input_data_view.ReadPointInViewport(&p_point_in_viewport))
        success = false;
      if (success && !input_data_view.ReadScreenPoint(&p_screen_point))
        success = false;
      if (success)
        p_key_modifiers = input_data_view.key_modifiers();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            FrameWidget::Name_, 3, false);
        return false;
      }
      FrameWidget::DragTargetDropCallback callback =
          FrameWidget_DragTargetDrop_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->DragTargetDrop(
std::move(p_drag_data), 
std::move(p_point_in_viewport), 
std::move(p_screen_point), 
std::move(p_key_modifiers), std::move(callback));
      return true;
    }
    case internal::kFrameWidget_DragSourceEndedAt_Name: {

      internal::FrameWidget_DragSourceEndedAt_Params_Data* params =
          reinterpret_cast<
              internal::FrameWidget_DragSourceEndedAt_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      ::gfx::PointF p_point_in_viewport{};
      ::gfx::PointF p_screen_point{};
      ::ui::mojom::DragOperation p_drag_operation{};
      FrameWidget_DragSourceEndedAt_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadPointInViewport(&p_point_in_viewport))
        success = false;
      if (success && !input_data_view.ReadScreenPoint(&p_screen_point))
        success = false;
      if (success && !input_data_view.ReadDragOperation(&p_drag_operation))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            FrameWidget::Name_, 4, false);
        return false;
      }
      FrameWidget::DragSourceEndedAtCallback callback =
          FrameWidget_DragSourceEndedAt_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->DragSourceEndedAt(
std::move(p_point_in_viewport), 
std::move(p_screen_point), 
std::move(p_drag_operation), std::move(callback));
      return true;
    }
    case internal::kFrameWidget_DragSourceSystemDragEnded_Name: {
      break;
    }
    case internal::kFrameWidget_OnStartStylusWriting_Name: {

      internal::FrameWidget_OnStartStylusWriting_Params_Data* params =
          reinterpret_cast<
              internal::FrameWidget_OnStartStylusWriting_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      FrameWidget_OnStartStylusWriting_ParamsDataView input_data_view(params, message);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            FrameWidget::Name_, 6, false);
        return false;
      }
      FrameWidget::OnStartStylusWritingCallback callback =
          FrameWidget_OnStartStylusWriting_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->OnStartStylusWriting(std::move(callback));
      return true;
    }
    case internal::kFrameWidget_SetBackgroundOpaque_Name: {
      break;
    }
    case internal::kFrameWidget_SetTextDirection_Name: {
      break;
    }
    case internal::kFrameWidget_SetActive_Name: {
      break;
    }
    case internal::kFrameWidget_SetInheritedEffectiveTouchActionForSubFrame_Name: {
      break;
    }
    case internal::kFrameWidget_UpdateRenderThrottlingStatusForSubFrame_Name: {
      break;
    }
    case internal::kFrameWidget_SetIsInertForSubFrame_Name: {
      break;
    }
    case internal::kFrameWidget_ShowContextMenu_Name: {
      break;
    }
    case internal::kFrameWidget_EnableDeviceEmulation_Name: {
      break;
    }
    case internal::kFrameWidget_DisableDeviceEmulation_Name: {
      break;
    }
    case internal::kFrameWidget_BindWidgetCompositor_Name: {
      break;
    }
    case internal::kFrameWidget_BindInputTargetClient_Name: {
      break;
    }
    case internal::kFrameWidget_SetViewportIntersection_Name: {
      break;
    }
  }
  return false;
}


static const mojo::internal::GenericValidationInfo kFrameWidgetValidationInfo[] = {
    {&internal::FrameWidget_DragTargetDragEnter_Params_Data::Validate,
     &internal::FrameWidget_DragTargetDragEnter_ResponseParams_Data::Validate},
    {&internal::FrameWidget_DragTargetDragOver_Params_Data::Validate,
     &internal::FrameWidget_DragTargetDragOver_ResponseParams_Data::Validate},
    {&internal::FrameWidget_DragTargetDragLeave_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::FrameWidget_DragTargetDrop_Params_Data::Validate,
     &internal::FrameWidget_DragTargetDrop_ResponseParams_Data::Validate},
    {&internal::FrameWidget_DragSourceEndedAt_Params_Data::Validate,
     &internal::FrameWidget_DragSourceEndedAt_ResponseParams_Data::Validate},
    {&internal::FrameWidget_DragSourceSystemDragEnded_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::FrameWidget_OnStartStylusWriting_Params_Data::Validate,
     &internal::FrameWidget_OnStartStylusWriting_ResponseParams_Data::Validate},
    {&internal::FrameWidget_SetBackgroundOpaque_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::FrameWidget_SetTextDirection_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::FrameWidget_SetActive_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::FrameWidget_SetInheritedEffectiveTouchActionForSubFrame_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::FrameWidget_UpdateRenderThrottlingStatusForSubFrame_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::FrameWidget_SetIsInertForSubFrame_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::FrameWidget_ShowContextMenu_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::FrameWidget_EnableDeviceEmulation_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::FrameWidget_DisableDeviceEmulation_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::FrameWidget_BindWidgetCompositor_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::FrameWidget_BindInputTargetClient_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::FrameWidget_SetViewportIntersection_Params_Data::Validate,
     nullptr /* no response */},
};

bool FrameWidgetRequestValidator::Accept(mojo::Message* message) {
  const char* name = ::blink::mojom::FrameWidget::Name_;
  return mojo::internal::ValidateRequestGenericPacked(message, name, kFrameWidgetValidationInfo);
}

bool FrameWidgetResponseValidator::Accept(mojo::Message* message) {
  const char* name = ::blink::mojom::FrameWidget::Name_;
  return mojo::internal::ValidateResponseGenericPacked(message, name, kFrameWidgetValidationInfo);
}
const char FrameWidgetHost::Name_[] = "blink.mojom.FrameWidgetHost";

FrameWidgetHost::IPCStableHashFunction FrameWidgetHost::MessageToMethodInfo_(mojo::Message& message) {
#if !BUILDFLAG(IS_FUCHSIA)
  switch (message.name()) {
    case internal::kFrameWidgetHost_AnimateDoubleTapZoomInMainFrame_Name: {
      return &FrameWidgetHost::AnimateDoubleTapZoomInMainFrame_Sym::IPCStableHash;
    }
    case internal::kFrameWidgetHost_ZoomToFindInPageRectInMainFrame_Name: {
      return &FrameWidgetHost::ZoomToFindInPageRectInMainFrame_Sym::IPCStableHash;
    }
    case internal::kFrameWidgetHost_SetHasTouchEventConsumers_Name: {
      return &FrameWidgetHost::SetHasTouchEventConsumers_Sym::IPCStableHash;
    }
    case internal::kFrameWidgetHost_IntrinsicSizingInfoChanged_Name: {
      return &FrameWidgetHost::IntrinsicSizingInfoChanged_Sym::IPCStableHash;
    }
    case internal::kFrameWidgetHost_AutoscrollStart_Name: {
      return &FrameWidgetHost::AutoscrollStart_Sym::IPCStableHash;
    }
    case internal::kFrameWidgetHost_AutoscrollFling_Name: {
      return &FrameWidgetHost::AutoscrollFling_Sym::IPCStableHash;
    }
    case internal::kFrameWidgetHost_AutoscrollEnd_Name: {
      return &FrameWidgetHost::AutoscrollEnd_Sym::IPCStableHash;
    }
    case internal::kFrameWidgetHost_StartDragging_Name: {
      return &FrameWidgetHost::StartDragging_Sym::IPCStableHash;
    }
  }
#endif  // !BUILDFLAG(IS_FUCHSIA)
  return nullptr;
}


const char* FrameWidgetHost::MessageToMethodName_(mojo::Message& message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  bool is_response = message.has_flag(mojo::Message::kFlagIsResponse);
  if (!is_response) {
    switch (message.name()) {
      case internal::kFrameWidgetHost_AnimateDoubleTapZoomInMainFrame_Name:
            return "Receive blink::mojom::FrameWidgetHost::AnimateDoubleTapZoomInMainFrame";
      case internal::kFrameWidgetHost_ZoomToFindInPageRectInMainFrame_Name:
            return "Receive blink::mojom::FrameWidgetHost::ZoomToFindInPageRectInMainFrame";
      case internal::kFrameWidgetHost_SetHasTouchEventConsumers_Name:
            return "Receive blink::mojom::FrameWidgetHost::SetHasTouchEventConsumers";
      case internal::kFrameWidgetHost_IntrinsicSizingInfoChanged_Name:
            return "Receive blink::mojom::FrameWidgetHost::IntrinsicSizingInfoChanged";
      case internal::kFrameWidgetHost_AutoscrollStart_Name:
            return "Receive blink::mojom::FrameWidgetHost::AutoscrollStart";
      case internal::kFrameWidgetHost_AutoscrollFling_Name:
            return "Receive blink::mojom::FrameWidgetHost::AutoscrollFling";
      case internal::kFrameWidgetHost_AutoscrollEnd_Name:
            return "Receive blink::mojom::FrameWidgetHost::AutoscrollEnd";
      case internal::kFrameWidgetHost_StartDragging_Name:
            return "Receive blink::mojom::FrameWidgetHost::StartDragging";
    }
  } else {
    switch (message.name()) {
      case internal::kFrameWidgetHost_AnimateDoubleTapZoomInMainFrame_Name:
            return "Receive reply blink::mojom::FrameWidgetHost::AnimateDoubleTapZoomInMainFrame";
      case internal::kFrameWidgetHost_ZoomToFindInPageRectInMainFrame_Name:
            return "Receive reply blink::mojom::FrameWidgetHost::ZoomToFindInPageRectInMainFrame";
      case internal::kFrameWidgetHost_SetHasTouchEventConsumers_Name:
            return "Receive reply blink::mojom::FrameWidgetHost::SetHasTouchEventConsumers";
      case internal::kFrameWidgetHost_IntrinsicSizingInfoChanged_Name:
            return "Receive reply blink::mojom::FrameWidgetHost::IntrinsicSizingInfoChanged";
      case internal::kFrameWidgetHost_AutoscrollStart_Name:
            return "Receive reply blink::mojom::FrameWidgetHost::AutoscrollStart";
      case internal::kFrameWidgetHost_AutoscrollFling_Name:
            return "Receive reply blink::mojom::FrameWidgetHost::AutoscrollFling";
      case internal::kFrameWidgetHost_AutoscrollEnd_Name:
            return "Receive reply blink::mojom::FrameWidgetHost::AutoscrollEnd";
      case internal::kFrameWidgetHost_StartDragging_Name:
            return "Receive reply blink::mojom::FrameWidgetHost::StartDragging";
    }
  }
  return "Receive unknown mojo message";
#else
  bool is_response = message.has_flag(mojo::Message::kFlagIsResponse);
  if (is_response) {
    return "Receive mojo reply";
  } else {
    return "Receive mojo message";
  }
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
}

#if !BUILDFLAG(IS_FUCHSIA)
uint32_t FrameWidgetHost::AnimateDoubleTapZoomInMainFrame_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::FrameWidgetHost::AnimateDoubleTapZoomInMainFrame");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t FrameWidgetHost::ZoomToFindInPageRectInMainFrame_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::FrameWidgetHost::ZoomToFindInPageRectInMainFrame");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t FrameWidgetHost::SetHasTouchEventConsumers_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::FrameWidgetHost::SetHasTouchEventConsumers");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t FrameWidgetHost::IntrinsicSizingInfoChanged_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::FrameWidgetHost::IntrinsicSizingInfoChanged");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t FrameWidgetHost::AutoscrollStart_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::FrameWidgetHost::AutoscrollStart");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t FrameWidgetHost::AutoscrollFling_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::FrameWidgetHost::AutoscrollFling");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t FrameWidgetHost::AutoscrollEnd_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::FrameWidgetHost::AutoscrollEnd");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t FrameWidgetHost::StartDragging_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::FrameWidgetHost::StartDragging");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
# endif // !BUILDFLAG(IS_FUCHSIA)

FrameWidgetHostProxy::FrameWidgetHostProxy(mojo::MessageReceiverWithResponder* receiver)
    : receiver_(receiver) {
}

void FrameWidgetHostProxy::AnimateDoubleTapZoomInMainFrame(
    const ::gfx::Point& in_tap_point, const ::gfx::Rect& in_rect_to_zoom) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::FrameWidgetHost::AnimateDoubleTapZoomInMainFrame", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("tap_point"), in_tap_point,
                        "<value of type const ::gfx::Point&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("rect_to_zoom"), in_rect_to_zoom,
                        "<value of type const ::gfx::Rect&>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kFrameWidgetHost_AnimateDoubleTapZoomInMainFrame_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::FrameWidgetHost_AnimateDoubleTapZoomInMainFrame_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->tap_point)::BaseType> tap_point_fragment(
          params.message());
  mojo::internal::Serialize<::gfx::mojom::PointDataView>(
      in_tap_point, tap_point_fragment);
  params->tap_point.Set(
      tap_point_fragment.is_null() ? nullptr : tap_point_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->tap_point.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null tap_point in FrameWidgetHost.AnimateDoubleTapZoomInMainFrame request");
  mojo::internal::MessageFragment<
      typename decltype(params->rect_to_zoom)::BaseType> rect_to_zoom_fragment(
          params.message());
  mojo::internal::Serialize<::gfx::mojom::RectDataView>(
      in_rect_to_zoom, rect_to_zoom_fragment);
  params->rect_to_zoom.Set(
      rect_to_zoom_fragment.is_null() ? nullptr : rect_to_zoom_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->rect_to_zoom.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null rect_to_zoom in FrameWidgetHost.AnimateDoubleTapZoomInMainFrame request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(FrameWidgetHost::Name_);
  message.set_method_name("AnimateDoubleTapZoomInMainFrame");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void FrameWidgetHostProxy::ZoomToFindInPageRectInMainFrame(
    const ::gfx::Rect& in_rect_to_zoom) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::FrameWidgetHost::ZoomToFindInPageRectInMainFrame", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("rect_to_zoom"), in_rect_to_zoom,
                        "<value of type const ::gfx::Rect&>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kFrameWidgetHost_ZoomToFindInPageRectInMainFrame_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::FrameWidgetHost_ZoomToFindInPageRectInMainFrame_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->rect_to_zoom)::BaseType> rect_to_zoom_fragment(
          params.message());
  mojo::internal::Serialize<::gfx::mojom::RectDataView>(
      in_rect_to_zoom, rect_to_zoom_fragment);
  params->rect_to_zoom.Set(
      rect_to_zoom_fragment.is_null() ? nullptr : rect_to_zoom_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->rect_to_zoom.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null rect_to_zoom in FrameWidgetHost.ZoomToFindInPageRectInMainFrame request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(FrameWidgetHost::Name_);
  message.set_method_name("ZoomToFindInPageRectInMainFrame");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void FrameWidgetHostProxy::SetHasTouchEventConsumers(
    ::blink::mojom::TouchEventConsumersPtr in_touch_event_consumers) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::FrameWidgetHost::SetHasTouchEventConsumers", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("touch_event_consumers"), in_touch_event_consumers,
                        "<value of type ::blink::mojom::TouchEventConsumersPtr>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kFrameWidgetHost_SetHasTouchEventConsumers_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::FrameWidgetHost_SetHasTouchEventConsumers_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->touch_event_consumers)::BaseType> touch_event_consumers_fragment(
          params.message());
  mojo::internal::Serialize<::blink::mojom::TouchEventConsumersDataView>(
      in_touch_event_consumers, touch_event_consumers_fragment);
  params->touch_event_consumers.Set(
      touch_event_consumers_fragment.is_null() ? nullptr : touch_event_consumers_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->touch_event_consumers.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null touch_event_consumers in FrameWidgetHost.SetHasTouchEventConsumers request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(FrameWidgetHost::Name_);
  message.set_method_name("SetHasTouchEventConsumers");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void FrameWidgetHostProxy::IntrinsicSizingInfoChanged(
    ::blink::mojom::IntrinsicSizingInfoPtr in_sizing_info) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::FrameWidgetHost::IntrinsicSizingInfoChanged", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("sizing_info"), in_sizing_info,
                        "<value of type ::blink::mojom::IntrinsicSizingInfoPtr>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kFrameWidgetHost_IntrinsicSizingInfoChanged_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::FrameWidgetHost_IntrinsicSizingInfoChanged_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->sizing_info)::BaseType> sizing_info_fragment(
          params.message());
  mojo::internal::Serialize<::blink::mojom::IntrinsicSizingInfoDataView>(
      in_sizing_info, sizing_info_fragment);
  params->sizing_info.Set(
      sizing_info_fragment.is_null() ? nullptr : sizing_info_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->sizing_info.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null sizing_info in FrameWidgetHost.IntrinsicSizingInfoChanged request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(FrameWidgetHost::Name_);
  message.set_method_name("IntrinsicSizingInfoChanged");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void FrameWidgetHostProxy::AutoscrollStart(
    const ::gfx::PointF& in_position) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::FrameWidgetHost::AutoscrollStart", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("position"), in_position,
                        "<value of type const ::gfx::PointF&>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kFrameWidgetHost_AutoscrollStart_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::FrameWidgetHost_AutoscrollStart_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->position)::BaseType> position_fragment(
          params.message());
  mojo::internal::Serialize<::gfx::mojom::PointFDataView>(
      in_position, position_fragment);
  params->position.Set(
      position_fragment.is_null() ? nullptr : position_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->position.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null position in FrameWidgetHost.AutoscrollStart request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(FrameWidgetHost::Name_);
  message.set_method_name("AutoscrollStart");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void FrameWidgetHostProxy::AutoscrollFling(
    const ::gfx::Vector2dF& in_velocity) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::FrameWidgetHost::AutoscrollFling", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("velocity"), in_velocity,
                        "<value of type const ::gfx::Vector2dF&>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kFrameWidgetHost_AutoscrollFling_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::FrameWidgetHost_AutoscrollFling_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->velocity)::BaseType> velocity_fragment(
          params.message());
  mojo::internal::Serialize<::gfx::mojom::Vector2dFDataView>(
      in_velocity, velocity_fragment);
  params->velocity.Set(
      velocity_fragment.is_null() ? nullptr : velocity_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->velocity.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null velocity in FrameWidgetHost.AutoscrollFling request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(FrameWidgetHost::Name_);
  message.set_method_name("AutoscrollFling");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void FrameWidgetHostProxy::AutoscrollEnd(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send blink::mojom::FrameWidgetHost::AutoscrollEnd");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kFrameWidgetHost_AutoscrollEnd_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::FrameWidgetHost_AutoscrollEnd_Params_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(FrameWidgetHost::Name_);
  message.set_method_name("AutoscrollEnd");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void FrameWidgetHostProxy::StartDragging(
    ::blink::mojom::DragDataPtr in_drag_data, ::blink::DragOperationsMask in_operations_allowed, const ::SkBitmap& in_image, const ::gfx::Vector2d& in_bitmap_offset_in_dip, ::blink::mojom::DragEventSourceInfoPtr in_event_info) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::FrameWidgetHost::StartDragging", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("drag_data"), in_drag_data,
                        "<value of type ::blink::mojom::DragDataPtr>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("operations_allowed"), in_operations_allowed,
                        "<value of type ::blink::DragOperationsMask>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("image"), in_image,
                        "<value of type const ::SkBitmap&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("bitmap_offset_in_dip"), in_bitmap_offset_in_dip,
                        "<value of type const ::gfx::Vector2d&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("event_info"), in_event_info,
                        "<value of type ::blink::mojom::DragEventSourceInfoPtr>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kFrameWidgetHost_StartDragging_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::FrameWidgetHost_StartDragging_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->drag_data)::BaseType> drag_data_fragment(
          params.message());
  mojo::internal::Serialize<::blink::mojom::DragDataDataView>(
      in_drag_data, drag_data_fragment);
  params->drag_data.Set(
      drag_data_fragment.is_null() ? nullptr : drag_data_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->drag_data.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null drag_data in FrameWidgetHost.StartDragging request");
  mojo::internal::MessageFragment<
      typename decltype(params->operations_allowed)::BaseType> operations_allowed_fragment(
          params.message());
  mojo::internal::Serialize<::blink::mojom::AllowedDragOperationsDataView>(
      in_operations_allowed, operations_allowed_fragment);
  params->operations_allowed.Set(
      operations_allowed_fragment.is_null() ? nullptr : operations_allowed_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->operations_allowed.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null operations_allowed in FrameWidgetHost.StartDragging request");
  mojo::internal::MessageFragment<
      typename decltype(params->image)::BaseType> image_fragment(
          params.message());
  mojo::internal::Serialize<::skia::mojom::BitmapN32DataView>(
      in_image, image_fragment);
  params->image.Set(
      image_fragment.is_null() ? nullptr : image_fragment.data());
  mojo::internal::MessageFragment<
      typename decltype(params->bitmap_offset_in_dip)::BaseType> bitmap_offset_in_dip_fragment(
          params.message());
  mojo::internal::Serialize<::gfx::mojom::Vector2dDataView>(
      in_bitmap_offset_in_dip, bitmap_offset_in_dip_fragment);
  params->bitmap_offset_in_dip.Set(
      bitmap_offset_in_dip_fragment.is_null() ? nullptr : bitmap_offset_in_dip_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->bitmap_offset_in_dip.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null bitmap_offset_in_dip in FrameWidgetHost.StartDragging request");
  mojo::internal::MessageFragment<
      typename decltype(params->event_info)::BaseType> event_info_fragment(
          params.message());
  mojo::internal::Serialize<::blink::mojom::DragEventSourceInfoDataView>(
      in_event_info, event_info_fragment);
  params->event_info.Set(
      event_info_fragment.is_null() ? nullptr : event_info_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->event_info.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null event_info in FrameWidgetHost.StartDragging request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(FrameWidgetHost::Name_);
  message.set_method_name("StartDragging");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

// static
bool FrameWidgetHostStubDispatch::Accept(
    FrameWidgetHost* impl,
    mojo::Message* message) {
  switch (message->header()->name) {
    case internal::kFrameWidgetHost_AnimateDoubleTapZoomInMainFrame_Name: {

      DCHECK(message->is_serialized());
      internal::FrameWidgetHost_AnimateDoubleTapZoomInMainFrame_Params_Data* params =
          reinterpret_cast<internal::FrameWidgetHost_AnimateDoubleTapZoomInMainFrame_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::gfx::Point p_tap_point{};
      ::gfx::Rect p_rect_to_zoom{};
      FrameWidgetHost_AnimateDoubleTapZoomInMainFrame_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadTapPoint(&p_tap_point))
        success = false;
      if (success && !input_data_view.ReadRectToZoom(&p_rect_to_zoom))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            FrameWidgetHost::Name_, 0, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->AnimateDoubleTapZoomInMainFrame(
std::move(p_tap_point), 
std::move(p_rect_to_zoom));
      return true;
    }
    case internal::kFrameWidgetHost_ZoomToFindInPageRectInMainFrame_Name: {

      DCHECK(message->is_serialized());
      internal::FrameWidgetHost_ZoomToFindInPageRectInMainFrame_Params_Data* params =
          reinterpret_cast<internal::FrameWidgetHost_ZoomToFindInPageRectInMainFrame_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::gfx::Rect p_rect_to_zoom{};
      FrameWidgetHost_ZoomToFindInPageRectInMainFrame_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadRectToZoom(&p_rect_to_zoom))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            FrameWidgetHost::Name_, 1, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->ZoomToFindInPageRectInMainFrame(
std::move(p_rect_to_zoom));
      return true;
    }
    case internal::kFrameWidgetHost_SetHasTouchEventConsumers_Name: {

      DCHECK(message->is_serialized());
      internal::FrameWidgetHost_SetHasTouchEventConsumers_Params_Data* params =
          reinterpret_cast<internal::FrameWidgetHost_SetHasTouchEventConsumers_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::blink::mojom::TouchEventConsumersPtr p_touch_event_consumers{};
      FrameWidgetHost_SetHasTouchEventConsumers_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadTouchEventConsumers(&p_touch_event_consumers))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            FrameWidgetHost::Name_, 2, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SetHasTouchEventConsumers(
std::move(p_touch_event_consumers));
      return true;
    }
    case internal::kFrameWidgetHost_IntrinsicSizingInfoChanged_Name: {

      DCHECK(message->is_serialized());
      internal::FrameWidgetHost_IntrinsicSizingInfoChanged_Params_Data* params =
          reinterpret_cast<internal::FrameWidgetHost_IntrinsicSizingInfoChanged_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::blink::mojom::IntrinsicSizingInfoPtr p_sizing_info{};
      FrameWidgetHost_IntrinsicSizingInfoChanged_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadSizingInfo(&p_sizing_info))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            FrameWidgetHost::Name_, 3, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->IntrinsicSizingInfoChanged(
std::move(p_sizing_info));
      return true;
    }
    case internal::kFrameWidgetHost_AutoscrollStart_Name: {

      DCHECK(message->is_serialized());
      internal::FrameWidgetHost_AutoscrollStart_Params_Data* params =
          reinterpret_cast<internal::FrameWidgetHost_AutoscrollStart_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::gfx::PointF p_position{};
      FrameWidgetHost_AutoscrollStart_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadPosition(&p_position))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            FrameWidgetHost::Name_, 4, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->AutoscrollStart(
std::move(p_position));
      return true;
    }
    case internal::kFrameWidgetHost_AutoscrollFling_Name: {

      DCHECK(message->is_serialized());
      internal::FrameWidgetHost_AutoscrollFling_Params_Data* params =
          reinterpret_cast<internal::FrameWidgetHost_AutoscrollFling_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::gfx::Vector2dF p_velocity{};
      FrameWidgetHost_AutoscrollFling_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadVelocity(&p_velocity))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            FrameWidgetHost::Name_, 5, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->AutoscrollFling(
std::move(p_velocity));
      return true;
    }
    case internal::kFrameWidgetHost_AutoscrollEnd_Name: {

      DCHECK(message->is_serialized());
      internal::FrameWidgetHost_AutoscrollEnd_Params_Data* params =
          reinterpret_cast<internal::FrameWidgetHost_AutoscrollEnd_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      FrameWidgetHost_AutoscrollEnd_ParamsDataView input_data_view(params, message);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            FrameWidgetHost::Name_, 6, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->AutoscrollEnd();
      return true;
    }
    case internal::kFrameWidgetHost_StartDragging_Name: {

      DCHECK(message->is_serialized());
      internal::FrameWidgetHost_StartDragging_Params_Data* params =
          reinterpret_cast<internal::FrameWidgetHost_StartDragging_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::blink::mojom::DragDataPtr p_drag_data{};
      ::blink::DragOperationsMask p_operations_allowed{};
      ::SkBitmap p_image{};
      ::gfx::Vector2d p_bitmap_offset_in_dip{};
      ::blink::mojom::DragEventSourceInfoPtr p_event_info{};
      FrameWidgetHost_StartDragging_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadDragData(&p_drag_data))
        success = false;
      if (success && !input_data_view.ReadOperationsAllowed(&p_operations_allowed))
        success = false;
      if (success && !input_data_view.ReadImage(&p_image))
        success = false;
      if (success && !input_data_view.ReadBitmapOffsetInDip(&p_bitmap_offset_in_dip))
        success = false;
      if (success && !input_data_view.ReadEventInfo(&p_event_info))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            FrameWidgetHost::Name_, 7, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->StartDragging(
std::move(p_drag_data), 
std::move(p_operations_allowed), 
std::move(p_image), 
std::move(p_bitmap_offset_in_dip), 
std::move(p_event_info));
      return true;
    }
  }
  return false;
}

// static
bool FrameWidgetHostStubDispatch::AcceptWithResponder(
    FrameWidgetHost* impl,
    mojo::Message* message,
    std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
  [[maybe_unused]] const bool message_is_sync =
      message->has_flag(mojo::Message::kFlagIsSync);
  [[maybe_unused]] const uint64_t request_id = message->request_id();
  switch (message->header()->name) {
    case internal::kFrameWidgetHost_AnimateDoubleTapZoomInMainFrame_Name: {
      break;
    }
    case internal::kFrameWidgetHost_ZoomToFindInPageRectInMainFrame_Name: {
      break;
    }
    case internal::kFrameWidgetHost_SetHasTouchEventConsumers_Name: {
      break;
    }
    case internal::kFrameWidgetHost_IntrinsicSizingInfoChanged_Name: {
      break;
    }
    case internal::kFrameWidgetHost_AutoscrollStart_Name: {
      break;
    }
    case internal::kFrameWidgetHost_AutoscrollFling_Name: {
      break;
    }
    case internal::kFrameWidgetHost_AutoscrollEnd_Name: {
      break;
    }
    case internal::kFrameWidgetHost_StartDragging_Name: {
      break;
    }
  }
  return false;
}


static const mojo::internal::GenericValidationInfo kFrameWidgetHostValidationInfo[] = {
    {&internal::FrameWidgetHost_AnimateDoubleTapZoomInMainFrame_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::FrameWidgetHost_ZoomToFindInPageRectInMainFrame_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::FrameWidgetHost_SetHasTouchEventConsumers_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::FrameWidgetHost_IntrinsicSizingInfoChanged_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::FrameWidgetHost_AutoscrollStart_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::FrameWidgetHost_AutoscrollFling_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::FrameWidgetHost_AutoscrollEnd_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::FrameWidgetHost_StartDragging_Params_Data::Validate,
     nullptr /* no response */},
};

bool FrameWidgetHostRequestValidator::Accept(mojo::Message* message) {
  const char* name = ::blink::mojom::FrameWidgetHost::Name_;
  return mojo::internal::ValidateRequestGenericPacked(message, name, kFrameWidgetHostValidationInfo);
}

const char PopupWidgetHost::Name_[] = "blink.mojom.PopupWidgetHost";

PopupWidgetHost::IPCStableHashFunction PopupWidgetHost::MessageToMethodInfo_(mojo::Message& message) {
#if !BUILDFLAG(IS_FUCHSIA)
  switch (message.name()) {
    case internal::kPopupWidgetHost_RequestClosePopup_Name: {
      return &PopupWidgetHost::RequestClosePopup_Sym::IPCStableHash;
    }
    case internal::kPopupWidgetHost_ShowPopup_Name: {
      return &PopupWidgetHost::ShowPopup_Sym::IPCStableHash;
    }
    case internal::kPopupWidgetHost_SetPopupBounds_Name: {
      return &PopupWidgetHost::SetPopupBounds_Sym::IPCStableHash;
    }
  }
#endif  // !BUILDFLAG(IS_FUCHSIA)
  return nullptr;
}


const char* PopupWidgetHost::MessageToMethodName_(mojo::Message& message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  bool is_response = message.has_flag(mojo::Message::kFlagIsResponse);
  if (!is_response) {
    switch (message.name()) {
      case internal::kPopupWidgetHost_RequestClosePopup_Name:
            return "Receive blink::mojom::PopupWidgetHost::RequestClosePopup";
      case internal::kPopupWidgetHost_ShowPopup_Name:
            return "Receive blink::mojom::PopupWidgetHost::ShowPopup";
      case internal::kPopupWidgetHost_SetPopupBounds_Name:
            return "Receive blink::mojom::PopupWidgetHost::SetPopupBounds";
    }
  } else {
    switch (message.name()) {
      case internal::kPopupWidgetHost_RequestClosePopup_Name:
            return "Receive reply blink::mojom::PopupWidgetHost::RequestClosePopup";
      case internal::kPopupWidgetHost_ShowPopup_Name:
            return "Receive reply blink::mojom::PopupWidgetHost::ShowPopup";
      case internal::kPopupWidgetHost_SetPopupBounds_Name:
            return "Receive reply blink::mojom::PopupWidgetHost::SetPopupBounds";
    }
  }
  return "Receive unknown mojo message";
#else
  bool is_response = message.has_flag(mojo::Message::kFlagIsResponse);
  if (is_response) {
    return "Receive mojo reply";
  } else {
    return "Receive mojo message";
  }
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
}

#if !BUILDFLAG(IS_FUCHSIA)
uint32_t PopupWidgetHost::RequestClosePopup_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::PopupWidgetHost::RequestClosePopup");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t PopupWidgetHost::ShowPopup_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::PopupWidgetHost::ShowPopup");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t PopupWidgetHost::SetPopupBounds_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::PopupWidgetHost::SetPopupBounds");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
# endif // !BUILDFLAG(IS_FUCHSIA)

class PopupWidgetHost_ShowPopup_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  PopupWidgetHost_ShowPopup_ForwardToCallback(
      PopupWidgetHost::ShowPopupCallback callback
      ) : callback_(std::move(callback)) {
  }

  PopupWidgetHost_ShowPopup_ForwardToCallback(const PopupWidgetHost_ShowPopup_ForwardToCallback&) = delete;
  PopupWidgetHost_ShowPopup_ForwardToCallback& operator=(const PopupWidgetHost_ShowPopup_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  PopupWidgetHost::ShowPopupCallback callback_;
};

class PopupWidgetHost_SetPopupBounds_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  PopupWidgetHost_SetPopupBounds_ForwardToCallback(
      PopupWidgetHost::SetPopupBoundsCallback callback
      ) : callback_(std::move(callback)) {
  }

  PopupWidgetHost_SetPopupBounds_ForwardToCallback(const PopupWidgetHost_SetPopupBounds_ForwardToCallback&) = delete;
  PopupWidgetHost_SetPopupBounds_ForwardToCallback& operator=(const PopupWidgetHost_SetPopupBounds_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  PopupWidgetHost::SetPopupBoundsCallback callback_;
};

PopupWidgetHostProxy::PopupWidgetHostProxy(mojo::MessageReceiverWithResponder* receiver)
    : receiver_(receiver) {
}

void PopupWidgetHostProxy::RequestClosePopup(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send blink::mojom::PopupWidgetHost::RequestClosePopup");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kPopupWidgetHost_RequestClosePopup_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::PopupWidgetHost_RequestClosePopup_Params_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PopupWidgetHost::Name_);
  message.set_method_name("RequestClosePopup");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void PopupWidgetHostProxy::ShowPopup(
    const ::gfx::Rect& in_initial_rect, const ::gfx::Rect& in_anchor_rect, ShowPopupCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::PopupWidgetHost::ShowPopup", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("initial_rect"), in_initial_rect,
                        "<value of type const ::gfx::Rect&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("anchor_rect"), in_anchor_rect,
                        "<value of type const ::gfx::Rect&>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kPopupWidgetHost_ShowPopup_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::PopupWidgetHost_ShowPopup_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->initial_rect)::BaseType> initial_rect_fragment(
          params.message());
  mojo::internal::Serialize<::gfx::mojom::RectDataView>(
      in_initial_rect, initial_rect_fragment);
  params->initial_rect.Set(
      initial_rect_fragment.is_null() ? nullptr : initial_rect_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->initial_rect.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null initial_rect in PopupWidgetHost.ShowPopup request");
  mojo::internal::MessageFragment<
      typename decltype(params->anchor_rect)::BaseType> anchor_rect_fragment(
          params.message());
  mojo::internal::Serialize<::gfx::mojom::RectDataView>(
      in_anchor_rect, anchor_rect_fragment);
  params->anchor_rect.Set(
      anchor_rect_fragment.is_null() ? nullptr : anchor_rect_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->anchor_rect.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null anchor_rect in PopupWidgetHost.ShowPopup request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PopupWidgetHost::Name_);
  message.set_method_name("ShowPopup");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new PopupWidgetHost_ShowPopup_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void PopupWidgetHostProxy::SetPopupBounds(
    const ::gfx::Rect& in_bounds, SetPopupBoundsCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::PopupWidgetHost::SetPopupBounds", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("bounds"), in_bounds,
                        "<value of type const ::gfx::Rect&>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kPopupWidgetHost_SetPopupBounds_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::PopupWidgetHost_SetPopupBounds_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->bounds)::BaseType> bounds_fragment(
          params.message());
  mojo::internal::Serialize<::gfx::mojom::RectDataView>(
      in_bounds, bounds_fragment);
  params->bounds.Set(
      bounds_fragment.is_null() ? nullptr : bounds_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->bounds.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null bounds in PopupWidgetHost.SetPopupBounds request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PopupWidgetHost::Name_);
  message.set_method_name("SetPopupBounds");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new PopupWidgetHost_SetPopupBounds_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}
class PopupWidgetHost_ShowPopup_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static PopupWidgetHost::ShowPopupCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<PopupWidgetHost_ShowPopup_ProxyToResponder> proxy(
        new PopupWidgetHost_ShowPopup_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&PopupWidgetHost_ShowPopup_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~PopupWidgetHost_ShowPopup_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  PopupWidgetHost_ShowPopup_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "PopupWidgetHost::ShowPopupCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      );
};

bool PopupWidgetHost_ShowPopup_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::PopupWidgetHost_ShowPopup_ResponseParams_Data* params =
      reinterpret_cast<
          internal::PopupWidgetHost_ShowPopup_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  PopupWidgetHost_ShowPopup_ResponseParamsDataView input_data_view(params, message);
  
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        PopupWidgetHost::Name_, 1, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run();
  return true;
}

void PopupWidgetHost_ShowPopup_ProxyToResponder::Run(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send reply blink::mojom::PopupWidgetHost::ShowPopup");
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kPopupWidgetHost_ShowPopup_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::PopupWidgetHost_ShowPopup_ResponseParams_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PopupWidgetHost::Name_);
  message.set_method_name("ShowPopup");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class PopupWidgetHost_SetPopupBounds_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static PopupWidgetHost::SetPopupBoundsCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<PopupWidgetHost_SetPopupBounds_ProxyToResponder> proxy(
        new PopupWidgetHost_SetPopupBounds_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&PopupWidgetHost_SetPopupBounds_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~PopupWidgetHost_SetPopupBounds_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  PopupWidgetHost_SetPopupBounds_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "PopupWidgetHost::SetPopupBoundsCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      );
};

bool PopupWidgetHost_SetPopupBounds_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::PopupWidgetHost_SetPopupBounds_ResponseParams_Data* params =
      reinterpret_cast<
          internal::PopupWidgetHost_SetPopupBounds_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  PopupWidgetHost_SetPopupBounds_ResponseParamsDataView input_data_view(params, message);
  
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        PopupWidgetHost::Name_, 2, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run();
  return true;
}

void PopupWidgetHost_SetPopupBounds_ProxyToResponder::Run(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send reply blink::mojom::PopupWidgetHost::SetPopupBounds");
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kPopupWidgetHost_SetPopupBounds_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::PopupWidgetHost_SetPopupBounds_ResponseParams_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PopupWidgetHost::Name_);
  message.set_method_name("SetPopupBounds");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}

// static
bool PopupWidgetHostStubDispatch::Accept(
    PopupWidgetHost* impl,
    mojo::Message* message) {
  switch (message->header()->name) {
    case internal::kPopupWidgetHost_RequestClosePopup_Name: {

      DCHECK(message->is_serialized());
      internal::PopupWidgetHost_RequestClosePopup_Params_Data* params =
          reinterpret_cast<internal::PopupWidgetHost_RequestClosePopup_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      PopupWidgetHost_RequestClosePopup_ParamsDataView input_data_view(params, message);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            PopupWidgetHost::Name_, 0, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->RequestClosePopup();
      return true;
    }
    case internal::kPopupWidgetHost_ShowPopup_Name: {
      break;
    }
    case internal::kPopupWidgetHost_SetPopupBounds_Name: {
      break;
    }
  }
  return false;
}

// static
bool PopupWidgetHostStubDispatch::AcceptWithResponder(
    PopupWidgetHost* impl,
    mojo::Message* message,
    std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
  [[maybe_unused]] const bool message_is_sync =
      message->has_flag(mojo::Message::kFlagIsSync);
  [[maybe_unused]] const uint64_t request_id = message->request_id();
  switch (message->header()->name) {
    case internal::kPopupWidgetHost_RequestClosePopup_Name: {
      break;
    }
    case internal::kPopupWidgetHost_ShowPopup_Name: {

      internal::PopupWidgetHost_ShowPopup_Params_Data* params =
          reinterpret_cast<
              internal::PopupWidgetHost_ShowPopup_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      ::gfx::Rect p_initial_rect{};
      ::gfx::Rect p_anchor_rect{};
      PopupWidgetHost_ShowPopup_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadInitialRect(&p_initial_rect))
        success = false;
      if (success && !input_data_view.ReadAnchorRect(&p_anchor_rect))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            PopupWidgetHost::Name_, 1, false);
        return false;
      }
      PopupWidgetHost::ShowPopupCallback callback =
          PopupWidgetHost_ShowPopup_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->ShowPopup(
std::move(p_initial_rect), 
std::move(p_anchor_rect), std::move(callback));
      return true;
    }
    case internal::kPopupWidgetHost_SetPopupBounds_Name: {

      internal::PopupWidgetHost_SetPopupBounds_Params_Data* params =
          reinterpret_cast<
              internal::PopupWidgetHost_SetPopupBounds_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      ::gfx::Rect p_bounds{};
      PopupWidgetHost_SetPopupBounds_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadBounds(&p_bounds))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            PopupWidgetHost::Name_, 2, false);
        return false;
      }
      PopupWidgetHost::SetPopupBoundsCallback callback =
          PopupWidgetHost_SetPopupBounds_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SetPopupBounds(
std::move(p_bounds), std::move(callback));
      return true;
    }
  }
  return false;
}


static const mojo::internal::GenericValidationInfo kPopupWidgetHostValidationInfo[] = {
    {&internal::PopupWidgetHost_RequestClosePopup_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::PopupWidgetHost_ShowPopup_Params_Data::Validate,
     &internal::PopupWidgetHost_ShowPopup_ResponseParams_Data::Validate},
    {&internal::PopupWidgetHost_SetPopupBounds_Params_Data::Validate,
     &internal::PopupWidgetHost_SetPopupBounds_ResponseParams_Data::Validate},
};

bool PopupWidgetHostRequestValidator::Accept(mojo::Message* message) {
  const char* name = ::blink::mojom::PopupWidgetHost::Name_;
  return mojo::internal::ValidateRequestGenericPacked(message, name, kPopupWidgetHostValidationInfo);
}

bool PopupWidgetHostResponseValidator::Accept(mojo::Message* message) {
  const char* name = ::blink::mojom::PopupWidgetHost::Name_;
  return mojo::internal::ValidateResponseGenericPacked(message, name, kPopupWidgetHostValidationInfo);
}


}  // namespace mojom
}  // namespace blink


namespace mojo {

}  // namespace mojo


// Symbols declared in the -test-utils.h header are defined here instead of a
// separate .cc file to save compile time.


namespace blink {
namespace mojom {


void FrameWidgetInterceptorForTesting::DragTargetDragEnter(::blink::mojom::DragDataPtr drag_data, const ::gfx::PointF& point_in_viewport, const ::gfx::PointF& screen_point, ::blink::DragOperationsMask operations_allowed, uint32_t key_modifiers, DragTargetDragEnterCallback callback) {
  GetForwardingInterface()->DragTargetDragEnter(std::move(drag_data), std::move(point_in_viewport), std::move(screen_point), std::move(operations_allowed), std::move(key_modifiers), std::move(callback));
}
void FrameWidgetInterceptorForTesting::DragTargetDragOver(const ::gfx::PointF& point_in_viewport, const ::gfx::PointF& screen_point, ::blink::DragOperationsMask operations_allowed, uint32_t key_modifiers, DragTargetDragOverCallback callback) {
  GetForwardingInterface()->DragTargetDragOver(std::move(point_in_viewport), std::move(screen_point), std::move(operations_allowed), std::move(key_modifiers), std::move(callback));
}
void FrameWidgetInterceptorForTesting::DragTargetDragLeave(const ::gfx::PointF& point_in_viewport, const ::gfx::PointF& screen_point) {
  GetForwardingInterface()->DragTargetDragLeave(std::move(point_in_viewport), std::move(screen_point));
}
void FrameWidgetInterceptorForTesting::DragTargetDrop(::blink::mojom::DragDataPtr drag_data, const ::gfx::PointF& point_in_viewport, const ::gfx::PointF& screen_point, uint32_t key_modifiers, DragTargetDropCallback callback) {
  GetForwardingInterface()->DragTargetDrop(std::move(drag_data), std::move(point_in_viewport), std::move(screen_point), std::move(key_modifiers), std::move(callback));
}
void FrameWidgetInterceptorForTesting::DragSourceEndedAt(const ::gfx::PointF& point_in_viewport, const ::gfx::PointF& screen_point, ::ui::mojom::DragOperation drag_operation, DragSourceEndedAtCallback callback) {
  GetForwardingInterface()->DragSourceEndedAt(std::move(point_in_viewport), std::move(screen_point), std::move(drag_operation), std::move(callback));
}
void FrameWidgetInterceptorForTesting::DragSourceSystemDragEnded() {
  GetForwardingInterface()->DragSourceSystemDragEnded();
}
void FrameWidgetInterceptorForTesting::OnStartStylusWriting(OnStartStylusWritingCallback callback) {
  GetForwardingInterface()->OnStartStylusWriting(std::move(callback));
}
void FrameWidgetInterceptorForTesting::SetBackgroundOpaque(bool opaque) {
  GetForwardingInterface()->SetBackgroundOpaque(std::move(opaque));
}
void FrameWidgetInterceptorForTesting::SetTextDirection(::base::i18n::TextDirection direction) {
  GetForwardingInterface()->SetTextDirection(std::move(direction));
}
void FrameWidgetInterceptorForTesting::SetActive(bool active) {
  GetForwardingInterface()->SetActive(std::move(active));
}
void FrameWidgetInterceptorForTesting::SetInheritedEffectiveTouchActionForSubFrame(::cc::TouchAction touch_action) {
  GetForwardingInterface()->SetInheritedEffectiveTouchActionForSubFrame(std::move(touch_action));
}
void FrameWidgetInterceptorForTesting::UpdateRenderThrottlingStatusForSubFrame(bool is_throttled, bool subtree_throttled, bool display_locked) {
  GetForwardingInterface()->UpdateRenderThrottlingStatusForSubFrame(std::move(is_throttled), std::move(subtree_throttled), std::move(display_locked));
}
void FrameWidgetInterceptorForTesting::SetIsInertForSubFrame(bool inert) {
  GetForwardingInterface()->SetIsInertForSubFrame(std::move(inert));
}
void FrameWidgetInterceptorForTesting::ShowContextMenu(::ui::MenuSourceType source_type, const ::gfx::Point& location) {
  GetForwardingInterface()->ShowContextMenu(std::move(source_type), std::move(location));
}
void FrameWidgetInterceptorForTesting::EnableDeviceEmulation(const ::blink::DeviceEmulationParams& parameters) {
  GetForwardingInterface()->EnableDeviceEmulation(std::move(parameters));
}
void FrameWidgetInterceptorForTesting::DisableDeviceEmulation() {
  GetForwardingInterface()->DisableDeviceEmulation();
}
void FrameWidgetInterceptorForTesting::BindWidgetCompositor(::mojo::PendingReceiver<::blink::mojom::WidgetCompositor> host) {
  GetForwardingInterface()->BindWidgetCompositor(std::move(host));
}
void FrameWidgetInterceptorForTesting::BindInputTargetClient(::mojo::PendingReceiver<::viz::mojom::InputTargetClient> host) {
  GetForwardingInterface()->BindInputTargetClient(std::move(host));
}
void FrameWidgetInterceptorForTesting::SetViewportIntersection(::blink::mojom::ViewportIntersectionStatePtr intersection_state, const absl::optional<::blink::VisualProperties>& visual_properties) {
  GetForwardingInterface()->SetViewportIntersection(std::move(intersection_state), std::move(visual_properties));
}
FrameWidgetAsyncWaiter::FrameWidgetAsyncWaiter(
    FrameWidget* proxy) : proxy_(proxy) {}

FrameWidgetAsyncWaiter::~FrameWidgetAsyncWaiter() = default;

void FrameWidgetAsyncWaiter::DragTargetDragEnter(
    ::blink::mojom::DragDataPtr drag_data, const ::gfx::PointF& point_in_viewport, const ::gfx::PointF& screen_point, ::blink::DragOperationsMask operations_allowed, uint32_t key_modifiers, ::ui::mojom::DragOperation* out_operation) {
  base::RunLoop loop;
  proxy_->DragTargetDragEnter(std::move(drag_data),std::move(point_in_viewport),std::move(screen_point),std::move(operations_allowed),std::move(key_modifiers),
      base::BindOnce(
          [](base::RunLoop* loop,
             ::ui::mojom::DragOperation* out_operation
,
             ::ui::mojom::DragOperation operation) {*out_operation = std::move(operation);
            loop->Quit();
          },
          &loop,
          out_operation));
  loop.Run();
}
void FrameWidgetAsyncWaiter::DragTargetDragOver(
    const ::gfx::PointF& point_in_viewport, const ::gfx::PointF& screen_point, ::blink::DragOperationsMask operations_allowed, uint32_t key_modifiers, ::ui::mojom::DragOperation* out_operation) {
  base::RunLoop loop;
  proxy_->DragTargetDragOver(std::move(point_in_viewport),std::move(screen_point),std::move(operations_allowed),std::move(key_modifiers),
      base::BindOnce(
          [](base::RunLoop* loop,
             ::ui::mojom::DragOperation* out_operation
,
             ::ui::mojom::DragOperation operation) {*out_operation = std::move(operation);
            loop->Quit();
          },
          &loop,
          out_operation));
  loop.Run();
}
void FrameWidgetAsyncWaiter::DragTargetDrop(
    ::blink::mojom::DragDataPtr drag_data, const ::gfx::PointF& point_in_viewport, const ::gfx::PointF& screen_point, uint32_t key_modifiers) {
  base::RunLoop loop;
  proxy_->DragTargetDrop(std::move(drag_data),std::move(point_in_viewport),std::move(screen_point),std::move(key_modifiers),
      base::BindOnce(
          [](base::RunLoop* loop) {
            loop->Quit();
          },
          &loop));
  loop.Run();
}
void FrameWidgetAsyncWaiter::DragSourceEndedAt(
    const ::gfx::PointF& point_in_viewport, const ::gfx::PointF& screen_point, ::ui::mojom::DragOperation drag_operation) {
  base::RunLoop loop;
  proxy_->DragSourceEndedAt(std::move(point_in_viewport),std::move(screen_point),std::move(drag_operation),
      base::BindOnce(
          [](base::RunLoop* loop) {
            loop->Quit();
          },
          &loop));
  loop.Run();
}
void FrameWidgetAsyncWaiter::OnStartStylusWriting(
    absl::optional<::gfx::Rect>* out_focused_edit_bounds, absl::optional<::gfx::Rect>* out_caret_bounds) {
  base::RunLoop loop;
  proxy_->OnStartStylusWriting(
      base::BindOnce(
          [](base::RunLoop* loop,
             absl::optional<::gfx::Rect>* out_focused_edit_bounds
,
             absl::optional<::gfx::Rect>* out_caret_bounds
,
             const absl::optional<::gfx::Rect>& focused_edit_bounds,
             const absl::optional<::gfx::Rect>& caret_bounds) {*out_focused_edit_bounds = std::move(focused_edit_bounds);*out_caret_bounds = std::move(caret_bounds);
            loop->Quit();
          },
          &loop,
          out_focused_edit_bounds,
          out_caret_bounds));
  loop.Run();
}



void FrameWidgetHostInterceptorForTesting::AnimateDoubleTapZoomInMainFrame(const ::gfx::Point& tap_point, const ::gfx::Rect& rect_to_zoom) {
  GetForwardingInterface()->AnimateDoubleTapZoomInMainFrame(std::move(tap_point), std::move(rect_to_zoom));
}
void FrameWidgetHostInterceptorForTesting::ZoomToFindInPageRectInMainFrame(const ::gfx::Rect& rect_to_zoom) {
  GetForwardingInterface()->ZoomToFindInPageRectInMainFrame(std::move(rect_to_zoom));
}
void FrameWidgetHostInterceptorForTesting::SetHasTouchEventConsumers(::blink::mojom::TouchEventConsumersPtr touch_event_consumers) {
  GetForwardingInterface()->SetHasTouchEventConsumers(std::move(touch_event_consumers));
}
void FrameWidgetHostInterceptorForTesting::IntrinsicSizingInfoChanged(::blink::mojom::IntrinsicSizingInfoPtr sizing_info) {
  GetForwardingInterface()->IntrinsicSizingInfoChanged(std::move(sizing_info));
}
void FrameWidgetHostInterceptorForTesting::AutoscrollStart(const ::gfx::PointF& position) {
  GetForwardingInterface()->AutoscrollStart(std::move(position));
}
void FrameWidgetHostInterceptorForTesting::AutoscrollFling(const ::gfx::Vector2dF& velocity) {
  GetForwardingInterface()->AutoscrollFling(std::move(velocity));
}
void FrameWidgetHostInterceptorForTesting::AutoscrollEnd() {
  GetForwardingInterface()->AutoscrollEnd();
}
void FrameWidgetHostInterceptorForTesting::StartDragging(::blink::mojom::DragDataPtr drag_data, ::blink::DragOperationsMask operations_allowed, const ::SkBitmap& image, const ::gfx::Vector2d& bitmap_offset_in_dip, ::blink::mojom::DragEventSourceInfoPtr event_info) {
  GetForwardingInterface()->StartDragging(std::move(drag_data), std::move(operations_allowed), std::move(image), std::move(bitmap_offset_in_dip), std::move(event_info));
}
FrameWidgetHostAsyncWaiter::FrameWidgetHostAsyncWaiter(
    FrameWidgetHost* proxy) : proxy_(proxy) {}

FrameWidgetHostAsyncWaiter::~FrameWidgetHostAsyncWaiter() = default;




void PopupWidgetHostInterceptorForTesting::RequestClosePopup() {
  GetForwardingInterface()->RequestClosePopup();
}
void PopupWidgetHostInterceptorForTesting::ShowPopup(const ::gfx::Rect& initial_rect, const ::gfx::Rect& anchor_rect, ShowPopupCallback callback) {
  GetForwardingInterface()->ShowPopup(std::move(initial_rect), std::move(anchor_rect), std::move(callback));
}
void PopupWidgetHostInterceptorForTesting::SetPopupBounds(const ::gfx::Rect& bounds, SetPopupBoundsCallback callback) {
  GetForwardingInterface()->SetPopupBounds(std::move(bounds), std::move(callback));
}
PopupWidgetHostAsyncWaiter::PopupWidgetHostAsyncWaiter(
    PopupWidgetHost* proxy) : proxy_(proxy) {}

PopupWidgetHostAsyncWaiter::~PopupWidgetHostAsyncWaiter() = default;

void PopupWidgetHostAsyncWaiter::ShowPopup(
    const ::gfx::Rect& initial_rect, const ::gfx::Rect& anchor_rect) {
  base::RunLoop loop;
  proxy_->ShowPopup(std::move(initial_rect),std::move(anchor_rect),
      base::BindOnce(
          [](base::RunLoop* loop) {
            loop->Quit();
          },
          &loop));
  loop.Run();
}
void PopupWidgetHostAsyncWaiter::SetPopupBounds(
    const ::gfx::Rect& bounds) {
  base::RunLoop loop;
  proxy_->SetPopupBounds(std::move(bounds),
      base::BindOnce(
          [](base::RunLoop* loop) {
            loop->Quit();
          },
          &loop));
  loop.Run();
}





}  // namespace mojom
}  // namespace blink


#if defined(__clang__)
#pragma clang diagnostic pop
#endif