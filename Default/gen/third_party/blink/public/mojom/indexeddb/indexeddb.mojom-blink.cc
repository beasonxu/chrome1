// third_party/blink/public/mojom/indexeddb/indexeddb.mojom-blink.cc is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2013 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#if defined(__clang__)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-private-field"
#endif

#include "third_party/blink/public/mojom/indexeddb/indexeddb.mojom-blink.h"

#include <math.h>
#include <stdint.h>
#include <utility>

#include "base/debug/alias.h"
#include "base/hash/md5_constexpr.h"
#include "base/run_loop.h"
#include "base/strings/string_number_conversions.h"
#include "base/trace_event/trace_event.h"
#include "base/trace_event/typed_macros.h"
#include "mojo/public/cpp/bindings/lib/generated_code_util.h"
#include "mojo/public/cpp/bindings/lib/message_internal.h"
#include "mojo/public/cpp/bindings/lib/send_message_helper.h"
#include "mojo/public/cpp/bindings/lib/proxy_to_responder.h"
#include "mojo/public/cpp/bindings/lib/serialization_util.h"
#include "mojo/public/cpp/bindings/lib/unserialized_message_context.h"
#include "mojo/public/cpp/bindings/lib/validate_params.h"
#include "mojo/public/cpp/bindings/lib/validation_errors.h"
#include "mojo/public/cpp/bindings/mojo_buildflags.h"
#include "mojo/public/interfaces/bindings/interface_control_messages.mojom.h"
#include "third_party/perfetto/include/perfetto/tracing/traced_value.h"

#include "third_party/blink/public/mojom/indexeddb/indexeddb.mojom-params-data.h"
#include "third_party/blink/public/mojom/indexeddb/indexeddb.mojom-shared-message-ids.h"

#include "third_party/blink/public/mojom/indexeddb/indexeddb.mojom-blink-import-headers.h"
#include "third_party/blink/public/mojom/indexeddb/indexeddb.mojom-blink-test-utils.h"
#include "mojo/public/cpp/bindings/lib/wtf_serialization.h"


#ifndef THIRD_PARTY_BLINK_PUBLIC_MOJOM_INDEXEDDB_INDEXEDDB_MOJOM_BLINK_JUMBO_H_
#define THIRD_PARTY_BLINK_PUBLIC_MOJOM_INDEXEDDB_INDEXEDDB_MOJOM_BLINK_JUMBO_H_
#include "third_party/blink/renderer/modules/indexeddb/indexed_db_blink_mojom_traits.h"
#endif



namespace blink {
namespace mojom {
namespace blink {
IDBKeyPath::IDBKeyPath()
    : data() {}

IDBKeyPath::IDBKeyPath(
    IDBKeyPathDataPtr data_in)
    : data(std::move(data_in)) {}

IDBKeyPath::~IDBKeyPath() = default;

void IDBKeyPath::WriteIntoTrace(
    perfetto::TracedValue traced_context) const {
  [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "data"), this->data,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type IDBKeyPathDataPtr>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool IDBKeyPath::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
IDBKeyRange::IDBKeyRange()
    : lower(),
      upper(),
      lower_open(),
      upper_open() {}

IDBKeyRange::IDBKeyRange(
    ::std::unique_ptr<::blink::IDBKey> lower_in,
    ::std::unique_ptr<::blink::IDBKey> upper_in,
    bool lower_open_in,
    bool upper_open_in)
    : lower(std::move(lower_in)),
      upper(std::move(upper_in)),
      lower_open(std::move(lower_open_in)),
      upper_open(std::move(upper_open_in)) {}

IDBKeyRange::~IDBKeyRange() = default;

void IDBKeyRange::WriteIntoTrace(
    perfetto::TracedValue traced_context) const {
  [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "lower"), this->lower,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type ::std::unique_ptr<::blink::IDBKey>>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "upper"), this->upper,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type ::std::unique_ptr<::blink::IDBKey>>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "lower_open"), this->lower_open,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type bool>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "upper_open"), this->upper_open,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type bool>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool IDBKeyRange::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
IDBIndexMetadata::IDBIndexMetadata()
    : id(),
      name(),
      key_path(),
      unique(),
      multi_entry() {}

IDBIndexMetadata::IDBIndexMetadata(
    int64_t id_in,
    const ::WTF::String& name_in,
    const ::blink::IDBKeyPath& key_path_in,
    bool unique_in,
    bool multi_entry_in)
    : id(std::move(id_in)),
      name(std::move(name_in)),
      key_path(std::move(key_path_in)),
      unique(std::move(unique_in)),
      multi_entry(std::move(multi_entry_in)) {}

IDBIndexMetadata::~IDBIndexMetadata() = default;

void IDBIndexMetadata::WriteIntoTrace(
    perfetto::TracedValue traced_context) const {
  [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "id"), this->id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type int64_t>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "name"), this->name,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const ::WTF::String&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "key_path"), this->key_path,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const ::blink::IDBKeyPath&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "unique"), this->unique,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type bool>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "multi_entry"), this->multi_entry,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type bool>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool IDBIndexMetadata::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
IDBObjectStoreMetadata::IDBObjectStoreMetadata()
    : id(),
      name(),
      key_path(),
      auto_increment(),
      max_index_id(),
      indexes() {}

IDBObjectStoreMetadata::IDBObjectStoreMetadata(
    int64_t id_in,
    const ::WTF::String& name_in,
    const ::blink::IDBKeyPath& key_path_in,
    bool auto_increment_in,
    int64_t max_index_id_in,
    const WTF::HashMap<int64_t, ::scoped_refptr<::blink::IDBIndexMetadata>>& indexes_in)
    : id(std::move(id_in)),
      name(std::move(name_in)),
      key_path(std::move(key_path_in)),
      auto_increment(std::move(auto_increment_in)),
      max_index_id(std::move(max_index_id_in)),
      indexes(std::move(indexes_in)) {}

IDBObjectStoreMetadata::~IDBObjectStoreMetadata() = default;

void IDBObjectStoreMetadata::WriteIntoTrace(
    perfetto::TracedValue traced_context) const {
  [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "id"), this->id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type int64_t>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "name"), this->name,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const ::WTF::String&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "key_path"), this->key_path,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const ::blink::IDBKeyPath&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "auto_increment"), this->auto_increment,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type bool>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "max_index_id"), this->max_index_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type int64_t>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "indexes"), this->indexes,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const WTF::HashMap<int64_t, ::scoped_refptr<::blink::IDBIndexMetadata>>&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool IDBObjectStoreMetadata::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
IDBDatabaseMetadata::IDBDatabaseMetadata()
    : id(),
      name(),
      version(),
      max_object_store_id(),
      object_stores(),
      was_cold_open() {}

IDBDatabaseMetadata::IDBDatabaseMetadata(
    int64_t id_in,
    const ::WTF::String& name_in,
    int64_t version_in,
    int64_t max_object_store_id_in,
    const WTF::HashMap<int64_t, ::scoped_refptr<::blink::IDBObjectStoreMetadata>>& object_stores_in,
    bool was_cold_open_in)
    : id(std::move(id_in)),
      name(std::move(name_in)),
      version(std::move(version_in)),
      max_object_store_id(std::move(max_object_store_id_in)),
      object_stores(std::move(object_stores_in)),
      was_cold_open(std::move(was_cold_open_in)) {}

IDBDatabaseMetadata::~IDBDatabaseMetadata() = default;

void IDBDatabaseMetadata::WriteIntoTrace(
    perfetto::TracedValue traced_context) const {
  [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "id"), this->id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type int64_t>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "name"), this->name,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const ::WTF::String&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "version"), this->version,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type int64_t>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "max_object_store_id"), this->max_object_store_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type int64_t>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "object_stores"), this->object_stores,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const WTF::HashMap<int64_t, ::scoped_refptr<::blink::IDBObjectStoreMetadata>>&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "was_cold_open"), this->was_cold_open,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type bool>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool IDBDatabaseMetadata::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
IDBNameAndVersion::IDBNameAndVersion()
    : name(),
      version() {}

IDBNameAndVersion::IDBNameAndVersion(
    const ::WTF::String& name_in,
    int64_t version_in)
    : name(std::move(name_in)),
      version(std::move(version_in)) {}

IDBNameAndVersion::~IDBNameAndVersion() = default;

void IDBNameAndVersion::WriteIntoTrace(
    perfetto::TracedValue traced_context) const {
  [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "name"), this->name,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const ::WTF::String&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "version"), this->version,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type int64_t>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool IDBNameAndVersion::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
IDBIndexKeys::IDBIndexKeys()
    : index_id(),
      index_keys() {}

IDBIndexKeys::IDBIndexKeys(
    int64_t index_id_in,
    WTF::Vector<::std::unique_ptr<::blink::IDBKey>> index_keys_in)
    : index_id(std::move(index_id_in)),
      index_keys(std::move(index_keys_in)) {}

IDBIndexKeys::~IDBIndexKeys() = default;

void IDBIndexKeys::WriteIntoTrace(
    perfetto::TracedValue traced_context) const {
  [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "index_id"), this->index_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type int64_t>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "index_keys"), this->index_keys,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type WTF::Vector<::std::unique_ptr<::blink::IDBKey>>>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool IDBIndexKeys::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
IDBFileInfo::IDBFileInfo()
    : name(),
      last_modified() {}

IDBFileInfo::IDBFileInfo(
    const ::WTF::String& name_in,
    ::base::Time last_modified_in)
    : name(std::move(name_in)),
      last_modified(std::move(last_modified_in)) {}

IDBFileInfo::~IDBFileInfo() = default;

void IDBFileInfo::WriteIntoTrace(
    perfetto::TracedValue traced_context) const {
  [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "name"), this->name,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const ::WTF::String&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "last_modified"), this->last_modified,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type ::base::Time>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool IDBFileInfo::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
IDBBlobInfo::IDBBlobInfo()
    : blob(),
      uuid(),
      mime_type(),
      size(),
      file() {}

IDBBlobInfo::IDBBlobInfo(
    ::mojo::PendingRemote<::blink::mojom::blink::Blob> blob_in,
    const WTF::String& uuid_in,
    const ::WTF::String& mime_type_in,
    int64_t size_in,
    IDBFileInfoPtr file_in)
    : blob(std::move(blob_in)),
      uuid(std::move(uuid_in)),
      mime_type(std::move(mime_type_in)),
      size(std::move(size_in)),
      file(std::move(file_in)) {}

IDBBlobInfo::~IDBBlobInfo() = default;

void IDBBlobInfo::WriteIntoTrace(
    perfetto::TracedValue traced_context) const {
  [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "blob"), this->blob,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type ::mojo::PendingRemote<::blink::mojom::blink::Blob>>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "uuid"), this->uuid,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const WTF::String&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "mime_type"), this->mime_type,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const ::WTF::String&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "size"), this->size,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type int64_t>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "file"), this->file,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type IDBFileInfoPtr>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool IDBBlobInfo::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
IDBValue::IDBValue()
    : bits(),
      external_objects() {}

IDBValue::IDBValue(
    WTF::Vector<uint8_t> bits_in,
    WTF::Vector<IDBExternalObjectPtr> external_objects_in)
    : bits(std::move(bits_in)),
      external_objects(std::move(external_objects_in)) {}

IDBValue::~IDBValue() = default;

void IDBValue::WriteIntoTrace(
    perfetto::TracedValue traced_context) const {
  [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "bits"), this->bits,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const WTF::Vector<uint8_t>&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "external_objects"), this->external_objects,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type WTF::Vector<IDBExternalObjectPtr>>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool IDBValue::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
IDBReturnValue::IDBReturnValue()
    : value(),
      primary_key(),
      key_path() {}

IDBReturnValue::IDBReturnValue(
    ::std::unique_ptr<::blink::IDBValue> value_in,
    ::std::unique_ptr<::blink::IDBKey> primary_key_in,
    const ::blink::IDBKeyPath& key_path_in)
    : value(std::move(value_in)),
      primary_key(std::move(primary_key_in)),
      key_path(std::move(key_path_in)) {}

IDBReturnValue::~IDBReturnValue() = default;

void IDBReturnValue::WriteIntoTrace(
    perfetto::TracedValue traced_context) const {
  [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "value"), this->value,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type ::std::unique_ptr<::blink::IDBValue>>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "primary_key"), this->primary_key,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type ::std::unique_ptr<::blink::IDBKey>>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "key_path"), this->key_path,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const ::blink::IDBKeyPath&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool IDBReturnValue::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
IDBError::IDBError()
    : error_code(),
      error_message() {}

IDBError::IDBError(
    IDBException error_code_in,
    const ::WTF::String& error_message_in)
    : error_code(std::move(error_code_in)),
      error_message(std::move(error_message_in)) {}

IDBError::~IDBError() = default;

void IDBError::WriteIntoTrace(
    perfetto::TracedValue traced_context) const {
  [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "error_code"), this->error_code,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type IDBException>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "error_message"), this->error_message,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const ::WTF::String&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool IDBError::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
IDBCursorValue::IDBCursorValue()
    : keys(),
      primary_keys(),
      values() {}

IDBCursorValue::IDBCursorValue(
    WTF::Vector<::std::unique_ptr<::blink::IDBKey>> keys_in,
    WTF::Vector<::std::unique_ptr<::blink::IDBKey>> primary_keys_in,
    WTF::Vector<::std::unique_ptr<::blink::IDBValue>> values_in)
    : keys(std::move(keys_in)),
      primary_keys(std::move(primary_keys_in)),
      values(std::move(values_in)) {}

IDBCursorValue::~IDBCursorValue() = default;

void IDBCursorValue::WriteIntoTrace(
    perfetto::TracedValue traced_context) const {
  [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "keys"), this->keys,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type WTF::Vector<::std::unique_ptr<::blink::IDBKey>>>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "primary_keys"), this->primary_keys,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type WTF::Vector<::std::unique_ptr<::blink::IDBKey>>>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "values"), this->values,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type WTF::Vector<::std::unique_ptr<::blink::IDBValue>>>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool IDBCursorValue::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
IDBDatabaseOpenCursorValue::IDBDatabaseOpenCursorValue()
    : cursor(),
      key(),
      primary_key(),
      value() {}

IDBDatabaseOpenCursorValue::IDBDatabaseOpenCursorValue(
    ::mojo::PendingAssociatedRemote<IDBCursor> cursor_in,
    ::std::unique_ptr<::blink::IDBKey> key_in,
    ::std::unique_ptr<::blink::IDBKey> primary_key_in,
    absl::optional<::std::unique_ptr<::blink::IDBValue>> value_in)
    : cursor(std::move(cursor_in)),
      key(std::move(key_in)),
      primary_key(std::move(primary_key_in)),
      value(std::move(value_in)) {}

IDBDatabaseOpenCursorValue::~IDBDatabaseOpenCursorValue() = default;

void IDBDatabaseOpenCursorValue::WriteIntoTrace(
    perfetto::TracedValue traced_context) const {
  [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "cursor"), this->cursor,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type ::mojo::PendingAssociatedRemote<IDBCursor>>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "key"), this->key,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type ::std::unique_ptr<::blink::IDBKey>>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "primary_key"), this->primary_key,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type ::std::unique_ptr<::blink::IDBKey>>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "value"), this->value,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type absl::optional<::std::unique_ptr<::blink::IDBValue>>>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool IDBDatabaseOpenCursorValue::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
IDBKey::IDBKey() : tag_(Tag::kKeyArray) {
  data_.key_array = new WTF::Vector<::std::unique_ptr<::blink::IDBKey>>;
}

IDBKey::~IDBKey() {
  DestroyActive();
}


void IDBKey::set_key_array(
    WTF::Vector<::std::unique_ptr<::blink::IDBKey>> key_array) {
  if (tag_ == Tag::kKeyArray) {
    *(data_.key_array) = std::move(key_array);
  } else {
    DestroyActive();
    tag_ = Tag::kKeyArray;
    data_.key_array = new WTF::Vector<::std::unique_ptr<::blink::IDBKey>>(
        std::move(key_array));
  }
}
void IDBKey::set_binary(
    WTF::Vector<uint8_t> binary) {
  if (tag_ == Tag::kBinary) {
    *(data_.binary) = std::move(binary);
  } else {
    DestroyActive();
    tag_ = Tag::kBinary;
    data_.binary = new WTF::Vector<uint8_t>(
        std::move(binary));
  }
}
void IDBKey::set_string(
    const ::WTF::String& string) {
  if (tag_ == Tag::kString) {
    *(data_.string) = std::move(string);
  } else {
    DestroyActive();
    tag_ = Tag::kString;
    data_.string = new ::WTF::String(
        std::move(string));
  }
}
void IDBKey::set_date(
    double date) {
  if (tag_ != Tag::kDate) {
    DestroyActive();
    tag_ = Tag::kDate;
  }
  data_.date = date;
}
void IDBKey::set_number(
    double number) {
  if (tag_ != Tag::kNumber) {
    DestroyActive();
    tag_ = Tag::kNumber;
  }
  data_.number = number;
}
void IDBKey::set_other_none(
    bool other_none) {
  if (tag_ != Tag::kOtherNone) {
    DestroyActive();
    tag_ = Tag::kOtherNone;
  }
  data_.other_none = other_none;
}

void IDBKey::DestroyActive() {
  switch (tag_) {

    case Tag::kKeyArray:

      delete data_.key_array;
      break;
    case Tag::kBinary:

      delete data_.binary;
      break;
    case Tag::kString:

      delete data_.string;
      break;
    case Tag::kDate:

      break;
    case Tag::kNumber:

      break;
    case Tag::kOtherNone:

      break;
  }
}

bool IDBKey::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context, false);
}
IDBKeyPathData::IDBKeyPathData() : tag_(Tag::kString) {
  data_.string = new ::WTF::String;
}

IDBKeyPathData::~IDBKeyPathData() {
  DestroyActive();
}


void IDBKeyPathData::set_string(
    const ::WTF::String& string) {
  if (tag_ == Tag::kString) {
    *(data_.string) = std::move(string);
  } else {
    DestroyActive();
    tag_ = Tag::kString;
    data_.string = new ::WTF::String(
        std::move(string));
  }
}
void IDBKeyPathData::set_string_array(
    WTF::Vector<::WTF::String> string_array) {
  if (tag_ == Tag::kStringArray) {
    *(data_.string_array) = std::move(string_array);
  } else {
    DestroyActive();
    tag_ = Tag::kStringArray;
    data_.string_array = new WTF::Vector<::WTF::String>(
        std::move(string_array));
  }
}

void IDBKeyPathData::DestroyActive() {
  switch (tag_) {

    case Tag::kString:

      delete data_.string;
      break;
    case Tag::kStringArray:

      delete data_.string_array;
      break;
  }
}

bool IDBKeyPathData::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context, false);
}
IDBExternalObject::IDBExternalObject() : tag_(Tag::kBlobOrFile) {
  data_.blob_or_file = new IDBBlobInfoPtr;
}

IDBExternalObject::~IDBExternalObject() {
  DestroyActive();
}


void IDBExternalObject::set_blob_or_file(
    IDBBlobInfoPtr blob_or_file) {
  if (tag_ == Tag::kBlobOrFile) {
    *(data_.blob_or_file) = std::move(blob_or_file);
  } else {
    DestroyActive();
    tag_ = Tag::kBlobOrFile;
    data_.blob_or_file = new IDBBlobInfoPtr(
        std::move(blob_or_file));
  }
}
void IDBExternalObject::set_file_system_access_token(
    ::mojo::PendingRemote<::blink::mojom::blink::FileSystemAccessTransferToken> file_system_access_token) {
  if (tag_ == Tag::kFileSystemAccessToken) {
    *(data_.file_system_access_token) = std::move(file_system_access_token);
  } else {
    DestroyActive();
    tag_ = Tag::kFileSystemAccessToken;
    data_.file_system_access_token = new ::mojo::PendingRemote<::blink::mojom::blink::FileSystemAccessTransferToken>(
        std::move(file_system_access_token));
  }
}

void IDBExternalObject::DestroyActive() {
  switch (tag_) {

    case Tag::kBlobOrFile:

      delete data_.blob_or_file;
      break;
    case Tag::kFileSystemAccessToken:

      delete data_.file_system_access_token;
      break;
  }
}

bool IDBExternalObject::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context, false);
}
IDBCursorResult::IDBCursorResult() : tag_(Tag::kErrorResult) {
  data_.error_result = new IDBErrorPtr;
}

IDBCursorResult::~IDBCursorResult() {
  DestroyActive();
}


void IDBCursorResult::set_error_result(
    IDBErrorPtr error_result) {
  if (tag_ == Tag::kErrorResult) {
    *(data_.error_result) = std::move(error_result);
  } else {
    DestroyActive();
    tag_ = Tag::kErrorResult;
    data_.error_result = new IDBErrorPtr(
        std::move(error_result));
  }
}
void IDBCursorResult::set_empty(
    bool empty) {
  if (tag_ != Tag::kEmpty) {
    DestroyActive();
    tag_ = Tag::kEmpty;
  }
  data_.empty = empty;
}
void IDBCursorResult::set_values(
    IDBCursorValuePtr values) {
  if (tag_ == Tag::kValues) {
    *(data_.values) = std::move(values);
  } else {
    DestroyActive();
    tag_ = Tag::kValues;
    data_.values = new IDBCursorValuePtr(
        std::move(values));
  }
}

void IDBCursorResult::DestroyActive() {
  switch (tag_) {

    case Tag::kErrorResult:

      delete data_.error_result;
      break;
    case Tag::kEmpty:

      break;
    case Tag::kValues:

      delete data_.values;
      break;
  }
}

bool IDBCursorResult::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context, false);
}
IDBTransactionPutResult::IDBTransactionPutResult() : tag_(Tag::kErrorResult) {
  data_.error_result = new IDBErrorPtr;
}

IDBTransactionPutResult::~IDBTransactionPutResult() {
  DestroyActive();
}


void IDBTransactionPutResult::set_error_result(
    IDBErrorPtr error_result) {
  if (tag_ == Tag::kErrorResult) {
    *(data_.error_result) = std::move(error_result);
  } else {
    DestroyActive();
    tag_ = Tag::kErrorResult;
    data_.error_result = new IDBErrorPtr(
        std::move(error_result));
  }
}
void IDBTransactionPutResult::set_key(
    ::std::unique_ptr<::blink::IDBKey> key) {
  if (tag_ == Tag::kKey) {
    *(data_.key) = std::move(key);
  } else {
    DestroyActive();
    tag_ = Tag::kKey;
    data_.key = new ::std::unique_ptr<::blink::IDBKey>(
        std::move(key));
  }
}

void IDBTransactionPutResult::DestroyActive() {
  switch (tag_) {

    case Tag::kErrorResult:

      delete data_.error_result;
      break;
    case Tag::kKey:

      delete data_.key;
      break;
  }
}

bool IDBTransactionPutResult::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context, false);
}
IDBDatabaseGetResult::IDBDatabaseGetResult() : tag_(Tag::kErrorResult) {
  data_.error_result = new IDBErrorPtr;
}

IDBDatabaseGetResult::~IDBDatabaseGetResult() {
  DestroyActive();
}


void IDBDatabaseGetResult::set_error_result(
    IDBErrorPtr error_result) {
  if (tag_ == Tag::kErrorResult) {
    *(data_.error_result) = std::move(error_result);
  } else {
    DestroyActive();
    tag_ = Tag::kErrorResult;
    data_.error_result = new IDBErrorPtr(
        std::move(error_result));
  }
}
void IDBDatabaseGetResult::set_empty(
    bool empty) {
  if (tag_ != Tag::kEmpty) {
    DestroyActive();
    tag_ = Tag::kEmpty;
  }
  data_.empty = empty;
}
void IDBDatabaseGetResult::set_key(
    ::std::unique_ptr<::blink::IDBKey> key) {
  if (tag_ == Tag::kKey) {
    *(data_.key) = std::move(key);
  } else {
    DestroyActive();
    tag_ = Tag::kKey;
    data_.key = new ::std::unique_ptr<::blink::IDBKey>(
        std::move(key));
  }
}
void IDBDatabaseGetResult::set_value(
    IDBReturnValuePtr value) {
  if (tag_ == Tag::kValue) {
    *(data_.value) = std::move(value);
  } else {
    DestroyActive();
    tag_ = Tag::kValue;
    data_.value = new IDBReturnValuePtr(
        std::move(value));
  }
}

void IDBDatabaseGetResult::DestroyActive() {
  switch (tag_) {

    case Tag::kErrorResult:

      delete data_.error_result;
      break;
    case Tag::kEmpty:

      break;
    case Tag::kKey:

      delete data_.key;
      break;
    case Tag::kValue:

      delete data_.value;
      break;
  }
}

bool IDBDatabaseGetResult::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context, false);
}
IDBDatabaseBatchGetAllResult::IDBDatabaseBatchGetAllResult() : tag_(Tag::kErrorResult) {
  data_.error_result = new IDBErrorPtr;
}

IDBDatabaseBatchGetAllResult::~IDBDatabaseBatchGetAllResult() {
  DestroyActive();
}


void IDBDatabaseBatchGetAllResult::set_error_result(
    IDBErrorPtr error_result) {
  if (tag_ == Tag::kErrorResult) {
    *(data_.error_result) = std::move(error_result);
  } else {
    DestroyActive();
    tag_ = Tag::kErrorResult;
    data_.error_result = new IDBErrorPtr(
        std::move(error_result));
  }
}
void IDBDatabaseBatchGetAllResult::set_values(
    WTF::Vector<WTF::Vector<IDBReturnValuePtr>> values) {
  if (tag_ == Tag::kValues) {
    *(data_.values) = std::move(values);
  } else {
    DestroyActive();
    tag_ = Tag::kValues;
    data_.values = new WTF::Vector<WTF::Vector<IDBReturnValuePtr>>(
        std::move(values));
  }
}

void IDBDatabaseBatchGetAllResult::DestroyActive() {
  switch (tag_) {

    case Tag::kErrorResult:

      delete data_.error_result;
      break;
    case Tag::kValues:

      delete data_.values;
      break;
  }
}

bool IDBDatabaseBatchGetAllResult::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context, false);
}
IDBDatabaseOpenCursorResult::IDBDatabaseOpenCursorResult() : tag_(Tag::kErrorResult) {
  data_.error_result = new IDBErrorPtr;
}

IDBDatabaseOpenCursorResult::~IDBDatabaseOpenCursorResult() {
  DestroyActive();
}


void IDBDatabaseOpenCursorResult::set_error_result(
    IDBErrorPtr error_result) {
  if (tag_ == Tag::kErrorResult) {
    *(data_.error_result) = std::move(error_result);
  } else {
    DestroyActive();
    tag_ = Tag::kErrorResult;
    data_.error_result = new IDBErrorPtr(
        std::move(error_result));
  }
}
void IDBDatabaseOpenCursorResult::set_empty(
    bool empty) {
  if (tag_ != Tag::kEmpty) {
    DestroyActive();
    tag_ = Tag::kEmpty;
  }
  data_.empty = empty;
}
void IDBDatabaseOpenCursorResult::set_value(
    IDBDatabaseOpenCursorValuePtr value) {
  if (tag_ == Tag::kValue) {
    *(data_.value) = std::move(value);
  } else {
    DestroyActive();
    tag_ = Tag::kValue;
    data_.value = new IDBDatabaseOpenCursorValuePtr(
        std::move(value));
  }
}

void IDBDatabaseOpenCursorResult::DestroyActive() {
  switch (tag_) {

    case Tag::kErrorResult:

      delete data_.error_result;
      break;
    case Tag::kEmpty:

      break;
    case Tag::kValue:

      delete data_.value;
      break;
  }
}

bool IDBDatabaseOpenCursorResult::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context, false);
}
const char IDBCallbacks::Name_[] = "blink.mojom.IDBCallbacks";

IDBCallbacks::IPCStableHashFunction IDBCallbacks::MessageToMethodInfo_(mojo::Message& message) {
#if !BUILDFLAG(IS_FUCHSIA)
  switch (message.name()) {
    case internal::kIDBCallbacks_Error_Name: {
      return &IDBCallbacks::Error_Sym::IPCStableHash;
    }
    case internal::kIDBCallbacks_SuccessNamesAndVersionsList_Name: {
      return &IDBCallbacks::SuccessNamesAndVersionsList_Sym::IPCStableHash;
    }
    case internal::kIDBCallbacks_Blocked_Name: {
      return &IDBCallbacks::Blocked_Sym::IPCStableHash;
    }
    case internal::kIDBCallbacks_UpgradeNeeded_Name: {
      return &IDBCallbacks::UpgradeNeeded_Sym::IPCStableHash;
    }
    case internal::kIDBCallbacks_SuccessDatabase_Name: {
      return &IDBCallbacks::SuccessDatabase_Sym::IPCStableHash;
    }
    case internal::kIDBCallbacks_SuccessInteger_Name: {
      return &IDBCallbacks::SuccessInteger_Sym::IPCStableHash;
    }
    case internal::kIDBCallbacks_Success_Name: {
      return &IDBCallbacks::Success_Sym::IPCStableHash;
    }
  }
#endif  // !BUILDFLAG(IS_FUCHSIA)
  return nullptr;
}


const char* IDBCallbacks::MessageToMethodName_(mojo::Message& message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  bool is_response = message.has_flag(mojo::Message::kFlagIsResponse);
  if (!is_response) {
    switch (message.name()) {
      case internal::kIDBCallbacks_Error_Name:
            return "Receive blink::mojom::IDBCallbacks::Error";
      case internal::kIDBCallbacks_SuccessNamesAndVersionsList_Name:
            return "Receive blink::mojom::IDBCallbacks::SuccessNamesAndVersionsList";
      case internal::kIDBCallbacks_Blocked_Name:
            return "Receive blink::mojom::IDBCallbacks::Blocked";
      case internal::kIDBCallbacks_UpgradeNeeded_Name:
            return "Receive blink::mojom::IDBCallbacks::UpgradeNeeded";
      case internal::kIDBCallbacks_SuccessDatabase_Name:
            return "Receive blink::mojom::IDBCallbacks::SuccessDatabase";
      case internal::kIDBCallbacks_SuccessInteger_Name:
            return "Receive blink::mojom::IDBCallbacks::SuccessInteger";
      case internal::kIDBCallbacks_Success_Name:
            return "Receive blink::mojom::IDBCallbacks::Success";
    }
  } else {
    switch (message.name()) {
      case internal::kIDBCallbacks_Error_Name:
            return "Receive reply blink::mojom::IDBCallbacks::Error";
      case internal::kIDBCallbacks_SuccessNamesAndVersionsList_Name:
            return "Receive reply blink::mojom::IDBCallbacks::SuccessNamesAndVersionsList";
      case internal::kIDBCallbacks_Blocked_Name:
            return "Receive reply blink::mojom::IDBCallbacks::Blocked";
      case internal::kIDBCallbacks_UpgradeNeeded_Name:
            return "Receive reply blink::mojom::IDBCallbacks::UpgradeNeeded";
      case internal::kIDBCallbacks_SuccessDatabase_Name:
            return "Receive reply blink::mojom::IDBCallbacks::SuccessDatabase";
      case internal::kIDBCallbacks_SuccessInteger_Name:
            return "Receive reply blink::mojom::IDBCallbacks::SuccessInteger";
      case internal::kIDBCallbacks_Success_Name:
            return "Receive reply blink::mojom::IDBCallbacks::Success";
    }
  }
  return "Receive unknown mojo message";
#else
  bool is_response = message.has_flag(mojo::Message::kFlagIsResponse);
  if (is_response) {
    return "Receive mojo reply";
  } else {
    return "Receive mojo message";
  }
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
}

#if !BUILDFLAG(IS_FUCHSIA)
uint32_t IDBCallbacks::Error_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::IDBCallbacks::Error");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t IDBCallbacks::SuccessNamesAndVersionsList_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::IDBCallbacks::SuccessNamesAndVersionsList");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t IDBCallbacks::Blocked_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::IDBCallbacks::Blocked");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t IDBCallbacks::UpgradeNeeded_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::IDBCallbacks::UpgradeNeeded");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t IDBCallbacks::SuccessDatabase_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::IDBCallbacks::SuccessDatabase");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t IDBCallbacks::SuccessInteger_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::IDBCallbacks::SuccessInteger");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t IDBCallbacks::Success_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::IDBCallbacks::Success");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
# endif // !BUILDFLAG(IS_FUCHSIA)

IDBCallbacksProxy::IDBCallbacksProxy(mojo::MessageReceiverWithResponder* receiver)
    : receiver_(receiver) {
}

void IDBCallbacksProxy::Error(
    IDBException in_code, const ::WTF::String& in_message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::IDBCallbacks::Error", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("code"), in_code,
                        "<value of type IDBException>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("message"), in_message,
                        "<value of type const ::WTF::String&>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kIDBCallbacks_Error_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::IDBCallbacks_Error_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::Serialize<::blink::mojom::IDBException>(
      in_code, &params->code);
  mojo::internal::MessageFragment<
      typename decltype(params->message)::BaseType> message_fragment(
          params.message());
  mojo::internal::Serialize<::mojo_base::mojom::String16DataView>(
      in_message, message_fragment);
  params->message.Set(
      message_fragment.is_null() ? nullptr : message_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->message.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null message in IDBCallbacks.Error request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(IDBCallbacks::Name_);
  message.set_method_name("Error");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void IDBCallbacksProxy::SuccessNamesAndVersionsList(
    WTF::Vector<IDBNameAndVersionPtr> in_value) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::IDBCallbacks::SuccessNamesAndVersionsList", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("value"), in_value,
                        "<value of type WTF::Vector<IDBNameAndVersionPtr>>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kIDBCallbacks_SuccessNamesAndVersionsList_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::IDBCallbacks_SuccessNamesAndVersionsList_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->value)::BaseType>
      value_fragment(params.message());
  const mojo::internal::ContainerValidateParams value_validate_params(
      0, false, nullptr);
  mojo::internal::Serialize<mojo::ArrayDataView<::blink::mojom::IDBNameAndVersionDataView>>(
      in_value, value_fragment, &value_validate_params);
  params->value.Set(
      value_fragment.is_null() ? nullptr : value_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->value.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null value in IDBCallbacks.SuccessNamesAndVersionsList request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(IDBCallbacks::Name_);
  message.set_method_name("SuccessNamesAndVersionsList");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void IDBCallbacksProxy::Blocked(
    int64_t in_existing_version) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::IDBCallbacks::Blocked", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("existing_version"), in_existing_version,
                        "<value of type int64_t>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kIDBCallbacks_Blocked_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::IDBCallbacks_Blocked_Params_Data> params(
          message);
  params.Allocate();
  params->existing_version = in_existing_version;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(IDBCallbacks::Name_);
  message.set_method_name("Blocked");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void IDBCallbacksProxy::UpgradeNeeded(
    ::mojo::PendingAssociatedRemote<IDBDatabase> in_pending_database, int64_t in_old_version, IDBDataLoss in_data_loss, const WTF::String& in_data_loss_message, const ::blink::IDBDatabaseMetadata& in_db_metadata) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::IDBCallbacks::UpgradeNeeded", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("pending_database"), in_pending_database,
                        "<value of type ::mojo::PendingAssociatedRemote<IDBDatabase>>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("old_version"), in_old_version,
                        "<value of type int64_t>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("data_loss"), in_data_loss,
                        "<value of type IDBDataLoss>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("data_loss_message"), in_data_loss_message,
                        "<value of type const WTF::String&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("db_metadata"), in_db_metadata,
                        "<value of type const ::blink::IDBDatabaseMetadata&>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kIDBCallbacks_UpgradeNeeded_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::IDBCallbacks_UpgradeNeeded_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::Serialize<::blink::mojom::IDBDatabaseAssociatedPtrInfoDataView>(
      in_pending_database, &params->pending_database, &params.message());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      !mojo::internal::IsHandleOrInterfaceValid(params->pending_database),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_INVALID_INTERFACE_ID,
      "invalid pending_database in IDBCallbacks.UpgradeNeeded request");
  params->old_version = in_old_version;
  mojo::internal::Serialize<::blink::mojom::IDBDataLoss>(
      in_data_loss, &params->data_loss);
  mojo::internal::MessageFragment<
      typename decltype(params->data_loss_message)::BaseType> data_loss_message_fragment(
          params.message());
  mojo::internal::Serialize<mojo::StringDataView>(
      in_data_loss_message, data_loss_message_fragment);
  params->data_loss_message.Set(
      data_loss_message_fragment.is_null() ? nullptr : data_loss_message_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->data_loss_message.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null data_loss_message in IDBCallbacks.UpgradeNeeded request");
  mojo::internal::MessageFragment<
      typename decltype(params->db_metadata)::BaseType> db_metadata_fragment(
          params.message());
  mojo::internal::Serialize<::blink::mojom::IDBDatabaseMetadataDataView>(
      in_db_metadata, db_metadata_fragment);
  params->db_metadata.Set(
      db_metadata_fragment.is_null() ? nullptr : db_metadata_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->db_metadata.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null db_metadata in IDBCallbacks.UpgradeNeeded request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(IDBCallbacks::Name_);
  message.set_method_name("UpgradeNeeded");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void IDBCallbacksProxy::SuccessDatabase(
    ::mojo::PendingAssociatedRemote<IDBDatabase> in_pending_database, const ::blink::IDBDatabaseMetadata& in_metadata) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::IDBCallbacks::SuccessDatabase", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("pending_database"), in_pending_database,
                        "<value of type ::mojo::PendingAssociatedRemote<IDBDatabase>>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("metadata"), in_metadata,
                        "<value of type const ::blink::IDBDatabaseMetadata&>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kIDBCallbacks_SuccessDatabase_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::IDBCallbacks_SuccessDatabase_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::Serialize<::blink::mojom::IDBDatabaseAssociatedPtrInfoDataView>(
      in_pending_database, &params->pending_database, &params.message());
  mojo::internal::MessageFragment<
      typename decltype(params->metadata)::BaseType> metadata_fragment(
          params.message());
  mojo::internal::Serialize<::blink::mojom::IDBDatabaseMetadataDataView>(
      in_metadata, metadata_fragment);
  params->metadata.Set(
      metadata_fragment.is_null() ? nullptr : metadata_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->metadata.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null metadata in IDBCallbacks.SuccessDatabase request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(IDBCallbacks::Name_);
  message.set_method_name("SuccessDatabase");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void IDBCallbacksProxy::SuccessInteger(
    int64_t in_value) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::IDBCallbacks::SuccessInteger", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("value"), in_value,
                        "<value of type int64_t>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kIDBCallbacks_SuccessInteger_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::IDBCallbacks_SuccessInteger_Params_Data> params(
          message);
  params.Allocate();
  params->value = in_value;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(IDBCallbacks::Name_);
  message.set_method_name("SuccessInteger");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void IDBCallbacksProxy::Success(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send blink::mojom::IDBCallbacks::Success");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kIDBCallbacks_Success_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::IDBCallbacks_Success_Params_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(IDBCallbacks::Name_);
  message.set_method_name("Success");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

// static
bool IDBCallbacksStubDispatch::Accept(
    IDBCallbacks* impl,
    mojo::Message* message) {
  switch (message->header()->name) {
    case internal::kIDBCallbacks_Error_Name: {

      DCHECK(message->is_serialized());
      internal::IDBCallbacks_Error_Params_Data* params =
          reinterpret_cast<internal::IDBCallbacks_Error_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      IDBException p_code{};
      ::WTF::String p_message{};
      IDBCallbacks_Error_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadCode(&p_code))
        success = false;
      if (success && !input_data_view.ReadMessage(&p_message))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            IDBCallbacks::Name_, 0, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->Error(
std::move(p_code), 
std::move(p_message));
      return true;
    }
    case internal::kIDBCallbacks_SuccessNamesAndVersionsList_Name: {

      DCHECK(message->is_serialized());
      internal::IDBCallbacks_SuccessNamesAndVersionsList_Params_Data* params =
          reinterpret_cast<internal::IDBCallbacks_SuccessNamesAndVersionsList_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      WTF::Vector<IDBNameAndVersionPtr> p_value{};
      IDBCallbacks_SuccessNamesAndVersionsList_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadValue(&p_value))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            IDBCallbacks::Name_, 1, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SuccessNamesAndVersionsList(
std::move(p_value));
      return true;
    }
    case internal::kIDBCallbacks_Blocked_Name: {

      DCHECK(message->is_serialized());
      internal::IDBCallbacks_Blocked_Params_Data* params =
          reinterpret_cast<internal::IDBCallbacks_Blocked_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      int64_t p_existing_version{};
      IDBCallbacks_Blocked_ParamsDataView input_data_view(params, message);
      
      if (success)
        p_existing_version = input_data_view.existing_version();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            IDBCallbacks::Name_, 2, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->Blocked(
std::move(p_existing_version));
      return true;
    }
    case internal::kIDBCallbacks_UpgradeNeeded_Name: {

      DCHECK(message->is_serialized());
      internal::IDBCallbacks_UpgradeNeeded_Params_Data* params =
          reinterpret_cast<internal::IDBCallbacks_UpgradeNeeded_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::mojo::PendingAssociatedRemote<IDBDatabase> p_pending_database{};
      int64_t p_old_version{};
      IDBDataLoss p_data_loss{};
      WTF::String p_data_loss_message{};
      ::blink::IDBDatabaseMetadata p_db_metadata{};
      IDBCallbacks_UpgradeNeeded_ParamsDataView input_data_view(params, message);
      
      if (success) {
        p_pending_database =
            input_data_view.TakePendingDatabase<decltype(p_pending_database)>();
      }
      if (success)
        p_old_version = input_data_view.old_version();
      if (success && !input_data_view.ReadDataLoss(&p_data_loss))
        success = false;
      if (success && !input_data_view.ReadDataLossMessage(&p_data_loss_message))
        success = false;
      if (success && !input_data_view.ReadDbMetadata(&p_db_metadata))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            IDBCallbacks::Name_, 3, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->UpgradeNeeded(
std::move(p_pending_database), 
std::move(p_old_version), 
std::move(p_data_loss), 
std::move(p_data_loss_message), 
std::move(p_db_metadata));
      return true;
    }
    case internal::kIDBCallbacks_SuccessDatabase_Name: {

      DCHECK(message->is_serialized());
      internal::IDBCallbacks_SuccessDatabase_Params_Data* params =
          reinterpret_cast<internal::IDBCallbacks_SuccessDatabase_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::mojo::PendingAssociatedRemote<IDBDatabase> p_pending_database{};
      ::blink::IDBDatabaseMetadata p_metadata{};
      IDBCallbacks_SuccessDatabase_ParamsDataView input_data_view(params, message);
      
      if (success) {
        p_pending_database =
            input_data_view.TakePendingDatabase<decltype(p_pending_database)>();
      }
      if (success && !input_data_view.ReadMetadata(&p_metadata))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            IDBCallbacks::Name_, 4, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SuccessDatabase(
std::move(p_pending_database), 
std::move(p_metadata));
      return true;
    }
    case internal::kIDBCallbacks_SuccessInteger_Name: {

      DCHECK(message->is_serialized());
      internal::IDBCallbacks_SuccessInteger_Params_Data* params =
          reinterpret_cast<internal::IDBCallbacks_SuccessInteger_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      int64_t p_value{};
      IDBCallbacks_SuccessInteger_ParamsDataView input_data_view(params, message);
      
      if (success)
        p_value = input_data_view.value();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            IDBCallbacks::Name_, 5, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SuccessInteger(
std::move(p_value));
      return true;
    }
    case internal::kIDBCallbacks_Success_Name: {

      DCHECK(message->is_serialized());
      internal::IDBCallbacks_Success_Params_Data* params =
          reinterpret_cast<internal::IDBCallbacks_Success_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      IDBCallbacks_Success_ParamsDataView input_data_view(params, message);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            IDBCallbacks::Name_, 6, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->Success();
      return true;
    }
  }
  return false;
}

// static
bool IDBCallbacksStubDispatch::AcceptWithResponder(
    IDBCallbacks* impl,
    mojo::Message* message,
    std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
  [[maybe_unused]] const bool message_is_sync =
      message->has_flag(mojo::Message::kFlagIsSync);
  [[maybe_unused]] const uint64_t request_id = message->request_id();
  switch (message->header()->name) {
    case internal::kIDBCallbacks_Error_Name: {
      break;
    }
    case internal::kIDBCallbacks_SuccessNamesAndVersionsList_Name: {
      break;
    }
    case internal::kIDBCallbacks_Blocked_Name: {
      break;
    }
    case internal::kIDBCallbacks_UpgradeNeeded_Name: {
      break;
    }
    case internal::kIDBCallbacks_SuccessDatabase_Name: {
      break;
    }
    case internal::kIDBCallbacks_SuccessInteger_Name: {
      break;
    }
    case internal::kIDBCallbacks_Success_Name: {
      break;
    }
  }
  return false;
}


static const mojo::internal::GenericValidationInfo kIDBCallbacksValidationInfo[] = {
    {&internal::IDBCallbacks_Error_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::IDBCallbacks_SuccessNamesAndVersionsList_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::IDBCallbacks_Blocked_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::IDBCallbacks_UpgradeNeeded_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::IDBCallbacks_SuccessDatabase_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::IDBCallbacks_SuccessInteger_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::IDBCallbacks_Success_Params_Data::Validate,
     nullptr /* no response */},
};

bool IDBCallbacksRequestValidator::Accept(mojo::Message* message) {
  const char* name = ::blink::mojom::blink::IDBCallbacks::Name_;
  return mojo::internal::ValidateRequestGenericPacked(message, name, kIDBCallbacksValidationInfo);
}

const char IDBDatabaseCallbacks::Name_[] = "blink.mojom.IDBDatabaseCallbacks";

IDBDatabaseCallbacks::IPCStableHashFunction IDBDatabaseCallbacks::MessageToMethodInfo_(mojo::Message& message) {
#if !BUILDFLAG(IS_FUCHSIA)
  switch (message.name()) {
    case internal::kIDBDatabaseCallbacks_ForcedClose_Name: {
      return &IDBDatabaseCallbacks::ForcedClose_Sym::IPCStableHash;
    }
    case internal::kIDBDatabaseCallbacks_VersionChange_Name: {
      return &IDBDatabaseCallbacks::VersionChange_Sym::IPCStableHash;
    }
    case internal::kIDBDatabaseCallbacks_Abort_Name: {
      return &IDBDatabaseCallbacks::Abort_Sym::IPCStableHash;
    }
    case internal::kIDBDatabaseCallbacks_Complete_Name: {
      return &IDBDatabaseCallbacks::Complete_Sym::IPCStableHash;
    }
  }
#endif  // !BUILDFLAG(IS_FUCHSIA)
  return nullptr;
}


const char* IDBDatabaseCallbacks::MessageToMethodName_(mojo::Message& message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  bool is_response = message.has_flag(mojo::Message::kFlagIsResponse);
  if (!is_response) {
    switch (message.name()) {
      case internal::kIDBDatabaseCallbacks_ForcedClose_Name:
            return "Receive blink::mojom::IDBDatabaseCallbacks::ForcedClose";
      case internal::kIDBDatabaseCallbacks_VersionChange_Name:
            return "Receive blink::mojom::IDBDatabaseCallbacks::VersionChange";
      case internal::kIDBDatabaseCallbacks_Abort_Name:
            return "Receive blink::mojom::IDBDatabaseCallbacks::Abort";
      case internal::kIDBDatabaseCallbacks_Complete_Name:
            return "Receive blink::mojom::IDBDatabaseCallbacks::Complete";
    }
  } else {
    switch (message.name()) {
      case internal::kIDBDatabaseCallbacks_ForcedClose_Name:
            return "Receive reply blink::mojom::IDBDatabaseCallbacks::ForcedClose";
      case internal::kIDBDatabaseCallbacks_VersionChange_Name:
            return "Receive reply blink::mojom::IDBDatabaseCallbacks::VersionChange";
      case internal::kIDBDatabaseCallbacks_Abort_Name:
            return "Receive reply blink::mojom::IDBDatabaseCallbacks::Abort";
      case internal::kIDBDatabaseCallbacks_Complete_Name:
            return "Receive reply blink::mojom::IDBDatabaseCallbacks::Complete";
    }
  }
  return "Receive unknown mojo message";
#else
  bool is_response = message.has_flag(mojo::Message::kFlagIsResponse);
  if (is_response) {
    return "Receive mojo reply";
  } else {
    return "Receive mojo message";
  }
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
}

#if !BUILDFLAG(IS_FUCHSIA)
uint32_t IDBDatabaseCallbacks::ForcedClose_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::IDBDatabaseCallbacks::ForcedClose");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t IDBDatabaseCallbacks::VersionChange_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::IDBDatabaseCallbacks::VersionChange");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t IDBDatabaseCallbacks::Abort_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::IDBDatabaseCallbacks::Abort");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t IDBDatabaseCallbacks::Complete_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::IDBDatabaseCallbacks::Complete");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
# endif // !BUILDFLAG(IS_FUCHSIA)

IDBDatabaseCallbacksProxy::IDBDatabaseCallbacksProxy(mojo::MessageReceiverWithResponder* receiver)
    : receiver_(receiver) {
}

void IDBDatabaseCallbacksProxy::ForcedClose(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send blink::mojom::IDBDatabaseCallbacks::ForcedClose");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kIDBDatabaseCallbacks_ForcedClose_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::IDBDatabaseCallbacks_ForcedClose_Params_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(IDBDatabaseCallbacks::Name_);
  message.set_method_name("ForcedClose");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void IDBDatabaseCallbacksProxy::VersionChange(
    int64_t in_old_version, int64_t in_new_version) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::IDBDatabaseCallbacks::VersionChange", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("old_version"), in_old_version,
                        "<value of type int64_t>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("new_version"), in_new_version,
                        "<value of type int64_t>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kIDBDatabaseCallbacks_VersionChange_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::IDBDatabaseCallbacks_VersionChange_Params_Data> params(
          message);
  params.Allocate();
  params->old_version = in_old_version;
  params->new_version = in_new_version;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(IDBDatabaseCallbacks::Name_);
  message.set_method_name("VersionChange");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void IDBDatabaseCallbacksProxy::Abort(
    int64_t in_transaction_id, IDBException in_code, const ::WTF::String& in_message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::IDBDatabaseCallbacks::Abort", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("transaction_id"), in_transaction_id,
                        "<value of type int64_t>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("code"), in_code,
                        "<value of type IDBException>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("message"), in_message,
                        "<value of type const ::WTF::String&>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kIDBDatabaseCallbacks_Abort_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::IDBDatabaseCallbacks_Abort_Params_Data> params(
          message);
  params.Allocate();
  params->transaction_id = in_transaction_id;
  mojo::internal::Serialize<::blink::mojom::IDBException>(
      in_code, &params->code);
  mojo::internal::MessageFragment<
      typename decltype(params->message)::BaseType> message_fragment(
          params.message());
  mojo::internal::Serialize<::mojo_base::mojom::String16DataView>(
      in_message, message_fragment);
  params->message.Set(
      message_fragment.is_null() ? nullptr : message_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->message.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null message in IDBDatabaseCallbacks.Abort request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(IDBDatabaseCallbacks::Name_);
  message.set_method_name("Abort");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void IDBDatabaseCallbacksProxy::Complete(
    int64_t in_transaction_id) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::IDBDatabaseCallbacks::Complete", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("transaction_id"), in_transaction_id,
                        "<value of type int64_t>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kIDBDatabaseCallbacks_Complete_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::IDBDatabaseCallbacks_Complete_Params_Data> params(
          message);
  params.Allocate();
  params->transaction_id = in_transaction_id;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(IDBDatabaseCallbacks::Name_);
  message.set_method_name("Complete");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

// static
bool IDBDatabaseCallbacksStubDispatch::Accept(
    IDBDatabaseCallbacks* impl,
    mojo::Message* message) {
  switch (message->header()->name) {
    case internal::kIDBDatabaseCallbacks_ForcedClose_Name: {

      DCHECK(message->is_serialized());
      internal::IDBDatabaseCallbacks_ForcedClose_Params_Data* params =
          reinterpret_cast<internal::IDBDatabaseCallbacks_ForcedClose_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      IDBDatabaseCallbacks_ForcedClose_ParamsDataView input_data_view(params, message);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            IDBDatabaseCallbacks::Name_, 0, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->ForcedClose();
      return true;
    }
    case internal::kIDBDatabaseCallbacks_VersionChange_Name: {

      DCHECK(message->is_serialized());
      internal::IDBDatabaseCallbacks_VersionChange_Params_Data* params =
          reinterpret_cast<internal::IDBDatabaseCallbacks_VersionChange_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      int64_t p_old_version{};
      int64_t p_new_version{};
      IDBDatabaseCallbacks_VersionChange_ParamsDataView input_data_view(params, message);
      
      if (success)
        p_old_version = input_data_view.old_version();
      if (success)
        p_new_version = input_data_view.new_version();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            IDBDatabaseCallbacks::Name_, 1, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->VersionChange(
std::move(p_old_version), 
std::move(p_new_version));
      return true;
    }
    case internal::kIDBDatabaseCallbacks_Abort_Name: {

      DCHECK(message->is_serialized());
      internal::IDBDatabaseCallbacks_Abort_Params_Data* params =
          reinterpret_cast<internal::IDBDatabaseCallbacks_Abort_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      int64_t p_transaction_id{};
      IDBException p_code{};
      ::WTF::String p_message{};
      IDBDatabaseCallbacks_Abort_ParamsDataView input_data_view(params, message);
      
      if (success)
        p_transaction_id = input_data_view.transaction_id();
      if (success && !input_data_view.ReadCode(&p_code))
        success = false;
      if (success && !input_data_view.ReadMessage(&p_message))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            IDBDatabaseCallbacks::Name_, 2, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->Abort(
std::move(p_transaction_id), 
std::move(p_code), 
std::move(p_message));
      return true;
    }
    case internal::kIDBDatabaseCallbacks_Complete_Name: {

      DCHECK(message->is_serialized());
      internal::IDBDatabaseCallbacks_Complete_Params_Data* params =
          reinterpret_cast<internal::IDBDatabaseCallbacks_Complete_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      int64_t p_transaction_id{};
      IDBDatabaseCallbacks_Complete_ParamsDataView input_data_view(params, message);
      
      if (success)
        p_transaction_id = input_data_view.transaction_id();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            IDBDatabaseCallbacks::Name_, 3, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->Complete(
std::move(p_transaction_id));
      return true;
    }
  }
  return false;
}

// static
bool IDBDatabaseCallbacksStubDispatch::AcceptWithResponder(
    IDBDatabaseCallbacks* impl,
    mojo::Message* message,
    std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
  [[maybe_unused]] const bool message_is_sync =
      message->has_flag(mojo::Message::kFlagIsSync);
  [[maybe_unused]] const uint64_t request_id = message->request_id();
  switch (message->header()->name) {
    case internal::kIDBDatabaseCallbacks_ForcedClose_Name: {
      break;
    }
    case internal::kIDBDatabaseCallbacks_VersionChange_Name: {
      break;
    }
    case internal::kIDBDatabaseCallbacks_Abort_Name: {
      break;
    }
    case internal::kIDBDatabaseCallbacks_Complete_Name: {
      break;
    }
  }
  return false;
}


static const mojo::internal::GenericValidationInfo kIDBDatabaseCallbacksValidationInfo[] = {
    {&internal::IDBDatabaseCallbacks_ForcedClose_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::IDBDatabaseCallbacks_VersionChange_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::IDBDatabaseCallbacks_Abort_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::IDBDatabaseCallbacks_Complete_Params_Data::Validate,
     nullptr /* no response */},
};

bool IDBDatabaseCallbacksRequestValidator::Accept(mojo::Message* message) {
  const char* name = ::blink::mojom::blink::IDBDatabaseCallbacks::Name_;
  return mojo::internal::ValidateRequestGenericPacked(message, name, kIDBDatabaseCallbacksValidationInfo);
}

const char IDBCursor::Name_[] = "blink.mojom.IDBCursor";

IDBCursor::IPCStableHashFunction IDBCursor::MessageToMethodInfo_(mojo::Message& message) {
#if !BUILDFLAG(IS_FUCHSIA)
  switch (message.name()) {
    case internal::kIDBCursor_Advance_Name: {
      return &IDBCursor::Advance_Sym::IPCStableHash;
    }
    case internal::kIDBCursor_CursorContinue_Name: {
      return &IDBCursor::CursorContinue_Sym::IPCStableHash;
    }
    case internal::kIDBCursor_Prefetch_Name: {
      return &IDBCursor::Prefetch_Sym::IPCStableHash;
    }
    case internal::kIDBCursor_PrefetchReset_Name: {
      return &IDBCursor::PrefetchReset_Sym::IPCStableHash;
    }
  }
#endif  // !BUILDFLAG(IS_FUCHSIA)
  return nullptr;
}


const char* IDBCursor::MessageToMethodName_(mojo::Message& message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  bool is_response = message.has_flag(mojo::Message::kFlagIsResponse);
  if (!is_response) {
    switch (message.name()) {
      case internal::kIDBCursor_Advance_Name:
            return "Receive blink::mojom::IDBCursor::Advance";
      case internal::kIDBCursor_CursorContinue_Name:
            return "Receive blink::mojom::IDBCursor::CursorContinue";
      case internal::kIDBCursor_Prefetch_Name:
            return "Receive blink::mojom::IDBCursor::Prefetch";
      case internal::kIDBCursor_PrefetchReset_Name:
            return "Receive blink::mojom::IDBCursor::PrefetchReset";
    }
  } else {
    switch (message.name()) {
      case internal::kIDBCursor_Advance_Name:
            return "Receive reply blink::mojom::IDBCursor::Advance";
      case internal::kIDBCursor_CursorContinue_Name:
            return "Receive reply blink::mojom::IDBCursor::CursorContinue";
      case internal::kIDBCursor_Prefetch_Name:
            return "Receive reply blink::mojom::IDBCursor::Prefetch";
      case internal::kIDBCursor_PrefetchReset_Name:
            return "Receive reply blink::mojom::IDBCursor::PrefetchReset";
    }
  }
  return "Receive unknown mojo message";
#else
  bool is_response = message.has_flag(mojo::Message::kFlagIsResponse);
  if (is_response) {
    return "Receive mojo reply";
  } else {
    return "Receive mojo message";
  }
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
}

#if !BUILDFLAG(IS_FUCHSIA)
uint32_t IDBCursor::Advance_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::IDBCursor::Advance");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t IDBCursor::CursorContinue_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::IDBCursor::CursorContinue");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t IDBCursor::Prefetch_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::IDBCursor::Prefetch");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t IDBCursor::PrefetchReset_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::IDBCursor::PrefetchReset");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
# endif // !BUILDFLAG(IS_FUCHSIA)

class IDBCursor_Advance_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  IDBCursor_Advance_ForwardToCallback(
      IDBCursor::AdvanceCallback callback
      ) : callback_(std::move(callback)) {
  }

  IDBCursor_Advance_ForwardToCallback(const IDBCursor_Advance_ForwardToCallback&) = delete;
  IDBCursor_Advance_ForwardToCallback& operator=(const IDBCursor_Advance_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  IDBCursor::AdvanceCallback callback_;
};

class IDBCursor_CursorContinue_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  IDBCursor_CursorContinue_ForwardToCallback(
      IDBCursor::CursorContinueCallback callback
      ) : callback_(std::move(callback)) {
  }

  IDBCursor_CursorContinue_ForwardToCallback(const IDBCursor_CursorContinue_ForwardToCallback&) = delete;
  IDBCursor_CursorContinue_ForwardToCallback& operator=(const IDBCursor_CursorContinue_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  IDBCursor::CursorContinueCallback callback_;
};

class IDBCursor_Prefetch_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  IDBCursor_Prefetch_ForwardToCallback(
      IDBCursor::PrefetchCallback callback
      ) : callback_(std::move(callback)) {
  }

  IDBCursor_Prefetch_ForwardToCallback(const IDBCursor_Prefetch_ForwardToCallback&) = delete;
  IDBCursor_Prefetch_ForwardToCallback& operator=(const IDBCursor_Prefetch_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  IDBCursor::PrefetchCallback callback_;
};

IDBCursorProxy::IDBCursorProxy(mojo::MessageReceiverWithResponder* receiver)
    : receiver_(receiver) {
}

void IDBCursorProxy::Advance(
    uint32_t in_count, AdvanceCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::IDBCursor::Advance", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("count"), in_count,
                        "<value of type uint32_t>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kIDBCursor_Advance_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::IDBCursor_Advance_Params_Data> params(
          message);
  params.Allocate();
  params->count = in_count;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(IDBCursor::Name_);
  message.set_method_name("Advance");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new IDBCursor_Advance_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void IDBCursorProxy::CursorContinue(
    ::std::unique_ptr<::blink::IDBKey> in_key, ::std::unique_ptr<::blink::IDBKey> in_primary_key, CursorContinueCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::IDBCursor::CursorContinue", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("key"), in_key,
                        "<value of type ::std::unique_ptr<::blink::IDBKey>>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("primary_key"), in_primary_key,
                        "<value of type ::std::unique_ptr<::blink::IDBKey>>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kIDBCursor_CursorContinue_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::IDBCursor_CursorContinue_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<decltype(params->key)>
      key_fragment(params.message());
  key_fragment.Claim(&params->key);
  mojo::internal::Serialize<::blink::mojom::IDBKeyDataView>(
      in_key, key_fragment, true);
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->key.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null key in IDBCursor.CursorContinue request");
  mojo::internal::MessageFragment<decltype(params->primary_key)>
      primary_key_fragment(params.message());
  primary_key_fragment.Claim(&params->primary_key);
  mojo::internal::Serialize<::blink::mojom::IDBKeyDataView>(
      in_primary_key, primary_key_fragment, true);
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->primary_key.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null primary_key in IDBCursor.CursorContinue request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(IDBCursor::Name_);
  message.set_method_name("CursorContinue");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new IDBCursor_CursorContinue_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void IDBCursorProxy::Prefetch(
    int32_t in_count, PrefetchCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::IDBCursor::Prefetch", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("count"), in_count,
                        "<value of type int32_t>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kIDBCursor_Prefetch_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::IDBCursor_Prefetch_Params_Data> params(
          message);
  params.Allocate();
  params->count = in_count;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(IDBCursor::Name_);
  message.set_method_name("Prefetch");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new IDBCursor_Prefetch_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void IDBCursorProxy::PrefetchReset(
    int32_t in_used_prefetches, int32_t in_unused_prefetches) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::IDBCursor::PrefetchReset", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("used_prefetches"), in_used_prefetches,
                        "<value of type int32_t>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("unused_prefetches"), in_unused_prefetches,
                        "<value of type int32_t>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kIDBCursor_PrefetchReset_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::IDBCursor_PrefetchReset_Params_Data> params(
          message);
  params.Allocate();
  params->used_prefetches = in_used_prefetches;
  params->unused_prefetches = in_unused_prefetches;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(IDBCursor::Name_);
  message.set_method_name("PrefetchReset");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}
class IDBCursor_Advance_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static IDBCursor::AdvanceCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<IDBCursor_Advance_ProxyToResponder> proxy(
        new IDBCursor_Advance_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&IDBCursor_Advance_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~IDBCursor_Advance_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  IDBCursor_Advance_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "IDBCursor::AdvanceCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      IDBCursorResultPtr in_result);
};

bool IDBCursor_Advance_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::IDBCursor_Advance_ResponseParams_Data* params =
      reinterpret_cast<
          internal::IDBCursor_Advance_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  IDBCursorResultPtr p_result{};
  IDBCursor_Advance_ResponseParamsDataView input_data_view(params, message);
  
  if (success && !input_data_view.ReadResult(&p_result))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        IDBCursor::Name_, 0, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_result));
  return true;
}

void IDBCursor_Advance_ProxyToResponder::Run(
    IDBCursorResultPtr in_result) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send reply blink::mojom::IDBCursor::Advance", "async_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("result"), in_result,
                        "<value of type IDBCursorResultPtr>");
   });
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kIDBCursor_Advance_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::IDBCursor_Advance_ResponseParams_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<decltype(params->result)>
      result_fragment(params.message());
  result_fragment.Claim(&params->result);
  mojo::internal::Serialize<::blink::mojom::IDBCursorResultDataView>(
      in_result, result_fragment, true);
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->result.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null result in ");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(IDBCursor::Name_);
  message.set_method_name("Advance");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class IDBCursor_CursorContinue_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static IDBCursor::CursorContinueCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<IDBCursor_CursorContinue_ProxyToResponder> proxy(
        new IDBCursor_CursorContinue_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&IDBCursor_CursorContinue_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~IDBCursor_CursorContinue_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  IDBCursor_CursorContinue_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "IDBCursor::CursorContinueCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      IDBCursorResultPtr in_result);
};

bool IDBCursor_CursorContinue_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::IDBCursor_CursorContinue_ResponseParams_Data* params =
      reinterpret_cast<
          internal::IDBCursor_CursorContinue_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  IDBCursorResultPtr p_result{};
  IDBCursor_CursorContinue_ResponseParamsDataView input_data_view(params, message);
  
  if (success && !input_data_view.ReadResult(&p_result))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        IDBCursor::Name_, 1, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_result));
  return true;
}

void IDBCursor_CursorContinue_ProxyToResponder::Run(
    IDBCursorResultPtr in_result) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send reply blink::mojom::IDBCursor::CursorContinue", "async_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("result"), in_result,
                        "<value of type IDBCursorResultPtr>");
   });
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kIDBCursor_CursorContinue_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::IDBCursor_CursorContinue_ResponseParams_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<decltype(params->result)>
      result_fragment(params.message());
  result_fragment.Claim(&params->result);
  mojo::internal::Serialize<::blink::mojom::IDBCursorResultDataView>(
      in_result, result_fragment, true);
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->result.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null result in ");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(IDBCursor::Name_);
  message.set_method_name("CursorContinue");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class IDBCursor_Prefetch_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static IDBCursor::PrefetchCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<IDBCursor_Prefetch_ProxyToResponder> proxy(
        new IDBCursor_Prefetch_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&IDBCursor_Prefetch_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~IDBCursor_Prefetch_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  IDBCursor_Prefetch_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "IDBCursor::PrefetchCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      IDBCursorResultPtr in_result);
};

bool IDBCursor_Prefetch_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::IDBCursor_Prefetch_ResponseParams_Data* params =
      reinterpret_cast<
          internal::IDBCursor_Prefetch_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  IDBCursorResultPtr p_result{};
  IDBCursor_Prefetch_ResponseParamsDataView input_data_view(params, message);
  
  if (success && !input_data_view.ReadResult(&p_result))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        IDBCursor::Name_, 2, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_result));
  return true;
}

void IDBCursor_Prefetch_ProxyToResponder::Run(
    IDBCursorResultPtr in_result) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send reply blink::mojom::IDBCursor::Prefetch", "async_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("result"), in_result,
                        "<value of type IDBCursorResultPtr>");
   });
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kIDBCursor_Prefetch_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::IDBCursor_Prefetch_ResponseParams_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<decltype(params->result)>
      result_fragment(params.message());
  result_fragment.Claim(&params->result);
  mojo::internal::Serialize<::blink::mojom::IDBCursorResultDataView>(
      in_result, result_fragment, true);
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->result.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null result in ");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(IDBCursor::Name_);
  message.set_method_name("Prefetch");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}

// static
bool IDBCursorStubDispatch::Accept(
    IDBCursor* impl,
    mojo::Message* message) {
  switch (message->header()->name) {
    case internal::kIDBCursor_Advance_Name: {
      break;
    }
    case internal::kIDBCursor_CursorContinue_Name: {
      break;
    }
    case internal::kIDBCursor_Prefetch_Name: {
      break;
    }
    case internal::kIDBCursor_PrefetchReset_Name: {

      DCHECK(message->is_serialized());
      internal::IDBCursor_PrefetchReset_Params_Data* params =
          reinterpret_cast<internal::IDBCursor_PrefetchReset_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      int32_t p_used_prefetches{};
      int32_t p_unused_prefetches{};
      IDBCursor_PrefetchReset_ParamsDataView input_data_view(params, message);
      
      if (success)
        p_used_prefetches = input_data_view.used_prefetches();
      if (success)
        p_unused_prefetches = input_data_view.unused_prefetches();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            IDBCursor::Name_, 3, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->PrefetchReset(
std::move(p_used_prefetches), 
std::move(p_unused_prefetches));
      return true;
    }
  }
  return false;
}

// static
bool IDBCursorStubDispatch::AcceptWithResponder(
    IDBCursor* impl,
    mojo::Message* message,
    std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
  [[maybe_unused]] const bool message_is_sync =
      message->has_flag(mojo::Message::kFlagIsSync);
  [[maybe_unused]] const uint64_t request_id = message->request_id();
  switch (message->header()->name) {
    case internal::kIDBCursor_Advance_Name: {

      internal::IDBCursor_Advance_Params_Data* params =
          reinterpret_cast<
              internal::IDBCursor_Advance_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      uint32_t p_count{};
      IDBCursor_Advance_ParamsDataView input_data_view(params, message);
      
      if (success)
        p_count = input_data_view.count();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            IDBCursor::Name_, 0, false);
        return false;
      }
      IDBCursor::AdvanceCallback callback =
          IDBCursor_Advance_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->Advance(
std::move(p_count), std::move(callback));
      return true;
    }
    case internal::kIDBCursor_CursorContinue_Name: {

      internal::IDBCursor_CursorContinue_Params_Data* params =
          reinterpret_cast<
              internal::IDBCursor_CursorContinue_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      ::std::unique_ptr<::blink::IDBKey> p_key{};
      ::std::unique_ptr<::blink::IDBKey> p_primary_key{};
      IDBCursor_CursorContinue_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadKey(&p_key))
        success = false;
      if (success && !input_data_view.ReadPrimaryKey(&p_primary_key))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            IDBCursor::Name_, 1, false);
        return false;
      }
      IDBCursor::CursorContinueCallback callback =
          IDBCursor_CursorContinue_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->CursorContinue(
std::move(p_key), 
std::move(p_primary_key), std::move(callback));
      return true;
    }
    case internal::kIDBCursor_Prefetch_Name: {

      internal::IDBCursor_Prefetch_Params_Data* params =
          reinterpret_cast<
              internal::IDBCursor_Prefetch_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      int32_t p_count{};
      IDBCursor_Prefetch_ParamsDataView input_data_view(params, message);
      
      if (success)
        p_count = input_data_view.count();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            IDBCursor::Name_, 2, false);
        return false;
      }
      IDBCursor::PrefetchCallback callback =
          IDBCursor_Prefetch_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->Prefetch(
std::move(p_count), std::move(callback));
      return true;
    }
    case internal::kIDBCursor_PrefetchReset_Name: {
      break;
    }
  }
  return false;
}


static const mojo::internal::GenericValidationInfo kIDBCursorValidationInfo[] = {
    {&internal::IDBCursor_Advance_Params_Data::Validate,
     &internal::IDBCursor_Advance_ResponseParams_Data::Validate},
    {&internal::IDBCursor_CursorContinue_Params_Data::Validate,
     &internal::IDBCursor_CursorContinue_ResponseParams_Data::Validate},
    {&internal::IDBCursor_Prefetch_Params_Data::Validate,
     &internal::IDBCursor_Prefetch_ResponseParams_Data::Validate},
    {&internal::IDBCursor_PrefetchReset_Params_Data::Validate,
     nullptr /* no response */},
};

bool IDBCursorRequestValidator::Accept(mojo::Message* message) {
  const char* name = ::blink::mojom::blink::IDBCursor::Name_;
  return mojo::internal::ValidateRequestGenericPacked(message, name, kIDBCursorValidationInfo);
}

bool IDBCursorResponseValidator::Accept(mojo::Message* message) {
  const char* name = ::blink::mojom::blink::IDBCursor::Name_;
  return mojo::internal::ValidateResponseGenericPacked(message, name, kIDBCursorValidationInfo);
}
const char IDBTransaction::Name_[] = "blink.mojom.IDBTransaction";

IDBTransaction::IPCStableHashFunction IDBTransaction::MessageToMethodInfo_(mojo::Message& message) {
#if !BUILDFLAG(IS_FUCHSIA)
  switch (message.name()) {
    case internal::kIDBTransaction_CreateObjectStore_Name: {
      return &IDBTransaction::CreateObjectStore_Sym::IPCStableHash;
    }
    case internal::kIDBTransaction_DeleteObjectStore_Name: {
      return &IDBTransaction::DeleteObjectStore_Sym::IPCStableHash;
    }
    case internal::kIDBTransaction_Put_Name: {
      return &IDBTransaction::Put_Sym::IPCStableHash;
    }
    case internal::kIDBTransaction_Commit_Name: {
      return &IDBTransaction::Commit_Sym::IPCStableHash;
    }
  }
#endif  // !BUILDFLAG(IS_FUCHSIA)
  return nullptr;
}


const char* IDBTransaction::MessageToMethodName_(mojo::Message& message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  bool is_response = message.has_flag(mojo::Message::kFlagIsResponse);
  if (!is_response) {
    switch (message.name()) {
      case internal::kIDBTransaction_CreateObjectStore_Name:
            return "Receive blink::mojom::IDBTransaction::CreateObjectStore";
      case internal::kIDBTransaction_DeleteObjectStore_Name:
            return "Receive blink::mojom::IDBTransaction::DeleteObjectStore";
      case internal::kIDBTransaction_Put_Name:
            return "Receive blink::mojom::IDBTransaction::Put";
      case internal::kIDBTransaction_Commit_Name:
            return "Receive blink::mojom::IDBTransaction::Commit";
    }
  } else {
    switch (message.name()) {
      case internal::kIDBTransaction_CreateObjectStore_Name:
            return "Receive reply blink::mojom::IDBTransaction::CreateObjectStore";
      case internal::kIDBTransaction_DeleteObjectStore_Name:
            return "Receive reply blink::mojom::IDBTransaction::DeleteObjectStore";
      case internal::kIDBTransaction_Put_Name:
            return "Receive reply blink::mojom::IDBTransaction::Put";
      case internal::kIDBTransaction_Commit_Name:
            return "Receive reply blink::mojom::IDBTransaction::Commit";
    }
  }
  return "Receive unknown mojo message";
#else
  bool is_response = message.has_flag(mojo::Message::kFlagIsResponse);
  if (is_response) {
    return "Receive mojo reply";
  } else {
    return "Receive mojo message";
  }
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
}

#if !BUILDFLAG(IS_FUCHSIA)
uint32_t IDBTransaction::CreateObjectStore_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::IDBTransaction::CreateObjectStore");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t IDBTransaction::DeleteObjectStore_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::IDBTransaction::DeleteObjectStore");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t IDBTransaction::Put_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::IDBTransaction::Put");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t IDBTransaction::Commit_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::IDBTransaction::Commit");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
# endif // !BUILDFLAG(IS_FUCHSIA)

class IDBTransaction_Put_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  IDBTransaction_Put_ForwardToCallback(
      IDBTransaction::PutCallback callback
      ) : callback_(std::move(callback)) {
  }

  IDBTransaction_Put_ForwardToCallback(const IDBTransaction_Put_ForwardToCallback&) = delete;
  IDBTransaction_Put_ForwardToCallback& operator=(const IDBTransaction_Put_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  IDBTransaction::PutCallback callback_;
};

IDBTransactionProxy::IDBTransactionProxy(mojo::MessageReceiverWithResponder* receiver)
    : receiver_(receiver) {
}

void IDBTransactionProxy::CreateObjectStore(
    int64_t in_object_store_id, const ::WTF::String& in_name, const ::blink::IDBKeyPath& in_key_path, bool in_auto_increment) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::IDBTransaction::CreateObjectStore", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("object_store_id"), in_object_store_id,
                        "<value of type int64_t>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("name"), in_name,
                        "<value of type const ::WTF::String&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("key_path"), in_key_path,
                        "<value of type const ::blink::IDBKeyPath&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("auto_increment"), in_auto_increment,
                        "<value of type bool>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kIDBTransaction_CreateObjectStore_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::IDBTransaction_CreateObjectStore_Params_Data> params(
          message);
  params.Allocate();
  params->object_store_id = in_object_store_id;
  mojo::internal::MessageFragment<
      typename decltype(params->name)::BaseType> name_fragment(
          params.message());
  mojo::internal::Serialize<::mojo_base::mojom::String16DataView>(
      in_name, name_fragment);
  params->name.Set(
      name_fragment.is_null() ? nullptr : name_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->name.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null name in IDBTransaction.CreateObjectStore request");
  mojo::internal::MessageFragment<
      typename decltype(params->key_path)::BaseType> key_path_fragment(
          params.message());
  mojo::internal::Serialize<::blink::mojom::IDBKeyPathDataView>(
      in_key_path, key_path_fragment);
  params->key_path.Set(
      key_path_fragment.is_null() ? nullptr : key_path_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->key_path.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null key_path in IDBTransaction.CreateObjectStore request");
  params->auto_increment = in_auto_increment;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(IDBTransaction::Name_);
  message.set_method_name("CreateObjectStore");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void IDBTransactionProxy::DeleteObjectStore(
    int64_t in_object_store_id) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::IDBTransaction::DeleteObjectStore", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("object_store_id"), in_object_store_id,
                        "<value of type int64_t>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kIDBTransaction_DeleteObjectStore_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::IDBTransaction_DeleteObjectStore_Params_Data> params(
          message);
  params.Allocate();
  params->object_store_id = in_object_store_id;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(IDBTransaction::Name_);
  message.set_method_name("DeleteObjectStore");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void IDBTransactionProxy::Put(
    int64_t in_object_store_id, ::std::unique_ptr<::blink::IDBValue> in_value, ::std::unique_ptr<::blink::IDBKey> in_key, IDBPutMode in_mode, WTF::Vector<::blink::IDBIndexKeys> in_index_keys, PutCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::IDBTransaction::Put", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("object_store_id"), in_object_store_id,
                        "<value of type int64_t>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("value"), in_value,
                        "<value of type ::std::unique_ptr<::blink::IDBValue>>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("key"), in_key,
                        "<value of type ::std::unique_ptr<::blink::IDBKey>>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("mode"), in_mode,
                        "<value of type IDBPutMode>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("index_keys"), in_index_keys,
                        "<value of type WTF::Vector<::blink::IDBIndexKeys>>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kIDBTransaction_Put_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::IDBTransaction_Put_Params_Data> params(
          message);
  params.Allocate();
  params->object_store_id = in_object_store_id;
  mojo::internal::MessageFragment<
      typename decltype(params->value)::BaseType> value_fragment(
          params.message());
  mojo::internal::Serialize<::blink::mojom::IDBValueDataView>(
      in_value, value_fragment);
  params->value.Set(
      value_fragment.is_null() ? nullptr : value_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->value.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null value in IDBTransaction.Put request");
  mojo::internal::MessageFragment<decltype(params->key)>
      key_fragment(params.message());
  key_fragment.Claim(&params->key);
  mojo::internal::Serialize<::blink::mojom::IDBKeyDataView>(
      in_key, key_fragment, true);
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->key.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null key in IDBTransaction.Put request");
  mojo::internal::Serialize<::blink::mojom::IDBPutMode>(
      in_mode, &params->mode);
  mojo::internal::MessageFragment<
      typename decltype(params->index_keys)::BaseType>
      index_keys_fragment(params.message());
  const mojo::internal::ContainerValidateParams index_keys_validate_params(
      0, false, nullptr);
  mojo::internal::Serialize<mojo::ArrayDataView<::blink::mojom::IDBIndexKeysDataView>>(
      in_index_keys, index_keys_fragment, &index_keys_validate_params);
  params->index_keys.Set(
      index_keys_fragment.is_null() ? nullptr : index_keys_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->index_keys.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null index_keys in IDBTransaction.Put request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(IDBTransaction::Name_);
  message.set_method_name("Put");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new IDBTransaction_Put_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void IDBTransactionProxy::Commit(
    int64_t in_num_errors_handled) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::IDBTransaction::Commit", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("num_errors_handled"), in_num_errors_handled,
                        "<value of type int64_t>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kIDBTransaction_Commit_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::IDBTransaction_Commit_Params_Data> params(
          message);
  params.Allocate();
  params->num_errors_handled = in_num_errors_handled;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(IDBTransaction::Name_);
  message.set_method_name("Commit");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}
class IDBTransaction_Put_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static IDBTransaction::PutCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<IDBTransaction_Put_ProxyToResponder> proxy(
        new IDBTransaction_Put_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&IDBTransaction_Put_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~IDBTransaction_Put_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  IDBTransaction_Put_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "IDBTransaction::PutCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      IDBTransactionPutResultPtr in_result);
};

bool IDBTransaction_Put_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::IDBTransaction_Put_ResponseParams_Data* params =
      reinterpret_cast<
          internal::IDBTransaction_Put_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  IDBTransactionPutResultPtr p_result{};
  IDBTransaction_Put_ResponseParamsDataView input_data_view(params, message);
  
  if (success && !input_data_view.ReadResult(&p_result))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        IDBTransaction::Name_, 2, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_result));
  return true;
}

void IDBTransaction_Put_ProxyToResponder::Run(
    IDBTransactionPutResultPtr in_result) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send reply blink::mojom::IDBTransaction::Put", "async_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("result"), in_result,
                        "<value of type IDBTransactionPutResultPtr>");
   });
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kIDBTransaction_Put_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::IDBTransaction_Put_ResponseParams_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<decltype(params->result)>
      result_fragment(params.message());
  result_fragment.Claim(&params->result);
  mojo::internal::Serialize<::blink::mojom::IDBTransactionPutResultDataView>(
      in_result, result_fragment, true);
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->result.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null result in ");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(IDBTransaction::Name_);
  message.set_method_name("Put");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}

// static
bool IDBTransactionStubDispatch::Accept(
    IDBTransaction* impl,
    mojo::Message* message) {
  switch (message->header()->name) {
    case internal::kIDBTransaction_CreateObjectStore_Name: {

      DCHECK(message->is_serialized());
      internal::IDBTransaction_CreateObjectStore_Params_Data* params =
          reinterpret_cast<internal::IDBTransaction_CreateObjectStore_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      int64_t p_object_store_id{};
      ::WTF::String p_name{};
      ::blink::IDBKeyPath p_key_path{};
      bool p_auto_increment{};
      IDBTransaction_CreateObjectStore_ParamsDataView input_data_view(params, message);
      
      if (success)
        p_object_store_id = input_data_view.object_store_id();
      if (success && !input_data_view.ReadName(&p_name))
        success = false;
      if (success && !input_data_view.ReadKeyPath(&p_key_path))
        success = false;
      if (success)
        p_auto_increment = input_data_view.auto_increment();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            IDBTransaction::Name_, 0, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->CreateObjectStore(
std::move(p_object_store_id), 
std::move(p_name), 
std::move(p_key_path), 
std::move(p_auto_increment));
      return true;
    }
    case internal::kIDBTransaction_DeleteObjectStore_Name: {

      DCHECK(message->is_serialized());
      internal::IDBTransaction_DeleteObjectStore_Params_Data* params =
          reinterpret_cast<internal::IDBTransaction_DeleteObjectStore_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      int64_t p_object_store_id{};
      IDBTransaction_DeleteObjectStore_ParamsDataView input_data_view(params, message);
      
      if (success)
        p_object_store_id = input_data_view.object_store_id();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            IDBTransaction::Name_, 1, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->DeleteObjectStore(
std::move(p_object_store_id));
      return true;
    }
    case internal::kIDBTransaction_Put_Name: {
      break;
    }
    case internal::kIDBTransaction_Commit_Name: {

      DCHECK(message->is_serialized());
      internal::IDBTransaction_Commit_Params_Data* params =
          reinterpret_cast<internal::IDBTransaction_Commit_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      int64_t p_num_errors_handled{};
      IDBTransaction_Commit_ParamsDataView input_data_view(params, message);
      
      if (success)
        p_num_errors_handled = input_data_view.num_errors_handled();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            IDBTransaction::Name_, 3, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->Commit(
std::move(p_num_errors_handled));
      return true;
    }
  }
  return false;
}

// static
bool IDBTransactionStubDispatch::AcceptWithResponder(
    IDBTransaction* impl,
    mojo::Message* message,
    std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
  [[maybe_unused]] const bool message_is_sync =
      message->has_flag(mojo::Message::kFlagIsSync);
  [[maybe_unused]] const uint64_t request_id = message->request_id();
  switch (message->header()->name) {
    case internal::kIDBTransaction_CreateObjectStore_Name: {
      break;
    }
    case internal::kIDBTransaction_DeleteObjectStore_Name: {
      break;
    }
    case internal::kIDBTransaction_Put_Name: {

      internal::IDBTransaction_Put_Params_Data* params =
          reinterpret_cast<
              internal::IDBTransaction_Put_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      int64_t p_object_store_id{};
      ::std::unique_ptr<::blink::IDBValue> p_value{};
      ::std::unique_ptr<::blink::IDBKey> p_key{};
      IDBPutMode p_mode{};
      WTF::Vector<::blink::IDBIndexKeys> p_index_keys{};
      IDBTransaction_Put_ParamsDataView input_data_view(params, message);
      
      if (success)
        p_object_store_id = input_data_view.object_store_id();
      if (success && !input_data_view.ReadValue(&p_value))
        success = false;
      if (success && !input_data_view.ReadKey(&p_key))
        success = false;
      if (success && !input_data_view.ReadMode(&p_mode))
        success = false;
      if (success && !input_data_view.ReadIndexKeys(&p_index_keys))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            IDBTransaction::Name_, 2, false);
        return false;
      }
      IDBTransaction::PutCallback callback =
          IDBTransaction_Put_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->Put(
std::move(p_object_store_id), 
std::move(p_value), 
std::move(p_key), 
std::move(p_mode), 
std::move(p_index_keys), std::move(callback));
      return true;
    }
    case internal::kIDBTransaction_Commit_Name: {
      break;
    }
  }
  return false;
}


static const mojo::internal::GenericValidationInfo kIDBTransactionValidationInfo[] = {
    {&internal::IDBTransaction_CreateObjectStore_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::IDBTransaction_DeleteObjectStore_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::IDBTransaction_Put_Params_Data::Validate,
     &internal::IDBTransaction_Put_ResponseParams_Data::Validate},
    {&internal::IDBTransaction_Commit_Params_Data::Validate,
     nullptr /* no response */},
};

bool IDBTransactionRequestValidator::Accept(mojo::Message* message) {
  const char* name = ::blink::mojom::blink::IDBTransaction::Name_;
  return mojo::internal::ValidateRequestGenericPacked(message, name, kIDBTransactionValidationInfo);
}

bool IDBTransactionResponseValidator::Accept(mojo::Message* message) {
  const char* name = ::blink::mojom::blink::IDBTransaction::Name_;
  return mojo::internal::ValidateResponseGenericPacked(message, name, kIDBTransactionValidationInfo);
}
const char IDBDatabaseGetAllResultSink::Name_[] = "blink.mojom.IDBDatabaseGetAllResultSink";

IDBDatabaseGetAllResultSink::IPCStableHashFunction IDBDatabaseGetAllResultSink::MessageToMethodInfo_(mojo::Message& message) {
#if !BUILDFLAG(IS_FUCHSIA)
  switch (message.name()) {
    case internal::kIDBDatabaseGetAllResultSink_ReceiveValues_Name: {
      return &IDBDatabaseGetAllResultSink::ReceiveValues_Sym::IPCStableHash;
    }
    case internal::kIDBDatabaseGetAllResultSink_ReceiveKeys_Name: {
      return &IDBDatabaseGetAllResultSink::ReceiveKeys_Sym::IPCStableHash;
    }
    case internal::kIDBDatabaseGetAllResultSink_OnError_Name: {
      return &IDBDatabaseGetAllResultSink::OnError_Sym::IPCStableHash;
    }
  }
#endif  // !BUILDFLAG(IS_FUCHSIA)
  return nullptr;
}


const char* IDBDatabaseGetAllResultSink::MessageToMethodName_(mojo::Message& message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  bool is_response = message.has_flag(mojo::Message::kFlagIsResponse);
  if (!is_response) {
    switch (message.name()) {
      case internal::kIDBDatabaseGetAllResultSink_ReceiveValues_Name:
            return "Receive blink::mojom::IDBDatabaseGetAllResultSink::ReceiveValues";
      case internal::kIDBDatabaseGetAllResultSink_ReceiveKeys_Name:
            return "Receive blink::mojom::IDBDatabaseGetAllResultSink::ReceiveKeys";
      case internal::kIDBDatabaseGetAllResultSink_OnError_Name:
            return "Receive blink::mojom::IDBDatabaseGetAllResultSink::OnError";
    }
  } else {
    switch (message.name()) {
      case internal::kIDBDatabaseGetAllResultSink_ReceiveValues_Name:
            return "Receive reply blink::mojom::IDBDatabaseGetAllResultSink::ReceiveValues";
      case internal::kIDBDatabaseGetAllResultSink_ReceiveKeys_Name:
            return "Receive reply blink::mojom::IDBDatabaseGetAllResultSink::ReceiveKeys";
      case internal::kIDBDatabaseGetAllResultSink_OnError_Name:
            return "Receive reply blink::mojom::IDBDatabaseGetAllResultSink::OnError";
    }
  }
  return "Receive unknown mojo message";
#else
  bool is_response = message.has_flag(mojo::Message::kFlagIsResponse);
  if (is_response) {
    return "Receive mojo reply";
  } else {
    return "Receive mojo message";
  }
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
}

#if !BUILDFLAG(IS_FUCHSIA)
uint32_t IDBDatabaseGetAllResultSink::ReceiveValues_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::IDBDatabaseGetAllResultSink::ReceiveValues");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t IDBDatabaseGetAllResultSink::ReceiveKeys_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::IDBDatabaseGetAllResultSink::ReceiveKeys");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t IDBDatabaseGetAllResultSink::OnError_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::IDBDatabaseGetAllResultSink::OnError");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
# endif // !BUILDFLAG(IS_FUCHSIA)

IDBDatabaseGetAllResultSinkProxy::IDBDatabaseGetAllResultSinkProxy(mojo::MessageReceiverWithResponder* receiver)
    : receiver_(receiver) {
}

void IDBDatabaseGetAllResultSinkProxy::ReceiveValues(
    WTF::Vector<IDBReturnValuePtr> in_values) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::IDBDatabaseGetAllResultSink::ReceiveValues", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("values"), in_values,
                        "<value of type WTF::Vector<IDBReturnValuePtr>>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kIDBDatabaseGetAllResultSink_ReceiveValues_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::IDBDatabaseGetAllResultSink_ReceiveValues_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->values)::BaseType>
      values_fragment(params.message());
  const mojo::internal::ContainerValidateParams values_validate_params(
      0, false, nullptr);
  mojo::internal::Serialize<mojo::ArrayDataView<::blink::mojom::IDBReturnValueDataView>>(
      in_values, values_fragment, &values_validate_params);
  params->values.Set(
      values_fragment.is_null() ? nullptr : values_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->values.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null values in IDBDatabaseGetAllResultSink.ReceiveValues request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(IDBDatabaseGetAllResultSink::Name_);
  message.set_method_name("ReceiveValues");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void IDBDatabaseGetAllResultSinkProxy::ReceiveKeys(
    WTF::Vector<::std::unique_ptr<::blink::IDBKey>> in_keys) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::IDBDatabaseGetAllResultSink::ReceiveKeys", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("keys"), in_keys,
                        "<value of type WTF::Vector<::std::unique_ptr<::blink::IDBKey>>>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kIDBDatabaseGetAllResultSink_ReceiveKeys_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::IDBDatabaseGetAllResultSink_ReceiveKeys_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->keys)::BaseType>
      keys_fragment(params.message());
  const mojo::internal::ContainerValidateParams keys_validate_params(
      0, false, nullptr);
  mojo::internal::Serialize<mojo::ArrayDataView<::blink::mojom::IDBKeyDataView>>(
      in_keys, keys_fragment, &keys_validate_params);
  params->keys.Set(
      keys_fragment.is_null() ? nullptr : keys_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->keys.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null keys in IDBDatabaseGetAllResultSink.ReceiveKeys request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(IDBDatabaseGetAllResultSink::Name_);
  message.set_method_name("ReceiveKeys");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void IDBDatabaseGetAllResultSinkProxy::OnError(
    IDBErrorPtr in_error) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::IDBDatabaseGetAllResultSink::OnError", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("error"), in_error,
                        "<value of type IDBErrorPtr>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kIDBDatabaseGetAllResultSink_OnError_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::IDBDatabaseGetAllResultSink_OnError_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->error)::BaseType> error_fragment(
          params.message());
  mojo::internal::Serialize<::blink::mojom::IDBErrorDataView>(
      in_error, error_fragment);
  params->error.Set(
      error_fragment.is_null() ? nullptr : error_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->error.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null error in IDBDatabaseGetAllResultSink.OnError request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(IDBDatabaseGetAllResultSink::Name_);
  message.set_method_name("OnError");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

// static
bool IDBDatabaseGetAllResultSinkStubDispatch::Accept(
    IDBDatabaseGetAllResultSink* impl,
    mojo::Message* message) {
  switch (message->header()->name) {
    case internal::kIDBDatabaseGetAllResultSink_ReceiveValues_Name: {

      DCHECK(message->is_serialized());
      internal::IDBDatabaseGetAllResultSink_ReceiveValues_Params_Data* params =
          reinterpret_cast<internal::IDBDatabaseGetAllResultSink_ReceiveValues_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      WTF::Vector<IDBReturnValuePtr> p_values{};
      IDBDatabaseGetAllResultSink_ReceiveValues_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadValues(&p_values))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            IDBDatabaseGetAllResultSink::Name_, 0, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->ReceiveValues(
std::move(p_values));
      return true;
    }
    case internal::kIDBDatabaseGetAllResultSink_ReceiveKeys_Name: {

      DCHECK(message->is_serialized());
      internal::IDBDatabaseGetAllResultSink_ReceiveKeys_Params_Data* params =
          reinterpret_cast<internal::IDBDatabaseGetAllResultSink_ReceiveKeys_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      WTF::Vector<::std::unique_ptr<::blink::IDBKey>> p_keys{};
      IDBDatabaseGetAllResultSink_ReceiveKeys_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadKeys(&p_keys))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            IDBDatabaseGetAllResultSink::Name_, 1, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->ReceiveKeys(
std::move(p_keys));
      return true;
    }
    case internal::kIDBDatabaseGetAllResultSink_OnError_Name: {

      DCHECK(message->is_serialized());
      internal::IDBDatabaseGetAllResultSink_OnError_Params_Data* params =
          reinterpret_cast<internal::IDBDatabaseGetAllResultSink_OnError_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      IDBErrorPtr p_error{};
      IDBDatabaseGetAllResultSink_OnError_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadError(&p_error))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            IDBDatabaseGetAllResultSink::Name_, 2, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->OnError(
std::move(p_error));
      return true;
    }
  }
  return false;
}

// static
bool IDBDatabaseGetAllResultSinkStubDispatch::AcceptWithResponder(
    IDBDatabaseGetAllResultSink* impl,
    mojo::Message* message,
    std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
  [[maybe_unused]] const bool message_is_sync =
      message->has_flag(mojo::Message::kFlagIsSync);
  [[maybe_unused]] const uint64_t request_id = message->request_id();
  switch (message->header()->name) {
    case internal::kIDBDatabaseGetAllResultSink_ReceiveValues_Name: {
      break;
    }
    case internal::kIDBDatabaseGetAllResultSink_ReceiveKeys_Name: {
      break;
    }
    case internal::kIDBDatabaseGetAllResultSink_OnError_Name: {
      break;
    }
  }
  return false;
}


static const mojo::internal::GenericValidationInfo kIDBDatabaseGetAllResultSinkValidationInfo[] = {
    {&internal::IDBDatabaseGetAllResultSink_ReceiveValues_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::IDBDatabaseGetAllResultSink_ReceiveKeys_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::IDBDatabaseGetAllResultSink_OnError_Params_Data::Validate,
     nullptr /* no response */},
};

bool IDBDatabaseGetAllResultSinkRequestValidator::Accept(mojo::Message* message) {
  const char* name = ::blink::mojom::blink::IDBDatabaseGetAllResultSink::Name_;
  return mojo::internal::ValidateRequestGenericPacked(message, name, kIDBDatabaseGetAllResultSinkValidationInfo);
}

const char IDBDatabase::Name_[] = "blink.mojom.IDBDatabase";

IDBDatabase::IPCStableHashFunction IDBDatabase::MessageToMethodInfo_(mojo::Message& message) {
#if !BUILDFLAG(IS_FUCHSIA)
  switch (message.name()) {
    case internal::kIDBDatabase_RenameObjectStore_Name: {
      return &IDBDatabase::RenameObjectStore_Sym::IPCStableHash;
    }
    case internal::kIDBDatabase_CreateTransaction_Name: {
      return &IDBDatabase::CreateTransaction_Sym::IPCStableHash;
    }
    case internal::kIDBDatabase_Close_Name: {
      return &IDBDatabase::Close_Sym::IPCStableHash;
    }
    case internal::kIDBDatabase_VersionChangeIgnored_Name: {
      return &IDBDatabase::VersionChangeIgnored_Sym::IPCStableHash;
    }
    case internal::kIDBDatabase_BatchGetAll_Name: {
      return &IDBDatabase::BatchGetAll_Sym::IPCStableHash;
    }
    case internal::kIDBDatabase_Get_Name: {
      return &IDBDatabase::Get_Sym::IPCStableHash;
    }
    case internal::kIDBDatabase_GetAll_Name: {
      return &IDBDatabase::GetAll_Sym::IPCStableHash;
    }
    case internal::kIDBDatabase_SetIndexKeys_Name: {
      return &IDBDatabase::SetIndexKeys_Sym::IPCStableHash;
    }
    case internal::kIDBDatabase_SetIndexesReady_Name: {
      return &IDBDatabase::SetIndexesReady_Sym::IPCStableHash;
    }
    case internal::kIDBDatabase_OpenCursor_Name: {
      return &IDBDatabase::OpenCursor_Sym::IPCStableHash;
    }
    case internal::kIDBDatabase_Count_Name: {
      return &IDBDatabase::Count_Sym::IPCStableHash;
    }
    case internal::kIDBDatabase_DeleteRange_Name: {
      return &IDBDatabase::DeleteRange_Sym::IPCStableHash;
    }
    case internal::kIDBDatabase_GetKeyGeneratorCurrentNumber_Name: {
      return &IDBDatabase::GetKeyGeneratorCurrentNumber_Sym::IPCStableHash;
    }
    case internal::kIDBDatabase_Clear_Name: {
      return &IDBDatabase::Clear_Sym::IPCStableHash;
    }
    case internal::kIDBDatabase_CreateIndex_Name: {
      return &IDBDatabase::CreateIndex_Sym::IPCStableHash;
    }
    case internal::kIDBDatabase_DeleteIndex_Name: {
      return &IDBDatabase::DeleteIndex_Sym::IPCStableHash;
    }
    case internal::kIDBDatabase_RenameIndex_Name: {
      return &IDBDatabase::RenameIndex_Sym::IPCStableHash;
    }
    case internal::kIDBDatabase_Abort_Name: {
      return &IDBDatabase::Abort_Sym::IPCStableHash;
    }
  }
#endif  // !BUILDFLAG(IS_FUCHSIA)
  return nullptr;
}


const char* IDBDatabase::MessageToMethodName_(mojo::Message& message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  bool is_response = message.has_flag(mojo::Message::kFlagIsResponse);
  if (!is_response) {
    switch (message.name()) {
      case internal::kIDBDatabase_RenameObjectStore_Name:
            return "Receive blink::mojom::IDBDatabase::RenameObjectStore";
      case internal::kIDBDatabase_CreateTransaction_Name:
            return "Receive blink::mojom::IDBDatabase::CreateTransaction";
      case internal::kIDBDatabase_Close_Name:
            return "Receive blink::mojom::IDBDatabase::Close";
      case internal::kIDBDatabase_VersionChangeIgnored_Name:
            return "Receive blink::mojom::IDBDatabase::VersionChangeIgnored";
      case internal::kIDBDatabase_BatchGetAll_Name:
            return "Receive blink::mojom::IDBDatabase::BatchGetAll";
      case internal::kIDBDatabase_Get_Name:
            return "Receive blink::mojom::IDBDatabase::Get";
      case internal::kIDBDatabase_GetAll_Name:
            return "Receive blink::mojom::IDBDatabase::GetAll";
      case internal::kIDBDatabase_SetIndexKeys_Name:
            return "Receive blink::mojom::IDBDatabase::SetIndexKeys";
      case internal::kIDBDatabase_SetIndexesReady_Name:
            return "Receive blink::mojom::IDBDatabase::SetIndexesReady";
      case internal::kIDBDatabase_OpenCursor_Name:
            return "Receive blink::mojom::IDBDatabase::OpenCursor";
      case internal::kIDBDatabase_Count_Name:
            return "Receive blink::mojom::IDBDatabase::Count";
      case internal::kIDBDatabase_DeleteRange_Name:
            return "Receive blink::mojom::IDBDatabase::DeleteRange";
      case internal::kIDBDatabase_GetKeyGeneratorCurrentNumber_Name:
            return "Receive blink::mojom::IDBDatabase::GetKeyGeneratorCurrentNumber";
      case internal::kIDBDatabase_Clear_Name:
            return "Receive blink::mojom::IDBDatabase::Clear";
      case internal::kIDBDatabase_CreateIndex_Name:
            return "Receive blink::mojom::IDBDatabase::CreateIndex";
      case internal::kIDBDatabase_DeleteIndex_Name:
            return "Receive blink::mojom::IDBDatabase::DeleteIndex";
      case internal::kIDBDatabase_RenameIndex_Name:
            return "Receive blink::mojom::IDBDatabase::RenameIndex";
      case internal::kIDBDatabase_Abort_Name:
            return "Receive blink::mojom::IDBDatabase::Abort";
    }
  } else {
    switch (message.name()) {
      case internal::kIDBDatabase_RenameObjectStore_Name:
            return "Receive reply blink::mojom::IDBDatabase::RenameObjectStore";
      case internal::kIDBDatabase_CreateTransaction_Name:
            return "Receive reply blink::mojom::IDBDatabase::CreateTransaction";
      case internal::kIDBDatabase_Close_Name:
            return "Receive reply blink::mojom::IDBDatabase::Close";
      case internal::kIDBDatabase_VersionChangeIgnored_Name:
            return "Receive reply blink::mojom::IDBDatabase::VersionChangeIgnored";
      case internal::kIDBDatabase_BatchGetAll_Name:
            return "Receive reply blink::mojom::IDBDatabase::BatchGetAll";
      case internal::kIDBDatabase_Get_Name:
            return "Receive reply blink::mojom::IDBDatabase::Get";
      case internal::kIDBDatabase_GetAll_Name:
            return "Receive reply blink::mojom::IDBDatabase::GetAll";
      case internal::kIDBDatabase_SetIndexKeys_Name:
            return "Receive reply blink::mojom::IDBDatabase::SetIndexKeys";
      case internal::kIDBDatabase_SetIndexesReady_Name:
            return "Receive reply blink::mojom::IDBDatabase::SetIndexesReady";
      case internal::kIDBDatabase_OpenCursor_Name:
            return "Receive reply blink::mojom::IDBDatabase::OpenCursor";
      case internal::kIDBDatabase_Count_Name:
            return "Receive reply blink::mojom::IDBDatabase::Count";
      case internal::kIDBDatabase_DeleteRange_Name:
            return "Receive reply blink::mojom::IDBDatabase::DeleteRange";
      case internal::kIDBDatabase_GetKeyGeneratorCurrentNumber_Name:
            return "Receive reply blink::mojom::IDBDatabase::GetKeyGeneratorCurrentNumber";
      case internal::kIDBDatabase_Clear_Name:
            return "Receive reply blink::mojom::IDBDatabase::Clear";
      case internal::kIDBDatabase_CreateIndex_Name:
            return "Receive reply blink::mojom::IDBDatabase::CreateIndex";
      case internal::kIDBDatabase_DeleteIndex_Name:
            return "Receive reply blink::mojom::IDBDatabase::DeleteIndex";
      case internal::kIDBDatabase_RenameIndex_Name:
            return "Receive reply blink::mojom::IDBDatabase::RenameIndex";
      case internal::kIDBDatabase_Abort_Name:
            return "Receive reply blink::mojom::IDBDatabase::Abort";
    }
  }
  return "Receive unknown mojo message";
#else
  bool is_response = message.has_flag(mojo::Message::kFlagIsResponse);
  if (is_response) {
    return "Receive mojo reply";
  } else {
    return "Receive mojo message";
  }
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
}

#if !BUILDFLAG(IS_FUCHSIA)
uint32_t IDBDatabase::RenameObjectStore_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::IDBDatabase::RenameObjectStore");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t IDBDatabase::CreateTransaction_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::IDBDatabase::CreateTransaction");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t IDBDatabase::Close_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::IDBDatabase::Close");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t IDBDatabase::VersionChangeIgnored_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::IDBDatabase::VersionChangeIgnored");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t IDBDatabase::BatchGetAll_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::IDBDatabase::BatchGetAll");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t IDBDatabase::Get_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::IDBDatabase::Get");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t IDBDatabase::GetAll_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::IDBDatabase::GetAll");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t IDBDatabase::SetIndexKeys_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::IDBDatabase::SetIndexKeys");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t IDBDatabase::SetIndexesReady_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::IDBDatabase::SetIndexesReady");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t IDBDatabase::OpenCursor_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::IDBDatabase::OpenCursor");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t IDBDatabase::Count_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::IDBDatabase::Count");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t IDBDatabase::DeleteRange_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::IDBDatabase::DeleteRange");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t IDBDatabase::GetKeyGeneratorCurrentNumber_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::IDBDatabase::GetKeyGeneratorCurrentNumber");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t IDBDatabase::Clear_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::IDBDatabase::Clear");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t IDBDatabase::CreateIndex_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::IDBDatabase::CreateIndex");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t IDBDatabase::DeleteIndex_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::IDBDatabase::DeleteIndex");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t IDBDatabase::RenameIndex_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::IDBDatabase::RenameIndex");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t IDBDatabase::Abort_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::IDBDatabase::Abort");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
# endif // !BUILDFLAG(IS_FUCHSIA)

class IDBDatabase_BatchGetAll_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  IDBDatabase_BatchGetAll_ForwardToCallback(
      IDBDatabase::BatchGetAllCallback callback
      ) : callback_(std::move(callback)) {
  }

  IDBDatabase_BatchGetAll_ForwardToCallback(const IDBDatabase_BatchGetAll_ForwardToCallback&) = delete;
  IDBDatabase_BatchGetAll_ForwardToCallback& operator=(const IDBDatabase_BatchGetAll_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  IDBDatabase::BatchGetAllCallback callback_;
};

class IDBDatabase_Get_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  IDBDatabase_Get_ForwardToCallback(
      IDBDatabase::GetCallback callback
      ) : callback_(std::move(callback)) {
  }

  IDBDatabase_Get_ForwardToCallback(const IDBDatabase_Get_ForwardToCallback&) = delete;
  IDBDatabase_Get_ForwardToCallback& operator=(const IDBDatabase_Get_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  IDBDatabase::GetCallback callback_;
};

class IDBDatabase_GetAll_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  IDBDatabase_GetAll_ForwardToCallback(
      IDBDatabase::GetAllCallback callback
      ) : callback_(std::move(callback)) {
  }

  IDBDatabase_GetAll_ForwardToCallback(const IDBDatabase_GetAll_ForwardToCallback&) = delete;
  IDBDatabase_GetAll_ForwardToCallback& operator=(const IDBDatabase_GetAll_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  IDBDatabase::GetAllCallback callback_;
};

class IDBDatabase_OpenCursor_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  IDBDatabase_OpenCursor_ForwardToCallback(
      IDBDatabase::OpenCursorCallback callback
      ) : callback_(std::move(callback)) {
  }

  IDBDatabase_OpenCursor_ForwardToCallback(const IDBDatabase_OpenCursor_ForwardToCallback&) = delete;
  IDBDatabase_OpenCursor_ForwardToCallback& operator=(const IDBDatabase_OpenCursor_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  IDBDatabase::OpenCursorCallback callback_;
};

IDBDatabaseProxy::IDBDatabaseProxy(mojo::MessageReceiverWithResponder* receiver)
    : receiver_(receiver) {
}

void IDBDatabaseProxy::RenameObjectStore(
    int64_t in_transaction_id, int64_t in_object_store_id, const ::WTF::String& in_new_name) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::IDBDatabase::RenameObjectStore", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("transaction_id"), in_transaction_id,
                        "<value of type int64_t>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("object_store_id"), in_object_store_id,
                        "<value of type int64_t>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("new_name"), in_new_name,
                        "<value of type const ::WTF::String&>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kIDBDatabase_RenameObjectStore_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::IDBDatabase_RenameObjectStore_Params_Data> params(
          message);
  params.Allocate();
  params->transaction_id = in_transaction_id;
  params->object_store_id = in_object_store_id;
  mojo::internal::MessageFragment<
      typename decltype(params->new_name)::BaseType> new_name_fragment(
          params.message());
  mojo::internal::Serialize<::mojo_base::mojom::String16DataView>(
      in_new_name, new_name_fragment);
  params->new_name.Set(
      new_name_fragment.is_null() ? nullptr : new_name_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->new_name.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null new_name in IDBDatabase.RenameObjectStore request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(IDBDatabase::Name_);
  message.set_method_name("RenameObjectStore");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void IDBDatabaseProxy::CreateTransaction(
    ::mojo::PendingAssociatedReceiver<IDBTransaction> in_transaction_receiver, int64_t in_transaction_id, const WTF::Vector<int64_t>& in_object_store_ids, IDBTransactionMode in_mode, IDBTransactionDurability in_durability) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::IDBDatabase::CreateTransaction", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("transaction_receiver"), in_transaction_receiver,
                        "<value of type ::mojo::PendingAssociatedReceiver<IDBTransaction>>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("transaction_id"), in_transaction_id,
                        "<value of type int64_t>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("object_store_ids"), in_object_store_ids,
                        "<value of type const WTF::Vector<int64_t>&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("mode"), in_mode,
                        "<value of type IDBTransactionMode>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("durability"), in_durability,
                        "<value of type IDBTransactionDurability>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kIDBDatabase_CreateTransaction_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::IDBDatabase_CreateTransaction_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::Serialize<::blink::mojom::IDBTransactionAssociatedRequestDataView>(
      in_transaction_receiver, &params->transaction_receiver, &params.message());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      !mojo::internal::IsHandleOrInterfaceValid(params->transaction_receiver),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_INVALID_INTERFACE_ID,
      "invalid transaction_receiver in IDBDatabase.CreateTransaction request");
  params->transaction_id = in_transaction_id;
  mojo::internal::MessageFragment<
      typename decltype(params->object_store_ids)::BaseType>
      object_store_ids_fragment(params.message());
  const mojo::internal::ContainerValidateParams object_store_ids_validate_params(
      0, false, nullptr);
  mojo::internal::Serialize<mojo::ArrayDataView<int64_t>>(
      in_object_store_ids, object_store_ids_fragment, &object_store_ids_validate_params);
  params->object_store_ids.Set(
      object_store_ids_fragment.is_null() ? nullptr : object_store_ids_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->object_store_ids.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null object_store_ids in IDBDatabase.CreateTransaction request");
  mojo::internal::Serialize<::blink::mojom::IDBTransactionMode>(
      in_mode, &params->mode);
  mojo::internal::Serialize<::blink::mojom::IDBTransactionDurability>(
      in_durability, &params->durability);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(IDBDatabase::Name_);
  message.set_method_name("CreateTransaction");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void IDBDatabaseProxy::Close(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send blink::mojom::IDBDatabase::Close");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kIDBDatabase_Close_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::IDBDatabase_Close_Params_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(IDBDatabase::Name_);
  message.set_method_name("Close");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void IDBDatabaseProxy::VersionChangeIgnored(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send blink::mojom::IDBDatabase::VersionChangeIgnored");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kIDBDatabase_VersionChangeIgnored_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::IDBDatabase_VersionChangeIgnored_Params_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(IDBDatabase::Name_);
  message.set_method_name("VersionChangeIgnored");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void IDBDatabaseProxy::BatchGetAll(
    int64_t in_transaction_id, int64_t in_object_store_id, int64_t in_index_id, WTF::Vector<IDBKeyRangePtr> in_key_ranges, uint32_t in_max_count, BatchGetAllCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::IDBDatabase::BatchGetAll", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("transaction_id"), in_transaction_id,
                        "<value of type int64_t>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("object_store_id"), in_object_store_id,
                        "<value of type int64_t>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("index_id"), in_index_id,
                        "<value of type int64_t>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("key_ranges"), in_key_ranges,
                        "<value of type WTF::Vector<IDBKeyRangePtr>>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("max_count"), in_max_count,
                        "<value of type uint32_t>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kIDBDatabase_BatchGetAll_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::IDBDatabase_BatchGetAll_Params_Data> params(
          message);
  params.Allocate();
  params->transaction_id = in_transaction_id;
  params->object_store_id = in_object_store_id;
  params->index_id = in_index_id;
  mojo::internal::MessageFragment<
      typename decltype(params->key_ranges)::BaseType>
      key_ranges_fragment(params.message());
  const mojo::internal::ContainerValidateParams key_ranges_validate_params(
      0, false, nullptr);
  mojo::internal::Serialize<mojo::ArrayDataView<::blink::mojom::IDBKeyRangeDataView>>(
      in_key_ranges, key_ranges_fragment, &key_ranges_validate_params);
  params->key_ranges.Set(
      key_ranges_fragment.is_null() ? nullptr : key_ranges_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->key_ranges.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null key_ranges in IDBDatabase.BatchGetAll request");
  params->max_count = in_max_count;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(IDBDatabase::Name_);
  message.set_method_name("BatchGetAll");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new IDBDatabase_BatchGetAll_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void IDBDatabaseProxy::Get(
    int64_t in_transaction_id, int64_t in_object_store_id, int64_t in_index_id, IDBKeyRangePtr in_key_range, bool in_key_only, GetCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::IDBDatabase::Get", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("transaction_id"), in_transaction_id,
                        "<value of type int64_t>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("object_store_id"), in_object_store_id,
                        "<value of type int64_t>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("index_id"), in_index_id,
                        "<value of type int64_t>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("key_range"), in_key_range,
                        "<value of type IDBKeyRangePtr>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("key_only"), in_key_only,
                        "<value of type bool>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kIDBDatabase_Get_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::IDBDatabase_Get_Params_Data> params(
          message);
  params.Allocate();
  params->transaction_id = in_transaction_id;
  params->object_store_id = in_object_store_id;
  params->index_id = in_index_id;
  mojo::internal::MessageFragment<
      typename decltype(params->key_range)::BaseType> key_range_fragment(
          params.message());
  mojo::internal::Serialize<::blink::mojom::IDBKeyRangeDataView>(
      in_key_range, key_range_fragment);
  params->key_range.Set(
      key_range_fragment.is_null() ? nullptr : key_range_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->key_range.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null key_range in IDBDatabase.Get request");
  params->key_only = in_key_only;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(IDBDatabase::Name_);
  message.set_method_name("Get");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new IDBDatabase_Get_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void IDBDatabaseProxy::GetAll(
    int64_t in_transaction_id, int64_t in_object_store_id, int64_t in_index_id, IDBKeyRangePtr in_key_range, bool in_key_only, int64_t in_max_count, GetAllCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::IDBDatabase::GetAll", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("transaction_id"), in_transaction_id,
                        "<value of type int64_t>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("object_store_id"), in_object_store_id,
                        "<value of type int64_t>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("index_id"), in_index_id,
                        "<value of type int64_t>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("key_range"), in_key_range,
                        "<value of type IDBKeyRangePtr>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("key_only"), in_key_only,
                        "<value of type bool>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("max_count"), in_max_count,
                        "<value of type int64_t>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kIDBDatabase_GetAll_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::IDBDatabase_GetAll_Params_Data> params(
          message);
  params.Allocate();
  params->transaction_id = in_transaction_id;
  params->object_store_id = in_object_store_id;
  params->index_id = in_index_id;
  mojo::internal::MessageFragment<
      typename decltype(params->key_range)::BaseType> key_range_fragment(
          params.message());
  mojo::internal::Serialize<::blink::mojom::IDBKeyRangeDataView>(
      in_key_range, key_range_fragment);
  params->key_range.Set(
      key_range_fragment.is_null() ? nullptr : key_range_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->key_range.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null key_range in IDBDatabase.GetAll request");
  params->key_only = in_key_only;
  params->max_count = in_max_count;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(IDBDatabase::Name_);
  message.set_method_name("GetAll");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new IDBDatabase_GetAll_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void IDBDatabaseProxy::SetIndexKeys(
    int64_t in_transaction_id, int64_t in_object_store_id, ::std::unique_ptr<::blink::IDBKey> in_primary_key, WTF::Vector<::blink::IDBIndexKeys> in_index_keys) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::IDBDatabase::SetIndexKeys", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("transaction_id"), in_transaction_id,
                        "<value of type int64_t>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("object_store_id"), in_object_store_id,
                        "<value of type int64_t>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("primary_key"), in_primary_key,
                        "<value of type ::std::unique_ptr<::blink::IDBKey>>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("index_keys"), in_index_keys,
                        "<value of type WTF::Vector<::blink::IDBIndexKeys>>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kIDBDatabase_SetIndexKeys_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::IDBDatabase_SetIndexKeys_Params_Data> params(
          message);
  params.Allocate();
  params->transaction_id = in_transaction_id;
  params->object_store_id = in_object_store_id;
  mojo::internal::MessageFragment<decltype(params->primary_key)>
      primary_key_fragment(params.message());
  primary_key_fragment.Claim(&params->primary_key);
  mojo::internal::Serialize<::blink::mojom::IDBKeyDataView>(
      in_primary_key, primary_key_fragment, true);
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->primary_key.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null primary_key in IDBDatabase.SetIndexKeys request");
  mojo::internal::MessageFragment<
      typename decltype(params->index_keys)::BaseType>
      index_keys_fragment(params.message());
  const mojo::internal::ContainerValidateParams index_keys_validate_params(
      0, false, nullptr);
  mojo::internal::Serialize<mojo::ArrayDataView<::blink::mojom::IDBIndexKeysDataView>>(
      in_index_keys, index_keys_fragment, &index_keys_validate_params);
  params->index_keys.Set(
      index_keys_fragment.is_null() ? nullptr : index_keys_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->index_keys.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null index_keys in IDBDatabase.SetIndexKeys request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(IDBDatabase::Name_);
  message.set_method_name("SetIndexKeys");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void IDBDatabaseProxy::SetIndexesReady(
    int64_t in_transaction_id, int64_t in_object_store_id, const WTF::Vector<int64_t>& in_index_ids) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::IDBDatabase::SetIndexesReady", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("transaction_id"), in_transaction_id,
                        "<value of type int64_t>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("object_store_id"), in_object_store_id,
                        "<value of type int64_t>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("index_ids"), in_index_ids,
                        "<value of type const WTF::Vector<int64_t>&>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kIDBDatabase_SetIndexesReady_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::IDBDatabase_SetIndexesReady_Params_Data> params(
          message);
  params.Allocate();
  params->transaction_id = in_transaction_id;
  params->object_store_id = in_object_store_id;
  mojo::internal::MessageFragment<
      typename decltype(params->index_ids)::BaseType>
      index_ids_fragment(params.message());
  const mojo::internal::ContainerValidateParams index_ids_validate_params(
      0, false, nullptr);
  mojo::internal::Serialize<mojo::ArrayDataView<int64_t>>(
      in_index_ids, index_ids_fragment, &index_ids_validate_params);
  params->index_ids.Set(
      index_ids_fragment.is_null() ? nullptr : index_ids_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->index_ids.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null index_ids in IDBDatabase.SetIndexesReady request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(IDBDatabase::Name_);
  message.set_method_name("SetIndexesReady");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void IDBDatabaseProxy::OpenCursor(
    int64_t in_transaction_id, int64_t in_object_store_id, int64_t in_index_id, IDBKeyRangePtr in_key_range, IDBCursorDirection in_direction, bool in_key_only, IDBTaskType in_task_type, OpenCursorCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::IDBDatabase::OpenCursor", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("transaction_id"), in_transaction_id,
                        "<value of type int64_t>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("object_store_id"), in_object_store_id,
                        "<value of type int64_t>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("index_id"), in_index_id,
                        "<value of type int64_t>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("key_range"), in_key_range,
                        "<value of type IDBKeyRangePtr>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("direction"), in_direction,
                        "<value of type IDBCursorDirection>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("key_only"), in_key_only,
                        "<value of type bool>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("task_type"), in_task_type,
                        "<value of type IDBTaskType>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kIDBDatabase_OpenCursor_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::IDBDatabase_OpenCursor_Params_Data> params(
          message);
  params.Allocate();
  params->transaction_id = in_transaction_id;
  params->object_store_id = in_object_store_id;
  params->index_id = in_index_id;
  mojo::internal::MessageFragment<
      typename decltype(params->key_range)::BaseType> key_range_fragment(
          params.message());
  mojo::internal::Serialize<::blink::mojom::IDBKeyRangeDataView>(
      in_key_range, key_range_fragment);
  params->key_range.Set(
      key_range_fragment.is_null() ? nullptr : key_range_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->key_range.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null key_range in IDBDatabase.OpenCursor request");
  mojo::internal::Serialize<::blink::mojom::IDBCursorDirection>(
      in_direction, &params->direction);
  params->key_only = in_key_only;
  mojo::internal::Serialize<::blink::mojom::IDBTaskType>(
      in_task_type, &params->task_type);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(IDBDatabase::Name_);
  message.set_method_name("OpenCursor");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new IDBDatabase_OpenCursor_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void IDBDatabaseProxy::Count(
    int64_t in_transaction_id, int64_t in_object_store_id, int64_t in_index_id, IDBKeyRangePtr in_key_range, ::mojo::PendingAssociatedRemote<IDBCallbacks> in_pending_callbacks) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::IDBDatabase::Count", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("transaction_id"), in_transaction_id,
                        "<value of type int64_t>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("object_store_id"), in_object_store_id,
                        "<value of type int64_t>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("index_id"), in_index_id,
                        "<value of type int64_t>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("key_range"), in_key_range,
                        "<value of type IDBKeyRangePtr>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("pending_callbacks"), in_pending_callbacks,
                        "<value of type ::mojo::PendingAssociatedRemote<IDBCallbacks>>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kIDBDatabase_Count_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::IDBDatabase_Count_Params_Data> params(
          message);
  params.Allocate();
  params->transaction_id = in_transaction_id;
  params->object_store_id = in_object_store_id;
  params->index_id = in_index_id;
  mojo::internal::MessageFragment<
      typename decltype(params->key_range)::BaseType> key_range_fragment(
          params.message());
  mojo::internal::Serialize<::blink::mojom::IDBKeyRangeDataView>(
      in_key_range, key_range_fragment);
  params->key_range.Set(
      key_range_fragment.is_null() ? nullptr : key_range_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->key_range.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null key_range in IDBDatabase.Count request");
  mojo::internal::Serialize<::blink::mojom::IDBCallbacksAssociatedPtrInfoDataView>(
      in_pending_callbacks, &params->pending_callbacks, &params.message());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      !mojo::internal::IsHandleOrInterfaceValid(params->pending_callbacks),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_INVALID_INTERFACE_ID,
      "invalid pending_callbacks in IDBDatabase.Count request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(IDBDatabase::Name_);
  message.set_method_name("Count");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void IDBDatabaseProxy::DeleteRange(
    int64_t in_transaction_id, int64_t in_object_store_id, IDBKeyRangePtr in_key_range, ::mojo::PendingAssociatedRemote<IDBCallbacks> in_pending_callbacks) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::IDBDatabase::DeleteRange", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("transaction_id"), in_transaction_id,
                        "<value of type int64_t>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("object_store_id"), in_object_store_id,
                        "<value of type int64_t>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("key_range"), in_key_range,
                        "<value of type IDBKeyRangePtr>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("pending_callbacks"), in_pending_callbacks,
                        "<value of type ::mojo::PendingAssociatedRemote<IDBCallbacks>>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kIDBDatabase_DeleteRange_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::IDBDatabase_DeleteRange_Params_Data> params(
          message);
  params.Allocate();
  params->transaction_id = in_transaction_id;
  params->object_store_id = in_object_store_id;
  mojo::internal::MessageFragment<
      typename decltype(params->key_range)::BaseType> key_range_fragment(
          params.message());
  mojo::internal::Serialize<::blink::mojom::IDBKeyRangeDataView>(
      in_key_range, key_range_fragment);
  params->key_range.Set(
      key_range_fragment.is_null() ? nullptr : key_range_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->key_range.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null key_range in IDBDatabase.DeleteRange request");
  mojo::internal::Serialize<::blink::mojom::IDBCallbacksAssociatedPtrInfoDataView>(
      in_pending_callbacks, &params->pending_callbacks, &params.message());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      !mojo::internal::IsHandleOrInterfaceValid(params->pending_callbacks),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_INVALID_INTERFACE_ID,
      "invalid pending_callbacks in IDBDatabase.DeleteRange request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(IDBDatabase::Name_);
  message.set_method_name("DeleteRange");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void IDBDatabaseProxy::GetKeyGeneratorCurrentNumber(
    int64_t in_transaction_id, int64_t in_object_store_id, ::mojo::PendingAssociatedRemote<IDBCallbacks> in_pending_callbacks) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::IDBDatabase::GetKeyGeneratorCurrentNumber", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("transaction_id"), in_transaction_id,
                        "<value of type int64_t>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("object_store_id"), in_object_store_id,
                        "<value of type int64_t>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("pending_callbacks"), in_pending_callbacks,
                        "<value of type ::mojo::PendingAssociatedRemote<IDBCallbacks>>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kIDBDatabase_GetKeyGeneratorCurrentNumber_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::IDBDatabase_GetKeyGeneratorCurrentNumber_Params_Data> params(
          message);
  params.Allocate();
  params->transaction_id = in_transaction_id;
  params->object_store_id = in_object_store_id;
  mojo::internal::Serialize<::blink::mojom::IDBCallbacksAssociatedPtrInfoDataView>(
      in_pending_callbacks, &params->pending_callbacks, &params.message());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      !mojo::internal::IsHandleOrInterfaceValid(params->pending_callbacks),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_INVALID_INTERFACE_ID,
      "invalid pending_callbacks in IDBDatabase.GetKeyGeneratorCurrentNumber request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(IDBDatabase::Name_);
  message.set_method_name("GetKeyGeneratorCurrentNumber");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void IDBDatabaseProxy::Clear(
    int64_t in_transaction_id, int64_t in_object_store_id, ::mojo::PendingAssociatedRemote<IDBCallbacks> in_pending_callbacks) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::IDBDatabase::Clear", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("transaction_id"), in_transaction_id,
                        "<value of type int64_t>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("object_store_id"), in_object_store_id,
                        "<value of type int64_t>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("pending_callbacks"), in_pending_callbacks,
                        "<value of type ::mojo::PendingAssociatedRemote<IDBCallbacks>>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kIDBDatabase_Clear_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::IDBDatabase_Clear_Params_Data> params(
          message);
  params.Allocate();
  params->transaction_id = in_transaction_id;
  params->object_store_id = in_object_store_id;
  mojo::internal::Serialize<::blink::mojom::IDBCallbacksAssociatedPtrInfoDataView>(
      in_pending_callbacks, &params->pending_callbacks, &params.message());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      !mojo::internal::IsHandleOrInterfaceValid(params->pending_callbacks),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_INVALID_INTERFACE_ID,
      "invalid pending_callbacks in IDBDatabase.Clear request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(IDBDatabase::Name_);
  message.set_method_name("Clear");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void IDBDatabaseProxy::CreateIndex(
    int64_t in_transaction_id, int64_t in_object_store_id, int64_t in_index_id, const ::WTF::String& in_name, const ::blink::IDBKeyPath& in_key_path, bool in_unique, bool in_multi_entry) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::IDBDatabase::CreateIndex", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("transaction_id"), in_transaction_id,
                        "<value of type int64_t>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("object_store_id"), in_object_store_id,
                        "<value of type int64_t>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("index_id"), in_index_id,
                        "<value of type int64_t>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("name"), in_name,
                        "<value of type const ::WTF::String&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("key_path"), in_key_path,
                        "<value of type const ::blink::IDBKeyPath&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("unique"), in_unique,
                        "<value of type bool>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("multi_entry"), in_multi_entry,
                        "<value of type bool>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kIDBDatabase_CreateIndex_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::IDBDatabase_CreateIndex_Params_Data> params(
          message);
  params.Allocate();
  params->transaction_id = in_transaction_id;
  params->object_store_id = in_object_store_id;
  params->index_id = in_index_id;
  mojo::internal::MessageFragment<
      typename decltype(params->name)::BaseType> name_fragment(
          params.message());
  mojo::internal::Serialize<::mojo_base::mojom::String16DataView>(
      in_name, name_fragment);
  params->name.Set(
      name_fragment.is_null() ? nullptr : name_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->name.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null name in IDBDatabase.CreateIndex request");
  mojo::internal::MessageFragment<
      typename decltype(params->key_path)::BaseType> key_path_fragment(
          params.message());
  mojo::internal::Serialize<::blink::mojom::IDBKeyPathDataView>(
      in_key_path, key_path_fragment);
  params->key_path.Set(
      key_path_fragment.is_null() ? nullptr : key_path_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->key_path.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null key_path in IDBDatabase.CreateIndex request");
  params->unique = in_unique;
  params->multi_entry = in_multi_entry;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(IDBDatabase::Name_);
  message.set_method_name("CreateIndex");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void IDBDatabaseProxy::DeleteIndex(
    int64_t in_transaction_id, int64_t in_object_store_id, int64_t in_index_id) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::IDBDatabase::DeleteIndex", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("transaction_id"), in_transaction_id,
                        "<value of type int64_t>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("object_store_id"), in_object_store_id,
                        "<value of type int64_t>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("index_id"), in_index_id,
                        "<value of type int64_t>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kIDBDatabase_DeleteIndex_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::IDBDatabase_DeleteIndex_Params_Data> params(
          message);
  params.Allocate();
  params->transaction_id = in_transaction_id;
  params->object_store_id = in_object_store_id;
  params->index_id = in_index_id;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(IDBDatabase::Name_);
  message.set_method_name("DeleteIndex");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void IDBDatabaseProxy::RenameIndex(
    int64_t in_transaction_id, int64_t in_object_store_id, int64_t in_index_id, const ::WTF::String& in_new_name) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::IDBDatabase::RenameIndex", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("transaction_id"), in_transaction_id,
                        "<value of type int64_t>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("object_store_id"), in_object_store_id,
                        "<value of type int64_t>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("index_id"), in_index_id,
                        "<value of type int64_t>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("new_name"), in_new_name,
                        "<value of type const ::WTF::String&>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kIDBDatabase_RenameIndex_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::IDBDatabase_RenameIndex_Params_Data> params(
          message);
  params.Allocate();
  params->transaction_id = in_transaction_id;
  params->object_store_id = in_object_store_id;
  params->index_id = in_index_id;
  mojo::internal::MessageFragment<
      typename decltype(params->new_name)::BaseType> new_name_fragment(
          params.message());
  mojo::internal::Serialize<::mojo_base::mojom::String16DataView>(
      in_new_name, new_name_fragment);
  params->new_name.Set(
      new_name_fragment.is_null() ? nullptr : new_name_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->new_name.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null new_name in IDBDatabase.RenameIndex request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(IDBDatabase::Name_);
  message.set_method_name("RenameIndex");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void IDBDatabaseProxy::Abort(
    int64_t in_transaction_id) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::IDBDatabase::Abort", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("transaction_id"), in_transaction_id,
                        "<value of type int64_t>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kIDBDatabase_Abort_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::IDBDatabase_Abort_Params_Data> params(
          message);
  params.Allocate();
  params->transaction_id = in_transaction_id;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(IDBDatabase::Name_);
  message.set_method_name("Abort");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}
class IDBDatabase_BatchGetAll_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static IDBDatabase::BatchGetAllCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<IDBDatabase_BatchGetAll_ProxyToResponder> proxy(
        new IDBDatabase_BatchGetAll_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&IDBDatabase_BatchGetAll_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~IDBDatabase_BatchGetAll_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  IDBDatabase_BatchGetAll_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "IDBDatabase::BatchGetAllCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      IDBDatabaseBatchGetAllResultPtr in_result);
};

bool IDBDatabase_BatchGetAll_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::IDBDatabase_BatchGetAll_ResponseParams_Data* params =
      reinterpret_cast<
          internal::IDBDatabase_BatchGetAll_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  IDBDatabaseBatchGetAllResultPtr p_result{};
  IDBDatabase_BatchGetAll_ResponseParamsDataView input_data_view(params, message);
  
  if (success && !input_data_view.ReadResult(&p_result))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        IDBDatabase::Name_, 4, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_result));
  return true;
}

void IDBDatabase_BatchGetAll_ProxyToResponder::Run(
    IDBDatabaseBatchGetAllResultPtr in_result) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send reply blink::mojom::IDBDatabase::BatchGetAll", "async_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("result"), in_result,
                        "<value of type IDBDatabaseBatchGetAllResultPtr>");
   });
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kIDBDatabase_BatchGetAll_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::IDBDatabase_BatchGetAll_ResponseParams_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<decltype(params->result)>
      result_fragment(params.message());
  result_fragment.Claim(&params->result);
  mojo::internal::Serialize<::blink::mojom::IDBDatabaseBatchGetAllResultDataView>(
      in_result, result_fragment, true);
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->result.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null result in ");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(IDBDatabase::Name_);
  message.set_method_name("BatchGetAll");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class IDBDatabase_Get_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static IDBDatabase::GetCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<IDBDatabase_Get_ProxyToResponder> proxy(
        new IDBDatabase_Get_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&IDBDatabase_Get_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~IDBDatabase_Get_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  IDBDatabase_Get_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "IDBDatabase::GetCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      IDBDatabaseGetResultPtr in_result);
};

bool IDBDatabase_Get_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::IDBDatabase_Get_ResponseParams_Data* params =
      reinterpret_cast<
          internal::IDBDatabase_Get_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  IDBDatabaseGetResultPtr p_result{};
  IDBDatabase_Get_ResponseParamsDataView input_data_view(params, message);
  
  if (success && !input_data_view.ReadResult(&p_result))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        IDBDatabase::Name_, 5, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_result));
  return true;
}

void IDBDatabase_Get_ProxyToResponder::Run(
    IDBDatabaseGetResultPtr in_result) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send reply blink::mojom::IDBDatabase::Get", "async_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("result"), in_result,
                        "<value of type IDBDatabaseGetResultPtr>");
   });
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kIDBDatabase_Get_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::IDBDatabase_Get_ResponseParams_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<decltype(params->result)>
      result_fragment(params.message());
  result_fragment.Claim(&params->result);
  mojo::internal::Serialize<::blink::mojom::IDBDatabaseGetResultDataView>(
      in_result, result_fragment, true);
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->result.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null result in ");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(IDBDatabase::Name_);
  message.set_method_name("Get");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class IDBDatabase_GetAll_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static IDBDatabase::GetAllCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<IDBDatabase_GetAll_ProxyToResponder> proxy(
        new IDBDatabase_GetAll_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&IDBDatabase_GetAll_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~IDBDatabase_GetAll_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  IDBDatabase_GetAll_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "IDBDatabase::GetAllCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      ::mojo::PendingReceiver<IDBDatabaseGetAllResultSink> in_receiver);
};

bool IDBDatabase_GetAll_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::IDBDatabase_GetAll_ResponseParams_Data* params =
      reinterpret_cast<
          internal::IDBDatabase_GetAll_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  ::mojo::PendingReceiver<IDBDatabaseGetAllResultSink> p_receiver{};
  IDBDatabase_GetAll_ResponseParamsDataView input_data_view(params, message);
  
  if (success) {
    p_receiver =
        input_data_view.TakeReceiver<decltype(p_receiver)>();
  }
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        IDBDatabase::Name_, 6, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_receiver));
  return true;
}

void IDBDatabase_GetAll_ProxyToResponder::Run(
    ::mojo::PendingReceiver<IDBDatabaseGetAllResultSink> in_receiver) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send reply blink::mojom::IDBDatabase::GetAll", "async_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("receiver"), in_receiver,
                        "<value of type ::mojo::PendingReceiver<IDBDatabaseGetAllResultSink>>");
   });
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kIDBDatabase_GetAll_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::IDBDatabase_GetAll_ResponseParams_Data> params(
          message);
  params.Allocate();
  mojo::internal::Serialize<mojo::InterfaceRequestDataView<::blink::mojom::IDBDatabaseGetAllResultSinkInterfaceBase>>(
      in_receiver, &params->receiver, &params.message());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      !mojo::internal::IsHandleOrInterfaceValid(params->receiver),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_INVALID_HANDLE,
      "invalid receiver in ");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(IDBDatabase::Name_);
  message.set_method_name("GetAll");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class IDBDatabase_OpenCursor_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static IDBDatabase::OpenCursorCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<IDBDatabase_OpenCursor_ProxyToResponder> proxy(
        new IDBDatabase_OpenCursor_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&IDBDatabase_OpenCursor_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~IDBDatabase_OpenCursor_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  IDBDatabase_OpenCursor_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "IDBDatabase::OpenCursorCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      IDBDatabaseOpenCursorResultPtr in_result);
};

bool IDBDatabase_OpenCursor_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::IDBDatabase_OpenCursor_ResponseParams_Data* params =
      reinterpret_cast<
          internal::IDBDatabase_OpenCursor_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  IDBDatabaseOpenCursorResultPtr p_result{};
  IDBDatabase_OpenCursor_ResponseParamsDataView input_data_view(params, message);
  
  if (success && !input_data_view.ReadResult(&p_result))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        IDBDatabase::Name_, 9, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_result));
  return true;
}

void IDBDatabase_OpenCursor_ProxyToResponder::Run(
    IDBDatabaseOpenCursorResultPtr in_result) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send reply blink::mojom::IDBDatabase::OpenCursor", "async_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("result"), in_result,
                        "<value of type IDBDatabaseOpenCursorResultPtr>");
   });
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kIDBDatabase_OpenCursor_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::IDBDatabase_OpenCursor_ResponseParams_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<decltype(params->result)>
      result_fragment(params.message());
  result_fragment.Claim(&params->result);
  mojo::internal::Serialize<::blink::mojom::IDBDatabaseOpenCursorResultDataView>(
      in_result, result_fragment, true);
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->result.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null result in ");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(IDBDatabase::Name_);
  message.set_method_name("OpenCursor");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}

// static
bool IDBDatabaseStubDispatch::Accept(
    IDBDatabase* impl,
    mojo::Message* message) {
  switch (message->header()->name) {
    case internal::kIDBDatabase_RenameObjectStore_Name: {

      DCHECK(message->is_serialized());
      internal::IDBDatabase_RenameObjectStore_Params_Data* params =
          reinterpret_cast<internal::IDBDatabase_RenameObjectStore_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      int64_t p_transaction_id{};
      int64_t p_object_store_id{};
      ::WTF::String p_new_name{};
      IDBDatabase_RenameObjectStore_ParamsDataView input_data_view(params, message);
      
      if (success)
        p_transaction_id = input_data_view.transaction_id();
      if (success)
        p_object_store_id = input_data_view.object_store_id();
      if (success && !input_data_view.ReadNewName(&p_new_name))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            IDBDatabase::Name_, 0, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->RenameObjectStore(
std::move(p_transaction_id), 
std::move(p_object_store_id), 
std::move(p_new_name));
      return true;
    }
    case internal::kIDBDatabase_CreateTransaction_Name: {

      DCHECK(message->is_serialized());
      internal::IDBDatabase_CreateTransaction_Params_Data* params =
          reinterpret_cast<internal::IDBDatabase_CreateTransaction_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::mojo::PendingAssociatedReceiver<IDBTransaction> p_transaction_receiver{};
      int64_t p_transaction_id{};
      WTF::Vector<int64_t> p_object_store_ids{};
      IDBTransactionMode p_mode{};
      IDBTransactionDurability p_durability{};
      IDBDatabase_CreateTransaction_ParamsDataView input_data_view(params, message);
      
      if (success) {
        p_transaction_receiver =
            input_data_view.TakeTransactionReceiver<decltype(p_transaction_receiver)>();
      }
      if (success)
        p_transaction_id = input_data_view.transaction_id();
      if (success && !input_data_view.ReadObjectStoreIds(&p_object_store_ids))
        success = false;
      if (success && !input_data_view.ReadMode(&p_mode))
        success = false;
      if (success && !input_data_view.ReadDurability(&p_durability))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            IDBDatabase::Name_, 1, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->CreateTransaction(
std::move(p_transaction_receiver), 
std::move(p_transaction_id), 
std::move(p_object_store_ids), 
std::move(p_mode), 
std::move(p_durability));
      return true;
    }
    case internal::kIDBDatabase_Close_Name: {

      DCHECK(message->is_serialized());
      internal::IDBDatabase_Close_Params_Data* params =
          reinterpret_cast<internal::IDBDatabase_Close_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      IDBDatabase_Close_ParamsDataView input_data_view(params, message);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            IDBDatabase::Name_, 2, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->Close();
      return true;
    }
    case internal::kIDBDatabase_VersionChangeIgnored_Name: {

      DCHECK(message->is_serialized());
      internal::IDBDatabase_VersionChangeIgnored_Params_Data* params =
          reinterpret_cast<internal::IDBDatabase_VersionChangeIgnored_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      IDBDatabase_VersionChangeIgnored_ParamsDataView input_data_view(params, message);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            IDBDatabase::Name_, 3, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->VersionChangeIgnored();
      return true;
    }
    case internal::kIDBDatabase_BatchGetAll_Name: {
      break;
    }
    case internal::kIDBDatabase_Get_Name: {
      break;
    }
    case internal::kIDBDatabase_GetAll_Name: {
      break;
    }
    case internal::kIDBDatabase_SetIndexKeys_Name: {

      DCHECK(message->is_serialized());
      internal::IDBDatabase_SetIndexKeys_Params_Data* params =
          reinterpret_cast<internal::IDBDatabase_SetIndexKeys_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      int64_t p_transaction_id{};
      int64_t p_object_store_id{};
      ::std::unique_ptr<::blink::IDBKey> p_primary_key{};
      WTF::Vector<::blink::IDBIndexKeys> p_index_keys{};
      IDBDatabase_SetIndexKeys_ParamsDataView input_data_view(params, message);
      
      if (success)
        p_transaction_id = input_data_view.transaction_id();
      if (success)
        p_object_store_id = input_data_view.object_store_id();
      if (success && !input_data_view.ReadPrimaryKey(&p_primary_key))
        success = false;
      if (success && !input_data_view.ReadIndexKeys(&p_index_keys))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            IDBDatabase::Name_, 7, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SetIndexKeys(
std::move(p_transaction_id), 
std::move(p_object_store_id), 
std::move(p_primary_key), 
std::move(p_index_keys));
      return true;
    }
    case internal::kIDBDatabase_SetIndexesReady_Name: {

      DCHECK(message->is_serialized());
      internal::IDBDatabase_SetIndexesReady_Params_Data* params =
          reinterpret_cast<internal::IDBDatabase_SetIndexesReady_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      int64_t p_transaction_id{};
      int64_t p_object_store_id{};
      WTF::Vector<int64_t> p_index_ids{};
      IDBDatabase_SetIndexesReady_ParamsDataView input_data_view(params, message);
      
      if (success)
        p_transaction_id = input_data_view.transaction_id();
      if (success)
        p_object_store_id = input_data_view.object_store_id();
      if (success && !input_data_view.ReadIndexIds(&p_index_ids))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            IDBDatabase::Name_, 8, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SetIndexesReady(
std::move(p_transaction_id), 
std::move(p_object_store_id), 
std::move(p_index_ids));
      return true;
    }
    case internal::kIDBDatabase_OpenCursor_Name: {
      break;
    }
    case internal::kIDBDatabase_Count_Name: {

      DCHECK(message->is_serialized());
      internal::IDBDatabase_Count_Params_Data* params =
          reinterpret_cast<internal::IDBDatabase_Count_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      int64_t p_transaction_id{};
      int64_t p_object_store_id{};
      int64_t p_index_id{};
      IDBKeyRangePtr p_key_range{};
      ::mojo::PendingAssociatedRemote<IDBCallbacks> p_pending_callbacks{};
      IDBDatabase_Count_ParamsDataView input_data_view(params, message);
      
      if (success)
        p_transaction_id = input_data_view.transaction_id();
      if (success)
        p_object_store_id = input_data_view.object_store_id();
      if (success)
        p_index_id = input_data_view.index_id();
      if (success && !input_data_view.ReadKeyRange(&p_key_range))
        success = false;
      if (success) {
        p_pending_callbacks =
            input_data_view.TakePendingCallbacks<decltype(p_pending_callbacks)>();
      }
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            IDBDatabase::Name_, 10, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->Count(
std::move(p_transaction_id), 
std::move(p_object_store_id), 
std::move(p_index_id), 
std::move(p_key_range), 
std::move(p_pending_callbacks));
      return true;
    }
    case internal::kIDBDatabase_DeleteRange_Name: {

      DCHECK(message->is_serialized());
      internal::IDBDatabase_DeleteRange_Params_Data* params =
          reinterpret_cast<internal::IDBDatabase_DeleteRange_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      int64_t p_transaction_id{};
      int64_t p_object_store_id{};
      IDBKeyRangePtr p_key_range{};
      ::mojo::PendingAssociatedRemote<IDBCallbacks> p_pending_callbacks{};
      IDBDatabase_DeleteRange_ParamsDataView input_data_view(params, message);
      
      if (success)
        p_transaction_id = input_data_view.transaction_id();
      if (success)
        p_object_store_id = input_data_view.object_store_id();
      if (success && !input_data_view.ReadKeyRange(&p_key_range))
        success = false;
      if (success) {
        p_pending_callbacks =
            input_data_view.TakePendingCallbacks<decltype(p_pending_callbacks)>();
      }
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            IDBDatabase::Name_, 11, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->DeleteRange(
std::move(p_transaction_id), 
std::move(p_object_store_id), 
std::move(p_key_range), 
std::move(p_pending_callbacks));
      return true;
    }
    case internal::kIDBDatabase_GetKeyGeneratorCurrentNumber_Name: {

      DCHECK(message->is_serialized());
      internal::IDBDatabase_GetKeyGeneratorCurrentNumber_Params_Data* params =
          reinterpret_cast<internal::IDBDatabase_GetKeyGeneratorCurrentNumber_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      int64_t p_transaction_id{};
      int64_t p_object_store_id{};
      ::mojo::PendingAssociatedRemote<IDBCallbacks> p_pending_callbacks{};
      IDBDatabase_GetKeyGeneratorCurrentNumber_ParamsDataView input_data_view(params, message);
      
      if (success)
        p_transaction_id = input_data_view.transaction_id();
      if (success)
        p_object_store_id = input_data_view.object_store_id();
      if (success) {
        p_pending_callbacks =
            input_data_view.TakePendingCallbacks<decltype(p_pending_callbacks)>();
      }
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            IDBDatabase::Name_, 12, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->GetKeyGeneratorCurrentNumber(
std::move(p_transaction_id), 
std::move(p_object_store_id), 
std::move(p_pending_callbacks));
      return true;
    }
    case internal::kIDBDatabase_Clear_Name: {

      DCHECK(message->is_serialized());
      internal::IDBDatabase_Clear_Params_Data* params =
          reinterpret_cast<internal::IDBDatabase_Clear_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      int64_t p_transaction_id{};
      int64_t p_object_store_id{};
      ::mojo::PendingAssociatedRemote<IDBCallbacks> p_pending_callbacks{};
      IDBDatabase_Clear_ParamsDataView input_data_view(params, message);
      
      if (success)
        p_transaction_id = input_data_view.transaction_id();
      if (success)
        p_object_store_id = input_data_view.object_store_id();
      if (success) {
        p_pending_callbacks =
            input_data_view.TakePendingCallbacks<decltype(p_pending_callbacks)>();
      }
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            IDBDatabase::Name_, 13, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->Clear(
std::move(p_transaction_id), 
std::move(p_object_store_id), 
std::move(p_pending_callbacks));
      return true;
    }
    case internal::kIDBDatabase_CreateIndex_Name: {

      DCHECK(message->is_serialized());
      internal::IDBDatabase_CreateIndex_Params_Data* params =
          reinterpret_cast<internal::IDBDatabase_CreateIndex_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      int64_t p_transaction_id{};
      int64_t p_object_store_id{};
      int64_t p_index_id{};
      ::WTF::String p_name{};
      ::blink::IDBKeyPath p_key_path{};
      bool p_unique{};
      bool p_multi_entry{};
      IDBDatabase_CreateIndex_ParamsDataView input_data_view(params, message);
      
      if (success)
        p_transaction_id = input_data_view.transaction_id();
      if (success)
        p_object_store_id = input_data_view.object_store_id();
      if (success)
        p_index_id = input_data_view.index_id();
      if (success && !input_data_view.ReadName(&p_name))
        success = false;
      if (success && !input_data_view.ReadKeyPath(&p_key_path))
        success = false;
      if (success)
        p_unique = input_data_view.unique();
      if (success)
        p_multi_entry = input_data_view.multi_entry();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            IDBDatabase::Name_, 14, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->CreateIndex(
std::move(p_transaction_id), 
std::move(p_object_store_id), 
std::move(p_index_id), 
std::move(p_name), 
std::move(p_key_path), 
std::move(p_unique), 
std::move(p_multi_entry));
      return true;
    }
    case internal::kIDBDatabase_DeleteIndex_Name: {

      DCHECK(message->is_serialized());
      internal::IDBDatabase_DeleteIndex_Params_Data* params =
          reinterpret_cast<internal::IDBDatabase_DeleteIndex_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      int64_t p_transaction_id{};
      int64_t p_object_store_id{};
      int64_t p_index_id{};
      IDBDatabase_DeleteIndex_ParamsDataView input_data_view(params, message);
      
      if (success)
        p_transaction_id = input_data_view.transaction_id();
      if (success)
        p_object_store_id = input_data_view.object_store_id();
      if (success)
        p_index_id = input_data_view.index_id();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            IDBDatabase::Name_, 15, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->DeleteIndex(
std::move(p_transaction_id), 
std::move(p_object_store_id), 
std::move(p_index_id));
      return true;
    }
    case internal::kIDBDatabase_RenameIndex_Name: {

      DCHECK(message->is_serialized());
      internal::IDBDatabase_RenameIndex_Params_Data* params =
          reinterpret_cast<internal::IDBDatabase_RenameIndex_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      int64_t p_transaction_id{};
      int64_t p_object_store_id{};
      int64_t p_index_id{};
      ::WTF::String p_new_name{};
      IDBDatabase_RenameIndex_ParamsDataView input_data_view(params, message);
      
      if (success)
        p_transaction_id = input_data_view.transaction_id();
      if (success)
        p_object_store_id = input_data_view.object_store_id();
      if (success)
        p_index_id = input_data_view.index_id();
      if (success && !input_data_view.ReadNewName(&p_new_name))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            IDBDatabase::Name_, 16, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->RenameIndex(
std::move(p_transaction_id), 
std::move(p_object_store_id), 
std::move(p_index_id), 
std::move(p_new_name));
      return true;
    }
    case internal::kIDBDatabase_Abort_Name: {

      DCHECK(message->is_serialized());
      internal::IDBDatabase_Abort_Params_Data* params =
          reinterpret_cast<internal::IDBDatabase_Abort_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      int64_t p_transaction_id{};
      IDBDatabase_Abort_ParamsDataView input_data_view(params, message);
      
      if (success)
        p_transaction_id = input_data_view.transaction_id();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            IDBDatabase::Name_, 17, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->Abort(
std::move(p_transaction_id));
      return true;
    }
  }
  return false;
}

// static
bool IDBDatabaseStubDispatch::AcceptWithResponder(
    IDBDatabase* impl,
    mojo::Message* message,
    std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
  [[maybe_unused]] const bool message_is_sync =
      message->has_flag(mojo::Message::kFlagIsSync);
  [[maybe_unused]] const uint64_t request_id = message->request_id();
  switch (message->header()->name) {
    case internal::kIDBDatabase_RenameObjectStore_Name: {
      break;
    }
    case internal::kIDBDatabase_CreateTransaction_Name: {
      break;
    }
    case internal::kIDBDatabase_Close_Name: {
      break;
    }
    case internal::kIDBDatabase_VersionChangeIgnored_Name: {
      break;
    }
    case internal::kIDBDatabase_BatchGetAll_Name: {

      internal::IDBDatabase_BatchGetAll_Params_Data* params =
          reinterpret_cast<
              internal::IDBDatabase_BatchGetAll_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      int64_t p_transaction_id{};
      int64_t p_object_store_id{};
      int64_t p_index_id{};
      WTF::Vector<IDBKeyRangePtr> p_key_ranges{};
      uint32_t p_max_count{};
      IDBDatabase_BatchGetAll_ParamsDataView input_data_view(params, message);
      
      if (success)
        p_transaction_id = input_data_view.transaction_id();
      if (success)
        p_object_store_id = input_data_view.object_store_id();
      if (success)
        p_index_id = input_data_view.index_id();
      if (success && !input_data_view.ReadKeyRanges(&p_key_ranges))
        success = false;
      if (success)
        p_max_count = input_data_view.max_count();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            IDBDatabase::Name_, 4, false);
        return false;
      }
      IDBDatabase::BatchGetAllCallback callback =
          IDBDatabase_BatchGetAll_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->BatchGetAll(
std::move(p_transaction_id), 
std::move(p_object_store_id), 
std::move(p_index_id), 
std::move(p_key_ranges), 
std::move(p_max_count), std::move(callback));
      return true;
    }
    case internal::kIDBDatabase_Get_Name: {

      internal::IDBDatabase_Get_Params_Data* params =
          reinterpret_cast<
              internal::IDBDatabase_Get_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      int64_t p_transaction_id{};
      int64_t p_object_store_id{};
      int64_t p_index_id{};
      IDBKeyRangePtr p_key_range{};
      bool p_key_only{};
      IDBDatabase_Get_ParamsDataView input_data_view(params, message);
      
      if (success)
        p_transaction_id = input_data_view.transaction_id();
      if (success)
        p_object_store_id = input_data_view.object_store_id();
      if (success)
        p_index_id = input_data_view.index_id();
      if (success && !input_data_view.ReadKeyRange(&p_key_range))
        success = false;
      if (success)
        p_key_only = input_data_view.key_only();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            IDBDatabase::Name_, 5, false);
        return false;
      }
      IDBDatabase::GetCallback callback =
          IDBDatabase_Get_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->Get(
std::move(p_transaction_id), 
std::move(p_object_store_id), 
std::move(p_index_id), 
std::move(p_key_range), 
std::move(p_key_only), std::move(callback));
      return true;
    }
    case internal::kIDBDatabase_GetAll_Name: {

      internal::IDBDatabase_GetAll_Params_Data* params =
          reinterpret_cast<
              internal::IDBDatabase_GetAll_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      int64_t p_transaction_id{};
      int64_t p_object_store_id{};
      int64_t p_index_id{};
      IDBKeyRangePtr p_key_range{};
      bool p_key_only{};
      int64_t p_max_count{};
      IDBDatabase_GetAll_ParamsDataView input_data_view(params, message);
      
      if (success)
        p_transaction_id = input_data_view.transaction_id();
      if (success)
        p_object_store_id = input_data_view.object_store_id();
      if (success)
        p_index_id = input_data_view.index_id();
      if (success && !input_data_view.ReadKeyRange(&p_key_range))
        success = false;
      if (success)
        p_key_only = input_data_view.key_only();
      if (success)
        p_max_count = input_data_view.max_count();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            IDBDatabase::Name_, 6, false);
        return false;
      }
      IDBDatabase::GetAllCallback callback =
          IDBDatabase_GetAll_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->GetAll(
std::move(p_transaction_id), 
std::move(p_object_store_id), 
std::move(p_index_id), 
std::move(p_key_range), 
std::move(p_key_only), 
std::move(p_max_count), std::move(callback));
      return true;
    }
    case internal::kIDBDatabase_SetIndexKeys_Name: {
      break;
    }
    case internal::kIDBDatabase_SetIndexesReady_Name: {
      break;
    }
    case internal::kIDBDatabase_OpenCursor_Name: {

      internal::IDBDatabase_OpenCursor_Params_Data* params =
          reinterpret_cast<
              internal::IDBDatabase_OpenCursor_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      int64_t p_transaction_id{};
      int64_t p_object_store_id{};
      int64_t p_index_id{};
      IDBKeyRangePtr p_key_range{};
      IDBCursorDirection p_direction{};
      bool p_key_only{};
      IDBTaskType p_task_type{};
      IDBDatabase_OpenCursor_ParamsDataView input_data_view(params, message);
      
      if (success)
        p_transaction_id = input_data_view.transaction_id();
      if (success)
        p_object_store_id = input_data_view.object_store_id();
      if (success)
        p_index_id = input_data_view.index_id();
      if (success && !input_data_view.ReadKeyRange(&p_key_range))
        success = false;
      if (success && !input_data_view.ReadDirection(&p_direction))
        success = false;
      if (success)
        p_key_only = input_data_view.key_only();
      if (success && !input_data_view.ReadTaskType(&p_task_type))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            IDBDatabase::Name_, 9, false);
        return false;
      }
      IDBDatabase::OpenCursorCallback callback =
          IDBDatabase_OpenCursor_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->OpenCursor(
std::move(p_transaction_id), 
std::move(p_object_store_id), 
std::move(p_index_id), 
std::move(p_key_range), 
std::move(p_direction), 
std::move(p_key_only), 
std::move(p_task_type), std::move(callback));
      return true;
    }
    case internal::kIDBDatabase_Count_Name: {
      break;
    }
    case internal::kIDBDatabase_DeleteRange_Name: {
      break;
    }
    case internal::kIDBDatabase_GetKeyGeneratorCurrentNumber_Name: {
      break;
    }
    case internal::kIDBDatabase_Clear_Name: {
      break;
    }
    case internal::kIDBDatabase_CreateIndex_Name: {
      break;
    }
    case internal::kIDBDatabase_DeleteIndex_Name: {
      break;
    }
    case internal::kIDBDatabase_RenameIndex_Name: {
      break;
    }
    case internal::kIDBDatabase_Abort_Name: {
      break;
    }
  }
  return false;
}


static const mojo::internal::GenericValidationInfo kIDBDatabaseValidationInfo[] = {
    {&internal::IDBDatabase_RenameObjectStore_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::IDBDatabase_CreateTransaction_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::IDBDatabase_Close_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::IDBDatabase_VersionChangeIgnored_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::IDBDatabase_BatchGetAll_Params_Data::Validate,
     &internal::IDBDatabase_BatchGetAll_ResponseParams_Data::Validate},
    {&internal::IDBDatabase_Get_Params_Data::Validate,
     &internal::IDBDatabase_Get_ResponseParams_Data::Validate},
    {&internal::IDBDatabase_GetAll_Params_Data::Validate,
     &internal::IDBDatabase_GetAll_ResponseParams_Data::Validate},
    {&internal::IDBDatabase_SetIndexKeys_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::IDBDatabase_SetIndexesReady_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::IDBDatabase_OpenCursor_Params_Data::Validate,
     &internal::IDBDatabase_OpenCursor_ResponseParams_Data::Validate},
    {&internal::IDBDatabase_Count_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::IDBDatabase_DeleteRange_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::IDBDatabase_GetKeyGeneratorCurrentNumber_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::IDBDatabase_Clear_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::IDBDatabase_CreateIndex_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::IDBDatabase_DeleteIndex_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::IDBDatabase_RenameIndex_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::IDBDatabase_Abort_Params_Data::Validate,
     nullptr /* no response */},
};

bool IDBDatabaseRequestValidator::Accept(mojo::Message* message) {
  const char* name = ::blink::mojom::blink::IDBDatabase::Name_;
  return mojo::internal::ValidateRequestGenericPacked(message, name, kIDBDatabaseValidationInfo);
}

bool IDBDatabaseResponseValidator::Accept(mojo::Message* message) {
  const char* name = ::blink::mojom::blink::IDBDatabase::Name_;
  return mojo::internal::ValidateResponseGenericPacked(message, name, kIDBDatabaseValidationInfo);
}
const char IDBFactory::Name_[] = "blink.mojom.IDBFactory";

IDBFactory::IPCStableHashFunction IDBFactory::MessageToMethodInfo_(mojo::Message& message) {
#if !BUILDFLAG(IS_FUCHSIA)
  switch (message.name()) {
    case internal::kIDBFactory_GetDatabaseInfo_Name: {
      return &IDBFactory::GetDatabaseInfo_Sym::IPCStableHash;
    }
    case internal::kIDBFactory_Open_Name: {
      return &IDBFactory::Open_Sym::IPCStableHash;
    }
    case internal::kIDBFactory_DeleteDatabase_Name: {
      return &IDBFactory::DeleteDatabase_Sym::IPCStableHash;
    }
    case internal::kIDBFactory_AbortTransactionsAndCompactDatabase_Name: {
      return &IDBFactory::AbortTransactionsAndCompactDatabase_Sym::IPCStableHash;
    }
    case internal::kIDBFactory_AbortTransactionsForDatabase_Name: {
      return &IDBFactory::AbortTransactionsForDatabase_Sym::IPCStableHash;
    }
  }
#endif  // !BUILDFLAG(IS_FUCHSIA)
  return nullptr;
}


const char* IDBFactory::MessageToMethodName_(mojo::Message& message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  bool is_response = message.has_flag(mojo::Message::kFlagIsResponse);
  if (!is_response) {
    switch (message.name()) {
      case internal::kIDBFactory_GetDatabaseInfo_Name:
            return "Receive blink::mojom::IDBFactory::GetDatabaseInfo";
      case internal::kIDBFactory_Open_Name:
            return "Receive blink::mojom::IDBFactory::Open";
      case internal::kIDBFactory_DeleteDatabase_Name:
            return "Receive blink::mojom::IDBFactory::DeleteDatabase";
      case internal::kIDBFactory_AbortTransactionsAndCompactDatabase_Name:
            return "Receive blink::mojom::IDBFactory::AbortTransactionsAndCompactDatabase";
      case internal::kIDBFactory_AbortTransactionsForDatabase_Name:
            return "Receive blink::mojom::IDBFactory::AbortTransactionsForDatabase";
    }
  } else {
    switch (message.name()) {
      case internal::kIDBFactory_GetDatabaseInfo_Name:
            return "Receive reply blink::mojom::IDBFactory::GetDatabaseInfo";
      case internal::kIDBFactory_Open_Name:
            return "Receive reply blink::mojom::IDBFactory::Open";
      case internal::kIDBFactory_DeleteDatabase_Name:
            return "Receive reply blink::mojom::IDBFactory::DeleteDatabase";
      case internal::kIDBFactory_AbortTransactionsAndCompactDatabase_Name:
            return "Receive reply blink::mojom::IDBFactory::AbortTransactionsAndCompactDatabase";
      case internal::kIDBFactory_AbortTransactionsForDatabase_Name:
            return "Receive reply blink::mojom::IDBFactory::AbortTransactionsForDatabase";
    }
  }
  return "Receive unknown mojo message";
#else
  bool is_response = message.has_flag(mojo::Message::kFlagIsResponse);
  if (is_response) {
    return "Receive mojo reply";
  } else {
    return "Receive mojo message";
  }
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
}

#if !BUILDFLAG(IS_FUCHSIA)
uint32_t IDBFactory::GetDatabaseInfo_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::IDBFactory::GetDatabaseInfo");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t IDBFactory::Open_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::IDBFactory::Open");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t IDBFactory::DeleteDatabase_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::IDBFactory::DeleteDatabase");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t IDBFactory::AbortTransactionsAndCompactDatabase_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::IDBFactory::AbortTransactionsAndCompactDatabase");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t IDBFactory::AbortTransactionsForDatabase_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::IDBFactory::AbortTransactionsForDatabase");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
# endif // !BUILDFLAG(IS_FUCHSIA)

class IDBFactory_AbortTransactionsAndCompactDatabase_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  IDBFactory_AbortTransactionsAndCompactDatabase_ForwardToCallback(
      IDBFactory::AbortTransactionsAndCompactDatabaseCallback callback
      ) : callback_(std::move(callback)) {
  }

  IDBFactory_AbortTransactionsAndCompactDatabase_ForwardToCallback(const IDBFactory_AbortTransactionsAndCompactDatabase_ForwardToCallback&) = delete;
  IDBFactory_AbortTransactionsAndCompactDatabase_ForwardToCallback& operator=(const IDBFactory_AbortTransactionsAndCompactDatabase_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  IDBFactory::AbortTransactionsAndCompactDatabaseCallback callback_;
};

class IDBFactory_AbortTransactionsForDatabase_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  IDBFactory_AbortTransactionsForDatabase_ForwardToCallback(
      IDBFactory::AbortTransactionsForDatabaseCallback callback
      ) : callback_(std::move(callback)) {
  }

  IDBFactory_AbortTransactionsForDatabase_ForwardToCallback(const IDBFactory_AbortTransactionsForDatabase_ForwardToCallback&) = delete;
  IDBFactory_AbortTransactionsForDatabase_ForwardToCallback& operator=(const IDBFactory_AbortTransactionsForDatabase_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  IDBFactory::AbortTransactionsForDatabaseCallback callback_;
};

IDBFactoryProxy::IDBFactoryProxy(mojo::MessageReceiverWithResponder* receiver)
    : receiver_(receiver) {
}

void IDBFactoryProxy::GetDatabaseInfo(
    ::mojo::PendingAssociatedRemote<IDBCallbacks> in_pending_callbacks) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::IDBFactory::GetDatabaseInfo", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("pending_callbacks"), in_pending_callbacks,
                        "<value of type ::mojo::PendingAssociatedRemote<IDBCallbacks>>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kIDBFactory_GetDatabaseInfo_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::IDBFactory_GetDatabaseInfo_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::Serialize<::blink::mojom::IDBCallbacksAssociatedPtrInfoDataView>(
      in_pending_callbacks, &params->pending_callbacks, &params.message());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      !mojo::internal::IsHandleOrInterfaceValid(params->pending_callbacks),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_INVALID_INTERFACE_ID,
      "invalid pending_callbacks in IDBFactory.GetDatabaseInfo request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(IDBFactory::Name_);
  message.set_method_name("GetDatabaseInfo");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void IDBFactoryProxy::Open(
    ::mojo::PendingAssociatedRemote<IDBCallbacks> in_pending_callbacks, ::mojo::PendingAssociatedRemote<IDBDatabaseCallbacks> in_database_callbacks, const ::WTF::String& in_name, int64_t in_version, ::mojo::PendingAssociatedReceiver<IDBTransaction> in_version_change_transaction_receiver, int64_t in_transaction_id) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::IDBFactory::Open", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("pending_callbacks"), in_pending_callbacks,
                        "<value of type ::mojo::PendingAssociatedRemote<IDBCallbacks>>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("database_callbacks"), in_database_callbacks,
                        "<value of type ::mojo::PendingAssociatedRemote<IDBDatabaseCallbacks>>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("name"), in_name,
                        "<value of type const ::WTF::String&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("version"), in_version,
                        "<value of type int64_t>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("version_change_transaction_receiver"), in_version_change_transaction_receiver,
                        "<value of type ::mojo::PendingAssociatedReceiver<IDBTransaction>>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("transaction_id"), in_transaction_id,
                        "<value of type int64_t>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kIDBFactory_Open_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::IDBFactory_Open_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::Serialize<::blink::mojom::IDBCallbacksAssociatedPtrInfoDataView>(
      in_pending_callbacks, &params->pending_callbacks, &params.message());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      !mojo::internal::IsHandleOrInterfaceValid(params->pending_callbacks),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_INVALID_INTERFACE_ID,
      "invalid pending_callbacks in IDBFactory.Open request");
  mojo::internal::Serialize<::blink::mojom::IDBDatabaseCallbacksAssociatedPtrInfoDataView>(
      in_database_callbacks, &params->database_callbacks, &params.message());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      !mojo::internal::IsHandleOrInterfaceValid(params->database_callbacks),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_INVALID_INTERFACE_ID,
      "invalid database_callbacks in IDBFactory.Open request");
  mojo::internal::MessageFragment<
      typename decltype(params->name)::BaseType> name_fragment(
          params.message());
  mojo::internal::Serialize<::mojo_base::mojom::String16DataView>(
      in_name, name_fragment);
  params->name.Set(
      name_fragment.is_null() ? nullptr : name_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->name.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null name in IDBFactory.Open request");
  params->version = in_version;
  mojo::internal::Serialize<::blink::mojom::IDBTransactionAssociatedRequestDataView>(
      in_version_change_transaction_receiver, &params->version_change_transaction_receiver, &params.message());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      !mojo::internal::IsHandleOrInterfaceValid(params->version_change_transaction_receiver),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_INVALID_INTERFACE_ID,
      "invalid version_change_transaction_receiver in IDBFactory.Open request");
  params->transaction_id = in_transaction_id;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(IDBFactory::Name_);
  message.set_method_name("Open");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void IDBFactoryProxy::DeleteDatabase(
    ::mojo::PendingAssociatedRemote<IDBCallbacks> in_pending_callbacks, const ::WTF::String& in_name, bool in_force_close) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::IDBFactory::DeleteDatabase", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("pending_callbacks"), in_pending_callbacks,
                        "<value of type ::mojo::PendingAssociatedRemote<IDBCallbacks>>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("name"), in_name,
                        "<value of type const ::WTF::String&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("force_close"), in_force_close,
                        "<value of type bool>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kIDBFactory_DeleteDatabase_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::IDBFactory_DeleteDatabase_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::Serialize<::blink::mojom::IDBCallbacksAssociatedPtrInfoDataView>(
      in_pending_callbacks, &params->pending_callbacks, &params.message());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      !mojo::internal::IsHandleOrInterfaceValid(params->pending_callbacks),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_INVALID_INTERFACE_ID,
      "invalid pending_callbacks in IDBFactory.DeleteDatabase request");
  mojo::internal::MessageFragment<
      typename decltype(params->name)::BaseType> name_fragment(
          params.message());
  mojo::internal::Serialize<::mojo_base::mojom::String16DataView>(
      in_name, name_fragment);
  params->name.Set(
      name_fragment.is_null() ? nullptr : name_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->name.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null name in IDBFactory.DeleteDatabase request");
  params->force_close = in_force_close;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(IDBFactory::Name_);
  message.set_method_name("DeleteDatabase");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void IDBFactoryProxy::AbortTransactionsAndCompactDatabase(
    AbortTransactionsAndCompactDatabaseCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send blink::mojom::IDBFactory::AbortTransactionsAndCompactDatabase");
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kIDBFactory_AbortTransactionsAndCompactDatabase_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::IDBFactory_AbortTransactionsAndCompactDatabase_Params_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(IDBFactory::Name_);
  message.set_method_name("AbortTransactionsAndCompactDatabase");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new IDBFactory_AbortTransactionsAndCompactDatabase_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void IDBFactoryProxy::AbortTransactionsForDatabase(
    AbortTransactionsForDatabaseCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send blink::mojom::IDBFactory::AbortTransactionsForDatabase");
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kIDBFactory_AbortTransactionsForDatabase_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::IDBFactory_AbortTransactionsForDatabase_Params_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(IDBFactory::Name_);
  message.set_method_name("AbortTransactionsForDatabase");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new IDBFactory_AbortTransactionsForDatabase_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}
class IDBFactory_AbortTransactionsAndCompactDatabase_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static IDBFactory::AbortTransactionsAndCompactDatabaseCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<IDBFactory_AbortTransactionsAndCompactDatabase_ProxyToResponder> proxy(
        new IDBFactory_AbortTransactionsAndCompactDatabase_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&IDBFactory_AbortTransactionsAndCompactDatabase_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~IDBFactory_AbortTransactionsAndCompactDatabase_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  IDBFactory_AbortTransactionsAndCompactDatabase_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "IDBFactory::AbortTransactionsAndCompactDatabaseCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      IDBStatus in_status);
};

bool IDBFactory_AbortTransactionsAndCompactDatabase_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::IDBFactory_AbortTransactionsAndCompactDatabase_ResponseParams_Data* params =
      reinterpret_cast<
          internal::IDBFactory_AbortTransactionsAndCompactDatabase_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  IDBStatus p_status{};
  IDBFactory_AbortTransactionsAndCompactDatabase_ResponseParamsDataView input_data_view(params, message);
  
  if (success && !input_data_view.ReadStatus(&p_status))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        IDBFactory::Name_, 3, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_status));
  return true;
}

void IDBFactory_AbortTransactionsAndCompactDatabase_ProxyToResponder::Run(
    IDBStatus in_status) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send reply blink::mojom::IDBFactory::AbortTransactionsAndCompactDatabase", "async_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("status"), in_status,
                        "<value of type IDBStatus>");
   });
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kIDBFactory_AbortTransactionsAndCompactDatabase_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::IDBFactory_AbortTransactionsAndCompactDatabase_ResponseParams_Data> params(
          message);
  params.Allocate();
  mojo::internal::Serialize<::blink::mojom::IDBStatus>(
      in_status, &params->status);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(IDBFactory::Name_);
  message.set_method_name("AbortTransactionsAndCompactDatabase");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class IDBFactory_AbortTransactionsForDatabase_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static IDBFactory::AbortTransactionsForDatabaseCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<IDBFactory_AbortTransactionsForDatabase_ProxyToResponder> proxy(
        new IDBFactory_AbortTransactionsForDatabase_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&IDBFactory_AbortTransactionsForDatabase_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~IDBFactory_AbortTransactionsForDatabase_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  IDBFactory_AbortTransactionsForDatabase_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "IDBFactory::AbortTransactionsForDatabaseCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      IDBStatus in_status);
};

bool IDBFactory_AbortTransactionsForDatabase_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::IDBFactory_AbortTransactionsForDatabase_ResponseParams_Data* params =
      reinterpret_cast<
          internal::IDBFactory_AbortTransactionsForDatabase_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  IDBStatus p_status{};
  IDBFactory_AbortTransactionsForDatabase_ResponseParamsDataView input_data_view(params, message);
  
  if (success && !input_data_view.ReadStatus(&p_status))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        IDBFactory::Name_, 4, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_status));
  return true;
}

void IDBFactory_AbortTransactionsForDatabase_ProxyToResponder::Run(
    IDBStatus in_status) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send reply blink::mojom::IDBFactory::AbortTransactionsForDatabase", "async_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("status"), in_status,
                        "<value of type IDBStatus>");
   });
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kIDBFactory_AbortTransactionsForDatabase_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::IDBFactory_AbortTransactionsForDatabase_ResponseParams_Data> params(
          message);
  params.Allocate();
  mojo::internal::Serialize<::blink::mojom::IDBStatus>(
      in_status, &params->status);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(IDBFactory::Name_);
  message.set_method_name("AbortTransactionsForDatabase");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}

// static
bool IDBFactoryStubDispatch::Accept(
    IDBFactory* impl,
    mojo::Message* message) {
  switch (message->header()->name) {
    case internal::kIDBFactory_GetDatabaseInfo_Name: {

      DCHECK(message->is_serialized());
      internal::IDBFactory_GetDatabaseInfo_Params_Data* params =
          reinterpret_cast<internal::IDBFactory_GetDatabaseInfo_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::mojo::PendingAssociatedRemote<IDBCallbacks> p_pending_callbacks{};
      IDBFactory_GetDatabaseInfo_ParamsDataView input_data_view(params, message);
      
      if (success) {
        p_pending_callbacks =
            input_data_view.TakePendingCallbacks<decltype(p_pending_callbacks)>();
      }
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            IDBFactory::Name_, 0, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->GetDatabaseInfo(
std::move(p_pending_callbacks));
      return true;
    }
    case internal::kIDBFactory_Open_Name: {

      DCHECK(message->is_serialized());
      internal::IDBFactory_Open_Params_Data* params =
          reinterpret_cast<internal::IDBFactory_Open_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::mojo::PendingAssociatedRemote<IDBCallbacks> p_pending_callbacks{};
      ::mojo::PendingAssociatedRemote<IDBDatabaseCallbacks> p_database_callbacks{};
      ::WTF::String p_name{};
      int64_t p_version{};
      ::mojo::PendingAssociatedReceiver<IDBTransaction> p_version_change_transaction_receiver{};
      int64_t p_transaction_id{};
      IDBFactory_Open_ParamsDataView input_data_view(params, message);
      
      if (success) {
        p_pending_callbacks =
            input_data_view.TakePendingCallbacks<decltype(p_pending_callbacks)>();
      }
      if (success) {
        p_database_callbacks =
            input_data_view.TakeDatabaseCallbacks<decltype(p_database_callbacks)>();
      }
      if (success && !input_data_view.ReadName(&p_name))
        success = false;
      if (success)
        p_version = input_data_view.version();
      if (success) {
        p_version_change_transaction_receiver =
            input_data_view.TakeVersionChangeTransactionReceiver<decltype(p_version_change_transaction_receiver)>();
      }
      if (success)
        p_transaction_id = input_data_view.transaction_id();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            IDBFactory::Name_, 1, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->Open(
std::move(p_pending_callbacks), 
std::move(p_database_callbacks), 
std::move(p_name), 
std::move(p_version), 
std::move(p_version_change_transaction_receiver), 
std::move(p_transaction_id));
      return true;
    }
    case internal::kIDBFactory_DeleteDatabase_Name: {

      DCHECK(message->is_serialized());
      internal::IDBFactory_DeleteDatabase_Params_Data* params =
          reinterpret_cast<internal::IDBFactory_DeleteDatabase_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::mojo::PendingAssociatedRemote<IDBCallbacks> p_pending_callbacks{};
      ::WTF::String p_name{};
      bool p_force_close{};
      IDBFactory_DeleteDatabase_ParamsDataView input_data_view(params, message);
      
      if (success) {
        p_pending_callbacks =
            input_data_view.TakePendingCallbacks<decltype(p_pending_callbacks)>();
      }
      if (success && !input_data_view.ReadName(&p_name))
        success = false;
      if (success)
        p_force_close = input_data_view.force_close();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            IDBFactory::Name_, 2, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->DeleteDatabase(
std::move(p_pending_callbacks), 
std::move(p_name), 
std::move(p_force_close));
      return true;
    }
    case internal::kIDBFactory_AbortTransactionsAndCompactDatabase_Name: {
      break;
    }
    case internal::kIDBFactory_AbortTransactionsForDatabase_Name: {
      break;
    }
  }
  return false;
}

// static
bool IDBFactoryStubDispatch::AcceptWithResponder(
    IDBFactory* impl,
    mojo::Message* message,
    std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
  [[maybe_unused]] const bool message_is_sync =
      message->has_flag(mojo::Message::kFlagIsSync);
  [[maybe_unused]] const uint64_t request_id = message->request_id();
  switch (message->header()->name) {
    case internal::kIDBFactory_GetDatabaseInfo_Name: {
      break;
    }
    case internal::kIDBFactory_Open_Name: {
      break;
    }
    case internal::kIDBFactory_DeleteDatabase_Name: {
      break;
    }
    case internal::kIDBFactory_AbortTransactionsAndCompactDatabase_Name: {

      internal::IDBFactory_AbortTransactionsAndCompactDatabase_Params_Data* params =
          reinterpret_cast<
              internal::IDBFactory_AbortTransactionsAndCompactDatabase_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      IDBFactory_AbortTransactionsAndCompactDatabase_ParamsDataView input_data_view(params, message);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            IDBFactory::Name_, 3, false);
        return false;
      }
      IDBFactory::AbortTransactionsAndCompactDatabaseCallback callback =
          IDBFactory_AbortTransactionsAndCompactDatabase_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->AbortTransactionsAndCompactDatabase(std::move(callback));
      return true;
    }
    case internal::kIDBFactory_AbortTransactionsForDatabase_Name: {

      internal::IDBFactory_AbortTransactionsForDatabase_Params_Data* params =
          reinterpret_cast<
              internal::IDBFactory_AbortTransactionsForDatabase_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      IDBFactory_AbortTransactionsForDatabase_ParamsDataView input_data_view(params, message);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            IDBFactory::Name_, 4, false);
        return false;
      }
      IDBFactory::AbortTransactionsForDatabaseCallback callback =
          IDBFactory_AbortTransactionsForDatabase_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->AbortTransactionsForDatabase(std::move(callback));
      return true;
    }
  }
  return false;
}


static const mojo::internal::GenericValidationInfo kIDBFactoryValidationInfo[] = {
    {&internal::IDBFactory_GetDatabaseInfo_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::IDBFactory_Open_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::IDBFactory_DeleteDatabase_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::IDBFactory_AbortTransactionsAndCompactDatabase_Params_Data::Validate,
     &internal::IDBFactory_AbortTransactionsAndCompactDatabase_ResponseParams_Data::Validate},
    {&internal::IDBFactory_AbortTransactionsForDatabase_Params_Data::Validate,
     &internal::IDBFactory_AbortTransactionsForDatabase_ResponseParams_Data::Validate},
};

bool IDBFactoryRequestValidator::Accept(mojo::Message* message) {
  const char* name = ::blink::mojom::blink::IDBFactory::Name_;
  return mojo::internal::ValidateRequestGenericPacked(message, name, kIDBFactoryValidationInfo);
}

bool IDBFactoryResponseValidator::Accept(mojo::Message* message) {
  const char* name = ::blink::mojom::blink::IDBFactory::Name_;
  return mojo::internal::ValidateResponseGenericPacked(message, name, kIDBFactoryValidationInfo);
}


}  // namespace blink
}  // namespace mojom
}  // namespace blink


namespace mojo {


// static
bool StructTraits<::blink::mojom::blink::IDBKeyPath::DataView, ::blink::mojom::blink::IDBKeyPathPtr>::Read(
    ::blink::mojom::blink::IDBKeyPath::DataView input,
    ::blink::mojom::blink::IDBKeyPathPtr* output) {
  bool success = true;
  ::blink::mojom::blink::IDBKeyPathPtr result(::blink::mojom::blink::IDBKeyPath::New());
  
      if (success && !input.ReadData(&result->data))
        success = false;
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::blink::mojom::blink::IDBKeyRange::DataView, ::blink::mojom::blink::IDBKeyRangePtr>::Read(
    ::blink::mojom::blink::IDBKeyRange::DataView input,
    ::blink::mojom::blink::IDBKeyRangePtr* output) {
  bool success = true;
  ::blink::mojom::blink::IDBKeyRangePtr result(::blink::mojom::blink::IDBKeyRange::New());
  
      if (success && !input.ReadLower(&result->lower))
        success = false;
      if (success && !input.ReadUpper(&result->upper))
        success = false;
      if (success)
        result->lower_open = input.lower_open();
      if (success)
        result->upper_open = input.upper_open();
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::blink::mojom::blink::IDBIndexMetadata::DataView, ::blink::mojom::blink::IDBIndexMetadataPtr>::Read(
    ::blink::mojom::blink::IDBIndexMetadata::DataView input,
    ::blink::mojom::blink::IDBIndexMetadataPtr* output) {
  bool success = true;
  ::blink::mojom::blink::IDBIndexMetadataPtr result(::blink::mojom::blink::IDBIndexMetadata::New());
  
      if (success)
        result->id = input.id();
      if (success && !input.ReadName(&result->name))
        success = false;
      if (success && !input.ReadKeyPath(&result->key_path))
        success = false;
      if (success)
        result->unique = input.unique();
      if (success)
        result->multi_entry = input.multi_entry();
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::blink::mojom::blink::IDBObjectStoreMetadata::DataView, ::blink::mojom::blink::IDBObjectStoreMetadataPtr>::Read(
    ::blink::mojom::blink::IDBObjectStoreMetadata::DataView input,
    ::blink::mojom::blink::IDBObjectStoreMetadataPtr* output) {
  bool success = true;
  ::blink::mojom::blink::IDBObjectStoreMetadataPtr result(::blink::mojom::blink::IDBObjectStoreMetadata::New());
  
      if (success)
        result->id = input.id();
      if (success && !input.ReadName(&result->name))
        success = false;
      if (success && !input.ReadKeyPath(&result->key_path))
        success = false;
      if (success)
        result->auto_increment = input.auto_increment();
      if (success)
        result->max_index_id = input.max_index_id();
      if (success && !input.ReadIndexes(&result->indexes))
        success = false;
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::blink::mojom::blink::IDBDatabaseMetadata::DataView, ::blink::mojom::blink::IDBDatabaseMetadataPtr>::Read(
    ::blink::mojom::blink::IDBDatabaseMetadata::DataView input,
    ::blink::mojom::blink::IDBDatabaseMetadataPtr* output) {
  bool success = true;
  ::blink::mojom::blink::IDBDatabaseMetadataPtr result(::blink::mojom::blink::IDBDatabaseMetadata::New());
  
      if (success)
        result->id = input.id();
      if (success && !input.ReadName(&result->name))
        success = false;
      if (success)
        result->version = input.version();
      if (success)
        result->max_object_store_id = input.max_object_store_id();
      if (success && !input.ReadObjectStores(&result->object_stores))
        success = false;
      if (success)
        result->was_cold_open = input.was_cold_open();
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::blink::mojom::blink::IDBNameAndVersion::DataView, ::blink::mojom::blink::IDBNameAndVersionPtr>::Read(
    ::blink::mojom::blink::IDBNameAndVersion::DataView input,
    ::blink::mojom::blink::IDBNameAndVersionPtr* output) {
  bool success = true;
  ::blink::mojom::blink::IDBNameAndVersionPtr result(::blink::mojom::blink::IDBNameAndVersion::New());
  
      if (success && !input.ReadName(&result->name))
        success = false;
      if (success)
        result->version = input.version();
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::blink::mojom::blink::IDBIndexKeys::DataView, ::blink::mojom::blink::IDBIndexKeysPtr>::Read(
    ::blink::mojom::blink::IDBIndexKeys::DataView input,
    ::blink::mojom::blink::IDBIndexKeysPtr* output) {
  bool success = true;
  ::blink::mojom::blink::IDBIndexKeysPtr result(::blink::mojom::blink::IDBIndexKeys::New());
  
      if (success)
        result->index_id = input.index_id();
      if (success && !input.ReadIndexKeys(&result->index_keys))
        success = false;
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::blink::mojom::blink::IDBFileInfo::DataView, ::blink::mojom::blink::IDBFileInfoPtr>::Read(
    ::blink::mojom::blink::IDBFileInfo::DataView input,
    ::blink::mojom::blink::IDBFileInfoPtr* output) {
  bool success = true;
  ::blink::mojom::blink::IDBFileInfoPtr result(::blink::mojom::blink::IDBFileInfo::New());
  
      if (success && !input.ReadName(&result->name))
        success = false;
      if (success && !input.ReadLastModified(&result->last_modified))
        success = false;
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::blink::mojom::blink::IDBBlobInfo::DataView, ::blink::mojom::blink::IDBBlobInfoPtr>::Read(
    ::blink::mojom::blink::IDBBlobInfo::DataView input,
    ::blink::mojom::blink::IDBBlobInfoPtr* output) {
  bool success = true;
  ::blink::mojom::blink::IDBBlobInfoPtr result(::blink::mojom::blink::IDBBlobInfo::New());
  
      if (success) {
        result->blob =
            input.TakeBlob<decltype(result->blob)>();
      }
      if (success && !input.ReadUuid(&result->uuid))
        success = false;
      if (success && !input.ReadMimeType(&result->mime_type))
        success = false;
      if (success)
        result->size = input.size();
      if (success && !input.ReadFile(&result->file))
        success = false;
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::blink::mojom::blink::IDBValue::DataView, ::blink::mojom::blink::IDBValuePtr>::Read(
    ::blink::mojom::blink::IDBValue::DataView input,
    ::blink::mojom::blink::IDBValuePtr* output) {
  bool success = true;
  ::blink::mojom::blink::IDBValuePtr result(::blink::mojom::blink::IDBValue::New());
  
      if (success && !input.ReadBits(&result->bits))
        success = false;
      if (success && !input.ReadExternalObjects(&result->external_objects))
        success = false;
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::blink::mojom::blink::IDBReturnValue::DataView, ::blink::mojom::blink::IDBReturnValuePtr>::Read(
    ::blink::mojom::blink::IDBReturnValue::DataView input,
    ::blink::mojom::blink::IDBReturnValuePtr* output) {
  bool success = true;
  ::blink::mojom::blink::IDBReturnValuePtr result(::blink::mojom::blink::IDBReturnValue::New());
  
      if (success && !input.ReadValue(&result->value))
        success = false;
      if (success && !input.ReadPrimaryKey(&result->primary_key))
        success = false;
      if (success && !input.ReadKeyPath(&result->key_path))
        success = false;
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::blink::mojom::blink::IDBError::DataView, ::blink::mojom::blink::IDBErrorPtr>::Read(
    ::blink::mojom::blink::IDBError::DataView input,
    ::blink::mojom::blink::IDBErrorPtr* output) {
  bool success = true;
  ::blink::mojom::blink::IDBErrorPtr result(::blink::mojom::blink::IDBError::New());
  
      if (success && !input.ReadErrorCode(&result->error_code))
        success = false;
      if (success && !input.ReadErrorMessage(&result->error_message))
        success = false;
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::blink::mojom::blink::IDBCursorValue::DataView, ::blink::mojom::blink::IDBCursorValuePtr>::Read(
    ::blink::mojom::blink::IDBCursorValue::DataView input,
    ::blink::mojom::blink::IDBCursorValuePtr* output) {
  bool success = true;
  ::blink::mojom::blink::IDBCursorValuePtr result(::blink::mojom::blink::IDBCursorValue::New());
  
      if (success && !input.ReadKeys(&result->keys))
        success = false;
      if (success && !input.ReadPrimaryKeys(&result->primary_keys))
        success = false;
      if (success && !input.ReadValues(&result->values))
        success = false;
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::blink::mojom::blink::IDBDatabaseOpenCursorValue::DataView, ::blink::mojom::blink::IDBDatabaseOpenCursorValuePtr>::Read(
    ::blink::mojom::blink::IDBDatabaseOpenCursorValue::DataView input,
    ::blink::mojom::blink::IDBDatabaseOpenCursorValuePtr* output) {
  bool success = true;
  ::blink::mojom::blink::IDBDatabaseOpenCursorValuePtr result(::blink::mojom::blink::IDBDatabaseOpenCursorValue::New());
  
      if (success) {
        result->cursor =
            input.TakeCursor<decltype(result->cursor)>();
      }
      if (success && !input.ReadKey(&result->key))
        success = false;
      if (success && !input.ReadPrimaryKey(&result->primary_key))
        success = false;
      if (success && !input.ReadValue(&result->value))
        success = false;
  *output = std::move(result);
  return success;
}

// static
bool UnionTraits<::blink::mojom::blink::IDBKey::DataView, ::blink::mojom::blink::IDBKeyPtr>::Read(
    ::blink::mojom::blink::IDBKey::DataView input,
    ::blink::mojom::blink::IDBKeyPtr* output) {
  using UnionType = ::blink::mojom::blink::IDBKey;
  using Tag = UnionType::Tag;

  switch (input.tag()) {
    case Tag::kKeyArray: {
      WTF::Vector<::std::unique_ptr<::blink::IDBKey>> result_key_array;
      if (!input.ReadKeyArray(&result_key_array))
        return false;

      *output = UnionType::NewKeyArray(
          std::move(result_key_array));
      break;
    }
    case Tag::kBinary: {
      WTF::Vector<uint8_t> result_binary;
      if (!input.ReadBinary(&result_binary))
        return false;

      *output = UnionType::NewBinary(
          std::move(result_binary));
      break;
    }
    case Tag::kString: {
      ::WTF::String result_string;
      if (!input.ReadString(&result_string))
        return false;

      *output = UnionType::NewString(
          std::move(result_string));
      break;
    }
    case Tag::kDate: {
      *output = UnionType::NewDate(input.date());
      break;
    }
    case Tag::kNumber: {
      *output = UnionType::NewNumber(input.number());
      break;
    }
    case Tag::kOtherNone: {
      *output = UnionType::NewOtherNone(input.other_none());
      break;
    }
    default:

      return false;
  }
  return true;
}

// static
bool UnionTraits<::blink::mojom::blink::IDBKeyPathData::DataView, ::blink::mojom::blink::IDBKeyPathDataPtr>::Read(
    ::blink::mojom::blink::IDBKeyPathData::DataView input,
    ::blink::mojom::blink::IDBKeyPathDataPtr* output) {
  using UnionType = ::blink::mojom::blink::IDBKeyPathData;
  using Tag = UnionType::Tag;

  switch (input.tag()) {
    case Tag::kString: {
      ::WTF::String result_string;
      if (!input.ReadString(&result_string))
        return false;

      *output = UnionType::NewString(
          std::move(result_string));
      break;
    }
    case Tag::kStringArray: {
      WTF::Vector<::WTF::String> result_string_array;
      if (!input.ReadStringArray(&result_string_array))
        return false;

      *output = UnionType::NewStringArray(
          std::move(result_string_array));
      break;
    }
    default:

      return false;
  }
  return true;
}

// static
bool UnionTraits<::blink::mojom::blink::IDBExternalObject::DataView, ::blink::mojom::blink::IDBExternalObjectPtr>::Read(
    ::blink::mojom::blink::IDBExternalObject::DataView input,
    ::blink::mojom::blink::IDBExternalObjectPtr* output) {
  using UnionType = ::blink::mojom::blink::IDBExternalObject;
  using Tag = UnionType::Tag;

  switch (input.tag()) {
    case Tag::kBlobOrFile: {
      ::blink::mojom::blink::IDBBlobInfoPtr result_blob_or_file;
      if (!input.ReadBlobOrFile(&result_blob_or_file))
        return false;

      *output = UnionType::NewBlobOrFile(
          std::move(result_blob_or_file));
      break;
    }
    case Tag::kFileSystemAccessToken: {
      *output = UnionType::NewFileSystemAccessToken(
          input.TakeFileSystemAccessToken<::mojo::PendingRemote<::blink::mojom::blink::FileSystemAccessTransferToken>>());
      break;
    }
    default:

      return false;
  }
  return true;
}

// static
bool UnionTraits<::blink::mojom::blink::IDBCursorResult::DataView, ::blink::mojom::blink::IDBCursorResultPtr>::Read(
    ::blink::mojom::blink::IDBCursorResult::DataView input,
    ::blink::mojom::blink::IDBCursorResultPtr* output) {
  using UnionType = ::blink::mojom::blink::IDBCursorResult;
  using Tag = UnionType::Tag;

  switch (input.tag()) {
    case Tag::kErrorResult: {
      ::blink::mojom::blink::IDBErrorPtr result_error_result;
      if (!input.ReadErrorResult(&result_error_result))
        return false;

      *output = UnionType::NewErrorResult(
          std::move(result_error_result));
      break;
    }
    case Tag::kEmpty: {
      *output = UnionType::NewEmpty(input.empty());
      break;
    }
    case Tag::kValues: {
      ::blink::mojom::blink::IDBCursorValuePtr result_values;
      if (!input.ReadValues(&result_values))
        return false;

      *output = UnionType::NewValues(
          std::move(result_values));
      break;
    }
    default:

      return false;
  }
  return true;
}

// static
bool UnionTraits<::blink::mojom::blink::IDBTransactionPutResult::DataView, ::blink::mojom::blink::IDBTransactionPutResultPtr>::Read(
    ::blink::mojom::blink::IDBTransactionPutResult::DataView input,
    ::blink::mojom::blink::IDBTransactionPutResultPtr* output) {
  using UnionType = ::blink::mojom::blink::IDBTransactionPutResult;
  using Tag = UnionType::Tag;

  switch (input.tag()) {
    case Tag::kErrorResult: {
      ::blink::mojom::blink::IDBErrorPtr result_error_result;
      if (!input.ReadErrorResult(&result_error_result))
        return false;

      *output = UnionType::NewErrorResult(
          std::move(result_error_result));
      break;
    }
    case Tag::kKey: {
      ::std::unique_ptr<::blink::IDBKey> result_key;
      if (!input.ReadKey(&result_key))
        return false;

      *output = UnionType::NewKey(
          std::move(result_key));
      break;
    }
    default:

      return false;
  }
  return true;
}

// static
bool UnionTraits<::blink::mojom::blink::IDBDatabaseGetResult::DataView, ::blink::mojom::blink::IDBDatabaseGetResultPtr>::Read(
    ::blink::mojom::blink::IDBDatabaseGetResult::DataView input,
    ::blink::mojom::blink::IDBDatabaseGetResultPtr* output) {
  using UnionType = ::blink::mojom::blink::IDBDatabaseGetResult;
  using Tag = UnionType::Tag;

  switch (input.tag()) {
    case Tag::kErrorResult: {
      ::blink::mojom::blink::IDBErrorPtr result_error_result;
      if (!input.ReadErrorResult(&result_error_result))
        return false;

      *output = UnionType::NewErrorResult(
          std::move(result_error_result));
      break;
    }
    case Tag::kEmpty: {
      *output = UnionType::NewEmpty(input.empty());
      break;
    }
    case Tag::kKey: {
      ::std::unique_ptr<::blink::IDBKey> result_key;
      if (!input.ReadKey(&result_key))
        return false;

      *output = UnionType::NewKey(
          std::move(result_key));
      break;
    }
    case Tag::kValue: {
      ::blink::mojom::blink::IDBReturnValuePtr result_value;
      if (!input.ReadValue(&result_value))
        return false;

      *output = UnionType::NewValue(
          std::move(result_value));
      break;
    }
    default:

      return false;
  }
  return true;
}

// static
bool UnionTraits<::blink::mojom::blink::IDBDatabaseBatchGetAllResult::DataView, ::blink::mojom::blink::IDBDatabaseBatchGetAllResultPtr>::Read(
    ::blink::mojom::blink::IDBDatabaseBatchGetAllResult::DataView input,
    ::blink::mojom::blink::IDBDatabaseBatchGetAllResultPtr* output) {
  using UnionType = ::blink::mojom::blink::IDBDatabaseBatchGetAllResult;
  using Tag = UnionType::Tag;

  switch (input.tag()) {
    case Tag::kErrorResult: {
      ::blink::mojom::blink::IDBErrorPtr result_error_result;
      if (!input.ReadErrorResult(&result_error_result))
        return false;

      *output = UnionType::NewErrorResult(
          std::move(result_error_result));
      break;
    }
    case Tag::kValues: {
      WTF::Vector<WTF::Vector<::blink::mojom::blink::IDBReturnValuePtr>> result_values;
      if (!input.ReadValues(&result_values))
        return false;

      *output = UnionType::NewValues(
          std::move(result_values));
      break;
    }
    default:

      return false;
  }
  return true;
}

// static
bool UnionTraits<::blink::mojom::blink::IDBDatabaseOpenCursorResult::DataView, ::blink::mojom::blink::IDBDatabaseOpenCursorResultPtr>::Read(
    ::blink::mojom::blink::IDBDatabaseOpenCursorResult::DataView input,
    ::blink::mojom::blink::IDBDatabaseOpenCursorResultPtr* output) {
  using UnionType = ::blink::mojom::blink::IDBDatabaseOpenCursorResult;
  using Tag = UnionType::Tag;

  switch (input.tag()) {
    case Tag::kErrorResult: {
      ::blink::mojom::blink::IDBErrorPtr result_error_result;
      if (!input.ReadErrorResult(&result_error_result))
        return false;

      *output = UnionType::NewErrorResult(
          std::move(result_error_result));
      break;
    }
    case Tag::kEmpty: {
      *output = UnionType::NewEmpty(input.empty());
      break;
    }
    case Tag::kValue: {
      ::blink::mojom::blink::IDBDatabaseOpenCursorValuePtr result_value;
      if (!input.ReadValue(&result_value))
        return false;

      *output = UnionType::NewValue(
          std::move(result_value));
      break;
    }
    default:

      return false;
  }
  return true;
}

}  // namespace mojo


// Symbols declared in the -test-utils.h header are defined here instead of a
// separate .cc file to save compile time.


namespace blink {
namespace mojom {
namespace blink {


void IDBCallbacksInterceptorForTesting::Error(IDBException code, const ::WTF::String& message) {
  GetForwardingInterface()->Error(std::move(code), std::move(message));
}
void IDBCallbacksInterceptorForTesting::SuccessNamesAndVersionsList(WTF::Vector<IDBNameAndVersionPtr> value) {
  GetForwardingInterface()->SuccessNamesAndVersionsList(std::move(value));
}
void IDBCallbacksInterceptorForTesting::Blocked(int64_t existing_version) {
  GetForwardingInterface()->Blocked(std::move(existing_version));
}
void IDBCallbacksInterceptorForTesting::UpgradeNeeded(::mojo::PendingAssociatedRemote<IDBDatabase> pending_database, int64_t old_version, IDBDataLoss data_loss, const WTF::String& data_loss_message, const ::blink::IDBDatabaseMetadata& db_metadata) {
  GetForwardingInterface()->UpgradeNeeded(std::move(pending_database), std::move(old_version), std::move(data_loss), std::move(data_loss_message), std::move(db_metadata));
}
void IDBCallbacksInterceptorForTesting::SuccessDatabase(::mojo::PendingAssociatedRemote<IDBDatabase> pending_database, const ::blink::IDBDatabaseMetadata& metadata) {
  GetForwardingInterface()->SuccessDatabase(std::move(pending_database), std::move(metadata));
}
void IDBCallbacksInterceptorForTesting::SuccessInteger(int64_t value) {
  GetForwardingInterface()->SuccessInteger(std::move(value));
}
void IDBCallbacksInterceptorForTesting::Success() {
  GetForwardingInterface()->Success();
}
IDBCallbacksAsyncWaiter::IDBCallbacksAsyncWaiter(
    IDBCallbacks* proxy) : proxy_(proxy) {}

IDBCallbacksAsyncWaiter::~IDBCallbacksAsyncWaiter() = default;




void IDBDatabaseCallbacksInterceptorForTesting::ForcedClose() {
  GetForwardingInterface()->ForcedClose();
}
void IDBDatabaseCallbacksInterceptorForTesting::VersionChange(int64_t old_version, int64_t new_version) {
  GetForwardingInterface()->VersionChange(std::move(old_version), std::move(new_version));
}
void IDBDatabaseCallbacksInterceptorForTesting::Abort(int64_t transaction_id, IDBException code, const ::WTF::String& message) {
  GetForwardingInterface()->Abort(std::move(transaction_id), std::move(code), std::move(message));
}
void IDBDatabaseCallbacksInterceptorForTesting::Complete(int64_t transaction_id) {
  GetForwardingInterface()->Complete(std::move(transaction_id));
}
IDBDatabaseCallbacksAsyncWaiter::IDBDatabaseCallbacksAsyncWaiter(
    IDBDatabaseCallbacks* proxy) : proxy_(proxy) {}

IDBDatabaseCallbacksAsyncWaiter::~IDBDatabaseCallbacksAsyncWaiter() = default;




void IDBCursorInterceptorForTesting::Advance(uint32_t count, AdvanceCallback callback) {
  GetForwardingInterface()->Advance(std::move(count), std::move(callback));
}
void IDBCursorInterceptorForTesting::CursorContinue(::std::unique_ptr<::blink::IDBKey> key, ::std::unique_ptr<::blink::IDBKey> primary_key, CursorContinueCallback callback) {
  GetForwardingInterface()->CursorContinue(std::move(key), std::move(primary_key), std::move(callback));
}
void IDBCursorInterceptorForTesting::Prefetch(int32_t count, PrefetchCallback callback) {
  GetForwardingInterface()->Prefetch(std::move(count), std::move(callback));
}
void IDBCursorInterceptorForTesting::PrefetchReset(int32_t used_prefetches, int32_t unused_prefetches) {
  GetForwardingInterface()->PrefetchReset(std::move(used_prefetches), std::move(unused_prefetches));
}
IDBCursorAsyncWaiter::IDBCursorAsyncWaiter(
    IDBCursor* proxy) : proxy_(proxy) {}

IDBCursorAsyncWaiter::~IDBCursorAsyncWaiter() = default;

void IDBCursorAsyncWaiter::Advance(
    uint32_t count, IDBCursorResultPtr* out_result) {
  base::RunLoop loop;
  proxy_->Advance(std::move(count),
      base::BindOnce(
          [](base::RunLoop* loop,
             IDBCursorResultPtr* out_result
,
             IDBCursorResultPtr result) {*out_result = std::move(result);
            loop->Quit();
          },
          &loop,
          out_result));
  loop.Run();
}
void IDBCursorAsyncWaiter::CursorContinue(
    ::std::unique_ptr<::blink::IDBKey> key, ::std::unique_ptr<::blink::IDBKey> primary_key, IDBCursorResultPtr* out_result) {
  base::RunLoop loop;
  proxy_->CursorContinue(std::move(key),std::move(primary_key),
      base::BindOnce(
          [](base::RunLoop* loop,
             IDBCursorResultPtr* out_result
,
             IDBCursorResultPtr result) {*out_result = std::move(result);
            loop->Quit();
          },
          &loop,
          out_result));
  loop.Run();
}
void IDBCursorAsyncWaiter::Prefetch(
    int32_t count, IDBCursorResultPtr* out_result) {
  base::RunLoop loop;
  proxy_->Prefetch(std::move(count),
      base::BindOnce(
          [](base::RunLoop* loop,
             IDBCursorResultPtr* out_result
,
             IDBCursorResultPtr result) {*out_result = std::move(result);
            loop->Quit();
          },
          &loop,
          out_result));
  loop.Run();
}



void IDBTransactionInterceptorForTesting::CreateObjectStore(int64_t object_store_id, const ::WTF::String& name, const ::blink::IDBKeyPath& key_path, bool auto_increment) {
  GetForwardingInterface()->CreateObjectStore(std::move(object_store_id), std::move(name), std::move(key_path), std::move(auto_increment));
}
void IDBTransactionInterceptorForTesting::DeleteObjectStore(int64_t object_store_id) {
  GetForwardingInterface()->DeleteObjectStore(std::move(object_store_id));
}
void IDBTransactionInterceptorForTesting::Put(int64_t object_store_id, ::std::unique_ptr<::blink::IDBValue> value, ::std::unique_ptr<::blink::IDBKey> key, IDBPutMode mode, WTF::Vector<::blink::IDBIndexKeys> index_keys, PutCallback callback) {
  GetForwardingInterface()->Put(std::move(object_store_id), std::move(value), std::move(key), std::move(mode), std::move(index_keys), std::move(callback));
}
void IDBTransactionInterceptorForTesting::Commit(int64_t num_errors_handled) {
  GetForwardingInterface()->Commit(std::move(num_errors_handled));
}
IDBTransactionAsyncWaiter::IDBTransactionAsyncWaiter(
    IDBTransaction* proxy) : proxy_(proxy) {}

IDBTransactionAsyncWaiter::~IDBTransactionAsyncWaiter() = default;

void IDBTransactionAsyncWaiter::Put(
    int64_t object_store_id, ::std::unique_ptr<::blink::IDBValue> value, ::std::unique_ptr<::blink::IDBKey> key, IDBPutMode mode, WTF::Vector<::blink::IDBIndexKeys> index_keys, IDBTransactionPutResultPtr* out_result) {
  base::RunLoop loop;
  proxy_->Put(std::move(object_store_id),std::move(value),std::move(key),std::move(mode),std::move(index_keys),
      base::BindOnce(
          [](base::RunLoop* loop,
             IDBTransactionPutResultPtr* out_result
,
             IDBTransactionPutResultPtr result) {*out_result = std::move(result);
            loop->Quit();
          },
          &loop,
          out_result));
  loop.Run();
}



void IDBDatabaseGetAllResultSinkInterceptorForTesting::ReceiveValues(WTF::Vector<IDBReturnValuePtr> values) {
  GetForwardingInterface()->ReceiveValues(std::move(values));
}
void IDBDatabaseGetAllResultSinkInterceptorForTesting::ReceiveKeys(WTF::Vector<::std::unique_ptr<::blink::IDBKey>> keys) {
  GetForwardingInterface()->ReceiveKeys(std::move(keys));
}
void IDBDatabaseGetAllResultSinkInterceptorForTesting::OnError(IDBErrorPtr error) {
  GetForwardingInterface()->OnError(std::move(error));
}
IDBDatabaseGetAllResultSinkAsyncWaiter::IDBDatabaseGetAllResultSinkAsyncWaiter(
    IDBDatabaseGetAllResultSink* proxy) : proxy_(proxy) {}

IDBDatabaseGetAllResultSinkAsyncWaiter::~IDBDatabaseGetAllResultSinkAsyncWaiter() = default;




void IDBDatabaseInterceptorForTesting::RenameObjectStore(int64_t transaction_id, int64_t object_store_id, const ::WTF::String& new_name) {
  GetForwardingInterface()->RenameObjectStore(std::move(transaction_id), std::move(object_store_id), std::move(new_name));
}
void IDBDatabaseInterceptorForTesting::CreateTransaction(::mojo::PendingAssociatedReceiver<IDBTransaction> transaction_receiver, int64_t transaction_id, const WTF::Vector<int64_t>& object_store_ids, IDBTransactionMode mode, IDBTransactionDurability durability) {
  GetForwardingInterface()->CreateTransaction(std::move(transaction_receiver), std::move(transaction_id), std::move(object_store_ids), std::move(mode), std::move(durability));
}
void IDBDatabaseInterceptorForTesting::Close() {
  GetForwardingInterface()->Close();
}
void IDBDatabaseInterceptorForTesting::VersionChangeIgnored() {
  GetForwardingInterface()->VersionChangeIgnored();
}
void IDBDatabaseInterceptorForTesting::BatchGetAll(int64_t transaction_id, int64_t object_store_id, int64_t index_id, WTF::Vector<IDBKeyRangePtr> key_ranges, uint32_t max_count, BatchGetAllCallback callback) {
  GetForwardingInterface()->BatchGetAll(std::move(transaction_id), std::move(object_store_id), std::move(index_id), std::move(key_ranges), std::move(max_count), std::move(callback));
}
void IDBDatabaseInterceptorForTesting::Get(int64_t transaction_id, int64_t object_store_id, int64_t index_id, IDBKeyRangePtr key_range, bool key_only, GetCallback callback) {
  GetForwardingInterface()->Get(std::move(transaction_id), std::move(object_store_id), std::move(index_id), std::move(key_range), std::move(key_only), std::move(callback));
}
void IDBDatabaseInterceptorForTesting::GetAll(int64_t transaction_id, int64_t object_store_id, int64_t index_id, IDBKeyRangePtr key_range, bool key_only, int64_t max_count, GetAllCallback callback) {
  GetForwardingInterface()->GetAll(std::move(transaction_id), std::move(object_store_id), std::move(index_id), std::move(key_range), std::move(key_only), std::move(max_count), std::move(callback));
}
void IDBDatabaseInterceptorForTesting::SetIndexKeys(int64_t transaction_id, int64_t object_store_id, ::std::unique_ptr<::blink::IDBKey> primary_key, WTF::Vector<::blink::IDBIndexKeys> index_keys) {
  GetForwardingInterface()->SetIndexKeys(std::move(transaction_id), std::move(object_store_id), std::move(primary_key), std::move(index_keys));
}
void IDBDatabaseInterceptorForTesting::SetIndexesReady(int64_t transaction_id, int64_t object_store_id, const WTF::Vector<int64_t>& index_ids) {
  GetForwardingInterface()->SetIndexesReady(std::move(transaction_id), std::move(object_store_id), std::move(index_ids));
}
void IDBDatabaseInterceptorForTesting::OpenCursor(int64_t transaction_id, int64_t object_store_id, int64_t index_id, IDBKeyRangePtr key_range, IDBCursorDirection direction, bool key_only, IDBTaskType task_type, OpenCursorCallback callback) {
  GetForwardingInterface()->OpenCursor(std::move(transaction_id), std::move(object_store_id), std::move(index_id), std::move(key_range), std::move(direction), std::move(key_only), std::move(task_type), std::move(callback));
}
void IDBDatabaseInterceptorForTesting::Count(int64_t transaction_id, int64_t object_store_id, int64_t index_id, IDBKeyRangePtr key_range, ::mojo::PendingAssociatedRemote<IDBCallbacks> pending_callbacks) {
  GetForwardingInterface()->Count(std::move(transaction_id), std::move(object_store_id), std::move(index_id), std::move(key_range), std::move(pending_callbacks));
}
void IDBDatabaseInterceptorForTesting::DeleteRange(int64_t transaction_id, int64_t object_store_id, IDBKeyRangePtr key_range, ::mojo::PendingAssociatedRemote<IDBCallbacks> pending_callbacks) {
  GetForwardingInterface()->DeleteRange(std::move(transaction_id), std::move(object_store_id), std::move(key_range), std::move(pending_callbacks));
}
void IDBDatabaseInterceptorForTesting::GetKeyGeneratorCurrentNumber(int64_t transaction_id, int64_t object_store_id, ::mojo::PendingAssociatedRemote<IDBCallbacks> pending_callbacks) {
  GetForwardingInterface()->GetKeyGeneratorCurrentNumber(std::move(transaction_id), std::move(object_store_id), std::move(pending_callbacks));
}
void IDBDatabaseInterceptorForTesting::Clear(int64_t transaction_id, int64_t object_store_id, ::mojo::PendingAssociatedRemote<IDBCallbacks> pending_callbacks) {
  GetForwardingInterface()->Clear(std::move(transaction_id), std::move(object_store_id), std::move(pending_callbacks));
}
void IDBDatabaseInterceptorForTesting::CreateIndex(int64_t transaction_id, int64_t object_store_id, int64_t index_id, const ::WTF::String& name, const ::blink::IDBKeyPath& key_path, bool unique, bool multi_entry) {
  GetForwardingInterface()->CreateIndex(std::move(transaction_id), std::move(object_store_id), std::move(index_id), std::move(name), std::move(key_path), std::move(unique), std::move(multi_entry));
}
void IDBDatabaseInterceptorForTesting::DeleteIndex(int64_t transaction_id, int64_t object_store_id, int64_t index_id) {
  GetForwardingInterface()->DeleteIndex(std::move(transaction_id), std::move(object_store_id), std::move(index_id));
}
void IDBDatabaseInterceptorForTesting::RenameIndex(int64_t transaction_id, int64_t object_store_id, int64_t index_id, const ::WTF::String& new_name) {
  GetForwardingInterface()->RenameIndex(std::move(transaction_id), std::move(object_store_id), std::move(index_id), std::move(new_name));
}
void IDBDatabaseInterceptorForTesting::Abort(int64_t transaction_id) {
  GetForwardingInterface()->Abort(std::move(transaction_id));
}
IDBDatabaseAsyncWaiter::IDBDatabaseAsyncWaiter(
    IDBDatabase* proxy) : proxy_(proxy) {}

IDBDatabaseAsyncWaiter::~IDBDatabaseAsyncWaiter() = default;

void IDBDatabaseAsyncWaiter::BatchGetAll(
    int64_t transaction_id, int64_t object_store_id, int64_t index_id, WTF::Vector<IDBKeyRangePtr> key_ranges, uint32_t max_count, IDBDatabaseBatchGetAllResultPtr* out_result) {
  base::RunLoop loop;
  proxy_->BatchGetAll(std::move(transaction_id),std::move(object_store_id),std::move(index_id),std::move(key_ranges),std::move(max_count),
      base::BindOnce(
          [](base::RunLoop* loop,
             IDBDatabaseBatchGetAllResultPtr* out_result
,
             IDBDatabaseBatchGetAllResultPtr result) {*out_result = std::move(result);
            loop->Quit();
          },
          &loop,
          out_result));
  loop.Run();
}
void IDBDatabaseAsyncWaiter::Get(
    int64_t transaction_id, int64_t object_store_id, int64_t index_id, IDBKeyRangePtr key_range, bool key_only, IDBDatabaseGetResultPtr* out_result) {
  base::RunLoop loop;
  proxy_->Get(std::move(transaction_id),std::move(object_store_id),std::move(index_id),std::move(key_range),std::move(key_only),
      base::BindOnce(
          [](base::RunLoop* loop,
             IDBDatabaseGetResultPtr* out_result
,
             IDBDatabaseGetResultPtr result) {*out_result = std::move(result);
            loop->Quit();
          },
          &loop,
          out_result));
  loop.Run();
}
void IDBDatabaseAsyncWaiter::GetAll(
    int64_t transaction_id, int64_t object_store_id, int64_t index_id, IDBKeyRangePtr key_range, bool key_only, int64_t max_count, ::mojo::PendingReceiver<IDBDatabaseGetAllResultSink>* out_receiver) {
  base::RunLoop loop;
  proxy_->GetAll(std::move(transaction_id),std::move(object_store_id),std::move(index_id),std::move(key_range),std::move(key_only),std::move(max_count),
      base::BindOnce(
          [](base::RunLoop* loop,
             ::mojo::PendingReceiver<IDBDatabaseGetAllResultSink>* out_receiver
,
             ::mojo::PendingReceiver<IDBDatabaseGetAllResultSink> receiver) {*out_receiver = std::move(receiver);
            loop->Quit();
          },
          &loop,
          out_receiver));
  loop.Run();
}
void IDBDatabaseAsyncWaiter::OpenCursor(
    int64_t transaction_id, int64_t object_store_id, int64_t index_id, IDBKeyRangePtr key_range, IDBCursorDirection direction, bool key_only, IDBTaskType task_type, IDBDatabaseOpenCursorResultPtr* out_result) {
  base::RunLoop loop;
  proxy_->OpenCursor(std::move(transaction_id),std::move(object_store_id),std::move(index_id),std::move(key_range),std::move(direction),std::move(key_only),std::move(task_type),
      base::BindOnce(
          [](base::RunLoop* loop,
             IDBDatabaseOpenCursorResultPtr* out_result
,
             IDBDatabaseOpenCursorResultPtr result) {*out_result = std::move(result);
            loop->Quit();
          },
          &loop,
          out_result));
  loop.Run();
}



void IDBFactoryInterceptorForTesting::GetDatabaseInfo(::mojo::PendingAssociatedRemote<IDBCallbacks> pending_callbacks) {
  GetForwardingInterface()->GetDatabaseInfo(std::move(pending_callbacks));
}
void IDBFactoryInterceptorForTesting::Open(::mojo::PendingAssociatedRemote<IDBCallbacks> pending_callbacks, ::mojo::PendingAssociatedRemote<IDBDatabaseCallbacks> database_callbacks, const ::WTF::String& name, int64_t version, ::mojo::PendingAssociatedReceiver<IDBTransaction> version_change_transaction_receiver, int64_t transaction_id) {
  GetForwardingInterface()->Open(std::move(pending_callbacks), std::move(database_callbacks), std::move(name), std::move(version), std::move(version_change_transaction_receiver), std::move(transaction_id));
}
void IDBFactoryInterceptorForTesting::DeleteDatabase(::mojo::PendingAssociatedRemote<IDBCallbacks> pending_callbacks, const ::WTF::String& name, bool force_close) {
  GetForwardingInterface()->DeleteDatabase(std::move(pending_callbacks), std::move(name), std::move(force_close));
}
void IDBFactoryInterceptorForTesting::AbortTransactionsAndCompactDatabase(AbortTransactionsAndCompactDatabaseCallback callback) {
  GetForwardingInterface()->AbortTransactionsAndCompactDatabase(std::move(callback));
}
void IDBFactoryInterceptorForTesting::AbortTransactionsForDatabase(AbortTransactionsForDatabaseCallback callback) {
  GetForwardingInterface()->AbortTransactionsForDatabase(std::move(callback));
}
IDBFactoryAsyncWaiter::IDBFactoryAsyncWaiter(
    IDBFactory* proxy) : proxy_(proxy) {}

IDBFactoryAsyncWaiter::~IDBFactoryAsyncWaiter() = default;

void IDBFactoryAsyncWaiter::AbortTransactionsAndCompactDatabase(
    IDBStatus* out_status) {
  base::RunLoop loop;
  proxy_->AbortTransactionsAndCompactDatabase(
      base::BindOnce(
          [](base::RunLoop* loop,
             IDBStatus* out_status
,
             IDBStatus status) {*out_status = std::move(status);
            loop->Quit();
          },
          &loop,
          out_status));
  loop.Run();
}
void IDBFactoryAsyncWaiter::AbortTransactionsForDatabase(
    IDBStatus* out_status) {
  base::RunLoop loop;
  proxy_->AbortTransactionsForDatabase(
      base::BindOnce(
          [](base::RunLoop* loop,
             IDBStatus* out_status
,
             IDBStatus status) {*out_status = std::move(status);
            loop->Quit();
          },
          &loop,
          out_status));
  loop.Run();
}





}  // namespace blink
}  // namespace mojom
}  // namespace blink


#if defined(__clang__)
#pragma clang diagnostic pop
#endif