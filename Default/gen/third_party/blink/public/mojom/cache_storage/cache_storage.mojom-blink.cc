// third_party/blink/public/mojom/cache_storage/cache_storage.mojom-blink.cc is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2013 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#if defined(__clang__)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-private-field"
#endif

#include "third_party/blink/public/mojom/cache_storage/cache_storage.mojom-blink.h"

#include <math.h>
#include <stdint.h>
#include <utility>

#include "base/debug/alias.h"
#include "base/hash/md5_constexpr.h"
#include "base/run_loop.h"
#include "base/strings/string_number_conversions.h"
#include "base/trace_event/trace_event.h"
#include "base/trace_event/typed_macros.h"
#include "mojo/public/cpp/bindings/lib/generated_code_util.h"
#include "mojo/public/cpp/bindings/lib/message_internal.h"
#include "mojo/public/cpp/bindings/lib/send_message_helper.h"
#include "mojo/public/cpp/bindings/lib/proxy_to_responder.h"
#include "mojo/public/cpp/bindings/lib/serialization_util.h"
#include "mojo/public/cpp/bindings/lib/unserialized_message_context.h"
#include "mojo/public/cpp/bindings/lib/validate_params.h"
#include "mojo/public/cpp/bindings/lib/validation_errors.h"
#include "mojo/public/cpp/bindings/mojo_buildflags.h"
#include "mojo/public/interfaces/bindings/interface_control_messages.mojom.h"
#include "third_party/perfetto/include/perfetto/tracing/traced_value.h"

#include "third_party/blink/public/mojom/cache_storage/cache_storage.mojom-params-data.h"
#include "third_party/blink/public/mojom/cache_storage/cache_storage.mojom-shared-message-ids.h"

#include "third_party/blink/public/mojom/cache_storage/cache_storage.mojom-blink-import-headers.h"
#include "third_party/blink/public/mojom/cache_storage/cache_storage.mojom-blink-test-utils.h"
#include "mojo/public/cpp/bindings/lib/wtf_serialization.h"


#ifndef THIRD_PARTY_BLINK_PUBLIC_MOJOM_CACHE_STORAGE_CACHE_STORAGE_MOJOM_BLINK_JUMBO_H_
#define THIRD_PARTY_BLINK_PUBLIC_MOJOM_CACHE_STORAGE_CACHE_STORAGE_MOJOM_BLINK_JUMBO_H_
#include "services/network/public/mojom/cookie_access_observer.mojom.h"
#include "services/network/public/mojom/devtools_observer.mojom.h"
#include "third_party/blink/renderer/platform/loader/fetch/fetch_api_request_body_mojom_traits.h"
#endif



namespace blink {
namespace mojom {
namespace blink {
CacheStorageVerboseError::CacheStorageVerboseError()
    : value(),
      message() {}

CacheStorageVerboseError::CacheStorageVerboseError(
    CacheStorageError value_in,
    const WTF::String& message_in)
    : value(std::move(value_in)),
      message(std::move(message_in)) {}

CacheStorageVerboseError::~CacheStorageVerboseError() = default;

void CacheStorageVerboseError::WriteIntoTrace(
    perfetto::TracedValue traced_context) const {
  [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "value"), this->value,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type CacheStorageError>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "message"), this->message,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const WTF::String&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool CacheStorageVerboseError::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
CacheQueryOptions::CacheQueryOptions()
    : ignore_search(false),
      ignore_method(false),
      ignore_vary(false) {}

CacheQueryOptions::CacheQueryOptions(
    bool ignore_search_in,
    bool ignore_method_in,
    bool ignore_vary_in)
    : ignore_search(std::move(ignore_search_in)),
      ignore_method(std::move(ignore_method_in)),
      ignore_vary(std::move(ignore_vary_in)) {}

CacheQueryOptions::~CacheQueryOptions() = default;
size_t CacheQueryOptions::Hash(size_t seed) const {
  seed = mojo::internal::WTFHash(seed, this->ignore_search);
  seed = mojo::internal::WTFHash(seed, this->ignore_method);
  seed = mojo::internal::WTFHash(seed, this->ignore_vary);
  return seed;
}

void CacheQueryOptions::WriteIntoTrace(
    perfetto::TracedValue traced_context) const {
  [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "ignore_search"), this->ignore_search,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type bool>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "ignore_method"), this->ignore_method,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type bool>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "ignore_vary"), this->ignore_vary,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type bool>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool CacheQueryOptions::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
MultiCacheQueryOptions::MultiCacheQueryOptions()
    : query_options(),
      cache_name() {}

MultiCacheQueryOptions::MultiCacheQueryOptions(
    CacheQueryOptionsPtr query_options_in,
    const ::WTF::String& cache_name_in)
    : query_options(std::move(query_options_in)),
      cache_name(std::move(cache_name_in)) {}

MultiCacheQueryOptions::~MultiCacheQueryOptions() = default;

void MultiCacheQueryOptions::WriteIntoTrace(
    perfetto::TracedValue traced_context) const {
  [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "query_options"), this->query_options,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type CacheQueryOptionsPtr>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "cache_name"), this->cache_name,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const ::WTF::String&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool MultiCacheQueryOptions::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
BatchOperation::BatchOperation()
    : operation_type(),
      request(),
      response(),
      match_options() {}

BatchOperation::BatchOperation(
    OperationType operation_type_in,
    ::blink::mojom::blink::FetchAPIRequestPtr request_in,
    ::blink::mojom::blink::FetchAPIResponsePtr response_in,
    CacheQueryOptionsPtr match_options_in)
    : operation_type(std::move(operation_type_in)),
      request(std::move(request_in)),
      response(std::move(response_in)),
      match_options(std::move(match_options_in)) {}

BatchOperation::~BatchOperation() = default;

void BatchOperation::WriteIntoTrace(
    perfetto::TracedValue traced_context) const {
  [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "operation_type"), this->operation_type,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type OperationType>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "request"), this->request,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type ::blink::mojom::blink::FetchAPIRequestPtr>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "response"), this->response,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type ::blink::mojom::blink::FetchAPIResponsePtr>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "match_options"), this->match_options,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type CacheQueryOptionsPtr>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool BatchOperation::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
EagerResponse::EagerResponse()
    : response(),
      pipe(),
      client_receiver() {}

EagerResponse::EagerResponse(
    ::blink::mojom::blink::FetchAPIResponsePtr response_in,
    ::mojo::ScopedDataPipeConsumerHandle pipe_in,
    ::mojo::PendingReceiver<::blink::mojom::blink::BlobReaderClient> client_receiver_in)
    : response(std::move(response_in)),
      pipe(std::move(pipe_in)),
      client_receiver(std::move(client_receiver_in)) {}

EagerResponse::~EagerResponse() = default;

void EagerResponse::WriteIntoTrace(
    perfetto::TracedValue traced_context) const {
  [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "response"), this->response,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type ::blink::mojom::blink::FetchAPIResponsePtr>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "pipe"), this->pipe,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type ::mojo::ScopedDataPipeConsumerHandle>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "client_receiver"), this->client_receiver,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type ::mojo::PendingReceiver<::blink::mojom::blink::BlobReaderClient>>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool EagerResponse::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
CacheEntry::CacheEntry()
    : request(),
      response() {}

CacheEntry::CacheEntry(
    ::blink::mojom::blink::FetchAPIRequestPtr request_in,
    ::blink::mojom::blink::FetchAPIResponsePtr response_in)
    : request(std::move(request_in)),
      response(std::move(response_in)) {}

CacheEntry::~CacheEntry() = default;

void CacheEntry::WriteIntoTrace(
    perfetto::TracedValue traced_context) const {
  [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "request"), this->request,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type ::blink::mojom::blink::FetchAPIRequestPtr>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "response"), this->response,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type ::blink::mojom::blink::FetchAPIResponsePtr>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool CacheEntry::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
OpenResult::OpenResult() : tag_(Tag::kStatus) {
  data_.status = CacheStorageError();
}

OpenResult::~OpenResult() {
  DestroyActive();
}


void OpenResult::set_status(
    CacheStorageError status) {
  if (tag_ != Tag::kStatus) {
    DestroyActive();
    tag_ = Tag::kStatus;
  }
  data_.status = status;
}
void OpenResult::set_cache(
    ::mojo::PendingAssociatedRemote<CacheStorageCache> cache) {
  if (tag_ == Tag::kCache) {
    *(data_.cache) = std::move(cache);
  } else {
    DestroyActive();
    tag_ = Tag::kCache;
    data_.cache = new ::mojo::PendingAssociatedRemote<CacheStorageCache>(
        std::move(cache));
  }
}

void OpenResult::DestroyActive() {
  switch (tag_) {

    case Tag::kStatus:

      break;
    case Tag::kCache:

      delete data_.cache;
      break;
  }
}

bool OpenResult::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context, false);
}
MatchResult::MatchResult() : tag_(Tag::kStatus) {
  data_.status = CacheStorageError();
}

MatchResult::~MatchResult() {
  DestroyActive();
}


void MatchResult::set_status(
    CacheStorageError status) {
  if (tag_ != Tag::kStatus) {
    DestroyActive();
    tag_ = Tag::kStatus;
  }
  data_.status = status;
}
void MatchResult::set_response(
    ::blink::mojom::blink::FetchAPIResponsePtr response) {
  if (tag_ == Tag::kResponse) {
    *(data_.response) = std::move(response);
  } else {
    DestroyActive();
    tag_ = Tag::kResponse;
    data_.response = new ::blink::mojom::blink::FetchAPIResponsePtr(
        std::move(response));
  }
}
void MatchResult::set_eager_response(
    EagerResponsePtr eager_response) {
  if (tag_ == Tag::kEagerResponse) {
    *(data_.eager_response) = std::move(eager_response);
  } else {
    DestroyActive();
    tag_ = Tag::kEagerResponse;
    data_.eager_response = new EagerResponsePtr(
        std::move(eager_response));
  }
}

void MatchResult::DestroyActive() {
  switch (tag_) {

    case Tag::kStatus:

      break;
    case Tag::kResponse:

      delete data_.response;
      break;
    case Tag::kEagerResponse:

      delete data_.eager_response;
      break;
  }
}

bool MatchResult::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context, false);
}
MatchAllResult::MatchAllResult() : tag_(Tag::kStatus) {
  data_.status = CacheStorageError();
}

MatchAllResult::~MatchAllResult() {
  DestroyActive();
}


void MatchAllResult::set_status(
    CacheStorageError status) {
  if (tag_ != Tag::kStatus) {
    DestroyActive();
    tag_ = Tag::kStatus;
  }
  data_.status = status;
}
void MatchAllResult::set_responses(
    WTF::Vector<::blink::mojom::blink::FetchAPIResponsePtr> responses) {
  if (tag_ == Tag::kResponses) {
    *(data_.responses) = std::move(responses);
  } else {
    DestroyActive();
    tag_ = Tag::kResponses;
    data_.responses = new WTF::Vector<::blink::mojom::blink::FetchAPIResponsePtr>(
        std::move(responses));
  }
}

void MatchAllResult::DestroyActive() {
  switch (tag_) {

    case Tag::kStatus:

      break;
    case Tag::kResponses:

      delete data_.responses;
      break;
  }
}

bool MatchAllResult::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context, false);
}
GetAllMatchedEntriesResult::GetAllMatchedEntriesResult() : tag_(Tag::kStatus) {
  data_.status = CacheStorageError();
}

GetAllMatchedEntriesResult::~GetAllMatchedEntriesResult() {
  DestroyActive();
}


void GetAllMatchedEntriesResult::set_status(
    CacheStorageError status) {
  if (tag_ != Tag::kStatus) {
    DestroyActive();
    tag_ = Tag::kStatus;
  }
  data_.status = status;
}
void GetAllMatchedEntriesResult::set_entries(
    WTF::Vector<CacheEntryPtr> entries) {
  if (tag_ == Tag::kEntries) {
    *(data_.entries) = std::move(entries);
  } else {
    DestroyActive();
    tag_ = Tag::kEntries;
    data_.entries = new WTF::Vector<CacheEntryPtr>(
        std::move(entries));
  }
}

void GetAllMatchedEntriesResult::DestroyActive() {
  switch (tag_) {

    case Tag::kStatus:

      break;
    case Tag::kEntries:

      delete data_.entries;
      break;
  }
}

bool GetAllMatchedEntriesResult::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context, false);
}
CacheKeysResult::CacheKeysResult() : tag_(Tag::kStatus) {
  data_.status = CacheStorageError();
}

CacheKeysResult::~CacheKeysResult() {
  DestroyActive();
}


void CacheKeysResult::set_status(
    CacheStorageError status) {
  if (tag_ != Tag::kStatus) {
    DestroyActive();
    tag_ = Tag::kStatus;
  }
  data_.status = status;
}
void CacheKeysResult::set_keys(
    WTF::Vector<::blink::mojom::blink::FetchAPIRequestPtr> keys) {
  if (tag_ == Tag::kKeys) {
    *(data_.keys) = std::move(keys);
  } else {
    DestroyActive();
    tag_ = Tag::kKeys;
    data_.keys = new WTF::Vector<::blink::mojom::blink::FetchAPIRequestPtr>(
        std::move(keys));
  }
}

void CacheKeysResult::DestroyActive() {
  switch (tag_) {

    case Tag::kStatus:

      break;
    case Tag::kKeys:

      delete data_.keys;
      break;
  }
}

bool CacheKeysResult::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context, false);
}
const char CacheStorageCache::Name_[] = "blink.mojom.CacheStorageCache";

CacheStorageCache::IPCStableHashFunction CacheStorageCache::MessageToMethodInfo_(mojo::Message& message) {
#if !BUILDFLAG(IS_FUCHSIA)
  switch (message.name()) {
    case internal::kCacheStorageCache_Match_Name: {
      return &CacheStorageCache::Match_Sym::IPCStableHash;
    }
    case internal::kCacheStorageCache_MatchAll_Name: {
      return &CacheStorageCache::MatchAll_Sym::IPCStableHash;
    }
    case internal::kCacheStorageCache_GetAllMatchedEntries_Name: {
      return &CacheStorageCache::GetAllMatchedEntries_Sym::IPCStableHash;
    }
    case internal::kCacheStorageCache_Keys_Name: {
      return &CacheStorageCache::Keys_Sym::IPCStableHash;
    }
    case internal::kCacheStorageCache_Batch_Name: {
      return &CacheStorageCache::Batch_Sym::IPCStableHash;
    }
    case internal::kCacheStorageCache_WriteSideData_Name: {
      return &CacheStorageCache::WriteSideData_Sym::IPCStableHash;
    }
  }
#endif  // !BUILDFLAG(IS_FUCHSIA)
  return nullptr;
}


const char* CacheStorageCache::MessageToMethodName_(mojo::Message& message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  bool is_response = message.has_flag(mojo::Message::kFlagIsResponse);
  if (!is_response) {
    switch (message.name()) {
      case internal::kCacheStorageCache_Match_Name:
            return "Receive blink::mojom::CacheStorageCache::Match";
      case internal::kCacheStorageCache_MatchAll_Name:
            return "Receive blink::mojom::CacheStorageCache::MatchAll";
      case internal::kCacheStorageCache_GetAllMatchedEntries_Name:
            return "Receive blink::mojom::CacheStorageCache::GetAllMatchedEntries";
      case internal::kCacheStorageCache_Keys_Name:
            return "Receive blink::mojom::CacheStorageCache::Keys";
      case internal::kCacheStorageCache_Batch_Name:
            return "Receive blink::mojom::CacheStorageCache::Batch";
      case internal::kCacheStorageCache_WriteSideData_Name:
            return "Receive blink::mojom::CacheStorageCache::WriteSideData";
    }
  } else {
    switch (message.name()) {
      case internal::kCacheStorageCache_Match_Name:
            return "Receive reply blink::mojom::CacheStorageCache::Match";
      case internal::kCacheStorageCache_MatchAll_Name:
            return "Receive reply blink::mojom::CacheStorageCache::MatchAll";
      case internal::kCacheStorageCache_GetAllMatchedEntries_Name:
            return "Receive reply blink::mojom::CacheStorageCache::GetAllMatchedEntries";
      case internal::kCacheStorageCache_Keys_Name:
            return "Receive reply blink::mojom::CacheStorageCache::Keys";
      case internal::kCacheStorageCache_Batch_Name:
            return "Receive reply blink::mojom::CacheStorageCache::Batch";
      case internal::kCacheStorageCache_WriteSideData_Name:
            return "Receive reply blink::mojom::CacheStorageCache::WriteSideData";
    }
  }
  return "Receive unknown mojo message";
#else
  bool is_response = message.has_flag(mojo::Message::kFlagIsResponse);
  if (is_response) {
    return "Receive mojo reply";
  } else {
    return "Receive mojo message";
  }
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
}

#if !BUILDFLAG(IS_FUCHSIA)
uint32_t CacheStorageCache::Match_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::CacheStorageCache::Match");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t CacheStorageCache::MatchAll_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::CacheStorageCache::MatchAll");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t CacheStorageCache::GetAllMatchedEntries_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::CacheStorageCache::GetAllMatchedEntries");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t CacheStorageCache::Keys_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::CacheStorageCache::Keys");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t CacheStorageCache::Batch_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::CacheStorageCache::Batch");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t CacheStorageCache::WriteSideData_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::CacheStorageCache::WriteSideData");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
# endif // !BUILDFLAG(IS_FUCHSIA)

class CacheStorageCache_Match_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  CacheStorageCache_Match_ForwardToCallback(
      CacheStorageCache::MatchCallback callback
      ) : callback_(std::move(callback)) {
  }

  CacheStorageCache_Match_ForwardToCallback(const CacheStorageCache_Match_ForwardToCallback&) = delete;
  CacheStorageCache_Match_ForwardToCallback& operator=(const CacheStorageCache_Match_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  CacheStorageCache::MatchCallback callback_;
};

class CacheStorageCache_MatchAll_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  CacheStorageCache_MatchAll_ForwardToCallback(
      CacheStorageCache::MatchAllCallback callback
      ) : callback_(std::move(callback)) {
  }

  CacheStorageCache_MatchAll_ForwardToCallback(const CacheStorageCache_MatchAll_ForwardToCallback&) = delete;
  CacheStorageCache_MatchAll_ForwardToCallback& operator=(const CacheStorageCache_MatchAll_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  CacheStorageCache::MatchAllCallback callback_;
};

class CacheStorageCache_GetAllMatchedEntries_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  CacheStorageCache_GetAllMatchedEntries_ForwardToCallback(
      CacheStorageCache::GetAllMatchedEntriesCallback callback
      ) : callback_(std::move(callback)) {
  }

  CacheStorageCache_GetAllMatchedEntries_ForwardToCallback(const CacheStorageCache_GetAllMatchedEntries_ForwardToCallback&) = delete;
  CacheStorageCache_GetAllMatchedEntries_ForwardToCallback& operator=(const CacheStorageCache_GetAllMatchedEntries_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  CacheStorageCache::GetAllMatchedEntriesCallback callback_;
};

class CacheStorageCache_Keys_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  CacheStorageCache_Keys_ForwardToCallback(
      CacheStorageCache::KeysCallback callback
      ) : callback_(std::move(callback)) {
  }

  CacheStorageCache_Keys_ForwardToCallback(const CacheStorageCache_Keys_ForwardToCallback&) = delete;
  CacheStorageCache_Keys_ForwardToCallback& operator=(const CacheStorageCache_Keys_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  CacheStorageCache::KeysCallback callback_;
};

class CacheStorageCache_Batch_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  CacheStorageCache_Batch_ForwardToCallback(
      CacheStorageCache::BatchCallback callback
      ) : callback_(std::move(callback)) {
  }

  CacheStorageCache_Batch_ForwardToCallback(const CacheStorageCache_Batch_ForwardToCallback&) = delete;
  CacheStorageCache_Batch_ForwardToCallback& operator=(const CacheStorageCache_Batch_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  CacheStorageCache::BatchCallback callback_;
};

class CacheStorageCache_WriteSideData_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  CacheStorageCache_WriteSideData_ForwardToCallback(
      CacheStorageCache::WriteSideDataCallback callback
      ) : callback_(std::move(callback)) {
  }

  CacheStorageCache_WriteSideData_ForwardToCallback(const CacheStorageCache_WriteSideData_ForwardToCallback&) = delete;
  CacheStorageCache_WriteSideData_ForwardToCallback& operator=(const CacheStorageCache_WriteSideData_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  CacheStorageCache::WriteSideDataCallback callback_;
};

CacheStorageCacheProxy::CacheStorageCacheProxy(mojo::MessageReceiverWithResponder* receiver)
    : receiver_(receiver) {
}

void CacheStorageCacheProxy::Match(
    ::blink::mojom::blink::FetchAPIRequestPtr in_request, CacheQueryOptionsPtr in_query_options, bool in_in_related_fetch_event, bool in_in_range_fetch_event, int64_t in_trace_id, MatchCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::CacheStorageCache::Match", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("request"), in_request,
                        "<value of type ::blink::mojom::blink::FetchAPIRequestPtr>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("query_options"), in_query_options,
                        "<value of type CacheQueryOptionsPtr>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("in_related_fetch_event"), in_in_related_fetch_event,
                        "<value of type bool>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("in_range_fetch_event"), in_in_range_fetch_event,
                        "<value of type bool>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("trace_id"), in_trace_id,
                        "<value of type int64_t>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kCacheStorageCache_Match_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::CacheStorageCache_Match_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->request)::BaseType> request_fragment(
          params.message());
  mojo::internal::Serialize<::blink::mojom::FetchAPIRequestDataView>(
      in_request, request_fragment);
  params->request.Set(
      request_fragment.is_null() ? nullptr : request_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->request.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null request in CacheStorageCache.Match request");
  mojo::internal::MessageFragment<
      typename decltype(params->query_options)::BaseType> query_options_fragment(
          params.message());
  mojo::internal::Serialize<::blink::mojom::CacheQueryOptionsDataView>(
      in_query_options, query_options_fragment);
  params->query_options.Set(
      query_options_fragment.is_null() ? nullptr : query_options_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->query_options.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null query_options in CacheStorageCache.Match request");
  params->in_related_fetch_event = in_in_related_fetch_event;
  params->in_range_fetch_event = in_in_range_fetch_event;
  params->trace_id = in_trace_id;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(CacheStorageCache::Name_);
  message.set_method_name("Match");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new CacheStorageCache_Match_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void CacheStorageCacheProxy::MatchAll(
    ::blink::mojom::blink::FetchAPIRequestPtr in_request, CacheQueryOptionsPtr in_query_options, int64_t in_trace_id, MatchAllCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::CacheStorageCache::MatchAll", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("request"), in_request,
                        "<value of type ::blink::mojom::blink::FetchAPIRequestPtr>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("query_options"), in_query_options,
                        "<value of type CacheQueryOptionsPtr>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("trace_id"), in_trace_id,
                        "<value of type int64_t>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kCacheStorageCache_MatchAll_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::CacheStorageCache_MatchAll_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->request)::BaseType> request_fragment(
          params.message());
  mojo::internal::Serialize<::blink::mojom::FetchAPIRequestDataView>(
      in_request, request_fragment);
  params->request.Set(
      request_fragment.is_null() ? nullptr : request_fragment.data());
  mojo::internal::MessageFragment<
      typename decltype(params->query_options)::BaseType> query_options_fragment(
          params.message());
  mojo::internal::Serialize<::blink::mojom::CacheQueryOptionsDataView>(
      in_query_options, query_options_fragment);
  params->query_options.Set(
      query_options_fragment.is_null() ? nullptr : query_options_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->query_options.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null query_options in CacheStorageCache.MatchAll request");
  params->trace_id = in_trace_id;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(CacheStorageCache::Name_);
  message.set_method_name("MatchAll");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new CacheStorageCache_MatchAll_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void CacheStorageCacheProxy::GetAllMatchedEntries(
    ::blink::mojom::blink::FetchAPIRequestPtr in_request, CacheQueryOptionsPtr in_query_options, int64_t in_trace_id, GetAllMatchedEntriesCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::CacheStorageCache::GetAllMatchedEntries", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("request"), in_request,
                        "<value of type ::blink::mojom::blink::FetchAPIRequestPtr>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("query_options"), in_query_options,
                        "<value of type CacheQueryOptionsPtr>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("trace_id"), in_trace_id,
                        "<value of type int64_t>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kCacheStorageCache_GetAllMatchedEntries_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::CacheStorageCache_GetAllMatchedEntries_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->request)::BaseType> request_fragment(
          params.message());
  mojo::internal::Serialize<::blink::mojom::FetchAPIRequestDataView>(
      in_request, request_fragment);
  params->request.Set(
      request_fragment.is_null() ? nullptr : request_fragment.data());
  mojo::internal::MessageFragment<
      typename decltype(params->query_options)::BaseType> query_options_fragment(
          params.message());
  mojo::internal::Serialize<::blink::mojom::CacheQueryOptionsDataView>(
      in_query_options, query_options_fragment);
  params->query_options.Set(
      query_options_fragment.is_null() ? nullptr : query_options_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->query_options.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null query_options in CacheStorageCache.GetAllMatchedEntries request");
  params->trace_id = in_trace_id;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(CacheStorageCache::Name_);
  message.set_method_name("GetAllMatchedEntries");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new CacheStorageCache_GetAllMatchedEntries_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void CacheStorageCacheProxy::Keys(
    ::blink::mojom::blink::FetchAPIRequestPtr in_request, CacheQueryOptionsPtr in_query_options, int64_t in_trace_id, KeysCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::CacheStorageCache::Keys", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("request"), in_request,
                        "<value of type ::blink::mojom::blink::FetchAPIRequestPtr>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("query_options"), in_query_options,
                        "<value of type CacheQueryOptionsPtr>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("trace_id"), in_trace_id,
                        "<value of type int64_t>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kCacheStorageCache_Keys_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::CacheStorageCache_Keys_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->request)::BaseType> request_fragment(
          params.message());
  mojo::internal::Serialize<::blink::mojom::FetchAPIRequestDataView>(
      in_request, request_fragment);
  params->request.Set(
      request_fragment.is_null() ? nullptr : request_fragment.data());
  mojo::internal::MessageFragment<
      typename decltype(params->query_options)::BaseType> query_options_fragment(
          params.message());
  mojo::internal::Serialize<::blink::mojom::CacheQueryOptionsDataView>(
      in_query_options, query_options_fragment);
  params->query_options.Set(
      query_options_fragment.is_null() ? nullptr : query_options_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->query_options.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null query_options in CacheStorageCache.Keys request");
  params->trace_id = in_trace_id;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(CacheStorageCache::Name_);
  message.set_method_name("Keys");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new CacheStorageCache_Keys_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void CacheStorageCacheProxy::Batch(
    WTF::Vector<BatchOperationPtr> in_batch_operations, int64_t in_trace_id, BatchCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::CacheStorageCache::Batch", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("batch_operations"), in_batch_operations,
                        "<value of type WTF::Vector<BatchOperationPtr>>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("trace_id"), in_trace_id,
                        "<value of type int64_t>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kCacheStorageCache_Batch_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::CacheStorageCache_Batch_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->batch_operations)::BaseType>
      batch_operations_fragment(params.message());
  const mojo::internal::ContainerValidateParams batch_operations_validate_params(
      0, false, nullptr);
  mojo::internal::Serialize<mojo::ArrayDataView<::blink::mojom::BatchOperationDataView>>(
      in_batch_operations, batch_operations_fragment, &batch_operations_validate_params);
  params->batch_operations.Set(
      batch_operations_fragment.is_null() ? nullptr : batch_operations_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->batch_operations.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null batch_operations in CacheStorageCache.Batch request");
  params->trace_id = in_trace_id;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(CacheStorageCache::Name_);
  message.set_method_name("Batch");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new CacheStorageCache_Batch_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void CacheStorageCacheProxy::WriteSideData(
    const ::blink::KURL& in_url, ::base::Time in_expected_response_time, ::mojo_base::BigBuffer in_data, int64_t in_trace_id, WriteSideDataCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::CacheStorageCache::WriteSideData", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("url"), in_url,
                        "<value of type const ::blink::KURL&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("expected_response_time"), in_expected_response_time,
                        "<value of type ::base::Time>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("data"), in_data,
                        "<value of type ::mojo_base::BigBuffer>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("trace_id"), in_trace_id,
                        "<value of type int64_t>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kCacheStorageCache_WriteSideData_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::CacheStorageCache_WriteSideData_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->url)::BaseType> url_fragment(
          params.message());
  mojo::internal::Serialize<::url::mojom::UrlDataView>(
      in_url, url_fragment);
  params->url.Set(
      url_fragment.is_null() ? nullptr : url_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->url.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null url in CacheStorageCache.WriteSideData request");
  mojo::internal::MessageFragment<
      typename decltype(params->expected_response_time)::BaseType> expected_response_time_fragment(
          params.message());
  mojo::internal::Serialize<::mojo_base::mojom::TimeDataView>(
      in_expected_response_time, expected_response_time_fragment);
  params->expected_response_time.Set(
      expected_response_time_fragment.is_null() ? nullptr : expected_response_time_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->expected_response_time.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null expected_response_time in CacheStorageCache.WriteSideData request");
  mojo::internal::MessageFragment<decltype(params->data)>
      data_fragment(params.message());
  data_fragment.Claim(&params->data);
  mojo::internal::Serialize<::mojo_base::mojom::BigBufferDataView>(
      in_data, data_fragment, true);
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->data.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null data in CacheStorageCache.WriteSideData request");
  params->trace_id = in_trace_id;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(CacheStorageCache::Name_);
  message.set_method_name("WriteSideData");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new CacheStorageCache_WriteSideData_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}
class CacheStorageCache_Match_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static CacheStorageCache::MatchCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<CacheStorageCache_Match_ProxyToResponder> proxy(
        new CacheStorageCache_Match_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&CacheStorageCache_Match_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~CacheStorageCache_Match_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  CacheStorageCache_Match_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "CacheStorageCache::MatchCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      MatchResultPtr in_result);
};

bool CacheStorageCache_Match_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::CacheStorageCache_Match_ResponseParams_Data* params =
      reinterpret_cast<
          internal::CacheStorageCache_Match_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  MatchResultPtr p_result{};
  CacheStorageCache_Match_ResponseParamsDataView input_data_view(params, message);
  
  if (success && !input_data_view.ReadResult(&p_result))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        CacheStorageCache::Name_, 0, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_result));
  return true;
}

void CacheStorageCache_Match_ProxyToResponder::Run(
    MatchResultPtr in_result) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send reply blink::mojom::CacheStorageCache::Match", "async_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("result"), in_result,
                        "<value of type MatchResultPtr>");
   });
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kCacheStorageCache_Match_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::CacheStorageCache_Match_ResponseParams_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<decltype(params->result)>
      result_fragment(params.message());
  result_fragment.Claim(&params->result);
  mojo::internal::Serialize<::blink::mojom::MatchResultDataView>(
      in_result, result_fragment, true);
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->result.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null result in ");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(CacheStorageCache::Name_);
  message.set_method_name("Match");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class CacheStorageCache_MatchAll_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static CacheStorageCache::MatchAllCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<CacheStorageCache_MatchAll_ProxyToResponder> proxy(
        new CacheStorageCache_MatchAll_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&CacheStorageCache_MatchAll_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~CacheStorageCache_MatchAll_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  CacheStorageCache_MatchAll_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "CacheStorageCache::MatchAllCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      MatchAllResultPtr in_result);
};

bool CacheStorageCache_MatchAll_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::CacheStorageCache_MatchAll_ResponseParams_Data* params =
      reinterpret_cast<
          internal::CacheStorageCache_MatchAll_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  MatchAllResultPtr p_result{};
  CacheStorageCache_MatchAll_ResponseParamsDataView input_data_view(params, message);
  
  if (success && !input_data_view.ReadResult(&p_result))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        CacheStorageCache::Name_, 1, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_result));
  return true;
}

void CacheStorageCache_MatchAll_ProxyToResponder::Run(
    MatchAllResultPtr in_result) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send reply blink::mojom::CacheStorageCache::MatchAll", "async_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("result"), in_result,
                        "<value of type MatchAllResultPtr>");
   });
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kCacheStorageCache_MatchAll_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::CacheStorageCache_MatchAll_ResponseParams_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<decltype(params->result)>
      result_fragment(params.message());
  result_fragment.Claim(&params->result);
  mojo::internal::Serialize<::blink::mojom::MatchAllResultDataView>(
      in_result, result_fragment, true);
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->result.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null result in ");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(CacheStorageCache::Name_);
  message.set_method_name("MatchAll");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class CacheStorageCache_GetAllMatchedEntries_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static CacheStorageCache::GetAllMatchedEntriesCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<CacheStorageCache_GetAllMatchedEntries_ProxyToResponder> proxy(
        new CacheStorageCache_GetAllMatchedEntries_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&CacheStorageCache_GetAllMatchedEntries_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~CacheStorageCache_GetAllMatchedEntries_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  CacheStorageCache_GetAllMatchedEntries_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "CacheStorageCache::GetAllMatchedEntriesCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      GetAllMatchedEntriesResultPtr in_result);
};

bool CacheStorageCache_GetAllMatchedEntries_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::CacheStorageCache_GetAllMatchedEntries_ResponseParams_Data* params =
      reinterpret_cast<
          internal::CacheStorageCache_GetAllMatchedEntries_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  GetAllMatchedEntriesResultPtr p_result{};
  CacheStorageCache_GetAllMatchedEntries_ResponseParamsDataView input_data_view(params, message);
  
  if (success && !input_data_view.ReadResult(&p_result))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        CacheStorageCache::Name_, 2, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_result));
  return true;
}

void CacheStorageCache_GetAllMatchedEntries_ProxyToResponder::Run(
    GetAllMatchedEntriesResultPtr in_result) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send reply blink::mojom::CacheStorageCache::GetAllMatchedEntries", "async_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("result"), in_result,
                        "<value of type GetAllMatchedEntriesResultPtr>");
   });
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kCacheStorageCache_GetAllMatchedEntries_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::CacheStorageCache_GetAllMatchedEntries_ResponseParams_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<decltype(params->result)>
      result_fragment(params.message());
  result_fragment.Claim(&params->result);
  mojo::internal::Serialize<::blink::mojom::GetAllMatchedEntriesResultDataView>(
      in_result, result_fragment, true);
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->result.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null result in ");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(CacheStorageCache::Name_);
  message.set_method_name("GetAllMatchedEntries");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class CacheStorageCache_Keys_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static CacheStorageCache::KeysCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<CacheStorageCache_Keys_ProxyToResponder> proxy(
        new CacheStorageCache_Keys_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&CacheStorageCache_Keys_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~CacheStorageCache_Keys_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  CacheStorageCache_Keys_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "CacheStorageCache::KeysCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      CacheKeysResultPtr in_result);
};

bool CacheStorageCache_Keys_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::CacheStorageCache_Keys_ResponseParams_Data* params =
      reinterpret_cast<
          internal::CacheStorageCache_Keys_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  CacheKeysResultPtr p_result{};
  CacheStorageCache_Keys_ResponseParamsDataView input_data_view(params, message);
  
  if (success && !input_data_view.ReadResult(&p_result))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        CacheStorageCache::Name_, 3, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_result));
  return true;
}

void CacheStorageCache_Keys_ProxyToResponder::Run(
    CacheKeysResultPtr in_result) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send reply blink::mojom::CacheStorageCache::Keys", "async_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("result"), in_result,
                        "<value of type CacheKeysResultPtr>");
   });
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kCacheStorageCache_Keys_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::CacheStorageCache_Keys_ResponseParams_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<decltype(params->result)>
      result_fragment(params.message());
  result_fragment.Claim(&params->result);
  mojo::internal::Serialize<::blink::mojom::CacheKeysResultDataView>(
      in_result, result_fragment, true);
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->result.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null result in ");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(CacheStorageCache::Name_);
  message.set_method_name("Keys");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class CacheStorageCache_Batch_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static CacheStorageCache::BatchCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<CacheStorageCache_Batch_ProxyToResponder> proxy(
        new CacheStorageCache_Batch_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&CacheStorageCache_Batch_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~CacheStorageCache_Batch_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  CacheStorageCache_Batch_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "CacheStorageCache::BatchCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      CacheStorageVerboseErrorPtr in_result);
};

bool CacheStorageCache_Batch_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::CacheStorageCache_Batch_ResponseParams_Data* params =
      reinterpret_cast<
          internal::CacheStorageCache_Batch_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  CacheStorageVerboseErrorPtr p_result{};
  CacheStorageCache_Batch_ResponseParamsDataView input_data_view(params, message);
  
  if (success && !input_data_view.ReadResult(&p_result))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        CacheStorageCache::Name_, 4, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_result));
  return true;
}

void CacheStorageCache_Batch_ProxyToResponder::Run(
    CacheStorageVerboseErrorPtr in_result) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send reply blink::mojom::CacheStorageCache::Batch", "async_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("result"), in_result,
                        "<value of type CacheStorageVerboseErrorPtr>");
   });
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kCacheStorageCache_Batch_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::CacheStorageCache_Batch_ResponseParams_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->result)::BaseType> result_fragment(
          params.message());
  mojo::internal::Serialize<::blink::mojom::CacheStorageVerboseErrorDataView>(
      in_result, result_fragment);
  params->result.Set(
      result_fragment.is_null() ? nullptr : result_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->result.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null result in ");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(CacheStorageCache::Name_);
  message.set_method_name("Batch");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class CacheStorageCache_WriteSideData_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static CacheStorageCache::WriteSideDataCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<CacheStorageCache_WriteSideData_ProxyToResponder> proxy(
        new CacheStorageCache_WriteSideData_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&CacheStorageCache_WriteSideData_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~CacheStorageCache_WriteSideData_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  CacheStorageCache_WriteSideData_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "CacheStorageCache::WriteSideDataCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      CacheStorageError in_result);
};

bool CacheStorageCache_WriteSideData_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::CacheStorageCache_WriteSideData_ResponseParams_Data* params =
      reinterpret_cast<
          internal::CacheStorageCache_WriteSideData_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  CacheStorageError p_result{};
  CacheStorageCache_WriteSideData_ResponseParamsDataView input_data_view(params, message);
  
  if (success && !input_data_view.ReadResult(&p_result))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        CacheStorageCache::Name_, 5, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_result));
  return true;
}

void CacheStorageCache_WriteSideData_ProxyToResponder::Run(
    CacheStorageError in_result) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send reply blink::mojom::CacheStorageCache::WriteSideData", "async_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("result"), in_result,
                        "<value of type CacheStorageError>");
   });
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kCacheStorageCache_WriteSideData_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::CacheStorageCache_WriteSideData_ResponseParams_Data> params(
          message);
  params.Allocate();
  mojo::internal::Serialize<::blink::mojom::CacheStorageError>(
      in_result, &params->result);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(CacheStorageCache::Name_);
  message.set_method_name("WriteSideData");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}

// static
bool CacheStorageCacheStubDispatch::Accept(
    CacheStorageCache* impl,
    mojo::Message* message) {
  switch (message->header()->name) {
    case internal::kCacheStorageCache_Match_Name: {
      break;
    }
    case internal::kCacheStorageCache_MatchAll_Name: {
      break;
    }
    case internal::kCacheStorageCache_GetAllMatchedEntries_Name: {
      break;
    }
    case internal::kCacheStorageCache_Keys_Name: {
      break;
    }
    case internal::kCacheStorageCache_Batch_Name: {
      break;
    }
    case internal::kCacheStorageCache_WriteSideData_Name: {
      break;
    }
  }
  return false;
}

// static
bool CacheStorageCacheStubDispatch::AcceptWithResponder(
    CacheStorageCache* impl,
    mojo::Message* message,
    std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
  [[maybe_unused]] const bool message_is_sync =
      message->has_flag(mojo::Message::kFlagIsSync);
  [[maybe_unused]] const uint64_t request_id = message->request_id();
  switch (message->header()->name) {
    case internal::kCacheStorageCache_Match_Name: {

      internal::CacheStorageCache_Match_Params_Data* params =
          reinterpret_cast<
              internal::CacheStorageCache_Match_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      ::blink::mojom::blink::FetchAPIRequestPtr p_request{};
      CacheQueryOptionsPtr p_query_options{};
      bool p_in_related_fetch_event{};
      bool p_in_range_fetch_event{};
      int64_t p_trace_id{};
      CacheStorageCache_Match_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadRequest(&p_request))
        success = false;
      if (success && !input_data_view.ReadQueryOptions(&p_query_options))
        success = false;
      if (success)
        p_in_related_fetch_event = input_data_view.in_related_fetch_event();
      if (success)
        p_in_range_fetch_event = input_data_view.in_range_fetch_event();
      if (success)
        p_trace_id = input_data_view.trace_id();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            CacheStorageCache::Name_, 0, false);
        return false;
      }
      CacheStorageCache::MatchCallback callback =
          CacheStorageCache_Match_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->Match(
std::move(p_request), 
std::move(p_query_options), 
std::move(p_in_related_fetch_event), 
std::move(p_in_range_fetch_event), 
std::move(p_trace_id), std::move(callback));
      return true;
    }
    case internal::kCacheStorageCache_MatchAll_Name: {

      internal::CacheStorageCache_MatchAll_Params_Data* params =
          reinterpret_cast<
              internal::CacheStorageCache_MatchAll_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      ::blink::mojom::blink::FetchAPIRequestPtr p_request{};
      CacheQueryOptionsPtr p_query_options{};
      int64_t p_trace_id{};
      CacheStorageCache_MatchAll_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadRequest(&p_request))
        success = false;
      if (success && !input_data_view.ReadQueryOptions(&p_query_options))
        success = false;
      if (success)
        p_trace_id = input_data_view.trace_id();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            CacheStorageCache::Name_, 1, false);
        return false;
      }
      CacheStorageCache::MatchAllCallback callback =
          CacheStorageCache_MatchAll_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->MatchAll(
std::move(p_request), 
std::move(p_query_options), 
std::move(p_trace_id), std::move(callback));
      return true;
    }
    case internal::kCacheStorageCache_GetAllMatchedEntries_Name: {

      internal::CacheStorageCache_GetAllMatchedEntries_Params_Data* params =
          reinterpret_cast<
              internal::CacheStorageCache_GetAllMatchedEntries_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      ::blink::mojom::blink::FetchAPIRequestPtr p_request{};
      CacheQueryOptionsPtr p_query_options{};
      int64_t p_trace_id{};
      CacheStorageCache_GetAllMatchedEntries_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadRequest(&p_request))
        success = false;
      if (success && !input_data_view.ReadQueryOptions(&p_query_options))
        success = false;
      if (success)
        p_trace_id = input_data_view.trace_id();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            CacheStorageCache::Name_, 2, false);
        return false;
      }
      CacheStorageCache::GetAllMatchedEntriesCallback callback =
          CacheStorageCache_GetAllMatchedEntries_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->GetAllMatchedEntries(
std::move(p_request), 
std::move(p_query_options), 
std::move(p_trace_id), std::move(callback));
      return true;
    }
    case internal::kCacheStorageCache_Keys_Name: {

      internal::CacheStorageCache_Keys_Params_Data* params =
          reinterpret_cast<
              internal::CacheStorageCache_Keys_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      ::blink::mojom::blink::FetchAPIRequestPtr p_request{};
      CacheQueryOptionsPtr p_query_options{};
      int64_t p_trace_id{};
      CacheStorageCache_Keys_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadRequest(&p_request))
        success = false;
      if (success && !input_data_view.ReadQueryOptions(&p_query_options))
        success = false;
      if (success)
        p_trace_id = input_data_view.trace_id();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            CacheStorageCache::Name_, 3, false);
        return false;
      }
      CacheStorageCache::KeysCallback callback =
          CacheStorageCache_Keys_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->Keys(
std::move(p_request), 
std::move(p_query_options), 
std::move(p_trace_id), std::move(callback));
      return true;
    }
    case internal::kCacheStorageCache_Batch_Name: {

      internal::CacheStorageCache_Batch_Params_Data* params =
          reinterpret_cast<
              internal::CacheStorageCache_Batch_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      WTF::Vector<BatchOperationPtr> p_batch_operations{};
      int64_t p_trace_id{};
      CacheStorageCache_Batch_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadBatchOperations(&p_batch_operations))
        success = false;
      if (success)
        p_trace_id = input_data_view.trace_id();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            CacheStorageCache::Name_, 4, false);
        return false;
      }
      CacheStorageCache::BatchCallback callback =
          CacheStorageCache_Batch_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->Batch(
std::move(p_batch_operations), 
std::move(p_trace_id), std::move(callback));
      return true;
    }
    case internal::kCacheStorageCache_WriteSideData_Name: {

      internal::CacheStorageCache_WriteSideData_Params_Data* params =
          reinterpret_cast<
              internal::CacheStorageCache_WriteSideData_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      ::blink::KURL p_url{};
      ::base::Time p_expected_response_time{};
      ::mojo_base::BigBuffer p_data{};
      int64_t p_trace_id{};
      CacheStorageCache_WriteSideData_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadUrl(&p_url))
        success = false;
      if (success && !input_data_view.ReadExpectedResponseTime(&p_expected_response_time))
        success = false;
      if (success && !input_data_view.ReadData(&p_data))
        success = false;
      if (success)
        p_trace_id = input_data_view.trace_id();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            CacheStorageCache::Name_, 5, false);
        return false;
      }
      CacheStorageCache::WriteSideDataCallback callback =
          CacheStorageCache_WriteSideData_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->WriteSideData(
std::move(p_url), 
std::move(p_expected_response_time), 
std::move(p_data), 
std::move(p_trace_id), std::move(callback));
      return true;
    }
  }
  return false;
}


static const mojo::internal::GenericValidationInfo kCacheStorageCacheValidationInfo[] = {
    {&internal::CacheStorageCache_Match_Params_Data::Validate,
     &internal::CacheStorageCache_Match_ResponseParams_Data::Validate},
    {&internal::CacheStorageCache_MatchAll_Params_Data::Validate,
     &internal::CacheStorageCache_MatchAll_ResponseParams_Data::Validate},
    {&internal::CacheStorageCache_GetAllMatchedEntries_Params_Data::Validate,
     &internal::CacheStorageCache_GetAllMatchedEntries_ResponseParams_Data::Validate},
    {&internal::CacheStorageCache_Keys_Params_Data::Validate,
     &internal::CacheStorageCache_Keys_ResponseParams_Data::Validate},
    {&internal::CacheStorageCache_Batch_Params_Data::Validate,
     &internal::CacheStorageCache_Batch_ResponseParams_Data::Validate},
    {&internal::CacheStorageCache_WriteSideData_Params_Data::Validate,
     &internal::CacheStorageCache_WriteSideData_ResponseParams_Data::Validate},
};

bool CacheStorageCacheRequestValidator::Accept(mojo::Message* message) {
  const char* name = ::blink::mojom::blink::CacheStorageCache::Name_;
  return mojo::internal::ValidateRequestGenericPacked(message, name, kCacheStorageCacheValidationInfo);
}

bool CacheStorageCacheResponseValidator::Accept(mojo::Message* message) {
  const char* name = ::blink::mojom::blink::CacheStorageCache::Name_;
  return mojo::internal::ValidateResponseGenericPacked(message, name, kCacheStorageCacheValidationInfo);
}
const char CacheStorage::Name_[] = "blink.mojom.CacheStorage";

CacheStorage::IPCStableHashFunction CacheStorage::MessageToMethodInfo_(mojo::Message& message) {
#if !BUILDFLAG(IS_FUCHSIA)
  switch (message.name()) {
    case internal::kCacheStorage_Has_Name: {
      return &CacheStorage::Has_Sym::IPCStableHash;
    }
    case internal::kCacheStorage_Delete_Name: {
      return &CacheStorage::Delete_Sym::IPCStableHash;
    }
    case internal::kCacheStorage_Keys_Name: {
      return &CacheStorage::Keys_Sym::IPCStableHash;
    }
    case internal::kCacheStorage_Match_Name: {
      return &CacheStorage::Match_Sym::IPCStableHash;
    }
    case internal::kCacheStorage_Open_Name: {
      return &CacheStorage::Open_Sym::IPCStableHash;
    }
  }
#endif  // !BUILDFLAG(IS_FUCHSIA)
  return nullptr;
}


const char* CacheStorage::MessageToMethodName_(mojo::Message& message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  bool is_response = message.has_flag(mojo::Message::kFlagIsResponse);
  if (!is_response) {
    switch (message.name()) {
      case internal::kCacheStorage_Has_Name:
            return "Receive blink::mojom::CacheStorage::Has";
      case internal::kCacheStorage_Delete_Name:
            return "Receive blink::mojom::CacheStorage::Delete";
      case internal::kCacheStorage_Keys_Name:
            return "Receive blink::mojom::CacheStorage::Keys";
      case internal::kCacheStorage_Match_Name:
            return "Receive blink::mojom::CacheStorage::Match";
      case internal::kCacheStorage_Open_Name:
            return "Receive blink::mojom::CacheStorage::Open";
    }
  } else {
    switch (message.name()) {
      case internal::kCacheStorage_Has_Name:
            return "Receive reply blink::mojom::CacheStorage::Has";
      case internal::kCacheStorage_Delete_Name:
            return "Receive reply blink::mojom::CacheStorage::Delete";
      case internal::kCacheStorage_Keys_Name:
            return "Receive reply blink::mojom::CacheStorage::Keys";
      case internal::kCacheStorage_Match_Name:
            return "Receive reply blink::mojom::CacheStorage::Match";
      case internal::kCacheStorage_Open_Name:
            return "Receive reply blink::mojom::CacheStorage::Open";
    }
  }
  return "Receive unknown mojo message";
#else
  bool is_response = message.has_flag(mojo::Message::kFlagIsResponse);
  if (is_response) {
    return "Receive mojo reply";
  } else {
    return "Receive mojo message";
  }
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
}

#if !BUILDFLAG(IS_FUCHSIA)
uint32_t CacheStorage::Has_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::CacheStorage::Has");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t CacheStorage::Delete_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::CacheStorage::Delete");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t CacheStorage::Keys_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::CacheStorage::Keys");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t CacheStorage::Match_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::CacheStorage::Match");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t CacheStorage::Open_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::CacheStorage::Open");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
# endif // !BUILDFLAG(IS_FUCHSIA)

class CacheStorage_Has_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  CacheStorage_Has_ForwardToCallback(
      CacheStorage::HasCallback callback
      ) : callback_(std::move(callback)) {
  }

  CacheStorage_Has_ForwardToCallback(const CacheStorage_Has_ForwardToCallback&) = delete;
  CacheStorage_Has_ForwardToCallback& operator=(const CacheStorage_Has_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  CacheStorage::HasCallback callback_;
};

class CacheStorage_Delete_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  CacheStorage_Delete_ForwardToCallback(
      CacheStorage::DeleteCallback callback
      ) : callback_(std::move(callback)) {
  }

  CacheStorage_Delete_ForwardToCallback(const CacheStorage_Delete_ForwardToCallback&) = delete;
  CacheStorage_Delete_ForwardToCallback& operator=(const CacheStorage_Delete_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  CacheStorage::DeleteCallback callback_;
};

class CacheStorage_Keys_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  CacheStorage_Keys_ForwardToCallback(
      CacheStorage::KeysCallback callback
      ) : callback_(std::move(callback)) {
  }

  CacheStorage_Keys_ForwardToCallback(const CacheStorage_Keys_ForwardToCallback&) = delete;
  CacheStorage_Keys_ForwardToCallback& operator=(const CacheStorage_Keys_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  CacheStorage::KeysCallback callback_;
};

class CacheStorage_Match_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  CacheStorage_Match_ForwardToCallback(
      CacheStorage::MatchCallback callback
      ) : callback_(std::move(callback)) {
  }

  CacheStorage_Match_ForwardToCallback(const CacheStorage_Match_ForwardToCallback&) = delete;
  CacheStorage_Match_ForwardToCallback& operator=(const CacheStorage_Match_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  CacheStorage::MatchCallback callback_;
};

class CacheStorage_Open_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  CacheStorage_Open_ForwardToCallback(
      CacheStorage::OpenCallback callback
      ) : callback_(std::move(callback)) {
  }

  CacheStorage_Open_ForwardToCallback(const CacheStorage_Open_ForwardToCallback&) = delete;
  CacheStorage_Open_ForwardToCallback& operator=(const CacheStorage_Open_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  CacheStorage::OpenCallback callback_;
};

CacheStorageProxy::CacheStorageProxy(mojo::MessageReceiverWithResponder* receiver)
    : receiver_(receiver) {
}

void CacheStorageProxy::Has(
    const ::WTF::String& in_cache_name, int64_t in_trace_id, HasCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::CacheStorage::Has", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("cache_name"), in_cache_name,
                        "<value of type const ::WTF::String&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("trace_id"), in_trace_id,
                        "<value of type int64_t>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kCacheStorage_Has_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::CacheStorage_Has_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->cache_name)::BaseType> cache_name_fragment(
          params.message());
  mojo::internal::Serialize<::mojo_base::mojom::String16DataView>(
      in_cache_name, cache_name_fragment);
  params->cache_name.Set(
      cache_name_fragment.is_null() ? nullptr : cache_name_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->cache_name.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null cache_name in CacheStorage.Has request");
  params->trace_id = in_trace_id;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(CacheStorage::Name_);
  message.set_method_name("Has");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new CacheStorage_Has_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void CacheStorageProxy::Delete(
    const ::WTF::String& in_cache_name, int64_t in_trace_id, DeleteCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::CacheStorage::Delete", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("cache_name"), in_cache_name,
                        "<value of type const ::WTF::String&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("trace_id"), in_trace_id,
                        "<value of type int64_t>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kCacheStorage_Delete_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::CacheStorage_Delete_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->cache_name)::BaseType> cache_name_fragment(
          params.message());
  mojo::internal::Serialize<::mojo_base::mojom::String16DataView>(
      in_cache_name, cache_name_fragment);
  params->cache_name.Set(
      cache_name_fragment.is_null() ? nullptr : cache_name_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->cache_name.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null cache_name in CacheStorage.Delete request");
  params->trace_id = in_trace_id;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(CacheStorage::Name_);
  message.set_method_name("Delete");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new CacheStorage_Delete_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void CacheStorageProxy::Keys(
    int64_t in_trace_id, KeysCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::CacheStorage::Keys", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("trace_id"), in_trace_id,
                        "<value of type int64_t>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kCacheStorage_Keys_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::CacheStorage_Keys_Params_Data> params(
          message);
  params.Allocate();
  params->trace_id = in_trace_id;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(CacheStorage::Name_);
  message.set_method_name("Keys");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new CacheStorage_Keys_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void CacheStorageProxy::Match(
    ::blink::mojom::blink::FetchAPIRequestPtr in_request, MultiCacheQueryOptionsPtr in_match_options, bool in_in_related_fetch_event, bool in_in_range_fetch_event, int64_t in_trace_id, MatchCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::CacheStorage::Match", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("request"), in_request,
                        "<value of type ::blink::mojom::blink::FetchAPIRequestPtr>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("match_options"), in_match_options,
                        "<value of type MultiCacheQueryOptionsPtr>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("in_related_fetch_event"), in_in_related_fetch_event,
                        "<value of type bool>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("in_range_fetch_event"), in_in_range_fetch_event,
                        "<value of type bool>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("trace_id"), in_trace_id,
                        "<value of type int64_t>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kCacheStorage_Match_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::CacheStorage_Match_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->request)::BaseType> request_fragment(
          params.message());
  mojo::internal::Serialize<::blink::mojom::FetchAPIRequestDataView>(
      in_request, request_fragment);
  params->request.Set(
      request_fragment.is_null() ? nullptr : request_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->request.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null request in CacheStorage.Match request");
  mojo::internal::MessageFragment<
      typename decltype(params->match_options)::BaseType> match_options_fragment(
          params.message());
  mojo::internal::Serialize<::blink::mojom::MultiCacheQueryOptionsDataView>(
      in_match_options, match_options_fragment);
  params->match_options.Set(
      match_options_fragment.is_null() ? nullptr : match_options_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->match_options.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null match_options in CacheStorage.Match request");
  params->in_related_fetch_event = in_in_related_fetch_event;
  params->in_range_fetch_event = in_in_range_fetch_event;
  params->trace_id = in_trace_id;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(CacheStorage::Name_);
  message.set_method_name("Match");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new CacheStorage_Match_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void CacheStorageProxy::Open(
    const ::WTF::String& in_cache_name, int64_t in_trace_id, OpenCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::CacheStorage::Open", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("cache_name"), in_cache_name,
                        "<value of type const ::WTF::String&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("trace_id"), in_trace_id,
                        "<value of type int64_t>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kCacheStorage_Open_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::CacheStorage_Open_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->cache_name)::BaseType> cache_name_fragment(
          params.message());
  mojo::internal::Serialize<::mojo_base::mojom::String16DataView>(
      in_cache_name, cache_name_fragment);
  params->cache_name.Set(
      cache_name_fragment.is_null() ? nullptr : cache_name_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->cache_name.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null cache_name in CacheStorage.Open request");
  params->trace_id = in_trace_id;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(CacheStorage::Name_);
  message.set_method_name("Open");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new CacheStorage_Open_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}
class CacheStorage_Has_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static CacheStorage::HasCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<CacheStorage_Has_ProxyToResponder> proxy(
        new CacheStorage_Has_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&CacheStorage_Has_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~CacheStorage_Has_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  CacheStorage_Has_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "CacheStorage::HasCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      CacheStorageError in_result);
};

bool CacheStorage_Has_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::CacheStorage_Has_ResponseParams_Data* params =
      reinterpret_cast<
          internal::CacheStorage_Has_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  CacheStorageError p_result{};
  CacheStorage_Has_ResponseParamsDataView input_data_view(params, message);
  
  if (success && !input_data_view.ReadResult(&p_result))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        CacheStorage::Name_, 0, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_result));
  return true;
}

void CacheStorage_Has_ProxyToResponder::Run(
    CacheStorageError in_result) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send reply blink::mojom::CacheStorage::Has", "async_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("result"), in_result,
                        "<value of type CacheStorageError>");
   });
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kCacheStorage_Has_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::CacheStorage_Has_ResponseParams_Data> params(
          message);
  params.Allocate();
  mojo::internal::Serialize<::blink::mojom::CacheStorageError>(
      in_result, &params->result);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(CacheStorage::Name_);
  message.set_method_name("Has");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class CacheStorage_Delete_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static CacheStorage::DeleteCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<CacheStorage_Delete_ProxyToResponder> proxy(
        new CacheStorage_Delete_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&CacheStorage_Delete_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~CacheStorage_Delete_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  CacheStorage_Delete_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "CacheStorage::DeleteCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      CacheStorageError in_result);
};

bool CacheStorage_Delete_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::CacheStorage_Delete_ResponseParams_Data* params =
      reinterpret_cast<
          internal::CacheStorage_Delete_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  CacheStorageError p_result{};
  CacheStorage_Delete_ResponseParamsDataView input_data_view(params, message);
  
  if (success && !input_data_view.ReadResult(&p_result))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        CacheStorage::Name_, 1, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_result));
  return true;
}

void CacheStorage_Delete_ProxyToResponder::Run(
    CacheStorageError in_result) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send reply blink::mojom::CacheStorage::Delete", "async_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("result"), in_result,
                        "<value of type CacheStorageError>");
   });
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kCacheStorage_Delete_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::CacheStorage_Delete_ResponseParams_Data> params(
          message);
  params.Allocate();
  mojo::internal::Serialize<::blink::mojom::CacheStorageError>(
      in_result, &params->result);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(CacheStorage::Name_);
  message.set_method_name("Delete");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class CacheStorage_Keys_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static CacheStorage::KeysCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<CacheStorage_Keys_ProxyToResponder> proxy(
        new CacheStorage_Keys_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&CacheStorage_Keys_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~CacheStorage_Keys_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  CacheStorage_Keys_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "CacheStorage::KeysCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      const WTF::Vector<::WTF::String>& in_keys);
};

bool CacheStorage_Keys_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::CacheStorage_Keys_ResponseParams_Data* params =
      reinterpret_cast<
          internal::CacheStorage_Keys_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  WTF::Vector<::WTF::String> p_keys{};
  CacheStorage_Keys_ResponseParamsDataView input_data_view(params, message);
  
  if (success && !input_data_view.ReadKeys(&p_keys))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        CacheStorage::Name_, 2, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_keys));
  return true;
}

void CacheStorage_Keys_ProxyToResponder::Run(
    const WTF::Vector<::WTF::String>& in_keys) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send reply blink::mojom::CacheStorage::Keys", "async_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("keys"), in_keys,
                        "<value of type const WTF::Vector<::WTF::String>&>");
   });
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kCacheStorage_Keys_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::CacheStorage_Keys_ResponseParams_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->keys)::BaseType>
      keys_fragment(params.message());
  const mojo::internal::ContainerValidateParams keys_validate_params(
      0, false, nullptr);
  mojo::internal::Serialize<mojo::ArrayDataView<::mojo_base::mojom::String16DataView>>(
      in_keys, keys_fragment, &keys_validate_params);
  params->keys.Set(
      keys_fragment.is_null() ? nullptr : keys_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->keys.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null keys in ");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(CacheStorage::Name_);
  message.set_method_name("Keys");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class CacheStorage_Match_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static CacheStorage::MatchCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<CacheStorage_Match_ProxyToResponder> proxy(
        new CacheStorage_Match_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&CacheStorage_Match_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~CacheStorage_Match_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  CacheStorage_Match_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "CacheStorage::MatchCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      MatchResultPtr in_result);
};

bool CacheStorage_Match_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::CacheStorage_Match_ResponseParams_Data* params =
      reinterpret_cast<
          internal::CacheStorage_Match_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  MatchResultPtr p_result{};
  CacheStorage_Match_ResponseParamsDataView input_data_view(params, message);
  
  if (success && !input_data_view.ReadResult(&p_result))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        CacheStorage::Name_, 3, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_result));
  return true;
}

void CacheStorage_Match_ProxyToResponder::Run(
    MatchResultPtr in_result) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send reply blink::mojom::CacheStorage::Match", "async_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("result"), in_result,
                        "<value of type MatchResultPtr>");
   });
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kCacheStorage_Match_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::CacheStorage_Match_ResponseParams_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<decltype(params->result)>
      result_fragment(params.message());
  result_fragment.Claim(&params->result);
  mojo::internal::Serialize<::blink::mojom::MatchResultDataView>(
      in_result, result_fragment, true);
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->result.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null result in ");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(CacheStorage::Name_);
  message.set_method_name("Match");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class CacheStorage_Open_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static CacheStorage::OpenCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<CacheStorage_Open_ProxyToResponder> proxy(
        new CacheStorage_Open_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&CacheStorage_Open_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~CacheStorage_Open_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  CacheStorage_Open_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "CacheStorage::OpenCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      OpenResultPtr in_result);
};

bool CacheStorage_Open_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::CacheStorage_Open_ResponseParams_Data* params =
      reinterpret_cast<
          internal::CacheStorage_Open_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  OpenResultPtr p_result{};
  CacheStorage_Open_ResponseParamsDataView input_data_view(params, message);
  
  if (success && !input_data_view.ReadResult(&p_result))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        CacheStorage::Name_, 4, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_result));
  return true;
}

void CacheStorage_Open_ProxyToResponder::Run(
    OpenResultPtr in_result) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send reply blink::mojom::CacheStorage::Open", "async_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("result"), in_result,
                        "<value of type OpenResultPtr>");
   });
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kCacheStorage_Open_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::CacheStorage_Open_ResponseParams_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<decltype(params->result)>
      result_fragment(params.message());
  result_fragment.Claim(&params->result);
  mojo::internal::Serialize<::blink::mojom::OpenResultDataView>(
      in_result, result_fragment, true);
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->result.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null result in ");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(CacheStorage::Name_);
  message.set_method_name("Open");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}

// static
bool CacheStorageStubDispatch::Accept(
    CacheStorage* impl,
    mojo::Message* message) {
  switch (message->header()->name) {
    case internal::kCacheStorage_Has_Name: {
      break;
    }
    case internal::kCacheStorage_Delete_Name: {
      break;
    }
    case internal::kCacheStorage_Keys_Name: {
      break;
    }
    case internal::kCacheStorage_Match_Name: {
      break;
    }
    case internal::kCacheStorage_Open_Name: {
      break;
    }
  }
  return false;
}

// static
bool CacheStorageStubDispatch::AcceptWithResponder(
    CacheStorage* impl,
    mojo::Message* message,
    std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
  [[maybe_unused]] const bool message_is_sync =
      message->has_flag(mojo::Message::kFlagIsSync);
  [[maybe_unused]] const uint64_t request_id = message->request_id();
  switch (message->header()->name) {
    case internal::kCacheStorage_Has_Name: {

      internal::CacheStorage_Has_Params_Data* params =
          reinterpret_cast<
              internal::CacheStorage_Has_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      ::WTF::String p_cache_name{};
      int64_t p_trace_id{};
      CacheStorage_Has_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadCacheName(&p_cache_name))
        success = false;
      if (success)
        p_trace_id = input_data_view.trace_id();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            CacheStorage::Name_, 0, false);
        return false;
      }
      CacheStorage::HasCallback callback =
          CacheStorage_Has_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->Has(
std::move(p_cache_name), 
std::move(p_trace_id), std::move(callback));
      return true;
    }
    case internal::kCacheStorage_Delete_Name: {

      internal::CacheStorage_Delete_Params_Data* params =
          reinterpret_cast<
              internal::CacheStorage_Delete_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      ::WTF::String p_cache_name{};
      int64_t p_trace_id{};
      CacheStorage_Delete_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadCacheName(&p_cache_name))
        success = false;
      if (success)
        p_trace_id = input_data_view.trace_id();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            CacheStorage::Name_, 1, false);
        return false;
      }
      CacheStorage::DeleteCallback callback =
          CacheStorage_Delete_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->Delete(
std::move(p_cache_name), 
std::move(p_trace_id), std::move(callback));
      return true;
    }
    case internal::kCacheStorage_Keys_Name: {

      internal::CacheStorage_Keys_Params_Data* params =
          reinterpret_cast<
              internal::CacheStorage_Keys_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      int64_t p_trace_id{};
      CacheStorage_Keys_ParamsDataView input_data_view(params, message);
      
      if (success)
        p_trace_id = input_data_view.trace_id();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            CacheStorage::Name_, 2, false);
        return false;
      }
      CacheStorage::KeysCallback callback =
          CacheStorage_Keys_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->Keys(
std::move(p_trace_id), std::move(callback));
      return true;
    }
    case internal::kCacheStorage_Match_Name: {

      internal::CacheStorage_Match_Params_Data* params =
          reinterpret_cast<
              internal::CacheStorage_Match_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      ::blink::mojom::blink::FetchAPIRequestPtr p_request{};
      MultiCacheQueryOptionsPtr p_match_options{};
      bool p_in_related_fetch_event{};
      bool p_in_range_fetch_event{};
      int64_t p_trace_id{};
      CacheStorage_Match_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadRequest(&p_request))
        success = false;
      if (success && !input_data_view.ReadMatchOptions(&p_match_options))
        success = false;
      if (success)
        p_in_related_fetch_event = input_data_view.in_related_fetch_event();
      if (success)
        p_in_range_fetch_event = input_data_view.in_range_fetch_event();
      if (success)
        p_trace_id = input_data_view.trace_id();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            CacheStorage::Name_, 3, false);
        return false;
      }
      CacheStorage::MatchCallback callback =
          CacheStorage_Match_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->Match(
std::move(p_request), 
std::move(p_match_options), 
std::move(p_in_related_fetch_event), 
std::move(p_in_range_fetch_event), 
std::move(p_trace_id), std::move(callback));
      return true;
    }
    case internal::kCacheStorage_Open_Name: {

      internal::CacheStorage_Open_Params_Data* params =
          reinterpret_cast<
              internal::CacheStorage_Open_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      ::WTF::String p_cache_name{};
      int64_t p_trace_id{};
      CacheStorage_Open_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadCacheName(&p_cache_name))
        success = false;
      if (success)
        p_trace_id = input_data_view.trace_id();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            CacheStorage::Name_, 4, false);
        return false;
      }
      CacheStorage::OpenCallback callback =
          CacheStorage_Open_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->Open(
std::move(p_cache_name), 
std::move(p_trace_id), std::move(callback));
      return true;
    }
  }
  return false;
}


static const mojo::internal::GenericValidationInfo kCacheStorageValidationInfo[] = {
    {&internal::CacheStorage_Has_Params_Data::Validate,
     &internal::CacheStorage_Has_ResponseParams_Data::Validate},
    {&internal::CacheStorage_Delete_Params_Data::Validate,
     &internal::CacheStorage_Delete_ResponseParams_Data::Validate},
    {&internal::CacheStorage_Keys_Params_Data::Validate,
     &internal::CacheStorage_Keys_ResponseParams_Data::Validate},
    {&internal::CacheStorage_Match_Params_Data::Validate,
     &internal::CacheStorage_Match_ResponseParams_Data::Validate},
    {&internal::CacheStorage_Open_Params_Data::Validate,
     &internal::CacheStorage_Open_ResponseParams_Data::Validate},
};

bool CacheStorageRequestValidator::Accept(mojo::Message* message) {
  const char* name = ::blink::mojom::blink::CacheStorage::Name_;
  return mojo::internal::ValidateRequestGenericPacked(message, name, kCacheStorageValidationInfo);
}

bool CacheStorageResponseValidator::Accept(mojo::Message* message) {
  const char* name = ::blink::mojom::blink::CacheStorage::Name_;
  return mojo::internal::ValidateResponseGenericPacked(message, name, kCacheStorageValidationInfo);
}


}  // namespace blink
}  // namespace mojom
}  // namespace blink


namespace mojo {


// static
bool StructTraits<::blink::mojom::blink::CacheStorageVerboseError::DataView, ::blink::mojom::blink::CacheStorageVerboseErrorPtr>::Read(
    ::blink::mojom::blink::CacheStorageVerboseError::DataView input,
    ::blink::mojom::blink::CacheStorageVerboseErrorPtr* output) {
  bool success = true;
  ::blink::mojom::blink::CacheStorageVerboseErrorPtr result(::blink::mojom::blink::CacheStorageVerboseError::New());
  
      if (success && !input.ReadValue(&result->value))
        success = false;
      if (success && !input.ReadMessage(&result->message))
        success = false;
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::blink::mojom::blink::CacheQueryOptions::DataView, ::blink::mojom::blink::CacheQueryOptionsPtr>::Read(
    ::blink::mojom::blink::CacheQueryOptions::DataView input,
    ::blink::mojom::blink::CacheQueryOptionsPtr* output) {
  bool success = true;
  ::blink::mojom::blink::CacheQueryOptionsPtr result(::blink::mojom::blink::CacheQueryOptions::New());
  
      if (success)
        result->ignore_search = input.ignore_search();
      if (success)
        result->ignore_method = input.ignore_method();
      if (success)
        result->ignore_vary = input.ignore_vary();
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::blink::mojom::blink::MultiCacheQueryOptions::DataView, ::blink::mojom::blink::MultiCacheQueryOptionsPtr>::Read(
    ::blink::mojom::blink::MultiCacheQueryOptions::DataView input,
    ::blink::mojom::blink::MultiCacheQueryOptionsPtr* output) {
  bool success = true;
  ::blink::mojom::blink::MultiCacheQueryOptionsPtr result(::blink::mojom::blink::MultiCacheQueryOptions::New());
  
      if (success && !input.ReadQueryOptions(&result->query_options))
        success = false;
      if (success && !input.ReadCacheName(&result->cache_name))
        success = false;
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::blink::mojom::blink::BatchOperation::DataView, ::blink::mojom::blink::BatchOperationPtr>::Read(
    ::blink::mojom::blink::BatchOperation::DataView input,
    ::blink::mojom::blink::BatchOperationPtr* output) {
  bool success = true;
  ::blink::mojom::blink::BatchOperationPtr result(::blink::mojom::blink::BatchOperation::New());
  
      if (success && !input.ReadOperationType(&result->operation_type))
        success = false;
      if (success && !input.ReadRequest(&result->request))
        success = false;
      if (success && !input.ReadResponse(&result->response))
        success = false;
      if (success && !input.ReadMatchOptions(&result->match_options))
        success = false;
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::blink::mojom::blink::EagerResponse::DataView, ::blink::mojom::blink::EagerResponsePtr>::Read(
    ::blink::mojom::blink::EagerResponse::DataView input,
    ::blink::mojom::blink::EagerResponsePtr* output) {
  bool success = true;
  ::blink::mojom::blink::EagerResponsePtr result(::blink::mojom::blink::EagerResponse::New());
  
      if (success && !input.ReadResponse(&result->response))
        success = false;
      if (success)
        result->pipe = input.TakePipe();
      if (success) {
        result->client_receiver =
            input.TakeClientReceiver<decltype(result->client_receiver)>();
      }
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::blink::mojom::blink::CacheEntry::DataView, ::blink::mojom::blink::CacheEntryPtr>::Read(
    ::blink::mojom::blink::CacheEntry::DataView input,
    ::blink::mojom::blink::CacheEntryPtr* output) {
  bool success = true;
  ::blink::mojom::blink::CacheEntryPtr result(::blink::mojom::blink::CacheEntry::New());
  
      if (success && !input.ReadRequest(&result->request))
        success = false;
      if (success && !input.ReadResponse(&result->response))
        success = false;
  *output = std::move(result);
  return success;
}

// static
bool UnionTraits<::blink::mojom::blink::OpenResult::DataView, ::blink::mojom::blink::OpenResultPtr>::Read(
    ::blink::mojom::blink::OpenResult::DataView input,
    ::blink::mojom::blink::OpenResultPtr* output) {
  using UnionType = ::blink::mojom::blink::OpenResult;
  using Tag = UnionType::Tag;

  switch (input.tag()) {
    case Tag::kStatus: {
      ::blink::mojom::blink::CacheStorageError result_status;
      if (!input.ReadStatus(&result_status))
        return false;

      *output = UnionType::NewStatus(result_status);
      break;
    }
    case Tag::kCache: {
      *output = UnionType::NewCache(
          input.TakeCache<::mojo::PendingAssociatedRemote<::blink::mojom::blink::CacheStorageCache>>());
      break;
    }
    default:

      return false;
  }
  return true;
}

// static
bool UnionTraits<::blink::mojom::blink::MatchResult::DataView, ::blink::mojom::blink::MatchResultPtr>::Read(
    ::blink::mojom::blink::MatchResult::DataView input,
    ::blink::mojom::blink::MatchResultPtr* output) {
  using UnionType = ::blink::mojom::blink::MatchResult;
  using Tag = UnionType::Tag;

  switch (input.tag()) {
    case Tag::kStatus: {
      ::blink::mojom::blink::CacheStorageError result_status;
      if (!input.ReadStatus(&result_status))
        return false;

      *output = UnionType::NewStatus(result_status);
      break;
    }
    case Tag::kResponse: {
      ::blink::mojom::blink::FetchAPIResponsePtr result_response;
      if (!input.ReadResponse(&result_response))
        return false;

      *output = UnionType::NewResponse(
          std::move(result_response));
      break;
    }
    case Tag::kEagerResponse: {
      ::blink::mojom::blink::EagerResponsePtr result_eager_response;
      if (!input.ReadEagerResponse(&result_eager_response))
        return false;

      *output = UnionType::NewEagerResponse(
          std::move(result_eager_response));
      break;
    }
    default:

      return false;
  }
  return true;
}

// static
bool UnionTraits<::blink::mojom::blink::MatchAllResult::DataView, ::blink::mojom::blink::MatchAllResultPtr>::Read(
    ::blink::mojom::blink::MatchAllResult::DataView input,
    ::blink::mojom::blink::MatchAllResultPtr* output) {
  using UnionType = ::blink::mojom::blink::MatchAllResult;
  using Tag = UnionType::Tag;

  switch (input.tag()) {
    case Tag::kStatus: {
      ::blink::mojom::blink::CacheStorageError result_status;
      if (!input.ReadStatus(&result_status))
        return false;

      *output = UnionType::NewStatus(result_status);
      break;
    }
    case Tag::kResponses: {
      WTF::Vector<::blink::mojom::blink::FetchAPIResponsePtr> result_responses;
      if (!input.ReadResponses(&result_responses))
        return false;

      *output = UnionType::NewResponses(
          std::move(result_responses));
      break;
    }
    default:

      return false;
  }
  return true;
}

// static
bool UnionTraits<::blink::mojom::blink::GetAllMatchedEntriesResult::DataView, ::blink::mojom::blink::GetAllMatchedEntriesResultPtr>::Read(
    ::blink::mojom::blink::GetAllMatchedEntriesResult::DataView input,
    ::blink::mojom::blink::GetAllMatchedEntriesResultPtr* output) {
  using UnionType = ::blink::mojom::blink::GetAllMatchedEntriesResult;
  using Tag = UnionType::Tag;

  switch (input.tag()) {
    case Tag::kStatus: {
      ::blink::mojom::blink::CacheStorageError result_status;
      if (!input.ReadStatus(&result_status))
        return false;

      *output = UnionType::NewStatus(result_status);
      break;
    }
    case Tag::kEntries: {
      WTF::Vector<::blink::mojom::blink::CacheEntryPtr> result_entries;
      if (!input.ReadEntries(&result_entries))
        return false;

      *output = UnionType::NewEntries(
          std::move(result_entries));
      break;
    }
    default:

      return false;
  }
  return true;
}

// static
bool UnionTraits<::blink::mojom::blink::CacheKeysResult::DataView, ::blink::mojom::blink::CacheKeysResultPtr>::Read(
    ::blink::mojom::blink::CacheKeysResult::DataView input,
    ::blink::mojom::blink::CacheKeysResultPtr* output) {
  using UnionType = ::blink::mojom::blink::CacheKeysResult;
  using Tag = UnionType::Tag;

  switch (input.tag()) {
    case Tag::kStatus: {
      ::blink::mojom::blink::CacheStorageError result_status;
      if (!input.ReadStatus(&result_status))
        return false;

      *output = UnionType::NewStatus(result_status);
      break;
    }
    case Tag::kKeys: {
      WTF::Vector<::blink::mojom::blink::FetchAPIRequestPtr> result_keys;
      if (!input.ReadKeys(&result_keys))
        return false;

      *output = UnionType::NewKeys(
          std::move(result_keys));
      break;
    }
    default:

      return false;
  }
  return true;
}

}  // namespace mojo


// Symbols declared in the -test-utils.h header are defined here instead of a
// separate .cc file to save compile time.


namespace blink {
namespace mojom {
namespace blink {


void CacheStorageCacheInterceptorForTesting::Match(::blink::mojom::blink::FetchAPIRequestPtr request, CacheQueryOptionsPtr query_options, bool in_related_fetch_event, bool in_range_fetch_event, int64_t trace_id, MatchCallback callback) {
  GetForwardingInterface()->Match(std::move(request), std::move(query_options), std::move(in_related_fetch_event), std::move(in_range_fetch_event), std::move(trace_id), std::move(callback));
}
void CacheStorageCacheInterceptorForTesting::MatchAll(::blink::mojom::blink::FetchAPIRequestPtr request, CacheQueryOptionsPtr query_options, int64_t trace_id, MatchAllCallback callback) {
  GetForwardingInterface()->MatchAll(std::move(request), std::move(query_options), std::move(trace_id), std::move(callback));
}
void CacheStorageCacheInterceptorForTesting::GetAllMatchedEntries(::blink::mojom::blink::FetchAPIRequestPtr request, CacheQueryOptionsPtr query_options, int64_t trace_id, GetAllMatchedEntriesCallback callback) {
  GetForwardingInterface()->GetAllMatchedEntries(std::move(request), std::move(query_options), std::move(trace_id), std::move(callback));
}
void CacheStorageCacheInterceptorForTesting::Keys(::blink::mojom::blink::FetchAPIRequestPtr request, CacheQueryOptionsPtr query_options, int64_t trace_id, KeysCallback callback) {
  GetForwardingInterface()->Keys(std::move(request), std::move(query_options), std::move(trace_id), std::move(callback));
}
void CacheStorageCacheInterceptorForTesting::Batch(WTF::Vector<BatchOperationPtr> batch_operations, int64_t trace_id, BatchCallback callback) {
  GetForwardingInterface()->Batch(std::move(batch_operations), std::move(trace_id), std::move(callback));
}
void CacheStorageCacheInterceptorForTesting::WriteSideData(const ::blink::KURL& url, ::base::Time expected_response_time, ::mojo_base::BigBuffer data, int64_t trace_id, WriteSideDataCallback callback) {
  GetForwardingInterface()->WriteSideData(std::move(url), std::move(expected_response_time), std::move(data), std::move(trace_id), std::move(callback));
}
CacheStorageCacheAsyncWaiter::CacheStorageCacheAsyncWaiter(
    CacheStorageCache* proxy) : proxy_(proxy) {}

CacheStorageCacheAsyncWaiter::~CacheStorageCacheAsyncWaiter() = default;

void CacheStorageCacheAsyncWaiter::Match(
    ::blink::mojom::blink::FetchAPIRequestPtr request, CacheQueryOptionsPtr query_options, bool in_related_fetch_event, bool in_range_fetch_event, int64_t trace_id, MatchResultPtr* out_result) {
  base::RunLoop loop;
  proxy_->Match(std::move(request),std::move(query_options),std::move(in_related_fetch_event),std::move(in_range_fetch_event),std::move(trace_id),
      base::BindOnce(
          [](base::RunLoop* loop,
             MatchResultPtr* out_result
,
             MatchResultPtr result) {*out_result = std::move(result);
            loop->Quit();
          },
          &loop,
          out_result));
  loop.Run();
}
void CacheStorageCacheAsyncWaiter::MatchAll(
    ::blink::mojom::blink::FetchAPIRequestPtr request, CacheQueryOptionsPtr query_options, int64_t trace_id, MatchAllResultPtr* out_result) {
  base::RunLoop loop;
  proxy_->MatchAll(std::move(request),std::move(query_options),std::move(trace_id),
      base::BindOnce(
          [](base::RunLoop* loop,
             MatchAllResultPtr* out_result
,
             MatchAllResultPtr result) {*out_result = std::move(result);
            loop->Quit();
          },
          &loop,
          out_result));
  loop.Run();
}
void CacheStorageCacheAsyncWaiter::GetAllMatchedEntries(
    ::blink::mojom::blink::FetchAPIRequestPtr request, CacheQueryOptionsPtr query_options, int64_t trace_id, GetAllMatchedEntriesResultPtr* out_result) {
  base::RunLoop loop;
  proxy_->GetAllMatchedEntries(std::move(request),std::move(query_options),std::move(trace_id),
      base::BindOnce(
          [](base::RunLoop* loop,
             GetAllMatchedEntriesResultPtr* out_result
,
             GetAllMatchedEntriesResultPtr result) {*out_result = std::move(result);
            loop->Quit();
          },
          &loop,
          out_result));
  loop.Run();
}
void CacheStorageCacheAsyncWaiter::Keys(
    ::blink::mojom::blink::FetchAPIRequestPtr request, CacheQueryOptionsPtr query_options, int64_t trace_id, CacheKeysResultPtr* out_result) {
  base::RunLoop loop;
  proxy_->Keys(std::move(request),std::move(query_options),std::move(trace_id),
      base::BindOnce(
          [](base::RunLoop* loop,
             CacheKeysResultPtr* out_result
,
             CacheKeysResultPtr result) {*out_result = std::move(result);
            loop->Quit();
          },
          &loop,
          out_result));
  loop.Run();
}
void CacheStorageCacheAsyncWaiter::Batch(
    WTF::Vector<BatchOperationPtr> batch_operations, int64_t trace_id, CacheStorageVerboseErrorPtr* out_result) {
  base::RunLoop loop;
  proxy_->Batch(std::move(batch_operations),std::move(trace_id),
      base::BindOnce(
          [](base::RunLoop* loop,
             CacheStorageVerboseErrorPtr* out_result
,
             CacheStorageVerboseErrorPtr result) {*out_result = std::move(result);
            loop->Quit();
          },
          &loop,
          out_result));
  loop.Run();
}
void CacheStorageCacheAsyncWaiter::WriteSideData(
    const ::blink::KURL& url, ::base::Time expected_response_time, ::mojo_base::BigBuffer data, int64_t trace_id, CacheStorageError* out_result) {
  base::RunLoop loop;
  proxy_->WriteSideData(std::move(url),std::move(expected_response_time),std::move(data),std::move(trace_id),
      base::BindOnce(
          [](base::RunLoop* loop,
             CacheStorageError* out_result
,
             CacheStorageError result) {*out_result = std::move(result);
            loop->Quit();
          },
          &loop,
          out_result));
  loop.Run();
}



void CacheStorageInterceptorForTesting::Has(const ::WTF::String& cache_name, int64_t trace_id, HasCallback callback) {
  GetForwardingInterface()->Has(std::move(cache_name), std::move(trace_id), std::move(callback));
}
void CacheStorageInterceptorForTesting::Delete(const ::WTF::String& cache_name, int64_t trace_id, DeleteCallback callback) {
  GetForwardingInterface()->Delete(std::move(cache_name), std::move(trace_id), std::move(callback));
}
void CacheStorageInterceptorForTesting::Keys(int64_t trace_id, KeysCallback callback) {
  GetForwardingInterface()->Keys(std::move(trace_id), std::move(callback));
}
void CacheStorageInterceptorForTesting::Match(::blink::mojom::blink::FetchAPIRequestPtr request, MultiCacheQueryOptionsPtr match_options, bool in_related_fetch_event, bool in_range_fetch_event, int64_t trace_id, MatchCallback callback) {
  GetForwardingInterface()->Match(std::move(request), std::move(match_options), std::move(in_related_fetch_event), std::move(in_range_fetch_event), std::move(trace_id), std::move(callback));
}
void CacheStorageInterceptorForTesting::Open(const ::WTF::String& cache_name, int64_t trace_id, OpenCallback callback) {
  GetForwardingInterface()->Open(std::move(cache_name), std::move(trace_id), std::move(callback));
}
CacheStorageAsyncWaiter::CacheStorageAsyncWaiter(
    CacheStorage* proxy) : proxy_(proxy) {}

CacheStorageAsyncWaiter::~CacheStorageAsyncWaiter() = default;

void CacheStorageAsyncWaiter::Has(
    const ::WTF::String& cache_name, int64_t trace_id, CacheStorageError* out_result) {
  base::RunLoop loop;
  proxy_->Has(std::move(cache_name),std::move(trace_id),
      base::BindOnce(
          [](base::RunLoop* loop,
             CacheStorageError* out_result
,
             CacheStorageError result) {*out_result = std::move(result);
            loop->Quit();
          },
          &loop,
          out_result));
  loop.Run();
}
void CacheStorageAsyncWaiter::Delete(
    const ::WTF::String& cache_name, int64_t trace_id, CacheStorageError* out_result) {
  base::RunLoop loop;
  proxy_->Delete(std::move(cache_name),std::move(trace_id),
      base::BindOnce(
          [](base::RunLoop* loop,
             CacheStorageError* out_result
,
             CacheStorageError result) {*out_result = std::move(result);
            loop->Quit();
          },
          &loop,
          out_result));
  loop.Run();
}
void CacheStorageAsyncWaiter::Keys(
    int64_t trace_id, WTF::Vector<::WTF::String>* out_keys) {
  base::RunLoop loop;
  proxy_->Keys(std::move(trace_id),
      base::BindOnce(
          [](base::RunLoop* loop,
             WTF::Vector<::WTF::String>* out_keys
,
             const WTF::Vector<::WTF::String>& keys) {*out_keys = std::move(keys);
            loop->Quit();
          },
          &loop,
          out_keys));
  loop.Run();
}
void CacheStorageAsyncWaiter::Match(
    ::blink::mojom::blink::FetchAPIRequestPtr request, MultiCacheQueryOptionsPtr match_options, bool in_related_fetch_event, bool in_range_fetch_event, int64_t trace_id, MatchResultPtr* out_result) {
  base::RunLoop loop;
  proxy_->Match(std::move(request),std::move(match_options),std::move(in_related_fetch_event),std::move(in_range_fetch_event),std::move(trace_id),
      base::BindOnce(
          [](base::RunLoop* loop,
             MatchResultPtr* out_result
,
             MatchResultPtr result) {*out_result = std::move(result);
            loop->Quit();
          },
          &loop,
          out_result));
  loop.Run();
}
void CacheStorageAsyncWaiter::Open(
    const ::WTF::String& cache_name, int64_t trace_id, OpenResultPtr* out_result) {
  base::RunLoop loop;
  proxy_->Open(std::move(cache_name),std::move(trace_id),
      base::BindOnce(
          [](base::RunLoop* loop,
             OpenResultPtr* out_result
,
             OpenResultPtr result) {*out_result = std::move(result);
            loop->Quit();
          },
          &loop,
          out_result));
  loop.Run();
}





}  // namespace blink
}  // namespace mojom
}  // namespace blink


#if defined(__clang__)
#pragma clang diagnostic pop
#endif