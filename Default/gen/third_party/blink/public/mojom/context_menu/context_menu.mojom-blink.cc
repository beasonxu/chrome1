// third_party/blink/public/mojom/context_menu/context_menu.mojom-blink.cc is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2013 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#if defined(__clang__)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-private-field"
#endif

#include "third_party/blink/public/mojom/context_menu/context_menu.mojom-blink.h"

#include <math.h>
#include <stdint.h>
#include <utility>

#include "base/debug/alias.h"
#include "base/hash/md5_constexpr.h"
#include "base/run_loop.h"
#include "base/strings/string_number_conversions.h"
#include "base/trace_event/trace_event.h"
#include "base/trace_event/typed_macros.h"
#include "mojo/public/cpp/bindings/lib/generated_code_util.h"
#include "mojo/public/cpp/bindings/lib/message_internal.h"
#include "mojo/public/cpp/bindings/lib/send_message_helper.h"
#include "mojo/public/cpp/bindings/lib/proxy_to_responder.h"
#include "mojo/public/cpp/bindings/lib/serialization_util.h"
#include "mojo/public/cpp/bindings/lib/unserialized_message_context.h"
#include "mojo/public/cpp/bindings/lib/validate_params.h"
#include "mojo/public/cpp/bindings/lib/validation_errors.h"
#include "mojo/public/cpp/bindings/mojo_buildflags.h"
#include "mojo/public/interfaces/bindings/interface_control_messages.mojom.h"
#include "third_party/perfetto/include/perfetto/tracing/traced_value.h"

#include "third_party/blink/public/mojom/context_menu/context_menu.mojom-params-data.h"
#include "third_party/blink/public/mojom/context_menu/context_menu.mojom-shared-message-ids.h"

#include "third_party/blink/public/mojom/context_menu/context_menu.mojom-blink-import-headers.h"
#include "third_party/blink/public/mojom/context_menu/context_menu.mojom-blink-test-utils.h"
#include "mojo/public/cpp/bindings/lib/wtf_serialization.h"


#ifndef THIRD_PARTY_BLINK_PUBLIC_MOJOM_CONTEXT_MENU_CONTEXT_MENU_MOJOM_BLINK_JUMBO_H_
#define THIRD_PARTY_BLINK_PUBLIC_MOJOM_CONTEXT_MENU_CONTEXT_MENU_MOJOM_BLINK_JUMBO_H_
#endif



namespace blink {
namespace mojom {
namespace blink {
FieldRendererId::FieldRendererId()
    : id() {}

FieldRendererId::FieldRendererId(
    uint64_t id_in)
    : id(std::move(id_in)) {}

FieldRendererId::~FieldRendererId() = default;
size_t FieldRendererId::Hash(size_t seed) const {
  seed = mojo::internal::WTFHash(seed, this->id);
  return seed;
}

void FieldRendererId::WriteIntoTrace(
    perfetto::TracedValue traced_context) const {
  [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "id"), this->id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type uint64_t>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool FieldRendererId::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
CustomContextMenuItem::CustomContextMenuItem()
    : label(),
      icon(),
      tool_tip(),
      type(),
      action(),
      rtl(),
      has_directional_override(),
      enabled(),
      checked(),
      submenu() {}

CustomContextMenuItem::CustomContextMenuItem(
    const ::WTF::String& label_in,
    const ::WTF::String& icon_in,
    const ::WTF::String& tool_tip_in,
    CustomContextMenuItemType type_in,
    int32_t action_in,
    bool rtl_in,
    bool has_directional_override_in,
    bool enabled_in,
    bool checked_in,
    WTF::Vector<CustomContextMenuItemPtr> submenu_in)
    : label(std::move(label_in)),
      icon(std::move(icon_in)),
      tool_tip(std::move(tool_tip_in)),
      type(std::move(type_in)),
      action(std::move(action_in)),
      rtl(std::move(rtl_in)),
      has_directional_override(std::move(has_directional_override_in)),
      enabled(std::move(enabled_in)),
      checked(std::move(checked_in)),
      submenu(std::move(submenu_in)) {}

CustomContextMenuItem::~CustomContextMenuItem() = default;

void CustomContextMenuItem::WriteIntoTrace(
    perfetto::TracedValue traced_context) const {
  [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "label"), this->label,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const ::WTF::String&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "icon"), this->icon,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const ::WTF::String&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "tool_tip"), this->tool_tip,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const ::WTF::String&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "type"), this->type,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type CustomContextMenuItemType>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "action"), this->action,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type int32_t>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "rtl"), this->rtl,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type bool>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "has_directional_override"), this->has_directional_override,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type bool>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "enabled"), this->enabled,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type bool>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "checked"), this->checked,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type bool>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "submenu"), this->submenu,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type WTF::Vector<CustomContextMenuItemPtr>>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool CustomContextMenuItem::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
UntrustworthyContextMenuParams::UntrustworthyContextMenuParams()
    : media_type(),
      x(),
      y(),
      link_url(),
      link_text(),
      impression(),
      unfiltered_link_url(),
      src_url(),
      has_image_contents(),
      media_flags(),
      selection_text(),
      title_text(),
      alt_text(),
      suggested_filename(),
      misspelled_word(),
      dictionary_suggestions(),
      spellcheck_enabled(),
      is_editable(),
      writing_direction_default(),
      writing_direction_left_to_right(),
      writing_direction_right_to_left(),
      edit_flags(),
      frame_charset(),
      referrer_policy(),
      link_followed(),
      custom_items(),
      source_type(),
      input_field_type(),
      selection_rect(),
      selection_start_offset(),
      opened_from_highlight(),
      field_renderer_id() {}

UntrustworthyContextMenuParams::UntrustworthyContextMenuParams(
    ContextMenuDataMediaType media_type_in,
    int32_t x_in,
    int32_t y_in,
    const ::blink::KURL& link_url_in,
    const ::WTF::String& link_text_in,
    const absl::optional<::blink::Impression>& impression_in,
    const ::blink::KURL& unfiltered_link_url_in,
    const ::blink::KURL& src_url_in,
    bool has_image_contents_in,
    int32_t media_flags_in,
    const ::WTF::String& selection_text_in,
    const ::WTF::String& title_text_in,
    const ::WTF::String& alt_text_in,
    const ::WTF::String& suggested_filename_in,
    const ::WTF::String& misspelled_word_in,
    WTF::Vector<::WTF::String> dictionary_suggestions_in,
    bool spellcheck_enabled_in,
    bool is_editable_in,
    int32_t writing_direction_default_in,
    int32_t writing_direction_left_to_right_in,
    int32_t writing_direction_right_to_left_in,
    int32_t edit_flags_in,
    const WTF::String& frame_charset_in,
    ::network::mojom::blink::ReferrerPolicy referrer_policy_in,
    const ::blink::KURL& link_followed_in,
    WTF::Vector<CustomContextMenuItemPtr> custom_items_in,
    ::ui::mojom::blink::MenuSourceType source_type_in,
    ContextMenuDataInputFieldType input_field_type_in,
    const ::gfx::Rect& selection_rect_in,
    int32_t selection_start_offset_in,
    bool opened_from_highlight_in,
    FieldRendererIdPtr field_renderer_id_in)
    : media_type(std::move(media_type_in)),
      x(std::move(x_in)),
      y(std::move(y_in)),
      link_url(std::move(link_url_in)),
      link_text(std::move(link_text_in)),
      impression(std::move(impression_in)),
      unfiltered_link_url(std::move(unfiltered_link_url_in)),
      src_url(std::move(src_url_in)),
      has_image_contents(std::move(has_image_contents_in)),
      media_flags(std::move(media_flags_in)),
      selection_text(std::move(selection_text_in)),
      title_text(std::move(title_text_in)),
      alt_text(std::move(alt_text_in)),
      suggested_filename(std::move(suggested_filename_in)),
      misspelled_word(std::move(misspelled_word_in)),
      dictionary_suggestions(std::move(dictionary_suggestions_in)),
      spellcheck_enabled(std::move(spellcheck_enabled_in)),
      is_editable(std::move(is_editable_in)),
      writing_direction_default(std::move(writing_direction_default_in)),
      writing_direction_left_to_right(std::move(writing_direction_left_to_right_in)),
      writing_direction_right_to_left(std::move(writing_direction_right_to_left_in)),
      edit_flags(std::move(edit_flags_in)),
      frame_charset(std::move(frame_charset_in)),
      referrer_policy(std::move(referrer_policy_in)),
      link_followed(std::move(link_followed_in)),
      custom_items(std::move(custom_items_in)),
      source_type(std::move(source_type_in)),
      input_field_type(std::move(input_field_type_in)),
      selection_rect(std::move(selection_rect_in)),
      selection_start_offset(std::move(selection_start_offset_in)),
      opened_from_highlight(std::move(opened_from_highlight_in)),
      field_renderer_id(std::move(field_renderer_id_in)) {}

UntrustworthyContextMenuParams::~UntrustworthyContextMenuParams() = default;

void UntrustworthyContextMenuParams::WriteIntoTrace(
    perfetto::TracedValue traced_context) const {
  [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "media_type"), this->media_type,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type ContextMenuDataMediaType>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "x"), this->x,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type int32_t>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "y"), this->y,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type int32_t>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "link_url"), this->link_url,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const ::blink::KURL&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "link_text"), this->link_text,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const ::WTF::String&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "impression"), this->impression,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const absl::optional<::blink::Impression>&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "unfiltered_link_url"), this->unfiltered_link_url,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const ::blink::KURL&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "src_url"), this->src_url,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const ::blink::KURL&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "has_image_contents"), this->has_image_contents,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type bool>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "media_flags"), this->media_flags,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type int32_t>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "selection_text"), this->selection_text,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const ::WTF::String&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "title_text"), this->title_text,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const ::WTF::String&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "alt_text"), this->alt_text,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const ::WTF::String&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "suggested_filename"), this->suggested_filename,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const ::WTF::String&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "misspelled_word"), this->misspelled_word,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const ::WTF::String&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "dictionary_suggestions"), this->dictionary_suggestions,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const WTF::Vector<::WTF::String>&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "spellcheck_enabled"), this->spellcheck_enabled,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type bool>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "is_editable"), this->is_editable,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type bool>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "writing_direction_default"), this->writing_direction_default,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type int32_t>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "writing_direction_left_to_right"), this->writing_direction_left_to_right,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type int32_t>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "writing_direction_right_to_left"), this->writing_direction_right_to_left,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type int32_t>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "edit_flags"), this->edit_flags,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type int32_t>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "frame_charset"), this->frame_charset,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const WTF::String&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "referrer_policy"), this->referrer_policy,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type ::network::mojom::blink::ReferrerPolicy>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "link_followed"), this->link_followed,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const ::blink::KURL&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "custom_items"), this->custom_items,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type WTF::Vector<CustomContextMenuItemPtr>>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "source_type"), this->source_type,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type ::ui::mojom::blink::MenuSourceType>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "input_field_type"), this->input_field_type,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type ContextMenuDataInputFieldType>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "selection_rect"), this->selection_rect,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const ::gfx::Rect&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "selection_start_offset"), this->selection_start_offset,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type int32_t>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "opened_from_highlight"), this->opened_from_highlight,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type bool>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "field_renderer_id"), this->field_renderer_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type FieldRendererIdPtr>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool UntrustworthyContextMenuParams::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
const char ContextMenuClient::Name_[] = "blink.mojom.ContextMenuClient";

ContextMenuClient::IPCStableHashFunction ContextMenuClient::MessageToMethodInfo_(mojo::Message& message) {
#if !BUILDFLAG(IS_FUCHSIA)
  switch (message.name()) {
    case internal::kContextMenuClient_CustomContextMenuAction_Name: {
      return &ContextMenuClient::CustomContextMenuAction_Sym::IPCStableHash;
    }
    case internal::kContextMenuClient_ContextMenuClosed_Name: {
      return &ContextMenuClient::ContextMenuClosed_Sym::IPCStableHash;
    }
  }
#endif  // !BUILDFLAG(IS_FUCHSIA)
  return nullptr;
}


const char* ContextMenuClient::MessageToMethodName_(mojo::Message& message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  bool is_response = message.has_flag(mojo::Message::kFlagIsResponse);
  if (!is_response) {
    switch (message.name()) {
      case internal::kContextMenuClient_CustomContextMenuAction_Name:
            return "Receive blink::mojom::ContextMenuClient::CustomContextMenuAction";
      case internal::kContextMenuClient_ContextMenuClosed_Name:
            return "Receive blink::mojom::ContextMenuClient::ContextMenuClosed";
    }
  } else {
    switch (message.name()) {
      case internal::kContextMenuClient_CustomContextMenuAction_Name:
            return "Receive reply blink::mojom::ContextMenuClient::CustomContextMenuAction";
      case internal::kContextMenuClient_ContextMenuClosed_Name:
            return "Receive reply blink::mojom::ContextMenuClient::ContextMenuClosed";
    }
  }
  return "Receive unknown mojo message";
#else
  bool is_response = message.has_flag(mojo::Message::kFlagIsResponse);
  if (is_response) {
    return "Receive mojo reply";
  } else {
    return "Receive mojo message";
  }
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
}

#if !BUILDFLAG(IS_FUCHSIA)
uint32_t ContextMenuClient::CustomContextMenuAction_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::ContextMenuClient::CustomContextMenuAction");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t ContextMenuClient::ContextMenuClosed_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::ContextMenuClient::ContextMenuClosed");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
# endif // !BUILDFLAG(IS_FUCHSIA)

ContextMenuClientProxy::ContextMenuClientProxy(mojo::MessageReceiverWithResponder* receiver)
    : receiver_(receiver) {
}

void ContextMenuClientProxy::CustomContextMenuAction(
    uint32_t in_action) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::ContextMenuClient::CustomContextMenuAction", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("action"), in_action,
                        "<value of type uint32_t>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kContextMenuClient_CustomContextMenuAction_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::ContextMenuClient_CustomContextMenuAction_Params_Data> params(
          message);
  params.Allocate();
  params->action = in_action;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(ContextMenuClient::Name_);
  message.set_method_name("CustomContextMenuAction");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void ContextMenuClientProxy::ContextMenuClosed(
    const ::blink::KURL& in_link_followed) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::ContextMenuClient::ContextMenuClosed", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("link_followed"), in_link_followed,
                        "<value of type const ::blink::KURL&>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kContextMenuClient_ContextMenuClosed_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::ContextMenuClient_ContextMenuClosed_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->link_followed)::BaseType> link_followed_fragment(
          params.message());
  mojo::internal::Serialize<::url::mojom::UrlDataView>(
      in_link_followed, link_followed_fragment);
  params->link_followed.Set(
      link_followed_fragment.is_null() ? nullptr : link_followed_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->link_followed.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null link_followed in ContextMenuClient.ContextMenuClosed request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(ContextMenuClient::Name_);
  message.set_method_name("ContextMenuClosed");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

// static
bool ContextMenuClientStubDispatch::Accept(
    ContextMenuClient* impl,
    mojo::Message* message) {
  switch (message->header()->name) {
    case internal::kContextMenuClient_CustomContextMenuAction_Name: {

      DCHECK(message->is_serialized());
      internal::ContextMenuClient_CustomContextMenuAction_Params_Data* params =
          reinterpret_cast<internal::ContextMenuClient_CustomContextMenuAction_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      uint32_t p_action{};
      ContextMenuClient_CustomContextMenuAction_ParamsDataView input_data_view(params, message);
      
      if (success)
        p_action = input_data_view.action();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            ContextMenuClient::Name_, 0, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->CustomContextMenuAction(
std::move(p_action));
      return true;
    }
    case internal::kContextMenuClient_ContextMenuClosed_Name: {

      DCHECK(message->is_serialized());
      internal::ContextMenuClient_ContextMenuClosed_Params_Data* params =
          reinterpret_cast<internal::ContextMenuClient_ContextMenuClosed_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::blink::KURL p_link_followed{};
      ContextMenuClient_ContextMenuClosed_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadLinkFollowed(&p_link_followed))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            ContextMenuClient::Name_, 1, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->ContextMenuClosed(
std::move(p_link_followed));
      return true;
    }
  }
  return false;
}

// static
bool ContextMenuClientStubDispatch::AcceptWithResponder(
    ContextMenuClient* impl,
    mojo::Message* message,
    std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
  [[maybe_unused]] const bool message_is_sync =
      message->has_flag(mojo::Message::kFlagIsSync);
  [[maybe_unused]] const uint64_t request_id = message->request_id();
  switch (message->header()->name) {
    case internal::kContextMenuClient_CustomContextMenuAction_Name: {
      break;
    }
    case internal::kContextMenuClient_ContextMenuClosed_Name: {
      break;
    }
  }
  return false;
}


static const mojo::internal::GenericValidationInfo kContextMenuClientValidationInfo[] = {
    {&internal::ContextMenuClient_CustomContextMenuAction_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::ContextMenuClient_ContextMenuClosed_Params_Data::Validate,
     nullptr /* no response */},
};

bool ContextMenuClientRequestValidator::Accept(mojo::Message* message) {
  const char* name = ::blink::mojom::blink::ContextMenuClient::Name_;
  return mojo::internal::ValidateRequestGenericPacked(message, name, kContextMenuClientValidationInfo);
}



}  // namespace blink
}  // namespace mojom
}  // namespace blink


namespace mojo {


// static
bool StructTraits<::blink::mojom::blink::FieldRendererId::DataView, ::blink::mojom::blink::FieldRendererIdPtr>::Read(
    ::blink::mojom::blink::FieldRendererId::DataView input,
    ::blink::mojom::blink::FieldRendererIdPtr* output) {
  bool success = true;
  ::blink::mojom::blink::FieldRendererIdPtr result(::blink::mojom::blink::FieldRendererId::New());
  
      if (success)
        result->id = input.id();
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::blink::mojom::blink::CustomContextMenuItem::DataView, ::blink::mojom::blink::CustomContextMenuItemPtr>::Read(
    ::blink::mojom::blink::CustomContextMenuItem::DataView input,
    ::blink::mojom::blink::CustomContextMenuItemPtr* output) {
  bool success = true;
  ::blink::mojom::blink::CustomContextMenuItemPtr result(::blink::mojom::blink::CustomContextMenuItem::New());
  
      if (success && !input.ReadLabel(&result->label))
        success = false;
      if (success && !input.ReadIcon(&result->icon))
        success = false;
      if (success && !input.ReadToolTip(&result->tool_tip))
        success = false;
      if (success && !input.ReadType(&result->type))
        success = false;
      if (success)
        result->action = input.action();
      if (success)
        result->rtl = input.rtl();
      if (success)
        result->has_directional_override = input.has_directional_override();
      if (success)
        result->enabled = input.enabled();
      if (success)
        result->checked = input.checked();
      if (success && !input.ReadSubmenu(&result->submenu))
        success = false;
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::blink::mojom::blink::UntrustworthyContextMenuParams::DataView, ::blink::mojom::blink::UntrustworthyContextMenuParamsPtr>::Read(
    ::blink::mojom::blink::UntrustworthyContextMenuParams::DataView input,
    ::blink::mojom::blink::UntrustworthyContextMenuParamsPtr* output) {
  bool success = true;
  ::blink::mojom::blink::UntrustworthyContextMenuParamsPtr result(::blink::mojom::blink::UntrustworthyContextMenuParams::New());
  
      if (success && !input.ReadMediaType(&result->media_type))
        success = false;
      if (success)
        result->x = input.x();
      if (success)
        result->y = input.y();
      if (success && !input.ReadLinkUrl(&result->link_url))
        success = false;
      if (success && !input.ReadLinkText(&result->link_text))
        success = false;
      if (success && !input.ReadImpression(&result->impression))
        success = false;
      if (success && !input.ReadUnfilteredLinkUrl(&result->unfiltered_link_url))
        success = false;
      if (success && !input.ReadSrcUrl(&result->src_url))
        success = false;
      if (success)
        result->has_image_contents = input.has_image_contents();
      if (success)
        result->media_flags = input.media_flags();
      if (success && !input.ReadSelectionText(&result->selection_text))
        success = false;
      if (success && !input.ReadTitleText(&result->title_text))
        success = false;
      if (success && !input.ReadAltText(&result->alt_text))
        success = false;
      if (success && !input.ReadSuggestedFilename(&result->suggested_filename))
        success = false;
      if (success && !input.ReadMisspelledWord(&result->misspelled_word))
        success = false;
      if (success && !input.ReadDictionarySuggestions(&result->dictionary_suggestions))
        success = false;
      if (success)
        result->spellcheck_enabled = input.spellcheck_enabled();
      if (success)
        result->is_editable = input.is_editable();
      if (success)
        result->writing_direction_default = input.writing_direction_default();
      if (success)
        result->writing_direction_left_to_right = input.writing_direction_left_to_right();
      if (success)
        result->writing_direction_right_to_left = input.writing_direction_right_to_left();
      if (success)
        result->edit_flags = input.edit_flags();
      if (success && !input.ReadFrameCharset(&result->frame_charset))
        success = false;
      if (success && !input.ReadReferrerPolicy(&result->referrer_policy))
        success = false;
      if (success && !input.ReadLinkFollowed(&result->link_followed))
        success = false;
      if (success && !input.ReadCustomItems(&result->custom_items))
        success = false;
      if (success && !input.ReadSourceType(&result->source_type))
        success = false;
      if (success && !input.ReadInputFieldType(&result->input_field_type))
        success = false;
      if (success && !input.ReadSelectionRect(&result->selection_rect))
        success = false;
      if (success)
        result->selection_start_offset = input.selection_start_offset();
      if (success)
        result->opened_from_highlight = input.opened_from_highlight();
      if (success && !input.ReadFieldRendererId(&result->field_renderer_id))
        success = false;
  *output = std::move(result);
  return success;
}

}  // namespace mojo


// Symbols declared in the -test-utils.h header are defined here instead of a
// separate .cc file to save compile time.


namespace blink {
namespace mojom {
namespace blink {


void ContextMenuClientInterceptorForTesting::CustomContextMenuAction(uint32_t action) {
  GetForwardingInterface()->CustomContextMenuAction(std::move(action));
}
void ContextMenuClientInterceptorForTesting::ContextMenuClosed(const ::blink::KURL& link_followed) {
  GetForwardingInterface()->ContextMenuClosed(std::move(link_followed));
}
ContextMenuClientAsyncWaiter::ContextMenuClientAsyncWaiter(
    ContextMenuClient* proxy) : proxy_(proxy) {}

ContextMenuClientAsyncWaiter::~ContextMenuClientAsyncWaiter() = default;






}  // namespace blink
}  // namespace mojom
}  // namespace blink


#if defined(__clang__)
#pragma clang diagnostic pop
#endif