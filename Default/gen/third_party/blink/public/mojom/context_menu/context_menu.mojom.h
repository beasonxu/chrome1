// third_party/blink/public/mojom/context_menu/context_menu.mojom.h is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2013 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef THIRD_PARTY_BLINK_PUBLIC_MOJOM_CONTEXT_MENU_CONTEXT_MENU_MOJOM_H_
#define THIRD_PARTY_BLINK_PUBLIC_MOJOM_CONTEXT_MENU_CONTEXT_MENU_MOJOM_H_

#include <stdint.h>

#include <limits>
#include <type_traits>
#include <utility>

#include "third_party/abseil-cpp/absl/types/optional.h"
#include "mojo/public/cpp/bindings/clone_traits.h"
#include "mojo/public/cpp/bindings/equals_traits.h"
#include "mojo/public/cpp/bindings/lib/serialization.h"
#include "mojo/public/cpp/bindings/struct_ptr.h"
#include "mojo/public/cpp/bindings/struct_traits.h"
#include "mojo/public/cpp/bindings/union_traits.h"

#include "third_party/perfetto/include/perfetto/tracing/traced_value_forward.h"

#include "third_party/blink/public/mojom/context_menu/context_menu.mojom-shared.h"
#include "third_party/blink/public/mojom/context_menu/context_menu.mojom-forward.h"
#include "mojo/public/mojom/base/string16.mojom.h"
#include "services/network/public/mojom/referrer_policy.mojom-forward.h"
#include "third_party/blink/public/mojom/conversions/conversions.mojom.h"
#include "ui/base/mojom/ui_base_types.mojom.h"
#include "ui/gfx/geometry/mojom/geometry.mojom.h"
#include "url/mojom/url.mojom.h"
#include "url/mojom/origin.mojom-forward.h"
#include <string>
#include <vector>

#include "mojo/public/cpp/bindings/lib/control_message_handler.h"
#include "mojo/public/cpp/bindings/raw_ptr_impl_ref_traits.h"


#include "third_party/blink/public/common/context_menu_data/context_menu_mojom_traits.h"
#include "third_party/blink/public/common/common_export.h"




namespace blink {
namespace mojom {

class ContextMenuClientProxy;

template <typename ImplRefTraits>
class ContextMenuClientStub;

class ContextMenuClientRequestValidator;


class BLINK_COMMON_EXPORT ContextMenuClient
    : public ContextMenuClientInterfaceBase {
 public:
  using IPCStableHashFunction = uint32_t(*)();

  static const char Name_[];
  static IPCStableHashFunction MessageToMethodInfo_(mojo::Message& message);
  static const char* MessageToMethodName_(mojo::Message& message);
  static constexpr uint32_t Version_ = 0;
  static constexpr bool PassesAssociatedKinds_ = false;
  static constexpr bool HasSyncMethods_ = false;
  static constexpr bool HasUninterruptableMethods_ = false;

  using Base_ = ContextMenuClientInterfaceBase;
  using Proxy_ = ContextMenuClientProxy;

  template <typename ImplRefTraits>
  using Stub_ = ContextMenuClientStub<ImplRefTraits>;

  using RequestValidator_ = ContextMenuClientRequestValidator;
  using ResponseValidator_ = mojo::PassThroughFilter;
  enum MethodMinVersions : uint32_t {
    kCustomContextMenuActionMinVersion = 0,
    kContextMenuClosedMinVersion = 0,
  };

// crbug.com/1340245 - this causes binary size bloat on Fuchsia, and we're OK
// with not having this data in traces there.
#if !BUILDFLAG(IS_FUCHSIA)
  struct CustomContextMenuAction_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct ContextMenuClosed_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
#endif // !BUILDFLAG(IS_FUCHSIA)
  virtual ~ContextMenuClient() = default;

  
  virtual void CustomContextMenuAction(uint32_t action) = 0;

  
  virtual void ContextMenuClosed(const ::GURL& link_followed) = 0;
};



class BLINK_COMMON_EXPORT ContextMenuClientProxy
    : public ContextMenuClient {
 public:
  using InterfaceType = ContextMenuClient;

  explicit ContextMenuClientProxy(mojo::MessageReceiverWithResponder* receiver);
  
  void CustomContextMenuAction(uint32_t action) final;
  
  void ContextMenuClosed(const ::GURL& link_followed) final;

 private:
  mojo::MessageReceiverWithResponder* receiver_;
};
class BLINK_COMMON_EXPORT ContextMenuClientStubDispatch {
 public:
  static bool Accept(ContextMenuClient* impl, mojo::Message* message);
  static bool AcceptWithResponder(
      ContextMenuClient* impl,
      mojo::Message* message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder);
};

template <typename ImplRefTraits =
              mojo::RawPtrImplRefTraits<ContextMenuClient>>
class ContextMenuClientStub
    : public mojo::MessageReceiverWithResponderStatus {
 public:
  using ImplPointerType = typename ImplRefTraits::PointerType;

  ContextMenuClientStub() = default;
  ~ContextMenuClientStub() override = default;

  void set_sink(ImplPointerType sink) { sink_ = std::move(sink); }
  ImplPointerType& sink() { return sink_; }

  bool Accept(mojo::Message* message) override {
    if (ImplRefTraits::IsNull(sink_))
      return false;
    return ContextMenuClientStubDispatch::Accept(
        ImplRefTraits::GetRawPointer(&sink_), message);
  }

  bool AcceptWithResponder(
      mojo::Message* message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) override {
    if (ImplRefTraits::IsNull(sink_))
      return false;
    return ContextMenuClientStubDispatch::AcceptWithResponder(
        ImplRefTraits::GetRawPointer(&sink_), message, std::move(responder));
  }

 private:
  ImplPointerType sink_;
};
class BLINK_COMMON_EXPORT ContextMenuClientRequestValidator : public mojo::MessageReceiver {
 public:
  bool Accept(mojo::Message* message) override;
};





class BLINK_COMMON_EXPORT FieldRendererId {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<FieldRendererId, T>::value>;
  using DataView = FieldRendererIdDataView;
  using Data_ = internal::FieldRendererId_Data;

  template <typename... Args>
  static FieldRendererIdPtr New(Args&&... args) {
    return FieldRendererIdPtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static FieldRendererIdPtr From(const U& u) {
    return mojo::TypeConverter<FieldRendererIdPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, FieldRendererId>::Convert(*this);
  }


  FieldRendererId();

  explicit FieldRendererId(
      uint64_t id);


  ~FieldRendererId();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = FieldRendererIdPtr>
  FieldRendererIdPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, FieldRendererId::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, FieldRendererId::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  size_t Hash(size_t seed) const;
  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        FieldRendererId::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        FieldRendererId::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::FieldRendererId_UnserializedMessageContext<
            UserType, FieldRendererId::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<FieldRendererId::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return FieldRendererId::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::FieldRendererId_UnserializedMessageContext<
            UserType, FieldRendererId::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<FieldRendererId::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
  uint64_t id;

  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, FieldRendererId::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, FieldRendererId::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, FieldRendererId::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, FieldRendererId::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}










class BLINK_COMMON_EXPORT CustomContextMenuItem {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<CustomContextMenuItem, T>::value>;
  using DataView = CustomContextMenuItemDataView;
  using Data_ = internal::CustomContextMenuItem_Data;

  template <typename... Args>
  static CustomContextMenuItemPtr New(Args&&... args) {
    return CustomContextMenuItemPtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static CustomContextMenuItemPtr From(const U& u) {
    return mojo::TypeConverter<CustomContextMenuItemPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, CustomContextMenuItem>::Convert(*this);
  }


  CustomContextMenuItem();

  CustomContextMenuItem(
      const ::std::u16string& label,
      const ::std::u16string& icon,
      const ::std::u16string& tool_tip,
      CustomContextMenuItemType type,
      int32_t action,
      bool rtl,
      bool has_directional_override,
      bool enabled,
      bool checked,
      std::vector<CustomContextMenuItemPtr> submenu);

CustomContextMenuItem(const CustomContextMenuItem&) = delete;
CustomContextMenuItem& operator=(const CustomContextMenuItem&) = delete;

  ~CustomContextMenuItem();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = CustomContextMenuItemPtr>
  CustomContextMenuItemPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, CustomContextMenuItem::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, CustomContextMenuItem::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        CustomContextMenuItem::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        CustomContextMenuItem::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::CustomContextMenuItem_UnserializedMessageContext<
            UserType, CustomContextMenuItem::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<CustomContextMenuItem::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return CustomContextMenuItem::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::CustomContextMenuItem_UnserializedMessageContext<
            UserType, CustomContextMenuItem::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<CustomContextMenuItem::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
  ::std::u16string label;
  
  ::std::u16string icon;
  
  ::std::u16string tool_tip;
  
  CustomContextMenuItemType type;
  
  int32_t action;
  
  bool rtl;
  
  bool has_directional_override;
  
  bool enabled;
  
  bool checked;
  
  std::vector<CustomContextMenuItemPtr> submenu;

  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, CustomContextMenuItem::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, CustomContextMenuItem::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, CustomContextMenuItem::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, CustomContextMenuItem::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





class BLINK_COMMON_EXPORT UntrustworthyContextMenuParams {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<UntrustworthyContextMenuParams, T>::value>;
  using DataView = UntrustworthyContextMenuParamsDataView;
  using Data_ = internal::UntrustworthyContextMenuParams_Data;

  template <typename... Args>
  static UntrustworthyContextMenuParamsPtr New(Args&&... args) {
    return UntrustworthyContextMenuParamsPtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static UntrustworthyContextMenuParamsPtr From(const U& u) {
    return mojo::TypeConverter<UntrustworthyContextMenuParamsPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, UntrustworthyContextMenuParams>::Convert(*this);
  }


  UntrustworthyContextMenuParams();

  UntrustworthyContextMenuParams(
      ContextMenuDataMediaType media_type,
      int32_t x,
      int32_t y,
      const ::GURL& link_url,
      const ::std::u16string& link_text,
      const absl::optional<::blink::Impression>& impression,
      const ::GURL& unfiltered_link_url,
      const ::GURL& src_url,
      bool has_image_contents,
      int32_t media_flags,
      const ::std::u16string& selection_text,
      const ::std::u16string& title_text,
      const ::std::u16string& alt_text,
      const ::std::u16string& suggested_filename,
      const ::std::u16string& misspelled_word,
      std::vector<::std::u16string> dictionary_suggestions,
      bool spellcheck_enabled,
      bool is_editable,
      int32_t writing_direction_default,
      int32_t writing_direction_left_to_right,
      int32_t writing_direction_right_to_left,
      int32_t edit_flags,
      const std::string& frame_charset,
      ::network::mojom::ReferrerPolicy referrer_policy,
      const ::GURL& link_followed,
      std::vector<CustomContextMenuItemPtr> custom_items,
      ::ui::MenuSourceType source_type,
      ContextMenuDataInputFieldType input_field_type,
      const ::gfx::Rect& selection_rect,
      int32_t selection_start_offset,
      bool opened_from_highlight,
      FieldRendererIdPtr field_renderer_id);

UntrustworthyContextMenuParams(const UntrustworthyContextMenuParams&) = delete;
UntrustworthyContextMenuParams& operator=(const UntrustworthyContextMenuParams&) = delete;

  ~UntrustworthyContextMenuParams();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = UntrustworthyContextMenuParamsPtr>
  UntrustworthyContextMenuParamsPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, UntrustworthyContextMenuParams::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, UntrustworthyContextMenuParams::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        UntrustworthyContextMenuParams::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        UntrustworthyContextMenuParams::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::UntrustworthyContextMenuParams_UnserializedMessageContext<
            UserType, UntrustworthyContextMenuParams::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<UntrustworthyContextMenuParams::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return UntrustworthyContextMenuParams::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::UntrustworthyContextMenuParams_UnserializedMessageContext<
            UserType, UntrustworthyContextMenuParams::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<UntrustworthyContextMenuParams::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
  ContextMenuDataMediaType media_type;
  
  int32_t x;
  
  int32_t y;
  
  ::GURL link_url;
  
  ::std::u16string link_text;
  
  absl::optional<::blink::Impression> impression;
  
  ::GURL unfiltered_link_url;
  
  ::GURL src_url;
  
  bool has_image_contents;
  
  int32_t media_flags;
  
  ::std::u16string selection_text;
  
  ::std::u16string title_text;
  
  ::std::u16string alt_text;
  
  ::std::u16string suggested_filename;
  
  ::std::u16string misspelled_word;
  
  std::vector<::std::u16string> dictionary_suggestions;
  
  bool spellcheck_enabled;
  
  bool is_editable;
  
  int32_t writing_direction_default;
  
  int32_t writing_direction_left_to_right;
  
  int32_t writing_direction_right_to_left;
  
  int32_t edit_flags;
  
  std::string frame_charset;
  
  ::network::mojom::ReferrerPolicy referrer_policy;
  
  ::GURL link_followed;
  
  std::vector<CustomContextMenuItemPtr> custom_items;
  
  ::ui::MenuSourceType source_type;
  
  ContextMenuDataInputFieldType input_field_type;
  
  ::gfx::Rect selection_rect;
  
  int32_t selection_start_offset;
  
  bool opened_from_highlight;
  
  FieldRendererIdPtr field_renderer_id;

  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, UntrustworthyContextMenuParams::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, UntrustworthyContextMenuParams::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, UntrustworthyContextMenuParams::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, UntrustworthyContextMenuParams::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}

template <typename StructPtrType>
FieldRendererIdPtr FieldRendererId::Clone() const {
  return New(
      mojo::Clone(id)
  );
}

template <typename T, FieldRendererId::EnableIfSame<T>*>
bool FieldRendererId::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->id, other_struct.id))
    return false;
  return true;
}

template <typename T, FieldRendererId::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.id < rhs.id)
    return true;
  if (rhs.id < lhs.id)
    return false;
  return false;
}
template <typename StructPtrType>
CustomContextMenuItemPtr CustomContextMenuItem::Clone() const {
  return New(
      mojo::Clone(label),
      mojo::Clone(icon),
      mojo::Clone(tool_tip),
      mojo::Clone(type),
      mojo::Clone(action),
      mojo::Clone(rtl),
      mojo::Clone(has_directional_override),
      mojo::Clone(enabled),
      mojo::Clone(checked),
      mojo::Clone(submenu)
  );
}

template <typename T, CustomContextMenuItem::EnableIfSame<T>*>
bool CustomContextMenuItem::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->label, other_struct.label))
    return false;
  if (!mojo::Equals(this->icon, other_struct.icon))
    return false;
  if (!mojo::Equals(this->tool_tip, other_struct.tool_tip))
    return false;
  if (!mojo::Equals(this->type, other_struct.type))
    return false;
  if (!mojo::Equals(this->action, other_struct.action))
    return false;
  if (!mojo::Equals(this->rtl, other_struct.rtl))
    return false;
  if (!mojo::Equals(this->has_directional_override, other_struct.has_directional_override))
    return false;
  if (!mojo::Equals(this->enabled, other_struct.enabled))
    return false;
  if (!mojo::Equals(this->checked, other_struct.checked))
    return false;
  if (!mojo::Equals(this->submenu, other_struct.submenu))
    return false;
  return true;
}

template <typename T, CustomContextMenuItem::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.label < rhs.label)
    return true;
  if (rhs.label < lhs.label)
    return false;
  if (lhs.icon < rhs.icon)
    return true;
  if (rhs.icon < lhs.icon)
    return false;
  if (lhs.tool_tip < rhs.tool_tip)
    return true;
  if (rhs.tool_tip < lhs.tool_tip)
    return false;
  if (lhs.type < rhs.type)
    return true;
  if (rhs.type < lhs.type)
    return false;
  if (lhs.action < rhs.action)
    return true;
  if (rhs.action < lhs.action)
    return false;
  if (lhs.rtl < rhs.rtl)
    return true;
  if (rhs.rtl < lhs.rtl)
    return false;
  if (lhs.has_directional_override < rhs.has_directional_override)
    return true;
  if (rhs.has_directional_override < lhs.has_directional_override)
    return false;
  if (lhs.enabled < rhs.enabled)
    return true;
  if (rhs.enabled < lhs.enabled)
    return false;
  if (lhs.checked < rhs.checked)
    return true;
  if (rhs.checked < lhs.checked)
    return false;
  if (lhs.submenu < rhs.submenu)
    return true;
  if (rhs.submenu < lhs.submenu)
    return false;
  return false;
}
template <typename StructPtrType>
UntrustworthyContextMenuParamsPtr UntrustworthyContextMenuParams::Clone() const {
  return New(
      mojo::Clone(media_type),
      mojo::Clone(x),
      mojo::Clone(y),
      mojo::Clone(link_url),
      mojo::Clone(link_text),
      mojo::Clone(impression),
      mojo::Clone(unfiltered_link_url),
      mojo::Clone(src_url),
      mojo::Clone(has_image_contents),
      mojo::Clone(media_flags),
      mojo::Clone(selection_text),
      mojo::Clone(title_text),
      mojo::Clone(alt_text),
      mojo::Clone(suggested_filename),
      mojo::Clone(misspelled_word),
      mojo::Clone(dictionary_suggestions),
      mojo::Clone(spellcheck_enabled),
      mojo::Clone(is_editable),
      mojo::Clone(writing_direction_default),
      mojo::Clone(writing_direction_left_to_right),
      mojo::Clone(writing_direction_right_to_left),
      mojo::Clone(edit_flags),
      mojo::Clone(frame_charset),
      mojo::Clone(referrer_policy),
      mojo::Clone(link_followed),
      mojo::Clone(custom_items),
      mojo::Clone(source_type),
      mojo::Clone(input_field_type),
      mojo::Clone(selection_rect),
      mojo::Clone(selection_start_offset),
      mojo::Clone(opened_from_highlight),
      mojo::Clone(field_renderer_id)
  );
}

template <typename T, UntrustworthyContextMenuParams::EnableIfSame<T>*>
bool UntrustworthyContextMenuParams::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->media_type, other_struct.media_type))
    return false;
  if (!mojo::Equals(this->x, other_struct.x))
    return false;
  if (!mojo::Equals(this->y, other_struct.y))
    return false;
  if (!mojo::Equals(this->link_url, other_struct.link_url))
    return false;
  if (!mojo::Equals(this->link_text, other_struct.link_text))
    return false;
  if (!mojo::Equals(this->impression, other_struct.impression))
    return false;
  if (!mojo::Equals(this->unfiltered_link_url, other_struct.unfiltered_link_url))
    return false;
  if (!mojo::Equals(this->src_url, other_struct.src_url))
    return false;
  if (!mojo::Equals(this->has_image_contents, other_struct.has_image_contents))
    return false;
  if (!mojo::Equals(this->media_flags, other_struct.media_flags))
    return false;
  if (!mojo::Equals(this->selection_text, other_struct.selection_text))
    return false;
  if (!mojo::Equals(this->title_text, other_struct.title_text))
    return false;
  if (!mojo::Equals(this->alt_text, other_struct.alt_text))
    return false;
  if (!mojo::Equals(this->suggested_filename, other_struct.suggested_filename))
    return false;
  if (!mojo::Equals(this->misspelled_word, other_struct.misspelled_word))
    return false;
  if (!mojo::Equals(this->dictionary_suggestions, other_struct.dictionary_suggestions))
    return false;
  if (!mojo::Equals(this->spellcheck_enabled, other_struct.spellcheck_enabled))
    return false;
  if (!mojo::Equals(this->is_editable, other_struct.is_editable))
    return false;
  if (!mojo::Equals(this->writing_direction_default, other_struct.writing_direction_default))
    return false;
  if (!mojo::Equals(this->writing_direction_left_to_right, other_struct.writing_direction_left_to_right))
    return false;
  if (!mojo::Equals(this->writing_direction_right_to_left, other_struct.writing_direction_right_to_left))
    return false;
  if (!mojo::Equals(this->edit_flags, other_struct.edit_flags))
    return false;
  if (!mojo::Equals(this->frame_charset, other_struct.frame_charset))
    return false;
  if (!mojo::Equals(this->referrer_policy, other_struct.referrer_policy))
    return false;
  if (!mojo::Equals(this->link_followed, other_struct.link_followed))
    return false;
  if (!mojo::Equals(this->custom_items, other_struct.custom_items))
    return false;
  if (!mojo::Equals(this->source_type, other_struct.source_type))
    return false;
  if (!mojo::Equals(this->input_field_type, other_struct.input_field_type))
    return false;
  if (!mojo::Equals(this->selection_rect, other_struct.selection_rect))
    return false;
  if (!mojo::Equals(this->selection_start_offset, other_struct.selection_start_offset))
    return false;
  if (!mojo::Equals(this->opened_from_highlight, other_struct.opened_from_highlight))
    return false;
  if (!mojo::Equals(this->field_renderer_id, other_struct.field_renderer_id))
    return false;
  return true;
}

template <typename T, UntrustworthyContextMenuParams::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.media_type < rhs.media_type)
    return true;
  if (rhs.media_type < lhs.media_type)
    return false;
  if (lhs.x < rhs.x)
    return true;
  if (rhs.x < lhs.x)
    return false;
  if (lhs.y < rhs.y)
    return true;
  if (rhs.y < lhs.y)
    return false;
  if (lhs.link_url < rhs.link_url)
    return true;
  if (rhs.link_url < lhs.link_url)
    return false;
  if (lhs.link_text < rhs.link_text)
    return true;
  if (rhs.link_text < lhs.link_text)
    return false;
  if (lhs.impression < rhs.impression)
    return true;
  if (rhs.impression < lhs.impression)
    return false;
  if (lhs.unfiltered_link_url < rhs.unfiltered_link_url)
    return true;
  if (rhs.unfiltered_link_url < lhs.unfiltered_link_url)
    return false;
  if (lhs.src_url < rhs.src_url)
    return true;
  if (rhs.src_url < lhs.src_url)
    return false;
  if (lhs.has_image_contents < rhs.has_image_contents)
    return true;
  if (rhs.has_image_contents < lhs.has_image_contents)
    return false;
  if (lhs.media_flags < rhs.media_flags)
    return true;
  if (rhs.media_flags < lhs.media_flags)
    return false;
  if (lhs.selection_text < rhs.selection_text)
    return true;
  if (rhs.selection_text < lhs.selection_text)
    return false;
  if (lhs.title_text < rhs.title_text)
    return true;
  if (rhs.title_text < lhs.title_text)
    return false;
  if (lhs.alt_text < rhs.alt_text)
    return true;
  if (rhs.alt_text < lhs.alt_text)
    return false;
  if (lhs.suggested_filename < rhs.suggested_filename)
    return true;
  if (rhs.suggested_filename < lhs.suggested_filename)
    return false;
  if (lhs.misspelled_word < rhs.misspelled_word)
    return true;
  if (rhs.misspelled_word < lhs.misspelled_word)
    return false;
  if (lhs.dictionary_suggestions < rhs.dictionary_suggestions)
    return true;
  if (rhs.dictionary_suggestions < lhs.dictionary_suggestions)
    return false;
  if (lhs.spellcheck_enabled < rhs.spellcheck_enabled)
    return true;
  if (rhs.spellcheck_enabled < lhs.spellcheck_enabled)
    return false;
  if (lhs.is_editable < rhs.is_editable)
    return true;
  if (rhs.is_editable < lhs.is_editable)
    return false;
  if (lhs.writing_direction_default < rhs.writing_direction_default)
    return true;
  if (rhs.writing_direction_default < lhs.writing_direction_default)
    return false;
  if (lhs.writing_direction_left_to_right < rhs.writing_direction_left_to_right)
    return true;
  if (rhs.writing_direction_left_to_right < lhs.writing_direction_left_to_right)
    return false;
  if (lhs.writing_direction_right_to_left < rhs.writing_direction_right_to_left)
    return true;
  if (rhs.writing_direction_right_to_left < lhs.writing_direction_right_to_left)
    return false;
  if (lhs.edit_flags < rhs.edit_flags)
    return true;
  if (rhs.edit_flags < lhs.edit_flags)
    return false;
  if (lhs.frame_charset < rhs.frame_charset)
    return true;
  if (rhs.frame_charset < lhs.frame_charset)
    return false;
  if (lhs.referrer_policy < rhs.referrer_policy)
    return true;
  if (rhs.referrer_policy < lhs.referrer_policy)
    return false;
  if (lhs.link_followed < rhs.link_followed)
    return true;
  if (rhs.link_followed < lhs.link_followed)
    return false;
  if (lhs.custom_items < rhs.custom_items)
    return true;
  if (rhs.custom_items < lhs.custom_items)
    return false;
  if (lhs.source_type < rhs.source_type)
    return true;
  if (rhs.source_type < lhs.source_type)
    return false;
  if (lhs.input_field_type < rhs.input_field_type)
    return true;
  if (rhs.input_field_type < lhs.input_field_type)
    return false;
  if (lhs.selection_rect < rhs.selection_rect)
    return true;
  if (rhs.selection_rect < lhs.selection_rect)
    return false;
  if (lhs.selection_start_offset < rhs.selection_start_offset)
    return true;
  if (rhs.selection_start_offset < lhs.selection_start_offset)
    return false;
  if (lhs.opened_from_highlight < rhs.opened_from_highlight)
    return true;
  if (rhs.opened_from_highlight < lhs.opened_from_highlight)
    return false;
  if (lhs.field_renderer_id < rhs.field_renderer_id)
    return true;
  if (rhs.field_renderer_id < lhs.field_renderer_id)
    return false;
  return false;
}


}  // namespace mojom
}  // namespace blink

namespace mojo {


template <>
struct BLINK_COMMON_EXPORT StructTraits<::blink::mojom::FieldRendererId::DataView,
                                         ::blink::mojom::FieldRendererIdPtr> {
  static bool IsNull(const ::blink::mojom::FieldRendererIdPtr& input) { return !input; }
  static void SetToNull(::blink::mojom::FieldRendererIdPtr* output) { output->reset(); }

  static decltype(::blink::mojom::FieldRendererId::id) id(
      const ::blink::mojom::FieldRendererIdPtr& input) {
    return input->id;
  }

  static bool Read(::blink::mojom::FieldRendererId::DataView input, ::blink::mojom::FieldRendererIdPtr* output);
};


template <>
struct BLINK_COMMON_EXPORT StructTraits<::blink::mojom::CustomContextMenuItem::DataView,
                                         ::blink::mojom::CustomContextMenuItemPtr> {
  static bool IsNull(const ::blink::mojom::CustomContextMenuItemPtr& input) { return !input; }
  static void SetToNull(::blink::mojom::CustomContextMenuItemPtr* output) { output->reset(); }

  static const decltype(::blink::mojom::CustomContextMenuItem::label)& label(
      const ::blink::mojom::CustomContextMenuItemPtr& input) {
    return input->label;
  }

  static const decltype(::blink::mojom::CustomContextMenuItem::icon)& icon(
      const ::blink::mojom::CustomContextMenuItemPtr& input) {
    return input->icon;
  }

  static const decltype(::blink::mojom::CustomContextMenuItem::tool_tip)& tool_tip(
      const ::blink::mojom::CustomContextMenuItemPtr& input) {
    return input->tool_tip;
  }

  static decltype(::blink::mojom::CustomContextMenuItem::type) type(
      const ::blink::mojom::CustomContextMenuItemPtr& input) {
    return input->type;
  }

  static decltype(::blink::mojom::CustomContextMenuItem::action) action(
      const ::blink::mojom::CustomContextMenuItemPtr& input) {
    return input->action;
  }

  static decltype(::blink::mojom::CustomContextMenuItem::rtl) rtl(
      const ::blink::mojom::CustomContextMenuItemPtr& input) {
    return input->rtl;
  }

  static decltype(::blink::mojom::CustomContextMenuItem::has_directional_override) has_directional_override(
      const ::blink::mojom::CustomContextMenuItemPtr& input) {
    return input->has_directional_override;
  }

  static decltype(::blink::mojom::CustomContextMenuItem::enabled) enabled(
      const ::blink::mojom::CustomContextMenuItemPtr& input) {
    return input->enabled;
  }

  static decltype(::blink::mojom::CustomContextMenuItem::checked) checked(
      const ::blink::mojom::CustomContextMenuItemPtr& input) {
    return input->checked;
  }

  static const decltype(::blink::mojom::CustomContextMenuItem::submenu)& submenu(
      const ::blink::mojom::CustomContextMenuItemPtr& input) {
    return input->submenu;
  }

  static bool Read(::blink::mojom::CustomContextMenuItem::DataView input, ::blink::mojom::CustomContextMenuItemPtr* output);
};


template <>
struct BLINK_COMMON_EXPORT StructTraits<::blink::mojom::UntrustworthyContextMenuParams::DataView,
                                         ::blink::mojom::UntrustworthyContextMenuParamsPtr> {
  static bool IsNull(const ::blink::mojom::UntrustworthyContextMenuParamsPtr& input) { return !input; }
  static void SetToNull(::blink::mojom::UntrustworthyContextMenuParamsPtr* output) { output->reset(); }

  static decltype(::blink::mojom::UntrustworthyContextMenuParams::media_type) media_type(
      const ::blink::mojom::UntrustworthyContextMenuParamsPtr& input) {
    return input->media_type;
  }

  static decltype(::blink::mojom::UntrustworthyContextMenuParams::x) x(
      const ::blink::mojom::UntrustworthyContextMenuParamsPtr& input) {
    return input->x;
  }

  static decltype(::blink::mojom::UntrustworthyContextMenuParams::y) y(
      const ::blink::mojom::UntrustworthyContextMenuParamsPtr& input) {
    return input->y;
  }

  static const decltype(::blink::mojom::UntrustworthyContextMenuParams::link_url)& link_url(
      const ::blink::mojom::UntrustworthyContextMenuParamsPtr& input) {
    return input->link_url;
  }

  static const decltype(::blink::mojom::UntrustworthyContextMenuParams::link_text)& link_text(
      const ::blink::mojom::UntrustworthyContextMenuParamsPtr& input) {
    return input->link_text;
  }

  static const decltype(::blink::mojom::UntrustworthyContextMenuParams::impression)& impression(
      const ::blink::mojom::UntrustworthyContextMenuParamsPtr& input) {
    return input->impression;
  }

  static const decltype(::blink::mojom::UntrustworthyContextMenuParams::unfiltered_link_url)& unfiltered_link_url(
      const ::blink::mojom::UntrustworthyContextMenuParamsPtr& input) {
    return input->unfiltered_link_url;
  }

  static const decltype(::blink::mojom::UntrustworthyContextMenuParams::src_url)& src_url(
      const ::blink::mojom::UntrustworthyContextMenuParamsPtr& input) {
    return input->src_url;
  }

  static decltype(::blink::mojom::UntrustworthyContextMenuParams::has_image_contents) has_image_contents(
      const ::blink::mojom::UntrustworthyContextMenuParamsPtr& input) {
    return input->has_image_contents;
  }

  static decltype(::blink::mojom::UntrustworthyContextMenuParams::media_flags) media_flags(
      const ::blink::mojom::UntrustworthyContextMenuParamsPtr& input) {
    return input->media_flags;
  }

  static const decltype(::blink::mojom::UntrustworthyContextMenuParams::selection_text)& selection_text(
      const ::blink::mojom::UntrustworthyContextMenuParamsPtr& input) {
    return input->selection_text;
  }

  static const decltype(::blink::mojom::UntrustworthyContextMenuParams::title_text)& title_text(
      const ::blink::mojom::UntrustworthyContextMenuParamsPtr& input) {
    return input->title_text;
  }

  static const decltype(::blink::mojom::UntrustworthyContextMenuParams::alt_text)& alt_text(
      const ::blink::mojom::UntrustworthyContextMenuParamsPtr& input) {
    return input->alt_text;
  }

  static const decltype(::blink::mojom::UntrustworthyContextMenuParams::suggested_filename)& suggested_filename(
      const ::blink::mojom::UntrustworthyContextMenuParamsPtr& input) {
    return input->suggested_filename;
  }

  static const decltype(::blink::mojom::UntrustworthyContextMenuParams::misspelled_word)& misspelled_word(
      const ::blink::mojom::UntrustworthyContextMenuParamsPtr& input) {
    return input->misspelled_word;
  }

  static const decltype(::blink::mojom::UntrustworthyContextMenuParams::dictionary_suggestions)& dictionary_suggestions(
      const ::blink::mojom::UntrustworthyContextMenuParamsPtr& input) {
    return input->dictionary_suggestions;
  }

  static decltype(::blink::mojom::UntrustworthyContextMenuParams::spellcheck_enabled) spellcheck_enabled(
      const ::blink::mojom::UntrustworthyContextMenuParamsPtr& input) {
    return input->spellcheck_enabled;
  }

  static decltype(::blink::mojom::UntrustworthyContextMenuParams::is_editable) is_editable(
      const ::blink::mojom::UntrustworthyContextMenuParamsPtr& input) {
    return input->is_editable;
  }

  static decltype(::blink::mojom::UntrustworthyContextMenuParams::writing_direction_default) writing_direction_default(
      const ::blink::mojom::UntrustworthyContextMenuParamsPtr& input) {
    return input->writing_direction_default;
  }

  static decltype(::blink::mojom::UntrustworthyContextMenuParams::writing_direction_left_to_right) writing_direction_left_to_right(
      const ::blink::mojom::UntrustworthyContextMenuParamsPtr& input) {
    return input->writing_direction_left_to_right;
  }

  static decltype(::blink::mojom::UntrustworthyContextMenuParams::writing_direction_right_to_left) writing_direction_right_to_left(
      const ::blink::mojom::UntrustworthyContextMenuParamsPtr& input) {
    return input->writing_direction_right_to_left;
  }

  static decltype(::blink::mojom::UntrustworthyContextMenuParams::edit_flags) edit_flags(
      const ::blink::mojom::UntrustworthyContextMenuParamsPtr& input) {
    return input->edit_flags;
  }

  static const decltype(::blink::mojom::UntrustworthyContextMenuParams::frame_charset)& frame_charset(
      const ::blink::mojom::UntrustworthyContextMenuParamsPtr& input) {
    return input->frame_charset;
  }

  static decltype(::blink::mojom::UntrustworthyContextMenuParams::referrer_policy) referrer_policy(
      const ::blink::mojom::UntrustworthyContextMenuParamsPtr& input) {
    return input->referrer_policy;
  }

  static const decltype(::blink::mojom::UntrustworthyContextMenuParams::link_followed)& link_followed(
      const ::blink::mojom::UntrustworthyContextMenuParamsPtr& input) {
    return input->link_followed;
  }

  static const decltype(::blink::mojom::UntrustworthyContextMenuParams::custom_items)& custom_items(
      const ::blink::mojom::UntrustworthyContextMenuParamsPtr& input) {
    return input->custom_items;
  }

  static decltype(::blink::mojom::UntrustworthyContextMenuParams::source_type) source_type(
      const ::blink::mojom::UntrustworthyContextMenuParamsPtr& input) {
    return input->source_type;
  }

  static decltype(::blink::mojom::UntrustworthyContextMenuParams::input_field_type) input_field_type(
      const ::blink::mojom::UntrustworthyContextMenuParamsPtr& input) {
    return input->input_field_type;
  }

  static const decltype(::blink::mojom::UntrustworthyContextMenuParams::selection_rect)& selection_rect(
      const ::blink::mojom::UntrustworthyContextMenuParamsPtr& input) {
    return input->selection_rect;
  }

  static decltype(::blink::mojom::UntrustworthyContextMenuParams::selection_start_offset) selection_start_offset(
      const ::blink::mojom::UntrustworthyContextMenuParamsPtr& input) {
    return input->selection_start_offset;
  }

  static decltype(::blink::mojom::UntrustworthyContextMenuParams::opened_from_highlight) opened_from_highlight(
      const ::blink::mojom::UntrustworthyContextMenuParamsPtr& input) {
    return input->opened_from_highlight;
  }

  static const decltype(::blink::mojom::UntrustworthyContextMenuParams::field_renderer_id)& field_renderer_id(
      const ::blink::mojom::UntrustworthyContextMenuParamsPtr& input) {
    return input->field_renderer_id;
  }

  static bool Read(::blink::mojom::UntrustworthyContextMenuParams::DataView input, ::blink::mojom::UntrustworthyContextMenuParamsPtr* output);
};

}  // namespace mojo

#endif  // THIRD_PARTY_BLINK_PUBLIC_MOJOM_CONTEXT_MENU_CONTEXT_MENU_MOJOM_H_