// Copyright 2019 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// DO NOT EDIT: This file is auto-generated by
// //third_party/blink/renderer/bindings/scripts/generate_bindings.py
//
// Use the GN flag `blink_enable_generated_code_formatting=true` to enable
// formatting of the generated files.

#ifndef THIRD_PARTY_BLINK_RENDERER_BINDINGS_MODULES_V8_V8_RTC_CONFIGURATION_H_
#define THIRD_PARTY_BLINK_RENDERER_BINDINGS_MODULES_V8_V8_RTC_CONFIGURATION_H_

#include "base/containers/span.h"
#include "third_party/blink/renderer/bindings/modules/v8/v8_rtc_bundle_policy.h"
#include "third_party/blink/renderer/bindings/modules/v8/v8_rtc_ice_transport_policy.h"
#include "third_party/blink/renderer/bindings/modules/v8/v8_rtc_rtcp_mux_policy.h"
#include "third_party/blink/renderer/bindings/modules/v8/v8_sdp_semantics.h"
#include "third_party/blink/renderer/modules/modules_export.h"
#include "third_party/blink/renderer/platform/bindings/dictionary_base.h"
#include "third_party/blink/renderer/platform/heap/collection_support/heap_vector.h"
#include "third_party/blink/renderer/platform/heap/member.h"

namespace blink {

class ExceptionState;
class RTCCertificate;
class RTCIceServer;

class MODULES_EXPORT RTCConfiguration : public bindings::DictionaryBase {
  
  public:
static RTCConfiguration* Create() {
  return MakeGarbageCollected<RTCConfiguration>();
}
static RTCConfiguration* Create(v8::Isolate* isolate) {
  return MakeGarbageCollected<RTCConfiguration>(isolate);
}
static RTCConfiguration* Create(v8::Isolate* isolate, v8::Local<v8::Value> v8_value, ExceptionState& exception_state);

explicit  RTCConfiguration();
explicit  RTCConfiguration(v8::Isolate* isolate);

bool hasBundlePolicy() const {
  return true;
}
V8RTCBundlePolicy bundlePolicy() const {
  return member_bundle_policy_;
}
void setBundlePolicy(V8RTCBundlePolicy value) {
  member_bundle_policy_ = value;
}
void setBundlePolicy(V8RTCBundlePolicy::Enum value) {
  member_bundle_policy_ = V8RTCBundlePolicy(value);
}

bool hasCertificates() const {
  return has_certificates_;
}
const HeapVector<Member<RTCCertificate>>& certificates() const {
  DCHECK(hasCertificates());
return member_certificates_;
}
HeapVector<Member<RTCCertificate>> getCertificatesOr(const HeapVector<Member<RTCCertificate>>& fallback_value) const;
HeapVector<Member<RTCCertificate>> getCertificatesOr(HeapVector<Member<RTCCertificate>>&& fallback_value) const;
void setCertificates(const HeapVector<Member<RTCCertificate>>& value);
void setCertificates(HeapVector<Member<RTCCertificate>>&& value);

bool hasEncodedInsertableStreams() const {
  return true;
}
bool encodedInsertableStreams() const {
  return member_encoded_insertable_streams_;
}
void setEncodedInsertableStreams(bool value) {
  member_encoded_insertable_streams_ = value;
}

bool hasIceCandidatePoolSize() const {
  return true;
}
uint8_t iceCandidatePoolSize() const {
  return member_ice_candidate_pool_size_;
}
void setIceCandidatePoolSize(uint8_t value) {
  member_ice_candidate_pool_size_ = value;
}

bool hasIceServers() const {
  return has_ice_servers_;
}
const HeapVector<Member<RTCIceServer>>& iceServers() const {
  DCHECK(hasIceServers());
return member_ice_servers_;
}
HeapVector<Member<RTCIceServer>> getIceServersOr(const HeapVector<Member<RTCIceServer>>& fallback_value) const;
HeapVector<Member<RTCIceServer>> getIceServersOr(HeapVector<Member<RTCIceServer>>&& fallback_value) const;
void setIceServers(const HeapVector<Member<RTCIceServer>>& value);
void setIceServers(HeapVector<Member<RTCIceServer>>&& value);

bool hasIceTransportPolicy() const {
  return has_ice_transport_policy_;
}
V8RTCIceTransportPolicy iceTransportPolicy() const {
  DCHECK(hasIceTransportPolicy());
return member_ice_transport_policy_;
}
V8RTCIceTransportPolicy getIceTransportPolicyOr(V8RTCIceTransportPolicy fallback_value) const {
  if (!hasIceTransportPolicy()) {
  return fallback_value;
}
return member_ice_transport_policy_;
}
void setIceTransportPolicy(V8RTCIceTransportPolicy value) {
  member_ice_transport_policy_ = value;
has_ice_transport_policy_ = true;
}
void setIceTransportPolicy(V8RTCIceTransportPolicy::Enum value) {
  member_ice_transport_policy_ = V8RTCIceTransportPolicy(value);
has_ice_transport_policy_ = true;
}

bool hasIceTransports() const {
  return has_ice_transports_;
}
V8RTCIceTransportPolicy iceTransports() const {
  DCHECK(hasIceTransports());
return member_ice_transports_;
}
V8RTCIceTransportPolicy getIceTransportsOr(V8RTCIceTransportPolicy fallback_value) const {
  if (!hasIceTransports()) {
  return fallback_value;
}
return member_ice_transports_;
}
void setIceTransports(V8RTCIceTransportPolicy value) {
  member_ice_transports_ = value;
has_ice_transports_ = true;
}
void setIceTransports(V8RTCIceTransportPolicy::Enum value) {
  member_ice_transports_ = V8RTCIceTransportPolicy(value);
has_ice_transports_ = true;
}

bool hasRtcAudioJitterBufferFastAccelerate() const {
  return has_rtc_audio_jitter_buffer_fast_accelerate_;
}
bool rtcAudioJitterBufferFastAccelerate() const {
  DCHECK(hasRtcAudioJitterBufferFastAccelerate());
return member_rtc_audio_jitter_buffer_fast_accelerate_;
}
bool getRtcAudioJitterBufferFastAccelerateOr(bool fallback_value) const {
  if (!hasRtcAudioJitterBufferFastAccelerate()) {
  return fallback_value;
}
return member_rtc_audio_jitter_buffer_fast_accelerate_;
}
void setRtcAudioJitterBufferFastAccelerate(bool value) {
  member_rtc_audio_jitter_buffer_fast_accelerate_ = value;
has_rtc_audio_jitter_buffer_fast_accelerate_ = true;
}

bool hasRtcAudioJitterBufferMaxPackets() const {
  return has_rtc_audio_jitter_buffer_max_packets_;
}
int32_t rtcAudioJitterBufferMaxPackets() const {
  DCHECK(hasRtcAudioJitterBufferMaxPackets());
return member_rtc_audio_jitter_buffer_max_packets_;
}
int32_t getRtcAudioJitterBufferMaxPacketsOr(int32_t fallback_value) const {
  if (!hasRtcAudioJitterBufferMaxPackets()) {
  return fallback_value;
}
return member_rtc_audio_jitter_buffer_max_packets_;
}
void setRtcAudioJitterBufferMaxPackets(int32_t value) {
  member_rtc_audio_jitter_buffer_max_packets_ = value;
has_rtc_audio_jitter_buffer_max_packets_ = true;
}

bool hasRtcAudioJitterBufferMinDelayMs() const {
  return has_rtc_audio_jitter_buffer_min_delay_ms_;
}
int32_t rtcAudioJitterBufferMinDelayMs() const {
  DCHECK(hasRtcAudioJitterBufferMinDelayMs());
return member_rtc_audio_jitter_buffer_min_delay_ms_;
}
int32_t getRtcAudioJitterBufferMinDelayMsOr(int32_t fallback_value) const {
  if (!hasRtcAudioJitterBufferMinDelayMs()) {
  return fallback_value;
}
return member_rtc_audio_jitter_buffer_min_delay_ms_;
}
void setRtcAudioJitterBufferMinDelayMs(int32_t value) {
  member_rtc_audio_jitter_buffer_min_delay_ms_ = value;
has_rtc_audio_jitter_buffer_min_delay_ms_ = true;
}

bool hasRtcpMuxPolicy() const {
  return true;
}
V8RTCRtcpMuxPolicy rtcpMuxPolicy() const {
  return member_rtcp_mux_policy_;
}
void setRtcpMuxPolicy(V8RTCRtcpMuxPolicy value) {
  member_rtcp_mux_policy_ = value;
}
void setRtcpMuxPolicy(V8RTCRtcpMuxPolicy::Enum value) {
  member_rtcp_mux_policy_ = V8RTCRtcpMuxPolicy(value);
}

bool hasSdpSemantics() const {
  return has_sdp_semantics_;
}
V8SdpSemantics sdpSemantics() const {
  DCHECK(hasSdpSemantics());
return member_sdp_semantics_;
}
V8SdpSemantics getSdpSemanticsOr(V8SdpSemantics fallback_value) const {
  if (!hasSdpSemantics()) {
  return fallback_value;
}
return member_sdp_semantics_;
}
void setSdpSemantics(V8SdpSemantics value) {
  member_sdp_semantics_ = value;
has_sdp_semantics_ = true;
}
void setSdpSemantics(V8SdpSemantics::Enum value) {
  member_sdp_semantics_ = V8SdpSemantics(value);
has_sdp_semantics_ = true;
}


// Obsolete accessor functions
void setBundlePolicy(const String& value) {
  member_bundle_policy_ = V8RTCBundlePolicy::Create(value).value();
}
void setIceTransportPolicy(const String& value) {
  member_ice_transport_policy_ = V8RTCIceTransportPolicy::Create(value).value();
has_ice_transport_policy_ = true;
}
void setIceTransports(const String& value) {
  member_ice_transports_ = V8RTCIceTransportPolicy::Create(value).value();
has_ice_transports_ = true;
}
void setRtcpMuxPolicy(const String& value) {
  member_rtcp_mux_policy_ = V8RTCRtcpMuxPolicy::Create(value).value();
}
void setSdpSemantics(const String& value) {
  member_sdp_semantics_ = V8SdpSemantics::Create(value).value();
has_sdp_semantics_ = true;
}

void Trace(Visitor* visitor) const override;


  protected:
bool FillV8ObjectWithMembers(ScriptState* script_state, v8::Local<v8::Object> v8_dictionary) const override;

void FillMembersFromV8Object(v8::Isolate* isolate, v8::Local<v8::Object> v8_dictionary, ExceptionState& exception_state);


  private:
static const base::span<const v8::Eternal<v8::Name>> GetV8OwnMemberNames(v8::Isolate* isolate);

bool has_certificates_ = false;
bool has_ice_servers_ = false;
bool has_ice_transport_policy_ = false;
bool has_ice_transports_ = false;
bool has_rtc_audio_jitter_buffer_fast_accelerate_ = false;
bool has_rtc_audio_jitter_buffer_max_packets_ = false;
bool has_rtc_audio_jitter_buffer_min_delay_ms_ = false;
bool has_sdp_semantics_ = false;

V8RTCBundlePolicy member_bundle_policy_{V8RTCBundlePolicy::Enum::kBalanced};
HeapVector<Member<RTCCertificate>> member_certificates_;
bool member_encoded_insertable_streams_{false};
uint8_t member_ice_candidate_pool_size_{0};
HeapVector<Member<RTCIceServer>> member_ice_servers_;
V8RTCIceTransportPolicy member_ice_transport_policy_{static_cast<V8RTCIceTransportPolicy::Enum>(0)};
V8RTCIceTransportPolicy member_ice_transports_{static_cast<V8RTCIceTransportPolicy::Enum>(0)};
bool member_rtc_audio_jitter_buffer_fast_accelerate_;
int32_t member_rtc_audio_jitter_buffer_max_packets_;
int32_t member_rtc_audio_jitter_buffer_min_delay_ms_;
V8RTCRtcpMuxPolicy member_rtcp_mux_policy_{V8RTCRtcpMuxPolicy::Enum::kRequire};
V8SdpSemantics member_sdp_semantics_{static_cast<V8SdpSemantics::Enum>(0)};


  
};


}  // namespace blink

#endif  // THIRD_PARTY_BLINK_RENDERER_BINDINGS_MODULES_V8_V8_RTC_CONFIGURATION_H_
