// Copyright 2019 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// DO NOT EDIT: This file is auto-generated by
// //third_party/blink/renderer/bindings/scripts/generate_bindings.py
//
// Use the GN flag `blink_enable_generated_code_formatting=true` to enable
// formatting of the generated files.

#include "third_party/blink/renderer/bindings/modules/v8/v8_element.h"

#include "third_party/blink/renderer/bindings/core/v8/generated_code_helper.h"
#include "third_party/blink/renderer/bindings/core/v8/native_value_traits_impl.h"
#include "third_party/blink/renderer/bindings/core/v8/to_v8_traits.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_accessible_node.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_animation.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_attr.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_check_visibility_options.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_dom_rect.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_dom_rect_list.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_dom_token_list.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_event_handler_non_null.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_fullscreen_options.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_get_animations_options.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_get_inner_html_options.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_html_collection.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_html_slot_element.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_keyframe_animation_options.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_named_node_map.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_node.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_node_list.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_pointer_lock_options.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_scroll_into_view_options.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_scroll_to_options.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_set_return_value_for_core.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_shadow_root.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_shadow_root_init.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_style_property_map.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_style_property_map_read_only.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_trusted_html.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_trusted_script.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_trusted_script_url.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_union_boolean_scrollintoviewoptions.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_union_keyframeanimationoptions_unrestricteddouble.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_union_node_string_trustedscript.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_union_trustedhtml_trustedscript_trustedscripturl.h"
#include "third_party/blink/renderer/bindings/modules/v8/v8_element_set_html_options.h"
#include "third_party/blink/renderer/core/animation/animation.h"
#include "third_party/blink/renderer/core/aom/accessible_node.h"
#include "third_party/blink/renderer/core/css/cssom/element_computed_style_map.h"
#include "third_party/blink/renderer/core/css/cssom/style_property_map.h"
#include "third_party/blink/renderer/core/css/cssom/style_property_map_read_only.h"
#include "third_party/blink/renderer/core/dom/attr.h"
#include "third_party/blink/renderer/core/dom/child_node.h"
#include "third_party/blink/renderer/core/dom/dom_token_list.h"
#include "third_party/blink/renderer/core/dom/element.h"
#include "third_party/blink/renderer/core/dom/named_node_map.h"
#include "third_party/blink/renderer/core/dom/node.h"
#include "third_party/blink/renderer/core/dom/node_list.h"
#include "third_party/blink/renderer/core/dom/non_document_type_child_node.h"
#include "third_party/blink/renderer/core/dom/parent_node.h"
#include "third_party/blink/renderer/core/dom/shadow_root.h"
#include "third_party/blink/renderer/core/execution_context/execution_context.h"
#include "third_party/blink/renderer/core/frame/web_feature.h"
#include "third_party/blink/renderer/core/fullscreen/element_fullscreen.h"
#include "third_party/blink/renderer/core/geometry/dom_rect.h"
#include "third_party/blink/renderer/core/geometry/dom_rect_list.h"
#include "third_party/blink/renderer/core/html/custom/ce_reactions_scope.h"
#include "third_party/blink/renderer/core/html/html_collection.h"
#include "third_party/blink/renderer/core/html/html_slot_element.h"
#include "third_party/blink/renderer/core/html_names.h"
#include "third_party/blink/renderer/core/keywords.h"
#include "third_party/blink/renderer/core/trustedtypes/trusted_html.h"
#include "third_party/blink/renderer/core/trustedtypes/trusted_script.h"
#include "third_party/blink/renderer/core/trustedtypes/trusted_script_url.h"
#include "third_party/blink/renderer/modules/sanitizer_api/element_sanitizer.h"
#include "third_party/blink/renderer/platform/bindings/exception_messages.h"
#include "third_party/blink/renderer/platform/bindings/idl_member_installer.h"
#include "third_party/blink/renderer/platform/bindings/runtime_call_stats.h"
#include "third_party/blink/renderer/platform/bindings/v8_binding.h"
#include "third_party/blink/renderer/platform/bindings/v8_dom_activity_logger.h"
#include "third_party/blink/renderer/platform/bindings/v8_per_context_data.h"
#include "third_party/blink/renderer/platform/instrumentation/use_counter.h"
#include "third_party/blink/renderer/platform/scheduler/public/cooperative_scheduling_manager.h"

namespace blink {



void V8Element::Impl::Init() {
  V8Element::install_interface_template_func_ = InstallInterfaceTemplate;
V8Element::install_unconditional_props_func_ = InstallUnconditionalProperties;
V8Element::install_context_independent_props_func_ = InstallContextIndependentProperties;
V8Element::install_context_dependent_props_func_ = InstallContextDependentProperties;
}

namespace  {

namespace v8_element {

void NamespaceURIAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_namespaceURI_Getter");
BLINK_BINDINGS_TRACE_EVENT("Element.namespaceURI.get");


v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
auto&& return_value = blink_receiver->namespaceURI();
v8::Isolate* isolate = info.GetIsolate();
bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNullable);
}


void PrefixAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_prefix_Getter");
BLINK_BINDINGS_TRACE_EVENT("Element.prefix.get");


v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
auto&& return_value = blink_receiver->prefix();
v8::Isolate* isolate = info.GetIsolate();
bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNullable);
}


void LocalNameAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_localName_Getter");
BLINK_BINDINGS_TRACE_EVENT("Element.localName.get");


v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
auto&& return_value = blink_receiver->localName();
v8::Isolate* isolate = info.GetIsolate();
bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNonNullable);
}


void TagNameAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_tagName_Getter");
BLINK_BINDINGS_TRACE_EVENT("Element.tagName.get");


v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
auto&& return_value = blink_receiver->tagName();
v8::Isolate* isolate = info.GetIsolate();
bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNonNullable);
}


void IdAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_id_Getter");
BLINK_BINDINGS_TRACE_EVENT("Element.id.get");


v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
auto&& return_value = blink_receiver->GetIdAttribute();
v8::Isolate* isolate = info.GetIsolate();
bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNonNullable);
}

void IdAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_id_Setter");
BLINK_BINDINGS_TRACE_EVENT("Element.id.set");

const char* const class_like_name = "Element";
const char* const property_name = "id";
bindings::PerformAttributeSetCEReactionsReflectTypeString(info, html_names::kIdAttr, class_like_name, property_name);
}

void ClassNameAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_className_Getter");
BLINK_BINDINGS_TRACE_EVENT("Element.className.get");


v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
auto&& return_value = blink_receiver->GetClassAttribute();
v8::Isolate* isolate = info.GetIsolate();
bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNonNullable);
}

void ClassNameAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_className_Setter");
BLINK_BINDINGS_TRACE_EVENT("Element.className.set");

const char* const class_like_name = "Element";
const char* const property_name = "className";
bindings::PerformAttributeSetCEReactionsReflectTypeString(info, html_names::kClassAttr, class_like_name, property_name);
}

void ClassListAttributeGetCallbackForMainWorld(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_classList_Getter");
BLINK_BINDINGS_TRACE_EVENT("Element.classList.get");


v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
auto&& return_value = blink_receiver->classList();
bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::kMainWorld);
}

void ClassListAttributeSetCallbackForMainWorld(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_classList_Setter");
BLINK_BINDINGS_TRACE_EVENT("Element.classList.set");

v8::Isolate* isolate = info.GetIsolate();
const char* const property_name = "classList";
if (UNLIKELY(info.Length() < 1)) {
  const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kAttributeSet;
const char* const class_like_name = "Element";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(1, info.Length()));
return;
}

// [PutForwards]
v8::Local<v8::Value> target;
v8::Local<v8::Object> v8_receiver = info.This();
v8::Local<v8::Context> current_context = isolate->GetCurrentContext();
if (!v8_receiver->Get(current_context, V8AtomicString(isolate, property_name)).ToLocal(&target)) {
  return;
}
if (!target->IsObject()) {
  const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kAttributeSet;
const char* const class_like_name = "Element";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
exception_state.ThrowTypeError("The attribute value is not an object");
return;
}
bool did_set;
v8::Local<v8::Value> v8_property_value = info[0];
if (!target.As<v8::Object>()->Set(current_context, V8AtomicString(isolate, "value"), v8_property_value).To(&did_set)) {{
  return;
}}
}

void ClassListAttributeGetCallbackForNonMainWorlds(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_classList_Getter");
BLINK_BINDINGS_TRACE_EVENT("Element.classList.get");


v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
auto&& return_value = blink_receiver->classList();
bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void ClassListAttributeSetCallbackForNonMainWorlds(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_classList_Setter");
BLINK_BINDINGS_TRACE_EVENT("Element.classList.set");

v8::Isolate* isolate = info.GetIsolate();
const char* const property_name = "classList";
if (UNLIKELY(info.Length() < 1)) {
  const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kAttributeSet;
const char* const class_like_name = "Element";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(1, info.Length()));
return;
}

// [PutForwards]
v8::Local<v8::Value> target;
v8::Local<v8::Object> v8_receiver = info.This();
v8::Local<v8::Context> current_context = isolate->GetCurrentContext();
if (!v8_receiver->Get(current_context, V8AtomicString(isolate, property_name)).ToLocal(&target)) {
  return;
}
if (!target->IsObject()) {
  const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kAttributeSet;
const char* const class_like_name = "Element";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
exception_state.ThrowTypeError("The attribute value is not an object");
return;
}
bool did_set;
v8::Local<v8::Value> v8_property_value = info[0];
if (!target.As<v8::Object>()->Set(current_context, V8AtomicString(isolate, "value"), v8_property_value).To(&did_set)) {{
  return;
}}
}

void SlotAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_slot_Getter");
BLINK_BINDINGS_TRACE_EVENT("Element.slot.get");


v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
auto&& return_value = blink_receiver->FastGetAttribute(html_names::kSlotAttr);
v8::Isolate* isolate = info.GetIsolate();
bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNonNullable);
}

void SlotAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_slot_Setter");
BLINK_BINDINGS_TRACE_EVENT("Element.slot.set");

const char* const class_like_name = "Element";
const char* const property_name = "slot";
bindings::PerformAttributeSetCEReactionsReflectTypeString(info, html_names::kSlotAttr, class_like_name, property_name);
}

void AttributesAttributeGetCallbackForMainWorld(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_attributes_Getter");
BLINK_BINDINGS_TRACE_EVENT("Element.attributes.get");


v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
auto&& return_value = blink_receiver->attributesForBindings();
bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::kMainWorld);
}


void AttributesAttributeGetCallbackForNonMainWorlds(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_attributes_Getter");
BLINK_BINDINGS_TRACE_EVENT("Element.attributes.get");


v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
auto&& return_value = blink_receiver->attributesForBindings();
bindings::V8SetReturnValue(info, return_value, blink_receiver);
}


void ShadowRootAttributeGetCallbackForMainWorld(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_shadowRoot_Getter");
BLINK_BINDINGS_TRACE_EVENT("Element.shadowRoot.get");


v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
auto&& return_value = blink_receiver->OpenShadowRoot();
bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::kMainWorld);
}


void ShadowRootAttributeGetCallbackForNonMainWorlds(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_shadowRoot_Getter");
BLINK_BINDINGS_TRACE_EVENT("Element.shadowRoot.get");


v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
auto&& return_value = blink_receiver->OpenShadowRoot();
bindings::V8SetReturnValue(info, return_value, blink_receiver);
}


void PartAttributeGetCallbackForMainWorld(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_part_Getter");
BLINK_BINDINGS_TRACE_EVENT("Element.part.get");


v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
auto&& return_value = blink_receiver->part();
bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::kMainWorld);
}

void PartAttributeSetCallbackForMainWorld(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_part_Setter");
BLINK_BINDINGS_TRACE_EVENT("Element.part.set");

v8::Isolate* isolate = info.GetIsolate();
const char* const property_name = "part";
if (UNLIKELY(info.Length() < 1)) {
  const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kAttributeSet;
const char* const class_like_name = "Element";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(1, info.Length()));
return;
}

// [PutForwards]
v8::Local<v8::Value> target;
v8::Local<v8::Object> v8_receiver = info.This();
v8::Local<v8::Context> current_context = isolate->GetCurrentContext();
if (!v8_receiver->Get(current_context, V8AtomicString(isolate, property_name)).ToLocal(&target)) {
  return;
}
if (!target->IsObject()) {
  const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kAttributeSet;
const char* const class_like_name = "Element";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
exception_state.ThrowTypeError("The attribute value is not an object");
return;
}
bool did_set;
v8::Local<v8::Value> v8_property_value = info[0];
if (!target.As<v8::Object>()->Set(current_context, V8AtomicString(isolate, "value"), v8_property_value).To(&did_set)) {{
  return;
}}
}

void PartAttributeGetCallbackForNonMainWorlds(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_part_Getter");
BLINK_BINDINGS_TRACE_EVENT("Element.part.get");


v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
auto&& return_value = blink_receiver->part();
bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void PartAttributeSetCallbackForNonMainWorlds(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_part_Setter");
BLINK_BINDINGS_TRACE_EVENT("Element.part.set");

v8::Isolate* isolate = info.GetIsolate();
const char* const property_name = "part";
if (UNLIKELY(info.Length() < 1)) {
  const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kAttributeSet;
const char* const class_like_name = "Element";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(1, info.Length()));
return;
}

// [PutForwards]
v8::Local<v8::Value> target;
v8::Local<v8::Object> v8_receiver = info.This();
v8::Local<v8::Context> current_context = isolate->GetCurrentContext();
if (!v8_receiver->Get(current_context, V8AtomicString(isolate, property_name)).ToLocal(&target)) {
  return;
}
if (!target->IsObject()) {
  const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kAttributeSet;
const char* const class_like_name = "Element";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
exception_state.ThrowTypeError("The attribute value is not an object");
return;
}
bool did_set;
v8::Local<v8::Value> v8_property_value = info[0];
if (!target.As<v8::Object>()->Set(current_context, V8AtomicString(isolate, "value"), v8_property_value).To(&did_set)) {{
  return;
}}
}

void AssignedSlotAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_assignedSlot_Getter");
BLINK_BINDINGS_TRACE_EVENT("Element.assignedSlot.get");


v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
auto&& return_value = blink_receiver->assignedSlotForBinding();
bindings::V8SetReturnValue(info, return_value, blink_receiver);
}


void InnerHTMLAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE(info.GetIsolate(), RuntimeCallStats::CounterId::kElementInnerHTML_Getter);
BLINK_BINDINGS_TRACE_EVENT("Element.innerHTML.get");


v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
auto&& return_value = blink_receiver->innerHTML();
v8::Isolate* isolate = info.GetIsolate();
bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNonNullable);
}

void InnerHTMLAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE(info.GetIsolate(), RuntimeCallStats::CounterId::kElementInnerHTML_Setter);
BLINK_BINDINGS_TRACE_EVENT("Element.innerHTML.set");


v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kAttributeSet;
const char* const class_like_name = "Element";
const char* const property_name = "innerHTML";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);

// [CEReactions]
CEReactionsScope ce_reactions_scope;

v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
v8::Local<v8::Value> v8_property_value = info[0];
ExecutionContext* execution_context_of_document_tree = bindings::ExecutionContextFromV8Wrappable(blink_receiver);
auto&& arg1_value = NativeValueTraits<IDLStringStringContextTrustedHTMLTreatNullAsEmptyString>::NativeValue(isolate, v8_property_value, exception_state, execution_context_of_document_tree);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
blink_receiver->setInnerHTML(arg1_value, exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}

}

void OuterHTMLAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_outerHTML_Getter");
BLINK_BINDINGS_TRACE_EVENT("Element.outerHTML.get");


v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
auto&& return_value = blink_receiver->outerHTML();
v8::Isolate* isolate = info.GetIsolate();
bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNonNullable);
}

void OuterHTMLAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_outerHTML_Setter");
BLINK_BINDINGS_TRACE_EVENT("Element.outerHTML.set");


v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kAttributeSet;
const char* const class_like_name = "Element";
const char* const property_name = "outerHTML";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);

// [CEReactions]
CEReactionsScope ce_reactions_scope;

v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
v8::Local<v8::Value> v8_property_value = info[0];
ExecutionContext* execution_context_of_document_tree = bindings::ExecutionContextFromV8Wrappable(blink_receiver);
auto&& arg1_value = NativeValueTraits<IDLStringStringContextTrustedHTMLTreatNullAsEmptyString>::NativeValue(isolate, v8_property_value, exception_state, execution_context_of_document_tree);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
blink_receiver->setOuterHTML(arg1_value, exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}

}

void ScrollTopAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_scrollTop_Getter");
BLINK_BINDINGS_TRACE_EVENT("Element.scrollTop.get");


v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
auto&& return_value = blink_receiver->scrollTop();
bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<double>());
}

void ScrollTopAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_scrollTop_Setter");
BLINK_BINDINGS_TRACE_EVENT("Element.scrollTop.set");



v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
v8::Isolate* isolate = info.GetIsolate();
v8::Local<v8::Value> v8_property_value = info[0];
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kAttributeSet;
const char* const class_like_name = "Element";
const char* const property_name = "scrollTop";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
auto&& arg1_value = NativeValueTraits<IDLUnrestrictedDouble>::NativeValue(isolate, v8_property_value, exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
blink_receiver->setScrollTop(arg1_value);

}

void ScrollLeftAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_scrollLeft_Getter");
BLINK_BINDINGS_TRACE_EVENT("Element.scrollLeft.get");


v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
auto&& return_value = blink_receiver->scrollLeft();
bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<double>());
}

void ScrollLeftAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_scrollLeft_Setter");
BLINK_BINDINGS_TRACE_EVENT("Element.scrollLeft.set");



v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
v8::Isolate* isolate = info.GetIsolate();
v8::Local<v8::Value> v8_property_value = info[0];
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kAttributeSet;
const char* const class_like_name = "Element";
const char* const property_name = "scrollLeft";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
auto&& arg1_value = NativeValueTraits<IDLUnrestrictedDouble>::NativeValue(isolate, v8_property_value, exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
blink_receiver->setScrollLeft(arg1_value);

}

void ScrollWidthAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_scrollWidth_Getter");
BLINK_BINDINGS_TRACE_EVENT("Element.scrollWidth.get");


v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
auto&& return_value = blink_receiver->scrollWidth();
bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<int32_t>());
}


void ScrollHeightAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_scrollHeight_Getter");
BLINK_BINDINGS_TRACE_EVENT("Element.scrollHeight.get");


v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
auto&& return_value = blink_receiver->scrollHeight();
bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<int32_t>());
}


void ClientTopAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_clientTop_Getter");
BLINK_BINDINGS_TRACE_EVENT("Element.clientTop.get");


v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
auto&& return_value = blink_receiver->clientTop();
bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<int32_t>());
}


void ClientLeftAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_clientLeft_Getter");
BLINK_BINDINGS_TRACE_EVENT("Element.clientLeft.get");


v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
auto&& return_value = blink_receiver->clientLeft();
bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<int32_t>());
}


void ClientWidthAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_clientWidth_Getter");
BLINK_BINDINGS_TRACE_EVENT("Element.clientWidth.get");


v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
auto&& return_value = blink_receiver->clientWidth();
bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<int32_t>());
}


void ClientHeightAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_clientHeight_Getter");
BLINK_BINDINGS_TRACE_EVENT("Element.clientHeight.get");


v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
auto&& return_value = blink_receiver->clientHeight();
bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<int32_t>());
}


void AttributeStyleMapAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_attributeStyleMap_Getter");
BLINK_BINDINGS_TRACE_EVENT("Element.attributeStyleMap.get");
v8::Isolate* isolate = info.GetIsolate();
v8::Local<v8::Context> current_context = isolate->GetCurrentContext();
ExecutionContext* current_execution_context = ExecutionContext::From(current_context);
// [Measure], [MeasureAs]
UseCounter::Count(current_execution_context, WebFeature::kCSSTypedOMStylePropertyMap);


v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
auto&& return_value = blink_receiver->attributeStyleMap();
bindings::V8SetReturnValue(info, return_value, blink_receiver);
}


void PopUpAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_popUp_Getter");
BLINK_BINDINGS_TRACE_EVENT("Element.popUp.get");
v8::Isolate* isolate = info.GetIsolate();
v8::Local<v8::Context> current_context = isolate->GetCurrentContext();
ExecutionContext* current_execution_context = ExecutionContext::From(current_context);
// [Measure], [MeasureAs]
UseCounter::Count(current_execution_context, WebFeature::kAnyPopupAttribute);


v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
auto return_value = blink_receiver->FastGetAttribute(html_names::kPopupAttr);

// [ReflectOnly]
const AtomicString reflect_value(return_value.LowerASCII());
if (reflect_value.IsNull()) {
  // Null string to IDL null.
} else if (reflect_value.IsEmpty()) {
  return_value = keywords::kAuto;
} else if (reflect_value == keywords::kAuto || reflect_value == keywords::kHint || reflect_value == keywords::kManual) {
  return_value = reflect_value;
} else {
  return_value = g_null_atom;
}  
bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNullable);
}

void PopUpAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_popUp_Setter");
BLINK_BINDINGS_TRACE_EVENT("Element.popUp.set");
v8::Isolate* isolate = info.GetIsolate();
v8::Local<v8::Context> current_context = isolate->GetCurrentContext();
ExecutionContext* current_execution_context = ExecutionContext::From(current_context);
// [Measure], [MeasureAs]
UseCounter::Count(current_execution_context, WebFeature::kAnyPopupAttribute);

const char* const class_like_name = "Element";
const char* const property_name = "popUp";
bindings::PerformAttributeSetCEReactionsReflectTypeStringOrNull(info, html_names::kPopupAttr, class_like_name, property_name);
}

void DefaultOpenAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_defaultOpen_Getter");
BLINK_BINDINGS_TRACE_EVENT("Element.defaultOpen.get");


v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
auto&& return_value = blink_receiver->FastHasAttribute(html_names::kDefaultopenAttr);
bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<bool>());
}

void DefaultOpenAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_defaultOpen_Setter");
BLINK_BINDINGS_TRACE_EVENT("Element.defaultOpen.set");

const char* const class_like_name = "Element";
const char* const property_name = "defaultOpen";
bindings::PerformAttributeSetCEReactionsReflectTypeBoolean(info, html_names::kDefaultopenAttr, class_like_name, property_name);
}

void PopUpToggleTargetAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_popUpToggleTarget_Getter");
BLINK_BINDINGS_TRACE_EVENT("Element.popUpToggleTarget.get");


v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
auto&& return_value = blink_receiver->FastGetAttribute(html_names::kPopuptoggletargetAttr);
v8::Isolate* isolate = info.GetIsolate();
bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNullable);
}

void PopUpToggleTargetAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_popUpToggleTarget_Setter");
BLINK_BINDINGS_TRACE_EVENT("Element.popUpToggleTarget.set");

const char* const class_like_name = "Element";
const char* const property_name = "popUpToggleTarget";
bindings::PerformAttributeSetCEReactionsReflectTypeStringOrNull(info, html_names::kPopuptoggletargetAttr, class_like_name, property_name);
}

void PopUpHideTargetAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_popUpHideTarget_Getter");
BLINK_BINDINGS_TRACE_EVENT("Element.popUpHideTarget.get");


v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
auto&& return_value = blink_receiver->FastGetAttribute(html_names::kPopuphidetargetAttr);
v8::Isolate* isolate = info.GetIsolate();
bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNullable);
}

void PopUpHideTargetAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_popUpHideTarget_Setter");
BLINK_BINDINGS_TRACE_EVENT("Element.popUpHideTarget.set");

const char* const class_like_name = "Element";
const char* const property_name = "popUpHideTarget";
bindings::PerformAttributeSetCEReactionsReflectTypeStringOrNull(info, html_names::kPopuphidetargetAttr, class_like_name, property_name);
}

void PopUpShowTargetAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_popUpShowTarget_Getter");
BLINK_BINDINGS_TRACE_EVENT("Element.popUpShowTarget.get");


v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
auto&& return_value = blink_receiver->FastGetAttribute(html_names::kPopupshowtargetAttr);
v8::Isolate* isolate = info.GetIsolate();
bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNullable);
}

void PopUpShowTargetAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_popUpShowTarget_Setter");
BLINK_BINDINGS_TRACE_EVENT("Element.popUpShowTarget.set");

const char* const class_like_name = "Element";
const char* const property_name = "popUpShowTarget";
bindings::PerformAttributeSetCEReactionsReflectTypeStringOrNull(info, html_names::kPopupshowtargetAttr, class_like_name, property_name);
}

void ComputedRoleAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_computedRole_Getter");
BLINK_BINDINGS_TRACE_EVENT("Element.computedRole.get");


v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
auto&& return_value = blink_receiver->computedRole();
v8::Isolate* isolate = info.GetIsolate();
bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNullable);
}


void ComputedNameAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_computedName_Getter");
BLINK_BINDINGS_TRACE_EVENT("Element.computedName.get");


v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
auto&& return_value = blink_receiver->computedName();
v8::Isolate* isolate = info.GetIsolate();
bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNullable);
}


void AccessibleNodeAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_accessibleNode_Getter");
BLINK_BINDINGS_TRACE_EVENT("Element.accessibleNode.get");


v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
auto&& return_value = blink_receiver->accessibleNode();
bindings::V8SetReturnValue(info, return_value, blink_receiver);
}


void OnbeforecopyAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_onbeforecopy_Getter");
BLINK_BINDINGS_TRACE_EVENT("Element.onbeforecopy.get");


v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
auto&& return_value = blink_receiver->onbeforecopy();
v8::Isolate* isolate = info.GetIsolate();
bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnbeforecopyAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_onbeforecopy_Setter");
BLINK_BINDINGS_TRACE_EVENT("Element.onbeforecopy.set");

v8::Local<v8::Value> v8_property_value = info[0];
EventListener* event_handler = JSEventHandler::CreateOrNull(
    v8_property_value,
    JSEventHandler::HandlerType::kEventHandler);
v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
blink_receiver->setOnbeforecopy(event_handler);
}

void OnbeforecutAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_onbeforecut_Getter");
BLINK_BINDINGS_TRACE_EVENT("Element.onbeforecut.get");


v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
auto&& return_value = blink_receiver->onbeforecut();
v8::Isolate* isolate = info.GetIsolate();
bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnbeforecutAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_onbeforecut_Setter");
BLINK_BINDINGS_TRACE_EVENT("Element.onbeforecut.set");

v8::Local<v8::Value> v8_property_value = info[0];
EventListener* event_handler = JSEventHandler::CreateOrNull(
    v8_property_value,
    JSEventHandler::HandlerType::kEventHandler);
v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
blink_receiver->setOnbeforecut(event_handler);
}

void OnbeforepasteAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_onbeforepaste_Getter");
BLINK_BINDINGS_TRACE_EVENT("Element.onbeforepaste.get");


v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
auto&& return_value = blink_receiver->onbeforepaste();
v8::Isolate* isolate = info.GetIsolate();
bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnbeforepasteAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_onbeforepaste_Setter");
BLINK_BINDINGS_TRACE_EVENT("Element.onbeforepaste.set");

v8::Local<v8::Value> v8_property_value = info[0];
EventListener* event_handler = JSEventHandler::CreateOrNull(
    v8_property_value,
    JSEventHandler::HandlerType::kEventHandler);
v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
blink_receiver->setOnbeforepaste(event_handler);
}

void OnsearchAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_onsearch_Getter");
BLINK_BINDINGS_TRACE_EVENT("Element.onsearch.get");


v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
auto&& return_value = blink_receiver->onsearch();
v8::Isolate* isolate = info.GetIsolate();
bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnsearchAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_onsearch_Setter");
BLINK_BINDINGS_TRACE_EVENT("Element.onsearch.set");

v8::Local<v8::Value> v8_property_value = info[0];
EventListener* event_handler = JSEventHandler::CreateOrNull(
    v8_property_value,
    JSEventHandler::HandlerType::kEventHandler);
v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
blink_receiver->setOnsearch(event_handler);
}

void ElementTimingAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_elementTiming_Getter");
BLINK_BINDINGS_TRACE_EVENT("Element.elementTiming.get");


v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
auto&& return_value = blink_receiver->FastGetAttribute(html_names::kElementtimingAttr);
v8::Isolate* isolate = info.GetIsolate();
bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNonNullable);
}

void ElementTimingAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_elementTiming_Setter");
BLINK_BINDINGS_TRACE_EVENT("Element.elementTiming.set");

const char* const class_like_name = "Element";
const char* const property_name = "elementTiming";
bindings::PerformAttributeSetCEReactionsReflectTypeString(info, html_names::kElementtimingAttr, class_like_name, property_name);
}

void OnfullscreenchangeAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_onfullscreenchange_Getter");
BLINK_BINDINGS_TRACE_EVENT("Element.onfullscreenchange.get");


v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
auto&& return_value = ElementFullscreen::onfullscreenchange(*blink_receiver);
v8::Isolate* isolate = info.GetIsolate();
bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnfullscreenchangeAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_onfullscreenchange_Setter");
BLINK_BINDINGS_TRACE_EVENT("Element.onfullscreenchange.set");

v8::Local<v8::Value> v8_property_value = info[0];
EventListener* event_handler = JSEventHandler::CreateOrNull(
    v8_property_value,
    JSEventHandler::HandlerType::kEventHandler);
v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
ElementFullscreen::setOnfullscreenchange(*blink_receiver, event_handler);
}

void OnfullscreenerrorAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_onfullscreenerror_Getter");
BLINK_BINDINGS_TRACE_EVENT("Element.onfullscreenerror.get");


v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
auto&& return_value = ElementFullscreen::onfullscreenerror(*blink_receiver);
v8::Isolate* isolate = info.GetIsolate();
bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnfullscreenerrorAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_onfullscreenerror_Setter");
BLINK_BINDINGS_TRACE_EVENT("Element.onfullscreenerror.set");

v8::Local<v8::Value> v8_property_value = info[0];
EventListener* event_handler = JSEventHandler::CreateOrNull(
    v8_property_value,
    JSEventHandler::HandlerType::kEventHandler);
v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
ElementFullscreen::setOnfullscreenerror(*blink_receiver, event_handler);
}

void OnwebkitfullscreenchangeAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_onwebkitfullscreenchange_Getter");
BLINK_BINDINGS_TRACE_EVENT("Element.onwebkitfullscreenchange.get");


v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
auto&& return_value = ElementFullscreen::onwebkitfullscreenchange(*blink_receiver);
v8::Isolate* isolate = info.GetIsolate();
bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnwebkitfullscreenchangeAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_onwebkitfullscreenchange_Setter");
BLINK_BINDINGS_TRACE_EVENT("Element.onwebkitfullscreenchange.set");

v8::Local<v8::Value> v8_property_value = info[0];
EventListener* event_handler = JSEventHandler::CreateOrNull(
    v8_property_value,
    JSEventHandler::HandlerType::kEventHandler);
v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
ElementFullscreen::setOnwebkitfullscreenchange(*blink_receiver, event_handler);
}

void OnwebkitfullscreenerrorAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_onwebkitfullscreenerror_Getter");
BLINK_BINDINGS_TRACE_EVENT("Element.onwebkitfullscreenerror.get");


v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
auto&& return_value = ElementFullscreen::onwebkitfullscreenerror(*blink_receiver);
v8::Isolate* isolate = info.GetIsolate();
bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnwebkitfullscreenerrorAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_onwebkitfullscreenerror_Setter");
BLINK_BINDINGS_TRACE_EVENT("Element.onwebkitfullscreenerror.set");

v8::Local<v8::Value> v8_property_value = info[0];
EventListener* event_handler = JSEventHandler::CreateOrNull(
    v8_property_value,
    JSEventHandler::HandlerType::kEventHandler);
v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
ElementFullscreen::setOnwebkitfullscreenerror(*blink_receiver, event_handler);
}

void RoleAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_role_Getter");
BLINK_BINDINGS_TRACE_EVENT("Element.role.get");


v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
auto&& return_value = blink_receiver->FastGetAttribute(html_names::kRoleAttr);
v8::Isolate* isolate = info.GetIsolate();
bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNullable);
}

void RoleAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_role_Setter");
BLINK_BINDINGS_TRACE_EVENT("Element.role.set");

const char* const class_like_name = "Element";
const char* const property_name = "role";
bindings::PerformAttributeSetCEReactionsReflectTypeStringOrNull(info, html_names::kRoleAttr, class_like_name, property_name);
}

void AriaAtomicAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaAtomic_Getter");
BLINK_BINDINGS_TRACE_EVENT("Element.ariaAtomic.get");


v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
auto&& return_value = blink_receiver->FastGetAttribute(html_names::kAriaAtomicAttr);
v8::Isolate* isolate = info.GetIsolate();
bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNullable);
}

void AriaAtomicAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaAtomic_Setter");
BLINK_BINDINGS_TRACE_EVENT("Element.ariaAtomic.set");

const char* const class_like_name = "Element";
const char* const property_name = "ariaAtomic";
bindings::PerformAttributeSetCEReactionsReflectTypeStringOrNull(info, html_names::kAriaAtomicAttr, class_like_name, property_name);
}

void AriaAutoCompleteAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaAutoComplete_Getter");
BLINK_BINDINGS_TRACE_EVENT("Element.ariaAutoComplete.get");


v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
auto&& return_value = blink_receiver->FastGetAttribute(html_names::kAriaAutocompleteAttr);
v8::Isolate* isolate = info.GetIsolate();
bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNullable);
}

void AriaAutoCompleteAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaAutoComplete_Setter");
BLINK_BINDINGS_TRACE_EVENT("Element.ariaAutoComplete.set");

const char* const class_like_name = "Element";
const char* const property_name = "ariaAutoComplete";
bindings::PerformAttributeSetCEReactionsReflectTypeStringOrNull(info, html_names::kAriaAutocompleteAttr, class_like_name, property_name);
}

void AriaBusyAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaBusy_Getter");
BLINK_BINDINGS_TRACE_EVENT("Element.ariaBusy.get");


v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
auto&& return_value = blink_receiver->FastGetAttribute(html_names::kAriaBusyAttr);
v8::Isolate* isolate = info.GetIsolate();
bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNullable);
}

void AriaBusyAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaBusy_Setter");
BLINK_BINDINGS_TRACE_EVENT("Element.ariaBusy.set");

const char* const class_like_name = "Element";
const char* const property_name = "ariaBusy";
bindings::PerformAttributeSetCEReactionsReflectTypeStringOrNull(info, html_names::kAriaBusyAttr, class_like_name, property_name);
}

void AriaCheckedAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaChecked_Getter");
BLINK_BINDINGS_TRACE_EVENT("Element.ariaChecked.get");


v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
auto&& return_value = blink_receiver->FastGetAttribute(html_names::kAriaCheckedAttr);
v8::Isolate* isolate = info.GetIsolate();
bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNullable);
}

void AriaCheckedAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaChecked_Setter");
BLINK_BINDINGS_TRACE_EVENT("Element.ariaChecked.set");

const char* const class_like_name = "Element";
const char* const property_name = "ariaChecked";
bindings::PerformAttributeSetCEReactionsReflectTypeStringOrNull(info, html_names::kAriaCheckedAttr, class_like_name, property_name);
}

void AriaColCountAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaColCount_Getter");
BLINK_BINDINGS_TRACE_EVENT("Element.ariaColCount.get");


v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
auto&& return_value = blink_receiver->FastGetAttribute(html_names::kAriaColcountAttr);
v8::Isolate* isolate = info.GetIsolate();
bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNullable);
}

void AriaColCountAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaColCount_Setter");
BLINK_BINDINGS_TRACE_EVENT("Element.ariaColCount.set");

const char* const class_like_name = "Element";
const char* const property_name = "ariaColCount";
bindings::PerformAttributeSetCEReactionsReflectTypeStringOrNull(info, html_names::kAriaColcountAttr, class_like_name, property_name);
}

void AriaColIndexAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaColIndex_Getter");
BLINK_BINDINGS_TRACE_EVENT("Element.ariaColIndex.get");


v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
auto&& return_value = blink_receiver->FastGetAttribute(html_names::kAriaColindexAttr);
v8::Isolate* isolate = info.GetIsolate();
bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNullable);
}

void AriaColIndexAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaColIndex_Setter");
BLINK_BINDINGS_TRACE_EVENT("Element.ariaColIndex.set");

const char* const class_like_name = "Element";
const char* const property_name = "ariaColIndex";
bindings::PerformAttributeSetCEReactionsReflectTypeStringOrNull(info, html_names::kAriaColindexAttr, class_like_name, property_name);
}

void AriaColSpanAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaColSpan_Getter");
BLINK_BINDINGS_TRACE_EVENT("Element.ariaColSpan.get");


v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
auto&& return_value = blink_receiver->FastGetAttribute(html_names::kAriaColspanAttr);
v8::Isolate* isolate = info.GetIsolate();
bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNullable);
}

void AriaColSpanAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaColSpan_Setter");
BLINK_BINDINGS_TRACE_EVENT("Element.ariaColSpan.set");

const char* const class_like_name = "Element";
const char* const property_name = "ariaColSpan";
bindings::PerformAttributeSetCEReactionsReflectTypeStringOrNull(info, html_names::kAriaColspanAttr, class_like_name, property_name);
}

void AriaCurrentAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaCurrent_Getter");
BLINK_BINDINGS_TRACE_EVENT("Element.ariaCurrent.get");


v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
auto&& return_value = blink_receiver->FastGetAttribute(html_names::kAriaCurrentAttr);
v8::Isolate* isolate = info.GetIsolate();
bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNullable);
}

void AriaCurrentAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaCurrent_Setter");
BLINK_BINDINGS_TRACE_EVENT("Element.ariaCurrent.set");

const char* const class_like_name = "Element";
const char* const property_name = "ariaCurrent";
bindings::PerformAttributeSetCEReactionsReflectTypeStringOrNull(info, html_names::kAriaCurrentAttr, class_like_name, property_name);
}

void AriaDescriptionAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaDescription_Getter");
BLINK_BINDINGS_TRACE_EVENT("Element.ariaDescription.get");


v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
auto&& return_value = blink_receiver->FastGetAttribute(html_names::kAriaDescriptionAttr);
v8::Isolate* isolate = info.GetIsolate();
bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNullable);
}

void AriaDescriptionAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaDescription_Setter");
BLINK_BINDINGS_TRACE_EVENT("Element.ariaDescription.set");

const char* const class_like_name = "Element";
const char* const property_name = "ariaDescription";
bindings::PerformAttributeSetCEReactionsReflectTypeStringOrNull(info, html_names::kAriaDescriptionAttr, class_like_name, property_name);
}

void AriaDisabledAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaDisabled_Getter");
BLINK_BINDINGS_TRACE_EVENT("Element.ariaDisabled.get");


v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
auto&& return_value = blink_receiver->FastGetAttribute(html_names::kAriaDisabledAttr);
v8::Isolate* isolate = info.GetIsolate();
bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNullable);
}

void AriaDisabledAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaDisabled_Setter");
BLINK_BINDINGS_TRACE_EVENT("Element.ariaDisabled.set");

const char* const class_like_name = "Element";
const char* const property_name = "ariaDisabled";
bindings::PerformAttributeSetCEReactionsReflectTypeStringOrNull(info, html_names::kAriaDisabledAttr, class_like_name, property_name);
}

void AriaExpandedAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaExpanded_Getter");
BLINK_BINDINGS_TRACE_EVENT("Element.ariaExpanded.get");


v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
auto&& return_value = blink_receiver->FastGetAttribute(html_names::kAriaExpandedAttr);
v8::Isolate* isolate = info.GetIsolate();
bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNullable);
}

void AriaExpandedAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaExpanded_Setter");
BLINK_BINDINGS_TRACE_EVENT("Element.ariaExpanded.set");

const char* const class_like_name = "Element";
const char* const property_name = "ariaExpanded";
bindings::PerformAttributeSetCEReactionsReflectTypeStringOrNull(info, html_names::kAriaExpandedAttr, class_like_name, property_name);
}

void AriaHasPopupAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaHasPopup_Getter");
BLINK_BINDINGS_TRACE_EVENT("Element.ariaHasPopup.get");


v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
auto&& return_value = blink_receiver->FastGetAttribute(html_names::kAriaHaspopupAttr);
v8::Isolate* isolate = info.GetIsolate();
bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNullable);
}

void AriaHasPopupAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaHasPopup_Setter");
BLINK_BINDINGS_TRACE_EVENT("Element.ariaHasPopup.set");

const char* const class_like_name = "Element";
const char* const property_name = "ariaHasPopup";
bindings::PerformAttributeSetCEReactionsReflectTypeStringOrNull(info, html_names::kAriaHaspopupAttr, class_like_name, property_name);
}

void AriaHiddenAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaHidden_Getter");
BLINK_BINDINGS_TRACE_EVENT("Element.ariaHidden.get");


v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
auto&& return_value = blink_receiver->FastGetAttribute(html_names::kAriaHiddenAttr);
v8::Isolate* isolate = info.GetIsolate();
bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNullable);
}

void AriaHiddenAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaHidden_Setter");
BLINK_BINDINGS_TRACE_EVENT("Element.ariaHidden.set");

const char* const class_like_name = "Element";
const char* const property_name = "ariaHidden";
bindings::PerformAttributeSetCEReactionsReflectTypeStringOrNull(info, html_names::kAriaHiddenAttr, class_like_name, property_name);
}

void AriaInvalidAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaInvalid_Getter");
BLINK_BINDINGS_TRACE_EVENT("Element.ariaInvalid.get");


v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
auto&& return_value = blink_receiver->FastGetAttribute(html_names::kAriaInvalidAttr);
v8::Isolate* isolate = info.GetIsolate();
bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNullable);
}

void AriaInvalidAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaInvalid_Setter");
BLINK_BINDINGS_TRACE_EVENT("Element.ariaInvalid.set");

const char* const class_like_name = "Element";
const char* const property_name = "ariaInvalid";
bindings::PerformAttributeSetCEReactionsReflectTypeStringOrNull(info, html_names::kAriaInvalidAttr, class_like_name, property_name);
}

void AriaKeyShortcutsAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaKeyShortcuts_Getter");
BLINK_BINDINGS_TRACE_EVENT("Element.ariaKeyShortcuts.get");


v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
auto&& return_value = blink_receiver->FastGetAttribute(html_names::kAriaKeyshortcutsAttr);
v8::Isolate* isolate = info.GetIsolate();
bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNullable);
}

void AriaKeyShortcutsAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaKeyShortcuts_Setter");
BLINK_BINDINGS_TRACE_EVENT("Element.ariaKeyShortcuts.set");

const char* const class_like_name = "Element";
const char* const property_name = "ariaKeyShortcuts";
bindings::PerformAttributeSetCEReactionsReflectTypeStringOrNull(info, html_names::kAriaKeyshortcutsAttr, class_like_name, property_name);
}

void AriaLabelAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaLabel_Getter");
BLINK_BINDINGS_TRACE_EVENT("Element.ariaLabel.get");


v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
auto&& return_value = blink_receiver->FastGetAttribute(html_names::kAriaLabelAttr);
v8::Isolate* isolate = info.GetIsolate();
bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNullable);
}

void AriaLabelAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaLabel_Setter");
BLINK_BINDINGS_TRACE_EVENT("Element.ariaLabel.set");

const char* const class_like_name = "Element";
const char* const property_name = "ariaLabel";
bindings::PerformAttributeSetCEReactionsReflectTypeStringOrNull(info, html_names::kAriaLabelAttr, class_like_name, property_name);
}

void AriaLevelAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaLevel_Getter");
BLINK_BINDINGS_TRACE_EVENT("Element.ariaLevel.get");


v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
auto&& return_value = blink_receiver->FastGetAttribute(html_names::kAriaLevelAttr);
v8::Isolate* isolate = info.GetIsolate();
bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNullable);
}

void AriaLevelAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaLevel_Setter");
BLINK_BINDINGS_TRACE_EVENT("Element.ariaLevel.set");

const char* const class_like_name = "Element";
const char* const property_name = "ariaLevel";
bindings::PerformAttributeSetCEReactionsReflectTypeStringOrNull(info, html_names::kAriaLevelAttr, class_like_name, property_name);
}

void AriaLiveAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaLive_Getter");
BLINK_BINDINGS_TRACE_EVENT("Element.ariaLive.get");


v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
auto&& return_value = blink_receiver->FastGetAttribute(html_names::kAriaLiveAttr);
v8::Isolate* isolate = info.GetIsolate();
bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNullable);
}

void AriaLiveAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaLive_Setter");
BLINK_BINDINGS_TRACE_EVENT("Element.ariaLive.set");

const char* const class_like_name = "Element";
const char* const property_name = "ariaLive";
bindings::PerformAttributeSetCEReactionsReflectTypeStringOrNull(info, html_names::kAriaLiveAttr, class_like_name, property_name);
}

void AriaModalAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaModal_Getter");
BLINK_BINDINGS_TRACE_EVENT("Element.ariaModal.get");


v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
auto&& return_value = blink_receiver->FastGetAttribute(html_names::kAriaModalAttr);
v8::Isolate* isolate = info.GetIsolate();
bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNullable);
}

void AriaModalAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaModal_Setter");
BLINK_BINDINGS_TRACE_EVENT("Element.ariaModal.set");

const char* const class_like_name = "Element";
const char* const property_name = "ariaModal";
bindings::PerformAttributeSetCEReactionsReflectTypeStringOrNull(info, html_names::kAriaModalAttr, class_like_name, property_name);
}

void AriaMultiLineAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaMultiLine_Getter");
BLINK_BINDINGS_TRACE_EVENT("Element.ariaMultiLine.get");


v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
auto&& return_value = blink_receiver->FastGetAttribute(html_names::kAriaMultilineAttr);
v8::Isolate* isolate = info.GetIsolate();
bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNullable);
}

void AriaMultiLineAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaMultiLine_Setter");
BLINK_BINDINGS_TRACE_EVENT("Element.ariaMultiLine.set");

const char* const class_like_name = "Element";
const char* const property_name = "ariaMultiLine";
bindings::PerformAttributeSetCEReactionsReflectTypeStringOrNull(info, html_names::kAriaMultilineAttr, class_like_name, property_name);
}

void AriaMultiSelectableAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaMultiSelectable_Getter");
BLINK_BINDINGS_TRACE_EVENT("Element.ariaMultiSelectable.get");


v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
auto&& return_value = blink_receiver->FastGetAttribute(html_names::kAriaMultiselectableAttr);
v8::Isolate* isolate = info.GetIsolate();
bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNullable);
}

void AriaMultiSelectableAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaMultiSelectable_Setter");
BLINK_BINDINGS_TRACE_EVENT("Element.ariaMultiSelectable.set");

const char* const class_like_name = "Element";
const char* const property_name = "ariaMultiSelectable";
bindings::PerformAttributeSetCEReactionsReflectTypeStringOrNull(info, html_names::kAriaMultiselectableAttr, class_like_name, property_name);
}

void AriaOrientationAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaOrientation_Getter");
BLINK_BINDINGS_TRACE_EVENT("Element.ariaOrientation.get");


v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
auto&& return_value = blink_receiver->FastGetAttribute(html_names::kAriaOrientationAttr);
v8::Isolate* isolate = info.GetIsolate();
bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNullable);
}

void AriaOrientationAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaOrientation_Setter");
BLINK_BINDINGS_TRACE_EVENT("Element.ariaOrientation.set");

const char* const class_like_name = "Element";
const char* const property_name = "ariaOrientation";
bindings::PerformAttributeSetCEReactionsReflectTypeStringOrNull(info, html_names::kAriaOrientationAttr, class_like_name, property_name);
}

void AriaPlaceholderAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaPlaceholder_Getter");
BLINK_BINDINGS_TRACE_EVENT("Element.ariaPlaceholder.get");


v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
auto&& return_value = blink_receiver->FastGetAttribute(html_names::kAriaPlaceholderAttr);
v8::Isolate* isolate = info.GetIsolate();
bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNullable);
}

void AriaPlaceholderAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaPlaceholder_Setter");
BLINK_BINDINGS_TRACE_EVENT("Element.ariaPlaceholder.set");

const char* const class_like_name = "Element";
const char* const property_name = "ariaPlaceholder";
bindings::PerformAttributeSetCEReactionsReflectTypeStringOrNull(info, html_names::kAriaPlaceholderAttr, class_like_name, property_name);
}

void AriaPosInSetAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaPosInSet_Getter");
BLINK_BINDINGS_TRACE_EVENT("Element.ariaPosInSet.get");


v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
auto&& return_value = blink_receiver->FastGetAttribute(html_names::kAriaPosinsetAttr);
v8::Isolate* isolate = info.GetIsolate();
bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNullable);
}

void AriaPosInSetAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaPosInSet_Setter");
BLINK_BINDINGS_TRACE_EVENT("Element.ariaPosInSet.set");

const char* const class_like_name = "Element";
const char* const property_name = "ariaPosInSet";
bindings::PerformAttributeSetCEReactionsReflectTypeStringOrNull(info, html_names::kAriaPosinsetAttr, class_like_name, property_name);
}

void AriaPressedAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaPressed_Getter");
BLINK_BINDINGS_TRACE_EVENT("Element.ariaPressed.get");


v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
auto&& return_value = blink_receiver->FastGetAttribute(html_names::kAriaPressedAttr);
v8::Isolate* isolate = info.GetIsolate();
bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNullable);
}

void AriaPressedAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaPressed_Setter");
BLINK_BINDINGS_TRACE_EVENT("Element.ariaPressed.set");

const char* const class_like_name = "Element";
const char* const property_name = "ariaPressed";
bindings::PerformAttributeSetCEReactionsReflectTypeStringOrNull(info, html_names::kAriaPressedAttr, class_like_name, property_name);
}

void AriaReadOnlyAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaReadOnly_Getter");
BLINK_BINDINGS_TRACE_EVENT("Element.ariaReadOnly.get");


v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
auto&& return_value = blink_receiver->FastGetAttribute(html_names::kAriaReadonlyAttr);
v8::Isolate* isolate = info.GetIsolate();
bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNullable);
}

void AriaReadOnlyAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaReadOnly_Setter");
BLINK_BINDINGS_TRACE_EVENT("Element.ariaReadOnly.set");

const char* const class_like_name = "Element";
const char* const property_name = "ariaReadOnly";
bindings::PerformAttributeSetCEReactionsReflectTypeStringOrNull(info, html_names::kAriaReadonlyAttr, class_like_name, property_name);
}

void AriaRelevantAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaRelevant_Getter");
BLINK_BINDINGS_TRACE_EVENT("Element.ariaRelevant.get");


v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
auto&& return_value = blink_receiver->FastGetAttribute(html_names::kAriaRelevantAttr);
v8::Isolate* isolate = info.GetIsolate();
bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNullable);
}

void AriaRelevantAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaRelevant_Setter");
BLINK_BINDINGS_TRACE_EVENT("Element.ariaRelevant.set");

const char* const class_like_name = "Element";
const char* const property_name = "ariaRelevant";
bindings::PerformAttributeSetCEReactionsReflectTypeStringOrNull(info, html_names::kAriaRelevantAttr, class_like_name, property_name);
}

void AriaRequiredAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaRequired_Getter");
BLINK_BINDINGS_TRACE_EVENT("Element.ariaRequired.get");


v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
auto&& return_value = blink_receiver->FastGetAttribute(html_names::kAriaRequiredAttr);
v8::Isolate* isolate = info.GetIsolate();
bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNullable);
}

void AriaRequiredAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaRequired_Setter");
BLINK_BINDINGS_TRACE_EVENT("Element.ariaRequired.set");

const char* const class_like_name = "Element";
const char* const property_name = "ariaRequired";
bindings::PerformAttributeSetCEReactionsReflectTypeStringOrNull(info, html_names::kAriaRequiredAttr, class_like_name, property_name);
}

void AriaRoleDescriptionAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaRoleDescription_Getter");
BLINK_BINDINGS_TRACE_EVENT("Element.ariaRoleDescription.get");


v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
auto&& return_value = blink_receiver->FastGetAttribute(html_names::kAriaRoledescriptionAttr);
v8::Isolate* isolate = info.GetIsolate();
bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNullable);
}

void AriaRoleDescriptionAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaRoleDescription_Setter");
BLINK_BINDINGS_TRACE_EVENT("Element.ariaRoleDescription.set");

const char* const class_like_name = "Element";
const char* const property_name = "ariaRoleDescription";
bindings::PerformAttributeSetCEReactionsReflectTypeStringOrNull(info, html_names::kAriaRoledescriptionAttr, class_like_name, property_name);
}

void AriaRowCountAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaRowCount_Getter");
BLINK_BINDINGS_TRACE_EVENT("Element.ariaRowCount.get");


v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
auto&& return_value = blink_receiver->FastGetAttribute(html_names::kAriaRowcountAttr);
v8::Isolate* isolate = info.GetIsolate();
bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNullable);
}

void AriaRowCountAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaRowCount_Setter");
BLINK_BINDINGS_TRACE_EVENT("Element.ariaRowCount.set");

const char* const class_like_name = "Element";
const char* const property_name = "ariaRowCount";
bindings::PerformAttributeSetCEReactionsReflectTypeStringOrNull(info, html_names::kAriaRowcountAttr, class_like_name, property_name);
}

void AriaRowIndexAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaRowIndex_Getter");
BLINK_BINDINGS_TRACE_EVENT("Element.ariaRowIndex.get");


v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
auto&& return_value = blink_receiver->FastGetAttribute(html_names::kAriaRowindexAttr);
v8::Isolate* isolate = info.GetIsolate();
bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNullable);
}

void AriaRowIndexAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaRowIndex_Setter");
BLINK_BINDINGS_TRACE_EVENT("Element.ariaRowIndex.set");

const char* const class_like_name = "Element";
const char* const property_name = "ariaRowIndex";
bindings::PerformAttributeSetCEReactionsReflectTypeStringOrNull(info, html_names::kAriaRowindexAttr, class_like_name, property_name);
}

void AriaRowSpanAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaRowSpan_Getter");
BLINK_BINDINGS_TRACE_EVENT("Element.ariaRowSpan.get");


v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
auto&& return_value = blink_receiver->FastGetAttribute(html_names::kAriaRowspanAttr);
v8::Isolate* isolate = info.GetIsolate();
bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNullable);
}

void AriaRowSpanAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaRowSpan_Setter");
BLINK_BINDINGS_TRACE_EVENT("Element.ariaRowSpan.set");

const char* const class_like_name = "Element";
const char* const property_name = "ariaRowSpan";
bindings::PerformAttributeSetCEReactionsReflectTypeStringOrNull(info, html_names::kAriaRowspanAttr, class_like_name, property_name);
}

void AriaSelectedAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaSelected_Getter");
BLINK_BINDINGS_TRACE_EVENT("Element.ariaSelected.get");


v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
auto&& return_value = blink_receiver->FastGetAttribute(html_names::kAriaSelectedAttr);
v8::Isolate* isolate = info.GetIsolate();
bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNullable);
}

void AriaSelectedAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaSelected_Setter");
BLINK_BINDINGS_TRACE_EVENT("Element.ariaSelected.set");

const char* const class_like_name = "Element";
const char* const property_name = "ariaSelected";
bindings::PerformAttributeSetCEReactionsReflectTypeStringOrNull(info, html_names::kAriaSelectedAttr, class_like_name, property_name);
}

void AriaSetSizeAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaSetSize_Getter");
BLINK_BINDINGS_TRACE_EVENT("Element.ariaSetSize.get");


v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
auto&& return_value = blink_receiver->FastGetAttribute(html_names::kAriaSetsizeAttr);
v8::Isolate* isolate = info.GetIsolate();
bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNullable);
}

void AriaSetSizeAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaSetSize_Setter");
BLINK_BINDINGS_TRACE_EVENT("Element.ariaSetSize.set");

const char* const class_like_name = "Element";
const char* const property_name = "ariaSetSize";
bindings::PerformAttributeSetCEReactionsReflectTypeStringOrNull(info, html_names::kAriaSetsizeAttr, class_like_name, property_name);
}

void AriaSortAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaSort_Getter");
BLINK_BINDINGS_TRACE_EVENT("Element.ariaSort.get");


v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
auto&& return_value = blink_receiver->FastGetAttribute(html_names::kAriaSortAttr);
v8::Isolate* isolate = info.GetIsolate();
bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNullable);
}

void AriaSortAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaSort_Setter");
BLINK_BINDINGS_TRACE_EVENT("Element.ariaSort.set");

const char* const class_like_name = "Element";
const char* const property_name = "ariaSort";
bindings::PerformAttributeSetCEReactionsReflectTypeStringOrNull(info, html_names::kAriaSortAttr, class_like_name, property_name);
}

void AriaValueMaxAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaValueMax_Getter");
BLINK_BINDINGS_TRACE_EVENT("Element.ariaValueMax.get");


v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
auto&& return_value = blink_receiver->FastGetAttribute(html_names::kAriaValuemaxAttr);
v8::Isolate* isolate = info.GetIsolate();
bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNullable);
}

void AriaValueMaxAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaValueMax_Setter");
BLINK_BINDINGS_TRACE_EVENT("Element.ariaValueMax.set");

const char* const class_like_name = "Element";
const char* const property_name = "ariaValueMax";
bindings::PerformAttributeSetCEReactionsReflectTypeStringOrNull(info, html_names::kAriaValuemaxAttr, class_like_name, property_name);
}

void AriaValueMinAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaValueMin_Getter");
BLINK_BINDINGS_TRACE_EVENT("Element.ariaValueMin.get");


v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
auto&& return_value = blink_receiver->FastGetAttribute(html_names::kAriaValueminAttr);
v8::Isolate* isolate = info.GetIsolate();
bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNullable);
}

void AriaValueMinAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaValueMin_Setter");
BLINK_BINDINGS_TRACE_EVENT("Element.ariaValueMin.set");

const char* const class_like_name = "Element";
const char* const property_name = "ariaValueMin";
bindings::PerformAttributeSetCEReactionsReflectTypeStringOrNull(info, html_names::kAriaValueminAttr, class_like_name, property_name);
}

void AriaValueNowAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaValueNow_Getter");
BLINK_BINDINGS_TRACE_EVENT("Element.ariaValueNow.get");


v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
auto&& return_value = blink_receiver->FastGetAttribute(html_names::kAriaValuenowAttr);
v8::Isolate* isolate = info.GetIsolate();
bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNullable);
}

void AriaValueNowAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaValueNow_Setter");
BLINK_BINDINGS_TRACE_EVENT("Element.ariaValueNow.set");

const char* const class_like_name = "Element";
const char* const property_name = "ariaValueNow";
bindings::PerformAttributeSetCEReactionsReflectTypeStringOrNull(info, html_names::kAriaValuenowAttr, class_like_name, property_name);
}

void AriaValueTextAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaValueText_Getter");
BLINK_BINDINGS_TRACE_EVENT("Element.ariaValueText.get");


v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
auto&& return_value = blink_receiver->FastGetAttribute(html_names::kAriaValuetextAttr);
v8::Isolate* isolate = info.GetIsolate();
bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNullable);
}

void AriaValueTextAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaValueText_Setter");
BLINK_BINDINGS_TRACE_EVENT("Element.ariaValueText.set");

const char* const class_like_name = "Element";
const char* const property_name = "ariaValueText";
bindings::PerformAttributeSetCEReactionsReflectTypeStringOrNull(info, html_names::kAriaValuetextAttr, class_like_name, property_name);
}

void AriaVirtualContentAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaVirtualContent_Getter");
BLINK_BINDINGS_TRACE_EVENT("Element.ariaVirtualContent.get");


v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
auto&& return_value = blink_receiver->FastGetAttribute(html_names::kAriaVirtualcontentAttr);
v8::Isolate* isolate = info.GetIsolate();
bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNullable);
}

void AriaVirtualContentAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaVirtualContent_Setter");
BLINK_BINDINGS_TRACE_EVENT("Element.ariaVirtualContent.set");

const char* const class_like_name = "Element";
const char* const property_name = "ariaVirtualContent";
bindings::PerformAttributeSetCEReactionsReflectTypeStringOrNull(info, html_names::kAriaVirtualcontentAttr, class_like_name, property_name);
}

void AriaActiveDescendantElementAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaActiveDescendantElement_Getter");
BLINK_BINDINGS_TRACE_EVENT("Element.ariaActiveDescendantElement.get");


v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
auto&& return_value = blink_receiver->GetElementAttribute(html_names::kAriaActivedescendantAttr);
bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void AriaActiveDescendantElementAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaActiveDescendantElement_Setter");
BLINK_BINDINGS_TRACE_EVENT("Element.ariaActiveDescendantElement.set");

v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kAttributeSet;
const char* const class_like_name = "Element";
const char* const property_name = "ariaActiveDescendantElement";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 1)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(1, info.Length()));
return;
}


// [CEReactions]
CEReactionsScope ce_reactions_scope;

v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
v8::Local<v8::Value> v8_property_value = info[0];
auto&& arg1_value = NativeValueTraits<IDLNullable<Element>>::NativeValue(isolate, v8_property_value, exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
blink_receiver->SetElementAttribute(html_names::kAriaActivedescendantAttr, arg1_value);

}

void AriaControlsElementsAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaControlsElements_Getter");
BLINK_BINDINGS_TRACE_EVENT("Element.ariaControlsElements.get");


v8::Local<v8::Value> v8_return_value;
v8::Local<v8::Object> v8_receiver = info.This();
v8::Local<v8::Context> receiver_context = v8_receiver->GetCreationContextChecked();
ScriptState* receiver_script_state = ScriptState::From(receiver_context);
ScriptState* script_state = receiver_script_state;
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
auto&& return_value = blink_receiver->GetElementArrayAttribute(html_names::kAriaControlsAttr);
if (!ToV8Traits<IDLNullable<IDLArray<Element>>>::ToV8(script_state, return_value).ToLocal(&v8_return_value)) {
  return;
}
bindings::V8SetReturnValue(info, v8_return_value);
}

void AriaControlsElementsAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaControlsElements_Setter");
BLINK_BINDINGS_TRACE_EVENT("Element.ariaControlsElements.set");

v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kAttributeSet;
const char* const class_like_name = "Element";
const char* const property_name = "ariaControlsElements";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 1)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(1, info.Length()));
return;
}


// [CEReactions]
CEReactionsScope ce_reactions_scope;

v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
v8::Local<v8::Value> v8_property_value = info[0];
auto&& arg1_value = NativeValueTraits<IDLNullable<IDLArray<Element>>>::NativeValue(isolate, v8_property_value, exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
blink_receiver->SetElementArrayAttribute(html_names::kAriaControlsAttr, arg1_value);

}

void AriaDescribedByElementsAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaDescribedByElements_Getter");
BLINK_BINDINGS_TRACE_EVENT("Element.ariaDescribedByElements.get");


v8::Local<v8::Value> v8_return_value;
v8::Local<v8::Object> v8_receiver = info.This();
v8::Local<v8::Context> receiver_context = v8_receiver->GetCreationContextChecked();
ScriptState* receiver_script_state = ScriptState::From(receiver_context);
ScriptState* script_state = receiver_script_state;
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
auto&& return_value = blink_receiver->GetElementArrayAttribute(html_names::kAriaDescribedbyAttr);
if (!ToV8Traits<IDLNullable<IDLArray<Element>>>::ToV8(script_state, return_value).ToLocal(&v8_return_value)) {
  return;
}
bindings::V8SetReturnValue(info, v8_return_value);
}

void AriaDescribedByElementsAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaDescribedByElements_Setter");
BLINK_BINDINGS_TRACE_EVENT("Element.ariaDescribedByElements.set");

v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kAttributeSet;
const char* const class_like_name = "Element";
const char* const property_name = "ariaDescribedByElements";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 1)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(1, info.Length()));
return;
}


// [CEReactions]
CEReactionsScope ce_reactions_scope;

v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
v8::Local<v8::Value> v8_property_value = info[0];
auto&& arg1_value = NativeValueTraits<IDLNullable<IDLArray<Element>>>::NativeValue(isolate, v8_property_value, exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
blink_receiver->SetElementArrayAttribute(html_names::kAriaDescribedbyAttr, arg1_value);

}

void AriaDetailsElementsAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaDetailsElements_Getter");
BLINK_BINDINGS_TRACE_EVENT("Element.ariaDetailsElements.get");


v8::Local<v8::Value> v8_return_value;
v8::Local<v8::Object> v8_receiver = info.This();
v8::Local<v8::Context> receiver_context = v8_receiver->GetCreationContextChecked();
ScriptState* receiver_script_state = ScriptState::From(receiver_context);
ScriptState* script_state = receiver_script_state;
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
auto&& return_value = blink_receiver->GetElementArrayAttribute(html_names::kAriaDetailsAttr);
if (!ToV8Traits<IDLNullable<IDLArray<Element>>>::ToV8(script_state, return_value).ToLocal(&v8_return_value)) {
  return;
}
bindings::V8SetReturnValue(info, v8_return_value);
}

void AriaDetailsElementsAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaDetailsElements_Setter");
BLINK_BINDINGS_TRACE_EVENT("Element.ariaDetailsElements.set");

v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kAttributeSet;
const char* const class_like_name = "Element";
const char* const property_name = "ariaDetailsElements";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 1)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(1, info.Length()));
return;
}


// [CEReactions]
CEReactionsScope ce_reactions_scope;

v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
v8::Local<v8::Value> v8_property_value = info[0];
auto&& arg1_value = NativeValueTraits<IDLNullable<IDLArray<Element>>>::NativeValue(isolate, v8_property_value, exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
blink_receiver->SetElementArrayAttribute(html_names::kAriaDetailsAttr, arg1_value);

}

void AriaErrorMessageElementAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaErrorMessageElement_Getter");
BLINK_BINDINGS_TRACE_EVENT("Element.ariaErrorMessageElement.get");


v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
auto&& return_value = blink_receiver->GetElementAttribute(html_names::kAriaErrormessageAttr);
bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void AriaErrorMessageElementAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaErrorMessageElement_Setter");
BLINK_BINDINGS_TRACE_EVENT("Element.ariaErrorMessageElement.set");

v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kAttributeSet;
const char* const class_like_name = "Element";
const char* const property_name = "ariaErrorMessageElement";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 1)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(1, info.Length()));
return;
}


// [CEReactions]
CEReactionsScope ce_reactions_scope;

v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
v8::Local<v8::Value> v8_property_value = info[0];
auto&& arg1_value = NativeValueTraits<IDLNullable<Element>>::NativeValue(isolate, v8_property_value, exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
blink_receiver->SetElementAttribute(html_names::kAriaErrormessageAttr, arg1_value);

}

void AriaFlowToElementsAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaFlowToElements_Getter");
BLINK_BINDINGS_TRACE_EVENT("Element.ariaFlowToElements.get");


v8::Local<v8::Value> v8_return_value;
v8::Local<v8::Object> v8_receiver = info.This();
v8::Local<v8::Context> receiver_context = v8_receiver->GetCreationContextChecked();
ScriptState* receiver_script_state = ScriptState::From(receiver_context);
ScriptState* script_state = receiver_script_state;
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
auto&& return_value = blink_receiver->GetElementArrayAttribute(html_names::kAriaFlowtoAttr);
if (!ToV8Traits<IDLNullable<IDLArray<Element>>>::ToV8(script_state, return_value).ToLocal(&v8_return_value)) {
  return;
}
bindings::V8SetReturnValue(info, v8_return_value);
}

void AriaFlowToElementsAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaFlowToElements_Setter");
BLINK_BINDINGS_TRACE_EVENT("Element.ariaFlowToElements.set");

v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kAttributeSet;
const char* const class_like_name = "Element";
const char* const property_name = "ariaFlowToElements";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 1)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(1, info.Length()));
return;
}


// [CEReactions]
CEReactionsScope ce_reactions_scope;

v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
v8::Local<v8::Value> v8_property_value = info[0];
auto&& arg1_value = NativeValueTraits<IDLNullable<IDLArray<Element>>>::NativeValue(isolate, v8_property_value, exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
blink_receiver->SetElementArrayAttribute(html_names::kAriaFlowtoAttr, arg1_value);

}

void AriaLabelledByElementsAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaLabelledByElements_Getter");
BLINK_BINDINGS_TRACE_EVENT("Element.ariaLabelledByElements.get");


v8::Local<v8::Value> v8_return_value;
v8::Local<v8::Object> v8_receiver = info.This();
v8::Local<v8::Context> receiver_context = v8_receiver->GetCreationContextChecked();
ScriptState* receiver_script_state = ScriptState::From(receiver_context);
ScriptState* script_state = receiver_script_state;
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
auto&& return_value = blink_receiver->GetElementArrayAttribute(html_names::kAriaLabelledbyAttr);
if (!ToV8Traits<IDLNullable<IDLArray<Element>>>::ToV8(script_state, return_value).ToLocal(&v8_return_value)) {
  return;
}
bindings::V8SetReturnValue(info, v8_return_value);
}

void AriaLabelledByElementsAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaLabelledByElements_Setter");
BLINK_BINDINGS_TRACE_EVENT("Element.ariaLabelledByElements.set");

v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kAttributeSet;
const char* const class_like_name = "Element";
const char* const property_name = "ariaLabelledByElements";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 1)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(1, info.Length()));
return;
}


// [CEReactions]
CEReactionsScope ce_reactions_scope;

v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
v8::Local<v8::Value> v8_property_value = info[0];
auto&& arg1_value = NativeValueTraits<IDLNullable<IDLArray<Element>>>::NativeValue(isolate, v8_property_value, exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
blink_receiver->SetElementArrayAttribute(html_names::kAriaLabelledbyAttr, arg1_value);

}

void AriaOwnsElementsAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaOwnsElements_Getter");
BLINK_BINDINGS_TRACE_EVENT("Element.ariaOwnsElements.get");


v8::Local<v8::Value> v8_return_value;
v8::Local<v8::Object> v8_receiver = info.This();
v8::Local<v8::Context> receiver_context = v8_receiver->GetCreationContextChecked();
ScriptState* receiver_script_state = ScriptState::From(receiver_context);
ScriptState* script_state = receiver_script_state;
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
auto&& return_value = blink_receiver->GetElementArrayAttribute(html_names::kAriaOwnsAttr);
if (!ToV8Traits<IDLNullable<IDLArray<Element>>>::ToV8(script_state, return_value).ToLocal(&v8_return_value)) {
  return;
}
bindings::V8SetReturnValue(info, v8_return_value);
}

void AriaOwnsElementsAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaOwnsElements_Setter");
BLINK_BINDINGS_TRACE_EVENT("Element.ariaOwnsElements.set");

v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kAttributeSet;
const char* const class_like_name = "Element";
const char* const property_name = "ariaOwnsElements";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 1)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(1, info.Length()));
return;
}


// [CEReactions]
CEReactionsScope ce_reactions_scope;

v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
v8::Local<v8::Value> v8_property_value = info[0];
auto&& arg1_value = NativeValueTraits<IDLNullable<IDLArray<Element>>>::NativeValue(isolate, v8_property_value, exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
blink_receiver->SetElementArrayAttribute(html_names::kAriaOwnsAttr, arg1_value);

}

void ChildrenAttributeGetCallbackForMainWorld(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_children_Getter");
BLINK_BINDINGS_TRACE_EVENT("Element.children.get");


v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
auto&& return_value = ParentNode::children(*blink_receiver);
bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::kMainWorld);
}


void ChildrenAttributeGetCallbackForNonMainWorlds(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_children_Getter");
BLINK_BINDINGS_TRACE_EVENT("Element.children.get");


v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
auto&& return_value = ParentNode::children(*blink_receiver);
bindings::V8SetReturnValue(info, return_value, blink_receiver);
}


void FirstElementChildAttributeGetCallbackForMainWorld(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_firstElementChild_Getter");
BLINK_BINDINGS_TRACE_EVENT("Element.firstElementChild.get");


v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
auto&& return_value = ParentNode::firstElementChild(*blink_receiver);
bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::kMainWorld);
}


void FirstElementChildAttributeGetCallbackForNonMainWorlds(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_firstElementChild_Getter");
BLINK_BINDINGS_TRACE_EVENT("Element.firstElementChild.get");


v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
auto&& return_value = ParentNode::firstElementChild(*blink_receiver);
bindings::V8SetReturnValue(info, return_value, blink_receiver);
}


void LastElementChildAttributeGetCallbackForMainWorld(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_lastElementChild_Getter");
BLINK_BINDINGS_TRACE_EVENT("Element.lastElementChild.get");


v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
auto&& return_value = ParentNode::lastElementChild(*blink_receiver);
bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::kMainWorld);
}


void LastElementChildAttributeGetCallbackForNonMainWorlds(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_lastElementChild_Getter");
BLINK_BINDINGS_TRACE_EVENT("Element.lastElementChild.get");


v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
auto&& return_value = ParentNode::lastElementChild(*blink_receiver);
bindings::V8SetReturnValue(info, return_value, blink_receiver);
}


void ChildElementCountAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_childElementCount_Getter");
BLINK_BINDINGS_TRACE_EVENT("Element.childElementCount.get");


v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
auto&& return_value = ParentNode::childElementCount(*blink_receiver);
bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<uint32_t>());
}


void PreviousElementSiblingAttributeGetCallbackForMainWorld(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_previousElementSibling_Getter");
BLINK_BINDINGS_TRACE_EVENT("Element.previousElementSibling.get");


v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
auto&& return_value = NonDocumentTypeChildNode::previousElementSibling(*blink_receiver);
bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::kMainWorld);
}


void PreviousElementSiblingAttributeGetCallbackForNonMainWorlds(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_previousElementSibling_Getter");
BLINK_BINDINGS_TRACE_EVENT("Element.previousElementSibling.get");


v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
auto&& return_value = NonDocumentTypeChildNode::previousElementSibling(*blink_receiver);
bindings::V8SetReturnValue(info, return_value, blink_receiver);
}


void NextElementSiblingAttributeGetCallbackForMainWorld(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_nextElementSibling_Getter");
BLINK_BINDINGS_TRACE_EVENT("Element.nextElementSibling.get");


v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
auto&& return_value = NonDocumentTypeChildNode::nextElementSibling(*blink_receiver);
bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::kMainWorld);
}


void NextElementSiblingAttributeGetCallbackForNonMainWorlds(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_nextElementSibling_Getter");
BLINK_BINDINGS_TRACE_EVENT("Element.nextElementSibling.get");


v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
auto&& return_value = NonDocumentTypeChildNode::nextElementSibling(*blink_receiver);
bindings::V8SetReturnValue(info, return_value, blink_receiver);
}


void AfterOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_after");
BLINK_BINDINGS_TRACE_EVENT("Element.after");





v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "Element";
const char* const property_name = "after";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);

// [CEReactions]
CEReactionsScope ce_reactions_scope;


v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
auto&& arg1_nodes = bindings::VariadicArgumentsToNativeValues<V8UnionNodeOrStringOrTrustedScript>(isolate, info, 0, exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
ChildNode::after(*blink_receiver, arg1_nodes, exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}

}

void AnimateOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_animate");
BLINK_BINDINGS_TRACE_EVENT("Element.animate");


v8::Isolate* isolate = info.GetIsolate();
v8::Local<v8::Context> current_context = isolate->GetCurrentContext();
ExecutionContext* current_execution_context = ExecutionContext::From(current_context);
// [Measure], [MeasureAs]
UseCounter::Count(current_execution_context, WebFeature::kV8Element_Animate_Method);


const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "Element";
const char* const property_name = "animate";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 1)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(1, info.Length()));
return;
}



Animation* return_value;
v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
do {  // Dummy loop for use of 'break'.
  const int non_undefined_argument_length = bindings::NonUndefinedArgumentLength(info);
v8::Local<v8::Context> receiver_context = v8_receiver->GetCreationContextChecked();
ScriptState* receiver_script_state = ScriptState::From(receiver_context);
ScriptState* script_state = receiver_script_state;
auto&& arg1_keyframes = NativeValueTraits<IDLNullable<IDLObject>>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
if (non_undefined_argument_length <= 1) {
  return_value = blink_receiver->animate(script_state, arg1_keyframes, exception_state);
break;
}
auto&& arg2_options = NativeValueTraits<V8UnionKeyframeAnimationOptionsOrUnrestrictedDouble>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
return_value = blink_receiver->animate(script_state, arg1_keyframes, arg2_options, exception_state);
} while (false);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void AppendOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_append");
BLINK_BINDINGS_TRACE_EVENT("Element.append");





v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "Element";
const char* const property_name = "append";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);

// [CEReactions]
CEReactionsScope ce_reactions_scope;


v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
auto&& arg1_nodes = bindings::VariadicArgumentsToNativeValues<V8UnionNodeOrStringOrTrustedScript>(isolate, info, 0, exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
ParentNode::append(*blink_receiver, arg1_nodes, exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}

}

void AttachShadowOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_attachShadow");
BLINK_BINDINGS_TRACE_EVENT("Element.attachShadow");


v8::Isolate* isolate = info.GetIsolate();
v8::Local<v8::Context> current_context = isolate->GetCurrentContext();
ExecutionContext* current_execution_context = ExecutionContext::From(current_context);
// [Measure], [MeasureAs]
UseCounter::Count(current_execution_context, WebFeature::kElementAttachShadow);


const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "Element";
const char* const property_name = "attachShadow";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 1)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(1, info.Length()));
return;
}



v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
auto&& arg1_shadow_root_init_dict = NativeValueTraits<ShadowRootInit>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& return_value = blink_receiver->attachShadow(arg1_shadow_root_init_dict, exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void BeforeOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_before");
BLINK_BINDINGS_TRACE_EVENT("Element.before");





v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "Element";
const char* const property_name = "before";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);

// [CEReactions]
CEReactionsScope ce_reactions_scope;


v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
auto&& arg1_nodes = bindings::VariadicArgumentsToNativeValues<V8UnionNodeOrStringOrTrustedScript>(isolate, info, 0, exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
ChildNode::before(*blink_receiver, arg1_nodes, exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}

}

void CheckVisibilityOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_checkVisibility");
BLINK_BINDINGS_TRACE_EVENT("Element.checkVisibility");







v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
decltype(NativeValueTraits<CheckVisibilityOptions>::NativeValue(std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg1_options;
if (info[0]->IsUndefined()) {
  arg1_options = CheckVisibilityOptions::Create();
} else {
  v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "Element";
const char* const property_name = "checkVisibility";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
arg1_options = NativeValueTraits<CheckVisibilityOptions>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
}
auto&& return_value = blink_receiver->checkVisibility(arg1_options);
bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<bool>());
}

void ClosestOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_closest");
BLINK_BINDINGS_TRACE_EVENT("Element.closest");




v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "Element";
const char* const property_name = "closest";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 1)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(1, info.Length()));
return;
}



v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
auto&& arg1_selectors = NativeValueTraits<IDLString>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& return_value = blink_receiver->closest(arg1_selectors, exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void ComputedStyleMapOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_computedStyleMap");
BLINK_BINDINGS_TRACE_EVENT("Element.computedStyleMap");


v8::Isolate* isolate = info.GetIsolate();
v8::Local<v8::Context> current_context = isolate->GetCurrentContext();
ExecutionContext* current_execution_context = ExecutionContext::From(current_context);
// [Measure], [MeasureAs]
UseCounter::Count(current_execution_context, WebFeature::kCSSTypedOMStylePropertyMap);





v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
auto&& return_value = ElementComputedStyleMap::computedStyleMap(*blink_receiver);
bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void GetAnimationsOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_getAnimations");
BLINK_BINDINGS_TRACE_EVENT("Element.getAnimations");







v8::Local<v8::Value> v8_return_value;
v8::Local<v8::Object> v8_receiver = info.This();
v8::Local<v8::Context> receiver_context = v8_receiver->GetCreationContextChecked();
ScriptState* receiver_script_state = ScriptState::From(receiver_context);
ScriptState* script_state = receiver_script_state;
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
decltype(NativeValueTraits<GetAnimationsOptions>::NativeValue(std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg1_options;
if (info[0]->IsUndefined()) {
  arg1_options = GetAnimationsOptions::Create();
} else {
  v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "Element";
const char* const property_name = "getAnimations";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
arg1_options = NativeValueTraits<GetAnimationsOptions>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
}
auto&& return_value = blink_receiver->getAnimations(arg1_options);
if (!ToV8Traits<IDLSequence<Animation>>::ToV8(script_state, return_value).ToLocal(&v8_return_value)) {
  return;
}
bindings::V8SetReturnValue(info, v8_return_value);
}

void GetAttributeOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_getAttribute");
BLINK_BINDINGS_TRACE_EVENT("Element.getAttribute");




v8::Isolate* isolate = info.GetIsolate();
if (UNLIKELY(info.Length() < 1)) {
  const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "Element";
const char* const property_name = "getAttribute";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(1, info.Length()));
return;
}



v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
decltype(NativeValueTraits<IDLString>::NativeValue(std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg1_name;
if (LIKELY(info[0]->IsString())) {
  arg1_name.Init(info[0].As<v8::String>());
} else {
  const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "Element";
const char* const property_name = "getAttribute";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
arg1_name = NativeValueTraits<IDLString>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
}
auto&& return_value = blink_receiver->getAttribute(arg1_name);
bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNullable);
}

void GetAttributeNSOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_getAttributeNS");
BLINK_BINDINGS_TRACE_EVENT("Element.getAttributeNS");




v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "Element";
const char* const property_name = "getAttributeNS";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 2)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(2, info.Length()));
return;
}



v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
auto&& arg1_namespace_uri = NativeValueTraits<IDLNullable<IDLString>>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_local_name = NativeValueTraits<IDLString>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& return_value = blink_receiver->getAttributeNS(arg1_namespace_uri, arg2_local_name);
bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNullable);
}

void GetAttributeNamesOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_getAttributeNames");
BLINK_BINDINGS_TRACE_EVENT("Element.getAttributeNames");







v8::Local<v8::Value> v8_return_value;
v8::Local<v8::Object> v8_receiver = info.This();
v8::Local<v8::Context> receiver_context = v8_receiver->GetCreationContextChecked();
ScriptState* receiver_script_state = ScriptState::From(receiver_context);
ScriptState* script_state = receiver_script_state;
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
auto&& return_value = blink_receiver->getAttributeNames();
if (!ToV8Traits<IDLSequence<IDLString>>::ToV8(script_state, return_value).ToLocal(&v8_return_value)) {
  return;
}
bindings::V8SetReturnValue(info, v8_return_value);
}

void GetAttributeNodeOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_getAttributeNode");
BLINK_BINDINGS_TRACE_EVENT("Element.getAttributeNode");




if (UNLIKELY(info.Length() < 1)) {
  v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "Element";
const char* const property_name = "getAttributeNode";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(1, info.Length()));
return;
}



v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
decltype(NativeValueTraits<IDLString>::NativeValue(std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg1_name;
if (LIKELY(info[0]->IsString())) {
  arg1_name.Init(info[0].As<v8::String>());
} else {
  v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "Element";
const char* const property_name = "getAttributeNode";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
arg1_name = NativeValueTraits<IDLString>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
}
auto&& return_value = blink_receiver->getAttributeNode(arg1_name);
bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void GetAttributeNodeNSOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_getAttributeNodeNS");
BLINK_BINDINGS_TRACE_EVENT("Element.getAttributeNodeNS");




v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "Element";
const char* const property_name = "getAttributeNodeNS";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 2)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(2, info.Length()));
return;
}



v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
auto&& arg1_namespace_uri = NativeValueTraits<IDLNullable<IDLString>>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_local_name = NativeValueTraits<IDLString>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& return_value = blink_receiver->getAttributeNodeNS(arg1_namespace_uri, arg2_local_name);
bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void GetBoundingClientRectOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE(info.GetIsolate(), RuntimeCallStats::CounterId::kElementGetBoundingClientRect);
BLINK_BINDINGS_TRACE_EVENT("Element.getBoundingClientRect");


v8::Isolate* isolate = info.GetIsolate();
v8::Local<v8::Context> current_context = isolate->GetCurrentContext();
ExecutionContext* current_execution_context = ExecutionContext::From(current_context);
// [Measure], [MeasureAs]
UseCounter::Count(current_execution_context, WebFeature::kV8Element_GetBoundingClientRect_Method);





v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
auto&& return_value = blink_receiver->getBoundingClientRect();
bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void GetClientRectsOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_getClientRects");
BLINK_BINDINGS_TRACE_EVENT("Element.getClientRects");


v8::Isolate* isolate = info.GetIsolate();
v8::Local<v8::Context> current_context = isolate->GetCurrentContext();
ExecutionContext* current_execution_context = ExecutionContext::From(current_context);
// [Measure], [MeasureAs]
UseCounter::Count(current_execution_context, WebFeature::kV8Element_GetClientRects_Method);





v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
auto&& return_value = blink_receiver->getClientRects();
bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void GetElementsByClassNameOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_getElementsByClassName");
BLINK_BINDINGS_TRACE_EVENT("Element.getElementsByClassName");




if (UNLIKELY(info.Length() < 1)) {
  v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "Element";
const char* const property_name = "getElementsByClassName";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(1, info.Length()));
return;
}



v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
decltype(NativeValueTraits<IDLString>::NativeValue(std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg1_class_names;
if (LIKELY(info[0]->IsString())) {
  arg1_class_names.Init(info[0].As<v8::String>());
} else {
  v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "Element";
const char* const property_name = "getElementsByClassName";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
arg1_class_names = NativeValueTraits<IDLString>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
}
auto&& return_value = blink_receiver->getElementsByClassName(arg1_class_names);
bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void GetElementsByTagNameOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_getElementsByTagName");
BLINK_BINDINGS_TRACE_EVENT("Element.getElementsByTagName");




if (UNLIKELY(info.Length() < 1)) {
  v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "Element";
const char* const property_name = "getElementsByTagName";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(1, info.Length()));
return;
}



v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
decltype(NativeValueTraits<IDLString>::NativeValue(std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg1_local_name;
if (LIKELY(info[0]->IsString())) {
  arg1_local_name.Init(info[0].As<v8::String>());
} else {
  v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "Element";
const char* const property_name = "getElementsByTagName";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
arg1_local_name = NativeValueTraits<IDLString>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
}
auto&& return_value = blink_receiver->getElementsByTagName(arg1_local_name);
bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void GetElementsByTagNameNSOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_getElementsByTagNameNS");
BLINK_BINDINGS_TRACE_EVENT("Element.getElementsByTagNameNS");




v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "Element";
const char* const property_name = "getElementsByTagNameNS";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 2)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(2, info.Length()));
return;
}



v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
auto&& arg1_namespace_uri = NativeValueTraits<IDLNullable<IDLString>>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_local_name = NativeValueTraits<IDLString>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& return_value = blink_receiver->getElementsByTagNameNS(arg1_namespace_uri, arg2_local_name);
bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void GetInnerHTMLOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_getInnerHTML");
BLINK_BINDINGS_TRACE_EVENT("Element.getInnerHTML");


v8::Isolate* isolate = info.GetIsolate();
v8::Local<v8::Context> current_context = isolate->GetCurrentContext();
ExecutionContext* current_execution_context = ExecutionContext::From(current_context);
// [Measure], [MeasureAs]
UseCounter::Count(current_execution_context, WebFeature::kElementGetInnerHTML);





v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
decltype(NativeValueTraits<GetInnerHTMLOptions>::NativeValue(std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg1_options;
if (info[0]->IsUndefined()) {
  arg1_options = GetInnerHTMLOptions::Create();
} else {
  const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "Element";
const char* const property_name = "getInnerHTML";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
arg1_options = NativeValueTraits<GetInnerHTMLOptions>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
}
auto&& return_value = blink_receiver->getInnerHTML(arg1_options);
bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNonNullable);
}

void HasAttributeOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_hasAttribute");
BLINK_BINDINGS_TRACE_EVENT("Element.hasAttribute");




if (UNLIKELY(info.Length() < 1)) {
  v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "Element";
const char* const property_name = "hasAttribute";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(1, info.Length()));
return;
}



v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
decltype(NativeValueTraits<IDLString>::NativeValue(std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg1_name;
if (LIKELY(info[0]->IsString())) {
  arg1_name.Init(info[0].As<v8::String>());
} else {
  v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "Element";
const char* const property_name = "hasAttribute";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
arg1_name = NativeValueTraits<IDLString>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
}
auto&& return_value = blink_receiver->hasAttribute(arg1_name);
bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<bool>());
}

void HasAttributeNSOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_hasAttributeNS");
BLINK_BINDINGS_TRACE_EVENT("Element.hasAttributeNS");




v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "Element";
const char* const property_name = "hasAttributeNS";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 2)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(2, info.Length()));
return;
}



v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
auto&& arg1_namespace_uri = NativeValueTraits<IDLNullable<IDLString>>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_local_name = NativeValueTraits<IDLString>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& return_value = blink_receiver->hasAttributeNS(arg1_namespace_uri, arg2_local_name);
bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<bool>());
}

void HasAttributesOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_hasAttributes");
BLINK_BINDINGS_TRACE_EVENT("Element.hasAttributes");







v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
auto&& return_value = blink_receiver->hasAttributes();
bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<bool>());
}

void HasPointerCaptureOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_hasPointerCapture");
BLINK_BINDINGS_TRACE_EVENT("Element.hasPointerCapture");




v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "Element";
const char* const property_name = "hasPointerCapture";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 1)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(1, info.Length()));
return;
}



v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
auto&& arg1_pointer_id = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& return_value = blink_receiver->hasPointerCapture(arg1_pointer_id);
bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<bool>());
}

void HidePopUpOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_hidePopUp");
BLINK_BINDINGS_TRACE_EVENT("Element.hidePopUp");


v8::Isolate* isolate = info.GetIsolate();
v8::Local<v8::Context> current_context = isolate->GetCurrentContext();
ExecutionContext* current_execution_context = ExecutionContext::From(current_context);
// [Measure], [MeasureAs]
UseCounter::Count(current_execution_context, WebFeature::kElementHidePopup);





v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "Element";
const char* const property_name = "hidePopUp";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
blink_receiver->hidePopUp(exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}

}

void InsertAdjacentElementOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_insertAdjacentElement");
BLINK_BINDINGS_TRACE_EVENT("Element.insertAdjacentElement");




v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "Element";
const char* const property_name = "insertAdjacentElement";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 2)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(2, info.Length()));
return;
}


// [CEReactions]
CEReactionsScope ce_reactions_scope;


v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
auto&& arg1_where = NativeValueTraits<IDLString>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_element = NativeValueTraits<Element>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& return_value = blink_receiver->insertAdjacentElement(arg1_where, arg2_element, exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void InsertAdjacentHTMLOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_insertAdjacentHTML");
BLINK_BINDINGS_TRACE_EVENT("Element.insertAdjacentHTML");




v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "Element";
const char* const property_name = "insertAdjacentHTML";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 2)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(2, info.Length()));
return;
}


// [CEReactions]
CEReactionsScope ce_reactions_scope;


v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
auto&& arg1_position = NativeValueTraits<IDLString>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
ExecutionContext* execution_context_of_document_tree = bindings::ExecutionContextFromV8Wrappable(blink_receiver);
auto&& arg2_text = NativeValueTraits<IDLStringStringContextTrustedHTML>::ArgumentValue(isolate, 1, info[1], exception_state, execution_context_of_document_tree);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
blink_receiver->insertAdjacentHTML(arg1_position, arg2_text, exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}

}

void InsertAdjacentTextOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_insertAdjacentText");
BLINK_BINDINGS_TRACE_EVENT("Element.insertAdjacentText");




v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "Element";
const char* const property_name = "insertAdjacentText";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 2)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(2, info.Length()));
return;
}



v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
auto&& arg1_where = NativeValueTraits<IDLString>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_data = NativeValueTraits<IDLString>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
blink_receiver->insertAdjacentText(arg1_where, arg2_data, exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}

}

void MatchesOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_matches");
BLINK_BINDINGS_TRACE_EVENT("Element.matches");




v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "Element";
const char* const property_name = "matches";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 1)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(1, info.Length()));
return;
}



v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
auto&& arg1_selectors = NativeValueTraits<IDLString>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& return_value = blink_receiver->matches(arg1_selectors, exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<bool>());
}

void PrependOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_prepend");
BLINK_BINDINGS_TRACE_EVENT("Element.prepend");





v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "Element";
const char* const property_name = "prepend";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);

// [CEReactions]
CEReactionsScope ce_reactions_scope;


v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
auto&& arg1_nodes = bindings::VariadicArgumentsToNativeValues<V8UnionNodeOrStringOrTrustedScript>(isolate, info, 0, exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
ParentNode::prepend(*blink_receiver, arg1_nodes, exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}

}

void QuerySelectorOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_querySelector");
BLINK_BINDINGS_TRACE_EVENT("Element.querySelector");




v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "Element";
const char* const property_name = "querySelector";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 1)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(1, info.Length()));
return;
}



v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
auto&& arg1_selectors = NativeValueTraits<IDLString>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& return_value = ParentNode::querySelector(*blink_receiver, arg1_selectors, exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void QuerySelectorAllOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_querySelectorAll");
BLINK_BINDINGS_TRACE_EVENT("Element.querySelectorAll");




v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "Element";
const char* const property_name = "querySelectorAll";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 1)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(1, info.Length()));
return;
}



v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
auto&& arg1_selectors = NativeValueTraits<IDLString>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& return_value = ParentNode::querySelectorAll(*blink_receiver, arg1_selectors, exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void ReleasePointerCaptureOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_releasePointerCapture");
BLINK_BINDINGS_TRACE_EVENT("Element.releasePointerCapture");




v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "Element";
const char* const property_name = "releasePointerCapture";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 1)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(1, info.Length()));
return;
}



v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
auto&& arg1_pointer_id = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
blink_receiver->releasePointerCapture(arg1_pointer_id, exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}

}

void RemoveOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_remove");
BLINK_BINDINGS_TRACE_EVENT("Element.remove");





v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "Element";
const char* const property_name = "remove";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);

// [CEReactions]
CEReactionsScope ce_reactions_scope;


v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
ChildNode::remove(*blink_receiver, exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}

}

void RemoveAttributeOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_removeAttribute");
BLINK_BINDINGS_TRACE_EVENT("Element.removeAttribute");




v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "Element";
const char* const property_name = "removeAttribute";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 1)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(1, info.Length()));
return;
}


// [CEReactions]
CEReactionsScope ce_reactions_scope;


v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
decltype(NativeValueTraits<IDLString>::NativeValue(std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg1_name;
if (LIKELY(info[0]->IsString())) {
  arg1_name.Init(info[0].As<v8::String>());
} else {
  arg1_name = NativeValueTraits<IDLString>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
}
blink_receiver->removeAttribute(arg1_name);

}

void RemoveAttributeNSOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_removeAttributeNS");
BLINK_BINDINGS_TRACE_EVENT("Element.removeAttributeNS");




v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "Element";
const char* const property_name = "removeAttributeNS";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 2)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(2, info.Length()));
return;
}


// [CEReactions]
CEReactionsScope ce_reactions_scope;


v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
auto&& arg1_namespace_uri = NativeValueTraits<IDLNullable<IDLString>>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_local_name = NativeValueTraits<IDLString>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
blink_receiver->removeAttributeNS(arg1_namespace_uri, arg2_local_name);

}

void RemoveAttributeNodeOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_removeAttributeNode");
BLINK_BINDINGS_TRACE_EVENT("Element.removeAttributeNode");




v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "Element";
const char* const property_name = "removeAttributeNode";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 1)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(1, info.Length()));
return;
}


// [CEReactions]
CEReactionsScope ce_reactions_scope;


v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
auto&& arg1_attr = NativeValueTraits<Attr>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& return_value = blink_receiver->removeAttributeNode(arg1_attr, exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void ReplaceChildrenOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_replaceChildren");
BLINK_BINDINGS_TRACE_EVENT("Element.replaceChildren");





v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "Element";
const char* const property_name = "replaceChildren";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);

// [CEReactions]
CEReactionsScope ce_reactions_scope;


v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
auto&& arg1_nodes = bindings::VariadicArgumentsToNativeValues<V8UnionNodeOrStringOrTrustedScript>(isolate, info, 0, exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
ParentNode::replaceChildren(*blink_receiver, arg1_nodes, exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}

}

void ReplaceWithOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_replaceWith");
BLINK_BINDINGS_TRACE_EVENT("Element.replaceWith");





v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "Element";
const char* const property_name = "replaceWith";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);

// [CEReactions]
CEReactionsScope ce_reactions_scope;


v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
auto&& arg1_nodes = bindings::VariadicArgumentsToNativeValues<V8UnionNodeOrStringOrTrustedScript>(isolate, info, 0, exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
ChildNode::replaceWith(*blink_receiver, arg1_nodes, exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}

}

void RequestFullscreenOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_requestFullscreen");
BLINK_BINDINGS_TRACE_EVENT("Element.requestFullscreen");

// Promise returning function: Convert a TypeError to a reject promise.
v8::Isolate* isolate = info.GetIsolate();
v8::Local<v8::Object> v8_receiver = info.This();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "Element";
const char* const property_name = "requestFullscreen";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
ExceptionToRejectPromiseScope reject_promise_scope(info, exception_state);
if (!V8Element::HasInstance(isolate, v8_receiver)) {
  exception_state.ThrowTypeError("Illegal invocation");
return;
}






v8::Local<v8::Context> receiver_context = v8_receiver->GetCreationContextChecked();
ScriptState* receiver_script_state = ScriptState::From(receiver_context);
ScriptState* script_state = receiver_script_state;
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
decltype(NativeValueTraits<FullscreenOptions>::NativeValue(std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg1_options;
if (info[0]->IsUndefined()) {
  arg1_options = FullscreenOptions::Create();
} else {
  arg1_options = NativeValueTraits<FullscreenOptions>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
}
auto&& return_value = ElementFullscreen::requestFullscreen(script_state, *blink_receiver, arg1_options, exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
bindings::V8SetReturnValue(info, return_value.V8Value());
}

void RequestPointerLockOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_requestPointerLock");
BLINK_BINDINGS_TRACE_EVENT("Element.requestPointerLock");


v8::Isolate* isolate = info.GetIsolate();
v8::Local<v8::Context> current_context = isolate->GetCurrentContext();
ExecutionContext* current_execution_context = ExecutionContext::From(current_context);
// [Measure], [MeasureAs]
UseCounter::Count(current_execution_context, WebFeature::kElementRequestPointerLock);





v8::Local<v8::Value> v8_return_value;
v8::Local<v8::Object> v8_receiver = info.This();
v8::Local<v8::Context> receiver_context = v8_receiver->GetCreationContextChecked();
ScriptState* receiver_script_state = ScriptState::From(receiver_context);
ScriptState* script_state = receiver_script_state;
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
decltype(NativeValueTraits<PointerLockOptions>::NativeValue(std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg1_options;
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "Element";
const char* const property_name = "requestPointerLock";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (info[0]->IsUndefined()) {
  arg1_options = PointerLockOptions::Create();
} else {
  arg1_options = NativeValueTraits<PointerLockOptions>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
}
auto&& return_value = blink_receiver->requestPointerLock(script_state, arg1_options, exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
if (!ToV8Traits<IDLAny>::ToV8(script_state, return_value).ToLocal(&v8_return_value)) {
  return;
}
bindings::V8SetReturnValue(info, v8_return_value);
}

void ScrollOperationOverload1(const v8::FunctionCallbackInfo<v8::Value>& info) {
  





v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
decltype(NativeValueTraits<ScrollToOptions>::NativeValue(std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg1_options;
if (info[0]->IsUndefined()) {
  arg1_options = ScrollToOptions::Create();
} else {
  v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "Element";
const char* const property_name = "scroll";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
arg1_options = NativeValueTraits<ScrollToOptions>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
}
blink_receiver->scrollTo(arg1_options);

}

void ScrollOperationOverload2(const v8::FunctionCallbackInfo<v8::Value>& info) {
  


v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "Element";
const char* const property_name = "scroll";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 2)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(2, info.Length()));
return;
}



v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
auto&& arg1_x = NativeValueTraits<IDLUnrestrictedDouble>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_y = NativeValueTraits<IDLUnrestrictedDouble>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
blink_receiver->scrollTo(arg1_x, arg2_y);

}

void ScrollOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_scroll");
BLINK_BINDINGS_TRACE_EVENT("Element.scroll");

scheduler::CooperativeSchedulingManager::Instance()->Safepoint();

const int arg_count = std::min(info.Length(), 2);
if (arg_count == 2) {
  return ScrollOperationOverload2(info);
}
if (arg_count == 1) {
  return ScrollOperationOverload1(info);
}
return ScrollOperationOverload1(info);
}

void ScrollByOperationOverload1(const v8::FunctionCallbackInfo<v8::Value>& info) {
  





v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
decltype(NativeValueTraits<ScrollToOptions>::NativeValue(std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg1_options;
if (info[0]->IsUndefined()) {
  arg1_options = ScrollToOptions::Create();
} else {
  v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "Element";
const char* const property_name = "scrollBy";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
arg1_options = NativeValueTraits<ScrollToOptions>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
}
blink_receiver->scrollBy(arg1_options);

}

void ScrollByOperationOverload2(const v8::FunctionCallbackInfo<v8::Value>& info) {
  


v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "Element";
const char* const property_name = "scrollBy";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 2)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(2, info.Length()));
return;
}



v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
auto&& arg1_x = NativeValueTraits<IDLUnrestrictedDouble>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_y = NativeValueTraits<IDLUnrestrictedDouble>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
blink_receiver->scrollBy(arg1_x, arg2_y);

}

void ScrollByOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_scrollBy");
BLINK_BINDINGS_TRACE_EVENT("Element.scrollBy");

scheduler::CooperativeSchedulingManager::Instance()->Safepoint();

const int arg_count = std::min(info.Length(), 2);
if (arg_count == 2) {
  return ScrollByOperationOverload2(info);
}
if (arg_count == 1) {
  return ScrollByOperationOverload1(info);
}
return ScrollByOperationOverload1(info);
}

void ScrollIntoViewOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_scrollIntoView");
BLINK_BINDINGS_TRACE_EVENT("Element.scrollIntoView");







v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
decltype(NativeValueTraits<V8UnionBooleanOrScrollIntoViewOptions>::NativeValue(std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg1_arg;
if (info[0]->IsUndefined()) {
  arg1_arg = MakeGarbageCollected<V8UnionBooleanOrScrollIntoViewOptions>(ScrollIntoViewOptions::Create());
} else {
  v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "Element";
const char* const property_name = "scrollIntoView";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
arg1_arg = NativeValueTraits<V8UnionBooleanOrScrollIntoViewOptions>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
}
blink_receiver->scrollIntoView(arg1_arg);

}

void ScrollIntoViewIfNeededOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_scrollIntoViewIfNeeded");
BLINK_BINDINGS_TRACE_EVENT("Element.scrollIntoViewIfNeeded");


v8::Isolate* isolate = info.GetIsolate();
v8::Local<v8::Context> current_context = isolate->GetCurrentContext();
ExecutionContext* current_execution_context = ExecutionContext::From(current_context);
// [Measure], [MeasureAs]
UseCounter::Count(current_execution_context, WebFeature::kElementScrollIntoViewIfNeeded);





do {  // Dummy loop for use of 'break'.
  const int non_undefined_argument_length = bindings::NonUndefinedArgumentLength(info);
v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
if (non_undefined_argument_length <= 0) {
  blink_receiver->scrollIntoViewIfNeeded();
break;
}
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "Element";
const char* const property_name = "scrollIntoViewIfNeeded";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
auto&& arg1_center_if_needed = NativeValueTraits<IDLBoolean>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
blink_receiver->scrollIntoViewIfNeeded(arg1_center_if_needed);
} while (false);

}

void ScrollToOperationOverload1(const v8::FunctionCallbackInfo<v8::Value>& info) {
  





v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
decltype(NativeValueTraits<ScrollToOptions>::NativeValue(std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg1_options;
if (info[0]->IsUndefined()) {
  arg1_options = ScrollToOptions::Create();
} else {
  v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "Element";
const char* const property_name = "scrollTo";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
arg1_options = NativeValueTraits<ScrollToOptions>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
}
blink_receiver->scrollTo(arg1_options);

}

void ScrollToOperationOverload2(const v8::FunctionCallbackInfo<v8::Value>& info) {
  


v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "Element";
const char* const property_name = "scrollTo";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 2)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(2, info.Length()));
return;
}



v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
auto&& arg1_x = NativeValueTraits<IDLUnrestrictedDouble>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_y = NativeValueTraits<IDLUnrestrictedDouble>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
blink_receiver->scrollTo(arg1_x, arg2_y);

}

void ScrollToOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_scrollTo");
BLINK_BINDINGS_TRACE_EVENT("Element.scrollTo");

scheduler::CooperativeSchedulingManager::Instance()->Safepoint();

const int arg_count = std::min(info.Length(), 2);
if (arg_count == 2) {
  return ScrollToOperationOverload2(info);
}
if (arg_count == 1) {
  return ScrollToOperationOverload1(info);
}
return ScrollToOperationOverload1(info);
}

void SetAttributeOperationOverload1(const v8::FunctionCallbackInfo<v8::Value>& info) {
  


v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "Element";
const char* const property_name = "setAttribute";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 2)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(2, info.Length()));
return;
}


// [CEReactions]
CEReactionsScope ce_reactions_scope;


v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
auto&& arg1_name = NativeValueTraits<IDLString>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_value = NativeValueTraits<IDLString>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
blink_receiver->setAttribute(arg1_name, arg2_value, exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}

}

void SetAttributeOperationOverload2(const v8::FunctionCallbackInfo<v8::Value>& info) {
  


v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "Element";
const char* const property_name = "setAttribute";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 2)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(2, info.Length()));
return;
}


// [CEReactions]
CEReactionsScope ce_reactions_scope;


v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
auto&& arg1_name = NativeValueTraits<IDLString>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_value = NativeValueTraits<V8UnionTrustedHTMLOrTrustedScriptOrTrustedScriptURL>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
blink_receiver->setAttribute(arg1_name, arg2_value, exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}

}

void SetAttributeOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_setAttribute");
BLINK_BINDINGS_TRACE_EVENT("Element.setAttribute");

scheduler::CooperativeSchedulingManager::Instance()->Safepoint();

const int arg_count = std::min(info.Length(), 2);
v8::Isolate* isolate = info.GetIsolate();
if (arg_count == 2) {
  if (V8TrustedScriptURL::HasInstance(isolate, info[1])) {
  return SetAttributeOperationOverload2(info);
}
if (V8TrustedScript::HasInstance(isolate, info[1])) {
  return SetAttributeOperationOverload2(info);
}
if (V8TrustedHTML::HasInstance(isolate, info[1])) {
  return SetAttributeOperationOverload2(info);
}
return SetAttributeOperationOverload1(info);
}

const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "Element";
const char* const property_name = "setAttribute";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 2)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(2, info.Length()));
return;
}
exception_state.ThrowTypeError("Overload resolution failed.");
return;
}

void SetAttributeNSOperationOverload1(const v8::FunctionCallbackInfo<v8::Value>& info) {
  


v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "Element";
const char* const property_name = "setAttributeNS";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 3)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(3, info.Length()));
return;
}


// [CEReactions]
CEReactionsScope ce_reactions_scope;


v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
auto&& arg1_namespace_uri = NativeValueTraits<IDLNullable<IDLString>>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_name = NativeValueTraits<IDLString>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg3_value = NativeValueTraits<IDLString>::ArgumentValue(isolate, 2, info[2], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
blink_receiver->setAttributeNS(arg1_namespace_uri, arg2_name, arg3_value, exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}

}

void SetAttributeNSOperationOverload2(const v8::FunctionCallbackInfo<v8::Value>& info) {
  


v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "Element";
const char* const property_name = "setAttributeNS";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 3)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(3, info.Length()));
return;
}


// [CEReactions]
CEReactionsScope ce_reactions_scope;


v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
auto&& arg1_namespace_uri = NativeValueTraits<IDLNullable<IDLString>>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_name = NativeValueTraits<IDLString>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg3_value = NativeValueTraits<V8UnionTrustedHTMLOrTrustedScriptOrTrustedScriptURL>::ArgumentValue(isolate, 2, info[2], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
blink_receiver->setAttributeNS(arg1_namespace_uri, arg2_name, arg3_value, exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}

}

void SetAttributeNSOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_setAttributeNS");
BLINK_BINDINGS_TRACE_EVENT("Element.setAttributeNS");

scheduler::CooperativeSchedulingManager::Instance()->Safepoint();

const int arg_count = std::min(info.Length(), 3);
v8::Isolate* isolate = info.GetIsolate();
if (arg_count == 3) {
  if (V8TrustedScriptURL::HasInstance(isolate, info[2])) {
  return SetAttributeNSOperationOverload2(info);
}
if (V8TrustedScript::HasInstance(isolate, info[2])) {
  return SetAttributeNSOperationOverload2(info);
}
if (V8TrustedHTML::HasInstance(isolate, info[2])) {
  return SetAttributeNSOperationOverload2(info);
}
return SetAttributeNSOperationOverload1(info);
}

const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "Element";
const char* const property_name = "setAttributeNS";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 3)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(3, info.Length()));
return;
}
exception_state.ThrowTypeError("Overload resolution failed.");
return;
}

void SetAttributeNodeOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_setAttributeNode");
BLINK_BINDINGS_TRACE_EVENT("Element.setAttributeNode");




v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "Element";
const char* const property_name = "setAttributeNode";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 1)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(1, info.Length()));
return;
}


// [CEReactions]
CEReactionsScope ce_reactions_scope;


v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
auto&& arg1_attr = NativeValueTraits<Attr>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& return_value = blink_receiver->setAttributeNode(arg1_attr, exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void SetAttributeNodeNSOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_setAttributeNodeNS");
BLINK_BINDINGS_TRACE_EVENT("Element.setAttributeNodeNS");




v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "Element";
const char* const property_name = "setAttributeNodeNS";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 1)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(1, info.Length()));
return;
}


// [CEReactions]
CEReactionsScope ce_reactions_scope;


v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
auto&& arg1_attr = NativeValueTraits<Attr>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& return_value = blink_receiver->setAttributeNodeNS(arg1_attr, exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void SetHTMLOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_setHTML");
BLINK_BINDINGS_TRACE_EVENT("Element.setHTML");


v8::Isolate* isolate = info.GetIsolate();
v8::Local<v8::Context> current_context = isolate->GetCurrentContext();
ExecutionContext* current_execution_context = ExecutionContext::From(current_context);
// [Measure], [MeasureAs]
UseCounter::Count(current_execution_context, WebFeature::kSanitizerAPIElementSetSanitized);


const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "Element";
const char* const property_name = "setHTML";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 1)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(1, info.Length()));
return;
}


// [CEReactions]
CEReactionsScope ce_reactions_scope;


v8::Local<v8::Object> v8_receiver = info.This();
v8::Local<v8::Context> receiver_context = v8_receiver->GetCreationContextChecked();
ScriptState* receiver_script_state = ScriptState::From(receiver_context);
ScriptState* script_state = receiver_script_state;
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
auto&& arg1_markup = NativeValueTraits<IDLString>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
decltype(NativeValueTraits<ElementSetHTMLOptions>::NativeValue(std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg2_options;
if (info[1]->IsUndefined()) {
  arg2_options = ElementSetHTMLOptions::Create();
} else {
  arg2_options = NativeValueTraits<ElementSetHTMLOptions>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
}
ElementSanitizer::setHTML(script_state, *blink_receiver, arg1_markup, arg2_options, exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}

}

void SetPointerCaptureOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_setPointerCapture");
BLINK_BINDINGS_TRACE_EVENT("Element.setPointerCapture");




v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "Element";
const char* const property_name = "setPointerCapture";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 1)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(1, info.Length()));
return;
}



v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
auto&& arg1_pointer_id = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
blink_receiver->setPointerCapture(arg1_pointer_id, exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}

}

void ShowPopUpOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_showPopUp");
BLINK_BINDINGS_TRACE_EVENT("Element.showPopUp");


v8::Isolate* isolate = info.GetIsolate();
v8::Local<v8::Context> current_context = isolate->GetCurrentContext();
ExecutionContext* current_execution_context = ExecutionContext::From(current_context);
// [Measure], [MeasureAs]
UseCounter::Count(current_execution_context, WebFeature::kElementShowPopup);





v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "Element";
const char* const property_name = "showPopUp";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
blink_receiver->showPopUp(exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}

}

void ToggleAttributeOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_toggleAttribute");
BLINK_BINDINGS_TRACE_EVENT("Element.toggleAttribute");




v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "Element";
const char* const property_name = "toggleAttribute";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 1)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(1, info.Length()));
return;
}


// [CEReactions]
CEReactionsScope ce_reactions_scope;


bool return_value;
do {  // Dummy loop for use of 'break'.
  const int non_undefined_argument_length = bindings::NonUndefinedArgumentLength(info);
v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
auto&& arg1_qualified_name = NativeValueTraits<IDLString>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
if (non_undefined_argument_length <= 1) {
  return_value = blink_receiver->toggleAttribute(arg1_qualified_name, exception_state);
break;
}
auto&& arg2_force = NativeValueTraits<IDLBoolean>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
return_value = blink_receiver->toggleAttribute(arg1_qualified_name, arg2_force, exception_state);
} while (false);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<bool>());
}

void WebkitMatchesSelectorOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_webkitMatchesSelector");
BLINK_BINDINGS_TRACE_EVENT("Element.webkitMatchesSelector");


v8::Isolate* isolate = info.GetIsolate();
v8::Local<v8::Context> current_context = isolate->GetCurrentContext();
ExecutionContext* current_execution_context = ExecutionContext::From(current_context);
// [Measure], [MeasureAs]
UseCounter::Count(current_execution_context, WebFeature::kElementPrefixedMatchesSelector);


const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "Element";
const char* const property_name = "webkitMatchesSelector";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 1)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(1, info.Length()));
return;
}



v8::Local<v8::Object> v8_receiver = info.This();
Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
auto&& arg1_selectors = NativeValueTraits<IDLString>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& return_value = blink_receiver->matches(arg1_selectors, exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<bool>());
}

void WebkitRequestFullScreenOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_webkitRequestFullScreen");
BLINK_BINDINGS_TRACE_EVENT("Element.webkitRequestFullScreen");


v8::Isolate* isolate = info.GetIsolate();
v8::Local<v8::Context> current_context = isolate->GetCurrentContext();
ExecutionContext* current_execution_context = ExecutionContext::From(current_context);
// [Measure], [MeasureAs]
UseCounter::Count(current_execution_context, WebFeature::kPrefixedElementRequestFullScreen);
v8::Local<v8::Object> v8_receiver = info.This();
v8::Local<v8::Context> receiver_context = v8_receiver->GetCreationContextChecked();
ScriptState* receiver_script_state = ScriptState::From(receiver_context);
ScriptState* script_state = receiver_script_state;
V8PerContextData* per_context_data = script_state->PerContextData();
// [LogActivity], [LogAllWorlds]
if (per_context_data && per_context_data->ActivityLogger()) { per_context_data->ActivityLogger()->LogMethod("Element.webkitRequestFullScreen", info); }





Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
decltype(NativeValueTraits<FullscreenOptions>::NativeValue(std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg1_options;
if (info[0]->IsUndefined()) {
  arg1_options = FullscreenOptions::Create();
} else {
  const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "Element";
const char* const property_name = "webkitRequestFullScreen";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
arg1_options = NativeValueTraits<FullscreenOptions>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
}
ElementFullscreen::webkitRequestFullscreen(*blink_receiver, arg1_options);

}

void WebkitRequestFullscreenOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_webkitRequestFullscreen");
BLINK_BINDINGS_TRACE_EVENT("Element.webkitRequestFullscreen");


v8::Isolate* isolate = info.GetIsolate();
v8::Local<v8::Context> current_context = isolate->GetCurrentContext();
ExecutionContext* current_execution_context = ExecutionContext::From(current_context);
// [Measure], [MeasureAs]
UseCounter::Count(current_execution_context, WebFeature::kPrefixedElementRequestFullscreen);
v8::Local<v8::Object> v8_receiver = info.This();
v8::Local<v8::Context> receiver_context = v8_receiver->GetCreationContextChecked();
ScriptState* receiver_script_state = ScriptState::From(receiver_context);
ScriptState* script_state = receiver_script_state;
V8PerContextData* per_context_data = script_state->PerContextData();
// [LogActivity], [LogAllWorlds]
if (per_context_data && per_context_data->ActivityLogger()) { per_context_data->ActivityLogger()->LogMethod("Element.webkitRequestFullscreen", info); }





Element* blink_receiver = V8Element::ToWrappableUnsafe(v8_receiver);
decltype(NativeValueTraits<FullscreenOptions>::NativeValue(std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg1_options;
if (info[0]->IsUndefined()) {
  arg1_options = FullscreenOptions::Create();
} else {
  const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "Element";
const char* const property_name = "webkitRequestFullscreen";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
arg1_options = NativeValueTraits<FullscreenOptions>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
}
ElementFullscreen::webkitRequestFullscreen(*blink_receiver, arg1_options);

}


}  // namespace v8_element

using namespace v8_element;

}  // namespace 

void V8Element::Impl::InstallInterfaceTemplate(v8::Isolate* isolate, const DOMWrapperWorld& world, v8::Local<v8::Template> interface_template) {
  const WrapperTypeInfo* const wrapper_type_info = V8Element::GetWrapperTypeInfo();
v8::Local<v8::FunctionTemplate> interface_function_template = interface_template.As<v8::FunctionTemplate>();
v8::Local<v8::ObjectTemplate> instance_object_template = interface_function_template->InstanceTemplate();
v8::Local<v8::ObjectTemplate> prototype_object_template = interface_function_template->PrototypeTemplate();
v8::Local<v8::FunctionTemplate> parent_interface_template = wrapper_type_info->parent_class->GetV8ClassTemplate(isolate, world).As<v8::FunctionTemplate>();
bindings::SetupIDLInterfaceTemplate(isolate, wrapper_type_info, instance_object_template, prototype_object_template, interface_function_template, parent_interface_template);








v8::Local<v8::Template> instance_template = instance_object_template;
v8::Local<v8::Template> prototype_template = prototype_object_template;
InstallUnconditionalProperties(isolate, world, instance_template, prototype_template, interface_template);
InstallContextIndependentProperties(isolate, world, instance_template, prototype_template, interface_template);
}

void V8Element::Impl::InstallUnconditionalProperties(v8::Isolate* isolate, const DOMWrapperWorld& world, v8::Local<v8::Template> instance_template, v8::Local<v8::Template> prototype_template, v8::Local<v8::Template> interface_template) {
  using bindings::IDLMemberInstaller;

v8::Local<v8::FunctionTemplate> interface_function_template = interface_template.As<v8::FunctionTemplate>();
v8::Local<v8::Signature> signature = v8::Signature::New(isolate, interface_function_template);
{
  static const IDLMemberInstaller::AttributeConfig kAttributeTable[] = {
{"namespaceURI", NamespaceURIAttributeGetCallback, nullptr, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone)},
{"prefix", PrefixAttributeGetCallback, nullptr, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone)},
{"localName", LocalNameAttributeGetCallback, nullptr, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone)},
{"tagName", TagNameAttributeGetCallback, nullptr, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone)},
{"id", IdAttributeGetCallback, IdAttributeSetCallback, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone)},
{"className", ClassNameAttributeGetCallback, ClassNameAttributeSetCallback, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone)},
{"classList", ClassListAttributeGetCallbackForMainWorld, ClassListAttributeSetCallbackForMainWorld, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kMainWorld), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone)},
{"classList", ClassListAttributeGetCallbackForNonMainWorlds, ClassListAttributeSetCallbackForNonMainWorlds, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kNonMainWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone)},
{"slot", SlotAttributeGetCallback, SlotAttributeSetCallback, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone)},
{"attributes", AttributesAttributeGetCallbackForMainWorld, nullptr, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kMainWorld), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone)},
{"attributes", AttributesAttributeGetCallbackForNonMainWorlds, nullptr, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kNonMainWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone)},
{"shadowRoot", ShadowRootAttributeGetCallbackForMainWorld, nullptr, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kMainWorld), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone)},
{"shadowRoot", ShadowRootAttributeGetCallbackForNonMainWorlds, nullptr, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kNonMainWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone)},
{"part", PartAttributeGetCallbackForMainWorld, PartAttributeSetCallbackForMainWorld, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kMainWorld), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone)},
{"part", PartAttributeGetCallbackForNonMainWorlds, PartAttributeSetCallbackForNonMainWorlds, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kNonMainWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone)},
{"assignedSlot", AssignedSlotAttributeGetCallback, nullptr, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone)},
{"innerHTML", InnerHTMLAttributeGetCallback, InnerHTMLAttributeSetCallback, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone)},
{"outerHTML", OuterHTMLAttributeGetCallback, OuterHTMLAttributeSetCallback, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone)},
{"scrollTop", ScrollTopAttributeGetCallback, ScrollTopAttributeSetCallback, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone)},
{"scrollLeft", ScrollLeftAttributeGetCallback, ScrollLeftAttributeSetCallback, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone)},
{"scrollWidth", ScrollWidthAttributeGetCallback, nullptr, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone)},
{"scrollHeight", ScrollHeightAttributeGetCallback, nullptr, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone)},
{"clientTop", ClientTopAttributeGetCallback, nullptr, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone)},
{"clientLeft", ClientLeftAttributeGetCallback, nullptr, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone)},
{"clientWidth", ClientWidthAttributeGetCallback, nullptr, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone)},
{"clientHeight", ClientHeightAttributeGetCallback, nullptr, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone)},
{"attributeStyleMap", AttributeStyleMapAttributeGetCallback, nullptr, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone)},
{"onbeforecopy", OnbeforecopyAttributeGetCallback, OnbeforecopyAttributeSetCallback, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone)},
{"onbeforecut", OnbeforecutAttributeGetCallback, OnbeforecutAttributeSetCallback, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone)},
{"onbeforepaste", OnbeforepasteAttributeGetCallback, OnbeforepasteAttributeSetCallback, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone)},
{"onsearch", OnsearchAttributeGetCallback, OnsearchAttributeSetCallback, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone)},
{"elementTiming", ElementTimingAttributeGetCallback, ElementTimingAttributeSetCallback, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone)},
{"onfullscreenchange", OnfullscreenchangeAttributeGetCallback, OnfullscreenchangeAttributeSetCallback, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone)},
{"onfullscreenerror", OnfullscreenerrorAttributeGetCallback, OnfullscreenerrorAttributeSetCallback, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone)},
{"onwebkitfullscreenchange", OnwebkitfullscreenchangeAttributeGetCallback, OnwebkitfullscreenchangeAttributeSetCallback, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone)},
{"onwebkitfullscreenerror", OnwebkitfullscreenerrorAttributeGetCallback, OnwebkitfullscreenerrorAttributeSetCallback, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone)},
{"role", RoleAttributeGetCallback, RoleAttributeSetCallback, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone)},
{"ariaAtomic", AriaAtomicAttributeGetCallback, AriaAtomicAttributeSetCallback, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone)},
{"ariaAutoComplete", AriaAutoCompleteAttributeGetCallback, AriaAutoCompleteAttributeSetCallback, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone)},
{"ariaBusy", AriaBusyAttributeGetCallback, AriaBusyAttributeSetCallback, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone)},
{"ariaChecked", AriaCheckedAttributeGetCallback, AriaCheckedAttributeSetCallback, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone)},
{"ariaColCount", AriaColCountAttributeGetCallback, AriaColCountAttributeSetCallback, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone)},
{"ariaColIndex", AriaColIndexAttributeGetCallback, AriaColIndexAttributeSetCallback, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone)},
{"ariaColSpan", AriaColSpanAttributeGetCallback, AriaColSpanAttributeSetCallback, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone)},
{"ariaCurrent", AriaCurrentAttributeGetCallback, AriaCurrentAttributeSetCallback, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone)},
{"ariaDescription", AriaDescriptionAttributeGetCallback, AriaDescriptionAttributeSetCallback, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone)},
{"ariaDisabled", AriaDisabledAttributeGetCallback, AriaDisabledAttributeSetCallback, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone)},
{"ariaExpanded", AriaExpandedAttributeGetCallback, AriaExpandedAttributeSetCallback, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone)},
{"ariaHasPopup", AriaHasPopupAttributeGetCallback, AriaHasPopupAttributeSetCallback, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone)},
{"ariaHidden", AriaHiddenAttributeGetCallback, AriaHiddenAttributeSetCallback, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone)},
{"ariaInvalid", AriaInvalidAttributeGetCallback, AriaInvalidAttributeSetCallback, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone)},
{"ariaKeyShortcuts", AriaKeyShortcutsAttributeGetCallback, AriaKeyShortcutsAttributeSetCallback, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone)},
{"ariaLabel", AriaLabelAttributeGetCallback, AriaLabelAttributeSetCallback, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone)},
{"ariaLevel", AriaLevelAttributeGetCallback, AriaLevelAttributeSetCallback, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone)},
{"ariaLive", AriaLiveAttributeGetCallback, AriaLiveAttributeSetCallback, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone)},
{"ariaModal", AriaModalAttributeGetCallback, AriaModalAttributeSetCallback, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone)},
{"ariaMultiLine", AriaMultiLineAttributeGetCallback, AriaMultiLineAttributeSetCallback, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone)},
{"ariaMultiSelectable", AriaMultiSelectableAttributeGetCallback, AriaMultiSelectableAttributeSetCallback, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone)},
{"ariaOrientation", AriaOrientationAttributeGetCallback, AriaOrientationAttributeSetCallback, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone)},
{"ariaPlaceholder", AriaPlaceholderAttributeGetCallback, AriaPlaceholderAttributeSetCallback, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone)},
{"ariaPosInSet", AriaPosInSetAttributeGetCallback, AriaPosInSetAttributeSetCallback, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone)},
{"ariaPressed", AriaPressedAttributeGetCallback, AriaPressedAttributeSetCallback, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone)},
{"ariaReadOnly", AriaReadOnlyAttributeGetCallback, AriaReadOnlyAttributeSetCallback, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone)},
{"ariaRelevant", AriaRelevantAttributeGetCallback, AriaRelevantAttributeSetCallback, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone)},
{"ariaRequired", AriaRequiredAttributeGetCallback, AriaRequiredAttributeSetCallback, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone)},
{"ariaRoleDescription", AriaRoleDescriptionAttributeGetCallback, AriaRoleDescriptionAttributeSetCallback, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone)},
{"ariaRowCount", AriaRowCountAttributeGetCallback, AriaRowCountAttributeSetCallback, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone)},
{"ariaRowIndex", AriaRowIndexAttributeGetCallback, AriaRowIndexAttributeSetCallback, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone)},
{"ariaRowSpan", AriaRowSpanAttributeGetCallback, AriaRowSpanAttributeSetCallback, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone)},
{"ariaSelected", AriaSelectedAttributeGetCallback, AriaSelectedAttributeSetCallback, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone)},
{"ariaSetSize", AriaSetSizeAttributeGetCallback, AriaSetSizeAttributeSetCallback, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone)},
{"ariaSort", AriaSortAttributeGetCallback, AriaSortAttributeSetCallback, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone)},
{"ariaValueMax", AriaValueMaxAttributeGetCallback, AriaValueMaxAttributeSetCallback, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone)},
{"ariaValueMin", AriaValueMinAttributeGetCallback, AriaValueMinAttributeSetCallback, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone)},
{"ariaValueNow", AriaValueNowAttributeGetCallback, AriaValueNowAttributeSetCallback, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone)},
{"ariaValueText", AriaValueTextAttributeGetCallback, AriaValueTextAttributeSetCallback, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone)},
{"children", ChildrenAttributeGetCallbackForMainWorld, nullptr, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kMainWorld), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone)},
{"children", ChildrenAttributeGetCallbackForNonMainWorlds, nullptr, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kNonMainWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone)},
{"firstElementChild", FirstElementChildAttributeGetCallbackForMainWorld, nullptr, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kMainWorld), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone)},
{"firstElementChild", FirstElementChildAttributeGetCallbackForNonMainWorlds, nullptr, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kNonMainWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone)},
{"lastElementChild", LastElementChildAttributeGetCallbackForMainWorld, nullptr, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kMainWorld), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone)},
{"lastElementChild", LastElementChildAttributeGetCallbackForNonMainWorlds, nullptr, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kNonMainWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone)},
{"childElementCount", ChildElementCountAttributeGetCallback, nullptr, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone)},
{"previousElementSibling", PreviousElementSiblingAttributeGetCallbackForMainWorld, nullptr, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kMainWorld), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone)},
{"previousElementSibling", PreviousElementSiblingAttributeGetCallbackForNonMainWorlds, nullptr, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kNonMainWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone)},
{"nextElementSibling", NextElementSiblingAttributeGetCallbackForMainWorld, nullptr, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kMainWorld), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone)},
{"nextElementSibling", NextElementSiblingAttributeGetCallbackForNonMainWorlds, nullptr, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kNonMainWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone)},
};
IDLMemberInstaller::InstallAttributes(isolate, world, instance_template, prototype_template, interface_template, signature, kAttributeTable);
}





{
  static const IDLMemberInstaller::OperationConfig kOperationTable[] = {
{"after", AfterOperationCallback, 0, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, 
{"animate", AnimateOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, 
{"append", AppendOperationCallback, 0, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, 
{"attachShadow", AttachShadowOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, 
{"before", BeforeOperationCallback, 0, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, 
{"closest", ClosestOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, 
{"computedStyleMap", ComputedStyleMapOperationCallback, 0, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, 
{"getAttribute", GetAttributeOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect)}, 
{"getAttributeNS", GetAttributeNSOperationCallback, 2, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect)}, 
{"getAttributeNames", GetAttributeNamesOperationCallback, 0, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect)}, 
{"getAttributeNode", GetAttributeNodeOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, 
{"getAttributeNodeNS", GetAttributeNodeNSOperationCallback, 2, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, 
{"getBoundingClientRect", GetBoundingClientRectOperationCallback, 0, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect)}, 
{"getClientRects", GetClientRectsOperationCallback, 0, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, 
{"getElementsByClassName", GetElementsByClassNameOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect)}, 
{"getElementsByTagName", GetElementsByTagNameOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect)}, 
{"getElementsByTagNameNS", GetElementsByTagNameNSOperationCallback, 2, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect)}, 
{"getInnerHTML", GetInnerHTMLOperationCallback, 0, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect)}, 
{"hasAttribute", HasAttributeOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect)}, 
{"hasAttributeNS", HasAttributeNSOperationCallback, 2, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect)}, 
{"hasAttributes", HasAttributesOperationCallback, 0, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect)}, 
{"hasPointerCapture", HasPointerCaptureOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, 
{"insertAdjacentElement", InsertAdjacentElementOperationCallback, 2, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, 
{"insertAdjacentHTML", InsertAdjacentHTMLOperationCallback, 2, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, 
{"insertAdjacentText", InsertAdjacentTextOperationCallback, 2, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, 
{"matches", MatchesOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, 
{"prepend", PrependOperationCallback, 0, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, 
{"querySelector", QuerySelectorOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect)}, 
{"querySelectorAll", QuerySelectorAllOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect)}, 
{"releasePointerCapture", ReleasePointerCaptureOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, 
{"remove", RemoveOperationCallback, 0, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, 
{"removeAttribute", RemoveAttributeOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, 
{"removeAttributeNS", RemoveAttributeNSOperationCallback, 2, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, 
{"removeAttributeNode", RemoveAttributeNodeOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, 
{"replaceChildren", ReplaceChildrenOperationCallback, 0, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, 
{"replaceWith", ReplaceWithOperationCallback, 0, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, 
{"requestFullscreen", RequestFullscreenOperationCallback, 0, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kDoNotCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, 
{"requestPointerLock", RequestPointerLockOperationCallback, 0, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, 
{"scroll", ScrollOperationCallback, 0, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, 
{"scrollBy", ScrollByOperationCallback, 0, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, 
{"scrollIntoView", ScrollIntoViewOperationCallback, 0, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, 
{"scrollIntoViewIfNeeded", ScrollIntoViewIfNeededOperationCallback, 0, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, 
{"scrollTo", ScrollToOperationCallback, 0, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, 
{"setAttribute", SetAttributeOperationCallback, 2, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, 
{"setAttributeNS", SetAttributeNSOperationCallback, 3, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, 
{"setAttributeNode", SetAttributeNodeOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, 
{"setAttributeNodeNS", SetAttributeNodeNSOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, 
{"setPointerCapture", SetPointerCaptureOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, 
{"toggleAttribute", ToggleAttributeOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, 
{"webkitMatchesSelector", WebkitMatchesSelectorOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, 
{"webkitRequestFullScreen", WebkitRequestFullScreenOperationCallback, 0, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, 
{"webkitRequestFullscreen", WebkitRequestFullscreenOperationCallback, 0, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, 
};
IDLMemberInstaller::InstallOperations(isolate, world, instance_template, prototype_template, interface_template, signature, kOperationTable);
}



}

void V8Element::Impl::InstallContextIndependentProperties(v8::Isolate* isolate, const DOMWrapperWorld& world, v8::Local<v8::Template> instance_template, v8::Local<v8::Template> prototype_template, v8::Local<v8::Template> interface_template) {
  using bindings::IDLMemberInstaller;

if (RuntimeEnabledFeatures::HTMLPopupAttributeEnabled()) {
  static const IDLMemberInstaller::AttributeConfig kAttributeTable[] = {
{"popUp", PopUpAttributeGetCallback, PopUpAttributeSetCallback, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone)},
{"defaultOpen", DefaultOpenAttributeGetCallback, DefaultOpenAttributeSetCallback, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone)},
{"popUpToggleTarget", PopUpToggleTargetAttributeGetCallback, PopUpToggleTargetAttributeSetCallback, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone)},
{"popUpHideTarget", PopUpHideTargetAttributeGetCallback, PopUpHideTargetAttributeSetCallback, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone)},
{"popUpShowTarget", PopUpShowTargetAttributeGetCallback, PopUpShowTargetAttributeSetCallback, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone)},
};
v8::Local<v8::FunctionTemplate> interface_function_template = interface_template.As<v8::FunctionTemplate>();
v8::Local<v8::Signature> signature = v8::Signature::New(isolate, interface_function_template);
IDLMemberInstaller::InstallAttributes(isolate, world, instance_template, prototype_template, interface_template, signature, kAttributeTable);
}
if (RuntimeEnabledFeatures::ComputedAccessibilityInfoEnabled()) {
  static const IDLMemberInstaller::AttributeConfig kAttributeTable[] = {
{"computedRole", ComputedRoleAttributeGetCallback, nullptr, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone)},
{"computedName", ComputedNameAttributeGetCallback, nullptr, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone)},
};
v8::Local<v8::FunctionTemplate> interface_function_template = interface_template.As<v8::FunctionTemplate>();
v8::Local<v8::Signature> signature = v8::Signature::New(isolate, interface_function_template);
IDLMemberInstaller::InstallAttributes(isolate, world, instance_template, prototype_template, interface_template, signature, kAttributeTable);
}
if (RuntimeEnabledFeatures::AccessibilityObjectModelEnabled()) {
  static const IDLMemberInstaller::AttributeConfig kAttributeTable[] = {
{"accessibleNode", AccessibleNodeAttributeGetCallback, nullptr, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone)},
};
v8::Local<v8::FunctionTemplate> interface_function_template = interface_template.As<v8::FunctionTemplate>();
v8::Local<v8::Signature> signature = v8::Signature::New(isolate, interface_function_template);
IDLMemberInstaller::InstallAttributes(isolate, world, instance_template, prototype_template, interface_template, signature, kAttributeTable);
}
if (RuntimeEnabledFeatures::AccessibilityAriaVirtualContentEnabled()) {
  static const IDLMemberInstaller::AttributeConfig kAttributeTable[] = {
{"ariaVirtualContent", AriaVirtualContentAttributeGetCallback, AriaVirtualContentAttributeSetCallback, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone)},
};
v8::Local<v8::FunctionTemplate> interface_function_template = interface_template.As<v8::FunctionTemplate>();
v8::Local<v8::Signature> signature = v8::Signature::New(isolate, interface_function_template);
IDLMemberInstaller::InstallAttributes(isolate, world, instance_template, prototype_template, interface_template, signature, kAttributeTable);
}
if (RuntimeEnabledFeatures::AOMAriaRelationshipPropertiesEnabled()) {
  static const IDLMemberInstaller::AttributeConfig kAttributeTable[] = {
{"ariaActiveDescendantElement", AriaActiveDescendantElementAttributeGetCallback, AriaActiveDescendantElementAttributeSetCallback, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone)},
{"ariaControlsElements", AriaControlsElementsAttributeGetCallback, AriaControlsElementsAttributeSetCallback, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone)},
{"ariaDescribedByElements", AriaDescribedByElementsAttributeGetCallback, AriaDescribedByElementsAttributeSetCallback, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone)},
{"ariaDetailsElements", AriaDetailsElementsAttributeGetCallback, AriaDetailsElementsAttributeSetCallback, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone)},
{"ariaErrorMessageElement", AriaErrorMessageElementAttributeGetCallback, AriaErrorMessageElementAttributeSetCallback, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone)},
{"ariaFlowToElements", AriaFlowToElementsAttributeGetCallback, AriaFlowToElementsAttributeSetCallback, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone)},
{"ariaLabelledByElements", AriaLabelledByElementsAttributeGetCallback, AriaLabelledByElementsAttributeSetCallback, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone)},
{"ariaOwnsElements", AriaOwnsElementsAttributeGetCallback, AriaOwnsElementsAttributeSetCallback, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone)},
};
v8::Local<v8::FunctionTemplate> interface_function_template = interface_template.As<v8::FunctionTemplate>();
v8::Local<v8::Signature> signature = v8::Signature::New(isolate, interface_function_template);
IDLMemberInstaller::InstallAttributes(isolate, world, instance_template, prototype_template, interface_template, signature, kAttributeTable);
}




if (RuntimeEnabledFeatures::checkVisibilityEnabled()) {
  static const IDLMemberInstaller::OperationConfig kOperationTable[] = {
{"checkVisibility", CheckVisibilityOperationCallback, 0, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, 
};
v8::Local<v8::FunctionTemplate> interface_function_template = interface_template.As<v8::FunctionTemplate>();
v8::Local<v8::Signature> signature = v8::Signature::New(isolate, interface_function_template);
IDLMemberInstaller::InstallOperations(isolate, world, instance_template, prototype_template, interface_template, signature, kOperationTable);
}
if (RuntimeEnabledFeatures::WebAnimationsAPIEnabled()) {
  static const IDLMemberInstaller::OperationConfig kOperationTable[] = {
{"getAnimations", GetAnimationsOperationCallback, 0, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, 
};
v8::Local<v8::FunctionTemplate> interface_function_template = interface_template.As<v8::FunctionTemplate>();
v8::Local<v8::Signature> signature = v8::Signature::New(isolate, interface_function_template);
IDLMemberInstaller::InstallOperations(isolate, world, instance_template, prototype_template, interface_template, signature, kOperationTable);
}
if (RuntimeEnabledFeatures::HTMLPopupAttributeEnabled()) {
  static const IDLMemberInstaller::OperationConfig kOperationTable[] = {
{"hidePopUp", HidePopUpOperationCallback, 0, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, 
{"showPopUp", ShowPopUpOperationCallback, 0, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, 
};
v8::Local<v8::FunctionTemplate> interface_function_template = interface_template.As<v8::FunctionTemplate>();
v8::Local<v8::Signature> signature = v8::Signature::New(isolate, interface_function_template);
IDLMemberInstaller::InstallOperations(isolate, world, instance_template, prototype_template, interface_template, signature, kOperationTable);
}


}

void V8Element::Impl::InstallContextDependentProperties(v8::Local<v8::Context> context, const DOMWrapperWorld& world, v8::Local<v8::Object> instance_object, v8::Local<v8::Object> prototype_object, v8::Local<v8::Object> interface_object, v8::Local<v8::Template> interface_template, FeatureSelector feature_selector) {
  using bindings::IDLMemberInstaller;

if (feature_selector.IsAll()) {
  // [Unscopable]
// 3.7.3. Interface prototype object
// https://webidl.spec.whatwg.org/#interface-prototype-object
// step 10. If interface has any member declared with the [Unscopable]
//   extended attribute, then:
static constexpr const char* kUnscopablePropertyNames[] = {
"slot", 
"popUp", 
"prepend", 
"append", 
"replaceChildren", 
"before", 
"after", 
"replaceWith", 
"remove", 
};
v8::Isolate* isolate = context->GetIsolate();
bindings::InstallUnscopablePropertyNames(
    isolate, context, prototype_object, kUnscopablePropertyNames);

}





ScriptState* script_state = ScriptState::From(context);
ExecutionContext* execution_context = ExecutionContext::From(script_state);
const bool is_in_secure_context = execution_context->IsSecureContext();
if (is_in_secure_context && (feature_selector.IsAll() && RuntimeEnabledFeatures::SanitizerAPIv0Enabled())) {
  static const IDLMemberInstaller::OperationConfig kOperationTable[] = {
{"setHTML", SetHTMLOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, 
};
v8::Isolate* isolate = context->GetIsolate();
v8::Local<v8::FunctionTemplate> interface_function_template = interface_template.As<v8::FunctionTemplate>();
v8::Local<v8::Signature> signature = v8::Signature::New(isolate, interface_function_template);
IDLMemberInstaller::InstallOperations(isolate, world, instance_object, prototype_object, interface_object, signature, kOperationTable);
}


}


}  // namespace blink
